<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏦 👩🏿‍🤝‍👨🏻 🍈 Redux vs MobX毫不困惑 🎛️ 🐪 🙆🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="近年来，我经常使用Redux，但是最近我一直在使用MobX作为状态管理的替代方法。 Redux的替代品似乎自然变成了一片混乱。人们不确定要选择哪种解决方案。问题不一定是Redux vs MobX。只要有其他选择，人们就会好奇如何最好地解决他们的问题。我写这些行是为了消除围绕Redux和MobX状态管...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Redux vs MobX毫不困惑</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489854/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/dt/7e/na/dt7enamgfkxspaajcdst26auxj8.jpeg" alt="图片"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
近年来，我经常使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是最近我一直在使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MobX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为状态管理的替代方法。 Redux的替代品似乎自然变成了一片混乱。人们不确定要选择哪种解决方案。问题不一定是Redux vs MobX。只要有其他选择，人们就会好奇如何最好地解决他们的问题。我写这些行是为了消除围绕Redux和MobX状态管理解决方案的困惑。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这篇文章将是关于什么的？</font><font style="vertical-align: inherit;">首先，我想简单地回到状态管理库解决的问题。</font><font style="vertical-align: inherit;">最后，如果仅在React或其他表示层库或SPA环境中使用this.setState（）和this.state，一切都会很好。</font><font style="vertical-align: inherit;">其次，我将继续为您提供两种解决方案的概述，以显示一致性和差异性。</font><font style="vertical-align: inherit;">最后但并非最不重要的一点是，如果您已经拥有可与MobX或Redux一起使用的应用程序，那么我想告诉您有关从一个状态库重构到另一个状态库的信息。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内容：</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们要解决什么问题？</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">REDUX和MOBX有什么区别？</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反应状态学习曲线</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于这个话题的最新想法</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更多资源</font></font></a></li>
</ol><br>
<a name="WhatProblem"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们要解决什么问题？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个人都希望在应用程序中具有状态管理。</font><font style="vertical-align: inherit;">但是，这为我们解决了什么问题？</font><font style="vertical-align: inherit;">大多数人从一个小型应用程序开始，并且已经实现了状态管理库。</font><font style="vertical-align: inherit;">每个人都在谈论它，对不对？</font><font style="vertical-align: inherit;">Redux！</font><font style="vertical-align: inherit;">MobX！</font><font style="vertical-align: inherit;">但是大多数应用程序从一开始就不需要雄心勃勃的状态管理。</font><font style="vertical-align: inherit;">这甚至更加危险，因为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大多数人将永远不会遇到诸如Redux或MobX之类的库的问题</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现状目前正在构建带有组件的前端应用程序。</font><font style="vertical-align: inherit;">组件具有内部状态。</font><font style="vertical-align: inherit;">在不断增长的应用程序中，状态管理可能会因本地状态而变得混乱，因为：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个组件必须与另一个组件共享状态</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个组件必须修改另一个组件的状态</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在某些时候，谈论应用程序的状态变得越来越困难。这将成为组件层次结构中状态对象和状态突变的肮脏网络。在大多数情况下，状态对象和状态突变不一定与一个组件相关联。它们通过组件树链接，并且您必须升高和降低状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，解决方案是引入状态管理库，例如MobX或Redux。它为您提供了保存状态，更改状态和接收状态更新的工具。您可以在一个位置进行搜索，在一个位置进行更改，并在一个位置接收状态更新。他遵循</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">单一真理来源</font></a><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原则。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由于状态和条件的变化与组件分离，因此这使您更容易推断状态和条件的变化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状态管理库（例如Redux和MobX）通常具有实用程序的附加组件，例如，对于Angular，它们具有angular-redux和mobx-angular，以使您的组件能够访问状态。</font><font style="vertical-align: inherit;">通常，这些组件称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">容器化组件，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或更准确地说，</font><font style="vertical-align: inherit;">称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相关组件</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您可以从组件层次结构中的任何位置访问状态并通过将组件更新为相关的状态来更改状态。</font></font><br>
<br>
<a name="whats-the-difference-between-redux-and-mobx"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">REDUX和MOBX有什么区别？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在深入探讨差异之前，我想向您介绍MobX和Redux之间的相似之处。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这两个库都用于控制JavaScript应用程序中的状态。它们不一定与Angular之类的库关联。它们还用于其他库中，例如ReactJ和VueJ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果选择一种状态管理解决方案，则不会遇到供应商停工的情况。您可以随时切换到另一个状态管理解决方案。您可以从MobX升级到Redux或从Redux升级到MobX。稍后，我将向您展示这种情况。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan Abramov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andrew Clark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设计的Redux </font><font style="vertical-align: inherit;">是</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Flux架构</font></a><font style="vertical-align: inherit;">的衍生产品</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。与Flux不同，它使用多个存储库中的一个来维护状态。此外，它使用纯函数代替调度程序来更改状态。如果您对流程不熟悉并且不熟悉状态管理，则不必担心最后一段。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redux受</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">功能编程</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（FP）</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">原理的</font></a><font style="vertical-align: inherit;">影响</font><font style="vertical-align: inherit;">。 FP可以用JavaScript完成，但是许多人来自Java等面向对象的背景，一开始就难以接受函数式编程的原理。稍后将解释为什么MobX作为初学者可能更容易学习。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于Redux包含函数式编程，因此它使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">纯函数</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">纯函数是接收输入，返回输出并且除相同函数外没有其他依赖项的函数。</font><font style="vertical-align: inherit;">这样的功能总是产生具有相同输入的相同输出，并且没有副作用。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更多细节</font></font></a></blockquote><br>
<pre><code class="javascript hljs">(state, action) =&gt; newState</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您的Redux状态</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保持不变</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">而不是变异，您总是返回一个新状态。</font><font style="vertical-align: inherit;">您不执行状态突变，也不依赖于对象引用。</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-comment">//     Redux,     </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAuthor</span>(<span class="hljs-params">state, action</span>) </span>{
  <span class="hljs-keyword">return</span> state.authors.push(action.author);<font></font>
}<font></font>
<span class="hljs-comment">//       </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAuthor</span>(<span class="hljs-params">state, action</span>) </span>{
  <span class="hljs-keyword">return</span> [ ...state.authors, action.author ];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后但并非最不重要的一点，在惯用的Redux中，您的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态已规范化</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，就像在数据库中一样。实体</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅通过id相互引用</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这是最佳做法。尽管并非所有人都可以，但是您可以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normalizr之</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类的库</font><font style="vertical-align: inherit;">来实现这种标准化状态。规范化状态使您可以保持平坦状态和实体作为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单一事实来源</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="json hljs">{<font></font>
  post: {<font></font>
    id: 'a',<font></font>
    authorId: 'b',<font></font>
    ...<font></font>
  },<font></font>
  author: {<font></font>
    id: 'b',<font></font>
    postIds: ['a', ...],<font></font>
    ...<font></font>
  }<font></font>
}</code></pre><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
相比之下，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Michel Weststratt的MobX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不仅受到面向对象编程的影响，还受到反应式编程的影响。</font><font style="vertical-align: inherit;">它将状态包裹在可观察的对象中。</font><font style="vertical-align: inherit;">因此，您</font><font style="vertical-align: inherit;">在自己的状态下</font><font style="vertical-align: inherit;">具有“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可观察</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”的</font><font style="vertical-align: inherit;">所有功能</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">数据可以具有简单的setter和getter，但是可观察的数据使您可以在数据更改后接收更新。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Mobx中，您的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态是volatile</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这样，您可以直接更改状态：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAuthor</span>(<span class="hljs-params">author</span>) </span>{
  <span class="hljs-keyword">this</span>.authors.push(author);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，组织之间保持相对（深层）嵌套的数据结构。</font><font style="vertical-align: inherit;">您没有使您的状况正常化。</font><font style="vertical-align: inherit;">条件</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保持</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非规范化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并嵌入。</font></font></b><br>
<br>
<pre><code class="json hljs">{<font></font>
  post: {<font></font>
    id: 'a',<font></font>
    ...<font></font>
    author: {<font></font>
      id: 'b',<font></font>
      ...<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个存储库与几个存储库</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Redux中，您将所有状态存储在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个全局存储库</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个全局状态中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。单个状态对象是您唯一的真理来源。另一方面，许多变速箱允许它改变不变的状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
相比之下，MobX使用几个存储库。像Redux减速器一样，您可以按技术水平，领域等应用分隔和征服。您可以将域对象存储在单独的存储库中，但也可以控制存储库中的查看状态。最后，您放置最适合您的应用程序的状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从技术上讲，您也可以在Redux中拥有多个存储库。</font><font style="vertical-align: inherit;">没有人会强迫您只使用一个。</font><font style="vertical-align: inherit;">但这不是Redux宣传的用例。</font><font style="vertical-align: inherit;">使用多个存储库与最佳做法背道而驰。</font><font style="vertical-align: inherit;">在Redux中，您希望有一个存储库，通过其简化器响应全局事件。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现是什么样的？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Redux上，将应用程序的配置添加到全局状态需要以下代码行。 </font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> initialState = {
  <span class="hljs-attr">users</span>: [<font></font>
    {<font></font>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Alex'</span><font></font>
    },<font></font>
    {<font></font>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Nik'</span><font></font>
    }<font></font>
  ]<font></font>
};<font></font>
<span class="hljs-comment">// reducer</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">users</span>(<span class="hljs-params">state = initialState, action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">'USER_ADD'</span>:
    <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">users</span>: [ ...state.users, action.user ] };
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">return</span> state;<font></font>
  }<font></font>
}<font></font>
<span class="hljs-comment">// action</span>
{ <span class="hljs-attr">type</span>: <span class="hljs-string">'USER_ADD'</span>, <span class="hljs-attr">user</span>: user };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在MobX中，存储将仅管理子状态（因为Redux中的reducer控制子状态），但是您可以直接更改状态。</font><font style="vertical-align: inherit;">@observable批注允许您观察状态变化。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">userStore</span></span>{<font></font>
@observable users = [<font></font>
    {<font></font>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Nikita'</span><font></font>
    }<font></font>
  ];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在您可以调用userStore.users.push（用户）；</font><font style="vertical-align: inherit;">在商店的副本上。</font><font style="vertical-align: inherit;">但是，建议通过操作使状态突变更明确。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">userStore</span></span>{<font></font>
@observable users = [<font></font>
    {<font></font>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Nikita'</span><font></font>
    }<font></font>
  ];<font></font>
}<font></font>
@action addUser = <span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> {
    <span class="hljs-keyword">this</span>.users.push(user);<font></font>
  }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以通过使用configure（{empceActions：true}）;配置MobX来严格应用它。</font><font style="vertical-align: inherit;">现在，您可以通过调用userStore.addUser（用户）来更改状态。</font><font style="vertical-align: inherit;">在商店的副本上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您已经了解了如何在Redux和MobX上更新状态。</font><font style="vertical-align: inherit;">在Redux中，您的状态为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只读</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您只能通过</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显式操作</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改状态</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">相反，在MobX中，状态包括读取和写入。</font><font style="vertical-align: inherit;">您可以不使用操作直接更改状态，但是可以使用forcenActions配置选择显式操作。</font></font><br>
<br>
<a name="the-learning-curve-in-react-state-management"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反应状态学习曲线</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redux和MobX都主要用于React应用程序。但是这些都是独立的状态管理库，无需React即可在任何地方使用。它们的交互库使将它们与Angular组件轻松组合成为可能。这些</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反应-终极版</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阵营+终极版</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mobx反应的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阵营+ MobX</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。稍后我将解释如何在Angular组件树中同时使用两者。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在最近的讨论中，确实发生了人们争论Redux中的学习曲线的问题。这通常是在React上下文中发生的：人们开始学习React，并已经想在Redux中使用状态管理。大多数人认为React和Redux本身具有良好的学习曲线，但是两者都可能令人不知所措。因此，MobX将是替代方案，因为它更适合初学者。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，对于新的React用户，我建议使用另一种方法来了解React生态系统中的状态管理。</font><font style="vertical-align: inherit;">开始学习在组件中使用自己的本地状态管理功能进行React。</font><font style="vertical-align: inherit;">在React应用程序中，您首先要了解React生命周期方法，并了解如何使用setState（）和this.state管理本地状态。</font><font style="vertical-align: inherit;">我强烈推荐这种学习方式。</font><font style="vertical-align: inherit;">否则，您将很快被React生态系统淹没。</font><font style="vertical-align: inherit;">最后，您将逐渐认识到管理组件的（内部）状态变得很复杂。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux或MobX适合初学者？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过熟悉Angular组件和内部状态管理，您可以选择状态管理库来解决您的问题。在使用完这两个库之后，我会说MobX对于初学者来说可能非常方便。我们已经看到MobX需要更少的代码，尽管它确实使用了一些我们不需要知道的魔术笔记。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用MobX，您无需熟悉函数式编程。不变性之类的术语可能仍然是外国的。</font></font><blockquote>  —   ,       JavaScript.     ,          ,   - , ,     MobX.</blockquote><br>
<br>
<h3>  Redux</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
随着您的应用程序变得越来越大，并且有多个开发人员在处理它，您应该考虑使用Redux。本质上，他承诺使用明确的行为来改变状态。动作具有齿轮箱可以用来改变状态的类型和有效载荷。开发团队以这种方式谈论状态变化非常容易。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redux为您提供了一个完整的体系结构，用于管理有明显限制的状态。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux成功案例</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redux的另一个优点是在服务器端的使用。由于我们正在处理简单的JavaScript，因此您可以通过网络发送状态。状态对象的序列化和反序列化是开箱即用的。但是，MobX也可以做到这一点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MobX不太自信，但是使用configure（{empceActions：true}）可以像Redux一样应用更精确的限制。这就是为什么我不会说您不能使用MobX来扩展应用程序，但是Redux有明确的方法来做某事。 MobX文档甚至说：“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[MobX]不会告诉您如何构建代码，在何处存储状态或如何处理事件</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。”开发团队首先必须创建一个状态管理架构。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
毕竟，状态管理的学习曲线并不那么陡峭。当我们重复建议时，React的新手将</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先学习如何正确使用setState（）和this.state</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。一段时间后，您将了解</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅使用setState（）的问题</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在React应用中保持状态。</font><font style="vertical-align: inherit;">在寻找解决方案时，您会遇到状态管理库，例如MobX或Redux。</font><font style="vertical-align: inherit;">但是选择哪一个呢？</font><font style="vertical-align: inherit;">由于MobX不太自信，具有较小的模板，并且可以与setState（）类似地使用，因此我建议在小型项目中给MobX一个机会。</font><font style="vertical-align: inherit;">一旦应用程序规模增加并增加参与者数量，您就应该考虑在MobX中应用其他限制或给Redux一个机会。</font><font style="vertical-align: inherit;">我喜欢使用两个库。</font><font style="vertical-align: inherit;">即使最后不使用其中之一，也有必要找到一种替代方法来管理状态。</font></font><br>
<br>
<a name="last-thoughts"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后的想法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每当我在Redux vs MobX讨论中阅读评论时，总会有一个评论：“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux标准太多，您应该改用MobX。我能够删除XXX行代码</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。“该评论可能是正确的，但没有人认为妥协。 Redux附带了许多模板，例如MobX，因为它是为特定的设计约束而添加的。这使您可以推断应用程序的状态，即使它的规模更大。与国家待遇有关的整个仪式，不仅是公正的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redux库很小。大多数时候，您</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只处理简单的JavaScript对象和数组。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这比MobX更接近原始JavaScript。在MobX中，对象和数组被包裹在可观察的对象中，这些对象隐藏了大多数标准模板。它建立在其中会发生魔术的隐藏抽象之上，但是更难理解基本机制。 Redux使您可以使用简单的JavaScript轻松谈论此问题。这使得测试和调试应用程序变得容易。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，您需要重新考虑我们在SPA中来自何处。一堆单页框架和应用程序库具有相同的状态管理问题，这些问题最终通过使用全面的流模型得以解决。 Redux是此方法的后继者。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在MobX中，它再次朝相反的方向移动。我们再次开始直接改变状态，而无需利用功能编程。对于某些人来说，这再次接近双向数据绑定。一段时间后，人们可能会再次遇到相同的问题，然后再出现诸如Redux之类的状态管理库。状态管理分散在各个组件之间，并且混乱不堪。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Redux上，您已经建立了设置仪式，而MobX则没有那么自信。但是最好接受MobX的最佳体验。人们需要知道如何组织状态管理，以改进他们对此的论点。否则，人们倾向于直接在组件中更改状态。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这两个库都很棒。</font><font style="vertical-align: inherit;">尽管Redux已经很成熟，但是MobX正在成为状态管理的可行替代方案。</font></font></blockquote><br>
<a name="more-resurces"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更多资源</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Michel Weststratt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">MobX的</font></a><font style="vertical-align: inherit;">创建者的</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比较</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN489840/index.html">驱动器解剖：硬盘驱动器</a></li>
<li><a href="../zh-CN489844/index.html">一些Java反编译器的比较分析</a></li>
<li><a href="../zh-CN489848/index.html">为什么我的同事/员工的行为像@％§？</a></li>
<li><a href="../zh-CN489850/index.html">安全周09：谁负责Android安全？</a></li>
<li><a href="../zh-CN489852/index.html">Linux上的ASP.Net Core中的透明身份验证</a></li>
<li><a href="../zh-CN489856/index.html">Banach-Tarski反向悖论或如何将存储的数据量减少五倍</a></li>
<li><a href="../zh-CN489858/index.html">国际化：使所有人都可以访问Web</a></li>
<li><a href="../zh-CN489860/index.html">德律风根的历史：从威廉二世和戈培尔到甲壳虫到今天的德国电子凤凰</a></li>
<li><a href="../zh-CN489862/index.html">Go中的规划：第二部分-Go Scheduler</a></li>
<li><a href="../zh-CN489868/index.html">冻结Mozilla WebThings</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>