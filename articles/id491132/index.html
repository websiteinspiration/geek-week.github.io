<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍽️ 🚑 🐧 Ketika filter mekar tidak cocok 👨🏻 👃🏼 ✉️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya tahu dari universitas tentang filter Bloom , struktur data probabilistik yang dinamai Burton Bloom. Tetapi saya tidak memiliki kesempatan untuk m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Ketika filter mekar tidak cocok</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491132/"><img src="https://habrastorage.org/webt/7x/rh/8w/7xrh8wafuzqnbs-o1jpgzjxtruw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tahu dari universitas tentang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filter Bloom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , struktur data probabilistik yang dinamai Burton Bloom. Tetapi saya tidak memiliki kesempatan untuk menggunakannya. Bulan lalu, kesempatan seperti itu muncul - dan struktur ini benar-benar membuat saya terpesona. Namun, saya segera menemukan beberapa kekurangan dalam dirinya. Artikel ini adalah kisah tentang hubungan asmara singkat saya dengan filter Bloom.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam proses meneliti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP spoofing,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perlu untuk memeriksa alamat IP dalam paket yang masuk, membandingkannya dengan lokasi geografis dari pusat data kami. Misalnya, paket dari Italia tidak boleh pergi ke pusat data Brasil. Masalah ini mungkin tampak sederhana, tetapi dalam lanskap Internet yang terus berubah itu jauh dari sederhana. Cukuplah untuk mengatakan bahwa pada akhirnya saya mengumpulkan banyak file teks besar dengan kira-kira konten berikut: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7cf/4b4/f67/7cf4b4f67fdf8b4d8a88c2685051c15f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini berarti bahwa permintaan dari alamat IP yang diselesaikan 192.0.2.1 telah direkam dalam data center Cloudflare nomor 107. Data ini berasal dari banyak sumber, termasuk sampel aktif dan pasif kami, log dari beberapa domain yang kami miliki (misalnya,</font></font><code>cloudflare.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), sumber terbuka (misalnya, tabel BGP), dll. Baris yang sama biasanya diulang dalam beberapa file. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada akhirnya, saya mendapat dataset raksasa seperti ini. </font><font style="vertical-align: inherit;">Pada titik tertentu, di semua sumber yang terkumpul, saya menghitung 1 miliar baris. </font><font style="vertical-align: inherit;">Biasanya saya menulis skrip bash untuk preprocessing data input, tetapi pada skala ini pendekatan ini tidak berhasil. </font><font style="vertical-align: inherit;">Sebagai contoh, menghapus duplikat dari file kecil ini dari 600 MiB dan 40 juta baris membutuhkan ... keabadian: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfa/dc1/9c0/bfadc19c083b6a31bc34b568cdc81d74.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cukuplah untuk mengatakan bahwa garis deduplicating dengan perintah biasa dari jenis </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam berbagai konfigurasi (lihat </font></font><code>--parallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>--buffer-size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>--unique</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) bukan yang terbaik untuk set data yang besar.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filter mekar</font></font></h1><br>
<img src="https://habrastorage.org/getpro/habr/post_images/3a6/110/0e6/3a61100e64277b6a515666b8bf0293f9.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ilustrasi </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">David Epstein</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam domain publik.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Kemudian saya sadar: jangan mengurutkan garis! Anda perlu menghapus duplikat, sehingga beberapa jenis struktur data 'set' akan bekerja lebih cepat. Selain itu, saya kira-kira tahu ukuran file input (jumlah baris unik), dan hilangnya beberapa data tidak kritis, yaitu, struktur data probabilistik cukup cocok.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini sempurna untuk filter Bloom!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat Anda membaca</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia di filter Bloom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ini adalah bagaimana saya melihat struktur data ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana Anda menerapkan</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pluralitas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Diberikan fungsi hash yang ideal dan memori tak terbatas, kita dapat dengan mudah membuat bitmap tak terbatas dan menetapkan angka bit untuk setiap elemen</font></font><code>hash(item)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini memberikan struktur data yang ideal untuk "banyak". </font><font style="vertical-align: inherit;">Baik? </font><font style="vertical-align: inherit;">Sepele. </font><font style="vertical-align: inherit;">Sayangnya, fungsi hash bertabrakan, dan memori tak terbatas tidak ada, jadi dalam kenyataan kita harus berkompromi. </font><font style="vertical-align: inherit;">Tetapi kita dapat menghitung probabilitas tabrakan dan mengelola nilai ini. </font><font style="vertical-align: inherit;">Misalnya, kami memiliki fungsi hash yang baik dan memori 128 GB. </font><font style="vertical-align: inherit;">Kita dapat menghitung bahwa probabilitas tumbukan untuk setiap elemen baru adalah 1 hingga 1099511627776. Ketika Anda menambahkan lebih banyak elemen, probabilitas meningkat saat bitmap diisi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, kita dapat menerapkan lebih dari satu fungsi hash dan mendapatkan bitmap yang lebih padat. </font><font style="vertical-align: inherit;">Di sinilah filter Bloom berfungsi dengan baik, yang merupakan kumpulan data matematika dengan empat variabel:</font></font><br>
<br>
<ul>
<li><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - jumlah elemen yang dimasukkan (nomor kardinal)</font></font><br>
</li>
<li><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - memori yang digunakan oleh bitmap</font></font><br>
</li>
<li><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - jumlah fungsi hash yang dihitung untuk setiap input</font></font><br>
</li>
<li><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - probabilitas kebetulan positif palsu</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengingat nomor kardinal </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan probabilitas positif palsu yang diinginkan </font></font><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, filter Bloom mengembalikan memori yang diperlukan </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan jumlah fungsi hash yang diperlukan </font></font><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lihatlah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">visualisasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thomas Hurst yang </font><font style="vertical-align: inherit;">luar </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">biasa</font></a><font style="vertical-align: inherit;"> ini </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">tentang</font></a><font style="vertical-align: inherit;"> bagaimana parameter saling memengaruhi.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-mekar</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dipandu oleh intuisi, saya menambahkan alat probabilistik mmuniq-bloom ke gudang senjata saya, yang mengambil input STDIN dan hanya mengembalikan garis unik di STDOUT. </font><font style="vertical-align: inherit;">Seharusnya lebih cepat daripada kombinasi </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font><code>uniq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu dia:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-bloom.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk kesederhanaan dan kecepatan, saya awalnya menetapkan beberapa parameter. Pertama, kecuali dinyatakan sebaliknya, mmuniq-bloom menggunakan delapan fungsi hash k = 8. Ini tampaknya mendekati angka optimal untuk ukuran data kami, dan fungsi hash dapat dengan cepat menghasilkan delapan hash yang layak. Kemudian kami menyelaraskan memori </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam bitmap ke kekuatan dua untuk menghindari operasi yang mahal </font></font><code>%modulo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang dalam assembler turun menjadi lambat </font></font><code>div</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jika array sama dengan kekuatan dua, kita bisa menggunakan bitwise AND (untuk bersenang-senang, baca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bagaimana kompiler mengoptimalkan beberapa operasi divisi dengan mengalikan dengan konstanta ajaib</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita dapat menjalankannya pada file data yang sama yang kita gunakan sebelumnya:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3fa/019/d05/3fa019d05b8d6a72ad1ea3bde9c15a19.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh, itu jauh lebih baik! 12 detik, bukan dua menit. Program ini menggunakan struktur data yang dioptimalkan, jumlah memori yang relatif terbatas, penguraian garis yang dioptimalkan, dan buffering keluaran yang baik ... dan dengan semua ini, 12 detik tampak seperti selamanya dibandingkan dengan alat </font></font><code>wc -l</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/953/ede/adb/953edeadb5701d03f92c7717f159f20d.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang terjadi? Saya mengerti bahwa menghitung string </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lebih mudah daripada menghitung string unik, tetapi apakah perbedaan 26 kali benar-benar dibenarkan? Apa yang diterima CPU </font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Harus untuk hash komputasi. Utilitas </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak menghabiskan prosesor, melakukan semua matematika aneh ini untuk masing-masing dari 40 juta baris. Saya menggunakan fungsi hash yang agak non-sepele </font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pasti membakar prosesor, kan? Mari kita verifikasi dengan menjalankan hanya fungsi hash, tetapi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak melakukan operasi dengan filter Bloom: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f5e/7a0/e0f/f5e7a0e0f26a3136ca3d0a9b362e0fe3.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini aneh. </font><font style="vertical-align: inherit;">Perhitungan fungsi hash hanya membutuhkan waktu sekitar dua detik, meskipun seluruh program dalam menjalankan sebelumnya membutuhkan waktu 12 detik. </font><font style="vertical-align: inherit;">Apakah satu filter Bloom berfungsi selama 10 detik? </font><font style="vertical-align: inherit;">Bagaimana ini mungkin? </font><font style="vertical-align: inherit;">Ini adalah struktur data yang sederhana ...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Senjata Rahasia - Profiler</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saatnya menerapkan alat yang tepat untuk tugas ini - mari kita jalankan profiler dan lihat apa yang sedang dikerjakan prosesor. Pertama, mari kita jalankan </font></font><code>strace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk memverifikasi bahwa tidak ada panggilan sistem yang tidak terduga: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7bc/29b/87c/7bc29b87cdeadac9a11ce78aa61129f6.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya terlihat baik. Sepuluh panggilan ke </font></font><code>mmap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masing-masing 4 ms (3971 μs) sangat menarik, tetapi itu tidak masalah. Kami pra-mengisi memori dengan </font></font><code>MAP_POPULATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, untuk mencegah kesalahan karena kurangnya halaman. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa langkah selanjutnya? Tentu saja </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/1da/aa8/acc/1daaa8acc9e3a84d1f591ad94cd84387.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lalu mari kita lihat hasilnya: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/637/38f/3e2/63738f3e2a4bb1207927ecbc45b0cf3b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, kita benar-benar membakar 87,2% dari siklus dalam kode utama. Mari kita lihat di mana tepatnya. Tim </font></font><code>perf annotate process_line --source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segera menunjukkan sesuatu yang tidak terduga. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/17f/f6f/cc8/17ff6fcc833def72269a07f7fd54d9f0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita melihat bahwa 26,90% dari prosesor terbakar</font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Tapi bukan itu saja! Compiler dengan benar memasukkan fungsi dan memperluas loop. Ternyata sebagian besar siklus mengarah ke ini </font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau ke garis </font></font><code>uint64_t v = *p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5c0/a3e/59c/5c0a3e59c8f954146bed3b2f1478e0ba.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jelas perf salah, bagaimana string yang sederhana dapat mengambil begitu banyak sumber daya? Tetapi mengulangi pengujian dengan profiler lain menunjukkan masalah yang sama. Sebagai contoh, saya suka menggunakan google-perftools dengan kcachegrind karena diagram berwarna-warni: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8af/fbd/e9e/8affbde9e2b92d4da89d445314ec4654.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasil visualisasi adalah sebagai berikut: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/130/ea3/9f9/130ea39f9a8c6a22c252381c3af88045.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biarkan saya meringkas apa yang telah kami temukan sejauh ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilitas standar </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memproses file 600 MiB untuk waktu prosesor 0,45 detik. Alat kami yang dioptimalkan </font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berjalan 12 detik. Prosesor dibakar pada satu instruksi </font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, memori dereferencing ...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6aa/3dd/e6a/6aa3dde6a6562dad5d0b3b2fa94c4565.jpg"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar dari </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jose Nicdao</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , CC BY / 2.0</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Oh! Bagaimana saya bisa lupa. Akses acak ke memori</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sangat</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lambat! Sangat, sangat, sangat lambat!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menurut</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angka yang harus diketahui oleh setiap programmer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, satu akses ke RAM membutuhkan waktu sekitar 100 ns. Mari kita hitung: 40 juta baris, masing-masing 8 hash. Karena filter Bloom kami memiliki ukuran 128 MiB, pada</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perangkat keras lama kami</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak muat ke cache L3! Hash didistribusikan secara merata di berbagai memori - masing-masing menghasilkan cache miss. Menyatukan semuanya, dan ternyata ...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b54/7e8/2e6/b547e82e6368f26843834121b1765103.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ternyata 32 detik terbakar hanya pada akses memori. Program sebenarnya cocok hanya dalam 12 detik, karena filter Bloom masih mendapat manfaat dari caching. Ini mudah dilihat </font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2b8/199/785/2b8199785c666437f37b9d96c209670f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya, kita seharusnya memiliki minimal 320 juta cache cache (LLC-load-misses), tetapi hanya 280 juta yang terjadi: ini masih tidak menjelaskan mengapa program bekerja hanya dalam 12 detik. Tapi itu tidak masalah. Adalah penting bahwa jumlah cache yang hilang adalah masalah nyata, dan kita dapat menyelesaikannya hanya dengan mengurangi jumlah akses memori. Mari kita coba mengkonfigurasi filter Bloom untuk menggunakan hanya satu fungsi hash: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/052/bec/d4f/052becd4ffe91553d1d3b01bfa53755b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ay! Sangat menyakitkan! Untuk mendapatkan probabilitas tabrakan 1 per 10.000 baris, filter Bloom memerlukan 64 gigabytes memori. Ini mengerikan!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, sepertinya kecepatannya tidak meningkat secara signifikan. </font><font style="vertical-align: inherit;">Butuh sistem operasi 22 detik untuk menyiapkan memori bagi kami, tetapi kami masih menghabiskan 11 detik di ruang pengguna. </font><font style="vertical-align: inherit;">Saya percaya bahwa sekarang semua keuntungan dari akses yang lebih jarang ke memori dikompensasi oleh probabilitas yang lebih rendah untuk masuk ke cache karena ukuran memori meningkat tajam. </font><font style="vertical-align: inherit;">Sebelumnya, 128 MiB sudah cukup untuk filter Bloom!</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menolak Filter Bloom</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini semakin konyol. </font><font style="vertical-align: inherit;">Untuk mengurangi kemungkinan kesalahan positif, Anda harus menggunakan banyak hash di filter Bloom (misalnya, delapan) dengan banyak akses memori, atau meninggalkan satu fungsi hash, tetapi gunakan memori dalam jumlah besar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami sebenarnya tidak memiliki batas memori, kami ingin meminimalkan jumlah panggilan ke sana. </font><font style="vertical-align: inherit;">Kami membutuhkan struktur data yang memerlukan biaya maksimum satu cache miss per elemen dan menggunakan RAM kurang dari 64 gigabyte ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, Anda dapat menerapkan struktur data yang kompleks, seperti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filter kukuk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi tentu ada opsi yang lebih mudah. </font><font style="vertical-align: inherit;">Bagaimana dengan tabel hash probing linier yang bagus? </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c29/a0d/136/c29a0d136e80e5fc0a6f90f1cab1378e.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ilustrasi </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podans Vadims</font></font></a></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temui mmuniq-hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah versi baru dari mmuniq-bloom menggunakan tabel hash:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-hash.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alih-alih bit untuk filter Bloom, kami sekarang menyimpan hash 64-bit dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fungsi 'siphash24'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini memberikan perlindungan yang jauh lebih baik terhadap tabrakan hash: jauh lebih baik dari satu per 10.000 baris. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari berhitung. </font><font style="vertical-align: inherit;">Menambahkan item baru ke tabel hash, katakanlah dengan 40 juta entri, memberikan peluang tabrakan hash </font></font><code>40 000 000/2^64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini sekitar 1 dalam 461 miliar - probabilitas yang cukup rendah. </font><font style="vertical-align: inherit;">Tapi kami tidak menambahkan satu elemen ke set yang sudah diisi sebelumnya! </font><font style="vertical-align: inherit;">Sebagai gantinya, kami menambahkan 40 juta baris ke set yang awalnya kosong. </font><font style="vertical-align: inherit;">Menurut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paradoks ulang tahun</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ini sangat meningkatkan kemungkinan tabrakan. </font><font style="vertical-align: inherit;">Perkiraan yang masuk akal akan menjadi perkiraan </font></font><code>'~n^2/2m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dalam kasus kami adalah</font></font><code>~(40M^2)/(2*(2^64))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ternyata satu peluang dari 23.000. Dengan kata lain, dengan fungsi hash yang baik, kami mengharapkan tabrakan di salah satu dari 23.000 kumpulan acak dari 40 juta elemen. Ini adalah probabilitas non-nol, tetapi masih lebih baik daripada di filter Bloom, dan sepenuhnya dapat ditoleransi untuk kasus penggunaan kami. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode dengan tabel hash bekerja lebih cepat, ia memiliki pola akses memori yang lebih baik dan probabilitas positif palsu yang lebih rendah daripada di filter Bloom.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/0ea/5c5/817/0ea5c5817289f136355f452748da0f86.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jangan khawatir dengan garis "konflik hash", itu hanya menunjukkan seberapa penuh tabel hash. </font><font style="vertical-align: inherit;">Kami menggunakan penginderaan linier, jadi ketika kami masuk ke set lengkap, kami hanya mengambil yang kosong berikutnya. </font><font style="vertical-align: inherit;">Dalam kasus kami, kami harus melewati rata-rata 0,7 set untuk menemukan tempat kosong di tabel. </font><font style="vertical-align: inherit;">Ini normal. </font><font style="vertical-align: inherit;">Karena kita beralih pada set dalam urutan linier, memori harus penuh secara kualitatif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari contoh sebelumnya, kita tahu bahwa fungsi hash kita membutuhkan waktu sekitar dua detik. </font><font style="vertical-align: inherit;">Kami menyimpulkan bahwa 40 juta akses memori membutuhkan waktu sekitar empat detik.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelajaran yang dipetik</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prosesor modern sangat baik dalam mengakses berurutan ke memori ketika dimungkinkan untuk memprediksi pola pengambilan sampel (lihat pengambilan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cache sebelumnya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Akses acak ke memori, di sisi lain, sangat mahal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Struktur data lanjutan sangat menarik, tetapi hati-hati. Komputer modern membutuhkan penggunaan algoritma yang dioptimalkan cache. Saat bekerja dengan kumpulan data besar yang tidak sesuai dengan L3, optimalisasi atas jumlah hit lebih disukai, daripada optimasi atas jumlah memori yang digunakan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wajar untuk mengatakan bahwa filter Bloom berperforma hebat ketika ditempatkan di cache L3. Tetapi jika tidak, maka mereka mengerikan. Ini bukan berita: Filter Bloom dioptimalkan untuk jumlah memori, bukan jumlah panggilan ke sana. Sebagai contoh, lihat</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel ilmiah tentang filter kukuk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal lain adalah diskusi tanpa akhir tentang fungsi hash. Jujur, dalam banyak kasus ini tidak masalah. Biaya menghitung bahkan fungsi hash yang kompleks tampaknya </font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kecil dibandingkan dengan biaya akses acak ke memori. Dalam kasus kami, menyederhanakan fungsi hash hanya akan membawa sedikit manfaat. Waktu CPU hanya terbuang sia-sia - menunggu memori! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seorang kolega sering mengatakan: “Dapat diasumsikan bahwa prosesor modern sangat cepat. Mereka bekerja dengan kecepatan tak terbatas, sampai mereka </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bersandar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">dinding memori</font></a><font style="vertical-align: inherit;"> . " </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akhirnya, jangan ulangi kesalahan saya. Anda selalu perlu melakukan profiling terlebih dahulu</font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan lihat penghitung IPC (instruksi per siklus). </font><font style="vertical-align: inherit;">Jika kurang dari satu, ini biasanya berarti bahwa program macet menunggu memori. </font><font style="vertical-align: inherit;">Nilai optimal di atas dua. </font><font style="vertical-align: inherit;">Ini berarti bahwa beban kerjanya terutama pada CPU. </font><font style="vertical-align: inherit;">Sayangnya, dalam tugas saya, IPC masih rendah ...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mmuniq unggul</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan bantuan kolega, saya menulis versi perbaikan alat mmuniq berdasarkan tabel hash. </font><font style="vertical-align: inherit;">Ini kodenya:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu secara dinamis dapat mengubah ukuran tabel hash, mendukung input dengan nomor kardinal sewenang-wenang. </font><font style="vertical-align: inherit;">Kemudian memproses data dalam paket, secara efektif menggunakan petunjuk </font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di CPU, yang mempercepat program sebesar 35-40%. </font><font style="vertical-align: inherit;">Hati-hati, penggunaan berlebihan </font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam kode jarang memberikan efek. </font><font style="vertical-align: inherit;">Untuk menggunakan fungsi ini, saya secara khusus memesan ulang algoritma. </font><font style="vertical-align: inherit;">Dengan semua peningkatan, waktu eksekusi dikurangi menjadi 2,1 detik:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e40/4df/9c4/e404df9c42a97be2f1051a69f98116e6.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamat</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penciptaan alat dasar yang mencoba mengungguli kombinasi 'sort / uniq' telah mengungkapkan beberapa fitur tersembunyi dari komputasi modern. </font><font style="vertical-align: inherit;">Setelah sedikit berkeringat, kami mempercepat program dari lebih dari dua menit menjadi dua detik. </font><font style="vertical-align: inherit;">Selama pengembangan, kami belajar tentang penundaan akses acak ke memori, serta kekuatan struktur data yang ramah-cache. </font><font style="vertical-align: inherit;">Struktur data yang aneh menarik perhatian, tetapi dalam praktiknya seringkali lebih efisien untuk mengurangi jumlah akses acak ke memori.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id491116/index.html">Standar Identifikasi Modern: OAuth 2.0, OpenID Connect, WebAuthn</a></li>
<li><a href="../id491118/index.html">Developer Heart: Devkits dari generasi ke-5 konsol (Bagian 1)</a></li>
<li><a href="../id491120/index.html">$ mol: 4 tahun kemudian</a></li>
<li><a href="../id491122/index.html">Analisis forensik cadangan HiSuite</a></li>
<li><a href="../id491130/index.html">Fitur Vue untuk Diingat</a></li>
<li><a href="../id491134/index.html">5 tahap pengelakan adopsi sertifikasi ISO / IEC 27001. Penyangkalan</a></li>
<li><a href="../id491136/index.html">Memproyeksikan konten dalam dokumentasi angular atau hilang-konten</a></li>
<li><a href="../id491138/index.html">Integrasi Satelit dan Menara yang Mungkin</a></li>
<li><a href="../id491146/index.html">UML untuk pengembang</a></li>
<li><a href="../id491150/index.html">Bagaimana saya meretas scammers, atau hanya bagian dalam panel phishing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>