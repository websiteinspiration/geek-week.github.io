<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥣 👩🏽‍🤝‍👨🏾 🔞 Novos recursos TypeScript para usabilidade aprimorada 🙃 🗑️ 🛸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O TypeScript, em muitos aspectos, não é mais uma linguagem de programação, mas uma ferramenta poderosa para aprender e documentar códigos que ajudam a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Novos recursos TypeScript para usabilidade aprimorada</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/493712/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O TypeScript, em muitos aspectos, não é mais uma linguagem de programação, mas uma ferramenta poderosa para aprender e documentar códigos que ajudam a escrever melhores programas JavaScript.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dos pontos mais notáveis ​​do TypeScript é o suporte a alguns dos recursos mais recentes descritos na especificação ECMAScript. Quando um desenvolvedor atualiza para uma nova versão do TypeScript, isso significa que ele tem novos recursos de JavaScript. Além disso, o uso desses recursos não significa possíveis problemas de compatibilidade. O TypeScript, além de apresentar os recursos mais recentes do JavaScript, também é notável pelo fato de os criadores da linguagem estarem constantemente apresentando algo novo à comunidade de programadores do TS, projetada para aumentar a usabilidade. Isso inclui, por exemplo, ferramentas auxiliares para refatoração de código, ferramentas para renomear entidades e para encontrar lugares onde elas são usadas em programas.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/ik/dc/io/ikdcio3bkdkuvgg4h-lplk9lvpm.jpeg"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O material, cuja tradução publicamos hoje, discutirá alguns novos recursos interessantes do TypeScript. </font><font style="vertical-align: inherit;">Para uma lista completa das inovações do TypeScript, dê uma olhada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objetos e matrizes imutáveis</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para criar matrizes imutáveis ​​usadas na forma de variáveis ​​comuns e parâmetros de função durante a compilação, no TypeScript, você pode usar os tipos auxiliares </font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>ReadonlyArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No entanto, seu uso pode causar uma sensação de heterogeneidade na anotação de tipo, especialmente ao declarar matrizes usando caracteres </font></font><code>[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">após especificar um tipo. </font><font style="vertical-align: inherit;">O TypeScript 3.4 apresenta uma nova maneira de rotular parâmetros que são matrizes somente leitura. </font><font style="vertical-align: inherit;">Imediatamente apareceu uma nova maneira de declarar variáveis ​​que deveriam ser imutáveis.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melhorando a usabilidade com parâmetros somente leitura</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao declarar os parâmetros das funções com as quais você precisa trabalhar como matrizes somente leitura, agora você pode usar a palavra-chave </font></font><code>readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No exemplo a seguir, as assinaturas dos dois métodos são idênticas:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">s: ReadonlyArray&lt;string&gt;</span>) </span>{ <span class="hljs-comment">/* ... */</span> }<font></font>
&nbsp;<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">s: readonly string[]</span>) </span>{ <span class="hljs-comment">/* ... */</span> }
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos dois casos, qualquer tentativa de modificar a matriz (por exemplo, usando seu método </font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) resultará em um erro. </font><font style="vertical-align: inherit;">Essa inovação elimina a necessidade de um tipo genérico auxiliar, o que significa que o código é mais fácil de ler. </font><font style="vertical-align: inherit;">Os tipos de objetos também podem ser rotulados como entidades somente leitura, mas ainda precisam de um tipo auxiliar </font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melhorando a usabilidade de variáveis ​​imutáveis ​​usando a construção as const</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O tipo de uma variável declarada usando uma palavra-chave </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não pode ser alterada. Este conceito existe em JavaScript. É adotado no TypeScript para organizar um trabalho mais rigoroso com os tipos. Porém, ao trabalhar com tipos de dados de objetos, como objetos ou matrizes, essas estruturas não são realmente imutáveis. Usar uma palavra-chave </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">significa que uma instância específica de um objeto ou matriz permanecerá inalterada ao trabalhar com uma constante; no entanto, o conteúdo desse objeto ou matriz poderá ser facilmente alterado. Por exemplo, sem violar as regras para trabalhar com entidades const, você pode adicionar novos valores à matriz usando o método </font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pode alterar os valores das propriedades dos objetos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usando </font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font><code>ReadonlyArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">você pode dizer ao TypeScript que o sistema deve tratar entidades como se fossem realmente imutáveis. </font><font style="vertical-align: inherit;">Isso significa que sempre que for feita uma tentativa no código para alterar essa entidade, uma mensagem de erro será emitida.</font></font><br>
<br>
<pre><code class="javascript hljs">interface Person {&nbsp;
&nbsp;&nbsp;<span class="hljs-attr">name</span>: string;&nbsp;<font></font>
}<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> person = {&nbsp;
&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">'Will'</span>&nbsp;
} <span class="hljs-keyword">as</span> Readonly&lt;Person&gt;;<font></font>
person.name = <span class="hljs-string">'Diana'</span>; <span class="hljs-comment">// !</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No TypeScript 3.4, entre outras inovações, o conceito de const assertion (declaração constante), que fornece o uso de uma construção, apareceu </font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este é um método simplificado para declarar constantes contendo objetos e matrizes imutáveis. </font><font style="vertical-align: inherit;">Essas declarações são criadas adicionando </font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma constante ao final da declaração. </font><font style="vertical-align: inherit;">Este método tem uma vantagem adicional, o que é que quando você usá-lo, você não precisa especificar explicitamente o tipo na declaração </font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> person = {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">'Will'</span>&nbsp;
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<font></font>
&nbsp;<font></font>
person.name = <span class="hljs-string">'Diana'</span>; <span class="hljs-comment">// !</span><font></font>
&nbsp;<font></font>
<span class="hljs-comment">//      as const</span>
<span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;&nbsp;<font></font>
array.push(<span class="hljs-number">4</span>); <span class="hljs-comment">// !</span>
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipo auxiliar Omitir</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem vários tipos auxiliares no TypeScript que facilitam o mapeamento de tipos existentes para novos ou definem condicionalmente um tipo com base em outros tipos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O tipo auxiliar </font></font><code>Partial</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permite marcar todas as propriedades do objeto como opcional. </font><font style="vertical-align: inherit;">Antes do lançamento do TypeScript 3.5, como se viu, eu constantemente usava um mecanismo interessante em meus projetos. </font><font style="vertical-align: inherit;">É o mesmo que o uso do tipo auxiliar agora permite </font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esse tipo, como o próprio nome indica, permite excluir algo de outros tipos. </font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aceita o tipo e a combinação de chaves e, em seguida, retorna um novo tipo do qual as propriedades descritas pelas chaves são excluídas. </font><font style="vertical-align: inherit;">Longe vão os dias em que eu tive que usá- </font></font><code>Pick</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lo </font></font><code>Exclude</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para a implementação independente da funcionalidade</font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     TypeScript 3.5</span><font></font>
type Omit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;<font></font>
&nbsp;<font></font>
interface A {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propA?: string;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propB?: string;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propC?: string;&nbsp;<font></font>
}<font></font>
&nbsp;<font></font>
type B = Omit&lt;A, <span class="hljs-string">'propA'</span> | <span class="hljs-string">'propC'</span>&gt;;&nbsp;
<span class="hljs-keyword">const</span> b: B = { <span class="hljs-attr">propA</span>: <span class="hljs-string">'hi'</span> }; <span class="hljs-comment">// ;</span>
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Novos recursos de JavaScript suportados pelo TypeScript</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando as sugestões para novos recursos JavaScript atingem quatro estágios de coordenação, elas são consideradas parte da próxima versão do idioma. </font><font style="vertical-align: inherit;">É verdade que isso não significa que esses recursos possam ser usados ​​imediatamente em JavaScript, pois seu suporte deve ser implementado em ambientes apropriados. </font><font style="vertical-align: inherit;">O aplicativo deve ter acesso a essas oportunidades onde quer que sua operação normal seja suposta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O suporte para novos recursos JavaScript é adicionado regularmente ao compilador TypeScript. </font><font style="vertical-align: inherit;">Normalmente, o código que implementa esses recursos podem ser convertidos em código JavaScript que é compatível com todos os navegadores que suportam a meta de construção do projeto especificado no </font></font><code>tsconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Verifique se há nulos e indefinidos</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os desenvolvedores de JavaScript estão familiarizados com o conceito de verdade e falsidade. Ao verificar a verdade pode ser identificado 6 valores, que são sempre falsa: </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>«»</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>NaN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e, claro, </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Na maioria das vezes, o desenvolvedor precisa descobrir se o valor é verdadeiro ou falso, mas, em alguns casos, você só precisa descobrir se o valor que está sendo investigado é um valor real </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por exemplo, no caso, se for necessário distinguir entre código </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ||     ,  index  0</span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index || <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 1 &lt;-- </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este código funcionará definindo </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o valor gravado em </font></font><code>index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, em todos os casos, exceto aqueles em que o valor </font></font><code>index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é igual </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para que esse código funcione corretamente em qualquer situação, ele precisa ser reescrito usando um esquema de teste mais complexo para descobrir o tipo real de valor.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   ,    </span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index !== <span class="hljs-literal">null</span> &amp;&amp; index !== <span class="hljs-literal">undefined</span> ? : <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 0</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora o código funciona, mas requer o uso de verificações mais complexas. </font><font style="vertical-align: inherit;">O novo operador para verificar o valor </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(parece dois pontos de interrogação - </font></font><code>??</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) simplifica essas verificações retornando o valor localizado na parte esquerda, se não for igual a </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Caso contrário, ele retorna o que está do lado direito.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// !</span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index ?? <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 0</span>
getValueOrOne(<span class="hljs-number">2</span>); <span class="hljs-comment">// 2</span>
getValueOrOne(); <span class="hljs-comment">// 1</span>
</code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Sequências opcionais</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro novo recurso JavaScript disponível no TypeScript 3.7 é o operador para organizar sequências opcionais ( </font></font><code>?.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Conheci esse operador pela primeira vez na linguagem de programação Groovy. Desde então, eu queria que ele aparecesse em JavaScript também. Esse operador permite organizar o acesso às propriedades incorporadas dos objetos sem a necessidade de verificação constante de sua existência. Se, ao acessar uma propriedade, esse operador encontrar um valor </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ele simplesmente retornará esse valor sem gerar um erro </font></font><code>TypeError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> value = foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz;<font></font>
&nbsp;<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> value = foo?.bar?.baz;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O operador de sequência opcional combinado com o operador de verificar os valores </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornece ao desenvolvedor ainda mais possibilidades, permitindo, por exemplo, gravar na variável o valor de alguma propriedade aninhada do objeto ou, se essa propriedade não existir, algum valor padrão. </font><font style="vertical-align: inherit;">Aqui está o que parece:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> value = foo?.bar?.baz ?? <span class="hljs-string">'default value'</span>;
</code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fields Campos de classe privada</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O TypeScript, desde o advento dessa linguagem, tem seu próprio conceito de campos de classe privada declarados com um modificador de acesso </font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esse conceito apareceu no TypeScript antes mesmo de as classes serem descritas no padrão ECMAScript. Mas no TypeScript, esse conceito se refere aos mecanismos que funcionam durante a compilação de código. O compilador lançará um erro se o campo privado da classe não for acessado por seus próprios métodos. Agora, em JavaScript, há uma oportunidade de declarar propriedades e métodos privados de uma classe. Mas esse recurso é semanticamente e sintaticamente diferente do que ainda existia no TypeScript. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os campos particulares em JavaScript não são declarados usando um modificador de acesso </font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Em vez disso, eles são declarados colocando um símbolo no início de seus nomes </font></font><code>#</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fan</span> </span>{&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;#on = <span class="hljs-literal">false</span>;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;private name = <span class="hljs-string">'fan'</span>;<font></font>
&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;turnOn() {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.#on = <span class="hljs-literal">true</span>;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;isTurnedOn() {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.#on;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> fan = <span class="hljs-keyword">new</span> Fan();&nbsp;<font></font>
fan.isTurnedOn(); <span class="hljs-comment">// false&nbsp;&nbsp;</span><font></font>
fan.turnOn();&nbsp;<font></font>
fan.isTurnedOn(); <span class="hljs-comment">// true</span><font></font>
&nbsp;<font></font>
fan.on; <span class="hljs-comment">//  </span>
fan.#on; <span class="hljs-comment">// </span>
fan.name; <span class="hljs-comment">//   ,    JS</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O JavaScript agora suporta campos particulares, a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proposta</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de métodos privados está no terceiro estágio de aprovação. </font><font style="vertical-align: inherit;">Atualmente, o modificador </font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e o caractere </font></font><code>#</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no nome do campo não podem ser usados ​​juntos. </font><font style="vertical-align: inherit;">Ambas as abordagens podem ser úteis durante o desenvolvimento, e qual escolher depende do programador. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui está um</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> podcast que discute a nova sintaxe para declarar campos particulares.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SingUsando a palavra-chave wait no nível superior do código</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mecanismos de programação assíncrona expandem muito os recursos de JavaScript e TypeScript. No início, promessas apareceram nessa área, então - um design </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que permite escrever código assíncrono mais limpo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dos casos em que as promessas são usadas, e não, </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é uma chamada de método assíncrona fora da função assíncrona. Por exemplo, no nível superior do módulo ou código do aplicativo. Como solução alternativa nessa situação, você pode propor a criação de uma expressão de função chamada assíncrona imediatamente (IIFE, expressão de função chamada imediatamente) e a execução de código assíncrono dentro dessa expressão.</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-keyword">async</span> () =&gt; {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/users/sitepen'</span>);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Check out the blog at <span class="hljs-subst">${data.blog}</span>`</span>);&nbsp;<font></font>
})();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O TypeScript agora suporta a capacidade do JavaScript de usar palavras </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">chave </font><font style="vertical-align: inherit;">no nível superior do código. </font><font style="vertical-align: inherit;">Isso significa que wait pode ser usado fora das funções declaradas com a palavra-chave </font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso é muito bom para escrever código compacto e claro. </font><font style="vertical-align: inherit;">É verdade que as expressões </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no nível superior do código são criticadas pelo fato de poderem retardar o carregamento dos módulos e criar uma situação em que um determinado módulo pode retardar o carregamento de todo o aplicativo, já que o sistema precisa aguardar a conclusão da operação assíncrona e executar todo o código do módulo.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/users/sitepen'</span>);&nbsp;
<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> { ...data };
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambiente aprimorado de experimentação TypeScript</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso não pode ser chamado de um novo recurso TypeScript, mas, como estamos falando do TypeScript como uma ferramenta, o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScript Playground</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode ser chamado de uma ferramenta eficaz para verificar rapidamente qualquer construção TypeScript e exibir o código JavaScript no qual essas construções se transformam. </font><font style="vertical-align: inherit;">A maioria dos exemplos aqui é testada especificamente no TypeScript Playground. </font><font style="vertical-align: inherit;">Agora, esse ambiente suporta a capacidade de selecionar uma versão específica do TypeScript (incluindo suporte para versões beta). </font><font style="vertical-align: inherit;">Inclui vários exemplos que ajudarão os iniciantes a começar com o TypeScript.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumário</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O TypeScript é uma ferramenta que ajuda a escrever um código JavaScript melhor e mais expressivo. </font><font style="vertical-align: inherit;">As ferramentas auxiliares do TypeScript facilitam a resolução de tarefas complexas, como refatoração e renomeação de entidades, que são muito mais complicadas no JavaScript comum. </font><font style="vertical-align: inherit;">O TypeScript está constantemente introduzindo novos mecanismos, como </font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Na linguagem, observa-se uma melhoria contínua no suporte de tipos complexos. </font><font style="vertical-align: inherit;">O TypeScript implementa rapidamente os recursos mais recentes do JavaScript. </font><font style="vertical-align: inherit;">É por isso que muitas pessoas escolhem o TypeScript, percebendo-o como uma ferramenta, linguagem e ecossistema. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queridos leitores! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quais novos recursos TypeScript você acha mais interessantes?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt493700/index.html">Usando malware no Azure para obter acesso aos inquilinos do Microsoft 365</a></li>
<li><a href="../pt493702/index.html">Transição maciça para o trabalho remoto: problemas técnicos e ameaças à segurança</a></li>
<li><a href="../pt493704/index.html">Usando TypeScript em JavaScript sem escrever TypeScript</a></li>
<li><a href="../pt493706/index.html">Conheça o seu inimigo: crie um backdoor do Node.js.</a></li>
<li><a href="../pt493708/index.html">Anatomia do cluster Kubernetes da minha casa</a></li>
<li><a href="../pt493714/index.html">Folhas de dicas de segurança: Nodejs</a></li>
<li><a href="../pt493716/index.html">Digite inferência no TypeScript usando a construção as const e a palavra-chave infer</a></li>
<li><a href="../pt493718/index.html">Discussão: utilitários UNIX padrão que poucos usaram e estão usando atualmente</a></li>
<li><a href="../pt493720/index.html">A tempestade perfeita: como a tecnologia está mudando a indústria de serviços de alimentação</a></li>
<li><a href="../pt493724/index.html">RPA Robótica de processos através dos olhos de um analista</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>