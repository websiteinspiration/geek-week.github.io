<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍘 👃🏼 🎫 デジタル回路の論理モデリングの例における慣性アルゴリズムの実装 🔮 🍠 🏙️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1.はじめに
 ネストされたオートマトンに関するトピックの2番目の部分に進みます。最初の、我々は、ネストされたオートマトンと接続OOP機能のモデルを有し、それが実現するのは困難ではないことが判明し、再帰アルゴリズムを検討しました。しかし、ネストされたオートマトンの可能性はこれに限定されません。したが...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>デジタル回路の論理モデリングの例における慣性アルゴリズムの実装</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/494874/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.はじめに</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネストされたオートマトンに関するトピックの2番目の部分に進みます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我々は、ネストされたオートマトンと接続OOP機能のモデルを有し、それが実現するのは困難ではないことが判明し、再帰アルゴリズムを検討しました。しかし、ネストされたオートマトンの可能性はこれに限定されません。したがって、オートマトンプログラムの制御モデルを説明するとき、オートマトンの埋め込みのアイデアに基づいて、慣性アルゴリズムが決定されました。慣性アルゴリズムは、計算モデルの通常のブロック図のフレームワークでは想像するのが難しく、サブルーチンの呼び出しの前のポイントに制御を戻すことはできません。しかし、私は従来のオートマトンが「オンザフライ」での遷移の廃止を規定していることを言わなければなりません。それにもかかわらず、オートマトンの場合、これは想像できるだけでなく、実装することもできます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
慣性アルゴリズムとデジタル回路の論理モデリング関連トピック。そして、慣性遅延は検討中のアルゴリズムのクラスに名前を与えたのでそれほどではありませんが、慣性遅延の遅延されたアクションの意味は、それらの仕事の意味に転送されました。もちろん、名前ではありませんが。 UMLでは、同様のアルゴリズムが履歴状態の概念を使用して実装されます。類推は簡単ですが、UMLでのデジタル回路のモデリングは、原則として問題外です。出発点に戻るときの状況が、何かを強いられたとしても、それが最も自然なように見えるだけです。例としては、チケット購入の拒否、銀行業務/取引のキャンセル、ネットワーク接続の切断などがあります。等最後に、UMLで述べたように、歴史的状態を使用しなければ、そのようなアルゴリズムの実装はそれほど「美しい」とは言えません[1]。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デジタル回路の論理モデリングのトピックは、それ自体が広範囲で興味深いものです。</font><font style="vertical-align: inherit;">そして、新しい読書は彼女を傷つけません。</font><font style="vertical-align: inherit;">後で見るように、自動プログラミング技術は、デジタル回路を記述、実装、および論理的にモデリングするさらに高度な方法を提供できます。</font><font style="vertical-align: inherit;">主な目標を追求して、これをすべて同じように知るようになります-興味深い、有用で、そして最後に、オートマトンにとって自然であるが、他の計算モデルで実装するのは非常に難しいアルゴリズムの美しいクラスを検討します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.デジタル回路の論理モデリング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文献では通常、デジタル回路をモデル化する2つの方法、つまりコンパイルとイベントを検討しています。コンパイルは機能が制限されています。要素の遅延は考慮されず、要素のランク付けと重大なフィードバックが必要です[2]。イベントメソッドにはそのような制限はなく、回路内の信号値の変化に関連するイベントの追跡に基づいています。コンパイルは考慮しませんが、自動プログラミングの可能性のフレームワーク内で実装されたメソッドとイベントを比較することに焦点を当てます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、図2に示す[2]の回路を考えます。</font><font style="vertical-align: inherit;">1.ソースからの彼女の作品の図を図1に示します。</font><font style="vertical-align: inherit;">2. 2つのオプションが考慮されます。単一の遅延では、回路のロジックエレメントに同じ遅延があり、分散遅延では、エレメントBおよびEに残りの回路エレメントの2倍の遅延があります。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/u-/mg/yh/u-mgyhg9tqeh4oldjno11ikt2te.jpeg" alt="画像"></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。</font><font style="vertical-align: inherit;">1.回路の例。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/k6/qe/nz/k6qenzlg7wobazlumdv4rppvzsg.jpeg" alt="画像"></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。 2.モデリングの例：a-単一の遅延。 b-分散遅延。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動シミュレーション方式では、何かを発明する必要さえありません。回路と回路の関係を実装する構造を記述するための十分に具体的な言語を作成する必要はありません。また、回路のモデリングプロセスでイベントを検出するための十分に具体的なアルゴリズムを必要とせず、回路のフロー図を構築するための基礎として機能します（両方の説明については、[2]を参照） ）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オートマトンの場合、プログラム設計のオートマトンテクノロジで通常使用される論理要素モデルが最初に作成され、論理要素のライブラリ（BLE）に含まれます。次に、このライブラリに基づいて、回路要素の数に対応する一連の並列オートマトンプロセスが作成されます。その間に、論理要素モデルの入力/出力チャネルを使用して接続が示されます（このため、VKPA環境では、ローカルプロセス変数で十分です）。結論として、回路モデルは、入力信号のプロセスジェネレータと信号図を表示するプロセスによって補足されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VKPa環境で検討された例のシミュレーション結果。図4に示されています。 3は、図1の図と完全に一致しています。 2.確かに、そのような偶然を達成することはすぐには不可能でした。そして、モデルの問題のためではなく、実際には「科学的選択方法」が入力信号の持続時間を計算しなければならなかったためです。しかし、[2]では、これについても、入力信号のパラメーターについても一言も述べられていません。完全な一致は、1）遅延の3倍に等しい期間が必要であり、2）信号オフセット（b）信号に対する相対値（a）が単位遅延に等しいことを確認することで達成されました。この問題を説明するには、図を参照してください。図4は、入力信号のさまざまな期間の信号図を示しています（これは変位を考慮していません）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rk/dz/5v/rkdz5valiuegnrsj1nuefttvjkm.jpeg" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。</font><font style="vertical-align: inherit;">3.シミュレーションの結果はVKPaになります。a-単一の遅延。</font><font style="vertical-align: inherit;">b-分散遅延。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/2t/lt/xo2tlt0ya5dhzahwtgp4brpnzfs.jpeg" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。</font><font style="vertical-align: inherit;">4.異なる入力信号期間でのシミュレーション結果</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じソースからの回路の別の例を考えてみます[2]。</font><font style="vertical-align: inherit;">そのスキームと作業のタイミング図を図1に示します。</font><font style="vertical-align: inherit;">5.イベントメソッドのフレームワークでは、時間図を「計算」するために、20のシミュレーションステップが必要でした（詳細は[2]を参照）。</font><font style="vertical-align: inherit;">しかし、そこで述べられているように、慣性タイプの遅延が選択された場合、さらに複雑なアルゴリズム、したがって、さらに多くのステップが必要になります。</font><font style="vertical-align: inherit;">私たちの場合（自動モデリング方法の場合）には、前のモデルがあり、図20の図に移動するには、マウスで「20クリック」する必要があります。</font><font style="vertical-align: inherit;">5、元の回路の不要な要素を削除します。</font><font style="vertical-align: inherit;">VKPaで得られた回路シミュレーションの結果を図2に示します。</font><font style="vertical-align: inherit;">6。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/8g/td/oz/8gtdozhietrpsmgvvgpbm1lybda.jpeg" alt="画像"></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。</font><font style="vertical-align: inherit;">5.回路例とそのタイミングチャート。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、図 </font><font style="vertical-align: inherit;">5要素OR要素Iに平行に追加しました。図4のグラフd </font><font style="vertical-align: inherit;">図6は、単一遅延の場合の動作を示しています。</font><font style="vertical-align: inherit;">大きな遅延を設定し、慣性タイプの遅延を設定すると、グラフdは直線になります。</font><font style="vertical-align: inherit;">したがって、慣性遅延が1つの値よりも大きいAnd要素は、これらの入力信号aとbの組み合わせによって、その入力で生成されたパルスを見逃しません。</font><font style="vertical-align: inherit;">遅延のタイプの操作は、1より大きい遅延を持つ要素に対してのみ意味があることに注意してください。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/o4/co/56/o4co565-ssyy4dnfdoksswaz1iy.jpeg" alt="画像"></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。</font><font style="vertical-align: inherit;">6.図の回路のモデリング </font><font style="vertical-align: inherit;">5および要素And（d）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.ロジック要素の実装</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的なケースでは、論理要素は2つのブロックの直列接続として表すことができます（図7を参照）-遅延のない理想的な論理要素とブロックであり、伝搬遅延（輸送遅延）または慣性遅延と見なすことができます[2]。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ki/gk/ni/kigkniynpjwkh7nyotw56o4ui2e.jpeg" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。</font><font style="vertical-align: inherit;">7.遅延論理要素モデル。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理想的な論理要素は、通常の論理関数によって非常に単純に実装され、遅延ブロックモデルは、オートマトンモデル（輸送および慣性遅延を含むユニバーサルモデル）の形で表すことができます。</font><font style="vertical-align: inherit;">このような普遍的な遅延のモデルを図4に示します。</font><font style="vertical-align: inherit;">図8に、ネストされたオートマトンのモデルを図8に示します。</font><font style="vertical-align: inherit;">9. C ++および自動プログラミング技術の一部としてのそれらの実装をリスト1に示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gs/z9/r7/gsz9r7kql40rkgpvcehogmuvf9i.jpeg" alt="画像"></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。</font><font style="vertical-align: inherit;">8.ユニバーサルディレイのモデル。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rc/v2/12/rcv212u1o8mbvjwquzasma_tj1g.jpeg" alt="画像"></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図。 9.ユニバーサルディレイ用のネストされたオートマトンのモデル。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図の機械8と図9機はミリムーアのアサルトライフルを混合しています。図のメインオートマトンの操作8.ローカル変数を作成し、アクションy12で参照を初期化することから始めます（述語x12がこれをすべてチェックします）。中間状態「ss」は、述部x3が正しく機能するために必要です。これは、初期化されていない可能性がある入力変数へのリンクを持っています。 「ss」状態から、モデルは入れ子のオートマトンを引き起こしながら、遅延出力に対応する状態になります。オートマトンの状態でのアクション（ムーアオートマトンのアクション）は、ネストされたオートマトンの操作が完了した後にのみ開始されることに注意してください。最終的に、現在の遅延値と出力変数の状態を設定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクションy13、遅延値が定義されている場合、遅延のタイプに応じて必要なネストされたオートマトンを作成します。埋め込まれたトランスポート遅延オートマトンは、離散時間クロックサイクルの設定値をカウントするだけで（遅延の持続時間は離散クロックサイクルの数によって決定されます）、さらに慣性遅延が入力信号レベルを制御します。この場合、述語x3の戻り値はトップレベルのオートマトンの現在の状態に依存することに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図のオートマトンの実装 </font><font style="vertical-align: inherit;">8、9はリスト3を反映しています。コードを考えると、仮想メソッドf（）に注意する必要があります。仮想メソッドf（）は、重複する抽象論理関数を実装し、指定されている場合は逆に実行します。</font><font style="vertical-align: inherit;">これはすべて、論理要素の派生モデルの実装に必要です。</font><font style="vertical-align: inherit;">リスト2は、そのような論理要素AND-NOTの実装を示しています。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト1.ユニバーサル遅延ロジック要素の実装</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_DiscreteTime[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FDiscreteTime</span> :</span>											
	<span class="hljs-keyword">public</span> LFsaAppl											<font></font>
{													<font></font>
<span class="hljs-keyword">public</span>:													
    <span class="hljs-keyword">enum</span> {cvarINE, cvarExlusiveOR, cvarOrNot};
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MooreAction</span><span class="hljs-params">()</span></span>;
	<span class="hljs-function"><span class="hljs-keyword">bool</span>	<span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;								
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FDiscreteTime(nameFsa); }
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FInit</span><span class="hljs-params">()</span></span>;											<font></font>
    FDiscreteTime(<span class="hljs-built_in">string</span> strNam, LArc* pTBL = TBL_DiscreteTime);<font></font>
	~FDiscreteTime(<span class="hljs-keyword">void</span>);										<font></font>
	CVar *pVarType;		<span class="hljs-comment">// delay type 0-transport; 1- inertial</span>
	CVar *pVarX1;		<span class="hljs-comment">// input variable</span>
	CVar *pVarStrNameX1;	<span class="hljs-comment">// input variable name</span>
    	CVar *pVarIfNotX1;	<span class="hljs-comment">// inverse of the first input variable</span>
    	CVar *pVarY1;		<span class="hljs-comment">// output variable</span>
	CVar *pVarStrNameY1;	<span class="hljs-comment">// output variable name</span>
	CVar *pVarValue01;	<span class="hljs-comment">// delay value from 0 to 1</span>
	CVar *pVarValue10;	<span class="hljs-comment">// delay value from 1 to 0</span>
    	CVar *pVarNegationY;<span class="hljs-comment">// output inversion 0 - no inversion; 1- inversion</span>
    	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">x3</span><span class="hljs-params">()</span></span>;	<span class="hljs-comment">// input analysis</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span></span>;	<span class="hljs-comment">// link setup analysis</span>
    	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;
    	<span class="hljs-keyword">int</span> nTypeElement;
<span class="hljs-keyword">protected</span>:
<span class="hljs-comment">// predicates												</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>;
<span class="hljs-comment">// actions												</span>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y4</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y5</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y6</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y7</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y13</span><span class="hljs-params">()</span></span>; 
    <span class="hljs-keyword">bool</span> bType{<span class="hljs-literal">false</span>};	<span class="hljs-comment">// delay type: false - transport; true - inertial;</span>
    <span class="hljs-keyword">bool</span> bX1{<span class="hljs-literal">false</span>};
    <span class="hljs-keyword">int</span> nCurrent{<span class="hljs-number">0</span>};
    <span class="hljs-keyword">int</span> nDelay{<span class="hljs-number">0</span>};		<span class="hljs-comment">// tech. delay counter value</span>
    LFsaAppl	*pFCall{<span class="hljs-literal">nullptr</span>};
    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FCallTransport</span>;</span>
    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FCallInertial</span>;</span><font></font>
};		<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FCallTransport</span> :</span>
	<span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MooreAction</span><span class="hljs-params">()</span></span>;<font></font>
	FCallTransport(FDiscreteTime	*pFDiscreteTime);<font></font>
	FDiscreteTime	*pFDiscreteTime;<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FCallInertial</span> :</span>
	<span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MooreAction</span><span class="hljs-params">()</span></span>;<font></font>
	FCallInertial(FDiscreteTime	*pFDiscreteTime);<font></font>
	FDiscreteTime	*pFDiscreteTime;<font></font>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x3</span><span class="hljs-params">()</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FDiscreteTime.h"</span>											</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"VARFSA/SetVarFsaLibrary.h"</span></span>
<span class="hljs-comment">//=====================================================================</span>
<span class="hljs-comment">//		Delay model at the upper structural level of the view</span>
<span class="hljs-comment">//=====================================================================</span><font></font>
LArc TBL_DiscreteTime[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,	<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>),	<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,	<span class="hljs-string">"ss"</span>,<span class="hljs-string">"x12"</span>, <span class="hljs-string">"--"</span>),	<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"ss"</span>,	<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x3"</span>,  <span class="hljs-string">"y7y6y13"</span>),<span class="hljs-comment">// transition to a single state</span>
    LArc(<span class="hljs-string">"ss"</span>,	<span class="hljs-string">"s0"</span>,<span class="hljs-string">"^x3"</span>, <span class="hljs-string">"y4y5y13"</span>),<span class="hljs-comment">// transition to zero state</span>
<span class="hljs-comment">// creation of a nested automaton at the transition to a single state</span>
    LArc(<span class="hljs-string">"s0"</span>,	<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x3"</span>,  <span class="hljs-string">"y13"</span>),    
<span class="hljs-comment">// creation of a nested automaton at the transition to the zero state</span>
    LArc(<span class="hljs-string">"s1"</span>,	<span class="hljs-string">"s0"</span>,<span class="hljs-string">"^x3"</span>, <span class="hljs-string">"y13"</span>),    <font></font>
    LArc()<font></font>
};<font></font>
FDiscreteTime::FDiscreteTime(<span class="hljs-built_in">string</span> strNam, LArc* pTBL):<font></font>
    LFsaAppl(pTBL, strNam, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>)<font></font>
{ }<font></font>
													<font></font>
FDiscreteTime::~FDiscreteTime(<span class="hljs-keyword">void</span>) { <span class="hljs-keyword">if</span> (pFCall) <span class="hljs-keyword">delete</span> pFCall; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FDiscreteTime::FInit</span><span class="hljs-params">()</span> </span>{										<font></font>
    FCreationOfLinksForVariables();<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FDiscreteTime::FCreationOfLinksForVariables</span><span class="hljs-params">()</span>
</span>{
<span class="hljs-comment">// Local variables</span>
    pVarNegationY = CreateLocVar(<span class="hljs-string">"negation"</span>, CLocVar::vtBool, <span class="hljs-string">"output inversion: 0-without inversion / 1-inversion"</span>);<font></font>
    pVarType = CreateLocVar(<span class="hljs-string">"type"</span>, CLocVar::vtBool, <span class="hljs-string">"delay type: 0-transp / 1-inertia"</span>);<font></font>
    pVarY1 = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">"local output"</span>);<font></font>
    pVarX1 = CreateLocVar(<span class="hljs-string">"x1"</span>, CLocVar::vtBool, <span class="hljs-string">"local input"</span>);<font></font>
    pVarValue01 = CreateLocVar(<span class="hljs-string">"value to 1"</span>, CLocVar::vtInteger, <span class="hljs-string">"delay value from 0 to 1"</span>);<font></font>
    pVarValue10 = CreateLocVar(<span class="hljs-string">"value to 0"</span>, CLocVar::vtInteger, <span class="hljs-string">"delay value from 1 to 0"</span>);<font></font>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable (x)"</span>);<font></font>
    pVarStrNameY1 = CreateLocVar(<span class="hljs-string">"strNameY"</span>, CLocVar::vtString, <span class="hljs-string">"name of external output variable (y)"</span>);<font></font>
    pVarIfNotX1 = CreateLocVar(<span class="hljs-string">"not(x1)"</span>, CLocVar::vtBool, <span class="hljs-string">"1st input inversion: 0-without inversion / 1-inversion"</span>);
    <span class="hljs-built_in">string</span> str;<font></font>
    str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(pVarStrNameX1-&gt;strGetDataSrc().c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    str = pVarStrNameY1-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarY1 = pTAppCore-&gt;GetAddressVar(pVarStrNameY1-&gt;strGetDataSrc().c_str(), <span class="hljs-keyword">this</span>);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<span class="hljs-comment">// predicates</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FDiscreteTime::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> nCurrent == nDelay; }
<span class="hljs-comment">//  </span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FDiscreteTime::x3</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">bool</span>(pVarNegationY-&gt;GetDataSrc())) <span class="hljs-keyword">return</span> !f();
    <span class="hljs-keyword">return</span> f();<font></font>
}<font></font>
<span class="hljs-comment">//</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FDiscreteTime::x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span>; }
<span class="hljs-comment">//</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FDiscreteTime::f</span><span class="hljs-params">()</span> </span>{<font></font>
    bX1 = <span class="hljs-keyword">bool</span>(pVarX1-&gt;GetDataSrc());
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">bool</span>(pVarIfNotX1-&gt;GetDataSrc())) bX1 = !bX1;
    <span class="hljs-keyword">return</span> bX1;<font></font>
}<font></font>
<span class="hljs-comment">// actions</span>
<span class="hljs-comment">// +1 to the current delay value</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FDiscreteTime::y1</span><span class="hljs-params">()</span> </span>{ nCurrent++; }
<span class="hljs-comment">// setting the delay value when switching from 0 to 1</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FDiscreteTime::y4</span><span class="hljs-params">()</span> </span>{ nDelay = <span class="hljs-keyword">int</span>(pVarValue01-&gt;GetDataSrc()); }
<span class="hljs-comment">// setting output to zero</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FDiscreteTime::y5</span><span class="hljs-params">()</span> </span>{ pVarY1-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0.0</span>); }
<span class="hljs-comment">// setting output to unit</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FDiscreteTime::y6</span><span class="hljs-params">()</span> </span>{ pVarY1-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">1</span>); }
<span class="hljs-comment">// setting the delay value when switching from 1 to 0</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FDiscreteTime::y7</span><span class="hljs-params">()</span> </span>{ nDelay = <span class="hljs-keyword">int</span>(pVarValue10-&gt;GetDataSrc()); }
<span class="hljs-comment">//</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FDiscreteTime::y12</span><span class="hljs-params">()</span> </span>{ FInit(); }
<span class="hljs-comment">// creation, if a delay is determined, of the necessary nested automaton</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FDiscreteTime::y13</span><span class="hljs-params">()</span> </span>{<font></font>
	nCurrent = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">if</span> (pFCall) { <span class="hljs-keyword">delete</span> pFCall; pFCall = <span class="hljs-literal">nullptr</span>; }
	<span class="hljs-keyword">if</span> (x1()) <span class="hljs-keyword">return</span>;<font></font>
	bType = pVarType-&gt;GetDataSrc();		<span class="hljs-comment">// set delay type</span>
	<span class="hljs-keyword">if</span> (bType) pFCall = <span class="hljs-keyword">new</span> FCallInertial(<span class="hljs-keyword">this</span>);
	<span class="hljs-keyword">else</span> pFCall = <span class="hljs-keyword">new</span> FCallTransport(<span class="hljs-keyword">this</span>);
	<span class="hljs-keyword">if</span> (pFCall) pFCall-&gt;FCall(<span class="hljs-keyword">this</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FDiscreteTime::MooreAction</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-built_in">string</span> strState = FGetState();
	<span class="hljs-keyword">if</span> (strState==<span class="hljs-string">"s0"</span>)	{ <font></font>
        y4(); y5();		<span class="hljs-comment">// y4) setting the delay value when switching from 0 to 1; y5) set the output to zero</span><font></font>
    }<font></font>
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strState==<span class="hljs-string">"s1"</span>) { <font></font>
        y7(); y6();		<span class="hljs-comment">// y7) setting the delay value when switching from 1 to 0; y6) setting the output to one</span><font></font>
    }<font></font>
}<font></font>
<span class="hljs-comment">//=====================================================================</span>
<span class="hljs-comment">//				Transport delay</span>
<span class="hljs-comment">//=====================================================================</span>
<span class="hljs-keyword">static</span> LArc TBL_CallTransport[] = {<font></font>
	LArc(<span class="hljs-string">"s5"</span>,<span class="hljs-string">"s5"</span>,<span class="hljs-string">"^x1"</span>,	<span class="hljs-string">"--"</span>),		<span class="hljs-comment">//</span>
	LArc(<span class="hljs-string">"s5"</span>,<span class="hljs-string">"00"</span>,<span class="hljs-string">"x1"</span>,	<span class="hljs-string">"--"</span>),		<span class="hljs-comment">// </span><font></font>
	LArc()<font></font>
};<font></font>
<font></font>
FCallTransport::FCallTransport(FDiscreteTime	*pFI):<font></font>
    LFsaAppl(TBL_CallTransport, <span class="hljs-string">"FCallTransport"</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>)<font></font>
{<font></font>
	pFDiscreteTime = pFI;<font></font>
}<font></font>
<span class="hljs-comment">// . == </span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FCallTransport::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pFDiscreteTime-&gt;x1(); }
<span class="hljs-comment">//</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCallTransport::MooreAction</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-built_in">string</span> strState = FGetState();
	<span class="hljs-keyword">if</span> (strState==<span class="hljs-string">"s5"</span>)	{ pFDiscreteTime-&gt;y1(); }<font></font>
}<font></font>
<span class="hljs-comment">//=====================================================================</span>
<span class="hljs-comment">//				Inertial delay</span>
<span class="hljs-comment">//=====================================================================</span>
<span class="hljs-keyword">static</span> LArc TBL_CallInertial[] = {<font></font>
	LArc(<span class="hljs-string">"s5"</span>,	<span class="hljs-string">"s5"</span>,<span class="hljs-string">"^x1x3"</span>,	<span class="hljs-string">"--"</span>),		<span class="hljs-comment">//</span>
	LArc(<span class="hljs-string">"s5"</span>,	<span class="hljs-string">"00"</span>,<span class="hljs-string">"x1x3"</span>,	<span class="hljs-string">"--"</span>),		<span class="hljs-comment">//</span>
	LArc(<span class="hljs-string">"s5"</span>,	<span class="hljs-string">"XX"</span>,<span class="hljs-string">"^x3"</span>,	<span class="hljs-string">"--"</span>),		<span class="hljs-comment">//</span><font></font>
	LArc()<font></font>
};<font></font>
<font></font>
FCallInertial::FCallInertial(FDiscreteTime	*pFI):<font></font>
    LFsaAppl(TBL_CallInertial, <span class="hljs-string">"FCallInertial"</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>)<font></font>
{<font></font>
	pFDiscreteTime = pFI;<font></font>
}<font></font>
<span class="hljs-comment">// . == </span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FCallInertial::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pFDiscreteTime-&gt;x1(); }
<span class="hljs-comment">// input value (depends on the name of the current state of the main automaton)</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FCallInertial::x3</span><span class="hljs-params">()</span> </span>{
	<span class="hljs-built_in">string</span> strState = FGetStateUp();
	<span class="hljs-keyword">bool</span> bX = pFDiscreteTime-&gt;x3();
    <span class="hljs-keyword">if</span> (strState == <span class="hljs-string">"s0"</span>) <span class="hljs-keyword">return</span> bX;
    <span class="hljs-keyword">if</span> (strState == <span class="hljs-string">"s1"</span>) <span class="hljs-keyword">return</span> !bX;
	<span class="hljs-keyword">if</span> (strState == <span class="hljs-string">"st"</span>) {
		<span class="hljs-built_in">string</span> str = pFDiscreteTime-&gt;FGetNextState();<font></font>
		bX = pFDiscreteTime-&gt;x3();<font></font>
		<span class="hljs-keyword">if</span> (!bX) {
			<span class="hljs-keyword">if</span> (x1()) {
                <span class="hljs-keyword">if</span> (str == <span class="hljs-string">"s0"</span>) <span class="hljs-keyword">return</span> !bX;
                <span class="hljs-keyword">if</span> (str == <span class="hljs-string">"s1"</span>) <span class="hljs-keyword">return</span> bX;<font></font>
			}<font></font>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
		}<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
	}<font></font>
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> bX; <font></font>
}<font></font>
<span class="hljs-comment">//</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FCallInertial::MooreAction</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-built_in">string</span> strState = FGetState();
	<span class="hljs-keyword">if</span> (strState==<span class="hljs-string">"s5"</span>)	{ pFDiscreteTime-&gt;y1(); }<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト2. NANDゲートの実装</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"../FDiscreteTime.h"</span></span>
<span class="hljs-keyword">extern</span> LArc TBL_DiscreteTime[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FIne</span> :</span>
	<span class="hljs-keyword">public</span> FDiscreteTime<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span>	<span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> <span class="hljs-keyword">override</span> </span>{ Q_UNUSED(pCVF) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FIne(nameFsa); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FInit</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<font></font>
    FIne(<span class="hljs-built_in">string</span> strNam, LArc* TBL = TBL_DiscreteTime);<font></font>
    ~FIne(<span class="hljs-keyword">void</span>);<font></font>
	CVar *pVarX2;		<span class="hljs-comment">//  </span>
	CVar *pVarStrNameX2;	<span class="hljs-comment">//    </span>
	CVar *pVarIfNotX2;	<span class="hljs-comment">//    </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;
<span class="hljs-keyword">protected</span>:
    	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;
    	<span class="hljs-keyword">bool</span> bX2;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Ine/FIne.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"VARFSA/SetVarFsaLibrary.h"</span></span><font></font>
<font></font>
FIne::FIne(<span class="hljs-built_in">string</span> strNam, LArc* pTBL):<font></font>
    FDiscreteTime(strNam, pTBL)<font></font>
{<font></font>
    nTypeElement = FDiscreteTime::cvarINE;<font></font>
}<font></font>
<font></font>
FIne::~FIne(<span class="hljs-keyword">void</span>) { }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FIne::FInit</span><span class="hljs-params">()</span> </span>{										
<span class="hljs-comment">// 	 		</span><font></font>
	FCreationOfLinksForVariables();<font></font>
<span class="hljs-comment">//	 										</span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;										<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FIne::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">//  </span><font></font>
	FDiscreteTime::FCreationOfLinksForVariables();<font></font>
	<span class="hljs-comment">//      x1, x2</span>
    pVarIfNotX2 = CreateLocVar(<span class="hljs-string">"not(x2)"</span>, CLocVar::vtBool, <span class="hljs-string">" 2- : 0- /1-"</span>);<font></font>
	pVarX2 = CreateLocVar(<span class="hljs-string">"x2"</span>, CLocVar::vtBool, <span class="hljs-string">" 2- "</span>);
    <span class="hljs-comment">//  ,         x2</span>
	pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">"  2- .(x)"</span>);
	<span class="hljs-comment">// :   ,     </span>
    <span class="hljs-built_in">string</span> str = pVarStrNameX2-&gt;strGetDataSrc();
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(pVarStrNameX2-&gt;strGetDataSrc().c_str(), <span class="hljs-keyword">this</span>); }
<span class="hljs-comment">//</span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<span class="hljs-comment">//</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> FDiscreteTime::x12() &amp;&amp; pVarX2 != <span class="hljs-literal">nullptr</span>; }
<span class="hljs-comment">//</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FIne::f</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">//  1- </span><font></font>
    FDiscreteTime::f();<font></font>
    <span class="hljs-comment">//   </span>
    bX2 = <span class="hljs-keyword">bool</span>(pVarX2-&gt;GetDataSrc());
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">bool</span>(pVarIfNotX2-&gt;GetDataSrc())) bX2 = !bX2;
    <span class="hljs-comment">//   : </span>
    <span class="hljs-keyword">return</span> bX1&amp;&amp;bX2;<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOPのおかげで、論理要素ANDのモデルのコードは、「親」遅延のコードよりも著しく小さくなりません。</font><font style="vertical-align: inherit;">さらに、それは主にAND要素のモデルの追加入力を作成する必要性によって決定されます。</font><font style="vertical-align: inherit;">構造レベルで、モデルが入力/出力の数と一致する場合、コードはさらに小さくなります。</font><font style="vertical-align: inherit;">そのため、構造的に類似したAND-NOT要素のモデルから生成されたXORゲートの実装コードをリスト3に示します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト3.排他的ORゲートウェイの実装</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Ine/FIne.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_DiscreteTime[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FExlusiveOR</span> :</span>
    <span class="hljs-keyword">public</span> FIne<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FExlusiveOR(nameFsa); }<font></font>
    FExlusiveOR(<span class="hljs-built_in">string</span> strNam, LArc* TBL = TBL_DiscreteTime);<font></font>
    ~FExlusiveOR(<span class="hljs-keyword">void</span>);
<span class="hljs-keyword">protected</span>:												
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FExlusiveOR.h"</span></span><font></font>
<font></font>
FExlusiveOR::FExlusiveOR(<span class="hljs-built_in">string</span> strNam, LArc* pTBL):<font></font>
    FIne(strNam, pTBL)<font></font>
{<font></font>
    nTypeElement = FDiscreteTime::cvarExlusiveOR;<font></font>
}<font></font>
<font></font>
FExlusiveOR::~FExlusiveOR(<span class="hljs-keyword">void</span>) { }
<span class="hljs-comment">//</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FExlusiveOR::f</span><span class="hljs-params">()</span> </span>{<font></font>
    FIne::f();<font></font>
    <span class="hljs-keyword">return</span> (bX1&amp;&amp;bX2)||(!bX1&amp;&amp;!bX2);<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、FExlusiveORクラスのf（）メソッドは、FIneクラスのf（）メソッドを呼び出して入力変数の値を読み取り、NAND関数の値を新しいクラスの論理関数に従って計算された値とオーバーラップさせます。</font><font style="vertical-align: inherit;">画像や類似画像では、他の2入力ロジック要素のモデルを作成できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.結論 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
任意のデジタル回路を実装するには、いわゆる機能的に完全な論理要素のセットで十分です。たとえば、AND、OR、NOT要素のセットにすることができます。次の論理要素の実装について検討しました-インバーター、AND-NOT、EXCLUSIVE OR要素の場合がある遅延。それらは、機能的に完全なセットの一部である基本的な要素に関連しています。スキームを実装またはシミュレーション、あるいはその両方を行うには、ライブラリに追加する必要があります。たとえば、OR-NOT要素や、機能的に完全なセットの要素に構成されたユニバーサルカスタム要素を実装します。そして、すでにこれで十分でしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、上記のモデルに基づいて、VKPa環境では、デジタル回路の論理モデリングのための本格的な環境が提供されます。これにより、任意のライブラリ要素から任意の数のプロセスを生成し、それらを構成して、それらの間の接続を確立できます。同時に、シミュレーションはより詳細になり（すべてのタイプの遅延を考慮に入れて）、上記の2つの一般的な論理モデリング方法（コンパイルとイベント）の場合よりも柔軟（要素を個別に構成できます）になります。そしてそれは特別な環境ではありません、ソフトウェアプロセスのモデルは変更されず、C ++言語の使用に基づく他のオブジェクト指向プログラミング環境と同じくらい普遍的なままです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてもっと...痛い。むかしむかし、科学文献の問題に直面し、より正確には、RSトリガーなどの主要な論理要素の説明は読み書きができないだけでなく、クールなエレクトロニクスエンジニアでさえ、それがどのように機能するかを知らないという事実があります。トリガー、私はこれを理解するために多くの時間を費やしました。そして、私はトリガーの問題の現時点で、少なくとも私には空白のスポットがないことを報告できます（詳細[3]を参照）。そして、それゆえ、概して、何も変化していないことに驚かされるだけです。トリガーの表形式の説明は以前に与えられたので、悪名高い禁止状態があり、禁止状態から出るときのトリガーの予測できない切り替えについて不平を言ったので、今日もまだ示されています。そして、これにもかかわらずその動作の十分に正確な説明の例はすでに知られています（たとえば、[4]を参照）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本当に、「あなたの行いは素晴らしいです、主よ！」</font><font style="vertical-align: inherit;">いいえ、そのような「RSトリガー記述子」の頭には...自動プログラミングと、VKPa環境で論理回路をモデル化するための検討された方法があります。</font><font style="vertical-align: inherit;">そして、記事のトピックに戻ると、たとえば、NANDエレメントの上記のモデルを使用して、トリガーモデルを簡単に作成し、その動作を詳細にシミュレーションできます。</font><font style="vertical-align: inherit;">慣性タイプの遅延しかない実際のロジック要素のプロパティを考慮に入れることを含みます。</font><font style="vertical-align: inherit;">さて、トリガーのプロパティの正式な証明が必要な場合は、[5]に示されています。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文献</font></font></b><div class="spoiler_text">1.  .,  .,  .  UML.  .  .  : , 2007. – 493 .<br>
2.  .,  .,  .   : .  . – .: , 1988. – 309 .<br>
3.    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">habr.com/ru/post/484588</a> . . . (  07.01.2020).<br>
4.  .    . 2-  . – .: , 2004. – 432.<br>
5.  ..    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">cloud.mail.ru/public/HwsK/T95PMM8Ed</a> . . . (  01.02.2020).<br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja494860/index.html">コロナウイルスの検査用スティックの製造はどうですか</a></li>
<li><a href="../ja494862/index.html">Railsサービスのメモリを最適化します（実際のケース）</a></li>
<li><a href="../ja494864/index.html">自慢のポスト</a></li>
<li><a href="../ja494866/index.html">Elbrusの8ビットネットワーク、それは理にかなっていますか？</a></li>
<li><a href="../ja494868/index.html">なぜJavaScript IIFEの使用をやめるべきか</a></li>
<li><a href="../ja494878/index.html">外国語学校またはチューターの選び方</a></li>
<li><a href="../ja494880/index.html">Hyperledger Fabricチェーンコードの新しいソフトウェアモデル</a></li>
<li><a href="../ja494882/index.html">検疫後に新しい目を追わないためにすべきこと</a></li>
<li><a href="../ja494884/index.html">Digital Dictation 2020は3月28日から4月11日までオンラインで開催されます</a></li>
<li><a href="../ja494890/index.html">チャットルール</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>