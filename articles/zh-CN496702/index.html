<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌞 🥪 👈🏻 英特尔V系列FPGA中的PCI Express：接口基础和硬件核心功能 🤸🏼 📀 👋🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="介绍
 许多人熟悉的PCI Express或PCIe接口在数字技术刚刚开始普及时就已经可供FPGA系统的开发人员使用。这时，有一个解决方案，其中软件内核连接到外部物理级微电路[ 5 ]。这样就可以以每秒2.5 gigatransactions的速度创建单车道PCIe生产线。此外，由于技术的发展，接口...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>英特尔V系列FPGA中的PCI Express：接口基础和硬件核心功能</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496702/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介绍</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
许多人熟悉的PCI Express或PCIe接口在数字技术刚刚开始普及时就已经可供FPGA系统的开发人员使用。这时，有一个解决方案，其中软件内核连接到外部物理级微电路[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]。这样就可以以每秒2.5 gigatransactions的速度创建单车道PCIe生产线。此外，由于技术的发展，接口的物理层已迁移到FPGA本身内部的PCIe硬件模块。可能的通道数量增加到8，在新的微电路数量中增加到16；遵循现代标准，可能的数据传输速率已经增长。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同时，仍然很难在俄语语言中找到与现代FPGA的硬件内核一起使用的辅助材料； PCIe接口本身上没有太多信息。硬件PCI Express内核指南意味着开发人员已经熟悉该标准，并且了解该设备与个人计算机（PC）之间的数据传输基础。但是，PCIe标准本身中的大量信息不能立即理解必须采取哪些步骤才能成功地将数据从设备传输到PC存储器，反之亦然。为了获得更完整的图像，必须从各种来源一点一点地收集大量信息。对于英特尔FPGA系统的开发人员来说，困难也是大多数可用的材料和文章都描述了如何使用Xilinx FPGA硬件内核。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，作者将尝试讨论FPGA系统设计人员使用PCI Express接口时需要了解的内容。</font><font style="vertical-align: inherit;">将考虑使用Avalon-ST版本的Intel V系列硬件内核PCI Express FPGA的功能。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCIe级别和数据包类型</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管事实上PCI Express通常被称为总线，但实际上，该接口是由一组串行双工通道连接的设备网络。 PCI Express网络本身包含几个主要节点：根（Root），端点（Endpoint）和路由器（Switch）（图1）。要仅在两个设备之间传输数据，拥有一个根和一个端点就足够了。对于现代PC，网络根与中央处理器的核心位于一个基板上。无论PCIe根位于何处，它都与系统内存关联。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_c/hp/8v/_chp8va2uvyrgrc_pt0irj-wnrk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图1-PCIe网络</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PCIe数据传输协议分为三层：事务层，数据链路层和物理层。</font><font style="vertical-align: inherit;">接口数据以数据包的形式传输。</font><font style="vertical-align: inherit;">数据包的一般视图</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pe/eg/sa/peegsa43-ji_l00myvwxe8kt6tg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如图2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所示。</font><i><font style="vertical-align: inherit;">图2-PCIe数据包的一般视图</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在事务级别，任何数据包（TLP）至少包含一个标头。</font><font style="vertical-align: inherit;">根据包的类型，标头后可能跟有数据-包的有用内容。</font><font style="vertical-align: inherit;">也可以在包的末尾添加一个附加的校验和。</font><font style="vertical-align: inherit;">存在以下主要类型的事务级别数据包（表1）：</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表1-事务级别数据包的类型</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第p。</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包视图</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据规格的包装类型名称</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内存读取请求 </font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内存读取请求</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内存写入请求</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内存写入请求</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I / O空间读取请求</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I / O读取请求</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I / O空间写请求</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I / O写请求</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">读取配置请求</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置读取请求</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写入配置请求</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置写请求</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读反应</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成时间</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信息</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信息</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在链路层，将数据包序列号和链路校验和添加到每个事务级别数据包。</font><font style="vertical-align: inherit;">数据链路层还形成自己的数据包类型（DLLP），包括（表2）：</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表2-数据链路数据包类型</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第p。</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包视图</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据规格的包装类型名称</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交易级别包裹确认</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLP确认</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交易级别包裹拒绝</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLP纳克</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">能源管理</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">能源管理</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据流控制</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流量控制</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，物理层使用从IEEE 802.3标准借用的数据包开头和结尾的符号对数据包进行补充。</font><font style="vertical-align: inherit;">对于事务级别的数据包，分别使用符号K27.7和K29.7。</font><font style="vertical-align: inherit;">对于数据链路数据包，符号为K28.2和K29.7。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当使用FPGA硬件内核时，开发人员仅需要形成事务级别的数据包。</font><font style="vertical-align: inherit;">通道和物理层数据包由内核块形成。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事务级分组路由</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总的来说，不同类型的数据包可以通过三种方式从发送方到达接收方：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">路由到该地址； </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ID路由</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 间接路由。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
路由方法和事务级别数据包类型之间的关系如表3所示。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表3-路由方法和数据包类型的对应关系</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数</font></font></th>
<th> </th>
<th> </th>
</tr>
<tr>
<td>1</td>
<td>  </td>
<td>       . <br>
    I/O     I/O<br>
</td>
</tr>
<tr>
<td>2</td>
<td>  </td>
<td>     . <br>
    ID.<br>
  <br>
</td>
</tr>
<tr>
<td>3</td>
<td> </td>
<td>    ID</td>
</tr>
</tbody></table></div><br>
<h2>   .        </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个端点都有自己的配置空间，各种指令和状态寄存器位于其中。其中包括基地址寄存器或BAR。初始化端点时，BIOS或操作系统会扫描端点的BAR，以确定每个端点需要多少内存和空间。然后，在每个活动的BAR中，写入系统内存分配部分的起始地址。结果，端点获取了可以发送适当请求的地址。通常，在端点处形成一个寄存器映射，该映射与分配的存储区域相关。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而且，每个端点，或者更确切地说，是内部的逻辑设备，都将获得其唯一的标识符，该标识符由三部分组成：总线号，设备号，逻辑设备（功能）号。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样，系统具有足够的信息来与端点进行通信。但是，使用BAR中的查询传输数据的性能很差。首先，对于32位宽的BAR，可用请求长度被限制为一个双字（DWORD）。对于64位BAR，两个双字。其次，每个请求都在中央处理器的参与下发生。为了减轻中央处理器的负担，并增加每个程序包的大小，端点必须独立地将数据移入或移出系统内存。为此，端点必须知道它可以在哪个系统内存地址写入或读取数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
鉴于以上所述，端点与系统内存之间的一般数据传输方案可以表示如下：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">端点驱动程序在系统内存中分配用于写入数据的缓冲区； </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 驱动程序在系统内存中形成一组地址​​和缓冲区大小-用于写入数据的缓冲区描述符；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 端点驱动程序将描述符集的地址写入与BAR区域关联的设备寄存器；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">端点驱动器编程与BAR区域相关的数据传输控制寄存器； </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 端点发送请求以读取系统内存，以获得一组描述符以写入系统内存；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 端点向系统内存发送写请求，并填充存储缓冲区；</font></font></li>
<li>      /   ,    ,        ,  ;</li>
<li>                   PCIe. </li>
</ol><br>
<h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在驱动程序配置端点寄存器的阶段，根据与BAR关联的地址空间的类型，端点将收到对内存的写请求（图3）或对I / O空间的写请求。如果驱动程序在寄存器配置期间读取了一个寄存器，则端点还将接收相应的读取请求（图4）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/w0/_e/5o/w0_e5oqkd6yfw7uyv9vewkmokw4.png" alt="图片"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图3-写入1 DW长的存储器</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/ca/by/yk/cabyyk_ju4inqbsdevo3b-z3pma.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的请求示例图4-读取1 DW长的存储器的请求示例</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与写或读请求不同，I / O请求具有许多限制。首先，写入和读取请求都需要接收者的响应。这导致以下事实：使用对I / O空间的请求的数据传输速率变得比理论PCIe带宽所允许的要低得多。其次，I / O空间请求的地址限制为32位，这不允许访问超过4 GB的系统内存片段。第三，I / O空间请求不能超过一个双字，并且不能使用多个虚拟通道进行传输。由于这些原因，将不再考虑对I / O空间进行写入和读取的请求。尽管如此，用于写/读存储器和I / O空间的报头的内容仅在许多字段上有所不同，因此，图3、4所示的分组结构也适用于I / O空间中的请求。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当端点或PCIe根接收读取内存或I / O空间的请求时，设备必须发送响应。如果请求的发送者在一定时间内未收到响应，则将导致等待响应时出错。如果由于某种原因设备无法发送请求的数据，则它必须生成错误响应。可能的原因可能是：收件人不支持此请求（不支持的请求）；收件人尚未准备好接受配置请求，并请求稍后再重复配置请求（配置请求重试状态），发生内部错误，由于该错误，收件人无法响应并拒绝该请求（完成中止）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
图5、6中显示了对读取请求的成功响应和对不支持的请求的错误响应的格式。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gp/pl/y4/gpply4dawc8olvy6iyeipyeraos.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图5-成功响应读取的</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/3s/uw/bv/3suwbvjqkiqpoaogl9ewbnbixjq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示例图6-关于不支持的请求的答案的示例</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
端点访问4 GB以内的内存区域时，数据包头的格式与图3、4中所示的头没有区别。或读取超过4 GB的内存时，在标头中使用一个附加的双字，该字具有目标地址的高位。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rr/1o/w6/rr1ow6yxljdhqffy9gguw6v-3os.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图7-一个128字节写请求头的示例</font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">表4</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
给出了包头字段的缩写名称说明。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表4-头字段的缩写列表</font></font></i><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第p。</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现场指定</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">栏位名称</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">约定</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TC</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交通类别-交通类别</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定义虚拟频道成员</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atr</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性</font></font></td>
<td>   : , ,    ID,       ID.</td>
</tr>
<tr>
<td>3</td>
<td>TH</td>
<td>    ‒ TLP Processing Hint</td>
<td>,         [1..0]      .</td>
</tr>
<tr>
<td>4</td>
<td>TD</td>
<td>       ‒ TLP Digest</td>
<td>,          .</td>
</tr>
<tr>
<td>5</td>
<td>EP</td>
<td>    </td>
<td>,      .</td>
</tr>
<tr>
<td>6</td>
<td>AT</td>
<td>  ‒ Address Translation</td>
<td>,     :   ,  ,  </td>
</tr>
<tr>
<td>7</td>
<td>BE</td>
<td>        ‒ Byte Enable</td>
<td>         </td>
</tr>
<tr>
<td>8</td>
<td>PH</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包装处理提示-处理提示</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提示包裹接收者应该如何使用包裹以及数据结构</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BCM</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字节数的变化</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指示数据包中的字节数是否已更改。</font><font style="vertical-align: inherit;">只有面对PCI-X设备的发送者才能设置标志</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果端点使用中断来报告事件，则它还必须形成适当的数据包。</font><font style="vertical-align: inherit;">总体而言，PCIe可以使用三种类型的中断：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">旧式中断（传统中断或INT）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消息形式的中断（消息信号中断或MSI）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扩展消息中断（扩展消息信号中断或MSI-X）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
继承的INT中断用于与不支持消息中断的系统兼容。实际上，这种中断是一条消息（消息类型为Message的数据包），它模拟物理中断线路的操作。发生指定事件时，端点将消息发送到PCIe根，表明INT中断已被激活，然后等待中断处理程序采取措施。在中断处理程序执行指定的操作之前，INT中断处于激活状态。继承的中断不允许您确定事件的源，这迫使中断处理程序顺序扫描PCIe树中的所有端点以服务此中断。服务中断后，端点将发送一条消息，指出INT中断更不活跃。 FPGA硬件内核根据来自用户逻辑的信号独立生成INT中断所需的消息，因此将不考虑数据包结构。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
消息中断及其扩展版本是PCIe中主要和强制的中断类型。实际上，两种类型的中断都是一个长度为一个双字的写入系统内存的请求。与常规请求的区别在于，在系统配置阶段为每个设备分配了记录地址和包内容。在这种情况下，中央处理器内部的本地高级可编程中断控制器（LAPIC）成为目的地。使用这种类型的中断时，无需按顺序轮询PCIe树中的所有设备。此外，如果系统允许设备使用多个中断向量，则每个向量都可以与其自己的事件相关联。总之，这减少了处理器处理中断的时间，并提高了整体系统性能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSI中断最多可形成32个独立的向量。确切的数目取决于端点的功能。在这种情况下，系统可能只允许使用部分矢量。在配置阶段，系统将中断地址和用于写入的初始数据写入端点配置空间的特殊寄存器。所有活动中断使用相同的地址。但是对于每个向量，端点都会更改初始数据的位。例如，让一个端点最多支持4个中断向量，系统中允许所有4个向量，并且用于写入的初始数据为0x4970。然后，为形成第一个向量，端点将原始数据保持不变地传递。对于第二向量，设备更改第一位并发送数字0x4971。对于第三个和第四个向量，设备将分别发送数字0x4972和0x4973。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FPGA硬件内核通过来自用户逻辑的信号独立形成带有MSI中断的数据包。但是，在命令内核发送中断之前，用户逻辑还必须将所需向量的数据包内容提供给特殊的内核接口。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MSI-X中断最多可形成2048个单个向量。在配置空间的相应寄存器中，端点指示中断表（图8）和挂起的中断标志表（挂起的位数组-PBA，图9）位于BAR地址空间中的哪个位置以及与基址的偏移量为多少，以及两者的大小表。系统将单独的地址和数据写入中断表的每一行，并且还可以通过“向量控制”字段的第一位来允许或禁止使用特定的向量。对于给定的事件，端点在未决中断的标志表中设置一个标志。如果在“向量控制”字段中没有为此中断设置屏蔽，则端点将中断发送到中断表中的地址，其中包含数据包的指定内容。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zl/6q/el/zl6qelezf6aixg5qjw-rbeotwkc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图8-MSI-X中断向量表</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/q8/ms/as/q8msasscf-ytecdpefn-ohdjc1q.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图9-未决中断的标志表</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
FPGA硬件内核没有用于MSI-X中断的专用接口。</font><font style="vertical-align: inherit;">开发人员本人必须在用户逻辑中创建一个中断表和一个挂起的中断标志表。</font><font style="vertical-align: inherit;">中断包也完全由用户生成，并通过通用内核接口与其他类型的包一起传输。</font><font style="vertical-align: inherit;">如上所述，在这种情况下的分组格式对应于以一个双字的长度写入系统存储器的请求。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">英特尔Avalon-ST版的硬件核心PCI Express FPGA V系列的功能</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管来自不同制造商的PCI Express FPGA的硬件内核实现了相似的功能，但各个内核接口或它们的操作顺序可能会有所不同。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
英特尔V系列PCI Express FPGA硬件内核有两个版本：Avalon-MM和Avalon-ST。后者虽然需要开发人员付出更多的努力，但可以让您获得最大的带宽。因此，将不考虑具有Avalon-MM接口的内核。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
带有Avalon-ST接口的PCI Express核心文档充分描述了内核参数，输入和输出信号。但是，内核具有开发人员应注意的许多功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一组功能与允许您根据PCIe要求在100毫秒内配置FPGA的方法有关。除了并行加载FPP类型外，还为开发人员提供了诸如通过协议配置（CvP）和内核自主模式（自主模式）之类的方法。开发人员必须确保所选PCIe速度（“ Lane Rate”参数）支持通过协议或独立内核模式进行的配置。对于通过协议进行配置，可以在内核文档中找到相关信息。在脱机模式下，没有此类信息，因此您需要编译项目。如果当前内核速度不支持独立内核模式，则Quartus将生成相应的错误（图10）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xj/hy/ok/xjhyokbx1mvolf2dweiawoytyzk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图10-为离线模式编译PCIe内核时出错</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
如果开发人员计划通过协议使用配置，他还应该注意PCIe连接器连接到哪个FPGA内核。如果开发人员使用的不是成品板而是自己的设备，则尤其如此。在具有多个PCIe硬件内核的FPGA中，只有一个内核允许启用CvP。 FPGA文档中指出了具有CvP支持的内核位置。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二组功能与Avalon-ST数据传输接口本身有关。该接口用于在用户逻辑和内核之间传输事务级别的数据包。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在接收方，内核有两个信号允许用户暂停接收到的数据包的接收：rx_st_mask信号和rx_st_ready信号。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用rx_st_ready信号，开发人员可以暂停所有类型的数据包的输出。但是，如果激活此信号，则内核将仅在工作频率的两个时钟周期后停止数据包的输出。因此，在信号激活期间，用户逻辑必须准备好接收额外的数据量。例如，如果开发人员使用FIFO形式的缓冲区，则他应避免缓冲区溢出。否则，软件包中的某些内容将丢失。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用信号“ rx_st_mask”，开发人员中止发出必须发送答案的请求。该信号也不会立即停止数据包的输出。根据文档，激活信号后，内核最多可以发出10个请求。如果用户逻辑激活“ rx_st_mask”，并且缓冲区中没有足够的空间来处理接收到的数据包，则这也可能激活“ rx_st_ready”信号。在这种情况下，用户逻辑停止从内部硬件内核缓冲区读取任何数据包。这不仅使硬件内核缓冲区超载，而且违反了数据包顺序要求。设备必须先跳过不需要响应的请求，然后读取响应。否则，数据通道将被严格阻塞。因此，开发人员应使用额外的缓冲区来处理带有答案的请求，并且不允许逻辑阻塞更高优先级的数据包。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在发送端，tx_st_valid和tx_st_ready信号可能会引起问题。如果tx_st_ready信号处于活动状态，则禁止用户逻辑在传出数据包的中间重置tx_st_valid。这意味着在转让期间，开发人员必须提供包装的全部内容。如果数据源的速度比内核接口慢，则用户逻辑必须在程序包启动之前累积所需的数据量。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在接收方和发送方，开发人员都应注意数据包头和内容中的字节顺序以及数据对齐方式。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在硬件核心的Avalon-ST数据包中，在PCIe数据包标头内的每个双字中，字节从低到高依次排列；包装内容物-从最旧到最年轻。开发人员必须在传出数据包中使用类似的顺序，才能成功将数据从端点传输到根。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
硬件内核的Avalon-ST接口以64位的倍数对齐数据。根据Avalon-ST接口的宽度，事务级别数据包报头的长度和数据包地址，内核可能会在数据包报头及其内容之间添加一个空的双字。反过来，在传输数据时，用户逻辑必须类似于内核，预先添加一个空的双字。空双字在数据包长度中没有考虑，仅对于硬件内核的正确操作才是必需的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下一个功能与传入的读取响应有关。内核描述说，它不会丢失标识符与传出请求不匹配的传入响应。同时，用户逻辑应遵循响应的等待时间。如果超过了等待时间，则用户逻辑必须引发标志“ cpl_err [0]”或“ cpl_err [1]”。从文档中还不清楚当端点发送多个读取请求时过滤将如何工作。用户逻辑仅告诉内核其中一个请求的超时已到期，但无法将此请求的标识符传递给内核。内核可能会将超时的过期请求的响应发送到用户端。因此，开发人员必须为传入的响应创建自己的过滤器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，强烈鼓励开发人员使用有关可用贷款的信息以进行打包。</font><font style="vertical-align: inherit;">核心文档说这是没有必要的，因为内核会检查借贷并在没有足够借贷时阻止软件包。</font><font style="vertical-align: inherit;">但是，所有类型的程序包都通过单个接口到达内核。</font><font style="vertical-align: inherit;">如果内核数据包缓冲区溢出，则内核将tx_st_ready信号降低为零。</font><font style="vertical-align: inherit;">在tx_st_ready信号设置为1之前，用户逻辑原则上不能发送任何数据包。</font><font style="vertical-align: inherit;">可通过合作伙伴设备中的软件包更新可用贷款的数量。</font><font style="vertical-align: inherit;">如果用户的逻辑不仅经常写入，而且经常读取，那么内核更新限制计数器的速度就会下降。</font><font style="vertical-align: inherit;">最后，整体系统性能会受到影响。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文介绍了通过PCI Express进行数据传输的一般原理，主要数据包的格式。</font><font style="vertical-align: inherit;">尽管如此，作者还是省略了诸如虚拟通道，控制读取的传入响应的数量以及数据包的顺序等接口组件。</font><font style="vertical-align: inherit;">这些主题进行了详细的一些外国来源[讨论</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文还包括作者在使用接口控制器时遇到的Intel Express V系列FPGA FPGA硬件内核的功能。</font><font style="vertical-align: inherit;">这种经验可能对其他开发人员有用。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用的资料清单</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于每秒千兆字节数据传输的PCIe DMA架构/ L. Rota，M. Caselle等。</font><font style="vertical-align: inherit;">等 </font><font style="vertical-align: inherit;">// IEEE TRANSACTIONS ON NUCLEAR SCIENCE，VOL。</font><font style="vertical-align: inherit;">62号 </font><font style="vertical-align: inherit;">2015年6月3日。</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">An Efficient and Flexible Host-FPGA PCIe Communication Library / Jian Gong, Tao Wang, Jiahua Chen et. al. // 2014 24th International Conference on Field Programmable Logic and Applications.</a></li>
<li>Design and Implementation of a High-Speed Data Acquisition Card Based on PCIe Bus / Li Mu-guo, Huang Ying, Liu Yu-zhi // 《测控技术》2013年第32卷第7期。</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Down to the TLP: How PCI express devices talk (Part I) / Eli Billauer</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Low-Cost FPGA Solution for PCI Express Implementation / Intel Corporation.</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Managing Receive-Buffer Space for Inbound Completions / Xilinx // Virtex-7 FPGA Gen3 Integrated Block for PCI Express v4.3, Appendix B</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">PCIe Completion Timeout / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">PCIe packet in cyclone VI GX / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">PCIe simple transaction / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">PCIe w/ Avalon ST: Equivalent of ko_cpl_spc_vc0? / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Point me in the right Direction – PCIe / Altera Forum</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在PCIE / Altera论坛中请求超时</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非合作接收器验证平台基于PCIe的高速接口设计/李晓宁，姚远成，秦明伟// // 2016年机械，控制，电气，机电，信息和计算机国际会议</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCI Express基本规范修订版3.0 / PCI-SIG</font></font></a> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于PCIe解决方案的Stratix V Avalon-ST接口/英特尔公司 </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于PCIe解决方案的Cyclone V Avalon-ST接口/英特尔公司</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN496680/index.html">行业4.1：机器人所有权，神经网络和开源货币化</a></li>
<li><a href="../zh-CN496682/index.html">如何保持专业需求</a></li>
<li><a href="../zh-CN496686/index.html">流量分析系统如何通过MITER ATT＆CK检测黑客策略</a></li>
<li><a href="../zh-CN496690/index.html">冠状病毒控制技术</a></li>
<li><a href="../zh-CN496692/index.html">＃06-整个字节不足... | 平坦的天气</a></li>
<li><a href="../zh-CN496704/index.html">Saturn-5火箭的PCB-反向工程及其说明</a></li>
<li><a href="../zh-CN496706/index.html">周末阅读：音频格式的历史-盒式磁带的时代和语音合成技术的发展</a></li>
<li><a href="../zh-CN496708/index.html">太空枪，蒸汽火箭和轨道镜</a></li>
<li><a href="../zh-CN496710/index.html">计算机信息：简单快速</a></li>
<li><a href="../zh-CN496712/index.html">一次渗透，或如何在泌尿科医师和Roskomnadzor的帮助下打破一切</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>