<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ℹ️ 🧟 👈🏽 Widgets auf Android. Ein seltenes Merkmal, um es herauszufinden 🍋 🖖🏿 🧑🏽‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Mein Name ist Alexander Khakimov, ich bin ein Android-Entwickler bei FINCH. 
 
 Ist es passiert, dass Ihr Design für iOS war und Sie es fü...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Widgets auf Android. Ein seltenes Merkmal, um es herauszufinden</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492166/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font><font style="vertical-align: inherit;">Mein Name ist Alexander Khakimov, ich bin ein Android-Entwickler bei FINCH. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ist es passiert, dass Ihr Design für iOS war und Sie es für Android anpassen müssen? </font><font style="vertical-align: inherit;">Wenn ja, verwenden Ihre Designer häufig Widgets? </font><font style="vertical-align: inherit;">Leider ist ein Widget für viele Entwickler ein seltener Fall, da selten jemand damit arbeitet. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel werde ich Ihnen ausführlich erklären, wie Sie ein Widget erstellen, das es wert ist, beachtet zu werden und meinen Fall zu teilen.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget-Erstellung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ein Widget zu erstellen, müssen Sie Folgendes wissen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionen von Widget-Komponenten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionen zum Anzeigen des Widgets im Bildschirmraster.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bietet Widget-Updates.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden jeden Artikel separat analysieren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionen von Widget-Komponenten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder Entwickler, der mindestens einmal mit RemoteViews gearbeitet hat, ist mit diesem Element vertraut. </font><font style="vertical-align: inherit;">Wenn Sie einer von diesen sind, können Sie mit dem nächsten Punkt fortfahren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RemoteViews dient zum Beschreiben und Verwalten von Ansichtshierarchien, die zu einem Prozess in einer anderen Anwendung gehören. </font><font style="vertical-align: inherit;">Mithilfe der Hierarchieverwaltung können Sie Eigenschaften ändern oder Methoden aufrufen, die zur Ansicht gehören, die Teil einer anderen Anwendung ist. </font><font style="vertical-align: inherit;">RemoteViews enthält einen begrenzten Satz von Komponenten aus der Standardkomponentenbibliothek android.widget. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Anzeigen in Widgets funktioniert in einem separaten Prozess (normalerweise ist dies der Startbildschirm). Verwenden Sie daher zum Ändern der Benutzeroberfläche des Widgets die BroadcastReceiver-Erweiterung - AppWidgetProvider, die in unserer Anwendung funktioniert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionen zum Anzeigen des Widgets im "Raster" des Bildschirms</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Tat ist dieser Punkt nicht so kompliziert, wenn Sie sich die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offiziellen Richtlinien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ansehen </font><font style="vertical-align: inherit;">:</font></font><br>
 <blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes Widget muss eine minWidth und eine minHeight definieren, die angeben, wie viel Speicherplatz standardmäßig mindestens belegt werden soll. </font><font style="vertical-align: inherit;">Wenn Benutzer ihrem Startbildschirm ein Widget hinzufügen, belegt es im Allgemeinen mehr als die von Ihnen angegebene Mindestbreite und -höhe. </font><font style="vertical-align: inherit;">Android-Startbildschirme bieten Benutzern ein Raster verfügbarer Bereiche, in denen sie Widgets und Symbole platzieren können. </font><font style="vertical-align: inherit;">Dieses Raster kann je nach Gerät variieren. </font><font style="vertical-align: inherit;">Beispielsweise bieten viele Mobilteile ein 4x4-Raster und Tablets ein größeres 8x7-Raster.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Übersetzen ins Russische: Jedes Widget muss seine eigene Mindestbreite und -höhe festlegen, um den Mindestplatz anzugeben, den es standardmäßig belegt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6r/p-/ux/6rp-uxyfekjzwlpantqmxkdfaio.png" alt="Bild"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel für Widget-Einstellungen beim Erstellen in Android Studio Das</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Widget, das dem Startbildschirm hinzugefügt wurde, nimmt normalerweise mehr Platz ein als die von Ihnen festgelegte Mindestbreite und -höhe. Die Android-Startbildschirme bieten Benutzern ein Raster mit verfügbaren Bereichen, in denen sich Widgets und Symbole befinden können. Dieses Raster kann je nach Gerät variieren. Beispielsweise bieten viele Telefone 4x4-Raster und Tablets große 8x4-Raster.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daraus wird deutlich, dass das Raster des Geräts beliebig sein kann und die Zellengröße je nach Größe des Rasters variieren kann. </font><font style="vertical-align: inherit;">Dementsprechend sollte der Inhalt des Widgets unter Berücksichtigung dieser Funktionen gestaltet werden. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die minimale Breite und Höhe des Widgets für eine bestimmte Anzahl von Spalten und Zeilen kann mithilfe der folgenden Formel berechnet werden: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
minSideSizeDp = 70 × n - 30, wobei n die Anzahl der Zeilen oder Spalten ist </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
. Derzeit können Sie maximal 4x4 festlegen. </font><font style="vertical-align: inherit;">Dadurch wird sichergestellt, dass Ihr Widget auf allen Geräten angezeigt wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bietet Widget-Updates</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da AppWidgetProvider im Wesentlichen eine Erweiterung von BroadcastReceiver ist, können Sie damit dasselbe tun wie mit einem normalen BroadcastReceiver. AppWidgetProvider analysiert einfach die entsprechenden Felder aus der in onReceive empfangenen Absicht und ruft die Abfangmethoden mit den empfangenen Extras auf. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Schwierigkeit ergab sich aus der Häufigkeit der Aktualisierung des Inhalts - der springende Punkt ist der Unterschied im internen Betrieb von Widgets unter iOS und Android. Tatsache ist, dass Daten in iOS-Widgets aktualisiert werden, wenn das Widget für den Benutzer sichtbar wird. In Android existiert ein solches Ereignis nicht. Wir können nicht herausfinden, wann der Benutzer das Widget sieht.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für Widgets unter Android ist die empfohlene Aktualisierungsmethode ein Timer-Update. </font><font style="vertical-align: inherit;">Die Timer-Einstellungen werden über den Widget-Parameter updatePeriodMillis festgelegt. </font><font style="vertical-align: inherit;">Leider erlaubt diese Einstellung nicht, das Widget mehr als einmal alle 30 Minuten zu aktualisieren. </font><font style="vertical-align: inherit;">Im Folgenden werde ich näher darauf eingehen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget-Fall</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weiter werden wir über den Fall sprechen, den wir bei FINCH in einem großen Lotterieantrag mit dem Stoloto-Antrag auf Teilnahme an staatlichen Lotterien hatten. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aufgabe des Antrags besteht darin, die Auswahl einer Lotterie und den Kauf eines Tickets für den Benutzer zu vereinfachen und transparent zu machen. </font><font style="vertical-align: inherit;">Daher ist die erforderliche Funktionalität des Widgets recht einfach: Zeigen Sie den vom Benutzer empfohlenen Spielen zum Kauf an und tippen Sie auf, um zum entsprechenden zu gelangen. </font><font style="vertical-align: inherit;">Die Liste der Spiele wird auf dem Server ermittelt und regelmäßig aktualisiert. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Fall enthielt das Widget-Design zwei Zustände:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für autorisierte Benutzer</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für einen nicht autorisierten Benutzer</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein autorisierter Benutzer muss seine Profildaten anzeigen: den Status der internen Brieftasche, die Anzahl der Tickets, die auf die Ziehung warten, und die Anzahl der verlorenen Gewinne. </font><font style="vertical-align: inherit;">Für jedes dieser Elemente wird ein Übergang zum Bildschirm innerhalb der Anwendung bereitgestellt, der sich von den anderen unterscheidet. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rp/d2/6i/rpd26ixtdxfjopibvmgaaczfkco.png" alt="Bild"><br>
<br>
<img src="https://habrastorage.org/webt/dk/yy/qx/dkyyqxqcnopxezwhknrmqbuedgu.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie vielleicht bemerkt haben, ist eine weitere Funktion für einen autorisierten Benutzer die Schaltfläche "Aktualisieren", aber dazu später mehr. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Anzeige von zwei Zuständen unter Berücksichtigung des Designs zu implementieren, habe ich den RemoteAdapter als Implementierung von RemoteViewsService verwendet, um Inhaltskarten zu generieren. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt ein kleiner Code und wie alles drinnen funktioniert. </font><font style="vertical-align: inherit;">Wenn Sie bereits Erfahrung mit dem Widget haben, wissen Sie, dass jede Aktualisierung der Widgetdaten mit der onUpdate-Methode beginnt:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onUpdate</span><span class="hljs-params">(
        context: <span class="hljs-type">Context</span>,
        appWidgetManager: <span class="hljs-type">AppWidgetManager</span>,
        appWidgetIds: <span class="hljs-type">IntArray</span>
    )</span></span> {<font></font>
        injector.openScope(<span class="hljs-keyword">this</span>, *arrayOf(<span class="hljs-keyword">this</span>))
        <span class="hljs-comment">// update each of the widgets with the remote adapter</span><font></font>
        appWidgetIds<font></font>
            .forEach {<font></font>
                updateWidget(context, appWidgetManager, it)<font></font>
          }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir schreiben ein Update für jede Instanz unseres Widgets.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateWidget</span><span class="hljs-params">(
        context: <span class="hljs-type">Context</span>,
        appWidgetManager: <span class="hljs-type">AppWidgetManager</span>,
        appWidgetId: <span class="hljs-type">Int</span>
    )</span></span> {
<span class="hljs-comment">// remoteViews   widgetId</span>
        <span class="hljs-keyword">val</span> remoteViews = RemoteViews(<font></font>
            context.packageName,<font></font>
            R.layout.app_widget_layout<font></font>
...<font></font>
<span class="hljs-comment">//        </span><font></font>
...<font></font>
<span class="hljs-comment">//    remoteViews</span><font></font>
updateRemoteAdapter(context, remoteViews, appWidgetId)<font></font>
 <font></font>
<span class="hljs-comment">//   remoteViews </span><font></font>
appWidgetManager.updateAppWidget(appWidgetId, remoteViews)<font></font>
<span class="hljs-comment">// collection view  </span><font></font>
appWidgetManager.notifyAppWidgetViewDataChanged(<font></font>
            appWidgetId,<font></font>
            R.id.lvWidgetItems<font></font>
        )<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adapter aktualisieren.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateRemoteAdapter</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, remoteViews: <span class="hljs-type">RemoteViews</span>, appWidgetId: <span class="hljs-type">Int</span>)</span></span> {
<span class="hljs-comment">//   RemoteViewsService   RemoteAdapter   </span>
        <span class="hljs-keyword">val</span> adapterIntent = Intent(context, StolotoAppWidgetRemoteViewsService::<span class="hljs-keyword">class</span>.java).apply {<font></font>
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)<font></font>
        }<font></font>
        remoteViews.setRemoteAdapter(R.id.lvWidgetItems, adapterIntent)<font></font>
// actionIntent  pendingIntent      <font></font>
        <span class="hljs-keyword">val</span> actionIntent = Intent(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java).apply {<font></font>
            action = WIDGET_CLICK_ACTION<font></font>
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)<font></font>
        }<font></font>
        <span class="hljs-keyword">val</span> pendingIntent = PendingIntent.getBroadcast(<font></font>
            context, <span class="hljs-number">0</span>, actionIntent,<font></font>
            PendingIntent.FLAG_UPDATE_CURRENT<font></font>
        )<font></font>
<span class="hljs-comment">// pendingIntent      </span><font></font>
        remoteViews.setPendingIntentTemplate(R.id.lvWidgetItems, pendingIntent)<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir schreiben die Implementierung unseres Service. </font><font style="vertical-align: inherit;">Darin ist es wichtig anzugeben, welche Implementierung der RemoteViewsService.RemoteViewsFactory-Schnittstelle zum Generieren von Inhalten verwendet werden soll.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StolotoAppWidgetRemoteViewsService</span> : <span class="hljs-type">RemoteViewsService</span></span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onGetViewFactory</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>)</span></span>: RemoteViewsFactory =<font></font>
        StolotoAppWidgetRemoteViewsFactory(<font></font>
            <span class="hljs-keyword">this</span>.applicationContext,<font></font>
            intent<font></font>
        )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist eigentlich eine dünne Hülle über dem Adapter. </font><font style="vertical-align: inherit;">Dank ihm können wir unsere Daten mit der Remote-Erfassungsansicht verknüpfen. </font><font style="vertical-align: inherit;">RemoteViewsFactory bietet Methoden zum Generieren von RemoteViews für jedes Element im Dataset. </font><font style="vertical-align: inherit;">Der Konstruktor hat keine Anforderungen - alles, was ich tue, ist, den Kontext darin zu übergeben. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes ein paar Worte zu den wichtigsten Methoden:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onCreate - Erstellen eines Adapters.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getLoadingView - Die Methode schlägt vor, die Ansicht zurückzugeben, die das System während der Erstellung anstelle der Listenelemente anzeigt. </font><font style="vertical-align: inherit;">Wenn Sie hier nichts erstellen, verwendet das System eine Standardansicht.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getViewAt - Die Methode schlägt vor, Listenelemente zu erstellen. </font><font style="vertical-align: inherit;">Hier kommt die Standardverwendung von RemoteViews.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onDataSetChanged wird aufgerufen, wenn eine Anforderung zum Aktualisieren der Daten in der Liste empfangen wird. </font><font style="vertical-align: inherit;">Jene. </font><font style="vertical-align: inherit;">Bei dieser Methode bereiten wir die Daten für die Liste vor. </font><font style="vertical-align: inherit;">Die Methode wird durch die Ausführung von schwerem, langem Code geschärft.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onDestroy wird aufgerufen, wenn die zuletzt verwendete Liste des Adapters gelöscht wird (ein Adapter kann von mehreren Listen verwendet werden).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RemoteViewsFactory lebt, während alle Instanzen der Liste aktiv sind, sodass wir aktuelle Daten darin speichern können, z. B. eine Liste aktueller Elemente.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Definieren Sie eine Liste der Daten, die angezeigt werden sollen:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> widgetItems = ArrayList&lt;WidgetItem&gt;()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Erstellen des Adapters beginnen wir mit dem Laden der Daten. </font><font style="vertical-align: inherit;">Hier können Sie alle schwierigen Aufgaben sicher ausführen, einschließlich des leisen Gehens in das Netzwerk, das den Fluss blockiert.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
        updateDataSync()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir den Befehl zum Aktualisieren von Daten aufrufen, rufen wir auch updateDataSync () auf.</font></font><br>
<br>
<pre><code class="kotlin hljs">   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDataSetChanged</span><span class="hljs-params">()</span></span> {<font></font>
        updateDataSync()<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In updateDataSync ist auch alles einfach. </font><font style="vertical-align: inherit;">Wir löschen die aktuelle Liste der Elemente. </font><font style="vertical-align: inherit;">Laden Sie Profil- und Spieldaten herunter.</font></font><br>
<br>
<pre><code class="kotlin hljs"> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateDataSync</span><span class="hljs-params">()</span></span> {<font></font>
        widgetItems.clear()<font></font>
        updateProfileSync()<font></font>
        updateGamesSync()<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist es interessanter</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateProfileSync</span><span class="hljs-params">()</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da es für uns wichtig ist, das Profil nur einem autorisierten Benutzer anzuzeigen, müssen wir die Profilinformationen nur in diesem Fall herunterladen:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> isUserFullAuth = isUserFullAuthInteractor<font></font>
            .execute()<font></font>
            .blockingGet()<font></font>
        <span class="hljs-keyword">if</span> (isUserFullAuth) {
            <span class="hljs-keyword">val</span> profile = getWidgetProfileInteractor<font></font>
                .execute()<font></font>
                .onErrorReturn {<font></font>
                    WidgetProfile()<font></font>
<span class="hljs-comment">//           </span><font></font>
                }<font></font>
                .blockingGet()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das WidgetProfile-Modell wird aus verschiedenen Quellen zusammengestellt, sodass die Logik ihres Empfangs und seine Standardwerte so angeordnet sind, dass ein negativer Brieftaschenwert auf falsche Daten oder Probleme mit dem Empfang hinweist. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für die Geschäftslogik ist das Fehlen von Brieftaschendaten von entscheidender Bedeutung. Im Falle einer falschen Brieftasche wird daher kein Profilmodell erstellt und der Liste der Elemente hinzugefügt.</font></font><br>
<br>
<pre><code class="kotlin hljs">  <span class="hljs-keyword">if</span> (profile.walletAmount &gt;= <span class="hljs-number">0L</span>) {<font></font>
                widgetItems.add(<font></font>
                    WidgetItem.Profile(<font></font>
                        wallet = profile.walletAmount.toMoneyFormat(),<font></font>
                        waitingTickets = <span class="hljs-keyword">if</span> (profile.waitingTicketsCount &gt;= <span class="hljs-number">0</span>) profile.waitingTicketsCount.toString() <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>,<font></font>
                        unpaidPrizeAmount = <span class="hljs-keyword">if</span> (profile.unpaidPrizeAmount &gt;= <span class="hljs-number">0</span>) profile.unpaidPrizeAmoount.toMoneyFormat() <span class="hljs-keyword">else</span> <span class="hljs-string">""</span><font></font>
                    )<font></font>
                )<font></font>
            }<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die updateGamesSync () -Methode verwendet getWidgetGamesInteractor und fügt der WidgetItems-Liste eine Reihe von Spielen hinzu, die für das Widget relevant sind. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor Sie mit der Kartengenerierung fortfahren, sollten Sie das WidgetItem-Modell genauer betrachten. </font><font style="vertical-align: inherit;">Die Implementierung erfolgt über die versiegelte Kotlin-Klasse, wodurch das Modell flexibler wird und die Arbeit damit bequemer ist.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetItem</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Profile</span></span>(
        <span class="hljs-keyword">val</span> wallet: String,
        <span class="hljs-keyword">val</span> waitingTickets: String,
        <span class="hljs-keyword">val</span> unpaidPrizeAmount: String<font></font>
    ) : WidgetItem()<font></font>
 <font></font>
    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span></span>(
        <span class="hljs-keyword">val</span> id: String,
        <span class="hljs-keyword">val</span> iconId: <span class="hljs-built_in">Int</span>,
        <span class="hljs-keyword">val</span> prizeValue: String,
        <span class="hljs-keyword">val</span> date: String<font></font>
    ) : WidgetItem()<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie RemoteViews und bestimmen Sie deren Antwort über FillInIntent</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getViewAt</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span>: RemoteViews {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> item = widgetItems[position]) {
            <span class="hljs-keyword">is</span> WidgetItem.Profile -&gt; {<font></font>
              RemoteViews(<font></font>
                        context.packageName,<font></font>
                        R.layout.item_widget_user_profile<font></font>
                    ).apply {<font></font>
                        setTextViewText(R.id.tvWidgetWalletMoney, item.wallet)<font></font>
                        setTextViewText(R.id.tvWidgetUnpaidCount, item.unpaidPrizeAmount)<font></font>
                        setTextViewText(R.id.tvWidgetWaitingCount, item.waitingTickets)<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileWallet, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_USER_WALLET<font></font>
                            )<font></font>
                        )<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileUnpaid, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_UNPAID_PRIZE<font></font>
                            )<font></font>
                        )<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileWaiting, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_WAITING_TICKETS<font></font>
                            )<font></font>
                        )<font></font>
                    }<font></font>
 <font></font>
            <span class="hljs-keyword">is</span> WidgetItem.Game -&gt; {<font></font>
                RemoteViews(<font></font>
                    context.packageName,<font></font>
                    R.layout.item_widget_game<font></font>
                ).apply {<font></font>
                    setImageViewResource(R.id.ivWidgetGame, item.iconId)<font></font>
                    setTextViewText(R.id.tvWidgetGamePrize, item.prizeValue)<font></font>
                    setTextViewText(R.id.tvWidgetGameDate, item.date)<font></font>
                    setOnClickFillInIntent(<font></font>
                        R.id.llWidgetGame, Intent().putExtra(<font></font>
                            StolotoAppWidgetProvider.KEY_GAME_CLICK, item.id<font></font>
                        )<font></font>
                    )<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die setOnClickFillInIntent-Methode weist die angegebene viewId-Absicht zu, die mit dem übergeordneten PendingIntent kombiniert wird, um das Verhalten beim Klicken auf die Ansicht mit dieser viewId zu bestimmen. </font><font style="vertical-align: inherit;">Auf diese Weise können wir auf Benutzerklicks in unserem WidgetProvider reagieren.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manuelles Widget-Update</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für unser Widget wurde eine Aktualisierungszeit von einer halben Stunde festgelegt. Sie können es häufiger aktualisieren, indem Sie beispielsweise mit WorkManager tanzen. Warum sollten Sie jedoch Ihr Netzwerk und Ihren Akku laden? Ein solches Verhalten in den frühen Entwicklungsstadien schien angemessen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles änderte sich, als das „Unternehmen“ bemerkte, dass beim Betrachten des Widgets die irrelevanten Daten darauf angezeigt werden: „Hier auf meinem iPhone öffne ich das Widget und es gibt die MEISTEN frischen Daten meines Profils.“ </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Situation ist alltäglich: iOS generiert neue Karten für JEDE Widget-Anzeige, da sie dafür einen speziellen Bildschirm haben und Android solche Ereignisse für das Widget im Prinzip nicht hat. Ich musste berücksichtigen, dass einige Lotterien alle 15 Minuten stattfinden, daher sollte das Widget aktuelle Informationen liefern - Sie möchten an einer Verlosung teilnehmen, diese ist jedoch bereits abgelaufen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um aus dieser unangenehmen Situation herauszukommen und das Problem mit der Aktualisierung der Daten irgendwie zu lösen, habe ich eine bewährte Lösung vorgeschlagen und implementiert - die Schaltfläche „Aktualisieren“. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen Sie diese Schaltfläche dem Layout-Layout mit der Liste hinzu und initialisieren Sie das Verhalten beim Aufruf von updateWidget.</font></font><br>
<br>
<pre><code class="kotlin hljs">...
<span class="hljs-comment">// Intent   AppWidgetManager.ACTION_APPWIDGET_UPDATE</span>
<span class="hljs-keyword">val</span> intentUpdate = Intent(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java)<font></font>
intentUpdate.action = AppWidgetManager.ACTION_APPWIDGET_UPDATE<font></font>
<font></font>
//    <font></font>
<span class="hljs-keyword">val</span> ids = AppWidgetManager.getInstance(context)<font></font>
   .getAppWidgetIds(ComponentName(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java))<font></font>
intentUpdate.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, ids)<font></font>
<font></font>
//  intent  PendingIntent,  PendingIntent.getBroadcast()<font></font>
<span class="hljs-keyword">val</span> pendingUpdate = PendingIntent.getBroadcast(<font></font>
   context,<font></font>
   appWidgetId,<font></font>
   intentUpdate,<font></font>
   PendingIntent.FLAG_UPDATE_CURRENT<font></font>
)<font></font>
//  pendingIntent      ‘’<font></font>
remoteViews.setOnClickPendingIntent(R.id.ivWidgetRefresh, pendingUpdate)<font></font>
…</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten Entwicklungen zeigten ein trauriges Bild: Vom Drücken der Schaltfläche "Aktualisieren" bis zum eigentlichen Update konnten einige Sekunden vergehen. </font><font style="vertical-align: inherit;">Obwohl das Widget von unserer Anwendung generiert wird, unterliegt es tatsächlich der Kontrolle des Systems und kommuniziert mit unserer Anwendung über Broadcasts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jene. </font><font style="vertical-align: inherit;">Wenn Sie auf die Schaltfläche "Aktualisieren" unseres Widgets klicken, beginnt die Kette:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Holen Sie sich die Absicht in die onReceive-Provider-Aktion.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppWidgetManager.ACTION_APPWIDGET_UPDATE. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rufen Sie onUpdate für alle in intent-e angegebenen WidgetsIds auf.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gehen Sie online für neue Daten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisieren Sie lokale Daten und zeigen Sie neue Listenkarten an.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen sah das Aktualisieren des Widgets nicht besonders gut aus, da wir durch Klicken auf die Schaltfläche einige Sekunden lang dasselbe Widget angesehen haben. </font><font style="vertical-align: inherit;">Es war unklar, ob die Daten aktualisiert wurden. </font><font style="vertical-align: inherit;">Wie kann man das Problem der visuellen Reaktion lösen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst habe ich das isWidgetLoading-Flag mit globalem Zugriff über den Interaktor hinzugefügt. </font><font style="vertical-align: inherit;">Die Rolle dieses Parameters ist recht einfach: Zeigen Sie die Schaltfläche "Aktualisieren" nicht an, während die Widgetdaten geladen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens habe ich den Datenladevorgang in der Fabrik in drei Phasen unterteilt:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadingStep</span> </span>{<font></font>
   START,<font></font>
   MIDDLE,<font></font>
   END<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
START - Start des Downloads. </font><font style="vertical-align: inherit;">Zu diesem Zeitpunkt ändert sich der Status aller Adapteransichten und das globale Download-Flag in "Laden". </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MITTEL - die Phase des Ladens der Hauptdaten. </font><font style="vertical-align: inherit;">Nach dem Herunterladen wird das globale Download-Flag in den Status "geladen" versetzt und die heruntergeladenen Daten werden im Adapter angezeigt. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ENDE - Ende des Downloads. </font><font style="vertical-align: inherit;">Der Adapter muss in diesem Schritt die Adapterdaten nicht ändern. </font><font style="vertical-align: inherit;">Dieser Schritt ist erforderlich, um die Aktualisierungsphase der Ansichten in WidgetProvider korrekt zu verarbeiten. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sehen wir uns genauer an, wie das Button-Update im Provider aussieht:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">if</span> (isFullAuthorized &amp;&amp; !widgetLoadingStateInteractor.isWidgetLoading) {<font></font>
   remoteViews.setViewVisibility(R.id.ivWidgetRefresh, View.VISIBLE)<font></font>
...<font></font>
<span class="hljs-comment">//     ,    </span><font></font>
...   <font></font>
} <span class="hljs-keyword">else</span> {<font></font>
   remoteViews.setViewVisibility(<font></font>
       R.id.ivWidgetRefresh,<font></font>
       <span class="hljs-keyword">if</span> (isFullAuthorized) View.INVISIBLE <span class="hljs-keyword">else</span> View.GONE <span class="hljs-comment">//       .</span><font></font>
   )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns nun an, was im Adapter passiert:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateDataSync</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">when</span> (loadingStep) {<font></font>
       START -&gt; {<font></font>
           widgetItems.forEach { it.isLoading = <span class="hljs-literal">true</span> }<font></font>
           widgetLoadingStateInteractor.isWidgetLoading = <span class="hljs-literal">true</span><font></font>
           loadingStep = MIDDLE<font></font>
           widgetManager.updateWidgets()<font></font>
       }<font></font>
       MIDDLE -&gt; {<font></font>
           widgetItems.clear()<font></font>
           updateProfileSync()<font></font>
           updateGamesSync()<font></font>
           widgetLoadingStateInteractor.isWidgetLoading = <span class="hljs-literal">false</span><font></font>
           loadingStep = END<font></font>
           widgetManager.updateWidgets()<font></font>
       }<font></font>
       END -&gt; {<font></font>
           loadingStep = START<font></font>
       }<font></font>
   }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/bq/ah/hg/bqahhgnwugy10345-bcegnupxo8.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Logik der Arbeit: </font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Ende der Schritte START und MIDDLE rufe ich die updateWidgets-Methode auf, um den vom Anbieter verwalteten Ansichtsstatus zu aktualisieren.</font></font></li>
<li>   START     «»   ,    MIDDLE.</li>
<li>         MIDDLE,    «».</li>
<li>   MIDDLE,          END. </li>
<li>      ,   END,    «».        ,    END   loadingStep  START.</li>
</ol><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Hilfe einer solchen Implementierung habe ich einen Kompromiss zwischen der Anforderung des "Unternehmens", die tatsächlichen Daten im Widget anzuzeigen, und der Notwendigkeit, das Update zu oft "abzurufen", erzielt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, der Artikel hat Ihnen geholfen. </font><font style="vertical-align: inherit;">Wenn Sie Erfahrung mit der Erstellung von Widgets für Android haben, teilen Sie uns dies in den Kommentaren mit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viel Glück</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de492150/index.html">Implementieren Sie es vollständig. Di-in-js</a></li>
<li><a href="../de492154/index.html">Der Start von ExoMars verzögerte sich auf das nächste Startfenster im Jahr 2022</a></li>
<li><a href="../de492156/index.html">Subtrahiert. Wollen. Tun</a></li>
<li><a href="../de492162/index.html">Augenschnittstellen. Bericht in Yandex</a></li>
<li><a href="../de492164/index.html">Tor zum Himmel oder zur Stadt der Zukunft</a></li>
<li><a href="../de492168/index.html">Frontarbeit an der Backend-Entwicklung der größten Portale für Open Source-Software: Erfahrungsaustausch</a></li>
<li><a href="../de492172/index.html">Dünne Sicherung von Linux-Dateisystemen. So erstellen Sie in 20 Sekunden Arbeitskopien eines MySQL-DBMS mit drei Terabyte</a></li>
<li><a href="../de492174/index.html">Drahtloser DIY Bodenfeuchtemonitor</a></li>
<li><a href="../de492178/index.html">Ein Pfad mit siebentausend Pixeln: Entwicklung der Monitorauflösungen und unserer Anforderungen</a></li>
<li><a href="../de492182/index.html">Grundlagen der Informationssicherheit bei Microsoft-Teams</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>