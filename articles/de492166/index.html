<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÑπÔ∏è üßü üëàüèΩ Widgets auf Android. Ein seltenes Merkmal, um es herauszufinden üçã üññüèø üßëüèΩ‚Äçü§ù‚Äçüßëüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Mein Name ist Alexander Khakimov, ich bin ein Android-Entwickler bei FINCH. 
 
 Ist es passiert, dass Ihr Design f√ºr iOS war und Sie es f√º...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Widgets auf Android. Ein seltenes Merkmal, um es herauszufinden</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492166/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font><font style="vertical-align: inherit;">Mein Name ist Alexander Khakimov, ich bin ein Android-Entwickler bei FINCH. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ist es passiert, dass Ihr Design f√ºr iOS war und Sie es f√ºr Android anpassen m√ºssen? </font><font style="vertical-align: inherit;">Wenn ja, verwenden Ihre Designer h√§ufig Widgets? </font><font style="vertical-align: inherit;">Leider ist ein Widget f√ºr viele Entwickler ein seltener Fall, da selten jemand damit arbeitet. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel werde ich Ihnen ausf√ºhrlich erkl√§ren, wie Sie ein Widget erstellen, das es wert ist, beachtet zu werden und meinen Fall zu teilen.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget-Erstellung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ein Widget zu erstellen, m√ºssen Sie Folgendes wissen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionen von Widget-Komponenten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionen zum Anzeigen des Widgets im Bildschirmraster.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bietet Widget-Updates.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden jeden Artikel separat analysieren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionen von Widget-Komponenten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder Entwickler, der mindestens einmal mit RemoteViews gearbeitet hat, ist mit diesem Element vertraut. </font><font style="vertical-align: inherit;">Wenn Sie einer von diesen sind, k√∂nnen Sie mit dem n√§chsten Punkt fortfahren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RemoteViews dient zum Beschreiben und Verwalten von Ansichtshierarchien, die zu einem Prozess in einer anderen Anwendung geh√∂ren. </font><font style="vertical-align: inherit;">Mithilfe der Hierarchieverwaltung k√∂nnen Sie Eigenschaften √§ndern oder Methoden aufrufen, die zur Ansicht geh√∂ren, die Teil einer anderen Anwendung ist. </font><font style="vertical-align: inherit;">RemoteViews enth√§lt einen begrenzten Satz von Komponenten aus der Standardkomponentenbibliothek android.widget. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Anzeigen in Widgets funktioniert in einem separaten Prozess (normalerweise ist dies der Startbildschirm). Verwenden Sie daher zum √Ñndern der Benutzeroberfl√§che des Widgets die BroadcastReceiver-Erweiterung - AppWidgetProvider, die in unserer Anwendung funktioniert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionen zum Anzeigen des Widgets im "Raster" des Bildschirms</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Tat ist dieser Punkt nicht so kompliziert, wenn Sie sich die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offiziellen Richtlinien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ansehen </font><font style="vertical-align: inherit;">:</font></font><br>
 <blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes Widget muss eine minWidth und eine minHeight definieren, die angeben, wie viel Speicherplatz standardm√§√üig mindestens belegt werden soll. </font><font style="vertical-align: inherit;">Wenn Benutzer ihrem Startbildschirm ein Widget hinzuf√ºgen, belegt es im Allgemeinen mehr als die von Ihnen angegebene Mindestbreite und -h√∂he. </font><font style="vertical-align: inherit;">Android-Startbildschirme bieten Benutzern ein Raster verf√ºgbarer Bereiche, in denen sie Widgets und Symbole platzieren k√∂nnen. </font><font style="vertical-align: inherit;">Dieses Raster kann je nach Ger√§t variieren. </font><font style="vertical-align: inherit;">Beispielsweise bieten viele Mobilteile ein 4x4-Raster und Tablets ein gr√∂√üeres 8x7-Raster.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úbersetzen ins Russische: Jedes Widget muss seine eigene Mindestbreite und -h√∂he festlegen, um den Mindestplatz anzugeben, den es standardm√§√üig belegt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6r/p-/ux/6rp-uxyfekjzwlpantqmxkdfaio.png" alt="Bild"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel f√ºr Widget-Einstellungen beim Erstellen in Android Studio Das</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Widget, das dem Startbildschirm hinzugef√ºgt wurde, nimmt normalerweise mehr Platz ein als die von Ihnen festgelegte Mindestbreite und -h√∂he. Die Android-Startbildschirme bieten Benutzern ein Raster mit verf√ºgbaren Bereichen, in denen sich Widgets und Symbole befinden k√∂nnen. Dieses Raster kann je nach Ger√§t variieren. Beispielsweise bieten viele Telefone 4x4-Raster und Tablets gro√üe 8x4-Raster.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daraus wird deutlich, dass das Raster des Ger√§ts beliebig sein kann und die Zellengr√∂√üe je nach Gr√∂√üe des Rasters variieren kann. </font><font style="vertical-align: inherit;">Dementsprechend sollte der Inhalt des Widgets unter Ber√ºcksichtigung dieser Funktionen gestaltet werden. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die minimale Breite und H√∂he des Widgets f√ºr eine bestimmte Anzahl von Spalten und Zeilen kann mithilfe der folgenden Formel berechnet werden: </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
minSideSizeDp = 70 √ó n - 30, wobei n die Anzahl der Zeilen oder Spalten ist </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
. Derzeit k√∂nnen Sie maximal 4x4 festlegen. </font><font style="vertical-align: inherit;">Dadurch wird sichergestellt, dass Ihr Widget auf allen Ger√§ten angezeigt wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bietet Widget-Updates</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da AppWidgetProvider im Wesentlichen eine Erweiterung von BroadcastReceiver ist, k√∂nnen Sie damit dasselbe tun wie mit einem normalen BroadcastReceiver. AppWidgetProvider analysiert einfach die entsprechenden Felder aus der in onReceive empfangenen Absicht und ruft die Abfangmethoden mit den empfangenen Extras auf. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Schwierigkeit ergab sich aus der H√§ufigkeit der Aktualisierung des Inhalts - der springende Punkt ist der Unterschied im internen Betrieb von Widgets unter iOS und Android. Tatsache ist, dass Daten in iOS-Widgets aktualisiert werden, wenn das Widget f√ºr den Benutzer sichtbar wird. In Android existiert ein solches Ereignis nicht. Wir k√∂nnen nicht herausfinden, wann der Benutzer das Widget sieht.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr Widgets unter Android ist die empfohlene Aktualisierungsmethode ein Timer-Update. </font><font style="vertical-align: inherit;">Die Timer-Einstellungen werden √ºber den Widget-Parameter updatePeriodMillis festgelegt. </font><font style="vertical-align: inherit;">Leider erlaubt diese Einstellung nicht, das Widget mehr als einmal alle 30 Minuten zu aktualisieren. </font><font style="vertical-align: inherit;">Im Folgenden werde ich n√§her darauf eingehen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget-Fall</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weiter werden wir √ºber den Fall sprechen, den wir bei FINCH in einem gro√üen Lotterieantrag mit dem Stoloto-Antrag auf Teilnahme an staatlichen Lotterien hatten. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aufgabe des Antrags besteht darin, die Auswahl einer Lotterie und den Kauf eines Tickets f√ºr den Benutzer zu vereinfachen und transparent zu machen. </font><font style="vertical-align: inherit;">Daher ist die erforderliche Funktionalit√§t des Widgets recht einfach: Zeigen Sie den vom Benutzer empfohlenen Spielen zum Kauf an und tippen Sie auf, um zum entsprechenden zu gelangen. </font><font style="vertical-align: inherit;">Die Liste der Spiele wird auf dem Server ermittelt und regelm√§√üig aktualisiert. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Fall enthielt das Widget-Design zwei Zust√§nde:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr autorisierte Benutzer</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr einen nicht autorisierten Benutzer</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein autorisierter Benutzer muss seine Profildaten anzeigen: den Status der internen Brieftasche, die Anzahl der Tickets, die auf die Ziehung warten, und die Anzahl der verlorenen Gewinne. </font><font style="vertical-align: inherit;">F√ºr jedes dieser Elemente wird ein √úbergang zum Bildschirm innerhalb der Anwendung bereitgestellt, der sich von den anderen unterscheidet. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rp/d2/6i/rpd26ixtdxfjopibvmgaaczfkco.png" alt="Bild"><br>
<br>
<img src="https://habrastorage.org/webt/dk/yy/qx/dkyyqxqcnopxezwhknrmqbuedgu.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie vielleicht bemerkt haben, ist eine weitere Funktion f√ºr einen autorisierten Benutzer die Schaltfl√§che "Aktualisieren", aber dazu sp√§ter mehr. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Anzeige von zwei Zust√§nden unter Ber√ºcksichtigung des Designs zu implementieren, habe ich den RemoteAdapter als Implementierung von RemoteViewsService verwendet, um Inhaltskarten zu generieren. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt ein kleiner Code und wie alles drinnen funktioniert. </font><font style="vertical-align: inherit;">Wenn Sie bereits Erfahrung mit dem Widget haben, wissen Sie, dass jede Aktualisierung der Widgetdaten mit der onUpdate-Methode beginnt:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onUpdate</span><span class="hljs-params">(
        context: <span class="hljs-type">Context</span>,
        appWidgetManager: <span class="hljs-type">AppWidgetManager</span>,
        appWidgetIds: <span class="hljs-type">IntArray</span>
    )</span></span> {<font></font>
        injector.openScope(<span class="hljs-keyword">this</span>, *arrayOf(<span class="hljs-keyword">this</span>))
        <span class="hljs-comment">// update each of the widgets with the remote adapter</span><font></font>
        appWidgetIds<font></font>
            .forEach {<font></font>
                updateWidget(context, appWidgetManager, it)<font></font>
          }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir schreiben ein Update f√ºr jede Instanz unseres Widgets.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateWidget</span><span class="hljs-params">(
        context: <span class="hljs-type">Context</span>,
        appWidgetManager: <span class="hljs-type">AppWidgetManager</span>,
        appWidgetId: <span class="hljs-type">Int</span>
    )</span></span> {
<span class="hljs-comment">// remoteViews   widgetId</span>
        <span class="hljs-keyword">val</span> remoteViews = RemoteViews(<font></font>
            context.packageName,<font></font>
            R.layout.app_widget_layout<font></font>
...<font></font>
<span class="hljs-comment">//        </span><font></font>
...<font></font>
<span class="hljs-comment">//    remoteViews</span><font></font>
updateRemoteAdapter(context, remoteViews, appWidgetId)<font></font>
 <font></font>
<span class="hljs-comment">//   remoteViews </span><font></font>
appWidgetManager.updateAppWidget(appWidgetId, remoteViews)<font></font>
<span class="hljs-comment">// collection view  </span><font></font>
appWidgetManager.notifyAppWidgetViewDataChanged(<font></font>
            appWidgetId,<font></font>
            R.id.lvWidgetItems<font></font>
        )<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adapter aktualisieren.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateRemoteAdapter</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, remoteViews: <span class="hljs-type">RemoteViews</span>, appWidgetId: <span class="hljs-type">Int</span>)</span></span> {
<span class="hljs-comment">//   RemoteViewsService   RemoteAdapter   </span>
        <span class="hljs-keyword">val</span> adapterIntent = Intent(context, StolotoAppWidgetRemoteViewsService::<span class="hljs-keyword">class</span>.java).apply {<font></font>
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)<font></font>
        }<font></font>
        remoteViews.setRemoteAdapter(R.id.lvWidgetItems, adapterIntent)<font></font>
// actionIntent  pendingIntent      <font></font>
        <span class="hljs-keyword">val</span> actionIntent = Intent(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java).apply {<font></font>
            action = WIDGET_CLICK_ACTION<font></font>
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)<font></font>
        }<font></font>
        <span class="hljs-keyword">val</span> pendingIntent = PendingIntent.getBroadcast(<font></font>
            context, <span class="hljs-number">0</span>, actionIntent,<font></font>
            PendingIntent.FLAG_UPDATE_CURRENT<font></font>
        )<font></font>
<span class="hljs-comment">// pendingIntent      </span><font></font>
        remoteViews.setPendingIntentTemplate(R.id.lvWidgetItems, pendingIntent)<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir schreiben die Implementierung unseres Service. </font><font style="vertical-align: inherit;">Darin ist es wichtig anzugeben, welche Implementierung der RemoteViewsService.RemoteViewsFactory-Schnittstelle zum Generieren von Inhalten verwendet werden soll.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StolotoAppWidgetRemoteViewsService</span> : <span class="hljs-type">RemoteViewsService</span></span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onGetViewFactory</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>)</span></span>: RemoteViewsFactory =<font></font>
        StolotoAppWidgetRemoteViewsFactory(<font></font>
            <span class="hljs-keyword">this</span>.applicationContext,<font></font>
            intent<font></font>
        )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist eigentlich eine d√ºnne H√ºlle √ºber dem Adapter. </font><font style="vertical-align: inherit;">Dank ihm k√∂nnen wir unsere Daten mit der Remote-Erfassungsansicht verkn√ºpfen. </font><font style="vertical-align: inherit;">RemoteViewsFactory bietet Methoden zum Generieren von RemoteViews f√ºr jedes Element im Dataset. </font><font style="vertical-align: inherit;">Der Konstruktor hat keine Anforderungen - alles, was ich tue, ist, den Kontext darin zu √ºbergeben. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als n√§chstes ein paar Worte zu den wichtigsten Methoden:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onCreate - Erstellen eines Adapters.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getLoadingView - Die Methode schl√§gt vor, die Ansicht zur√ºckzugeben, die das System w√§hrend der Erstellung anstelle der Listenelemente anzeigt. </font><font style="vertical-align: inherit;">Wenn Sie hier nichts erstellen, verwendet das System eine Standardansicht.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getViewAt - Die Methode schl√§gt vor, Listenelemente zu erstellen. </font><font style="vertical-align: inherit;">Hier kommt die Standardverwendung von RemoteViews.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onDataSetChanged wird aufgerufen, wenn eine Anforderung zum Aktualisieren der Daten in der Liste empfangen wird. </font><font style="vertical-align: inherit;">Jene. </font><font style="vertical-align: inherit;">Bei dieser Methode bereiten wir die Daten f√ºr die Liste vor. </font><font style="vertical-align: inherit;">Die Methode wird durch die Ausf√ºhrung von schwerem, langem Code gesch√§rft.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onDestroy wird aufgerufen, wenn die zuletzt verwendete Liste des Adapters gel√∂scht wird (ein Adapter kann von mehreren Listen verwendet werden).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RemoteViewsFactory lebt, w√§hrend alle Instanzen der Liste aktiv sind, sodass wir aktuelle Daten darin speichern k√∂nnen, z. B. eine Liste aktueller Elemente.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Definieren Sie eine Liste der Daten, die angezeigt werden sollen:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> widgetItems = ArrayList&lt;WidgetItem&gt;()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Erstellen des Adapters beginnen wir mit dem Laden der Daten. </font><font style="vertical-align: inherit;">Hier k√∂nnen Sie alle schwierigen Aufgaben sicher ausf√ºhren, einschlie√ülich des leisen Gehens in das Netzwerk, das den Fluss blockiert.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
        updateDataSync()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir den Befehl zum Aktualisieren von Daten aufrufen, rufen wir auch updateDataSync () auf.</font></font><br>
<br>
<pre><code class="kotlin hljs">   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDataSetChanged</span><span class="hljs-params">()</span></span> {<font></font>
        updateDataSync()<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In updateDataSync ist auch alles einfach. </font><font style="vertical-align: inherit;">Wir l√∂schen die aktuelle Liste der Elemente. </font><font style="vertical-align: inherit;">Laden Sie Profil- und Spieldaten herunter.</font></font><br>
<br>
<pre><code class="kotlin hljs"> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateDataSync</span><span class="hljs-params">()</span></span> {<font></font>
        widgetItems.clear()<font></font>
        updateProfileSync()<font></font>
        updateGamesSync()<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist es interessanter</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateProfileSync</span><span class="hljs-params">()</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da es f√ºr uns wichtig ist, das Profil nur einem autorisierten Benutzer anzuzeigen, m√ºssen wir die Profilinformationen nur in diesem Fall herunterladen:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> isUserFullAuth = isUserFullAuthInteractor<font></font>
            .execute()<font></font>
            .blockingGet()<font></font>
        <span class="hljs-keyword">if</span> (isUserFullAuth) {
            <span class="hljs-keyword">val</span> profile = getWidgetProfileInteractor<font></font>
                .execute()<font></font>
                .onErrorReturn {<font></font>
                    WidgetProfile()<font></font>
<span class="hljs-comment">//           </span><font></font>
                }<font></font>
                .blockingGet()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das WidgetProfile-Modell wird aus verschiedenen Quellen zusammengestellt, sodass die Logik ihres Empfangs und seine Standardwerte so angeordnet sind, dass ein negativer Brieftaschenwert auf falsche Daten oder Probleme mit dem Empfang hinweist. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr die Gesch√§ftslogik ist das Fehlen von Brieftaschendaten von entscheidender Bedeutung. Im Falle einer falschen Brieftasche wird daher kein Profilmodell erstellt und der Liste der Elemente hinzugef√ºgt.</font></font><br>
<br>
<pre><code class="kotlin hljs">  <span class="hljs-keyword">if</span> (profile.walletAmount &gt;= <span class="hljs-number">0L</span>) {<font></font>
                widgetItems.add(<font></font>
                    WidgetItem.Profile(<font></font>
                        wallet = profile.walletAmount.toMoneyFormat(),<font></font>
                        waitingTickets = <span class="hljs-keyword">if</span> (profile.waitingTicketsCount &gt;= <span class="hljs-number">0</span>) profile.waitingTicketsCount.toString() <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>,<font></font>
                        unpaidPrizeAmount = <span class="hljs-keyword">if</span> (profile.unpaidPrizeAmount &gt;= <span class="hljs-number">0</span>) profile.unpaidPrizeAmoount.toMoneyFormat() <span class="hljs-keyword">else</span> <span class="hljs-string">""</span><font></font>
                    )<font></font>
                )<font></font>
            }<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die updateGamesSync () -Methode verwendet getWidgetGamesInteractor und f√ºgt der WidgetItems-Liste eine Reihe von Spielen hinzu, die f√ºr das Widget relevant sind. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor Sie mit der Kartengenerierung fortfahren, sollten Sie das WidgetItem-Modell genauer betrachten. </font><font style="vertical-align: inherit;">Die Implementierung erfolgt √ºber die versiegelte Kotlin-Klasse, wodurch das Modell flexibler wird und die Arbeit damit bequemer ist.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetItem</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Profile</span></span>(
        <span class="hljs-keyword">val</span> wallet: String,
        <span class="hljs-keyword">val</span> waitingTickets: String,
        <span class="hljs-keyword">val</span> unpaidPrizeAmount: String<font></font>
    ) : WidgetItem()<font></font>
 <font></font>
    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span></span>(
        <span class="hljs-keyword">val</span> id: String,
        <span class="hljs-keyword">val</span> iconId: <span class="hljs-built_in">Int</span>,
        <span class="hljs-keyword">val</span> prizeValue: String,
        <span class="hljs-keyword">val</span> date: String<font></font>
    ) : WidgetItem()<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie RemoteViews und bestimmen Sie deren Antwort √ºber FillInIntent</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getViewAt</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span>: RemoteViews {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> item = widgetItems[position]) {
            <span class="hljs-keyword">is</span> WidgetItem.Profile -&gt; {<font></font>
              RemoteViews(<font></font>
                        context.packageName,<font></font>
                        R.layout.item_widget_user_profile<font></font>
                    ).apply {<font></font>
                        setTextViewText(R.id.tvWidgetWalletMoney, item.wallet)<font></font>
                        setTextViewText(R.id.tvWidgetUnpaidCount, item.unpaidPrizeAmount)<font></font>
                        setTextViewText(R.id.tvWidgetWaitingCount, item.waitingTickets)<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileWallet, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_USER_WALLET<font></font>
                            )<font></font>
                        )<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileUnpaid, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_UNPAID_PRIZE<font></font>
                            )<font></font>
                        )<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileWaiting, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_WAITING_TICKETS<font></font>
                            )<font></font>
                        )<font></font>
                    }<font></font>
 <font></font>
            <span class="hljs-keyword">is</span> WidgetItem.Game -&gt; {<font></font>
                RemoteViews(<font></font>
                    context.packageName,<font></font>
                    R.layout.item_widget_game<font></font>
                ).apply {<font></font>
                    setImageViewResource(R.id.ivWidgetGame, item.iconId)<font></font>
                    setTextViewText(R.id.tvWidgetGamePrize, item.prizeValue)<font></font>
                    setTextViewText(R.id.tvWidgetGameDate, item.date)<font></font>
                    setOnClickFillInIntent(<font></font>
                        R.id.llWidgetGame, Intent().putExtra(<font></font>
                            StolotoAppWidgetProvider.KEY_GAME_CLICK, item.id<font></font>
                        )<font></font>
                    )<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die setOnClickFillInIntent-Methode weist die angegebene viewId-Absicht zu, die mit dem √ºbergeordneten PendingIntent kombiniert wird, um das Verhalten beim Klicken auf die Ansicht mit dieser viewId zu bestimmen. </font><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen wir auf Benutzerklicks in unserem WidgetProvider reagieren.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manuelles Widget-Update</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr unser Widget wurde eine Aktualisierungszeit von einer halben Stunde festgelegt. Sie k√∂nnen es h√§ufiger aktualisieren, indem Sie beispielsweise mit WorkManager tanzen. Warum sollten Sie jedoch Ihr Netzwerk und Ihren Akku laden? Ein solches Verhalten in den fr√ºhen Entwicklungsstadien schien angemessen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles √§nderte sich, als das ‚ÄûUnternehmen‚Äú bemerkte, dass beim Betrachten des Widgets die irrelevanten Daten darauf angezeigt werden: ‚ÄûHier auf meinem iPhone √∂ffne ich das Widget und es gibt die MEISTEN frischen Daten meines Profils.‚Äú </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Situation ist allt√§glich: iOS generiert neue Karten f√ºr JEDE Widget-Anzeige, da sie daf√ºr einen speziellen Bildschirm haben und Android solche Ereignisse f√ºr das Widget im Prinzip nicht hat. Ich musste ber√ºcksichtigen, dass einige Lotterien alle 15 Minuten stattfinden, daher sollte das Widget aktuelle Informationen liefern - Sie m√∂chten an einer Verlosung teilnehmen, diese ist jedoch bereits abgelaufen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um aus dieser unangenehmen Situation herauszukommen und das Problem mit der Aktualisierung der Daten irgendwie zu l√∂sen, habe ich eine bew√§hrte L√∂sung vorgeschlagen und implementiert - die Schaltfl√§che ‚ÄûAktualisieren‚Äú. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºgen Sie diese Schaltfl√§che dem Layout-Layout mit der Liste hinzu und initialisieren Sie das Verhalten beim Aufruf von updateWidget.</font></font><br>
<br>
<pre><code class="kotlin hljs">...
<span class="hljs-comment">// Intent   AppWidgetManager.ACTION_APPWIDGET_UPDATE</span>
<span class="hljs-keyword">val</span> intentUpdate = Intent(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java)<font></font>
intentUpdate.action = AppWidgetManager.ACTION_APPWIDGET_UPDATE<font></font>
<font></font>
//    <font></font>
<span class="hljs-keyword">val</span> ids = AppWidgetManager.getInstance(context)<font></font>
   .getAppWidgetIds(ComponentName(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java))<font></font>
intentUpdate.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, ids)<font></font>
<font></font>
//  intent  PendingIntent,  PendingIntent.getBroadcast()<font></font>
<span class="hljs-keyword">val</span> pendingUpdate = PendingIntent.getBroadcast(<font></font>
   context,<font></font>
   appWidgetId,<font></font>
   intentUpdate,<font></font>
   PendingIntent.FLAG_UPDATE_CURRENT<font></font>
)<font></font>
//  pendingIntent      ‚Äò‚Äô<font></font>
remoteViews.setOnClickPendingIntent(R.id.ivWidgetRefresh, pendingUpdate)<font></font>
‚Ä¶</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten Entwicklungen zeigten ein trauriges Bild: Vom Dr√ºcken der Schaltfl√§che "Aktualisieren" bis zum eigentlichen Update konnten einige Sekunden vergehen. </font><font style="vertical-align: inherit;">Obwohl das Widget von unserer Anwendung generiert wird, unterliegt es tats√§chlich der Kontrolle des Systems und kommuniziert mit unserer Anwendung √ºber Broadcasts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jene. </font><font style="vertical-align: inherit;">Wenn Sie auf die Schaltfl√§che "Aktualisieren" unseres Widgets klicken, beginnt die Kette:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Holen Sie sich die Absicht in die onReceive-Provider-Aktion.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppWidgetManager.ACTION_APPWIDGET_UPDATE. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rufen Sie onUpdate f√ºr alle in intent-e angegebenen WidgetsIds auf.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gehen Sie online f√ºr neue Daten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisieren Sie lokale Daten und zeigen Sie neue Listenkarten an.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen sah das Aktualisieren des Widgets nicht besonders gut aus, da wir durch Klicken auf die Schaltfl√§che einige Sekunden lang dasselbe Widget angesehen haben. </font><font style="vertical-align: inherit;">Es war unklar, ob die Daten aktualisiert wurden. </font><font style="vertical-align: inherit;">Wie kann man das Problem der visuellen Reaktion l√∂sen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst habe ich das isWidgetLoading-Flag mit globalem Zugriff √ºber den Interaktor hinzugef√ºgt. </font><font style="vertical-align: inherit;">Die Rolle dieses Parameters ist recht einfach: Zeigen Sie die Schaltfl√§che "Aktualisieren" nicht an, w√§hrend die Widgetdaten geladen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zweitens habe ich den Datenladevorgang in der Fabrik in drei Phasen unterteilt:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadingStep</span> </span>{<font></font>
   START,<font></font>
   MIDDLE,<font></font>
   END<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
START - Start des Downloads. </font><font style="vertical-align: inherit;">Zu diesem Zeitpunkt √§ndert sich der Status aller Adapteransichten und das globale Download-Flag in "Laden". </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MITTEL - die Phase des Ladens der Hauptdaten. </font><font style="vertical-align: inherit;">Nach dem Herunterladen wird das globale Download-Flag in den Status "geladen" versetzt und die heruntergeladenen Daten werden im Adapter angezeigt. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ENDE - Ende des Downloads. </font><font style="vertical-align: inherit;">Der Adapter muss in diesem Schritt die Adapterdaten nicht √§ndern. </font><font style="vertical-align: inherit;">Dieser Schritt ist erforderlich, um die Aktualisierungsphase der Ansichten in WidgetProvider korrekt zu verarbeiten. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sehen wir uns genauer an, wie das Button-Update im Provider aussieht:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">if</span> (isFullAuthorized &amp;&amp; !widgetLoadingStateInteractor.isWidgetLoading) {<font></font>
   remoteViews.setViewVisibility(R.id.ivWidgetRefresh, View.VISIBLE)<font></font>
...<font></font>
<span class="hljs-comment">//     ,    </span><font></font>
...   <font></font>
} <span class="hljs-keyword">else</span> {<font></font>
   remoteViews.setViewVisibility(<font></font>
       R.id.ivWidgetRefresh,<font></font>
       <span class="hljs-keyword">if</span> (isFullAuthorized) View.INVISIBLE <span class="hljs-keyword">else</span> View.GONE <span class="hljs-comment">//       .</span><font></font>
   )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns nun an, was im Adapter passiert:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateDataSync</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">when</span> (loadingStep) {<font></font>
       START -&gt; {<font></font>
           widgetItems.forEach { it.isLoading = <span class="hljs-literal">true</span> }<font></font>
           widgetLoadingStateInteractor.isWidgetLoading = <span class="hljs-literal">true</span><font></font>
           loadingStep = MIDDLE<font></font>
           widgetManager.updateWidgets()<font></font>
       }<font></font>
       MIDDLE -&gt; {<font></font>
           widgetItems.clear()<font></font>
           updateProfileSync()<font></font>
           updateGamesSync()<font></font>
           widgetLoadingStateInteractor.isWidgetLoading = <span class="hljs-literal">false</span><font></font>
           loadingStep = END<font></font>
           widgetManager.updateWidgets()<font></font>
       }<font></font>
       END -&gt; {<font></font>
           loadingStep = START<font></font>
       }<font></font>
   }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/bq/ah/hg/bqahhgnwugy10345-bcegnupxo8.png" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Logik der Arbeit: </font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Ende der Schritte START und MIDDLE rufe ich die updateWidgets-Methode auf, um den vom Anbieter verwalteten Ansichtsstatus zu aktualisieren.</font></font></li>
<li>   START     ¬´¬ª   ,    MIDDLE.</li>
<li>         MIDDLE,    ¬´¬ª.</li>
<li>   MIDDLE,          END. </li>
<li>      ,   END,    ¬´¬ª.        ,    END   loadingStep  START.</li>
</ol><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Hilfe einer solchen Implementierung habe ich einen Kompromiss zwischen der Anforderung des "Unternehmens", die tats√§chlichen Daten im Widget anzuzeigen, und der Notwendigkeit, das Update zu oft "abzurufen", erzielt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, der Artikel hat Ihnen geholfen. </font><font style="vertical-align: inherit;">Wenn Sie Erfahrung mit der Erstellung von Widgets f√ºr Android haben, teilen Sie uns dies in den Kommentaren mit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viel Gl√ºck</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de492150/index.html">Implementieren Sie es vollst√§ndig. Di-in-js</a></li>
<li><a href="../de492154/index.html">Der Start von ExoMars verz√∂gerte sich auf das n√§chste Startfenster im Jahr 2022</a></li>
<li><a href="../de492156/index.html">Subtrahiert. Wollen. Tun</a></li>
<li><a href="../de492162/index.html">Augenschnittstellen. Bericht in Yandex</a></li>
<li><a href="../de492164/index.html">Tor zum Himmel oder zur Stadt der Zukunft</a></li>
<li><a href="../de492168/index.html">Frontarbeit an der Backend-Entwicklung der gr√∂√üten Portale f√ºr Open Source-Software: Erfahrungsaustausch</a></li>
<li><a href="../de492172/index.html">D√ºnne Sicherung von Linux-Dateisystemen. So erstellen Sie in 20 Sekunden Arbeitskopien eines MySQL-DBMS mit drei Terabyte</a></li>
<li><a href="../de492174/index.html">Drahtloser DIY Bodenfeuchtemonitor</a></li>
<li><a href="../de492178/index.html">Ein Pfad mit siebentausend Pixeln: Entwicklung der Monitoraufl√∂sungen und unserer Anforderungen</a></li>
<li><a href="../de492182/index.html">Grundlagen der Informationssicherheit bei Microsoft-Teams</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>