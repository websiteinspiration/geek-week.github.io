<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¾â€ğŸ­ ğŸ˜» ğŸ¤™ğŸ» Layanan microser atau sistem modular? Bagaimana pelanggan dapat memilih pendekatan arsitektur TI suatu produk âœŠğŸ¿ ğŸ¤²ğŸ» â˜ºï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Microservice dan sistem modular adalah jenis arsitektur solusi TI.
 Saat bekerja dengan modul, kami menyelesaikan versi kotak dari produk TI yang ada....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Layanan microser atau sistem modular? Bagaimana pelanggan dapat memilih pendekatan arsitektur TI suatu produk</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/497248/"><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microservice dan sistem modular adalah jenis arsitektur solusi TI.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat bekerja dengan modul, kami menyelesaikan versi kotak dari produk TI yang ada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang kami maksud dengan versi kotak adalah monolith, sistem siap pakai dengan inti yang dikirimkan ke semua pelanggan dengan cara yang sama, "sebagaimana adanya." </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penyempurnaan terdiri dalam membuat modul dengan fungsi yang hilang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mendapatkan modul baru dengan menggunakan kembali bagian monolith (inti atau modul lainnya). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Logika bisnis tertulis di dalam monolith: untuk program (aplikasi, situs, portal) ada satu titik masuk dan satu titik keluar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika bekerja dengan layanan microser, kami membuat produk IT dari awal, menyusunnya dari "batu bata" - layanan microser atom yang bertanggung jawab atas proses kecil yang terpisah (mengirim surat, menerima informasi pesanan, mengubah status pesanan, membuat klien, dll.).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Serangkaian blok tersebut digabungkan dengan logika bisnis ke dalam sistem umum (misalnya, menggunakan BPMS). </font><font style="vertical-align: inherit;">Meskipun terdapat koneksi, setiap blok bersifat otonom dan memiliki titik masuk dan keluar sendiri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagian besar produk TI untuk pelanggan kami dimulai dengan pengembangan modular. </font><font style="vertical-align: inherit;">Beberapa dari mereka berkembang dari waktu ke waktu ke layanan microser. </font><font style="vertical-align: inherit;">Untuk bagian lain, layanan microser tidak diperlukan. </font><font style="vertical-align: inherit;">Dalam artikel ini, kita akan memeriksa mengapa ini benar-benar terjadi dan kriteria apa yang membantu menentukan apakah perlu untuk mengimplementasikan layanan-layanan mikro atau jika Anda harus tetap bekerja dengan modul-modul.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e49/d21/b9e/e49d21b9e7d70c040a3d7ce537b94c19.jpg" alt="gambar"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manfaat Arsitektur Modular</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua sistem CMS (Bitrix, Magento, Drupal, Hybris, dll.), CRM, ERP, WMS dan banyak lainnya memiliki versi kotak. </font><font style="vertical-align: inherit;">Mereka menjual dengan baik dan dalam permintaan tinggi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat alasan obyektif mengapa pelanggan paling sering memilih untuk bekerja dengan arsitektur modular dan dengan sukarela membeli solusi kotak.</font></font><br>
<br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi kecepatan tinggi</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Menginstal, mengonfigurasi, dan mengisi direktori untuk perangkat lunak semacam itu membutuhkan sedikit waktu. </font><font style="vertical-align: inherit;">Adalah realistis bagi perusahaan menengah untuk mulai bekerja dengan sebuah kotak tiga hingga empat bulan setelah dimulainya, kadang-kadang bahkan sedikit lebih awal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk usaha kecil, periode ini bisa hanya beberapa hari.</font></font></li>
<li><b> </b><br>
<br>
     . ,       enterprise-   .</li>
<li><b>     </b><br>
<br>
       .            . ,       ,                  ,     .</li>
<li><b> ,  </b><br>
<br>
             .    ,        .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada faktor subyektif lain yang dapat menyesatkan dan memengaruhi keputusan untuk menggunakan kotak dan modul. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Perlombaan produsen</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Penjual perangkat lunak dengan hangat meyakinkan pelanggan bahwa solusi mereka di luar kotak adalah solusi yang tepat: telah diuji selama bertahun-tahun, dan modis, dan perusahaan, dan populer, dan pemasaran ... Setiap pemasok: Bitrix, Magento, SAP, Oracle, OpenCart, Django dan semua orang bekerja keras dalam teknik pemasaran dan penjualan. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Kesalahpahaman tentang kompleksitas peningkatan</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pelanggan sering kali penuh dengan optimisme. Mereka memilih perangkat lunak kotak dan berpikir: â€œYa, perbaikan akan diperlukan. Tapi itu mudah: Anda tidak perlu menemukan sesuatu yang baru. Kami memiliki versi populer, tetapi jutaan pengguna tidak dapat membuat kesalahan dan membeli produk yang buruk. "</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam pandangan mereka, proses penyempurnaan terlihat seperti ini: ada fungsionalitas (kotak) utama. Untuk "menyelesaikan" sesuatu di dalamnya, pengembang harus "hanya" mendefinisikan kembali modul atau dengan cepat menulis sendiri. Dalam hal ini, tidak perlu menggunakan metode berulang, karena semuanya dianggap dipikirkan dalam monolit: metode umum untuk menghitung pajak ditentukan, ada aturan yang jelas untuk menulis metode pengiriman dan pembayaran, alur kerja pesanan yang jelas, dll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kehidupan nyata, berbagai hal berbeda. Dan setelah emosi yang menyenangkan dari awal yang mudah bekerja dengan kotak, pelanggan masih dihadapkan dengan kenyataan pahit. Paling sering hal ini terjadi dengan perusahaan dari bisnis menengah dan besar, proyek-proyek yang memiliki logika bisnis yang unik, dan peningkatan skala besar diperlukan di dalamnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika perusahaan Anda adalah bisnis kecil dan perangkat lunak bukan aset utama Anda, maka kemungkinan besar, solusi kotak (atau lebih baik - cloud) yang populer akan cocok untuk Anda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat masalah apa yang mungkin Anda temui ketika bekerja dengan arsitektur modular dan bagaimana layanan Microsoft membantu untuk menghindari ini.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah sistem modular</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah utama adalah bahwa semua sistem modular tidak dirancang untuk mendefinisikan ulang fungsionalitas secara serius. </font><font style="vertical-align: inherit;">Mereka memiliki kotak, modul yang sudah jadi - yang lebih baik untuk menggunakannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semakin dekat ke tingkat perusahaan ukuran proyek dan kompleksitas kustomisasi mereka, semakin banyak masalah dengan penyelesaian modul. </font><font style="vertical-align: inherit;">Mari kita bicara tentang yang utama.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah No. 1. Inti dari sistem menjadi titik perlambatan, dan modularitas menjadi komplikasi yang tidak perlu.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Katakanlah proyek Anda dikaitkan dengan logika gudang kompleks. Jika Anda memilih arsitektur modular, maka pengembang tidak hanya perlu membuat fungsionalitas untuk mengelola gudang ini - mereka perlu mendefinisikan ulang atau memperluas modul multicore, yang, pada gilirannya, menggunakan metode kernel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, perlu untuk memperhitungkan logika pengembalian yang kompleks ke gudang: ketergantungan pada peristiwa dari sistem CRM, perpindahan barang antar katalog, dll. Juga perlu mempertimbangkan logika tersembunyi yang terkait dengan pengembalian dana, poin bonus, dll.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika begitu banyak redefinisi terjadi, monolit berubah secara signifikan. </font><font style="vertical-align: inherit;">Penting untuk diingat bahwa hubungan antara volume fungsional baru dan jumlah modul adalah non-linier: untuk menambah satu fungsi, Anda harus membuat perubahan pada beberapa modul, yang masing-masing mengubah operasi yang lain, atau mendefinisikan kembali sejumlah besar metode modul lain dalam modul baru, yang tidak mengubah esensi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah semua perubahan, sistem menjadi sangat rumit sehingga dibutuhkan sejumlah besar jam untuk menambahkan kustomisasi berikut.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2d3/82f/0de/2d382f0de298b267b9e3ce6ca8f2fd58.webp" alt="gambar"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah No. 2. Prinsip dokumentasi-mandiri tidak didukung dalam sistem modular.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dokumentasi untuk sistem modular sulit diperbarui. </font><font style="vertical-align: inherit;">Sangat banyak, dan menjadi usang dengan setiap perubahan. </font><font style="vertical-align: inherit;">Penyempurnaan satu modul memerlukan perubahan pada beberapa dokumen lain (dalam pengguna, dokumentasi teknis), dan semuanya perlu ditulis ulang. </font></font><br>
ï»¿<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai aturan, tidak ada orang yang melakukan pekerjaan seperti itu: menghabiskan waktu spesialis IT yang berharga untuk hal ini berarti hanya menghabiskan anggaran. </font><font style="vertical-align: inherit;">Bahkan penggunaan penyimpanan dokumentasi dalam kode (PHPDoc) tidak menjamin keandalannya. </font><font style="vertical-align: inherit;">Pada akhirnya, jika dokumentasi mungkin berbeda dari implementasinya, itu tentu akan berbeda.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah No. 3. Koherensi kode yang lebih besar - jalan menuju kemunduran: "mereka mengubahnya di sini, terjatuh"</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah klasik sistem modular adalah dalam perjuangan melawan regresi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengembangan TDD sulit digunakan untuk monolit karena koherensi metode yang berbeda (Anda dapat dengan mudah menghabiskan 30 baris tes pada lima baris kode, ditambah perlengkapan). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, dalam perang melawan regresi, perlu untuk menutupi fungsional dengan tes integrasi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun mengingat perkembangan yang sudah lambat (setelah semua, Anda perlu mengembangkannya dengan hati-hati untuk menyediakan banyak penggantian), pelanggan tidak ingin membayar untuk tes integrasi yang kompleks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tes fungsional menjadi sebesar tidak berarti. Mereka berjalan berjam-jam, bahkan secara paralel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya, front modern seperti PWA dapat diuji API secara fungsional. Tetapi tes sering bergantung pada penerimaan data dari sirkuit eksternal - dan karenanya mulai gagal jika, misalnya, uji SAP berada di belakang toko bahan makanan selama N bulan, dan uji "1C" mengirim data yang salah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika Anda harus mengunggah suntingan kecil untuk beberapa modul, pengembang harus memilih dari dua kejahatan: mulai menjalankan CI penuh dan menghabiskan banyak waktu pada penyebaran atau lay out hotfix tanpa menjalankan tes, berisiko melanggar sesuatu. Sangat dramatis ketika pengeditan tersebut tiba dari departemen pemasaran pada Black Friday. Tentu saja, cepat atau lambat, regresi dan kesalahan manusia akan terjadi. Apakah itu familier?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada akhirnya, untuk memenuhi tujuan bisnis, tim beralih ke mode operasi darurat, dengan terampil menyulap tes dan dengan hati-hati melihat dashboard dari log - Kibana, Grafana, Zabbix ... Dan apa yang kita dapatkan pada akhirnya? </font><font style="vertical-align: inherit;">Habis terbakar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda harus mengakui bahwa situasi dengan regresi tidak seperti "perusahaan stabil" sebagaimana mestinya dalam mimpi dan impian pelanggan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah # 4: Konektivitas Kode dan Pembaruan Platform</font></font></h3><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah lain dengan konektivitas kode adalah kesulitan dalam memperbarui platform. </font></font><br>
ï»¿<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, Magento berisi dua juta baris kode. Di mana pun kita melihat, ada banyak kode di mana-mana (Akeneo, Pimcore, Bitrix). Saat menambahkan fungsionalitas ke kernel, akan lebih baik untuk mempertimbangkan perubahan akun di modul khusus Anda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah contoh langsung untuk Magento. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada akhir 2018, versi baru platform Magento 2.3 dirilis. Multistores dan Elasticsearch telah ditambahkan ke Edisi Open Source. Selain itu, ribuan bug diperbaiki di kernel dan beberapa barang dalam OMS ditambahkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang dihadapi proyek e-Commerce yang telah menulis multistores di Magento 2.2? Mereka perlu menulis ulang banyak logika dalam pemrosesan order, checkout, kartu produk untuk menggunakan fungsionalitas kotak. Memang, â€œbenar sekaliâ€ - mengapa menduplikasi fungsi versi kotak dalam modul? Mengurangi volume kode khusus dalam proyek besar selalu berguna - setelah semua, semua metode kotak memperhitungkan multi-gudang ini, dan memperbarui kotak tanpa refactoring tersebut bisa sia-sia (perhatikan masalah keamanan untuk kesederhanaan, terutama karena mereka dapat digulung tanpa memperbarui). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang bayangkan: berapa banyak waktu yang akan dihabiskan untuk pembaruan semacam itu dan bagaimana ini bisa diuji tanpa tes integrasi, yang sulit untuk ditulis?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak mengherankan bahwa bagi banyak orang, memperbarui platform terjadi baik tanpa refactoring, tetapi dengan peningkatan duplikasi, atau (jika tim ingin melakukan segalanya dalam feng shui) dengan "meninggalkan" untuk waktu yang lama dalam refactoring dan memulihkan ketertiban.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah No. 5. Opacity dari proses bisnis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu masalah paling penting dalam manajemen proyek adalah bahwa pelanggan tidak melihat semua logika dan semua proses bisnis proyek. </font><font style="vertical-align: inherit;">Mereka hanya dapat dipulihkan dari kode atau dari dokumentasi (relevansinya, seperti yang kami katakan sebelumnya, bermasalah untuk dipelihara dalam sistem modular).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya, Bitrix memiliki bagian BPM, sementara Pimcore memiliki visualisasi alur kerja. </font><font style="vertical-align: inherit;">Tetapi upaya ini untuk mengelola modul melalui proses bisnis selalu bertentangan dengan kehadiran kernel. </font><font style="vertical-align: inherit;">Selain itu, peristiwa, penghitung waktu kompleks, operasi transaksional - semua ini tidak terjadi dalam BPM monolit. </font><font style="vertical-align: inherit;">Saya ulangi: ini berlaku untuk perusahaan menengah dan besar. </font><font style="vertical-align: inherit;">Untuk perusahaan kecil, kemampuan sistem modular sudah cukup. </font><font style="vertical-align: inherit;">Tetapi jika kita berbicara tentang segmen perusahaan, maka solusi ini masih tidak memiliki pusat kendali tunggal di mana Anda dapat pergi dan melihat diagram dari setiap proses, status apa pun, bagaimana tepatnya sesuatu terjadi, apa saja pengecualian, penghitung waktu, peristiwa dan mahkota . </font><font style="vertical-align: inherit;">Tidak ada cukup kesempatan untuk mengubah proses bisnis, tetapi tidak modul. </font><font style="vertical-align: inherit;">Manajemen proses proyek tenggelam dalam kecepatan perubahan dan koherensi logika.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah 6. Kompleksitas penskalaan sistem</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda menggunakan monolith, itu akan digunakan secara keseluruhan dengan semua modul di setiap server aplikasi. </font><font style="vertical-align: inherit;">Itu </font><font style="vertical-align: inherit;">Anda tidak dapat secara terpisah meningkatkan layanan pemrosesan pesanan dan bonus dalam satu musim, secara terpisah dari sisa kode. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlu lebih banyak memori dan prosesor, yang sangat meningkatkan biaya cluster.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana layanan microser menyelamatkan pelanggan dari kekurangan khas pengembangan modular. </font><font style="vertical-align: inherit;">Orkestra Layanan Mikro di Camunda dan jBPM</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Spoiler: Solusi untuk masalah yang tercantum dalam paragraf terakhir dimungkinkan menggunakan BPMS dan mengatur sistem layanan mikro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BPMS (sistem manajemen proses bisnis bahasa Inggris) adalah perangkat lunak untuk mengelola proses bisnis dalam suatu perusahaan. BPMS populer yang bekerja dengan kami adalah Camunda dan jBPM. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Orkestrasi menjelaskan bagaimana layanan harus berinteraksi satu sama lain menggunakan olahpesan, termasuk logika bisnis dan serangkaian tindakan. Menggunakan BPMS, kami tidak hanya menggambar skema abstrak - proses bisnis kami akan dieksekusi sesuai dengan yang ditarik. Apa yang kita lihat dalam diagram dijamin berkorelasi dengan cara proses bekerja, apa layanan-mikro yang digunakan, parameter apa, sesuai dengan tabel keputusan mana, logika tertentu dipilih.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ct/ik/ul/ctikula_txivfnw4laxpscmckiq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai contoh, kami mengambil proses yang sering ditemui - mengirim pesanan untuk pengiriman. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan pesan atau panggilan langsung apa pun, kami mulai memproses pesanan dengan proses memilih metode pengiriman. </font><font style="vertical-align: inherit;">Logika pemilihan diatur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akibatnya, proses, layanan, dan pengembangan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menjadi mudah dibaca;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">self-documenting (mereka bekerja persis seperti yang digambar, dan tidak ada rassynchron antara dokumentasi dan pekerjaan kode yang sebenarnya);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cukup debugged (mudah untuk melihat bagaimana proses ini atau itu berjalan dan memahami apa kesalahannya).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan berkenalan dengan prinsip-prinsip dimana sistem manajemen proses bisnis bekerja.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prinsip BPMS No. 1. Pembangunan Menjadi Visual dan Proses</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BPMS memungkinkan Anda untuk membuat proses bisnis di mana tim proyek (pengembang atau pengguna bisnis) menentukan urutan peluncuran layanan-layanan mikro, serta kondisi dan cabang di mana ia bergerak. </font><font style="vertical-align: inherit;">Dalam hal ini, satu proses bisnis (urutan tindakan) dapat dimasukkan dalam proses bisnis lain. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua ini disajikan dengan jelas di BPMS: secara real time Anda dapat menonton skema ini, mengeditnya, menempatkannya dengan cara yang produktif. </font><font style="vertical-align: inherit;">Di sini, prinsip lingkungan yang mendokumentasikan diri terpenuhi secara maksimal - prosesnya bekerja persis seperti yang divisualisasikan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua layanan microsoft menjadi kubus proses yang dapat ditambahkan dari snap ke pengguna bisnis. </font><font style="vertical-align: inherit;">Bisnis mengelola prosesnya, dan pengembang bertanggung jawab atas ketersediaan dan operasi yang benar dari layanan mikro tertentu. </font><font style="vertical-align: inherit;">Selain itu, semua pihak memahami logika umum dan tujuan dari proses tersebut.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prinsip BPMS No. 2. Setiap layanan memiliki input dan output yang jelas.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prinsipnya terdengar sangat sederhana, dan mungkin bagi pengembang atau pengguna bisnis yang tidak berpengalaman bahwa BPMS tidak meningkatkan strategi penulisan layanan mikro dengan cara apa pun. </font><font style="vertical-align: inherit;">Seperti, layanan microser biasa dapat ditulis tanpa BPMS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya, itu mungkin, tetapi sulit. </font><font style="vertical-align: inherit;">Ketika seorang pengembang menulis layanan mikro tanpa BPMS, ia pasti memiliki keinginan untuk menghemat abstrak. </font><font style="vertical-align: inherit;">Layanan microsoft menjadi terus terang besar, dan terkadang mereka bahkan mulai menggunakan kembali yang lain. </font><font style="vertical-align: inherit;">Ada keinginan untuk menghemat transparansi transfer hasil dari satu layanan ke yang lain. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BPMS mendorong Anda untuk menulis lebih abstrak. </font><font style="vertical-align: inherit;">Pengembangan dilakukan dengan tepat proses, dengan definisi input dan output.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prinsip BPMS No. 3. Concurrency dari pemrosesan antrian</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bayangkan proses pemrosesan pesanan: kita harus pergi ke suatu pasar, mengambil semua pesanan yang baik dan mulai memprosesnya. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7b5/a9d/d5a/7b5a9dd5a1bc98e6a13215e99bece0fd.jpg" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lihatlah diagram (bagian dari diagram). </font><font style="vertical-align: inherit;">Di sini ditentukan bahwa setiap 10 menit kami memeriksa semua pesanan pasar, kemudian berjalan secara paralel (seperti yang ditunjukkan oleh "hamburger" vertikal dalam Pesanan Proses) pemrosesan setiap pesanan. </font><font style="vertical-align: inherit;">Jika berhasil, transfer semua data ke ERP dan selesaikan pemrosesan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita tiba-tiba perlu menaikkan log untuk memproses pesanan tertentu, di Camunda, JBoss atau BPMS lainnya, kita akan dapat sepenuhnya memulihkan semua data dan melihat di mana antrian itu dan dengan parameter input / output apa.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prinsip BPMS No. 4. </font><font style="vertical-align: inherit;">Kesalahan dan eskalasi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bayangkan bahwa suatu kesalahan terjadi selama proses pengiriman. </font><font style="vertical-align: inherit;">Misalnya (omong-omong, ini kasus nyata), perusahaan transportasi menerima pesanan, dan kemudian gudang dibakar. </font><font style="vertical-align: inherit;">Kisah nyata lainnya: terburu-buru Malam Tahun Baru, produk pertama kali ditunda, dan kemudian, mungkin, hilang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, peristiwa dipicu oleh mouse di BPMS, misalnya, pemberitahuan klien jika waktu pengiriman telah lewat. </font><font style="vertical-align: inherit;">Jika Anda menerima kesalahan dari perusahaan transportasi di dalam, Anda dapat memulai proses di cabang Anda sendiri dan mengganggu semuanya: beri tahu, berikan diskon pada pesanan berikutnya, kembalikan uangnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua pengecualian semacam itu sulit tidak hanya untuk program di luar BPMS (misalnya, penghitung waktu dalam penghitung waktu), tetapi juga harus dipahami dalam konteks keseluruhan proses.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prinsip BPMS No. 5. </font><font style="vertical-align: inherit;">Pilihan tindakan untuk salah satu acara dan opsi antarproses</font></font><br>
</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kirim pesanan yang sama dalam pengiriman. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara total, kami memiliki tiga skenario:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">barang dikirim seperti yang diharapkan;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">barang tidak dikirim seperti yang diharapkan;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">barang telah hilang.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Langsung di BPMS, kita dapat menentukan prosedur pengiriman barang ke perusahaan transportasi dan mengharapkan salah satu peristiwa dengan memesan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengiriman yang berhasil (pesan dari proses pengiriman produk bahwa semuanya dikirimkan);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau timbulnya beberapa waktu.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika waktu belum berlalu, Anda perlu memulai layanan lain: parsing pesanan khusus ini dengan operator (Anda perlu mengatur tugas untuk itu dalam sistem OMS / CRM untuk mengetahui di mana pesanan berada) dengan pemberitahuan lebih lanjut dari klien. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi jika selama investigasi pesanan telah disampaikan, Anda harus menghentikan investigasi dan menyelesaikan pesanan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di BPMS, semua interupsi dan pengecualian ada di pihak BPMS. </font><font style="vertical-align: inherit;">Anda tidak membebani kode dengan logika ini (dan keberadaan logika tersebut dalam kode akan membuat layanan microser besar dan buruk digunakan kembali dalam proses lain).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prinsip BPMS No. 6. </font><font style="vertical-align: inherit;">Di Camunda Anda, Anda akan melihat semua log</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menggunakan acara dan opsi antarproses, Anda:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda melihat seluruh rangkaian peristiwa dalam satu jendela (apa yang terjadi dengan urutan, cabang pengecualian yang dilaluinya, dll. - mudah dilihat);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat mengumpulkan semua analitik untuk BI berdasarkan log BPMS saja (tanpa perlu membebani layanan Microsoft dengan peristiwa logging).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akibatnya, Anda akan dapat mengumpulkan statistik secara khusus tentang masalah pemrosesan, tingkat transisi, semua proses perusahaan. </font><font style="vertical-align: inherit;">Ada penyatuan informasi logging - mudah untuk menghubungkan acara dalam pengiriman dengan tindakan operator atau acara dari sistem informasi lainnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan perbedaan dengan sistem modular: log universal juga dapat dibuat di sana, tetapi ketika berinteraksi dengan sistem lain, Anda perlu melakukan sesuatu dengan penyatuan pencatatan di dalamnya, dan ini tidak selalu memungkinkan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan: perbandingan arsitektur perangkat mikro dan modular</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap jenis arsitektur memiliki kelebihan dan kekurangan. Tidak ada solusi universal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami tidak menganjurkan pergeseran besar-besaran ke layanan mikro. Sebaliknya, untuk bisnis kecil atau ketika menggunakan sedikit penyesuaian, pendekatan modular akan lebih cocok. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juga, kami tidak menentang solusi TI apa pun (Bitrix, Magento, kerangka kerja seperti Symfony atau Django, dll.), Karena kami mengembangkan lebih dari enam ribu jam kode setiap bulan pada kerangka kerja ini saja, dan jumlah front'a dan layanan microser. Oleh karena itu, kami yakin bahwa penting untuk mencari solusi teknis yang sesuai, dan tidak mempromosikan penggunaan platform tertentu (yang, sayangnya, bagian penting dari penjualan di bidang TI sedang meluncur).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bagian artikel sebelumnya, Anda belajar tentang kerugian dan kelebihan arsitektur modular. </font><font style="vertical-align: inherit;">Kami berharap ini sudah membantu mengevaluasi apakah penyempurnaan versi kotak atau pembuatan layanan microser dari awal akan lebih cocok. </font><font style="vertical-align: inherit;">Jika tidak mungkin untuk memutuskan, mari kita lihat bagaimana berbagai jenis arsitektur berubah tergantung pada kehidupan proyek. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada awal proyek:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan microservices - Anda tidak memiliki fungsionalitas, dan Anda harus menulis semuanya untuk mulai bekerja;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan sistem modular - dari versi kotak, sejumlah besar fungsi segera tersedia untuk Anda, dan Anda dapat mulai menggunakan produk segera setelah pembelian.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah 3-4 bulan pertama pengembangan (ini adalah tanggal rilis rata-rata untuk MVP pertama) dan seterusnya:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan microservices - volume fungsionalitas secara bertahap disejajarkan dengan versi kotak. </font><font style="vertical-align: inherit;">Untuk bisnis menengah, arsitektur microservice akan mengejar ketinggalan dengan modular cukup cepat, tetapi untuk besar - umumnya secara instan. </font><font style="vertical-align: inherit;">Dan di masa depan, pemeliharaan dan pengembangan sistem modular dalam hal unit fungsional akan meningkat;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan sistem modular - kecepatan pengembangan fungsionalitas akan jauh lebih rendah daripada di layanan mikro.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/getpro/habr/post_images/8e3/771/cc5/8e3771cc589bd9e28a8344e2ea2a1b37.jpg" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai kesimpulan, mari kita lihat bagaimana orkestrasi layanan microser terlihat dengan contoh spesifik.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh layanan visualisasi orkestrasi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan orkestrasi layanan menggunakan Camunda. </font><font style="vertical-align: inherit;">Dari gambar-gambar berikut, Anda dapat mengevaluasi betapa mudahnya mengelola layanan microser menggunakan BPMS dengan orkestrator. </font><font style="vertical-align: inherit;">Semua proses adalah visual, logikanya jelas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proses bisnis terlihat seperti ini: </font></font><br>
<img src="https://habrastorage.org/getpro/habr/post_images/ad3/5b5/cd6/ad35b5cd690d2ca590c703ab3ed8d3e4.webp" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh (pesanan, ketersediaan layanan): </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/56b/f55/d9e/56bf55d9e2fb275a477601628430d2c6.jpg" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dapat dilihat bahwa dalam pesanan ini ada cabang "Tidak ada barang". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salinan lain dari pesanan (pergi ke perakitan): </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/470/5d8/4c1/4705d84c19cebb0ad9c5fca58f41d2fd.jpg" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pesanan lebih jauh dan sesuai dengan tabel keputusan (DMN) pergi ke cabang pemrosesan oleh operator layanan pengiriman tertentu (Boxberry): </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/af8/d54/486/af8d5448653f276387c54492a93fece2.jpg" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perawatan untuk proses bersarang: Proses </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/14c/b45/693/14cb45693eca190e592e3d2357c92d6b.jpg" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bersarang bekerja: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/14c/b45/693/14cb45693eca190e592e3d2357c92d6b.jpg" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejarah proses bisnis: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d78/88b/be8/d7888bbe8dbbb036df2425c2a5d115f0.jpg" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Properti visualisasi ini:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proses bisnis mudah dibaca bahkan oleh pengguna yang tidak siap;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mereka dapat dieksekusi, yaitu, mereka bekerja persis seperti yang digambar, tidak ada rassynchron antara "dokumentasi" dan kerja aktual dari kode;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prosesnya transparan: mudah untuk melihat bagaimana impor, pesanan, pemrosesan berjalan, mudah untuk melihat di mana kesalahan itu dibuat.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ingatlah bahwa kami di kt.team menggunakan pengembangan modular dan microservice, memilih opsi yang tepat untuk setiap produk secara individual. </font><font style="vertical-align: inherit;">Tetapi jika pilihan telah dibuat dalam mendukung arsitektur layanan-mikro, maka kami sangat yakin bahwa tidak mungkin dilakukan tanpa sistem BPM seperti Camunda atau jBPM. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lihat juga: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video pada topik "Arsitektur microservice atau monolitik: apa yang harus dipilih?"</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id497232/index.html">Nikolay Petrov: "OpenStreetMap adalah proyek di mana tidak perlu untuk berkomunikasi dengan orang-orang"</a></li>
<li><a href="../id497234/index.html">Memodifikasi Proxy MQTT</a></li>
<li><a href="../id497238/index.html">Membuat SQL Server dan PerfMon Friends</a></li>
<li><a href="../id497240/index.html">Analisis laporan Baruch Sadogursky "DevOps untuk pengembang (atau menentang mereka?!)"</a></li>
<li><a href="../id497242/index.html">Respirator setengah masker buatan sendiri dari bahan improvisasi dalam 10 menit</a></li>
<li><a href="../id497254/index.html">Cisco HyperFlex: Peluncuran, Konfigurasi, Integrasi Cloud - 21-22 April</a></li>
<li><a href="../id497258/index.html">Tcl / Tk. Penjelajah file alternatif untuk platform Linux dan Android</a></li>
<li><a href="../id497260/index.html">Bagaimana para pengembang Myst berhasil menyesuaikan seluruh alam semesta dalam satu CD-ROM</a></li>
<li><a href="../id497264/index.html">Antarmuka yang dipersonalisasi. Bagian 2. Pengaturan navigasi otomatis</a></li>
<li><a href="../id497268/index.html">Judul "Baca artikel untuk Anda." Maret 2020. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>