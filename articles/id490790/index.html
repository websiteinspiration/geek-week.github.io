<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏻 🚬 🔠 File Zip: Sejarah, Penjelasan, dan Implementasi ◻️ 🕶️ 🐻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya sudah lama bertanya-tanya bagaimana data dikompresi, termasuk dalam file Zip. Suatu kali saya memutuskan untuk memuaskan rasa ingin tahu saya: un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>File Zip: Sejarah, Penjelasan, dan Implementasi</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/490790/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bo/tw/dr/botwdrbtegpbnpnwmy7id56fbaa.jpeg"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya sudah lama bertanya-tanya bagaimana data dikompresi, termasuk dalam file Zip. Suatu kali saya memutuskan untuk memuaskan rasa ingin tahu saya: untuk mempelajari cara kompresi, dan menulis program Zip saya sendiri. Implementasi telah menjadi latihan yang menyenangkan dalam pemrograman. Anda mendapatkan kesenangan luar biasa dari membuat mesin debugged yang mengambil data, mentransfer bit-bitnya ke representasi yang lebih efisien, dan kemudian mengumpulkannya kembali. Saya harap Anda juga akan tertarik membacanya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini menjelaskan dengan sangat rinci bagaimana file Zip dan skema kompresi bekerja: kompresi LZ77, algoritma Huffman, algoritma Deflate dan banyak lagi. Anda akan mempelajari sejarah perkembangan teknologi dan melihat contoh implementasi yang cukup efektif yang ditulis dari awal dalam C. Kode sumbernya ada di sini: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hwzip-1.0.zip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya sangat berterima kasih kepada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ange Albertini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gynvael Coldwind</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fabian Giesen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jonas Skeppstedt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">web</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primiano Tucci,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nico Weber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang memberikan umpan balik yang berharga pada draft artikel ini.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kandungan</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cerita</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PKZip</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Info-zip dan zlib</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winzip</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompresi Lempel-Ziv (LZ77)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode Huffman</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma Huffman</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode kanonik Huffman</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decoding Huffman yang Efisien</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menurunkan</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit stream</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membongkar (Inflasi)</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blok Deflate Terkompresi</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengempiskan blok menggunakan kode Huffman tetap</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengempiskan blok menggunakan kode Huffman dinamis</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompresi (Deflasi)</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Format File Zip</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambaran</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur data</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhir dari entri direktori pusat</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Header file pusat</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Header file lokal</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penerapan Zip Read</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi Catatan Zip</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hwzip</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">petunjuk perakitan</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latihan</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahan yang berguna</font></font></a></li>
</ul><br>
<a name="1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cerita</font></font></h2><br>
<a name="2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PKZip</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada tahun delapan puluhan dan awal sembilan puluhan, sebelum Internet menjadi luas, penggemar komputer menggunakan modem dial-up untuk terhubung melalui jaringan telepon ke jaringan Bulletin Board Systems (BBS). </font><font style="vertical-align: inherit;">BBS adalah sistem komputer interaktif yang memungkinkan pengguna mengirim pesan, bermain game, dan berbagi file. </font><font style="vertical-align: inherit;">Untuk online, cukup memiliki komputer, modem, dan nomor telepon BBS yang bagus. </font><font style="vertical-align: inherit;">Nomor </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diterbitkan di majalah komputer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan di BBS lainnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alat penting untuk memfasilitasi distribusi file adalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengarsip</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini memungkinkan Anda untuk menyimpan satu atau lebih file dalam satu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file arsip</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk lebih mudah menyimpan atau mengirimkan informasi. Dan idealnya, arsip juga mengkompresi file untuk menghemat ruang dan waktu untuk pengiriman melalui jaringan. Pada masa BBS, pengarsip Arc populer, ditulis oleh Tom Henderson dari System Enhancement Associates (SEA), sebuah perusahaan kecil yang ia dirikan bersama saudara iparnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada akhir 1980-an, programmer Phil Katz merilis Arc versi sendiri, PKArc. Itu kompatibel dengan Arc SEA, tetapi bekerja lebih cepat berkat subrutin yang ditulis dalam bahasa assembly dan menggunakan metode kompresi baru. Program ini menjadi populer, Katz berhenti dari pekerjaannya dan menciptakan PKWare untuk fokus pada pengembangan lebih lanjut. Menurut legenda, sebagian besar pekerjaan terjadi di dapur ibunya di Glendale, Wisconsin.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1e/50a/990/b1e50a990a86a05045dde9d2a819fbf0.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foto oleh Phil Katz </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari sebuah artikel di Milwaukee Sentinel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , 19 September 1994.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Namun, KLHS tidak senang dengan inisiatif Katz. Perusahaan menuduhnya melakukan pelanggaran merek dagang dan hak cipta. Litigasi dan kontroversi di jaringan BBS dan dunia PC telah dikenal sebagai </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arc Wars</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pada akhirnya, perselisihan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diselesaikan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk SEA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meninggalkan Arc, Katz menciptakan format pengarsipan baru pada tahun 1989, yang ia sebut Zip dan tersedia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk umum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote> ,   ,        ,      .  ,  ".ZIP",             ,      ,     ,          , , ,                  ,     ,      .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Program Katz untuk membuat file seperti itu disebut PKZip dan segera menyebar ke dunia BBS dan PC. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu aspek yang paling mungkin berkontribusi pada keberhasilan format Zip adalah bahwa dokumentasi tersebut disertai dengan PKZip, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application Note</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang menjelaskan secara rinci bagaimana format itu bekerja. Ini memungkinkan orang lain untuk mempelajari format dan membuat program yang menghasilkan, mengekstrak, atau berinteraksi dengan file Zip. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zip - format kompresi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tanpa kehilangan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : setelah mengekstrak data akan sama seperti sebelum kompresi. Algoritma mencari redundansi dalam sumber data dan lebih efisien menyajikan informasi. Pendekatan ini berbeda dari </font><i><font style="vertical-align: inherit;">kompresi</font></i><font style="vertical-align: inherit;"> lossy </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang digunakan dalam format seperti JPEG dan MP3: ketika dikompresi, beberapa informasi yang kurang terlihat oleh mata manusia atau telinga dibuang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PKZip didistribusikan sebagai Shareware: dapat digunakan dan disalin secara bebas, tetapi penulis menyarankan pengguna untuk "mendaftar" program. </font><font style="vertical-align: inherit;">Untuk $ 47, Anda bisa mendapatkan instruksi cetak, dukungan premium, dan versi aplikasi yang ditingkatkan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/031/509/4fc/0315094fc6917b61db8f78b2f776ce13.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu versi utama PKZip adalah 2.04c, dirilis pada 28 Desember 1992 ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versi 2.04g</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dirilis tidak lama setelah itu </font><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Ini menggunakan algoritma kompresi Deflate default. </font><font style="vertical-align: inherit;">Versi menentukan pengembangan lebih lanjut dari kompresi dalam file Zip ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel yang ditujukan untuk rilis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58e/bd3/69b/58ebd369bf36c272d0c8c7c9515fc670.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejak itu, format zip telah digunakan dalam banyak format file lainnya. </font><font style="vertical-align: inherit;">Misalnya, arsip Java (.jar), Paket Aplikasi Android (.apk), dan file .docx Microsoft Office menggunakan format Zip. </font><font style="vertical-align: inherit;">Banyak format dan protokol menggunakan algoritma kompresi yang sama, Deflate. </font><font style="vertical-align: inherit;">Katakanlah, halaman web mungkin ditransfer ke browser Anda sebagai file gzip, format yang menggunakan kompresi Deflate. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Phil Katz meninggal pada tahun 2000. </font><font style="vertical-align: inherit;">PKWare masih ada dan mendukung format Zip, meskipun perusahaan berfokus terutama pada perangkat lunak perlindungan data.</font></font><br>
<br>
<a name="3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Info-zip dan zlib</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tak lama setelah rilis PKZip pada tahun 1989, program lain untuk membongkar file Zip mulai muncul. Misalnya, program </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unzip</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang dapat membongkar sistem Unix. Pada bulan Maret 1990, milis bernama Info-ZIP dibuat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grup </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Info-ZIP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> telah merilis program open source gratis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unzip</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zip</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang digunakan untuk membongkar dan membuat file zip. Kode telah porting ke banyak sistem, dan itu masih standar untuk program Zip untuk sistem Unix. Ini kemudian membantu meningkatkan popularitas file Zip. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah Info-ZIP kode yang melakukan kompresi dan dekompresi deflate dipindahkan ke perpustakaan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zlib</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terpisah </font><font style="vertical-align: inherit;">yang mereka tulis</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jean-loup Gailly</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (kompresi) dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mark Adler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (membongkar).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68b/216/d1d/68b216d1debaffdb2d890067e38bed47.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jean-loup Gailly (kiri) dan Mark Adler (kanan) pada Penghargaan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USENIX STUG 2009</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Salah satu alasan untuk membuat perpustakaan adalah bahwa ia menyediakan kenyamanan menggunakan kompresi Deflate di aplikasi dan format lain, misalnya, di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gzip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PNG baru</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Format baru ini dimaksudkan untuk menggantikan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compress</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GIF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang menggunakan algoritma LZW yang dilindungi paten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai bagian dari pembuatan format ini, Peter Deutsch menulis spesifikasi Deflate dan menerbitkannya dengan nama </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internet RFC 1951</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada Mei 1996. Ini ternyata deskripsi yang lebih mudah diakses dibandingkan dengan Catatan Aplikasi PKZip asli.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hari ini zlib digunakan di mana-mana. </font><font style="vertical-align: inherit;">Mungkin dia sekarang bertanggung jawab untuk mengompresi halaman ini di server web dan membongkar di browser Anda. </font><font style="vertical-align: inherit;">Saat ini, sebagian besar file zip dikompresi dan didekompresi menggunakan zlib.</font></font><br>
<br>
<a name="4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winzip</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banyak dari mereka yang tidak menemukan PKZip menggunakan WinZip. Pengguna PC beralih dari DOS ke Windows, dan dari PKZip ke WinZip. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya dimulai dengan proyek oleh programmer Nico Mac, yang menciptakan perangkat lunak untuk OS / 2 di Mansfield Software Group di Storrs-Mansfield, Connecticut. Nico menggunakan Presentation Manager, ini adalah antarmuka pengguna grafis di OS / 2, dan dia kesal karena dia harus beralih dari manajer file ke perintah DOS setiap kali dia ingin membuat file Zip. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mac menulis sebuah program GUI sederhana yang bekerja dengan file Zip langsung di Presentation Manager, menamainya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PMZip,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan merilisnya sebagai shareware pada 1990-an.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OS / 2 tidak berhasil, dan dunia PC mengambil alih Microsoft Windows. </font><font style="vertical-align: inherit;">Pada tahun 1991, Mac memutuskan untuk belajar bagaimana menulis program Windows, dan proyek pertamanya adalah port aplikasi Zip-nya ke OS baru. </font><font style="vertical-align: inherit;">Pada April 1991, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WinZip 1.00 dirilis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Itu didistribusikan sebagai shareware dengan masa percobaan 21 hari dan biaya pendaftaran $ 29. </font><font style="vertical-align: inherit;">Dia terlihat seperti ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b1/2f4/bcd/0b12f4bcd048691aa0487b9d3a445b39.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam versi pertama WinZip, PKZip digunakan di bawah tenda. </font><font style="vertical-align: inherit;">Tetapi dari versi 5.0 pada tahun 1993, kode dari Info-ZIP mulai digunakan untuk pemrosesan langsung file Zip. </font><font style="vertical-align: inherit;">Antarmuka pengguna juga berevolusi secara bertahap.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf4/273/962/bf427396212f63fba9c80db12fdd2132.png"></div><br>
<i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WinZip 6.3 di</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bawah Windows 3.11 untuk Workgroups. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WinZip adalah salah satu program shareware paling populer di tahun 1990-an. </font><font style="vertical-align: inherit;">Tetapi pada akhirnya, itu kehilangan relevansi karena menanamkan dukungan untuk file Zip dalam sistem operasi. </font><font style="vertical-align: inherit;">Windows telah bekerja dengan mereka sebagai "folder terkompresi" sejak tahun 2001 (Windows XP), perpustakaan</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DynaZip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> digunakan untuk ini</font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mac pada awalnya bernama Nico Mak Computing. </font><font style="vertical-align: inherit;">Pada tahun 2000, namanya diganti menjadi WinZip Computing, dan sekitar tahun-tahun itu Mack meninggalkannya. </font><font style="vertical-align: inherit;">Pada tahun 2005,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vector Capital menjual</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perusahaan</font><font style="vertical-align: inherit;">, dan pada akhirnya, itu menjadi milik</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Corel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang masih merilis WinZip sebagai produk.</font></font><br>
<br>
<a name="5"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompresi Lempel-Ziv (LZ77)</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompresi zip terdiri dari dua bahan utama: kompresi Lempel-Ziv dan kode Huffman. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu cara untuk mengompres teks adalah dengan membuat daftar kata atau frasa umum dengan penggantian varietas kata-kata ini di dalam teks dengan tautan ke kamus. Misalnya, kata panjang "kompresi" dalam teks sumber dapat direpresentasikan sebagai # 1234, di mana 1234 merujuk pada posisi kata dalam daftar. Ini disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kompresi kamus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi dari sudut pandang kompresi universal, metode ini memiliki beberapa kelemahan. Pertama, apa sebenarnya yang harus masuk ke kamus? Sumber data dapat dalam berbagai bahasa, bahkan bisa juga bukan teks yang dapat dibaca manusia. Dan jika kamus tidak disetujui sebelumnya antara kompresi dan dekompresi, maka kamus harus disimpan dan ditransfer bersama dengan data terkompresi, yang mengurangi manfaat kompresi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi elegan untuk masalah ini adalah dengan menggunakan sumber data itu sendiri sebagai kamus. Pada tahun </font><font style="vertical-align: inherit;">1977, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma Universal untuk Kompresi Data Sekuensial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Jacob Ziv dan Abraham Lempel (yang bekerja di Technion), mengusulkan skema kompresi di mana data sumber disajikan sebagai urutan kembar tiga:</font></font><br>
<br>
<pre><code class="cpp hljs">(, , )
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
di mana </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mereka </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membentuk tautan mundur ke urutan karakter yang ingin Anda salin dari posisi sebelumnya di teks asli, dan </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini adalah karakter berikutnya dalam data yang dihasilkan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e5/21e/fdb/5e521efdb5649015f685e26ab308d1b9.jpg"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ce/cfa/2e3/2cecfa2e39798ce3302ff4b48e1a62ef.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abraham Lempel dan Jacob Ziv. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan baris berikut:</font></font><br>
<br>
<pre><code class="cpp hljs">It was the best of times,<font></font>
it was the worst of times,<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada baris kedua, urutan "t was the w" dapat direpresentasikan sebagai (26, 10, w), karena dibuat kembali dengan menyalin 10 karakter dari posisi 26 karakter kembali ke huruf "w". Untuk karakter yang belum muncul, backlink panjang nol digunakan. Misalnya, "I" awal dapat direpresentasikan sebagai (0, 0, I). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skema ini disebut kompresi Lempel-Ziv, atau kompresi LZ77. Namun, dalam implementasi praktis dari algoritma, bagian dari triplet biasanya tidak digunakan </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sebagai gantinya, karakter dihasilkan secara individual, dan ( </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">pasangan digunakan untuk backlink </font><font style="vertical-align: inherit;">(opsi ini disebut kompresi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LZSS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Bagaimana </font><font style="vertical-align: inherit;">literal dan backlink </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dikodekan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah masalah yang terpisah, kami akan mempertimbangkannya di bawah ini ketika kami menganalisis algoritma</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengempis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teks ini:</font></font><br>
<br>
<pre><code class="cpp hljs">It was the best of times,<font></font>
it was the worst of times,<font></font>
it was the age of wisdom,<font></font>
it was the age of foolishness,<font></font>
it was the epoch of belief,<font></font>
it was the epoch of incredulity,<font></font>
it was the season of Light,<font></font>
it was the season of Darkness,<font></font>
it was the spring of hope,<font></font>
it was the winter of despair,<font></font>
we had everything before us,<font></font>
we had nothing before us,<font></font>
we were all going direct to Heaven,<font></font>
we were all going direct the other way<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat mengompres ini:</font></font><br>
<br>
<pre><code class="cpp hljs">It was the best of times,<font></font>
i(<span class="hljs-number">26</span>,<span class="hljs-number">10</span>)wor(<span class="hljs-number">27</span>,<span class="hljs-number">24</span>)age(<span class="hljs-number">25</span>,<span class="hljs-number">4</span>)wisdom(<span class="hljs-number">26</span>,<span class="hljs-number">20</span>)<font></font>
foolishnes(<span class="hljs-number">57</span>,<span class="hljs-number">14</span>)epoch(<span class="hljs-number">33</span>,<span class="hljs-number">4</span>)belief(<span class="hljs-number">28</span>,<span class="hljs-number">22</span>)incredulity<font></font>
(<span class="hljs-number">33</span>,<span class="hljs-number">13</span>)season(<span class="hljs-number">34</span>,<span class="hljs-number">4</span>)Light(<span class="hljs-number">28</span>,<span class="hljs-number">23</span>)Dark(<span class="hljs-number">120</span>,<span class="hljs-number">17</span>)<font></font>
spring(<span class="hljs-number">31</span>,<span class="hljs-number">4</span>)hope(<span class="hljs-number">231</span>,<span class="hljs-number">14</span>)inter(<span class="hljs-number">27</span>,<span class="hljs-number">4</span>)despair,
<span class="hljs-function">we had <span class="hljs-title">everyth</span><span class="hljs-params">(<span class="hljs-number">57</span>,<span class="hljs-number">4</span>)</span>before <span class="hljs-title">us</span><span class="hljs-params">(<span class="hljs-number">29</span>,<span class="hljs-number">9</span>)</span><span class="hljs-title">no</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">20</span>)</span>
<span class="hljs-title">we</span><span class="hljs-params">(<span class="hljs-number">12</span>,<span class="hljs-number">3</span>)</span>all <span class="hljs-title">go</span><span class="hljs-params">(<span class="hljs-number">29</span>,<span class="hljs-number">4</span>)</span>direct to <span class="hljs-title">Heaven</span>
<span class="hljs-params">(<span class="hljs-number">36</span>,<span class="hljs-number">28</span>)</span><span class="hljs-params">(<span class="hljs-number">139</span>,<span class="hljs-number">3</span>)</span><span class="hljs-params">(<span class="hljs-number">83</span>,<span class="hljs-number">3</span>)</span><span class="hljs-params">(<span class="hljs-number">138</span>,<span class="hljs-number">3</span>)</span>way
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu sifat penting dari backlink adalah mereka dapat tumpang tindih. </font><font style="vertical-align: inherit;">Ini terjadi ketika panjangnya lebih besar dari jarak. </font><font style="vertical-align: inherit;">Contohnya:</font></font><br>
<br>
<pre><code class="cpp hljs">Fa-la-la-la-la
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat mengompres ke:</font></font><br>
<br>
<pre><code class="cpp hljs">Fa-la(<span class="hljs-number">3</span>,<span class="hljs-number">9</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini mungkin tampak aneh bagi Anda, tetapi metode ini bekerja: setelah byte dari tiga "-la" pertama disalin, penyalinan terus menggunakan byte yang baru dibuat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan, ini adalah jenis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengkodean panjang seri</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di mana bagian data disalin berulang kali untuk mendapatkan panjang yang diinginkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh interaktif menggunakan kompresi Lempel-Ziv untuk lirik ditampilkan dalam artikel oleh Colin Morris. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah Pop Lyrics Getting More Repetitive? </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut ini adalah contoh menyalin backlink di C. Harap dicatat bahwa karena kemungkinan tumpang tindih, kami tidak dapat menggunakan </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font></font><code>memmove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Output the (dist,len) backref at dst_pos in dst. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lz77_output_backref</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_pos,
                                       <span class="hljs-keyword">size_t</span> dist, <span class="hljs-keyword">size_t</span> len)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;<font></font>
<font></font>
        assert(dist &lt;= dst_pos &amp;&amp; <span class="hljs-string">"cannot reference before beginning of dst"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {<font></font>
                dst[dst_pos] = dst[dst_pos - dist];<font></font>
                dst_pos++;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mudah untuk menghasilkan literal, tetapi untuk kelengkapannya kita akan menggunakan fungsi bantu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Output lit at dst_pos in dst. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lz77_output_lit</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_pos, <span class="hljs-keyword">uint8_t</span> lit)</span>
</span>{<font></font>
        dst[dst_pos] = lit;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan bahwa pemanggil fungsi ini harus memastikan bahwa ada </font></font><code>dst</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cukup ruang untuk data yang dihasilkan dan bahwa backlink tidak mengakses posisi sebelum dimulainya buffer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sulit untuk tidak menghasilkan data menggunakan backlink selama membongkar, tetapi untuk membuatnya terlebih dahulu saat mengompresi sumber data. Ini dapat dilakukan dengan cara yang berbeda, tetapi kami akan menggunakan metode berdasarkan tabel hash dari zlib, yang diusulkan dalam RFC 1951. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan menggunakan tabel hash dengan posisi awalan tiga karakter yang sebelumnya ditemukan dalam baris (backlink yang lebih pendek tidak membawa manfaat apa pun). Deflate memungkinkan backlink dalam 32.768 karakter sebelumnya - ini disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jendela</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini memberikan kompresi streaming: data input diproses sedikit demi sedikit, asalkan jendela dengan byte terakhir disimpan dalam memori. Namun, implementasi kami mengasumsikan bahwa semua data input tersedia untuk kami dan bahwa kami dapat memprosesnya secara bersamaan. Ini memungkinkan Anda untuk fokus pada kompresi daripada akuntansi, yang diperlukan untuk pemrosesan aliran. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan menggunakan dua array: di </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi nilai hash dari tiga karakter awalan untuk posisi di input, dan di </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi posisi posisi sebelumnya dengan nilai hash ini. Bahkan, </font></font><code>head[h]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini adalah judul dari daftar posisi awalan yang ditautkan dengan hash </font></font><code>h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan </font></font><code>prev[x]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menerima elemen sebelum </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">daftar.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LZ_WND_SIZE 32768</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LZ_MAX_LEN  258</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HASH_SIZE 15</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NO_POS    SIZE_MAX</span><font></font>
<font></font>
<span class="hljs-comment">/* Perform LZ77 compression on the len bytes in src. Returns false as soon as
   either of the callback functions returns false, otherwise returns true when
   all bytes have been processed. */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">lz77_compress</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> len,
                   <span class="hljs-keyword">bool</span> (*lit_callback)(<span class="hljs-keyword">uint8_t</span> lit, <span class="hljs-keyword">void</span> *aux),
                   <span class="hljs-keyword">bool</span> (*backref_callback)(<span class="hljs-keyword">size_t</span> dist, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">void</span> *aux),
                   <span class="hljs-keyword">void</span> *aux)</span>
</span>{
        <span class="hljs-keyword">size_t</span> head[<span class="hljs-number">1U</span> &lt;&lt; HASH_SIZE];
        <span class="hljs-keyword">size_t</span> prev[LZ_WND_SIZE];<font></font>
<font></font>
        <span class="hljs-keyword">uint16_t</span> h;
        <span class="hljs-keyword">size_t</span> i, j, dist;
        <span class="hljs-keyword">size_t</span> match_len, match_pos;
        <span class="hljs-keyword">size_t</span> prev_match_len, prev_match_pos;<font></font>
<font></font>
        <span class="hljs-comment">/* Initialize the hash table. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(head) / <span class="hljs-keyword">sizeof</span>(head[<span class="hljs-number">0</span>]); i++) {<font></font>
                head[i] = NO_POS;<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memasukkan posisi string baru ke tabel hash </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, itu diperbarui untuk menunjukkan yang sebelumnya </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kemudian diperbarui sendiri </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert_hash</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> hash, <span class="hljs-keyword">size_t</span> pos, <span class="hljs-keyword">size_t</span> *head, <span class="hljs-keyword">size_t</span> *prev)</span>
</span>{<font></font>
        prev[pos % LZ_WND_SIZE] = head[hash];<font></font>
        head[hash] = pos;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan operasi modulo saat mengindeks </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: kami hanya tertarik pada posisi yang termasuk dalam jendela saat ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alih-alih menghitung nilai hash untuk setiap awalan tiga karakter dari awal, kami akan menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hash ring</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan akan terus memperbaruinya sehingga hanya tiga karakter terakhir yang tercermin dalam nilainya:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint16_t</span> <span class="hljs-title">update_hash</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> hash, <span class="hljs-keyword">uint8_t</span> c)</span>
</span>{<font></font>
        hash &lt;&lt;= <span class="hljs-number">5</span>;                     <span class="hljs-comment">/* Shift out old bits. */</span>
        hash ^= c;                      <span class="hljs-comment">/* Include new bits. */</span>
        hash &amp;= (<span class="hljs-number">1U</span> &lt;&lt; HASH_SIZE) - <span class="hljs-number">1</span>;  <span class="hljs-comment">/* Mask off excess bits. */</span><font></font>
<font></font>
        <span class="hljs-keyword">return</span> hash;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peta hash kemudian dapat digunakan untuk secara efisien mencari kecocokan sebelumnya dengan urutan, seperti yang ditunjukkan di bawah ini. </font><font style="vertical-align: inherit;">Mencari kecocokan adalah operasi kompresi paling intensif sumber daya, jadi kami akan membatasi kedalaman pencarian dalam daftar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengubah berbagai parameter, seperti kedalaman pencarian pada daftar awalan dan melakukan perbandingan malas, seperti dijelaskan di bawah, adalah cara untuk meningkatkan kecepatan dengan mengurangi tingkat kompresi. </font><font style="vertical-align: inherit;">Pengaturan dalam kode kami dipilih agar sesuai dengan tingkat kompresi maksimum di zlib.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Find the longest most recent string which matches the string starting
 * at src[pos]. The match must be strictly longer than prev_match_len and
 * shorter or equal to max_match_len. Returns the length of the match if found
 * and stores the match position in *match_pos, otherwise returns zero. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">find_match</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> pos, <span class="hljs-keyword">uint16_t</span> hash,
                         <span class="hljs-keyword">size_t</span> prev_match_len, <span class="hljs-keyword">size_t</span> max_match_len,
                         <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> *head, <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> *prev,
                         <span class="hljs-keyword">size_t</span> *match_pos)</span>
</span>{
        <span class="hljs-keyword">size_t</span> max_match_steps = <span class="hljs-number">4096</span>;
        <span class="hljs-keyword">size_t</span> i, l;
        <span class="hljs-keyword">bool</span> found;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (prev_match_len == <span class="hljs-number">0</span>) {
                <span class="hljs-comment">/* We want backrefs of length 3 or longer. */</span>
                prev_match_len = <span class="hljs-number">2</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (prev_match_len &gt;= max_match_len) {
                <span class="hljs-comment">/* A longer match would be too long. */</span>
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (prev_match_len &gt;= <span class="hljs-number">32</span>) {
                <span class="hljs-comment">/* Do not try too hard if there is already a good match. */</span>
                max_match_steps /= <span class="hljs-number">4</span>;<font></font>
        }<font></font>
<font></font>
        found = <span class="hljs-literal">false</span>;<font></font>
        i = head[hash];<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (max_match_steps != <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (i == NO_POS) {
                        <span class="hljs-comment">/* No match. */</span>
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
<font></font>
                assert(i &lt; pos &amp;&amp; <span class="hljs-string">"Matches should precede pos."</span>);
                <span class="hljs-keyword">if</span> (pos - i &gt; LZ_WND_SIZE) {
                        <span class="hljs-comment">/* The match is outside the window. */</span>
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
<font></font>
                l = cmp(src, i, pos, prev_match_len, max_match_len);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (l != <span class="hljs-number">0</span>) {<font></font>
                        assert(l &gt; prev_match_len);<font></font>
                        assert(l &lt;= max_match_len);<font></font>
<font></font>
                        found = <span class="hljs-literal">true</span>;<font></font>
                        *match_pos = i;<font></font>
                        prev_match_len = l;<font></font>
<font></font>
                        <span class="hljs-keyword">if</span> (l == max_match_len) {
                                <span class="hljs-comment">/* A longer match is not possible. */</span>
                                <span class="hljs-keyword">return</span> l;<font></font>
                        }<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Look further back in the prefix list. */</span><font></font>
                i = prev[i % LZ_WND_SIZE];<font></font>
                max_match_steps--;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!found) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> prev_match_len;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Compare the substrings starting at src[i] and src[j], and return the length
 * of the common prefix. The match must be strictly longer than prev_match_len
 * and shorter or equal to max_match_len. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> i, <span class="hljs-keyword">size_t</span> j,
                  <span class="hljs-keyword">size_t</span> prev_match_len, <span class="hljs-keyword">size_t</span> max_match_len)</span>
</span>{
        <span class="hljs-keyword">size_t</span> l;<font></font>
<font></font>
        assert(prev_match_len &lt; max_match_len);<font></font>
<font></font>
        <span class="hljs-comment">/* Check whether the first prev_match_len + 1 characters match. Do this
         * backwards for a higher chance of finding a mismatch quickly. */</span>
        <span class="hljs-keyword">for</span> (l = <span class="hljs-number">0</span>; l &lt; prev_match_len + <span class="hljs-number">1</span>; l++) {
                <span class="hljs-keyword">if</span> (src[i + prev_match_len - l] !=<font></font>
                    src[j + prev_match_len - l]) {<font></font>
                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        assert(l == prev_match_len + <span class="hljs-number">1</span>);<font></font>
<font></font>
        <span class="hljs-comment">/* Now check how long the full match is. */</span>
        <span class="hljs-keyword">for</span> (; l &lt; max_match_len; l++) {
                <span class="hljs-keyword">if</span> (src[i + l] != src[j + l]) {
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        assert(l &gt; prev_match_len);<font></font>
        assert(l &lt;= max_match_len);<font></font>
        assert(<span class="hljs-built_in">memcmp</span>(&amp;src[i], &amp;src[j], l) == <span class="hljs-number">0</span>);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> l;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat menghentikan fungsi dengan </font></font><code>lz77_compress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode ini untuk mencari kecocokan sebelumnya:</font></font><br>
<br>
<pre><code class="cpp hljs">       <span class="hljs-comment">/* h is the hash of the three-byte prefix starting at position i. */</span>
        h = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (len &gt;= <span class="hljs-number">2</span>) {<font></font>
                h = update_hash(h, src[<span class="hljs-number">0</span>]);<font></font>
                h = update_hash(h, src[<span class="hljs-number">1</span>]);<font></font>
        }<font></font>
<font></font>
        prev_match_len = <span class="hljs-number">0</span>;<font></font>
        prev_match_pos = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i + <span class="hljs-number">2</span> &lt; len; i++) {<font></font>
                h = update_hash(h, src[i + <span class="hljs-number">2</span>]);<font></font>
<font></font>
                <span class="hljs-comment">/* Search for a match using the hash table. */</span><font></font>
                match_len = find_match(src, i, h, prev_match_len,<font></font>
                                       min(LZ_MAX_LEN, len - i), head, prev,<font></font>
                                       &amp;match_pos);<font></font>
<font></font>
                <span class="hljs-comment">/* Insert the current hash for future searches. */</span><font></font>
                insert_hash(h, i, head, prev);<font></font>
<font></font>
                <span class="hljs-comment">/* If the previous match is at least as good as the current. */</span>
                <span class="hljs-keyword">if</span> (prev_match_len != <span class="hljs-number">0</span> &amp;&amp; prev_match_len &gt;= match_len) {
                        <span class="hljs-comment">/* Output the previous match. */</span>
                        dist = (i - <span class="hljs-number">1</span>) - prev_match_pos;
                        <span class="hljs-keyword">if</span> (!backref_callback(dist, prev_match_len, aux)) {
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                        }<font></font>
                        <span class="hljs-comment">/* Move past the match. */</span>
                        <span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; min((i - <span class="hljs-number">1</span>) + prev_match_len,<font></font>
                                                len - <span class="hljs-number">2</span>); j++) {<font></font>
                                h = update_hash(h, src[j + <span class="hljs-number">2</span>]);<font></font>
                                insert_hash(h, j, head, prev);<font></font>
                        }<font></font>
                        i = (i - <span class="hljs-number">1</span>) + prev_match_len - <span class="hljs-number">1</span>;<font></font>
                        prev_match_len = <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* If no match (and no previous match), output literal. */</span>
                <span class="hljs-keyword">if</span> (match_len == <span class="hljs-number">0</span>) {<font></font>
                        assert(prev_match_len == <span class="hljs-number">0</span>);
                        <span class="hljs-keyword">if</span> (!lit_callback(src[i], aux)) {
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Otherwise the current match is better than the previous. */</span><font></font>
<font></font>
                <span class="hljs-keyword">if</span> (prev_match_len != <span class="hljs-number">0</span>) {
                        <span class="hljs-comment">/* Output a literal instead of the previous match. */</span>
                        <span class="hljs-keyword">if</span> (!lit_callback(src[i - <span class="hljs-number">1</span>], aux)) {
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                        }<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Defer this match and see if the next is even better. */</span><font></font>
                prev_match_len = match_len;<font></font>
                prev_match_pos = match_pos;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Output any previous match. */</span>
        <span class="hljs-keyword">if</span> (prev_match_len != <span class="hljs-number">0</span>) {<font></font>
                dist = (i - <span class="hljs-number">1</span>) - prev_match_pos;
                <span class="hljs-keyword">if</span> (!backref_callback(dist, prev_match_len, aux)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                i = (i - <span class="hljs-number">1</span>) + prev_match_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Output any remaining literals. */</span>
        <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
                <span class="hljs-keyword">if</span> (!lit_callback(src[i], aux)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode ini mencari backlink terpanjang yang dapat dihasilkan pada posisi saat ini. Tetapi sebelum mengeluarkannya, program memutuskan apakah mungkin untuk menemukan kecocokan yang lebih lama di posisi berikutnya. Dalam zlib, ini disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">evaluasi perbandingan malas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini masih merupakan </font><font style="vertical-align: inherit;">algoritma </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serakah</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : ia memilih pertandingan yang paling lama, bahkan jika yang lebih pendek saat ini memungkinkan Anda untuk kemudian mendapatkan pertandingan yang lebih lama dan mencapai kompresi yang lebih kuat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompresi Lempel-Ziv dapat bekerja cepat dan lambat. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zopfli</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menghabiskan banyak waktu mencari backlink optimal untuk memeras persentase kompresi tambahan. Ini berguna untuk data yang dikompresi sekali dan kemudian digunakan kembali, misalnya, untuk informasi statis di server web. Di sisi lain skala adalah kompresor seperti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Snappy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LZ4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang dibandingkan hanya dengan awalan 4-byte terakhir dan sangat cepat. Jenis kompresi ini berguna dalam database dan sistem RPC di mana waktu yang dihabiskan untuk kompresi terbayar dengan menghemat waktu saat mengirim data melalui jaringan atau ke disk. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gagasan menggunakan data sumber sebagai kamus sangat elegan, tetapi Anda juga dapat memanfaatkan kamus statis. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brotli</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah algoritma berbasis LZ77, tetapi juga menggunakan yang besar</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kamus statis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> string, yang sering ditemukan di jaringan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode LZ77 dapat dilihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di lz77.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lz77.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="6"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode Huffman</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algoritma kompresi Zip kedua adalah kode Huffman. </font><i><font style="vertical-align: inherit;">Kode</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
istilah </font><font style="vertical-align: inherit;">dalam konteks ini adalah referensi ke sistem untuk menyajikan data dalam bentuk lain. </font><font style="vertical-align: inherit;">Dalam hal ini, kami tertarik pada kode yang dapat digunakan untuk secara efisien mewakili literal dan backlink yang dihasilkan oleh algoritma Lempel-Ziv. </font><font style="vertical-align: inherit;">
Secara tradisional, teks bahasa Inggris disajikan menggunakan </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">American Standard Code for Information Interchange (ASCII)</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sistem ini memberikan setiap karakter nomor, yang biasanya disimpan dalam representasi 8-bit. </font><font style="vertical-align: inherit;">Berikut adalah kode ASCII untuk huruf besar alfabet bahasa Inggris:</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEBUAH</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">01000001</font></font></td>
<td><strong>N</strong></td>
<td>01001110</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>01000010</td>
<td><strong>O</strong></td>
<td>01001111</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>01000011</td>
<td><strong>P</strong></td>
<td>01010000</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>01000100</td>
<td><strong>Q</strong></td>
<td>01010001</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>01000101</td>
<td><strong>R</strong></td>
<td>01010010</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>01000110</td>
<td><strong>S</strong></td>
<td>01010011</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>01000111</td>
<td><strong>T</strong></td>
<td>01010100</td>
</tr>
<tr>
<td><strong>H</strong></td>
<td>01001000</td>
<td><strong>U</strong></td>
<td>01010101</td>
</tr>
<tr>
<td><strong>I</strong></td>
<td>01001001</td>
<td><strong>V</strong></td>
<td>01010110</td>
</tr>
<tr>
<td><strong>J</strong></td>
<td>01001010</td>
<td><strong>W</strong></td>
<td>01010111</td>
</tr>
<tr>
<td><strong>K</strong></td>
<td>01001011</td>
<td><strong>X</strong></td>
<td>01011000</td>
</tr>
<tr>
<td><strong>L</strong></td>
<td>01001100</td>
<td><strong>Y</strong></td>
<td>01011001</td>
</tr>
<tr>
<td><strong>M</strong></td>
<td>01001101</td>
<td><strong>Z</strong></td>
<td>01011010</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Satu byte per karakter adalah cara mudah untuk menyimpan teks. Ini memungkinkan Anda untuk dengan mudah mengakses atau memodifikasi bagian teks, dan selalu jelas berapa banyak byte yang diperlukan untuk menyimpan N karakter, atau berapa banyak karakter yang disimpan dalam N byte. Namun, ini bukan cara yang paling efektif dalam hal ruang yang ditempati. Misalnya, dalam bahasa Inggris, huruf E paling sering digunakan, dan Z paling sedikit digunakan. Oleh karena itu, dalam hal volume, lebih efisien untuk menggunakan representasi bit yang lebih pendek untuk E dan yang lebih lama untuk Z, daripada menetapkan jumlah bit yang sama untuk setiap karakter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode yang menentukan pengkodean panjang yang berbeda untuk karakter sumber yang berbeda disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode panjang variabel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Contoh paling terkenal adalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode Morse.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, di mana setiap karakter dikodekan dengan titik dan garis, awalnya ditransmisikan dengan telegraf dengan pulsa pendek dan panjang:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEBUAH</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• -</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- •</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- • • •</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HAI</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- - -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- • - •</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• - - •</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- • •</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- - • -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">•</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• - •</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• • - •</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• • •</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- - •</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• • • •</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• • -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saya</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• •</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• • • -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• - - -</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• - -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- • -</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- • • -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• - • •</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- • - -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- -</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- - • •</font></font></strong></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu kelemahan dari kode Morse adalah bahwa satu codeword mungkin merupakan awalan dari yang lain. Misalnya, • • - • tidak memiliki decoding yang unik: itu bisa F atau ER. Ini diselesaikan dengan jeda (panjang tiga titik) antara huruf-huruf selama transmisi. Namun, akan lebih baik jika codeword tidak bisa menjadi awalan dari kata lain. Kode ini disebut tidak </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direvisi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kode ASCII dengan panjang tetap tidak diperbaiki karena codeword selalu memiliki panjang yang sama. Tetapi kode panjang variabel juga bisa diperbaiki. Nomor telepon sering tidak diperbaiki. Sebelum nomor telepon darurat 112 diperkenalkan di Swedia, semua nomor yang dimulai dengan 112 harus diubah Dan di AS tidak ada nomor telepon tunggal yang dimulai dengan 911.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk meminimalkan ukuran pesan yang disandikan, lebih baik menggunakan kode yang tidak diperbaiki di mana karakter yang sering muncul memiliki kata sandi yang lebih pendek. </font><font style="vertical-align: inherit;">Kode optimal adalah kode yang menghasilkan hasil sesingkat mungkin - jumlah panjang kata-kata kode, dikalikan dengan frekuensi kemunculannya, akan menjadi jumlah minimum yang mungkin. </font><font style="vertical-align: inherit;">Ini disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode non-awalan dengan redundansi minimal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , atau </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode Huffman</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , untuk menghormati penemu algoritma yang efisien untuk menghasilkan kode tersebut.</font></font><br>
<br>
<a name="7"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma Huffman</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat mempelajari bahan-bahan untuk menulis disertasi doktoralnya mengenai teknik elektronik di MIT, David Huffman mengikuti kursus teori informasi yang diajarkan oleh Robert Fano. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menurut legenda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Fano mengizinkan murid-muridnya untuk memilih: menulis ujian akhir atau kursus. Huffman memilih yang terakhir, dan dia diberi topik mencari kode awalan dengan redundansi minimal. Diasumsikan bahwa dia tidak tahu bahwa Fano sendiri sedang mengerjakan tugas ini pada waktu itu ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritma Shannon-Fano</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah metode yang paling terkenal pada tahun-tahun itu </font><font style="vertical-align: inherit;">). Karya Huffman diterbitkan pada tahun 1952 dengan judul </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Method for Construction of Minimum-Redundancy Codes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada tahun 1952. Dan sejak itu algoritmanya telah banyak digunakan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf0/4fe/003/cf04fe00303a663594eea8e8db063002.jpg"></div><br>
<i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siaran pers</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> David Huffman, </font><font style="vertical-align: inherit;">UC Santa Cruz. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algoritma Huffman membuat kode yang tidak diperbaiki dengan redundansi minimal untuk rangkaian karakter dan frekuensi penggunaannya. </font><font style="vertical-align: inherit;">Algoritme berulang kali memilih dua karakter yang paling tidak mungkin ditemukan dalam sumber data - katakanlah, X dan Y - dan menggantinya dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">karakter komposit yang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berarti "X atau Y". </font><font style="vertical-align: inherit;">Frekuensi kemunculan simbol gabungan adalah jumlah dari frekuensi dua simbol sumber. </font><font style="vertical-align: inherit;">Codeword untuk X dan Y dapat berupa codeword apa saja yang ditugaskan ke karakter majemuk "X atau Y" diikuti oleh 0 atau 1 untuk membedakan antara karakter asli. </font><font style="vertical-align: inherit;">Ketika input data direduksi menjadi satu karakter, algoritma berhenti bekerja ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penjelasan video</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut adalah contoh algoritme yang bekerja pada rangkaian karakter kecil:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frekuensi</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEBUAH</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Iterasi pengolahan pertama:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e90/a8f/4e4/e90a8f4e47c49cd14ca3a55f884d55e3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dua simbol paling langka, C dan D, dihapus dari himpunan dan digantikan oleh simbol gabungan yang frekuensinya adalah jumlah dari frekuensi C dan D:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e9/b0b/aed/7e9b0baeda34fc4d368c933bed7e1d15.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang simbol paling langka adalah B dan simbol komposit dengan frekuensi 5. Mereka dihapus dari himpunan dan diganti dengan simbol komposit dengan frekuensi 9:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bca/94b/ad6/bca94bad698775402e8bab2c6a20f664.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akhirnya, A dan simbol gabungan dengan frekuensi 9 digabungkan menjadi simbol baru dengan frekuensi 15:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/260/aa3/800/260aa38005cf701421881214915d859a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seluruh set dikurangi menjadi satu karakter, pemrosesan selesai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algoritma menciptakan struktur yang disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pohon Huffman</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Karakter input adalah daun, dan semakin tinggi frekuensi karakter, semakin tinggi lokasinya. </font><font style="vertical-align: inherit;">Mulai dari akar pohon, Anda dapat membuat kata-kata kode untuk karakter dengan menambahkan 0 atau 1 ketika masing-masing bergerak ke kiri atau kanan. </font><font style="vertical-align: inherit;">Ternyata seperti ini:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata sandi</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEBUAH</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak ada codeword yang merupakan awalan untuk yang lain. Semakin sering simbol muncul, semakin pendek kata kodenya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tree juga dapat digunakan untuk decoding: kita mulai dari root dan ke kanan atau kiri untuk nilai dengan 0 atau 1 di depan karakter. Misalnya, baris 010100 diterjemahkan dalam ABBA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan bahwa panjang setiap codeword setara dengan kedalaman node tree yang sesuai. Seperti yang akan kita lihat di bagian selanjutnya, kita tidak perlu pohon asli untuk menetapkan codeword. Cukup mengetahui panjang kata-kata itu sendiri. Dengan demikian, hasil implementasi kami dari algoritma Huffman akan menjadi panjang kata-kata kode. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menyimpan set karakter dan secara efisien menemukan frekuensi terendah, kami akan menggunakan struktur data </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tumpukan biner</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Secara khusus, kami tertarik</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min-heap</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , karena nilai minimum harus di atas.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Swap the 32-bit values pointed to by a and b. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap32</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> *a, <span class="hljs-keyword">uint32_t</span> *b)</span>
</span>{
        <span class="hljs-keyword">uint32_t</span> tmp;<font></font>
<font></font>
        tmp = *a;<font></font>
        *a = *b;<font></font>
        *b = tmp;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Move element i in the n-element heap down to restore the minheap property. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">minheap_down</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> *heap, <span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">size_t</span> i)</span>
</span>{
        <span class="hljs-keyword">size_t</span> left, right, min;<font></font>
<font></font>
        assert(i &gt;= <span class="hljs-number">1</span> &amp;&amp; i &lt;= n &amp;&amp; <span class="hljs-string">"i must be inside the heap"</span>);<font></font>
<font></font>
        <span class="hljs-comment">/* While the ith element has at least one child. */</span>
        <span class="hljs-keyword">while</span> (i * <span class="hljs-number">2</span> &lt;= n) {<font></font>
                left = i * <span class="hljs-number">2</span>;<font></font>
                right = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<font></font>
<font></font>
                <span class="hljs-comment">/* Find the child with lowest value. */</span><font></font>
                min = left;<font></font>
                <span class="hljs-keyword">if</span> (right &lt;= n &amp;&amp; heap[right] &lt; heap[left]) {<font></font>
                        min = right;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Move i down if it is larger. */</span>
                <span class="hljs-keyword">if</span> (heap[min] &lt; heap[i]) {<font></font>
                        swap32(&amp;heap[min], &amp;heap[i]);<font></font>
                        i = min;<font></font>
                } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Establish minheap property for heap[1..n]. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">minheap_heapify</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> *heap, <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;<font></font>
<font></font>
        <span class="hljs-comment">/* Floyd's algorithm. */</span>
        <span class="hljs-keyword">for</span> (i = n / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i--) {<font></font>
                minheap_down(heap, n, i);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk melacak frekuensi </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">karakter, kami akan menggunakan banyak </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemen. </font><font style="vertical-align: inherit;">Juga, setiap kali simbol komposit dibuat, kami ingin "menautkan" kedua simbol sumber itu. </font><font style="vertical-align: inherit;">Oleh karena itu, setiap simbol akan memiliki "elemen komunikasi". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menyimpan </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heap- </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemen </font><font style="vertical-align: inherit;">dan </font><font style="vertical-align: inherit;">elemen komunikasi, kita akan menggunakan array </font></font><code>n * 2 + 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemen. </font><font style="vertical-align: inherit;">Ketika dua karakter pada heap digantikan oleh satu, kita akan menggunakan elemen kedua untuk menyimpan tautan ke karakter baru. </font><font style="vertical-align: inherit;">Pendekatan ini didasarkan pada implementasi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengelola Gigabita</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Witten, Moffat dan Bell.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada setiap node di heap, kita akan menggunakan 16 bit paling signifikan untuk menyimpan frekuensi simbol, dan 16 bit lebih rendah untuk menyimpan indeks elemen komunikasi simbol. Karena penggunaan bit tinggi, perbedaan frekuensi akan ditentukan oleh hasil perbandingan 32-bit antara dua elemen heap. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena representasi ini, kita perlu memastikan bahwa frekuensi karakter selalu cocok dalam 16 bit. Setelah menyelesaikan algoritma, simbol komposit akhir akan memiliki frekuensi semua simbol gabungan, yaitu, jumlah ini harus ditempatkan dalam 16 bit. Implementasi Deflate kami akan memverifikasi ini dengan secara simultan memproses hingga 64.535 karakter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Simbol dengan frekuensi nol akan menerima kata-kata kode dengan panjang nol dan tidak akan berpartisipasi dalam kompilasi pengkodean.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kata kode mencapai kedalaman maksimum yang ditentukan, kami akan “memperlancar” distribusi frekuensi dengan memberlakukan batas frekuensi dan mencoba lagi (ya, dengan bantuan </font></font><code>goto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Ada cara yang lebih canggih untuk melakukan pengkodean Huffman yang terbatas, tetapi yang ini sederhana dan efisien.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_HUFFMAN_SYMBOLS 288      <span class="hljs-comment">/* Deflate uses max 288 symbols. */</span></span><font></font>
<font></font>
<span class="hljs-comment">/* Construct a Huffman code for n symbols with the frequencies in freq, and
 * codeword length limited to max_len. The sum of the frequencies must be &lt;=
 * UINT16_MAX. max_len must be large enough that a code is always possible,
 * i.e. 2 ** max_len &gt;= n. Symbols with zero frequency are not part of the code
 * and get length zero. Outputs the codeword lengths in lengths[0..n-1]. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">compute_huffman_lengths</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> *freqs, <span class="hljs-keyword">size_t</span> n,
                                    <span class="hljs-keyword">uint8_t</span> max_len, <span class="hljs-keyword">uint8_t</span> *lengths)</span>
</span>{
        <span class="hljs-keyword">uint32_t</span> nodes[MAX_HUFFMAN_SYMBOLS * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>], p, q;
        <span class="hljs-keyword">uint16_t</span> freq;
        <span class="hljs-keyword">size_t</span> i, h, l;
        <span class="hljs-keyword">uint16_t</span> freq_cap = UINT16_MAX;<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span>
        <span class="hljs-keyword">uint32_t</span> freq_sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                freq_sum += freqs[i];<font></font>
        }<font></font>
        assert(freq_sum &lt;= UINT16_MAX &amp;&amp; <span class="hljs-string">"Frequency sum too large!"</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
        assert(n &lt;= MAX_HUFFMAN_SYMBOLS);<font></font>
        assert((<span class="hljs-number">1U</span> &lt;&lt; max_len) &gt;= n &amp;&amp; <span class="hljs-string">"max_len must be large enough"</span>);<font></font>
<font></font>
try_again:<font></font>
        <span class="hljs-comment">/* Initialize the heap. h is the heap size. */</span>
        h = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                freq = freqs[i];<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (freq == <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">/* Ignore zero-frequency symbols. */</span><font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (freq &gt; freq_cap) {<font></font>
                        freq = freq_cap; <span class="hljs-comment">/* Enforce the frequency cap. */</span><font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* High 16 bits: Symbol frequency.
                   Low 16 bits:  Symbol link element index. */</span><font></font>
                h++;<font></font>
                nodes[h] = ((<span class="hljs-keyword">uint32_t</span>)freq &lt;&lt; <span class="hljs-number">16</span>) | (<span class="hljs-keyword">uint32_t</span>)(n + h);<font></font>
        }<font></font>
        minheap_heapify(nodes, h);<font></font>
<font></font>
        <span class="hljs-comment">/* Special case for less than two non-zero symbols. */</span>
        <span class="hljs-keyword">if</span> (h &lt; <span class="hljs-number">2</span>) {
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                        lengths[i] = (freqs[i] == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Build the Huffman tree. */</span>
        <span class="hljs-keyword">while</span> (h &gt; <span class="hljs-number">1</span>) {
                <span class="hljs-comment">/* Remove the lowest frequency node p from the heap. */</span>
                p = nodes[<span class="hljs-number">1</span>];<font></font>
                nodes[<span class="hljs-number">1</span>] = nodes[h--];<font></font>
                minheap_down(nodes, h, <span class="hljs-number">1</span>);<font></font>
<font></font>
                <span class="hljs-comment">/* Get q, the next lowest frequency node. */</span>
                q = nodes[<span class="hljs-number">1</span>];<font></font>
<font></font>
                <span class="hljs-comment">/* Replace q with a new symbol with the combined frequencies of
                   p and q, and with the no longer used h+1'th node as the
                   link element. */</span>
                nodes[<span class="hljs-number">1</span>] = ((p &amp; <span class="hljs-number">0xffff0000</span>) + (q &amp; <span class="hljs-number">0xffff0000</span>))<font></font>
                           | (<span class="hljs-keyword">uint32_t</span>)(h + <span class="hljs-number">1</span>);<font></font>
<font></font>
                <span class="hljs-comment">/* Set the links of p and q to point to the link element of
                   the new node. */</span>
                nodes[p &amp; <span class="hljs-number">0xffff</span>] = nodes[q &amp; <span class="hljs-number">0xffff</span>] = (<span class="hljs-keyword">uint32_t</span>)(h + <span class="hljs-number">1</span>);<font></font>
<font></font>
                <span class="hljs-comment">/* Move the new symbol down to restore heap property. */</span>
                minheap_down(nodes, h, <span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Compute the codeword length for each symbol. */</span>
        h = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {
                <span class="hljs-keyword">if</span> (freqs[i] == <span class="hljs-number">0</span>) {<font></font>
                        lengths[i] = <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
                h++;<font></font>
<font></font>
                <span class="hljs-comment">/* Link element for the i'th symbol. */</span><font></font>
                p = nodes[n + h];<font></font>
<font></font>
                <span class="hljs-comment">/* Follow the links until we hit the root (link index 2). */</span>
                l = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">while</span> (p != <span class="hljs-number">2</span>) {<font></font>
                        l++;<font></font>
                        p = nodes[p];<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (l &gt; max_len) {
                        <span class="hljs-comment">/* Lower freq_cap to flatten the distribution. */</span>
                        assert(freq_cap != <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-string">"Cannot lower freq_cap!"</span>);<font></font>
                        freq_cap /= <span class="hljs-number">2</span>;
                        <span class="hljs-keyword">goto</span> try_again;<font></font>
                }<font></font>
<font></font>
                assert(l &lt;= UINT8_MAX);<font></font>
                lengths[i] = (<span class="hljs-keyword">uint8_t</span>)l;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alternatif elegan untuk opsi tumpukan biner adalah menyimpan karakter dalam dua antrian. </font><font style="vertical-align: inherit;">Yang pertama berisi karakter sumber, diurutkan berdasarkan frekuensi. </font><font style="vertical-align: inherit;">Ketika simbol gabungan dibuat, ditambahkan kedua. </font><font style="vertical-align: inherit;">Dengan demikian, simbol dengan frekuensi terendah akan selalu berada di posisi pertama dari salah satu antrian. </font><font style="vertical-align: inherit;">Pendekatan ini dijelaskan oleh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jan van Leeuwen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the Construction of Huffman Trees</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (1976). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengodean Huffman optimal untuk kode non-awalan, tetapi dalam kasus lain ada metode yang lebih efisien: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengkodean aritmatika</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistem bilangan asimetris</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="8"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode kanonik Huffman</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada contoh di atas, kami membangun pohon Huffman:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/260/aa3/800/260aa38005cf701421881214915d859a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita pergi dari root dan menggunakan 0 untuk cabang kiri dan 1 untuk kanan, maka kita mendapatkan kode berikut:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata sandi</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEBUAH</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keputusan untuk menggunakan 0 untuk cabang kiri dan 1 untuk yang benar tampaknya sewenang-wenang. </font><font style="vertical-align: inherit;">Jika kita melakukan yang sebaliknya, kita mendapatkan:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata sandi</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEBUAH</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">01</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">001</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita dapat secara acak menandai dua cabang yang berasal dari simpul dengan nol dan satu (yang utama adalah bahwa labelnya berbeda), dan masih mendapatkan kode yang setara:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29b/acb/499/29bacb4999e9a3f530f22634846a97b7.png"></div><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata sandi</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEBUAH</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebelas</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">101</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meskipun algoritma Huffman memberikan panjang kode sandi yang diperlukan untuk kode yang tidak diperbaiki dengan redundansi minimal, ada banyak cara untuk menetapkan masing-masing kode kata. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengingat panjang codeword yang dihitung oleh algoritma Huffman, kode Huffman kanonik memberikan codeword ke karakter dengan cara tertentu. Ini berguna karena memungkinkan Anda untuk menyimpan dan mengirimkan panjang codeword dengan data terkompresi: decoder akan dapat memulihkan codeword berdasarkan panjangnya. Tentu saja, Anda dapat menyimpan dan mengirimkan frekuensi simbol dan menjalankan algoritma Huffman di dekoder, tetapi ini akan membutuhkan lebih banyak pekerjaan dan lebih banyak penyimpanan dari dekoder. Properti lain yang sangat penting adalah bahwa struktur kode kanonik menggunakan decoding yang efisien.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Idenya adalah untuk menetapkan kata kode ke karakter secara berurutan, di bawah satu per satu. Kata kode pertama adalah 0. Berikutnya akan menjadi kata dengan panjang kata sebelumnya + 1. Kata pertama dengan panjang N terdiri dari kata terakhir panjang N-1, menambahkan satu (untuk mendapatkan kata kode baru) dan menggeser satu langkah ke kiri (untuk menambah panjang). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam terminologi pohon Hoffman, kata-kata kode secara berurutan ditugaskan untuk meninggalkan dalam urutan dari kiri ke kanan, satu tingkat pada satu waktu, bergeser ke kiri ketika pindah ke tingkat berikutnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh ABCD kami, algoritma Huffman menetapkan kata-kata kode dengan panjang 1, 2, 3, dan 3. Kata pertama adalah 0. Ini juga kata terakhir dari panjang 1. Untuk panjang 2, kita mengambil 0 dan menambahkan 1 untuk mendapatkan kode berikutnya, yang akan menjadi awalan dari kode dua-bit , geser ke kiri dan dapatkan 10. Ini sekarang kata terakhir dari panjang 2. Untuk mendapatkan panjang 3, kita tambahkan 1 dan bergeser: 110. Untuk mendapatkan kata panjang berikutnya 3 kita tambahkan 1: 111.</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kata sandi</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEBUAH</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implementasi generator kode kanonik ditunjukkan di bawah ini. </font><font style="vertical-align: inherit;">Perhatikan bahwa algoritma Deflate mengharapkan codeword dihasilkan berdasarkan prinsip LSB-first (pertama, bit paling tidak signifikan). </font><font style="vertical-align: inherit;">Artinya, bit pertama dari codeword harus disimpan dalam bit yang paling tidak signifikan. </font><font style="vertical-align: inherit;">Ini berarti bahwa kita perlu mengubah urutan bit, misalnya, menggunakan tabel pencarian.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_HUFFMAN_BITS 15          <span class="hljs-comment">/* Deflate uses max 15-bit codewords. */</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">compute_canonical_code</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> *codewords, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *lengths,
                                   <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;
        <span class="hljs-keyword">uint16_t</span> count[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>] = {<span class="hljs-number">0</span>};
        <span class="hljs-keyword">uint16_t</span> code[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">int</span> l;<font></font>
<font></font>
        <span class="hljs-comment">/* Count the number of codewords of each length. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                count[lengths[i]]++;<font></font>
        }<font></font>
        count[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* Ignore zero-length codes. */</span><font></font>
<font></font>
        <span class="hljs-comment">/* Compute the first codeword for each length. */</span>
        code[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (l = <span class="hljs-number">1</span>; l &lt;= MAX_HUFFMAN_BITS; l++) {<font></font>
                code[l] = (<span class="hljs-keyword">uint16_t</span>)((code[l - <span class="hljs-number">1</span>] + count[l - <span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Assign a codeword for each symbol. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                l = lengths[i];<font></font>
                <span class="hljs-keyword">if</span> (l == <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                codewords[i] = reverse16(code[l]++, l); <span class="hljs-comment">/* Make it LSB-first. */</span><font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Reverse the n least significant bits of x.
   The (16 - n) most significant bits of the result will be zero. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint16_t</span> <span class="hljs-title">reverse16</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> x, <span class="hljs-keyword">int</span> n)</span>
</span>{
        <span class="hljs-keyword">uint16_t</span> lo, hi;
        <span class="hljs-keyword">uint16_t</span> reversed;<font></font>
<font></font>
        assert(n &gt; <span class="hljs-number">0</span>);<font></font>
        assert(n &lt;= <span class="hljs-number">16</span>);<font></font>
<font></font>
        lo = x &amp; <span class="hljs-number">0xff</span>;<font></font>
        hi = x &gt;&gt; <span class="hljs-number">8</span>;<font></font>
<font></font>
        reversed = (<span class="hljs-keyword">uint16_t</span>)((reverse8_tbl[lo] &lt;&lt; <span class="hljs-number">8</span>) | reverse8_tbl[hi]);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> reversed &gt;&gt; (<span class="hljs-number">16</span> - n);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kumpulkan semuanya dan tulis kode inisialisasi encoder:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">huffman_encoder_t</span> <span class="hljs-title">huffman_encoder_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">huffman_encoder_t</span> {</span>
        <span class="hljs-keyword">uint16_t</span> codewords[MAX_HUFFMAN_SYMBOLS]; <span class="hljs-comment">/* LSB-first codewords. */</span>
        <span class="hljs-keyword">uint8_t</span> lengths[MAX_HUFFMAN_SYMBOLS];    <span class="hljs-comment">/* Codeword lengths. */</span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Initialize a Huffman encoder based on the n symbol frequencies. */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">huffman_encoder_init</span><span class="hljs-params">(<span class="hljs-keyword">huffman_encoder_t</span> *e, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> *freqs, <span class="hljs-keyword">size_t</span> n,
                          <span class="hljs-keyword">uint8_t</span> max_codeword_len)</span>
</span>{<font></font>
        assert(n &lt;= MAX_HUFFMAN_SYMBOLS);<font></font>
        assert(max_codeword_len &lt;= MAX_HUFFMAN_BITS);<font></font>
<font></font>
        compute_huffman_lengths(freqs, n, max_codeword_len, e-&gt;lengths);<font></font>
        compute_canonical_code(e-&gt;codewords, e-&gt;lengths, n);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami juga membuat fungsi untuk mengonfigurasi pembuat enkode menggunakan panjang kode yang sudah dihitung:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Initialize a Huffman encoder based on the n codeword lengths. */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">huffman_encoder_init2</span><span class="hljs-params">(<span class="hljs-keyword">huffman_encoder_t</span> *e, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *lengths,
                           <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                e-&gt;lengths[i] = lengths[i];<font></font>
        }<font></font>
        compute_canonical_code(e-&gt;codewords, e-&gt;lengths, n);<font></font>
}<font></font>
</code></pre><br>
<a name="9"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decoding Huffman yang Efisien</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cara termudah untuk memecahkan kode Huffman adalah dengan melintasi pohon mulai dari root, membaca sedikit input sekaligus dan memutuskan cabang mana yang akan diambil selanjutnya, kiri atau kanan. </font><font style="vertical-align: inherit;">Ketika simpul daun tercapai, itu adalah karakter yang diterjemahkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode ini sering diajarkan di universitas dan buku. </font><font style="vertical-align: inherit;">Ini sederhana dan elegan, tetapi memproses sedikit demi sedikit terlalu lambat. </font><font style="vertical-align: inherit;">Jauh lebih cepat untuk memecahkan kode menggunakan tabel pencarian. </font><font style="vertical-align: inherit;">Untuk contoh di atas, di mana panjang codeword maksimum adalah tiga bit, Anda dapat menggunakan tabel berikut:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bits</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panjang Codeword</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEBUAH</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 01</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEBUAH</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEBUAH</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEBUAH</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meskipun hanya ada empat karakter, kita membutuhkan tabel dengan delapan entri untuk mencakup semua kemungkinan kombinasi tiga-bit. </font><font style="vertical-align: inherit;">Simbol dengan codeword yang lebih pendek dari tiga bit memiliki beberapa entri dalam tabel. </font><font style="vertical-align: inherit;">Misalnya, kata 10 "ditambah" dengan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 dan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 untuk mencakup semua kombinasi tiga bit dimulai dengan 10. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memecahkan kode dengan cara ini, Anda perlu mengindeks dalam tabel dengan tiga bit input berikut dan segera menemukan karakter yang sesuai dan panjang kata kodenya. </font><font style="vertical-align: inherit;">Panjangnya penting, karena meskipun melihat pada tiga bit berikutnya, kita perlu mendapatkan jumlah bit input yang sama dengan panjang codeword.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode pencarian berdasarkan tabel bekerja sangat cepat, tetapi memiliki kelemahan: ukuran tabel berlipat ganda dengan setiap bit tambahan dalam panjang kata sandi. Artinya, konstruksi tabel melambat secara eksponensial, dan jika tidak lagi sesuai dengan cache prosesor, maka metode mulai bekerja lambat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena itu, tabel pencarian biasanya hanya digunakan untuk kata-kata kode yang tidak lebih besar dari panjang tertentu. Dan untuk kata-kata yang lebih panjang, ambil pendekatan yang berbeda. Sama seperti pengkodean Huffman yang memberikan codeword yang lebih pendek ke karakter yang lebih sering, penggunaan tabel pencarian untuk codeword pendek dalam banyak kasus merupakan optimasi yang sangat baik. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam zlib</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beberapa level tabel pencarian digunakan. </font><font style="vertical-align: inherit;">Jika kata sandi terlalu panjang untuk tabel pertama, maka pencarian akan pergi ke tabel sekunder untuk mengindeks bit yang tersisa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi ada metode lain yang sangat elegan, berdasarkan pada sifat-sifat kode Huffman kanonik. </font><font style="vertical-align: inherit;">Hal ini dijelaskan dalam </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentang Implementasi Kode Awalan Redundansi Minimum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Moffat dan Turpin, 1997), dan juga dijelaskan dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Lost Huffman Paper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> karya Charles Bloom. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ambil kata-kata kode dari versi kanonik: 0, 10, 110, 111. Kami akan melacak kata-kata kode pertama dari setiap panjang, serta jumlah setiap kata kode dalam urutan umum - "indeks simbol".</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panjang Codeword</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codeword pertama</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indeks karakter pertama</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 (A)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 (B)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 (C)</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena codeword ditugaskan secara berurutan, jika kita mengetahui jumlah bit, kita dapat menemukan dalam tabel di atas karakter yang diwakili bit-bit ini. </font><font style="vertical-align: inherit;">Sebagai contoh, untuk three-bit 111 kita melihat bahwa ini adalah offset oleh salah satu dari codeword pertama panjang ini (110). </font><font style="vertical-align: inherit;">Indeks karakter pertama dari panjang ini adalah 3, dan offset satu memberi kita indeks 4. Tabel lain membandingkan indeks karakter dengan karakter:</font></font><br>
<br>
<pre><code class="cpp hljs">sym_idx = d-&gt;first_symbol[len] + (bits - d-&gt;first_code[len]);<font></font>
sym = d-&gt;syms[sym_idx];<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sedikit optimisasi: alih-alih secara terpisah menyimpan indeks karakter pertama dan codeword pertama, kita dapat menyimpan indeks pertama dikurangi codeword pertama dalam tabel:</font></font><br>
<br>
<pre><code class="cpp hljs">sym_idx = d-&gt;offset_first_sym_idx[len] + bits;<font></font>
sym = d-&gt;syms[sym_idx];<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memahami berapa banyak bit yang perlu diperkirakan, kami kembali menggunakan properti urutan kode. </font><font style="vertical-align: inherit;">Dalam contoh kami, semua codeword satu-bit yang valid benar-benar kurang dari 1, dua-bit - benar-benar kurang dari 11, tiga-bit - kurang dari 1000 (pada kenyataannya, berlaku untuk semua nilai tiga-bit). </font><font style="vertical-align: inherit;">Dengan kata lain, codeword N-bit yang valid harus benar-benar kurang dari codeword N-bit pertama ditambah jumlah codeword N-bit. </font><font style="vertical-align: inherit;">Selain itu, kita dapat menggeser batas-batas ini ke kiri sehingga lebar mereka tiga bit. </font><font style="vertical-align: inherit;">Sebut saja </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bit restriktif</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk masing-masing panjang codeword:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panjang Codeword</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Batasi bit</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></td>
</tr>
</tbody></table></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembatas untuk panjang 3 telah meluap menjadi 4 bit, tetapi ini hanya berarti bahwa setiap kata tiga bit akan dilakukan. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita dapat mencari di antara data input tiga bit dan membandingkannya dengan bit terbatas untuk memahami berapa lama kata kode kita. </font><font style="vertical-align: inherit;">Setelah selesai, kami menggeser bit input, hanya untuk menghitung angka yang benar, dan kemudian menemukan indeks karakter:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (len = <span class="hljs-number">1</span>; len &lt;= <span class="hljs-number">3</span>; len++) {
        <span class="hljs-keyword">if</span> (bits &lt; d-&gt;sentinel_bits[len]) {<font></font>
                bits &gt;&gt;= <span class="hljs-number">3</span> - len;  <span class="hljs-comment">/* Get the len most significant bits. */</span><font></font>
                sym_idx = d-&gt;offset_first_sym_idx[len] + bits;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompleksitas waktu dari proses adalah linear sehubungan dengan jumlah bit dalam kata-kata kode, tetapi tempat dihabiskan secara efisien, hanya memuat dan perbandingan diperlukan pada setiap langkah, dan karena kata-kata kode yang lebih pendek lebih umum, metode ini memungkinkan pengoptimalan kompresi dalam banyak situasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode dekoder lengkap:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HUFFMAN_LOOKUP_TABLE_BITS 8  <span class="hljs-comment">/* Seems a good trade-off. */</span></span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">huffman_decoder_t</span> <span class="hljs-title">huffman_decoder_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">huffman_decoder_t</span> {</span>
        <span class="hljs-comment">/* Lookup table for fast decoding of short codewords. */</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
                <span class="hljs-keyword">uint16_t</span> sym : <span class="hljs-number">9</span>;  <span class="hljs-comment">/* Wide enough to fit the max symbol nbr. */</span>
                <span class="hljs-keyword">uint16_t</span> len : <span class="hljs-number">7</span>;  <span class="hljs-comment">/* 0 means no symbol. */</span>
        } table[<span class="hljs-number">1U</span> &lt;&lt; HUFFMAN_LOOKUP_TABLE_BITS];<font></font>
<font></font>
        <span class="hljs-comment">/* "Sentinel bits" value for each codeword length. */</span>
        <span class="hljs-keyword">uint16_t</span> sentinel_bits[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];<font></font>
<font></font>
        <span class="hljs-comment">/* First symbol index minus first codeword mod 2**16 for each length. */</span>
        <span class="hljs-keyword">uint16_t</span> offset_first_sym_idx[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];<font></font>
<font></font>
        <span class="hljs-comment">/* Map from symbol index to symbol. */</span>
        <span class="hljs-keyword">uint16_t</span> syms[MAX_HUFFMAN_SYMBOLS];
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span>
        <span class="hljs-keyword">size_t</span> num_syms;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Get the n least significant bits of x. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">lsb</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> x, <span class="hljs-keyword">int</span> n)</span>
</span>{<font></font>
        assert(n &gt;= <span class="hljs-number">0</span> &amp;&amp; n &lt;= <span class="hljs-number">63</span>);
        <span class="hljs-keyword">return</span> x &amp; (((<span class="hljs-keyword">uint64_t</span>)<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Use the decoder d to decode a symbol from the LSB-first zero-padded bits.
 * Returns the decoded symbol number or -1 if no symbol could be decoded.
 * *num_used_bits will be set to the number of bits used to decode the symbol,
 * or zero if no symbol could be decoded. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">huffman_decode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_decoder_t</span> *d, <span class="hljs-keyword">uint16_t</span> bits,
                                 <span class="hljs-keyword">size_t</span> *num_used_bits)</span>
</span>{
        <span class="hljs-keyword">uint64_t</span> lookup_bits;
        <span class="hljs-keyword">size_t</span> l;
        <span class="hljs-keyword">size_t</span> sym_idx;<font></font>
<font></font>
        <span class="hljs-comment">/* First try the lookup table. */</span><font></font>
        lookup_bits = lsb(bits, HUFFMAN_LOOKUP_TABLE_BITS);<font></font>
        assert(lookup_bits &lt; <span class="hljs-keyword">sizeof</span>(d-&gt;table) / <span class="hljs-keyword">sizeof</span>(d-&gt;table[<span class="hljs-number">0</span>]));
        <span class="hljs-keyword">if</span> (d-&gt;table[lookup_bits].len != <span class="hljs-number">0</span>) {<font></font>
                assert(d-&gt;table[lookup_bits].len &lt;= HUFFMAN_LOOKUP_TABLE_BITS);<font></font>
                assert(d-&gt;table[lookup_bits].sym &lt; d-&gt;num_syms);<font></font>
<font></font>
                *num_used_bits = d-&gt;table[lookup_bits].len;<font></font>
                <span class="hljs-keyword">return</span> d-&gt;table[lookup_bits].sym;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Then do canonical decoding with the bits in MSB-first order. */</span><font></font>
        bits = reverse16(bits, MAX_HUFFMAN_BITS);<font></font>
        <span class="hljs-keyword">for</span> (l = HUFFMAN_LOOKUP_TABLE_BITS + <span class="hljs-number">1</span>; l &lt;= MAX_HUFFMAN_BITS; l++) {
                <span class="hljs-keyword">if</span> (bits &lt; d-&gt;sentinel_bits[l]) {<font></font>
                        bits &gt;&gt;= MAX_HUFFMAN_BITS - l;<font></font>
<font></font>
                        sym_idx = (<span class="hljs-keyword">uint16_t</span>)(d-&gt;offset_first_sym_idx[l] + bits);<font></font>
                        assert(sym_idx &lt; d-&gt;num_syms);<font></font>
<font></font>
                        *num_used_bits = l;<font></font>
                        <span class="hljs-keyword">return</span> d-&gt;syms[sym_idx];<font></font>
                }<font></font>
        }<font></font>
<font></font>
        *num_used_bits = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengkonfigurasi decoder, kita akan melakukan pre-compute kode kanonik, seperti untuk </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">huffman_encoder_init</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan mengisi tabel yang berbeda:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Initialize huffman decoder d for a code defined by the n codeword lengths.
   Returns false if the codeword lengths do not correspond to a valid prefix
   code. */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">huffman_decoder_init</span><span class="hljs-params">(<span class="hljs-keyword">huffman_decoder_t</span> *d, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *lengths,
                          <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;
        <span class="hljs-keyword">uint16_t</span> count[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>] = {<span class="hljs-number">0</span>};
        <span class="hljs-keyword">uint16_t</span> code[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">uint32_t</span> s;
        <span class="hljs-keyword">uint16_t</span> sym_idx[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">int</span> l;<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span><font></font>
        assert(n &lt;= MAX_HUFFMAN_SYMBOLS);<font></font>
        d-&gt;num_syms = n;<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
        <span class="hljs-comment">/* Zero-initialize the lookup table. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(d-&gt;table) / <span class="hljs-keyword">sizeof</span>(d-&gt;table[<span class="hljs-number">0</span>]); i++) {<font></font>
                d-&gt;table[i].len = <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Count the number of codewords of each length. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                assert(lengths[i] &lt;= MAX_HUFFMAN_BITS);<font></font>
                count[lengths[i]]++;<font></font>
        }<font></font>
        count[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">/* Ignore zero-length codewords. */</span><font></font>
<font></font>
        <span class="hljs-comment">/* Compute sentinel_bits and offset_first_sym_idx for each length. */</span>
        code[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<font></font>
        sym_idx[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (l = <span class="hljs-number">1</span>; l &lt;= MAX_HUFFMAN_BITS; l++) {
                <span class="hljs-comment">/* First canonical codeword of this length. */</span>
                code[l] = (<span class="hljs-keyword">uint16_t</span>)((code[l - <span class="hljs-number">1</span>] + count[l - <span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">1</span>);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (count[l] != <span class="hljs-number">0</span> &amp;&amp; code[l] + count[l] - <span class="hljs-number">1</span> &gt; (<span class="hljs-number">1U</span> &lt;&lt; l) - <span class="hljs-number">1</span>) {
                        <span class="hljs-comment">/* The last codeword is longer than l bits. */</span>
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
<font></font>
                s = (<span class="hljs-keyword">uint32_t</span>)((code[l] + count[l]) &lt;&lt; (MAX_HUFFMAN_BITS - l));<font></font>
                d-&gt;sentinel_bits[l] = (<span class="hljs-keyword">uint16_t</span>)s;<font></font>
                assert(d-&gt;sentinel_bits[l] == s &amp;&amp; <span class="hljs-string">"No overflow."</span>);<font></font>
<font></font>
                sym_idx[l] = sym_idx[l - <span class="hljs-number">1</span>] + count[l - <span class="hljs-number">1</span>];<font></font>
                d-&gt;offset_first_sym_idx[l] = sym_idx[l] - code[l];<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Build mapping from index to symbol and populate the lookup table. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                l = lengths[i];<font></font>
                <span class="hljs-keyword">if</span> (l == <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                d-&gt;syms[sym_idx[l]] = (<span class="hljs-keyword">uint16_t</span>)i;<font></font>
                sym_idx[l]++;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (l &lt;= HUFFMAN_LOOKUP_TABLE_BITS) {<font></font>
                        table_insert(d, i, l, code[l]);<font></font>
                        code[l]++;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">table_insert</span><span class="hljs-params">(<span class="hljs-keyword">huffman_decoder_t</span> *d, <span class="hljs-keyword">size_t</span> sym, <span class="hljs-keyword">int</span> len,
                         <span class="hljs-keyword">uint16_t</span> codeword)</span>
</span>{
        <span class="hljs-keyword">int</span> pad_len;
        <span class="hljs-keyword">uint16_t</span> padding, index;<font></font>
<font></font>
        assert(len &lt;= HUFFMAN_LOOKUP_TABLE_BITS);<font></font>
<font></font>
        codeword = reverse16(codeword, len); <span class="hljs-comment">/* Make it LSB-first. */</span><font></font>
        pad_len = HUFFMAN_LOOKUP_TABLE_BITS - len;<font></font>
<font></font>
        <span class="hljs-comment">/* Pad the pad_len upper bits with all bit combinations. */</span>
        <span class="hljs-keyword">for</span> (padding = <span class="hljs-number">0</span>; padding &lt; (<span class="hljs-number">1U</span> &lt;&lt; pad_len); padding++) {<font></font>
                index = (<span class="hljs-keyword">uint16_t</span>)(codeword | (padding &lt;&lt; len));<font></font>
                d-&gt;table[index].sym = (<span class="hljs-keyword">uint16_t</span>)sym;<font></font>
                d-&gt;table[index].len = (<span class="hljs-keyword">uint16_t</span>)len;<font></font>
<font></font>
                assert(d-&gt;table[index].sym == sym &amp;&amp; <span class="hljs-string">"Fits in bitfield."</span>);<font></font>
                assert(d-&gt;table[index].len == len &amp;&amp; <span class="hljs-string">"Fits in bitfield."</span>);<font></font>
        }<font></font>
}<font></font>
</code></pre><br>
<a name="10"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menurunkan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algoritma Deflate, diperkenalkan pada PKZip 2.04c pada tahun 1993, adalah metode kompresi standar dalam file Zip modern. </font><font style="vertical-align: inherit;">Ini juga digunakan dalam gzip, PNG dan banyak format lainnya. </font><font style="vertical-align: inherit;">Ini menggunakan kombinasi kompresi LZ77 dan pengkodean Huffman, yang akan kita bahas dan terapkan di bagian ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum Deflate, PKZip menggunakan metode kompresi Shrink, Reduce, dan Implode. </font><font style="vertical-align: inherit;">Hari ini mereka jarang, meskipun setelah Deflate masih digunakan untuk beberapa waktu, karena mereka mengkonsumsi lebih sedikit memori. </font><font style="vertical-align: inherit;">Tapi kami tidak akan mempertimbangkannya.</font></font><br>
<br>
<a name="11"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit stream</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deflate menyimpan Huffman codewords dalam bitstream sesuai dengan prinsip LSB-first. Ini berarti bahwa bit pertama dari aliran disimpan dalam bit paling tidak signifikan dari byte pertama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan bitstream (baca dari kiri ke kanan) 1-0-0-1-1. Ketika disimpan sesuai dengan prinsip LSB-first, nilai byte menjadi 0b00011001 (biner) atau 0x19 (heksadesimal). Kelihatannya aliran diwakili secara terbalik (dalam arti tertentu), tetapi keuntungannya adalah lebih mudah bagi kita untuk mendapatkan bit N pertama dari kata komputer: kita cukup menyembunyikan bit N paling tidak signifikan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prosedur ini diambil dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bitstream.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Input bitstream. */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">istream_t</span> <span class="hljs-title">istream_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">istream_t</span> {</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src;  <span class="hljs-comment">/* Source bytes. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *end;  <span class="hljs-comment">/* Past-the-end byte of src. */</span>
        <span class="hljs-keyword">size_t</span> bitpos;       <span class="hljs-comment">/* Position of the next bit to read. */</span>
        <span class="hljs-keyword">size_t</span> bitpos_end;   <span class="hljs-comment">/* Position of past-the-end bit. */</span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Initialize an input stream to present the n bytes from src as an LSB-first
 * bitstream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">istream_init</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> n)</span>
</span>{<font></font>
        is-&gt;src = src;<font></font>
        is-&gt;end = src + n;<font></font>
        is-&gt;bitpos = <span class="hljs-number">0</span>;<font></font>
        is-&gt;bitpos_end = n * <span class="hljs-number">8</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Decoder Huffman kami perlu melihat bit-bit berikut dalam stream (bit-bit yang cukup untuk kata kode terpanjang), dan kemudian melanjutkan stream dengan jumlah bit yang digunakan oleh simbol yang diterjemahkan:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ISTREAM_MIN_BITS (64 - 7)</span><font></font>
<font></font>
<span class="hljs-comment">/* Get the next bits from the input stream. The number of bits returned is
 * between ISTREAM_MIN_BITS and 64, depending on the position in the stream, or
 * fewer if the end of stream is reached. The upper bits are zero-padded. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">istream_bits</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">istream_t</span> *is)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *next;
        <span class="hljs-keyword">uint64_t</span> bits;
        <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
        next = is-&gt;src + (is-&gt;bitpos / <span class="hljs-number">8</span>);<font></font>
<font></font>
        assert(next &lt;= is-&gt;end &amp;&amp; <span class="hljs-string">"Cannot read past end of stream."</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (is-&gt;end - next &gt;= <span class="hljs-number">8</span>) {
                <span class="hljs-comment">/* Common case: read 8 bytes in one go. */</span><font></font>
                bits = read64le(next);<font></font>
        } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">/* Read the available bytes and zero-pad. */</span>
                bits = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; is-&gt;end - next; i++) {<font></font>
                        bits |= (<span class="hljs-keyword">uint64_t</span>)next[i] &lt;&lt; (i * <span class="hljs-number">8</span>);<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> bits &gt;&gt; (is-&gt;bitpos % <span class="hljs-number">8</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Advance n bits in the bitstream if possible. Returns false if that many bits
 * are not available in the stream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">istream_advance</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">size_t</span> n)</span> </span>{
        <span class="hljs-keyword">if</span> (is-&gt;bitpos + n &gt; is-&gt;bitpos_end) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        is-&gt;bitpos += n;<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Intinya adalah bahwa pada mesin 64-bit </font></font><code>istream_bits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda biasanya dapat mengeksekusi sebagai instruksi boot tunggal dan beberapa aritmatika, mengingat bahwa elemen-elemen struktur </font></font><code>istream_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada di register. </font><font style="vertical-align: inherit;">read64le diimplementasikan dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bits.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (kompiler modern mengubahnya menjadi unduhan 64-bit tunggal menggunakan prinsip little-endian):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Read a 64-bit value from p in little-endian byte order. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">read64le</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p)</span>
</span>{
        <span class="hljs-comment">/* The one true way, see
         * https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html */</span>
        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">0</span>)  |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>)  |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">16</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">24</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-number">32</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">5</span>] &lt;&lt; <span class="hljs-number">40</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">6</span>] &lt;&lt; <span class="hljs-number">48</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">7</span>] &lt;&lt; <span class="hljs-number">56</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami juga membutuhkan fungsi untuk melanjutkan bitstream ke perbatasan byte berikutnya:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Round x up to the next multiple of m, which must be a power of 2. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">round_up</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> x, <span class="hljs-keyword">size_t</span> m)</span>
</span>{<font></font>
        assert((m &amp; (m - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-string">"m must be a power of two"</span>);
        <span class="hljs-keyword">return</span> (x + m - <span class="hljs-number">1</span>) &amp; (<span class="hljs-keyword">size_t</span>)(-m); <span class="hljs-comment">/* Hacker's Delight (2nd), 3-1. */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Align the input stream to the next 8-bit boundary and return a pointer to
 * that byte, which may be the past-the-end-of-stream byte. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-title">istream_byte_align</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *byte;<font></font>
<font></font>
        assert(is-&gt;bitpos &lt;= is-&gt;bitpos_end &amp;&amp; <span class="hljs-string">"Not past end of stream."</span>);<font></font>
<font></font>
        is-&gt;bitpos = round_up(is-&gt;bitpos, <span class="hljs-number">8</span>);<font></font>
        byte = is-&gt;src + is-&gt;bitpos / <span class="hljs-number">8</span>;<font></font>
        assert(byte &lt;= is-&gt;end);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> byte;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk bitstream keluar, kami menulis bit menggunakan proses baca-modifikasi-tulis. </font><font style="vertical-align: inherit;">Dalam kasus cepat, Anda dapat menulis sedikit menggunakan 64-bit read, semacam operasi bit dan 64-bit write.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Output bitstream. */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ostream_t</span> <span class="hljs-title">ostream_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ostream_t</span> {</span>
        <span class="hljs-keyword">uint8_t</span> *dst;
        <span class="hljs-keyword">uint8_t</span> *end;
        <span class="hljs-keyword">size_t</span> bitpos;
        <span class="hljs-keyword">size_t</span> bitpos_end;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Initialize an output stream to write LSB-first bits into dst[0..n-1]. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ostream_init</span><span class="hljs-params">(<span class="hljs-keyword">ostream_t</span> *os, <span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> n)</span>
</span>{<font></font>
        os-&gt;dst = dst;<font></font>
        os-&gt;end = dst + n;<font></font>
        os-&gt;bitpos = <span class="hljs-number">0</span>;<font></font>
        os-&gt;bitpos_end = n * <span class="hljs-number">8</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Get the current bit position in the stream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">ostream_bit_pos</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">ostream_t</span> *os)</span>
</span>{
        <span class="hljs-keyword">return</span> os-&gt;bitpos;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Return the number of bytes written to the output buffer. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">ostream_bytes_written</span><span class="hljs-params">(<span class="hljs-keyword">ostream_t</span> *os)</span>
</span>{
        <span class="hljs-keyword">return</span> round_up(os-&gt;bitpos, <span class="hljs-number">8</span>) / <span class="hljs-number">8</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Write n bits to the output stream. Returns false if there is not enough room
 * at the destination. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">ostream_write</span><span class="hljs-params">(<span class="hljs-keyword">ostream_t</span> *os, <span class="hljs-keyword">uint64_t</span> bits, <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint64_t</span> x;
        <span class="hljs-keyword">int</span> shift, i;<font></font>
<font></font>
        assert(n &lt;= <span class="hljs-number">57</span>);<font></font>
        assert(bits &lt;= ((<span class="hljs-keyword">uint64_t</span>)<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-string">"Must fit in n bits."</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (os-&gt;bitpos_end - os-&gt;bitpos &lt; n) {
                <span class="hljs-comment">/* Not enough room. */</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        p = &amp;os-&gt;dst[os-&gt;bitpos / <span class="hljs-number">8</span>];<font></font>
        shift = os-&gt;bitpos % <span class="hljs-number">8</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (os-&gt;end - p &gt;= <span class="hljs-number">8</span>) {
                <span class="hljs-comment">/* Common case: read and write 8 bytes in one go. */</span><font></font>
                x = read64le(p);<font></font>
                x = lsb(x, shift);<font></font>
                x |= bits &lt;&lt; shift;<font></font>
                write64le(p, x);<font></font>
        } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">/* Slow case: read/write as many bytes as are available. */</span>
                x = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; os-&gt;end - p; i++) {<font></font>
                        x |= (<span class="hljs-keyword">uint64_t</span>)p[i] &lt;&lt; (i * <span class="hljs-number">8</span>);<font></font>
                }<font></font>
                x = lsb(x, shift);<font></font>
                x |= bits &lt;&lt; shift;<font></font>
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; os-&gt;end - p; i++) {<font></font>
                        p[i] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; (i * <span class="hljs-number">8</span>));<font></font>
                }<font></font>
        }<font></font>
<font></font>
        os-&gt;bitpos += n;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Write a 64-bit value x to dst in little-endian byte order. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write64le</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">uint64_t</span> x)</span>
</span>{<font></font>
        dst[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">0</span>);<font></font>
        dst[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">8</span>);<font></font>
        dst[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">16</span>);<font></font>
        dst[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">24</span>);<font></font>
        dst[<span class="hljs-number">4</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">32</span>);<font></font>
        dst[<span class="hljs-number">5</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">40</span>);<font></font>
        dst[<span class="hljs-number">6</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">48</span>);<font></font>
        dst[<span class="hljs-number">7</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">56</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita juga perlu secara efisien menulis byte ke stream. </font><font style="vertical-align: inherit;">Tentu saja, Anda dapat berulang kali menjalankan rekaman 8-bit, tetapi akan jauh lebih cepat untuk digunakan </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Align the bitstream to the next byte boundary, then write the n bytes from
   src to it. Returns false if there is not enough room in the stream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">ostream_write_bytes_aligned</span><span class="hljs-params">(<span class="hljs-keyword">ostream_t</span> *os,
                                               <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src,
                                               <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">if</span> (os-&gt;bitpos_end - round_up(os-&gt;bitpos, <span class="hljs-number">8</span>) &lt; n * <span class="hljs-number">8</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        os-&gt;bitpos = round_up(os-&gt;bitpos, <span class="hljs-number">8</span>);
        <span class="hljs-built_in">memcpy</span>(&amp;os-&gt;dst[os-&gt;bitpos / <span class="hljs-number">8</span>], src, n);<font></font>
        os-&gt;bitpos += n * <span class="hljs-number">8</span>;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br>
<a name="12"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membongkar (Inflasi)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena algoritma kompresi disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deflate</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - blowing, mengekstraksi udara dari sesuatu - proses pembongkaran terkadang disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inflation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jika Anda mempelajari proses ini pertama kali, kami akan memahami cara kerja format. </font><font style="vertical-align: inherit;">Anda dapat melihat kode di bagian pertama dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deflate.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deflate.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bits.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tables.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tables.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (dihasilkan menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generate_tables.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Data yang dikompres menggunakan Deflate disimpan sebagai serangkaian </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blok.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Setiap blok dimulai dengan header 3-bit, di mana bit pertama (paling tidak signifikan) diatur jika itu adalah blok terakhir dari seri, dan dua bit lainnya menunjukkan jenisnya.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/875/b36/1fd/875b361fd3414431d2a20d1ab0b6ef8b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada tiga jenis blok: terkompresi (0), dikompresi menggunakan kode Huffman tetap (1), dan dikompresi menggunakan kode Huffman "dinamis" (2). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode ini melakukan pembongkaran menggunakan fungsi bantu untuk berbagai jenis blok, yang akan kami implementasikan nanti:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> {<font></font>
        HWINF_OK,   <span class="hljs-comment">/* Inflation was successful. */</span>
        HWINF_FULL, <span class="hljs-comment">/* Not enough room in the output buffer. */</span>
        HWINF_ERR   <span class="hljs-comment">/* Error in the input data. */</span>
} <span class="hljs-keyword">inf_stat_t</span>;<font></font>
<font></font>
<span class="hljs-comment">/* Decompress (inflate) the Deflate stream in src. The number of input bytes
   used, at most src_len, is stored in *src_used on success. Output is written
   to dst. The number of bytes written, at most dst_cap, is stored in *dst_used
   on success. src[0..src_len-1] and dst[0..dst_cap-1] must not overlap.
   Returns a status value as defined above. */</span>
<span class="hljs-function"><span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">hwinflate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len, <span class="hljs-keyword">size_t</span> *src_used,
                     <span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_used)</span>
</span>{
        <span class="hljs-keyword">istream_t</span> is;
        <span class="hljs-keyword">size_t</span> dst_pos;
        <span class="hljs-keyword">uint64_t</span> bits;
        <span class="hljs-keyword">bool</span> bfinal;
        <span class="hljs-keyword">inf_stat_t</span> s;<font></font>
<font></font>
        istream_init(&amp;is, src, src_len);<font></font>
        dst_pos = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">do</span> {
                <span class="hljs-comment">/* Read the 3-bit block header. */</span><font></font>
                bits = istream_bits(&amp;is);<font></font>
                <span class="hljs-keyword">if</span> (!istream_advance(&amp;is, <span class="hljs-number">3</span>)) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
                bfinal = bits &amp; <span class="hljs-number">1</span>;<font></font>
                bits &gt;&gt;= <span class="hljs-number">1</span>;<font></font>
<font></font>
                <span class="hljs-keyword">switch</span> (lsb(bits, <span class="hljs-number">2</span>)) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">/* 00: No compression. */</span><font></font>
                        s = inf_noncomp_block(&amp;is, dst, dst_cap, &amp;dst_pos);<font></font>
                        <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">/* 01: Compressed with fixed Huffman codes. */</span><font></font>
                        s = inf_fixed_block(&amp;is, dst, dst_cap, &amp;dst_pos);<font></font>
                        <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">/* 10: Compressed with "dynamic" Huffman codes. */</span><font></font>
                        s = inf_dyn_block(&amp;is, dst, dst_cap, &amp;dst_pos);<font></font>
                        <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>: <span class="hljs-comment">/* Invalid block type. */</span>
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (s != HWINF_OK) {
                        <span class="hljs-keyword">return</span> s;<font></font>
                }<font></font>
        } <span class="hljs-keyword">while</span> (!bfinal);<font></font>
<font></font>
        *src_used = (<span class="hljs-keyword">size_t</span>)(istream_byte_align(&amp;is) - src);<font></font>
<font></font>
        assert(dst_pos &lt;= dst_cap);<font></font>
        *dst_used = dst_pos;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> HWINF_OK;<font></font>
}<font></font>
</code></pre><br>
<a name="13"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blok Deflate Terkompresi</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah blok "tersimpan", tipe paling sederhana. </font><font style="vertical-align: inherit;">Itu dimulai dengan batas 8-bit berikutnya dari bitstream dengan kata 16-bit (len) yang menunjukkan panjang blok. </font><font style="vertical-align: inherit;">Di belakangnya ada kata 16-bit (nlen) lain, yang melengkapi (urutan bit terbalik) dari kata len. </font><font style="vertical-align: inherit;">Diasumsikan bahwa nlen bertindak sebagai len checksum sederhana: jika file rusak, maka nilainya mungkin tidak akan komplementer dan program akan dapat mendeteksi kesalahan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e1/eb8/15b/0e1eb815b2dfec1edb50eeafd1291cc5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah len dan nlen adalah data yang tidak terkompresi. </font><font style="vertical-align: inherit;">Karena panjang blok adalah nilai 16-bit, ukuran data dibatasi hingga 65.535 byte.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">inf_noncomp_block</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">uint8_t</span> *dst,
                                    <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_pos)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint16_t</span> len, nlen;<font></font>
<font></font>
        p = istream_byte_align(is);<font></font>
<font></font>
        <span class="hljs-comment">/* Read len and nlen (2 x 16 bits). */</span>
        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">32</span>)) {
                <span class="hljs-keyword">return</span> HWINF_ERR; <span class="hljs-comment">/* Not enough input. */</span><font></font>
        }<font></font>
        len  = read16le(p);<font></font>
        nlen = read16le(p + <span class="hljs-number">2</span>);<font></font>
        p += <span class="hljs-number">4</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (nlen != (<span class="hljs-keyword">uint16_t</span>)~len) {
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!istream_advance(is, len * <span class="hljs-number">8</span>)) {
                <span class="hljs-keyword">return</span> HWINF_ERR; <span class="hljs-comment">/* Not enough input. */</span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (dst_cap - *dst_pos &lt; len) {
                <span class="hljs-keyword">return</span> HWINF_FULL; <span class="hljs-comment">/* Not enough room to output. */</span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">memcpy</span>(&amp;dst[*dst_pos], p, len);<font></font>
        *dst_pos += len;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> HWINF_OK;<font></font>
}<font></font>
</code></pre><br>
<a name="14"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengempiskan blok menggunakan kode Huffman tetap</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Blok Deflate terkompresi menggunakan kode Huffman untuk mewakili urutan literasi LZ77. </font><font style="vertical-align: inherit;">Tautan balik rusak menggunakan spidol ujung blok. </font><font style="vertical-align: inherit;">Untuk literal, panjang backlink, dan marker, kode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">litlen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Huffman </font><i><font style="vertical-align: inherit;">digunakan</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dan untuk jarak backlink, kode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> digunakan </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c35/0e1/a8c/c350e1a8c73f69203949ccc534141497.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Litlen mengkodekan nilai dalam kisaran 0-285. </font><font style="vertical-align: inherit;">Nilai 0-255 digunakan untuk byte literal, 256 adalah penanda akhir blok, dan 257-285 digunakan untuk panjang backlink. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Backlinks panjangnya 3-258 byte. </font><font style="vertical-align: inherit;">Nilai Litlen menentukan panjang dasar, di mana nol atau lebih </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bit tambahan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ditambahkan dari aliran </font><font style="vertical-align: inherit;">, sehingga panjang penuh diperoleh sesuai dengan tabel di bawah ini. </font><font style="vertical-align: inherit;">Sebagai contoh, nilai litlen 269 berarti panjang dasar 19 dan dua bit tambahan. </font><font style="vertical-align: inherit;">Penambahan dua bit dari aliran memberikan panjang akhir dari 19 hingga 22.</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Litlen</font></font></strong></td>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit ekstra</font></font></strong></td>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panjangnya</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">257</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">258</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">259</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">260</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">261</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">262</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">263</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">264</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">265</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11-12</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">266</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13-14</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">267</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15-16</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">268</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17-18</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">269</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19-22</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">270</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">23–26</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">271</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">27-30</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">272</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">31–34</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">273</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">35–42</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">274</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">43-50</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">275</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">51–58</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">276</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">59–66</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">277</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">67–82</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">278</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">83–98</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">279</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">99-114</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">280</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">115–130</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">281</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">131–162</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">282</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">163–194</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">283</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">195–226</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">284</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">227–257</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">285</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">258</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Harap dicatat bahwa nilai litlen 284 ditambah 5 bit ekstra dapat mewakili panjang 227 hingga 258, namun spesifikasi menyatakan bahwa panjang 258 - panjang maksimum backlink - harus direpresentasikan menggunakan nilai litlen terpisah. </font><font style="vertical-align: inherit;">Ini seharusnya mengurangi pengkodean dalam situasi di mana panjang maksimum sering dijumpai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dekompresor menggunakan tabel untuk mendapatkan panjang dasar dan bit tambahan dari nilai litlen (minus 257):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Table of litlen symbol values minus 257 with corresponding base length
   and number of extra bits. */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">litlen_tbl_t</span> {</span>
        <span class="hljs-keyword">uint16_t</span> base_len : <span class="hljs-number">9</span>;
        <span class="hljs-keyword">uint16_t</span> ebits : <span class="hljs-number">7</span>;<font></font>
};<font></font>
<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">litlen_tbl_t</span> <span class="hljs-title">litlen_tbl</span>[29] = {</span>
<span class="hljs-comment">/* 257 */</span> { <span class="hljs-number">3</span>, <span class="hljs-number">0</span> },
<span class="hljs-comment">/* 258 */</span> { <span class="hljs-number">4</span>, <span class="hljs-number">0</span> },<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/* 284 */</span> { <span class="hljs-number">227</span>, <span class="hljs-number">5</span> },
<span class="hljs-comment">/* 285 */</span> { <span class="hljs-number">258</span>, <span class="hljs-number">0</span> }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode litlen tetap Huffman adalah kanonik dan menggunakan panjang codeword berikut (286–287 bukan nilai litlen yang valid, tetapi mereka terlibat dalam pembuatan kode):</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai Litlen</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panjang Codeword</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0–143</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">144–255</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">256–279</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">280–287</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dekompresor menyimpan panjang-panjang ini dalam tabel yang nyaman untuk transmisi ke </font></font><code>huffman_decoder_init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> fixed_litlen_lengths[<span class="hljs-number">288</span>] = {
<span class="hljs-comment">/*   0 */</span> <span class="hljs-number">8</span>,
<span class="hljs-comment">/*   1 */</span> <span class="hljs-number">8</span>,<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/* 287 */</span> <span class="hljs-number">8</span>,<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jarak backlink bervariasi dari 1 hingga 32.768. Mereka dikodekan menggunakan skema yang mirip dengan skema pengkodean panjang. </font><font style="vertical-align: inherit;">The Huffman code dist mengkodekan nilai dari 0 hingga 29, yang masing-masing sesuai dengan panjang dasar, di mana bit tambahan ditambahkan untuk mendapatkan jarak akhir:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dist</font></font></strong></td>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit ekstra</font></font></strong></td>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jarak</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5-6</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7-8</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9-12</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13-16</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17-24</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25–32</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">33–48</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebelas</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">49–64</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65–96</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tigabelas</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">97–128</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">129–192</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lima belas</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">193–256</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enambelas</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">257-384</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">385-512</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delapan belas</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">513-768</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sembilan belas</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">769-1024</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua puluh</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1025-1536</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1537–2048</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2049-3072</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">23</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3073–4096</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebelas</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4097-6144</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebelas</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6145–8192</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8193–12288</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">27</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12289–16384</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tigabelas</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16385–24576</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tanggal 29</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tigabelas</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24577–32768</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dist kode tetap Huffman adalah kanonik. </font><font style="vertical-align: inherit;">Semua codeword panjangnya 5 bit. </font><font style="vertical-align: inherit;">Sederhana, dekompresor menyimpan kode dalam tabel yang dapat digunakan dengan </font></font><code>huffman_decoder_init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(nilai dist 30-31 tidak benar. Diindikasikan bahwa mereka terlibat dalam pembuatan kode Huffman, tetapi sebenarnya tidak berpengaruh):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> fixed_dist_lengths[<span class="hljs-number">32</span>] = {
<span class="hljs-comment">/*  0 */</span> <span class="hljs-number">5</span>,
<span class="hljs-comment">/*  1 */</span> <span class="hljs-number">5</span>,<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/* 31 */</span> <span class="hljs-number">5</span>,<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode Dekompresi atau Pembongkaran - Blok Deflate menggunakan kode Huffman tetap:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">inf_fixed_block</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">uint8_t</span> *dst,
                                  <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_pos)</span>
</span>{
        <span class="hljs-keyword">huffman_decoder_t</span> litlen_dec, dist_dec;<font></font>
<font></font>
        huffman_decoder_init(&amp;litlen_dec, fixed_litlen_lengths,<font></font>
                             <span class="hljs-keyword">sizeof</span>(fixed_litlen_lengths) /
                             <span class="hljs-keyword">sizeof</span>(fixed_litlen_lengths[<span class="hljs-number">0</span>]));<font></font>
        huffman_decoder_init(&amp;dist_dec, fixed_dist_lengths,<font></font>
                             <span class="hljs-keyword">sizeof</span>(fixed_dist_lengths) /
                             <span class="hljs-keyword">sizeof</span>(fixed_dist_lengths[<span class="hljs-number">0</span>]));<font></font>
<font></font>
        <span class="hljs-keyword">return</span> inf_block(is, dst, dst_cap, dst_pos, &amp;litlen_dec, &amp;dist_dec);<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LITLEN_EOB 256</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LITLEN_MAX 285</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LITLEN_TBL_OFFSET 257</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LEN 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_LEN 258</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DISTSYM_MAX 29</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_DISTANCE 1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_DISTANCE 32768</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">inf_block</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_cap,
                            <span class="hljs-keyword">size_t</span> *dst_pos,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_decoder_t</span> *litlen_dec,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_decoder_t</span> *dist_dec)</span>
</span>{
        <span class="hljs-keyword">uint64_t</span> bits;
        <span class="hljs-keyword">size_t</span> used, used_tot, dist, len;
        <span class="hljs-keyword">int</span> litlen, distsym;
        <span class="hljs-keyword">uint16_t</span> ebits;<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
                <span class="hljs-comment">/* Read a litlen symbol. */</span><font></font>
                bits = istream_bits(is);<font></font>
                litlen = huffman_decode(litlen_dec, (<span class="hljs-keyword">uint16_t</span>)bits, &amp;used);<font></font>
                bits &gt;&gt;= used;<font></font>
                used_tot = used;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (litlen &lt; <span class="hljs-number">0</span> || litlen &gt; LITLEN_MAX) {
                        <span class="hljs-comment">/* Failed to decode, or invalid symbol. */</span>
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (litlen &lt;= UINT8_MAX) {
                        <span class="hljs-comment">/* Literal. */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, used_tot)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">if</span> (*dst_pos == dst_cap) {
                                <span class="hljs-keyword">return</span> HWINF_FULL;<font></font>
                        }<font></font>
                        lz77_output_lit(dst, (*dst_pos)++, (<span class="hljs-keyword">uint8_t</span>)litlen);
                        <span class="hljs-keyword">continue</span>;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (litlen == LITLEN_EOB) {
                        <span class="hljs-comment">/* End of block. */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, used_tot)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">return</span> HWINF_OK;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* It is a back reference. Figure out the length. */</span><font></font>
                assert(litlen &gt;= LITLEN_TBL_OFFSET &amp;&amp; litlen &lt;= LITLEN_MAX);<font></font>
                len   = litlen_tbl[litlen - LITLEN_TBL_OFFSET].base_len;<font></font>
                ebits = litlen_tbl[litlen - LITLEN_TBL_OFFSET].ebits;<font></font>
                <span class="hljs-keyword">if</span> (ebits != <span class="hljs-number">0</span>) {<font></font>
                        len += lsb(bits, ebits);<font></font>
                        bits &gt;&gt;= ebits;<font></font>
                        used_tot += ebits;<font></font>
                }<font></font>
                assert(len &gt;= MIN_LEN &amp;&amp; len &lt;= MAX_LEN);<font></font>
<font></font>
                <span class="hljs-comment">/* Get the distance. */</span>
                distsym = huffman_decode(dist_dec, (<span class="hljs-keyword">uint16_t</span>)bits, &amp;used);<font></font>
                bits &gt;&gt;= used;<font></font>
                used_tot += used;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (distsym &lt; <span class="hljs-number">0</span> || distsym &gt; DISTSYM_MAX) {
                        <span class="hljs-comment">/* Failed to decode, or invalid symbol. */</span>
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
                dist  = dist_tbl[distsym].base_dist;<font></font>
                ebits = dist_tbl[distsym].ebits;<font></font>
                <span class="hljs-keyword">if</span> (ebits != <span class="hljs-number">0</span>) {<font></font>
                        dist += lsb(bits, ebits);<font></font>
                        bits &gt;&gt;= ebits;<font></font>
                        used_tot += ebits;<font></font>
                }<font></font>
                assert(dist &gt;= MIN_DISTANCE &amp;&amp; dist &lt;= MAX_DISTANCE);<font></font>
<font></font>
                assert(used_tot &lt;= ISTREAM_MIN_BITS);<font></font>
                <span class="hljs-keyword">if</span> (!istream_advance(is, used_tot)) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Bounds check and output the backref. */</span>
                <span class="hljs-keyword">if</span> (dist &gt; *dst_pos) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (round_up(len, <span class="hljs-number">8</span>) &lt;= dst_cap - *dst_pos) {<font></font>
                        output_backref64(dst, *dst_pos, dist, len);<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &lt;= dst_cap - *dst_pos) {<font></font>
                        lz77_output_backref(dst, *dst_pos, dist, len);<font></font>
                } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">return</span> HWINF_FULL;<font></font>
                }<font></font>
                (*dst_pos) += len;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan optimasi ini: ketika tidak ada cukup ruang di buffer keluar, kami mengeluarkan backlink menggunakan fungsi di bawah ini, yang menyalin 64 bit sekaligus. </font><font style="vertical-align: inherit;">Ini "berantakan" dalam arti sering menyalin beberapa byte tambahan (hingga kelipatan 8 berikutnya). </font><font style="vertical-align: inherit;">Tetapi ini bekerja jauh lebih cepat </font></font><code>lz77_output_backref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena ia membutuhkan iterasi siklus dan akses memori yang lebih sedikit. </font><font style="vertical-align: inherit;">Bahkan, backlink pendek sekarang akan diproses dalam satu iterasi, yang sangat baik untuk memprediksi percabangan.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Output the (dist,len) backref at dst_pos in dst using 64-bit wide writes.
   There must be enough room for len bytes rounded to the next multiple of 8. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">output_backref64</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_pos, <span class="hljs-keyword">size_t</span> dist,
                             <span class="hljs-keyword">size_t</span> len)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;
        <span class="hljs-keyword">uint64_t</span> tmp;<font></font>
<font></font>
        assert(len &gt; <span class="hljs-number">0</span>);<font></font>
        assert(dist &lt;= dst_pos &amp;&amp; <span class="hljs-string">"cannot reference before beginning of dst"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (len &gt; dist) {
                <span class="hljs-comment">/* Self-overlapping backref; fall back to byte-by-byte copy. */</span><font></font>
                lz77_output_backref(dst, dst_pos, dist, len);<font></font>
                <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">do</span> {
                <span class="hljs-built_in">memcpy</span>(&amp;tmp, &amp;dst[dst_pos - dist + i], <span class="hljs-number">8</span>);
                <span class="hljs-built_in">memcpy</span>(&amp;dst[dst_pos + i], &amp;tmp, <span class="hljs-number">8</span>);<font></font>
                i += <span class="hljs-number">8</span>;<font></font>
        } <span class="hljs-keyword">while</span> (i &lt; len);<font></font>
}<font></font>
</code></pre><br>
<a name="15"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengempiskan blok menggunakan kode Huffman dinamis</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengempiskan blok menggunakan kode Huffman dinamis bekerja dengan cara yang sama seperti dijelaskan di atas. Tetapi alih-alih kode yang telah ditentukan untuk litlen dan dist, mereka menggunakan kode yang disimpan dalam aliran Deflate itu sendiri di awal blok. Nama ini mungkin tidak berhasil, karena kode Huffman dinamis juga disebut kode yang berubah selama pengkodean - ini adalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengkodean Huffman adaptif</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kode yang dijelaskan di sini tidak ada hubungannya dengan prosedur itu. Mereka dinamis hanya dalam arti bahwa blok yang berbeda dapat menggunakan kode yang berbeda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Membuat kode litlen dan dist dinamis adalah bagian tersulit dari format Deflate. Tetapi segera setelah kode dihasilkan, dekompresi dilakukan dengan cara yang sama seperti yang dijelaskan di bagian sebelumnya, menggunakan </font></font><code>inf_block</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">inf_dyn_block</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">uint8_t</span> *dst,
                                <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_pos)</span>
</span>{
        <span class="hljs-keyword">inf_stat_t</span> s;
        <span class="hljs-keyword">huffman_decoder_t</span> litlen_dec, dist_dec;<font></font>
<font></font>
        s = init_dyn_decoders(is, &amp;litlen_dec, &amp;dist_dec);<font></font>
        <span class="hljs-keyword">if</span> (s != HWINF_OK) {
                <span class="hljs-keyword">return</span> s;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> inf_block(is, dst, dst_cap, dst_pos, &amp;litlen_dec, &amp;dist_dec);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode litlen dan dist untuk blok Deflate dinamis disimpan sebagai serangkaian panjang kode kata. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panjangnya</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sendiri dikodekan menggunakan kode Huffman ketiga - </font><i><font style="vertical-align: inherit;">codelen</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Kode ini ditentukan oleh panjang kata-kata kode ( </font></font><code>codelen_lens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) yang disimpan dalam blok (apakah saya menyebutkan bahwa itu sulit?).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84e/1fc/0e3/84e1fc0e3d3cfcb56ff215702d14f73d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada awal blok dinamis ada 14 bit yang menentukan jumlah panjang kata kode litlen, dist- dan codelen yang perlu dibaca dari blok:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_CODELEN_LENS 4</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_CODELEN_LENS 19</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LITLEN_LENS 257</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_LITLEN_LENS 288</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_DIST_LENS 1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_DIST_LENS 32</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_MAX_LIT 15</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_COPY 16</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_COPY_MIN 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_COPY_MAX 6</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS 17</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS_MIN 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS_MAX 10</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS2 18</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS2_MIN 11</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS2_MAX 138</span><font></font>
<font></font>
<span class="hljs-comment">/* RFC 1951, 3.2.7 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> codelen_lengths_order[MAX_CODELEN_LENS] =<font></font>
{ <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">13</span>, <span class="hljs-number">2</span>, <span class="hljs-number">14</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span> };<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">init_dyn_decoders</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is,
                                    <span class="hljs-keyword">huffman_decoder_t</span> *litlen_dec,
                                    <span class="hljs-keyword">huffman_decoder_t</span> *dist_dec)</span>
</span>{
        <span class="hljs-keyword">uint64_t</span> bits;
        <span class="hljs-keyword">size_t</span> num_litlen_lens, num_dist_lens, num_codelen_lens;
        <span class="hljs-keyword">uint8_t</span> codelen_lengths[MAX_CODELEN_LENS];
        <span class="hljs-keyword">uint8_t</span> code_lengths[MAX_LITLEN_LENS + MAX_DIST_LENS];
        <span class="hljs-keyword">size_t</span> i, n, used;
        <span class="hljs-keyword">int</span> sym;
        <span class="hljs-keyword">huffman_decoder_t</span> codelen_dec;<font></font>
<font></font>
        bits = istream_bits(is);<font></font>
<font></font>
        <span class="hljs-comment">/* Number of litlen codeword lengths (5 bits + 257). */</span>
        num_litlen_lens = lsb(bits, <span class="hljs-number">5</span>) + MIN_LITLEN_LENS;<font></font>
        bits &gt;&gt;= <span class="hljs-number">5</span>;<font></font>
        assert(num_litlen_lens &lt;= MAX_LITLEN_LENS);<font></font>
<font></font>
        <span class="hljs-comment">/* Number of dist codeword lengths (5 bits + 1). */</span>
        num_dist_lens = lsb(bits, <span class="hljs-number">5</span>) + MIN_DIST_LENS;<font></font>
        bits &gt;&gt;= <span class="hljs-number">5</span>;<font></font>
        assert(num_dist_lens &lt;= MAX_DIST_LENS);<font></font>
<font></font>
        <span class="hljs-comment">/* Number of code length lengths (4 bits + 4). */</span>
        num_codelen_lens = lsb(bits, <span class="hljs-number">4</span>) + MIN_CODELEN_LENS;<font></font>
        bits &gt;&gt;= <span class="hljs-number">4</span>;<font></font>
        assert(num_codelen_lens &lt;= MAX_CODELEN_LENS);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">5</span> + <span class="hljs-number">5</span> + <span class="hljs-number">4</span>)) {
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian datang panjang codeword untuk kode codelen. </font><font style="vertical-align: inherit;">Panjang ini adalah nilai tiga-bit yang biasa, tetapi ditulis dalam urutan khusus yang ditentukan dalam </font></font><code>codelen_lengths_order</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Karena perlu untuk menentukan 19 panjang, hanya akan dibaca dari sungai </font></font><code>num_codelen_lens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">semua yang lain secara implisit adalah nol. </font><font style="vertical-align: inherit;">Panjangnya terdaftar dalam urutan tertentu sehingga panjang nol lebih cenderung jatuh pada akhir daftar dan tidak disimpan dalam blok.</font></font><br>
<br>
<pre><code class="cpp hljs">       <span class="hljs-comment">/* Read the codelen codeword lengths (3 bits each)
           and initialize the codelen decoder. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_codelen_lens; i++) {<font></font>
                bits = istream_bits(is);<font></font>
                codelen_lengths[codelen_lengths_order[i]] =<font></font>
                        (<span class="hljs-keyword">uint8_t</span>)lsb(bits, <span class="hljs-number">3</span>);
                <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">3</span>)) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
        }<font></font>
        <span class="hljs-keyword">for</span> (; i &lt; MAX_CODELEN_LENS; i++) {<font></font>
                codelen_lengths[codelen_lengths_order[i]] = <span class="hljs-number">0</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (!huffman_decoder_init(&amp;codelen_dec, codelen_lengths,<font></font>
                                  MAX_CODELEN_LENS)) {<font></font>
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan mengatur decoder codelen, kita dapat membaca panjang kata-kata kode litlen dan dist dari stream.</font></font><br>
<br>
<pre><code class="cpp hljs">       <span class="hljs-comment">/* Read the litlen and dist codeword lengths. */</span>
        i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (i &lt; num_litlen_lens + num_dist_lens) {<font></font>
                bits = istream_bits(is);<font></font>
                sym = huffman_decode(&amp;codelen_dec, (<span class="hljs-keyword">uint16_t</span>)bits, &amp;used);<font></font>
                bits &gt;&gt;= used;<font></font>
                <span class="hljs-keyword">if</span> (!istream_advance(is, used)) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (sym &gt;= <span class="hljs-number">0</span> &amp;&amp; sym &lt;= CODELEN_MAX_LIT) {
                        <span class="hljs-comment">/* A literal codeword length. */</span>
                        code_lengths[i++] = (<span class="hljs-keyword">uint8_t</span>)sym;<font></font>
                }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16, 17 dan 18 bukan panjang sebenarnya, itu adalah indikator bahwa panjang sebelumnya perlu diulang beberapa kali, atau Anda perlu mengulangi panjang nol:</font></font><br>
<br>
<pre><code class="cpp hljs">               <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_COPY) {
                        <span class="hljs-comment">/* Copy the previous codeword length 3--6 times. */</span>
                        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span>) {
                                <span class="hljs-keyword">return</span> HWINF_ERR; <span class="hljs-comment">/* No previous length. */</span><font></font>
                        }<font></font>
                        n = lsb(bits, <span class="hljs-number">2</span>) + CODELEN_COPY_MIN; <span class="hljs-comment">/* 2 bits + 3 */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">2</span>)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        assert(n &gt;= CODELEN_COPY_MIN &amp;&amp; n &lt;= CODELEN_COPY_MAX);<font></font>
                        <span class="hljs-keyword">if</span> (i + n &gt; num_litlen_lens + num_dist_lens) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">while</span> (n--) {<font></font>
                                code_lengths[i] = code_lengths[i - <span class="hljs-number">1</span>];<font></font>
                                i++;<font></font>
                        }<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_ZEROS) {
                        <span class="hljs-comment">/* 3--10 zeros. */</span>
                        n = lsb(bits, <span class="hljs-number">3</span>) + CODELEN_ZEROS_MIN; <span class="hljs-comment">/* 3 bits + 3 */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">3</span>)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        assert(n &gt;= CODELEN_ZEROS_MIN &amp;&amp;<font></font>
                               n &lt;= CODELEN_ZEROS_MAX);<font></font>
                        <span class="hljs-keyword">if</span> (i + n &gt; num_litlen_lens + num_dist_lens) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">while</span> (n--) {<font></font>
                                code_lengths[i++] = <span class="hljs-number">0</span>;<font></font>
                        }<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_ZEROS2) {
                        <span class="hljs-comment">/* 11--138 zeros. */</span>
                        n = lsb(bits, <span class="hljs-number">7</span>) + CODELEN_ZEROS2_MIN; <span class="hljs-comment">/* 7 bits +138 */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">7</span>)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        assert(n &gt;= CODELEN_ZEROS2_MIN &amp;&amp;<font></font>
                               n &lt;= CODELEN_ZEROS2_MAX);<font></font>
                        <span class="hljs-keyword">if</span> (i + n &gt; num_litlen_lens + num_dist_lens) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">while</span> (n--) {<font></font>
                                code_lengths[i++] = <span class="hljs-number">0</span>;<font></font>
                        }<font></font>
                } <span class="hljs-keyword">else</span> {
                        <span class="hljs-comment">/* Invalid symbol. */</span>
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan bahwa panjang litlen dan dist dibaca satu per satu ke dalam array </font></font><code>code_lengths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mereka tidak dapat dibaca secara terpisah, karena panjang kode berjalan dapat dibawa dari panjang litlen terakhir ke panjang dist pertama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menyiapkan panjang kode kata, kita dapat mengonfigurasi decoder Huffman dan kembali ke tugas mendekode literal dan tautan balik:</font></font><br>
<br>
<pre><code class="cpp hljs">       <span class="hljs-keyword">if</span> (!huffman_decoder_init(litlen_dec, &amp;code_lengths[<span class="hljs-number">0</span>],<font></font>
                                  num_litlen_lens)) {<font></font>
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (!huffman_decoder_init(dist_dec, &amp;code_lengths[num_litlen_lens],<font></font>
                                  num_dist_lens)) {<font></font>
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> HWINF_OK;<font></font>
}<font></font>
</code></pre><br>
<a name="16"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompresi (Deflasi)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bagian sebelumnya, kami menciptakan semua alat yang diperlukan untuk kompresi Deflate: Lempel-Ziv, pengkodean Huffman, bit stream dan deskripsi dari tiga jenis blok Deflate. Dan di bagian ini kita akan menggabungkan semuanya untuk mendapatkan kompresi Deflate. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compression Lempel-Ziv mem-parsing data sumber ke dalam urutan backlink dan literal. Urutan ini harus dibagi dan dikodekan ke blok Deflate, seperti yang dijelaskan di bagian sebelumnya. Memilih metode partisi sering disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pemblokiran.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Di satu sisi, setiap blok baru berarti semacam overhead, volume yang tergantung pada jenis blok dan isinya. </font><font style="vertical-align: inherit;">Lebih sedikit blok - lebih sedikit overhead. </font><font style="vertical-align: inherit;">Di sisi lain, biaya pembuatan blok baru ini dapat membuahkan hasil. </font><font style="vertical-align: inherit;">Misalnya, jika karakteristik data memungkinkan untuk melakukan pengkodean Huffman secara lebih efisien dan mengurangi jumlah total data yang dihasilkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memblokir adalah tugas optimasi yang sulit. </font><font style="vertical-align: inherit;">Beberapa kompresor (misalnya, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zopfli</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) mencoba lebih baik daripada yang lain, tetapi kebanyakan hanya menggunakan pendekatan serakah: mereka mengeluarkan blok segera setelah mereka mencapai ukuran tertentu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berbagai jenis blok memiliki batasan ukurannya sendiri:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blok yang tidak terkompresi dapat mengandung tidak lebih dari 65.535 byte.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode tetap Huffman tidak memiliki ukuran maksimum.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode Dynamic Huffman umumnya tidak memiliki ukuran maksimum, tetapi karena implementasi algoritma Huffman kami menggunakan urutan karakter 16-bit, kami dibatasi hingga 65.535 karakter.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menggunakan blok jenis apa pun secara bebas, batasi ukurannya hingga 65.534 byte:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* The largest number of bytes that will fit in any kind of block is 65,534.
   It will fit in an uncompressed block (max 65,535 bytes) and a Huffman
   block with only literals (65,535 symbols including end-of-block marker). */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_BLOCK_LEN_BYTES 65534</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk melacak bitstream keluar dan konten blok saat ini selama kompresi, kami akan menggunakan struktur:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deflate_state_t</span> <span class="hljs-title">deflate_state_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deflate_state_t</span> {</span>
        <span class="hljs-keyword">ostream_t</span> os;<font></font>
<font></font>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *block_src; <span class="hljs-comment">/* First src byte in the block. */</span><font></font>
<font></font>
        <span class="hljs-keyword">size_t</span> block_len;       <span class="hljs-comment">/* Number of symbols in the current block. */</span>
        <span class="hljs-keyword">size_t</span> block_len_bytes; <span class="hljs-comment">/* Number of src bytes in the block. */</span><font></font>
<font></font>
        <span class="hljs-comment">/* Symbol frequencies for the current block. */</span>
        <span class="hljs-keyword">uint16_t</span> litlen_freqs[LITLEN_MAX + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">uint16_t</span> dist_freqs[DISTSYM_MAX + <span class="hljs-number">1</span>];<font></font>
<font></font>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
                <span class="hljs-keyword">uint16_t</span> distance;    <span class="hljs-comment">/* Backref distance. */</span>
                <span class="hljs-keyword">union</span> {
                        <span class="hljs-keyword">uint16_t</span> lit; <span class="hljs-comment">/* Literal byte or end-of-block. */</span>
                        <span class="hljs-keyword">uint16_t</span> len; <span class="hljs-comment">/* Backref length (distance != 0). */</span><font></font>
                } u;<font></font>
        } block[MAX_BLOCK_LEN_BYTES + <span class="hljs-number">1</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reset_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s)</span>
</span>{<font></font>
        s-&gt;block_len = <span class="hljs-number">0</span>;<font></font>
        s-&gt;block_len_bytes = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">memset</span>(s-&gt;litlen_freqs, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(s-&gt;litlen_freqs));
        <span class="hljs-built_in">memset</span>(s-&gt;dist_freqs, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(s-&gt;dist_freqs));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menambahkan hasil kerja ke blok, </font></font><code>lz77_compress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami akan menggunakan fungsi callback, dan setelah mencapai ukuran maksimum, kami akan menulis blok ke bitstream:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">lit_callback</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> lit, <span class="hljs-keyword">void</span> *aux)</span>
</span>{
        <span class="hljs-keyword">deflate_state_t</span> *s = aux;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (s-&gt;block_len_bytes + <span class="hljs-number">1</span> &gt; MAX_BLOCK_LEN_BYTES) {
                <span class="hljs-keyword">if</span> (!write_block(s, <span class="hljs-literal">false</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                s-&gt;block_src += s-&gt;block_len_bytes;<font></font>
                reset_block(s);<font></font>
        }<font></font>
<font></font>
        assert(s-&gt;block_len &lt; <span class="hljs-keyword">sizeof</span>(s-&gt;block) / <span class="hljs-keyword">sizeof</span>(s-&gt;block[<span class="hljs-number">0</span>]));<font></font>
        s-&gt;block[s-&gt;block_len  ].distance = <span class="hljs-number">0</span>;<font></font>
        s-&gt;block[s-&gt;block_len++].u.lit = lit;<font></font>
        s-&gt;block_len_bytes++;<font></font>
<font></font>
        s-&gt;litlen_freqs[lit]++;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">backref_callback</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> dist, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">void</span> *aux)</span>
</span>{
        <span class="hljs-keyword">deflate_state_t</span> *s = aux;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (s-&gt;block_len_bytes + len &gt; MAX_BLOCK_LEN_BYTES) {
                <span class="hljs-keyword">if</span> (!write_block(s, <span class="hljs-literal">false</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                s-&gt;block_src += s-&gt;block_len_bytes;<font></font>
                reset_block(s);<font></font>
        }<font></font>
<font></font>
        assert(s-&gt;block_len &lt; <span class="hljs-keyword">sizeof</span>(s-&gt;block) / <span class="hljs-keyword">sizeof</span>(s-&gt;block[<span class="hljs-number">0</span>]));<font></font>
        s-&gt;block[s-&gt;block_len  ].distance = (<span class="hljs-keyword">uint16_t</span>)dist;<font></font>
        s-&gt;block[s-&gt;block_len++].u.len = (<span class="hljs-keyword">uint16_t</span>)len;<font></font>
        s-&gt;block_len_bytes += len;<font></font>
<font></font>
        assert(len &gt;= MIN_LEN &amp;&amp; len &lt;= MAX_LEN);<font></font>
        assert(dist &gt;= MIN_DISTANCE &amp;&amp; dist &lt;= MAX_DISTANCE);<font></font>
        s-&gt;litlen_freqs[len2litlen[len]]++;<font></font>
        s-&gt;dist_freqs[distance2dist[dist]]++;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang paling menarik adalah rekaman balok. </font><font style="vertical-align: inherit;">Jika blok tidak dikompresi, maka semuanya sederhana:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_uncomp_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">final</span>)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> len_nlen[<span class="hljs-number">4</span>];<font></font>
<font></font>
        <span class="hljs-comment">/* Write the block header. */</span>
        <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, (<span class="hljs-number">0x0</span> &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-keyword">final</span>, <span class="hljs-number">3</span>)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        len_nlen[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">uint8_t</span>)(s-&gt;block_len_bytes &gt;&gt; <span class="hljs-number">0</span>);<font></font>
        len_nlen[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">uint8_t</span>)(s-&gt;block_len_bytes &gt;&gt; <span class="hljs-number">8</span>);<font></font>
        len_nlen[<span class="hljs-number">2</span>] = ~len_nlen[<span class="hljs-number">0</span>];<font></font>
        len_nlen[<span class="hljs-number">3</span>] = ~len_nlen[<span class="hljs-number">1</span>];<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!ostream_write_bytes_aligned(&amp;s-&gt;os, len_nlen, <span class="hljs-keyword">sizeof</span>(len_nlen))) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!ostream_write_bytes_aligned(&amp;s-&gt;os, s-&gt;block_src,<font></font>
                                         s-&gt;block_len_bytes)) {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menulis blok Huffman statis, pertama-tama kita membuat kode kanonik berdasarkan panjang kode sandi tetap untuk kode litlen dan dist. </font><font style="vertical-align: inherit;">Kemudian kita mengulangi blok, menuliskan karakter yang menggunakan kode ini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_static_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">final</span>)</span>
</span>{
        <span class="hljs-keyword">huffman_encoder_t</span> litlen_enc, dist_enc;<font></font>
<font></font>
        <span class="hljs-comment">/* Write the block header. */</span>
        <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, (<span class="hljs-number">0x1</span> &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-keyword">final</span>, <span class="hljs-number">3</span>)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        huffman_encoder_init2(&amp;litlen_enc, fixed_litlen_lengths,<font></font>
                              <span class="hljs-keyword">sizeof</span>(fixed_litlen_lengths) /
                              <span class="hljs-keyword">sizeof</span>(fixed_litlen_lengths[<span class="hljs-number">0</span>]));<font></font>
        huffman_encoder_init2(&amp;dist_enc, fixed_dist_lengths,<font></font>
                              <span class="hljs-keyword">sizeof</span>(fixed_dist_lengths) /
                              <span class="hljs-keyword">sizeof</span>(fixed_dist_lengths[<span class="hljs-number">0</span>]));<font></font>
<font></font>
        <span class="hljs-keyword">return</span> write_huffman_block(s, &amp;litlen_enc, &amp;dist_enc);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_huffman_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *litlen_enc,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *dist_enc)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i, nbits;
        <span class="hljs-keyword">uint64_t</span> distance, dist, len, litlen, bits, ebits;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; s-&gt;block_len; i++) {
                <span class="hljs-keyword">if</span> (s-&gt;block[i].distance == <span class="hljs-number">0</span>) {
                        <span class="hljs-comment">/* Literal or EOB. */</span><font></font>
                        litlen = s-&gt;block[i].u.lit;<font></font>
                        assert(litlen &lt;= LITLEN_EOB);<font></font>
                        <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os,<font></font>
                                           litlen_enc-&gt;codewords[litlen],<font></font>
                                           litlen_enc-&gt;lengths[litlen])) {<font></font>
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Back reference length. */</span><font></font>
                len = s-&gt;block[i].u.len;<font></font>
                litlen = len2litlen[len];<font></font>
<font></font>
                <span class="hljs-comment">/* litlen bits */</span><font></font>
                bits = litlen_enc-&gt;codewords[litlen];<font></font>
                nbits = litlen_enc-&gt;lengths[litlen];<font></font>
<font></font>
                <span class="hljs-comment">/* ebits */</span><font></font>
                ebits = len - litlen_tbl[litlen - LITLEN_TBL_OFFSET].base_len;<font></font>
                bits |= ebits &lt;&lt; nbits;<font></font>
                nbits += litlen_tbl[litlen - LITLEN_TBL_OFFSET].ebits;<font></font>
<font></font>
                <span class="hljs-comment">/* Back reference distance. */</span><font></font>
                distance = s-&gt;block[i].distance;<font></font>
                dist = distance2dist[distance];<font></font>
<font></font>
                <span class="hljs-comment">/* dist bits */</span>
                bits |= (<span class="hljs-keyword">uint64_t</span>)dist_enc-&gt;codewords[dist] &lt;&lt; nbits;<font></font>
                nbits += dist_enc-&gt;lengths[dist];<font></font>
<font></font>
                <span class="hljs-comment">/* ebits */</span><font></font>
                ebits = distance - dist_tbl[dist].base_dist;<font></font>
                bits |= ebits &lt;&lt; nbits;<font></font>
                nbits += dist_tbl[dist].ebits;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, bits, nbits)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, menulis blok dinamis Huffman lebih sulit karena mengandung kode rumit litlen dan kode dist. </font><font style="vertical-align: inherit;">Untuk mewakili pengkodean ini, kami menggunakan struktur berikut:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">codelen_sym_t</span> <span class="hljs-title">codelen_sym_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">codelen_sym_t</span> {</span>
        <span class="hljs-keyword">uint8_t</span> sym;
        <span class="hljs-keyword">uint8_t</span> count; <span class="hljs-comment">/* For symbols 16, 17, 18. */</span><font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, kita membuang ekor nol panjang dari codewords litlen dan dist, dan kemudian menyalinnya ke dalam array reguler untuk pengkodean selanjutnya. </font><font style="vertical-align: inherit;">Kami tidak dapat membuang semua nol: tidak mungkin untuk menyandikan blok Deflate jika tidak ada kode dist tunggal di dalamnya. </font><font style="vertical-align: inherit;">Juga tidak mungkin memiliki kurang dari 257 kode litlen, tetapi karena kita selalu memiliki penanda akhir byte, akan selalu ada panjang kode non-nol untuk karakter 256.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Encode litlen_lens and dist_lens into encoded. *num_litlen_lens and
   *num_dist_lens will be set to the number of encoded litlen and dist lens,
   respectively. Returns the number of elements in encoded. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">encode_dist_litlen_lens</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *litlen_lens,
                                      <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *dist_lens,
                                      <span class="hljs-keyword">codelen_sym_t</span> *encoded,
                                      <span class="hljs-keyword">size_t</span> *num_litlen_lens,
                                      <span class="hljs-keyword">size_t</span> *num_dist_lens)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i, n;
        <span class="hljs-keyword">uint8_t</span> lens[LITLEN_MAX + <span class="hljs-number">1</span> + DISTSYM_MAX + <span class="hljs-number">1</span>];<font></font>
<font></font>
        *num_litlen_lens = LITLEN_MAX + <span class="hljs-number">1</span>;<font></font>
        *num_dist_lens = DISTSYM_MAX + <span class="hljs-number">1</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* Drop trailing zero litlen lengths. */</span>
        assert(litlen_lens[LITLEN_EOB] != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-string">"EOB len should be non-zero."</span>);
        <span class="hljs-keyword">while</span> (litlen_lens[*num_litlen_lens - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) {<font></font>
                (*num_litlen_lens)--;<font></font>
        }<font></font>
        assert(*num_litlen_lens &gt;= MIN_LITLEN_LENS);<font></font>
<font></font>
        <span class="hljs-comment">/* Drop trailing zero dist lengths, keeping at least one. */</span>
        <span class="hljs-keyword">while</span> (dist_lens[*num_dist_lens - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; *num_dist_lens &gt; <span class="hljs-number">1</span>) {<font></font>
                (*num_dist_lens)--;<font></font>
        }<font></font>
        assert(*num_dist_lens &gt;= MIN_DIST_LENS);<font></font>
<font></font>
        <span class="hljs-comment">/* Copy the lengths into a unified array. */</span>
        n = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; *num_litlen_lens; i++) {<font></font>
                lens[n++] = litlen_lens[i];<font></font>
        }<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; *num_dist_lens; i++) {<font></font>
                lens[n++] = dist_lens[i];<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> encode_lens(lens, n, encoded);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menambahkan panjang kode menjadi satu array, kami melakukan pengkodean menggunakan karakter khusus untuk menjalankan panjang kode yang sama.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Encode the n code lengths in lens into encoded, returning the number of
   elements in encoded. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">encode_lens</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *lens, <span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">codelen_sym_t</span> *encoded)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i, j, num_encoded;
        <span class="hljs-keyword">uint8_t</span> count;<font></font>
<font></font>
        i = <span class="hljs-number">0</span>;<font></font>
        num_encoded = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (i &lt; n) {
                <span class="hljs-keyword">if</span> (lens[i] == <span class="hljs-number">0</span>) {
                        <span class="hljs-comment">/* Scan past the end of this zero run (max 138). */</span>
                        <span class="hljs-keyword">for</span> (j = i; j &lt; min(n, i + CODELEN_ZEROS2_MAX) &amp;&amp;<font></font>
                                    lens[j] == <span class="hljs-number">0</span>; j++);<font></font>
                        count = (<span class="hljs-keyword">uint8_t</span>)(j - i);<font></font>
<font></font>
                        <span class="hljs-keyword">if</span> (count &lt; CODELEN_ZEROS_MIN) {
                                <span class="hljs-comment">/* Output a single zero. */</span>
                                encoded[num_encoded++].sym = <span class="hljs-number">0</span>;<font></font>
                                i++;<font></font>
                                <span class="hljs-keyword">continue</span>;<font></font>
                        }<font></font>
<font></font>
                        <span class="hljs-comment">/* Output a repeated zero. */</span>
                        <span class="hljs-keyword">if</span> (count &lt;= CODELEN_ZEROS_MAX) {
                                <span class="hljs-comment">/* Repeated zero 3--10 times. */</span><font></font>
                                assert(count &gt;= CODELEN_ZEROS_MIN &amp;&amp;<font></font>
                                       count &lt;= CODELEN_ZEROS_MAX);<font></font>
                                encoded[num_encoded].sym = CODELEN_ZEROS;<font></font>
                                encoded[num_encoded++].count = count;<font></font>
                        } <span class="hljs-keyword">else</span> {
                                <span class="hljs-comment">/* Repeated zero 11--138 times. */</span><font></font>
                                assert(count &gt;= CODELEN_ZEROS2_MIN &amp;&amp;<font></font>
                                       count &lt;= CODELEN_ZEROS2_MAX);<font></font>
                                encoded[num_encoded].sym = CODELEN_ZEROS2;<font></font>
                                encoded[num_encoded++].count = count;<font></font>
                        }<font></font>
                        i = j;<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Output len. */</span><font></font>
                encoded[num_encoded++].sym = lens[i++];<font></font>
<font></font>
                <span class="hljs-comment">/* Scan past the end of the run of this len (max 6). */</span>
                <span class="hljs-keyword">for</span> (j = i; j &lt; min(n, i + CODELEN_COPY_MAX) &amp;&amp;<font></font>
                            lens[j] == lens[i - <span class="hljs-number">1</span>]; j++);<font></font>
                count = (<span class="hljs-keyword">uint8_t</span>)(j - i);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (count &gt;= CODELEN_COPY_MIN) {
                        <span class="hljs-comment">/* Repeat last len 3--6 times. */</span><font></font>
                        assert(count &gt;= CODELEN_COPY_MIN &amp;&amp;<font></font>
                               count &lt;= CODELEN_COPY_MAX);<font></font>
                        encoded[num_encoded].sym = CODELEN_COPY;<font></font>
                        encoded[num_encoded++].count = count;<font></font>
                        i = j;<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> num_encoded;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karakter yang digunakan untuk encoding akan direkam menggunakan kode Huffman - codelen. </font><font style="vertical-align: inherit;">Panjang kode kata dari kode kode ditulis ke blok dalam urutan tertentu sehingga panjang nol lebih mungkin berakhir di akhir. </font><font style="vertical-align: inherit;">Berikut adalah fungsi yang menghitung berapa panjang yang harus ditulis:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> codelen_lengths_order[<span class="hljs-number">19</span>] =<font></font>
{ <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">13</span>, <span class="hljs-number">2</span>, <span class="hljs-number">14</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span> };<font></font>
<font></font>
<span class="hljs-comment">/* Count the number of significant (not trailing zeros) codelen lengths. */</span>
<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">count_codelen_lens</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *codelen_lens)</span>
</span>{
        <span class="hljs-keyword">size_t</span> n = MAX_CODELEN_LENS;<font></font>
<font></font>
        <span class="hljs-comment">/* Drop trailing zero lengths. */</span>
        <span class="hljs-keyword">while</span> (codelen_lens[codelen_lengths_order[n - <span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>) {<font></font>
                n--;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* The first 4 lengths in the order (16, 17, 18, 0) cannot be used to
           encode any non-zero lengths. Since there will always be at least
           one non-zero codeword length (for EOB), n will be &gt;= 4. */</span><font></font>
        assert(n &gt;= MIN_CODELEN_LENS &amp;&amp; n &lt;= MAX_CODELEN_LENS);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> n;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan kita telah mengatur kode litlen dan dist, mengatur pengkodean panjang kata-kata kode mereka dan kode untuk panjang ini. </font><font style="vertical-align: inherit;">Sekarang kita dapat menulis blok Huffman dinamis:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_dynamic_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">final</span>,
                                <span class="hljs-keyword">size_t</span> num_litlen_lens, <span class="hljs-keyword">size_t</span> num_dist_lens,
                                <span class="hljs-keyword">size_t</span> num_codelen_lens,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *codelen_enc,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">codelen_sym_t</span> *encoded_lens,
                                <span class="hljs-keyword">size_t</span> num_encoded_lens,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *litlen_enc,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *dist_enc)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;
        <span class="hljs-keyword">uint8_t</span> codelen, sym;
        <span class="hljs-keyword">size_t</span> nbits;
        <span class="hljs-keyword">uint64_t</span> bits, hlit, hdist, hclen, count;<font></font>
<font></font>
        <span class="hljs-comment">/* Block header. */</span>
        bits = (<span class="hljs-number">0x2</span> &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-keyword">final</span>;<font></font>
        nbits = <span class="hljs-number">3</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* hlit (5 bits) */</span><font></font>
        hlit = num_litlen_lens - MIN_LITLEN_LENS;<font></font>
        bits |= hlit &lt;&lt; nbits;<font></font>
        nbits += <span class="hljs-number">5</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* hdist (5 bits) */</span><font></font>
        hdist = num_dist_lens - MIN_DIST_LENS;<font></font>
        bits |= hdist &lt;&lt; nbits;<font></font>
        nbits += <span class="hljs-number">5</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* hclen (4 bits) */</span><font></font>
        hclen = num_codelen_lens - MIN_CODELEN_LENS;<font></font>
        bits |= hclen &lt;&lt; nbits;<font></font>
        nbits += <span class="hljs-number">4</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, bits, nbits)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Codelen lengths. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_codelen_lens; i++) {<font></font>
                codelen = codelen_enc-&gt;lengths[codelen_lengths_order[i]];<font></font>
                <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, codelen, <span class="hljs-number">3</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Litlen and dist code lengths. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_encoded_lens; i++) {<font></font>
                sym = encoded_lens[i].sym;<font></font>
<font></font>
                bits = codelen_enc-&gt;codewords[sym];<font></font>
                nbits = codelen_enc-&gt;lengths[sym];<font></font>
<font></font>
                count = encoded_lens[i].count;<font></font>
                <span class="hljs-keyword">if</span> (sym == CODELEN_COPY) { <span class="hljs-comment">/* 2 ebits */</span><font></font>
                        bits |= (count - CODELEN_COPY_MIN) &lt;&lt; nbits;<font></font>
                        nbits += <span class="hljs-number">2</span>;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_ZEROS) { <span class="hljs-comment">/* 3 ebits */</span><font></font>
                        bits |= (count - CODELEN_ZEROS_MIN) &lt;&lt; nbits;<font></font>
                        nbits += <span class="hljs-number">3</span>;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_ZEROS2) { <span class="hljs-comment">/* 7 ebits */</span><font></font>
                        bits |= (count - CODELEN_ZEROS2_MIN) &lt;&lt; nbits;<font></font>
                        nbits += <span class="hljs-number">7</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, bits, nbits)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> write_huffman_block(s, litlen_enc, dist_enc);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk setiap blok, kami ingin menggunakan tipe yang membutuhkan jumlah bit paling sedikit. </font><font style="vertical-align: inherit;">Panjang blok yang tidak dikompresi dapat dihitung dengan cepat:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Calculate the number of bits for an uncompressed block, including header. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">uncomp_block_len</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">deflate_state_t</span> *s)</span>
</span>{
        <span class="hljs-keyword">size_t</span> bit_pos, padding;<font></font>
<font></font>
        <span class="hljs-comment">/* Bit position after writing the block header. */</span>
        bit_pos = ostream_bit_pos(&amp;s-&gt;os) + <span class="hljs-number">3</span>;<font></font>
        padding = round_up(bit_pos, <span class="hljs-number">8</span>) - bit_pos;<font></font>
<font></font>
        <span class="hljs-comment">/* Header + padding + len/nlen + block contents. */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> + padding + <span class="hljs-number">2</span> * <span class="hljs-number">16</span> + s-&gt;block_len_bytes * <span class="hljs-number">8</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk blok yang disandikan Huffman, Anda dapat menghitung panjang tubuh menggunakan frekuensi karakter litlen dan dist dan panjang codeword:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Calculate the number of bits for a Huffman encoded block body. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">huffman_block_body_len</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">deflate_state_t</span> *s,
                                     <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *litlen_lens,
                                     <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *dist_lens)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i, freq, len;<font></font>
<font></font>
        len = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= LITLEN_MAX; i++) {<font></font>
                freq = s-&gt;litlen_freqs[i];<font></font>
                len += litlen_lens[i] * freq;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (i &gt;= LITLEN_TBL_OFFSET) {<font></font>
                        len += litlen_tbl[i - LITLEN_TBL_OFFSET].ebits * freq;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= DISTSYM_MAX; i++) {<font></font>
                freq = s-&gt;dist_freqs[i];<font></font>
                len += dist_lens[i] * freq;<font></font>
                len += dist_tbl[i].ebits * freq;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> len;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Panjang total blok statis adalah 3 bit header plus panjang tubuh. </font><font style="vertical-align: inherit;">Menghitung ukuran header dari blok dinamis membutuhkan lebih banyak pekerjaan:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Calculate the number of bits for a dynamic Huffman block. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">dyn_block_len</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">size_t</span> num_codelen_lens,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> *codelen_freqs,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *codelen_enc,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *litlen_enc,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *dist_enc)</span>
</span>{
        <span class="hljs-keyword">size_t</span> len, i, freq;<font></font>
<font></font>
        <span class="hljs-comment">/* Block header. */</span>
        len = <span class="hljs-number">3</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* Nbr of litlen, dist, and codelen lengths. */</span>
        len += <span class="hljs-number">5</span> + <span class="hljs-number">5</span> + <span class="hljs-number">4</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* Codelen lengths. */</span>
        len += <span class="hljs-number">3</span> * num_codelen_lens;<font></font>
<font></font>
        <span class="hljs-comment">/* Codelen encoding. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_CODELEN_LENS; i++) {<font></font>
                freq = codelen_freqs[i];<font></font>
                len += codelen_enc-&gt;lengths[i] * freq;<font></font>
<font></font>
                <span class="hljs-comment">/* Extra bits. */</span>
                <span class="hljs-keyword">if</span> (i == CODELEN_COPY) {<font></font>
                        len += <span class="hljs-number">2</span> * freq;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == CODELEN_ZEROS) {<font></font>
                        len += <span class="hljs-number">3</span> * freq;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == CODELEN_ZEROS2) {<font></font>
                        len += <span class="hljs-number">7</span> * freq;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> len + huffman_block_body_len(s, litlen_enc-&gt;lengths,<font></font>
                                            dist_enc-&gt;lengths);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita akan menyatukan semuanya dan membuat fungsi utama untuk menulis blok:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Write the current deflate block, marking it final if that parameter is true,
   returning false if there is not enough room in the output stream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">final</span>)</span>
</span>{
        <span class="hljs-keyword">size_t</span> old_bit_pos, uncomp_len, static_len, dynamic_len;
        <span class="hljs-keyword">huffman_encoder_t</span> dyn_litlen_enc, dyn_dist_enc, codelen_enc;
        <span class="hljs-keyword">size_t</span> num_encoded_lens, num_litlen_lens, num_dist_lens;
        <span class="hljs-keyword">codelen_sym_t</span> encoded_lens[LITLEN_MAX + <span class="hljs-number">1</span> + DISTSYM_MAX + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">uint16_t</span> codelen_freqs[MAX_CODELEN_LENS] = {<span class="hljs-number">0</span>};
        <span class="hljs-keyword">size_t</span> num_codelen_lens;
        <span class="hljs-keyword">size_t</span> i;<font></font>
<font></font>
        old_bit_pos = ostream_bit_pos(&amp;s-&gt;os);<font></font>
<font></font>
        <span class="hljs-comment">/* Add the end-of-block marker in case we write a Huffman block. */</span>
        assert(s-&gt;block_len &lt; <span class="hljs-keyword">sizeof</span>(s-&gt;block) / <span class="hljs-keyword">sizeof</span>(s-&gt;block[<span class="hljs-number">0</span>]));<font></font>
        assert(s-&gt;litlen_freqs[LITLEN_EOB] == <span class="hljs-number">0</span>);<font></font>
        s-&gt;block[s-&gt;block_len  ].distance = <span class="hljs-number">0</span>;<font></font>
        s-&gt;block[s-&gt;block_len++].u.lit = LITLEN_EOB;<font></font>
        s-&gt;litlen_freqs[LITLEN_EOB] = <span class="hljs-number">1</span>;<font></font>
<font></font>
        uncomp_len = uncomp_block_len(s);<font></font>
<font></font>
        static_len = <span class="hljs-number">3</span> + huffman_block_body_len(s, fixed_litlen_lengths,<font></font>
                                                fixed_dist_lengths);<font></font>
<font></font>
        <span class="hljs-comment">/* Compute "dynamic" Huffman codes. */</span><font></font>
        huffman_encoder_init(&amp;dyn_litlen_enc, s-&gt;litlen_freqs,<font></font>
                             LITLEN_MAX + <span class="hljs-number">1</span>, <span class="hljs-number">15</span>);<font></font>
        huffman_encoder_init(&amp;dyn_dist_enc, s-&gt;dist_freqs, DISTSYM_MAX + <span class="hljs-number">1</span>, <span class="hljs-number">15</span>);<font></font>
<font></font>
        <span class="hljs-comment">/* Encode the litlen and dist code lengths. */</span><font></font>
        num_encoded_lens = encode_dist_litlen_lens(dyn_litlen_enc.lengths,<font></font>
                                                   dyn_dist_enc.lengths,<font></font>
                                                   encoded_lens,<font></font>
                                                   &amp;num_litlen_lens,<font></font>
                                                   &amp;num_dist_lens);<font></font>
<font></font>
        <span class="hljs-comment">/* Compute the codelen code. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_encoded_lens; i++) {<font></font>
                codelen_freqs[encoded_lens[i].sym]++;<font></font>
        }<font></font>
        huffman_encoder_init(&amp;codelen_enc, codelen_freqs, MAX_CODELEN_LENS, <span class="hljs-number">7</span>);<font></font>
        num_codelen_lens = count_codelen_lens(codelen_enc.lengths);<font></font>
<font></font>
        dynamic_len = dyn_block_len(s, num_codelen_lens, codelen_freqs,<font></font>
                                    &amp;codelen_enc, &amp;dyn_litlen_enc,<font></font>
                                    &amp;dyn_dist_enc);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (uncomp_len &lt;= dynamic_len &amp;&amp; uncomp_len &lt;= static_len) {
                <span class="hljs-keyword">if</span> (!write_uncomp_block(s, <span class="hljs-keyword">final</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                assert(ostream_bit_pos(&amp;s-&gt;os) - old_bit_pos == uncomp_len);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (static_len &lt;= dynamic_len) {
                <span class="hljs-keyword">if</span> (!write_static_block(s, <span class="hljs-keyword">final</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                assert(ostream_bit_pos(&amp;s-&gt;os) - old_bit_pos == static_len);<font></font>
        } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (!write_dynamic_block(s, <span class="hljs-keyword">final</span>, num_litlen_lens,<font></font>
                                         num_dist_lens, num_codelen_lens,<font></font>
                                         &amp;codelen_enc, encoded_lens,<font></font>
                                         num_encoded_lens, &amp;dyn_litlen_enc,<font></font>
                                         &amp;dyn_dist_enc)) {<font></font>
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                assert(ostream_bit_pos(&amp;s-&gt;os) - old_bit_pos == dynamic_len);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akhirnya, inisiator dari seluruh proses kompresi harus mengatur keadaan awal, memulai kompresi Lempel-Ziv dan menulis blok yang dihasilkan:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Compress (deflate) the data in src into dst. The number of bytes output, at
   most dst_cap, is stored in *dst_used. Returns false if there is not enough
   room in dst. src and dst must not overlap. */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hwdeflate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len, <span class="hljs-keyword">uint8_t</span> *dst,
               <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_used)</span>
</span>{
        <span class="hljs-keyword">deflate_state_t</span> s;<font></font>
<font></font>
        ostream_init(&amp;s.os, dst, dst_cap);<font></font>
        reset_block(&amp;s);<font></font>
        s.block_src = src;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!lz77_compress(src, src_len, &amp;lit_callback,<font></font>
                           &amp;backref_callback, &amp;s)) {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!write_block(&amp;s, <span class="hljs-literal">true</span>)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* The end of the final block should match the end of src. */</span><font></font>
        assert(s.block_src + s.block_len_bytes == src + src_len);<font></font>
<font></font>
        *dst_used = ostream_bytes_written(&amp;s.os);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br>
<a name="17"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Format File Zip</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di atas, kami memeriksa bagaimana kompresi Deflate yang digunakan dalam file Zip bekerja. </font><font style="vertical-align: inherit;">Bagaimana dengan format file itu sendiri? </font><font style="vertical-align: inherit;">Pada bagian ini, kita akan memeriksa secara rinci struktur dan implementasinya. </font><font style="vertical-align: inherit;">Kode ini tersedia dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zip.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zip.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="18"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambaran</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Format file dijelaskan dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan Aplikasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PKZip </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap file, atau item arsip, dalam file zip memiliki </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">header file lokal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan metadata tentang item.</font></font></li>
<li><i> </i>   .         ,      ,    ,      Zip-.</li>
<li>  ,     <i>   </i>.       ,        .     Zip-.</li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/821/bba/6ce/821bba6cede767c834da639e00d7d6ba.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap item arsip dikompresi dan disimpan secara terpisah. Ini berarti bahwa bahkan jika ada kecocokan antara file dalam arsip, mereka tidak akan diperhitungkan untuk meningkatkan kompresi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lokasi katalog pusat di bagian akhir memungkinkan Anda untuk secara bertahap melengkapi arsip. Ketika elemen file dikompresi, mereka ditambahkan ke arsip. Indeks direkam setelah semua ukuran terkompresi, yang memungkinkan Anda untuk mengetahui offset semua file. Menambahkan file ke arsip yang ada cukup mudah, ditempatkan setelah elemen terakhir, dan direktori pusat ditimpa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemampuan untuk secara bertahap membuat arsip sangat penting untuk menyebarkan informasi pada banyak disket atau volume. Saat dikompresi, PKZip menyarankan pengguna memasukkan disket baru, dan menulis direktori pusat ke yang terakhir (terakhir). Untuk membuka arsip multi-volume, PKZip pertama-tama meminta disket terakhir untuk menulis untuk membaca direktori pusat, dan kemudian sisa disket yang diperlukan untuk mengekstrak file yang diminta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini mungkin mengejutkan Anda, tetapi tidak ada aturan yang melarang memiliki banyak file dengan nama yang sama di arsip. Ini dapat menyebabkan banyak kebingungan ketika membongkar: jika ada beberapa file dengan nama yang sama, maka yang mana yang harus Anda ekstrak? Pada gilirannya, ini dapat menyebabkan masalah keamanan. Karena bug "Kunci Utama" di Android (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CVE-2013-4787</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slide</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari laporan tentang Black Hat) penyerang dapat melewati pemeriksaan sistem operasi </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">tanda tangan kriptografi</font></a><font style="vertical-align: inherit;"> saat menginstal program. Program Android didistribusikan dalam </font><font style="vertical-align: inherit;">file </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang merupakan file Zip. Ternyata, jika APK berisi beberapa file dengan nama yang sama, kode verifikasi tanda tangan memilih </font><font style="vertical-align: inherit;">file </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terakhir</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan nama yang sama, dan penginstal memilih </font><font style="vertical-align: inherit;">file </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pertama</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yaitu, verifikasi tidak dilakukan. Dengan kata lain, perbedaan kecil antara dua pustaka Zip ini memungkinkan untuk mem-bypass seluruh model keamanan sistem operasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak seperti kebanyakan format, file zip tidak boleh dimulai dengan tanda tangan atau </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angka ajaib</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Secara umum tidak ditunjukkan bahwa file Zip harus dimulai dengan cara tertentu, yang dengan mudah memungkinkan Anda membuat file yang keduanya valid sebagai Zip dan sebagai format lain - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file polyglot</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Misalnya, mengekstrak arsip Zip sendiri (misalnya, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pkz204g.exe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) biasanya merupakan file yang dapat dieksekusi dan Zip: bagian pertama dapat dieksekusi, diikuti oleh file Zip (yang dibongkar oleh bagian yang dapat dieksekusi). OS dapat menjalankannya sebagai yang dapat dieksekusi, tetapi program Zip akan membukanya sebagai file Zip. Fitur ini dapat menyebabkan Anda tidak memerlukan tanda tangan di awal file.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meskipun file polyglot tersebut cerdas, mereka dapat menyebabkan masalah keamanan karena mereka dapat menipu program yang mencoba menentukan konten file dan juga memungkinkan pengiriman kode berbahaya di tempat dengan file dari jenis yang berbeda. Misalnya, eksploitasi menggunakan </font><font style="vertical-align: inherit;">file </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GIFAR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang pada saat yang sama adalah gambar GIF yang benar dan arsip Java (JAR, sejenis file Zip). Untuk informasi lebih lanjut tentang masalah ini, lihat artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Format file yang menyalahgunakan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (mulai dari halaman 18). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang akan kita lihat di bawah, file Zip menggunakan bidang 32-bit untuk offset dan ukuran untuk membatasi ukuran arsip dan elemen-elemennya hingga empat gigabyte. Dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan Aplikasi 4.5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PKWare telah menambahkan ekstensi format yang memungkinkan penggunaan offset dan ukuran 64-bit. File yang menggunakan ekstensi ini dalam format Zip64, tetapi kami tidak akan mempertimbangkannya.</font></font><br>
<br>
<a name="19"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur data</font></font></h3><br>
<a name="20"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhir dari entri direktori pusat</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akhir entri direktori pusat (EOCDR) biasanya digunakan sebagai titik awal untuk membaca file zip. Ini berisi lokasi dan ukuran direktori pusat, serta komentar opsional tentang seluruh arsip. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam file zip yang ditempati beberapa disket - atau volume - EOCDR juga berisi informasi tentang disk mana yang saat ini kami gunakan, pada disk mana direktori pusat mulai, dll Saat ini, fungsi ini jarang digunakan, dan kode dalam artikel ini tidak memproses file seperti itu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EOCDR ditentukan oleh tanda tangan 'P' 'K', diikuti oleh byte 5 dan 6. Diikuti oleh struktur di bawah ini, angkanya disimpan sesuai dengan prinsip little-endian:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* End of Central Directory Record. */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eocdr</span> {</span>
        <span class="hljs-keyword">uint16_t</span> disk_nbr;        <span class="hljs-comment">/* Number of this disk. */</span>
        <span class="hljs-keyword">uint16_t</span> cd_start_disk;   <span class="hljs-comment">/* Nbr. of disk with start of the CD. */</span>
        <span class="hljs-keyword">uint16_t</span> disk_cd_entries; <span class="hljs-comment">/* Nbr. of CD entries on this disk. */</span>
        <span class="hljs-keyword">uint16_t</span> cd_entries;      <span class="hljs-comment">/* Nbr. of Central Directory entries. */</span>
        <span class="hljs-keyword">uint32_t</span> cd_size;         <span class="hljs-comment">/* Central Directory size in bytes. */</span>
        <span class="hljs-keyword">uint32_t</span> cd_offset;       <span class="hljs-comment">/* Central Directory file offset. */</span>
        <span class="hljs-keyword">uint16_t</span> comment_len;     <span class="hljs-comment">/* Archive comment length. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comment;   <span class="hljs-comment">/* Archive comment. */</span><font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EOCDR harus berada di akhir file. </font><font style="vertical-align: inherit;">Tetapi karena mungkin ada komentar dengan panjang 16-bit sewenang-wenang di ekornya, mungkin perlu untuk menemukan posisi tertentu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Read 16/32 bits little-endian and bump p forward afterwards. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> READ16(p) ((p) += 2, read16le((p) - 2))</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> READ32(p) ((p) += 4, read32le((p) - 4))</span><font></font>
<font></font>
<span class="hljs-comment">/* Size of the End of Central Directory Record, not including comment. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EOCDR_BASE_SZ 22</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EOCDR_SIGNATURE 0x06054b50  <span class="hljs-comment">/* "PK\5\6" little-endian. */</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">find_eocdr</span><span class="hljs-params">(struct eocdr *r, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len)</span>
</span>{
        <span class="hljs-keyword">size_t</span> comment_len;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint32_t</span> signature;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (comment_len = <span class="hljs-number">0</span>; comment_len &lt;= UINT16_MAX; comment_len++) {
                <span class="hljs-keyword">if</span> (src_len &lt; EOCDR_BASE_SZ + comment_len) {
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
<font></font>
                p = &amp;src[src_len - EOCDR_BASE_SZ - comment_len];<font></font>
                signature = READ32(p);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (signature == EOCDR_SIGNATURE) {<font></font>
                        r-&gt;disk_nbr = READ16(p);<font></font>
                        r-&gt;cd_start_disk = READ16(p);<font></font>
                        r-&gt;disk_cd_entries = READ16(p);<font></font>
                        r-&gt;cd_entries = READ16(p);<font></font>
                        r-&gt;cd_size = READ32(p);<font></font>
                        r-&gt;cd_offset = READ32(p);<font></font>
                        r-&gt;comment_len = READ16(p);<font></font>
                        r-&gt;comment = p;<font></font>
                        assert(p == &amp;src[src_len - comment_len] &amp;&amp;<font></font>
                               <span class="hljs-string">"All fields read."</span>);<font></font>
<font></font>
                        <span class="hljs-keyword">if</span> (r-&gt;comment_len == comment_len) {
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
                        }<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Merekam EOCDR itu mudah. </font><font style="vertical-align: inherit;">Fungsi ini menulis dan mengembalikan jumlah byte yang ditulis:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Write 16/32 bits little-endian and bump p forward afterwards. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WRITE16(p, x) (write16le((p), (x)), (p) += 2)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WRITE32(p, x) (write32le((p), (x)), (p) += 4)</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">write_eocdr</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">const</span> struct eocdr *r)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p = dst;<font></font>
<font></font>
        WRITE32(p, EOCDR_SIGNATURE);<font></font>
        WRITE16(p, r-&gt;disk_nbr);<font></font>
        WRITE16(p, r-&gt;cd_start_disk);<font></font>
        WRITE16(p, r-&gt;disk_cd_entries);<font></font>
        WRITE16(p, r-&gt;cd_entries);<font></font>
        WRITE32(p, r-&gt;cd_size);<font></font>
        WRITE32(p, r-&gt;cd_offset);<font></font>
        WRITE16(p, r-&gt;comment_len);<font></font>
        assert(p - dst == EOCDR_BASE_SZ);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (r-&gt;comment_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, r-&gt;comment, r-&gt;comment_len);<font></font>
                p += r-&gt;comment_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">size_t</span>)(p - dst);<font></font>
}<font></font>
</code></pre><br>
<a name="21"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Header file pusat</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Direktori pusat terdiri dari header file pusat yang ditulis satu demi satu, satu untuk setiap item arsip. </font><font style="vertical-align: inherit;">Setiap pos dimulai dengan tanda tangan 'P', 'K', 1, 2, dan kemudian ada struktur seperti itu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXT_ATTR_DIR (1U &lt;&lt; 4)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXT_ATTR_ARC (1U &lt;&lt; 5)</span><font></font>
<font></font>
<span class="hljs-comment">/* Central File Header (Central Directory Entry) */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfh</span> {</span>
        <span class="hljs-keyword">uint16_t</span> made_by_ver;    <span class="hljs-comment">/* Version made by. */</span>
        <span class="hljs-keyword">uint16_t</span> extract_ver;    <span class="hljs-comment">/* Version needed to extract. */</span>
        <span class="hljs-keyword">uint16_t</span> gp_flag;        <span class="hljs-comment">/* General purpose bit flag. */</span>
        <span class="hljs-keyword">uint16_t</span> method;         <span class="hljs-comment">/* Compression method. */</span>
        <span class="hljs-keyword">uint16_t</span> mod_time;       <span class="hljs-comment">/* Modification time. */</span>
        <span class="hljs-keyword">uint16_t</span> mod_date;       <span class="hljs-comment">/* Modification date. */</span>
        <span class="hljs-keyword">uint32_t</span> crc32;          <span class="hljs-comment">/* CRC-32 checksum. */</span>
        <span class="hljs-keyword">uint32_t</span> comp_size;      <span class="hljs-comment">/* Compressed size. */</span>
        <span class="hljs-keyword">uint32_t</span> uncomp_size;    <span class="hljs-comment">/* Uncompressed size. */</span>
        <span class="hljs-keyword">uint16_t</span> name_len;       <span class="hljs-comment">/* Filename length. */</span>
        <span class="hljs-keyword">uint16_t</span> extra_len;      <span class="hljs-comment">/* Extra data length. */</span>
        <span class="hljs-keyword">uint16_t</span> comment_len;    <span class="hljs-comment">/* Comment length. */</span>
        <span class="hljs-keyword">uint16_t</span> disk_nbr_start; <span class="hljs-comment">/* Disk nbr. where file begins. */</span>
        <span class="hljs-keyword">uint16_t</span> int_attrs;      <span class="hljs-comment">/* Internal file attributes. */</span>
        <span class="hljs-keyword">uint32_t</span> ext_attrs;      <span class="hljs-comment">/* External file attributes. */</span>
        <span class="hljs-keyword">uint32_t</span> lfh_offset;     <span class="hljs-comment">/* Local File Header offset. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *name;     <span class="hljs-comment">/* Filename. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *extra;    <span class="hljs-comment">/* Extra data. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comment;  <span class="hljs-comment">/* File comment. */</span><font></font>
};<font></font>
</code></pre><br>
<code>made_by_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>extract_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyandikan informasi tentang OS dan versi program yang digunakan untuk menambahkan item ini, serta versi mana yang diperlukan untuk mengambilnya. </font><font style="vertical-align: inherit;">Delapan bit paling penting menyandikan sistem operasi (misalnya, 0 berarti DOS, 3 berarti Unix, 10 berarti Windows NTFS), dan delapan bit yang lebih rendah menyandikan versi perangkat lunak. </font><font style="vertical-align: inherit;">Tetapkan nilai desimal ke 20, yang berarti kompatibilitas dengan PKZip 2.0. </font></font><br>
<br>
<code>gp_flag</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengandung berbagai flag. </font><font style="vertical-align: inherit;">Kami tertarik:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 0, menunjukkan fakta enkripsi elemen (kami tidak akan mempertimbangkan ini);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan bit 1 dan 2, mengkode tingkat kompresi Deflate (0 - normal, 1 - maksimum, 2 - cepat, 3 - sangat cepat).</font></font></li>
</ul><br>
<code>method</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengkodekan metode kompresi. 0 - data tidak dikompresi, 8 - Delate diterapkan. Nilai-nilai lain berhubungan dengan algoritma lama atau baru, tetapi hampir semua Zip menggunakan kedua nilai ini. </font></font><br>
<br>
<code>mod_time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>mod_date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi tanggal dan waktu file diubah, disandikan dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">format MS-DOS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dengan menggunakan kode ini, kami akan mengonversi cap waktu C biasa </font></font><code>time_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke dan dari format MS-DOS:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Convert DOS date and time to time_t. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">time_t</span> <span class="hljs-title">dos2ctime</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> dos_date, <span class="hljs-keyword">uint16_t</span> dos_time)</span>
</span>{
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> <span class="hljs-title">tm</span> = {</span><span class="hljs-number">0</span>};<font></font>
<font></font>
        tm.tm_sec = (dos_time &amp; <span class="hljs-number">0x1f</span>) * <span class="hljs-number">2</span>;  <span class="hljs-comment">/* Bits 0--4:  Secs divided by 2. */</span>
        tm.tm_min = (dos_time &gt;&gt; <span class="hljs-number">5</span>) &amp; <span class="hljs-number">0x3f</span>; <span class="hljs-comment">/* Bits 5--10: Minute. */</span>
        tm.tm_hour = (dos_time &gt;&gt; <span class="hljs-number">11</span>);      <span class="hljs-comment">/* Bits 11-15: Hour (0--23). */</span><font></font>
<font></font>
        tm.tm_mday = (dos_date &amp; <span class="hljs-number">0x1f</span>);          <span class="hljs-comment">/* Bits 0--4: Day (1--31). */</span>
        tm.tm_mon = ((dos_date &gt;&gt; <span class="hljs-number">5</span>) &amp; <span class="hljs-number">0xf</span>) - <span class="hljs-number">1</span>; <span class="hljs-comment">/* Bits 5--8: Month (1--12). */</span>
        tm.tm_year = (dos_date &gt;&gt; <span class="hljs-number">9</span>) + <span class="hljs-number">80</span>;       <span class="hljs-comment">/* Bits 9--15: Year-1980. */</span><font></font>
<font></font>
        tm.tm_isdst = <span class="hljs-number">-1</span>;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> mktime(&amp;tm);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Convert time_t to DOS date and time. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ctime2dos</span><span class="hljs-params">(<span class="hljs-keyword">time_t</span> t, <span class="hljs-keyword">uint16_t</span> *dos_date, <span class="hljs-keyword">uint16_t</span> *dos_time)</span>
</span>{
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">tm</span> = <span class="hljs-title">localtime</span>(&amp;<span class="hljs-title">t</span>);</span><font></font>
<font></font>
        *dos_time = <span class="hljs-number">0</span>;<font></font>
        *dos_time |= tm-&gt;tm_sec / <span class="hljs-number">2</span>;    <span class="hljs-comment">/* Bits 0--4:  Second divided by two. */</span>
        *dos_time |= tm-&gt;tm_min &lt;&lt; <span class="hljs-number">5</span>;   <span class="hljs-comment">/* Bits 5--10: Minute. */</span>
        *dos_time |= tm-&gt;tm_hour &lt;&lt; <span class="hljs-number">11</span>; <span class="hljs-comment">/* Bits 11-15: Hour. */</span><font></font>
<font></font>
        *dos_date = <span class="hljs-number">0</span>;<font></font>
        *dos_date |= tm-&gt;tm_mday;             <span class="hljs-comment">/* Bits 0--4:  Day (1--31). */</span>
        *dos_date |= (tm-&gt;tm_mon + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">5</span>;   <span class="hljs-comment">/* Bits 5--8:  Month (1--12). */</span>
        *dos_date |= (tm-&gt;tm_year - <span class="hljs-number">80</span>) &lt;&lt; <span class="hljs-number">9</span>; <span class="hljs-comment">/* Bits 9--15: Year from 1980. */</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bidang ini </font></font><code>crc32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai kode redundan siklik dari</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> data yang tidak terkompresi. Ini digunakan untuk memverifikasi integritas data setelah pengambilan. Implementasi di sini: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crc32.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<code>comp_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>uncomp_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi ukuran terkompresi dan tidak terkompresi dari data file item. Tiga bidang berikut ini berisi panjang nama, komentar, dan data tambahan segera setelah judul. </font></font><code>disk_nbr_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dirancang untuk arsip menggunakan banyak disket. </font></font><br>
<br>
<code>int_attrs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>ext_attrs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menjelaskan atribut internal dan eksternal file. Yang internal berkaitan dengan isi file, misalnya, bit paling signifikan menunjukkan apakah file hanya berisi teks. Atribut eksternal menunjukkan apakah file disembunyikan, hanya-baca, dll. Isi bidang ini tergantung pada OS, khususnya, pada</font></font><code>made_by_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dalam DOS, 8 bit yang lebih rendah berisi byte atribut file, yang dapat diperoleh dari panggilan sistem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Int 21 / AX = 4300h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sebagai contoh, bit 4 berarti bahwa itu adalah direktori, dan bit 5 berarti bahwa atribut "arsip" diatur (berlaku untuk sebagian besar file di DOS). Sejauh yang saya mengerti, demi kompatibilitas, bit ini juga diatur di OS lain. Pada Unix, 16 bit tinggi dari bidang ini berisi bit mode file yang dikembalikan oleh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stat (2)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di </font></font><code>st_mode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<code>lfh_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memberi tahu kami di mana mencari header file lokal. </font></font><code>name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- nama file (C-line), dan </font></font><code>comment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- komentar opsional untuk elemen arsip ini (C-line). </font></font><code>extra</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat berisi data tambahan opsional seperti informasi tentang pemilik file Unix, tanggal dan waktu perubahan yang lebih akurat, atau bidang Zip64.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi ini digunakan untuk membaca tajuk pusat file:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Size of a Central File Header, not including name, extra, and comment. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CFH_BASE_SZ 46</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CFH_SIGNATURE 0x02014b50 <span class="hljs-comment">/* "PK\1\2" little-endian. */</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">read_cfh</span><span class="hljs-params">(struct cfh *cfh, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len,
                     <span class="hljs-keyword">size_t</span> offset)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint32_t</span> signature;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (offset &gt; src_len || src_len - offset &lt; CFH_BASE_SZ) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        p = &amp;src[offset];<font></font>
        signature = READ32(p);<font></font>
        <span class="hljs-keyword">if</span> (signature != CFH_SIGNATURE) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        cfh-&gt;made_by_ver = READ16(p);<font></font>
        cfh-&gt;extract_ver = READ16(p);<font></font>
        cfh-&gt;gp_flag = READ16(p);<font></font>
        cfh-&gt;method = READ16(p);<font></font>
        cfh-&gt;mod_time = READ16(p);<font></font>
        cfh-&gt;mod_date = READ16(p);<font></font>
        cfh-&gt;crc32 = READ32(p);<font></font>
        cfh-&gt;comp_size = READ32(p);<font></font>
        cfh-&gt;uncomp_size = READ32(p);<font></font>
        cfh-&gt;name_len = READ16(p);<font></font>
        cfh-&gt;extra_len = READ16(p);<font></font>
        cfh-&gt;comment_len = READ16(p);<font></font>
        cfh-&gt;disk_nbr_start = READ16(p);<font></font>
        cfh-&gt;int_attrs = READ16(p);<font></font>
        cfh-&gt;ext_attrs = READ32(p);<font></font>
        cfh-&gt;lfh_offset = READ32(p);<font></font>
        cfh-&gt;name = p;<font></font>
        cfh-&gt;extra = cfh-&gt;name + cfh-&gt;name_len;<font></font>
        cfh-&gt;comment = cfh-&gt;extra + cfh-&gt;extra_len;<font></font>
        assert(p == &amp;src[offset + CFH_BASE_SZ] &amp;&amp; <span class="hljs-string">"All fields read."</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (src_len - offset - CFH_BASE_SZ &lt;<font></font>
            cfh-&gt;name_len + cfh-&gt;extra_len + cfh-&gt;comment_len) {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">write_cfh</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">const</span> struct cfh *cfh)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p = dst;<font></font>
<font></font>
        WRITE32(p, CFH_SIGNATURE);<font></font>
        WRITE16(p, cfh-&gt;made_by_ver);<font></font>
        WRITE16(p, cfh-&gt;extract_ver);<font></font>
        WRITE16(p, cfh-&gt;gp_flag);<font></font>
        WRITE16(p, cfh-&gt;method);<font></font>
        WRITE16(p, cfh-&gt;mod_time);<font></font>
        WRITE16(p, cfh-&gt;mod_date);<font></font>
        WRITE32(p, cfh-&gt;crc32);<font></font>
        WRITE32(p, cfh-&gt;comp_size);<font></font>
        WRITE32(p, cfh-&gt;uncomp_size);<font></font>
        WRITE16(p, cfh-&gt;name_len);<font></font>
        WRITE16(p, cfh-&gt;extra_len);<font></font>
        WRITE16(p, cfh-&gt;comment_len);<font></font>
        WRITE16(p, cfh-&gt;disk_nbr_start);<font></font>
        WRITE16(p, cfh-&gt;int_attrs);<font></font>
        WRITE32(p, cfh-&gt;ext_attrs);<font></font>
        WRITE32(p, cfh-&gt;lfh_offset);<font></font>
        assert(p - dst == CFH_BASE_SZ);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (cfh-&gt;name_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, cfh-&gt;name, cfh-&gt;name_len);<font></font>
                p += cfh-&gt;name_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (cfh-&gt;extra_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, cfh-&gt;extra, cfh-&gt;extra_len);<font></font>
                p += cfh-&gt;extra_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (cfh-&gt;comment_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, cfh-&gt;comment, cfh-&gt;comment_len);<font></font>
                p += cfh-&gt;comment_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">size_t</span>)(p - dst);<font></font>
}<font></font>
</code></pre><br>
<a name="22"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Header file lokal</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Data dari setiap elemen arsip didahului oleh tajuk file lokal, yang mengulang sebagian besar informasi dari tajuk pusat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Duplikasi data di header pusat dan lokal mungkin diperkenalkan sehingga PKZip tidak akan menyimpan seluruh direktori pusat dalam memori saat membongkar. Sebaliknya, karena setiap file diekstraksi, nama dan informasi lainnya dapat dibaca dari header lokal. Selain itu, tajuk lokal berguna untuk memulihkan file dari arsip Zip di mana direktori pusat hilang atau rusak. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, redundansi ini juga merupakan sumber utama ketidakpastian. Misalnya, apa yang terjadi jika nama file di header pusat dan lokal tidak cocok? Ini sering mengarah pada masalah bug dan keamanan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak semua informasi dari pos pusat digandakan. </font><font style="vertical-align: inherit;">Misalnya, bidang dengan atribut file. </font><font style="vertical-align: inherit;">Selain itu, jika bit paling signifikan ketiga </font></font><code>gp_flags</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(CRC-32) diatur, maka bidang terkompresi dan tidak terkompresi akan diatur ulang ke nol, dan informasi ini dapat ditemukan di blok </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data Descriptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> setelah data file itu sendiri (kami tidak akan mempertimbangkannya). </font><font style="vertical-align: inherit;">Ini memungkinkan Anda merekam tajuk lokal sebelum ukuran file elemen diketahui atau ukuran apa yang akan dikompres. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Header lokal dimulai dengan tanda tangan 'P', 'K', 3, 4, dan kemudian ada struktur seperti itu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Local File Header. */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lfh</span> {</span>
        <span class="hljs-keyword">uint16_t</span> extract_ver;
        <span class="hljs-keyword">uint16_t</span> gp_flag;
        <span class="hljs-keyword">uint16_t</span> method;
        <span class="hljs-keyword">uint16_t</span> mod_time;
        <span class="hljs-keyword">uint16_t</span> mod_date;
        <span class="hljs-keyword">uint32_t</span> crc32;
        <span class="hljs-keyword">uint32_t</span> comp_size;
        <span class="hljs-keyword">uint32_t</span> uncomp_size;
        <span class="hljs-keyword">uint16_t</span> name_len;
        <span class="hljs-keyword">uint16_t</span> extra_len;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *name;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *extra;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi-fungsi ini membaca dan menulis header lokal, seperti struktur data lainnya:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Size of a Local File Header, not including name and extra. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LFH_BASE_SZ 30</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LFH_SIGNATURE 0x04034b50 <span class="hljs-comment">/* "PK\3\4" little-endian. */</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">read_lfh</span><span class="hljs-params">(struct lfh *lfh, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len,
                     <span class="hljs-keyword">size_t</span> offset)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint32_t</span> signature;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (offset &gt; src_len || src_len - offset &lt; LFH_BASE_SZ) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        p = &amp;src[offset];<font></font>
        signature = READ32(p);<font></font>
        <span class="hljs-keyword">if</span> (signature != LFH_SIGNATURE) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        lfh-&gt;extract_ver = READ16(p);<font></font>
        lfh-&gt;gp_flag = READ16(p);<font></font>
        lfh-&gt;method = READ16(p);<font></font>
        lfh-&gt;mod_time = READ16(p);<font></font>
        lfh-&gt;mod_date = READ16(p);<font></font>
        lfh-&gt;crc32 = READ32(p);<font></font>
        lfh-&gt;comp_size = READ32(p);<font></font>
        lfh-&gt;uncomp_size = READ32(p);<font></font>
        lfh-&gt;name_len = READ16(p);<font></font>
        lfh-&gt;extra_len = READ16(p);<font></font>
        lfh-&gt;name = p;<font></font>
        lfh-&gt;extra = lfh-&gt;name + lfh-&gt;name_len;<font></font>
        assert(p == &amp;src[offset + LFH_BASE_SZ] &amp;&amp; <span class="hljs-string">"All fields read."</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (src_len - offset - LFH_BASE_SZ &lt; lfh-&gt;name_len + lfh-&gt;extra_len) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">write_lfh</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">const</span> struct lfh *lfh)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p = dst;<font></font>
<font></font>
        WRITE32(p, LFH_SIGNATURE);<font></font>
        WRITE16(p, lfh-&gt;extract_ver);<font></font>
        WRITE16(p, lfh-&gt;gp_flag);<font></font>
        WRITE16(p, lfh-&gt;method);<font></font>
        WRITE16(p, lfh-&gt;mod_time);<font></font>
        WRITE16(p, lfh-&gt;mod_date);<font></font>
        WRITE32(p, lfh-&gt;crc32);<font></font>
        WRITE32(p, lfh-&gt;comp_size);<font></font>
        WRITE32(p, lfh-&gt;uncomp_size);<font></font>
        WRITE16(p, lfh-&gt;name_len);<font></font>
        WRITE16(p, lfh-&gt;extra_len);<font></font>
        assert(p - dst == LFH_BASE_SZ);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (lfh-&gt;name_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, lfh-&gt;name, lfh-&gt;name_len);<font></font>
                p += lfh-&gt;name_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (lfh-&gt;extra_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, lfh-&gt;extra, lfh-&gt;extra_len);<font></font>
                p += lfh-&gt;extra_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">size_t</span>)(p - dst);<font></font>
}<font></font>
</code></pre><br>
<a name="23"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penerapan Zip Read</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan menggunakan fungsi-fungsi di atas, kami menerapkan pembacaan file Zip ke dalam memori dan mendapatkan iterator untuk mengakses elemen arsip:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">size_t</span> <span class="hljs-keyword">zipiter_t</span>; <span class="hljs-comment">/* Zip archive member iterator. */</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zip_t</span> <span class="hljs-title">zip_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zip_t</span> {</span>
        <span class="hljs-keyword">uint16_t</span> num_members;    <span class="hljs-comment">/* Number of members. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comment;  <span class="hljs-comment">/* Zip file comment (not terminated). */</span>
        <span class="hljs-keyword">uint16_t</span> comment_len;    <span class="hljs-comment">/* Zip file comment length. */</span>
        <span class="hljs-keyword">zipiter_t</span> members_begin; <span class="hljs-comment">/* Iterator to the first member. */</span>
        <span class="hljs-keyword">zipiter_t</span> members_end;   <span class="hljs-comment">/* Iterator to the end of members. */</span><font></font>
<font></font>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src;
        <span class="hljs-keyword">size_t</span> src_len;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Initialize zip based on the source data. Returns true on success, or false
   if the data could not be parsed as a valid Zip file. */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">zip_read</span><span class="hljs-params">(<span class="hljs-keyword">zip_t</span> *zip, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len)</span>
</span>{
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eocdr</span> <span class="hljs-title">eocdr</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfh</span> <span class="hljs-title">cfh</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lfh</span> <span class="hljs-title">lfh</span>;</span>
        <span class="hljs-keyword">size_t</span> i, offset;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comp_data;<font></font>
<font></font>
        zip-&gt;src = src;<font></font>
        zip-&gt;src_len = src_len;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!find_eocdr(&amp;eocdr, src, src_len)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (eocdr.disk_nbr != <span class="hljs-number">0</span> || eocdr.cd_start_disk != <span class="hljs-number">0</span> ||<font></font>
            eocdr.disk_cd_entries != eocdr.cd_entries) {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Cannot handle multi-volume archives. */</span><font></font>
        }<font></font>
<font></font>
        zip-&gt;num_members = eocdr.cd_entries;<font></font>
        zip-&gt;comment = eocdr.comment;<font></font>
        zip-&gt;comment_len = eocdr.comment_len;<font></font>
<font></font>
        offset = eocdr.cd_offset;<font></font>
        zip-&gt;members_begin = offset;<font></font>
<font></font>
        <span class="hljs-comment">/* Read the member info and do a few checks. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; eocdr.cd_entries; i++) {
                <span class="hljs-keyword">if</span> (!read_cfh(&amp;cfh, src, src_len, offset)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (cfh.gp_flag &amp; <span class="hljs-number">1</span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* The member is encrypted. */</span><font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (cfh.method != ZIP_STORED &amp;&amp; cfh.method != ZIP_DEFLATED) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Unsupported compression method. */</span><font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (cfh.method == ZIP_STORED &amp;&amp;<font></font>
                    cfh.uncomp_size != cfh.comp_size) {<font></font>
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (cfh.disk_nbr_start != <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Cannot handle multi-volume archives. */</span><font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memchr</span>(cfh.name, <span class="hljs-string">'\0'</span>, cfh.name_len) != <span class="hljs-literal">NULL</span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Bad filename. */</span><font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (!read_lfh(&amp;lfh, src, src_len, cfh.lfh_offset)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
<font></font>
                comp_data = lfh.extra + lfh.extra_len;<font></font>
                <span class="hljs-keyword">if</span> (cfh.comp_size &gt; src_len - (<span class="hljs-keyword">size_t</span>)(comp_data - src)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Member data does not fit in src. */</span><font></font>
                }<font></font>
<font></font>
                offset += CFH_BASE_SZ + cfh.name_len + cfh.extra_len +<font></font>
                          cfh.comment_len;<font></font>
        }<font></font>
<font></font>
        zip-&gt;members_end = offset;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang saya sebutkan di atas, elemen iterator hanyalah offset ke header file pusat di mana Anda dapat mengakses data elemen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> { ZIP_STORED = <span class="hljs-number">0</span>, ZIP_DEFLATED = <span class="hljs-number">8</span> } <span class="hljs-keyword">method_t</span>;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zipmemb_t</span> <span class="hljs-title">zipmemb_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zipmemb_t</span> {</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *name;      <span class="hljs-comment">/* Member name (not null terminated). */</span>
        <span class="hljs-keyword">uint16_t</span> name_len;        <span class="hljs-comment">/* Member name length. */</span>
        <span class="hljs-keyword">time_t</span> mtime;             <span class="hljs-comment">/* Modification time. */</span>
        <span class="hljs-keyword">uint32_t</span> comp_size;       <span class="hljs-comment">/* Compressed size. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comp_data; <span class="hljs-comment">/* Compressed data. */</span>
        <span class="hljs-keyword">method_t</span> method;          <span class="hljs-comment">/* Compression method. */</span>
        <span class="hljs-keyword">uint32_t</span> uncomp_size;     <span class="hljs-comment">/* Uncompressed size. */</span>
        <span class="hljs-keyword">uint32_t</span> crc32;           <span class="hljs-comment">/* CRC-32 checksum. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comment;   <span class="hljs-comment">/* Comment (not null terminated). */</span>
        <span class="hljs-keyword">uint16_t</span> comment_len;     <span class="hljs-comment">/* Comment length. */</span>
        <span class="hljs-keyword">bool</span> is_dir;              <span class="hljs-comment">/* Whether this is a directory. */</span>
        <span class="hljs-keyword">zipiter_t</span> next;           <span class="hljs-comment">/* Iterator to the next member. */</span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Get the Zip archive member through iterator it. */</span>
<span class="hljs-function"><span class="hljs-keyword">zipmemb_t</span> <span class="hljs-title">zip_member</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">zip_t</span> *zip, <span class="hljs-keyword">zipiter_t</span> it)</span>
</span>{
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfh</span> <span class="hljs-title">cfh</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lfh</span> <span class="hljs-title">lfh</span>;</span>
        <span class="hljs-keyword">bool</span> ok;
        <span class="hljs-keyword">zipmemb_t</span> m;<font></font>
<font></font>
        assert(it &gt;= zip-&gt;members_begin &amp;&amp; it &lt; zip-&gt;members_end);<font></font>
<font></font>
        ok = read_cfh(&amp;cfh, zip-&gt;src, zip-&gt;src_len, it);<font></font>
        assert(ok);<font></font>
<font></font>
        ok = read_lfh(&amp;lfh, zip-&gt;src, zip-&gt;src_len, cfh.lfh_offset);<font></font>
        assert(ok);<font></font>
<font></font>
        m.name = cfh.name;<font></font>
        m.name_len = cfh.name_len;<font></font>
        m.mtime = dos2ctime(cfh.mod_date, cfh.mod_time);<font></font>
        m.comp_size = cfh.comp_size;<font></font>
        m.comp_data = lfh.extra + lfh.extra_len;<font></font>
        m.method = cfh.method;<font></font>
        m.uncomp_size = cfh.uncomp_size;<font></font>
        m.crc32 = cfh.crc32;<font></font>
        m.comment = cfh.comment;<font></font>
        m.comment_len = cfh.comment_len;<font></font>
        m.is_dir = (cfh.ext_attrs &amp; EXT_ATTR_DIR) != <span class="hljs-number">0</span>;<font></font>
<font></font>
        m.next = it + CFH_BASE_SZ +<font></font>
                 cfh.name_len + cfh.extra_len + cfh.comment_len;<font></font>
<font></font>
        assert(m.next &lt;= zip-&gt;members_end);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> m;<font></font>
}<font></font>
</code></pre><br>
<a name="24"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi Catatan Zip</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menulis file zip ke buffer memori, pertama-tama Anda perlu mengetahui berapa banyak memori yang dialokasikan untuk itu. </font><font style="vertical-align: inherit;">Dan karena kita tidak tahu berapa banyak data yang akan kita kompres sebelum kita mencoba menulis, kita akan menghitung batas atas berdasarkan ukuran elemen yang tidak terkompresi:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Compute an upper bound on the dst size required by zip_write() for an
 * archive with num_memb members with certain filenames, sizes, and archive
 * comment. Returns zero on error, e.g. if a filename is longer than 2^16-1, or
 * if the total file size is larger than 2^32-1. */</span>
<span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">zip_max_size</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> num_memb, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *filenames,
                      <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *file_sizes, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *comment)</span>
</span>{
        <span class="hljs-keyword">size_t</span> comment_len, name_len;
        <span class="hljs-keyword">uint64_t</span> total;
        <span class="hljs-keyword">uint16_t</span> i;<font></font>
<font></font>
        comment_len = (comment == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : <span class="hljs-built_in">strlen</span>(comment));
        <span class="hljs-keyword">if</span> (comment_len &gt; UINT16_MAX) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        total = EOCDR_BASE_SZ + comment_len; <span class="hljs-comment">/* EOCDR */</span><font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_memb; i++) {<font></font>
                assert(filenames[i] != <span class="hljs-literal">NULL</span>);<font></font>
                name_len = <span class="hljs-built_in">strlen</span>(filenames[i]);
                <span class="hljs-keyword">if</span> (name_len &gt; UINT16_MAX) {
                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
                }<font></font>
<font></font>
                total += CFH_BASE_SZ + name_len; <span class="hljs-comment">/* Central File Header */</span>
                total += LFH_BASE_SZ + name_len; <span class="hljs-comment">/* Local File Header */</span>
                total += file_sizes[i];          <span class="hljs-comment">/* Uncompressed data size. */</span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (total &gt; UINT32_MAX) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">uint32_t</span>)total;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode ini menulis file zip menggunakan kompresi mengempis dari setiap elemen, mengurangi ukurannya:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Write a Zip file containing num_memb members into dst, which must be large
   enough to hold the resulting data. Returns the number of bytes written, which
   is guaranteed to be less than or equal to the result of zip_max_size() when
   called with the corresponding arguments. comment shall be a null-terminated
   string or null. callback shall be null or point to a function which will
   get called after the compression of each member. */</span>
<span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">zip_write</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">uint16_t</span> num_memb,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *filenames,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-keyword">const</span> *file_data,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *file_sizes,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">time_t</span> *mtimes,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *comment,
                   <span class="hljs-keyword">void</span> (*callback)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">uint32_t</span> size,
                                    <span class="hljs-keyword">uint32_t</span> comp_size))</span>
</span>{
        <span class="hljs-keyword">uint16_t</span> i;
        <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eocdr</span> <span class="hljs-title">eocdr</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfh</span> <span class="hljs-title">cfh</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lfh</span> <span class="hljs-title">lfh</span>;</span>
        <span class="hljs-keyword">bool</span> ok;
        <span class="hljs-keyword">uint16_t</span> name_len;
        <span class="hljs-keyword">uint8_t</span> *data_dst;
        <span class="hljs-keyword">size_t</span> comp_sz;
        <span class="hljs-keyword">uint32_t</span> lfh_offset, cd_offset, eocdr_offset;<font></font>
<font></font>
        p = dst;<font></font>
<font></font>
        <span class="hljs-comment">/* Write Local File Headers and deflated or stored data. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_memb; i++) {<font></font>
                assert(filenames[i] != <span class="hljs-literal">NULL</span>);<font></font>
                assert(<span class="hljs-built_in">strlen</span>(filenames[i]) &lt;= UINT16_MAX);<font></font>
                name_len = (<span class="hljs-keyword">uint16_t</span>)<span class="hljs-built_in">strlen</span>(filenames[i]);<font></font>
<font></font>
                data_dst = p + LFH_BASE_SZ + name_len;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (hwdeflate(file_data[i], file_sizes[i], data_dst,<font></font>
                              file_sizes[i], &amp;comp_sz) &amp;&amp;<font></font>
                                comp_sz &lt; file_sizes[i]) {<font></font>
                        lfh.method = ZIP_DEFLATED;<font></font>
                        assert(comp_sz &lt;= UINT32_MAX);<font></font>
                        lfh.comp_size = (<span class="hljs-keyword">uint32_t</span>)comp_sz;<font></font>
                } <span class="hljs-keyword">else</span> {
                        <span class="hljs-built_in">memcpy</span>(data_dst, file_data[i], file_sizes[i]);<font></font>
                        lfh.method = ZIP_STORED;<font></font>
                        lfh.comp_size = file_sizes[i];<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (callback != <span class="hljs-literal">NULL</span>) {<font></font>
                        callback(filenames[i], file_sizes[i], lfh.comp_size);<font></font>
                }<font></font>
<font></font>
                lfh.extract_ver = (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">8</span>) | <span class="hljs-number">20</span>; <span class="hljs-comment">/* DOS | PKZIP 2.0 */</span>
                lfh.gp_flag = (lfh.method == ZIP_DEFLATED ? (<span class="hljs-number">0x1</span> &lt;&lt; <span class="hljs-number">1</span>) : <span class="hljs-number">0x0</span>);<font></font>
                ctime2dos(mtimes[i], &amp;lfh.mod_date, &amp;lfh.mod_time);<font></font>
                lfh.crc32 = crc32(file_data[i], file_sizes[i]);<font></font>
                lfh.uncomp_size = file_sizes[i];<font></font>
                lfh.name_len = name_len;<font></font>
                lfh.extra_len = <span class="hljs-number">0</span>;<font></font>
                lfh.name = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>*)filenames[i];<font></font>
                p += write_lfh(p, &amp;lfh);<font></font>
                p += lfh.comp_size;<font></font>
        }<font></font>
<font></font>
        assert(p - dst &lt;= UINT32_MAX);<font></font>
        cd_offset = (<span class="hljs-keyword">uint32_t</span>)(p - dst);<font></font>
<font></font>
        <span class="hljs-comment">/* Write the Central Directory based on the Local File Headers. */</span>
        lfh_offset = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_memb; i++) {<font></font>
                ok = read_lfh(&amp;lfh, dst, SIZE_MAX, lfh_offset);<font></font>
                assert(ok);<font></font>
<font></font>
                cfh.made_by_ver = lfh.extract_ver;<font></font>
                cfh.extract_ver = lfh.extract_ver;<font></font>
                cfh.gp_flag = lfh.gp_flag;<font></font>
                cfh.method = lfh.method;<font></font>
                cfh.mod_time = lfh.mod_time;<font></font>
                cfh.mod_date = lfh.mod_date;<font></font>
                cfh.crc32 = lfh.crc32;<font></font>
                cfh.comp_size = lfh.comp_size;<font></font>
                cfh.uncomp_size = lfh.uncomp_size;<font></font>
                cfh.name_len = lfh.name_len;<font></font>
                cfh.extra_len = <span class="hljs-number">0</span>;<font></font>
                cfh.comment_len = <span class="hljs-number">0</span>;<font></font>
                cfh.disk_nbr_start = <span class="hljs-number">0</span>;<font></font>
                cfh.int_attrs = <span class="hljs-number">0</span>;<font></font>
                cfh.ext_attrs = EXT_ATTR_ARC;<font></font>
                cfh.lfh_offset = lfh_offset;<font></font>
                cfh.name = lfh.name;<font></font>
                p += write_cfh(p, &amp;cfh);<font></font>
<font></font>
                lfh_offset += LFH_BASE_SZ + lfh.name_len + lfh.comp_size;<font></font>
        }<font></font>
<font></font>
        assert(p - dst &lt;= UINT32_MAX);<font></font>
        eocdr_offset = (<span class="hljs-keyword">uint32_t</span>)(p - dst);<font></font>
<font></font>
        <span class="hljs-comment">/* Write the End of Central Directory Record. */</span>
        eocdr.disk_nbr = <span class="hljs-number">0</span>;<font></font>
        eocdr.cd_start_disk = <span class="hljs-number">0</span>;<font></font>
        eocdr.disk_cd_entries = num_memb;<font></font>
        eocdr.cd_entries = num_memb;<font></font>
        eocdr.cd_size = eocdr_offset - cd_offset;<font></font>
        eocdr.cd_offset = cd_offset;<font></font>
        eocdr.comment_len = (<span class="hljs-keyword">uint16_t</span>)(comment == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : <span class="hljs-built_in">strlen</span>(comment));<font></font>
        eocdr.comment = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>*)comment;<font></font>
        p += write_eocdr(p, &amp;eocdr);<font></font>
<font></font>
        assert(p - dst &lt;= zip_max_size(num_memb, filenames, file_sizes,<font></font>
                                       comment));<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">uint32_t</span>)(p - dst);<font></font>
}<font></font>
</code></pre><br>
<a name="25"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hwzip</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita tahu cara membaca dan menulis file Zip, cara mengompres dan mendekompresi data yang tersimpan di dalamnya. </font><font style="vertical-align: inherit;">Sekarang mari kita menulis program Zip sederhana yang berisi semua alat ini. </font><font style="vertical-align: inherit;">Kode ini tersedia di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hwzip.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan menggunakan makro untuk penanganan kesalahan sederhana dan beberapa fungsi tambahan untuk alokasi memori yang diperiksa:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PERROR_IF(cond, msg) <span class="hljs-meta-keyword">if</span> (cond) { perror(msg); exit(1); }</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">xmalloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span>
</span>{
        <span class="hljs-keyword">void</span> *ptr = <span class="hljs-built_in">malloc</span>(size);<font></font>
        PERROR_IF(ptr == <span class="hljs-literal">NULL</span>, <span class="hljs-string">"malloc"</span>);
        <span class="hljs-keyword">return</span> ptr;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">xrealloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">size_t</span> size)</span>
</span>{<font></font>
        ptr = <span class="hljs-built_in">realloc</span>(ptr, size);<font></font>
        PERROR_IF(ptr == <span class="hljs-literal">NULL</span>, <span class="hljs-string">"realloc"</span>);
        <span class="hljs-keyword">return</span> ptr;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dua fungsi lainnya digunakan untuk membaca dan menulis file:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-title">read_file</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">size_t</span> *file_sz)</span>
</span>{<font></font>
        FILE *f;<font></font>
        <span class="hljs-keyword">uint8_t</span> *buf;
        <span class="hljs-keyword">size_t</span> buf_cap;<font></font>
<font></font>
        f = fopen(filename, <span class="hljs-string">"rb"</span>);<font></font>
        PERROR_IF(f == <span class="hljs-literal">NULL</span>, <span class="hljs-string">"fopen"</span>);<font></font>
<font></font>
        buf_cap = <span class="hljs-number">4096</span>;<font></font>
        buf = xmalloc(buf_cap);<font></font>
<font></font>
        *file_sz = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (feof(f) == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (buf_cap - *file_sz == <span class="hljs-number">0</span>) {<font></font>
                        buf_cap *= <span class="hljs-number">2</span>;<font></font>
                        buf = xrealloc(buf, buf_cap);<font></font>
                }<font></font>
<font></font>
                *file_sz += fread(&amp;buf[*file_sz], <span class="hljs-number">1</span>, buf_cap - *file_sz, f);<font></font>
                PERROR_IF(ferror(f), <span class="hljs-string">"fread"</span>);<font></font>
        }<font></font>
<font></font>
        PERROR_IF(fclose(f) != <span class="hljs-number">0</span>, <span class="hljs-string">"fclose"</span>);
        <span class="hljs-keyword">return</span> buf;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write_file</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *data, <span class="hljs-keyword">size_t</span> n)</span>
</span>{<font></font>
        FILE *f;<font></font>
<font></font>
        f = fopen(filename, <span class="hljs-string">"wb"</span>);<font></font>
        PERROR_IF(f == <span class="hljs-literal">NULL</span>, <span class="hljs-string">"fopen"</span>);<font></font>
        PERROR_IF(fwrite(data, <span class="hljs-number">1</span>, n, f) != n, <span class="hljs-string">"fwrite"</span>);<font></font>
        PERROR_IF(fclose(f) != <span class="hljs-number">0</span>, <span class="hljs-string">"fclose"</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Program Zip kami dapat melakukan tiga fungsi: membuat daftar isi file Zip dan mengekstraknya, serta membuat file Zip. </font><font style="vertical-align: inherit;">Cantuman tidak mudah:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">list_zip</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *zip_data;
        <span class="hljs-keyword">size_t</span> zip_sz;
        <span class="hljs-keyword">zip_t</span> z;
        <span class="hljs-keyword">zipiter_t</span> it;
        <span class="hljs-keyword">zipmemb_t</span> m;<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Listing ZIP archive: %s\n\n"</span>, filename);<font></font>
<font></font>
        zip_data = read_file(filename, &amp;zip_sz);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!zip_read(&amp;z, zip_data, zip_sz)) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Failed to parse ZIP file!\n"</span>);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (z.comment_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.*s\n\n"</span>, (<span class="hljs-keyword">int</span>)z.comment_len, z.comment);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (it = z.members_begin; it != z.members_end; it = m.next) {<font></font>
                m = zip_member(&amp;z, it);<font></font>
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.*s\n"</span>, (<span class="hljs-keyword">int</span>)m.name_len, m.name);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
<font></font>
        <span class="hljs-built_in">free</span>(zip_data);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ekstraksi sedikit lebih rumit. </font><font style="vertical-align: inherit;">Kami akan menggunakan fungsi bantu untuk penghentian nol nama file (untuk meneruskannya </font></font><code>fopen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) dan membongkar:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> *<span class="hljs-title">terminate_str</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">char</span> *p = xmalloc(n + <span class="hljs-number">1</span>);
        <span class="hljs-built_in">memcpy</span>(p, str, n);<font></font>
        p[n] = <span class="hljs-string">'\0'</span>;
        <span class="hljs-keyword">return</span> p;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-title">inflate_member</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">zipmemb_t</span> *m)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">size_t</span> src_used, dst_used;<font></font>
<font></font>
        assert(m-&gt;method == ZIP_DEFLATED);<font></font>
<font></font>
        p = xmalloc(m-&gt;uncomp_size);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (hwinflate(m-&gt;comp_data, m-&gt;comp_size, &amp;src_used, p, m-&gt;uncomp_size,<font></font>
                      &amp;dst_used) != HWINF_OK) {<font></font>
                <span class="hljs-built_in">free</span>(p);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (src_used != m-&gt;comp_size || dst_used != m-&gt;uncomp_size) {
                <span class="hljs-built_in">free</span>(p);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> p;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Program kami akan melewati semua elemen arsip yang memiliki direktori. </font><font style="vertical-align: inherit;">Ini dilakukan untuk menghindari apa yang disebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serangan jalur traversal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : arsip jahat digunakan untuk menulis file dari luar direktori yang ditentukan oleh pengguna. </font><font style="vertical-align: inherit;">Baca detailnya di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FAQ Info-ZIP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">extract_zip</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *zip_data;
        <span class="hljs-keyword">size_t</span> zip_sz;
        <span class="hljs-keyword">zip_t</span> z;
        <span class="hljs-keyword">zipiter_t</span> it;
        <span class="hljs-keyword">zipmemb_t</span> m;
        <span class="hljs-keyword">char</span> *tname;
        <span class="hljs-keyword">uint8_t</span> *inflated;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *uncomp_data;<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Extracting ZIP archive: %s\n\n"</span>, filename);<font></font>
<font></font>
        zip_data = read_file(filename, &amp;zip_sz);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!zip_read(&amp;z, zip_data, zip_sz)) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Failed to read ZIP file!\n"</span>);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (z.comment_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.*s\n\n"</span>, (<span class="hljs-keyword">int</span>)z.comment_len, z.comment);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (it = z.members_begin; it != z.members_end; it = m.next) {<font></font>
                m = zip_member(&amp;z, it);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (m.is_dir) {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" (Skipping dir: %.*s)\n"</span>,<font></font>
                               (<span class="hljs-keyword">int</span>)m.name_len, m.name);
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memchr</span>(m.name, <span class="hljs-string">'/'</span>,  m.name_len) != <span class="hljs-literal">NULL</span> ||
                    <span class="hljs-built_in">memchr</span>(m.name, <span class="hljs-string">'\\'</span>, m.name_len) != <span class="hljs-literal">NULL</span>) {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" (Skipping file in dir: %.*s)\n"</span>,<font></font>
                               (<span class="hljs-keyword">int</span>)m.name_len, m.name);
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                assert(m.method == ZIP_STORED || m.method == ZIP_DEFLATED);<font></font>
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %s: %.*s"</span>,<font></font>
                       m.method == ZIP_STORED ? <span class="hljs-string">"Extracting"</span> : <span class="hljs-string">" Inflating"</span>,<font></font>
                       (<span class="hljs-keyword">int</span>)m.name_len, m.name);<font></font>
                fflush(<span class="hljs-built_in">stdout</span>);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (m.method == ZIP_STORED) {<font></font>
                        assert(m.uncomp_size == m.comp_size);<font></font>
                        inflated = <span class="hljs-literal">NULL</span>;<font></font>
                        uncomp_data = m.comp_data;<font></font>
                } <span class="hljs-keyword">else</span> {<font></font>
                        inflated = inflate_member(&amp;m);<font></font>
                        <span class="hljs-keyword">if</span> (inflated == <span class="hljs-literal">NULL</span>) {
                                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error: inflation failed!\n"</span>);
                                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
                        }<font></font>
                        uncomp_data = inflated;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (crc32(uncomp_data, m.uncomp_size) != m.crc32) {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error: CRC-32 mismatch!\n"</span>);
                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
                }<font></font>
<font></font>
                tname = terminate_str((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)m.name, m.name_len);<font></font>
                write_file(tname, uncomp_data, m.uncomp_size);<font></font>
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
<font></font>
                <span class="hljs-built_in">free</span>(inflated);
                <span class="hljs-built_in">free</span>(tname);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        <span class="hljs-built_in">free</span>(zip_data);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk membuat arsip zip, kita akan membaca file input dan memberi mereka makan </font></font><code>zip_write</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Karena pustaka C standar tidak memungkinkan Anda untuk mendapatkan waktu modifikasi file, kami akan menggunakan waktu saat ini (saya meninggalkan ini sebagai pekerjaan rumah untuk memperbaiki fitur ini).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">zip_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">uint32_t</span> size, <span class="hljs-keyword">uint32_t</span> comp_size)</span>
</span>{
        <span class="hljs-keyword">bool</span> deflated = comp_size &lt; size;<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %s: %s"</span>, deflated ? <span class="hljs-string">"Deflated"</span> : <span class="hljs-string">"  Stored"</span>, filename);
        <span class="hljs-keyword">if</span> (deflated) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" (%u%%)"</span>, <span class="hljs-number">100</span> - <span class="hljs-number">100</span> * comp_size / size);<font></font>
        }<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create_zip</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *zip_filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *comment,
                       <span class="hljs-keyword">uint16_t</span> n, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *filenames)</span>
</span>{
        <span class="hljs-keyword">time_t</span> mtime;
        <span class="hljs-keyword">time_t</span> *mtimes;
        <span class="hljs-keyword">uint8_t</span> **file_data;
        <span class="hljs-keyword">uint32_t</span> *file_sizes;
        <span class="hljs-keyword">size_t</span> file_size, zip_size;
        <span class="hljs-keyword">uint8_t</span> *zip_data;
        <span class="hljs-keyword">uint16_t</span> i;<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Creating ZIP archive: %s\n\n"</span>, zip_filename);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (comment != <span class="hljs-literal">NULL</span>) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n\n"</span>, comment);<font></font>
        }<font></font>
<font></font>
        mtime = time(<span class="hljs-literal">NULL</span>);<font></font>
<font></font>
        file_data = xmalloc(<span class="hljs-keyword">sizeof</span>(*file_data) * n);<font></font>
        file_sizes = xmalloc(<span class="hljs-keyword">sizeof</span>(*file_sizes) * n);<font></font>
        mtimes = xmalloc(<span class="hljs-keyword">sizeof</span>(*mtimes) * n);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                file_data[i] = read_file(filenames[i], &amp;file_size);<font></font>
                <span class="hljs-keyword">if</span> (file_size &gt;= UINT32_MAX) {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s is too large!\n"</span>, filenames[i]);
                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
                }<font></font>
                file_sizes[i] = (<span class="hljs-keyword">uint32_t</span>)file_size;<font></font>
                mtimes[i] = mtime;<font></font>
        }<font></font>
<font></font>
        zip_size = zip_max_size(n, filenames, file_sizes, comment);<font></font>
        <span class="hljs-keyword">if</span> (zip_size == <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"zip writing not possible"</span>);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        zip_data = xmalloc(zip_size);<font></font>
        zip_size = zip_write(zip_data, n, filenames,<font></font>
                             (<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-keyword">const</span> *)file_data,<font></font>
                             file_sizes, mtimes, comment, zip_callback);<font></font>
<font></font>
        write_file(zip_filename, zip_data, zip_size);<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
<font></font>
        <span class="hljs-built_in">free</span>(zip_data);
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {
                <span class="hljs-built_in">free</span>(file_data[i]);<font></font>
        }<font></font>
        <span class="hljs-built_in">free</span>(mtimes);
        <span class="hljs-built_in">free</span>(file_sizes);
        <span class="hljs-built_in">free</span>(file_data);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akhirnya, ia </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memeriksa argumen baris perintah dan memutuskan apa yang harus dilakukan:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print_usage</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *argv0)</span>
</span>{
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Usage:\n\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"  %s list &lt;zipfile&gt;\n"</span>, argv0);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"  %s extract &lt;zipfile&gt;\n"</span>, argv0);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"  %s create &lt;zipfile&gt; [-c &lt;comment&gt;] &lt;files...&gt;\n"</span>, argv0);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"HWZIP "</span> VERSION <span class="hljs-string">" -- A very simple ZIP program "</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"from https://www.hanshq.net/zip.html\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"list"</span>) == <span class="hljs-number">0</span>) {<font></font>
                list_zip(argv[<span class="hljs-number">2</span>]);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"extract"</span>) == <span class="hljs-number">0</span>) {<font></font>
                extract_zip(argv[<span class="hljs-number">2</span>]);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argc &gt;= <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"create"</span>) == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (argc &gt;= <span class="hljs-number">5</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">3</span>], <span class="hljs-string">"-c"</span>) == <span class="hljs-number">0</span>) {<font></font>
                        create_zip(argv[<span class="hljs-number">2</span>], argv[<span class="hljs-number">4</span>], (<span class="hljs-keyword">uint16_t</span>)(argc - <span class="hljs-number">5</span>),<font></font>
                                   (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *)&amp;argv[<span class="hljs-number">5</span>]);<font></font>
                } <span class="hljs-keyword">else</span> {<font></font>
                        create_zip(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, (<span class="hljs-keyword">uint16_t</span>)(argc - <span class="hljs-number">3</span>),<font></font>
                                   (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *)&amp;argv[<span class="hljs-number">3</span>]);<font></font>
                }<font></font>
        } <span class="hljs-keyword">else</span> {<font></font>
                print_usage(argv[<span class="hljs-number">0</span>]);
                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br>
<a name="26"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">petunjuk perakitan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Satu set lengkap file sumber tersedia di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hwzip-1.0.zip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cara mengompilasi HWZip di Linux atau Mac:</font></font><br>
<br>
<pre><code class="cpp hljs">$ clang generate_tables.c &amp;&amp; ./a.out &gt; tables.c<font></font>
$ clang -O3 -DNDEBUG -march=native -o hwzip crc32.c deflate.c huffman.c \<font></font>
        hwzip.c lz77.c tables.c zip.c<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di Windows, di prompt perintah pengembang di Visual Studio (jika Anda tidak memiliki Visual Studio, unduh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alat pembuatan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="cpp hljs">cl /TC generate_tables.c &amp;&amp; generate_tables &gt; tables.c<font></font>
cl /O2 /DNDEBUG /MT /Fehwzip.exe /TC crc32.c deflate.c huffman.c hwzip.c<font></font>
        lz77.c tables.c zip.c /link setargv.obj<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setargv.obj untuk </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memperluas argumen baris perintah wildcard</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .)</font></font><br>
<br>
<a name="27"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sungguh menakjubkan bagaimana teknologi berkembang dengan cepat dan lambat. </font><font style="vertical-align: inherit;">Format Zip dibuat 30 tahun yang lalu berdasarkan teknologi dari tahun lima puluhan dan tujuh puluhan. </font><font style="vertical-align: inherit;">Dan meskipun banyak yang telah berubah sejak saat itu, file Zip, pada kenyataannya, tetap sama dan hari ini lebih umum daripada sebelumnya. </font><font style="vertical-align: inherit;">Saya pikir akan bermanfaat untuk memiliki pemahaman yang baik tentang bagaimana mereka bekerja.</font></font><br>
<br>
<a name="28"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latihan</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat HWZip merekam waktu yang dibutuhkan untuk setiap file berubah, daripada waktu saat ini arsip dibuat. </font><font style="vertical-align: inherit;">Gunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stat (2)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di Linux atau Mac dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetFileTime</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di Windows. </font><font style="vertical-align: inherit;">Atau tambahkan bendera baris perintah yang memungkinkan pengguna untuk mengatur waktu tertentu untuk perubahan file.</font></font></li>
<li>              gzip-.   —    ,    Deflate (   ).    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC 1952</a>.</li>
<li>    Zip-     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a>.  HWZip ,   <code>read_file</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mmap(2)</a>  Linux  Mac  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CreateFileMapping</a>  Windows.</li>
<li> HWZip ,          Zip64.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> appnote.txt</a>.</li>
</ul><br>
<a name="29"></a><h2> </h2><br>
<ul>
<li>  BBS-   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BBS: The Documentary</a>.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> YouTube</a>.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Part 8: Compression</a>    SEA  PKWare.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a>.</li>
<li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">A better Zip bomb</a>    Zip-,    «»    .</li>
<li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zip Files All The Way Down</a> ,   <i>Zip-</i> — ,    .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ascii-zip</a> —  ,  Deflate-   ASCII-.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rosetta Flash</a>.</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ten Thousand Security Pitfalls: the Zip File Format</a> —        .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Reading bits in far too many ways part 1</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">part 2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">part 3</a> —       .</li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Understanding Compression</a>      .</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id490780/index.html">Intel Xeon Scalable Gen2: Penjualan Besar Core</a></li>
<li><a href="../id490782/index.html">AnalogBytes Conference: Roskomnadzor, media, highload, dan semuanya</a></li>
<li><a href="../id490784/index.html">Saya seorang pengembang Android dan saya tidak ingin melakukan pekerjaan manual.</a></li>
<li><a href="../id490786/index.html">Analisis kebocoran urutan kedua: ketika bocor dari mereka yang mencuri data dari bank</a></li>
<li><a href="../id490788/index.html">REPL tidak berguna. Laporan Yandex</a></li>
<li><a href="../id490792/index.html">VXLAN dalam NSX-V - Underlay Bermasalah</a></li>
<li><a href="../id490796/index.html">Cara mengotomatiskan keamanan wadah dengan gaya Kebijakan sebagai Kode menggunakan CRD</a></li>
<li><a href="../id490804/index.html">Bagaimana ibu seorang peretas masuk penjara dan menginfeksi komputer bos</a></li>
<li><a href="../id490808/index.html">Matematika dalam astronotika: mesin peledakan rotasi</a></li>
<li><a href="../id490812/index.html">Pengalaman Pengajuan Sertifikasi Spring Professional 5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>