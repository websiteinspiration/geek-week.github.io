<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍⚕️ 🏎️ 🐢 プログラマブル計算機のEFORTH 🚙 🔶 🤹🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="これは、161eForth v0.5bに関するシリーズの最初の記事で、ここで終わります： habr.com/en/post/452572 EFORTH
 
 トランスレータは、国内のMK-161電子計算機でも利用できるようになりました！ 5月17日、バージョンv0.5bが私のテストと5つのTEST-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>プログラマブル計算機のEFORTH</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452398/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、161eForth v0.5bに関するシリーズの最初の記事で、ここで終わります：</font></font></i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/en/post/452572 EFORTH</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
トランスレータは、国内のMK-161電子計算機でも利用できるようになりました！ 5月17日、バージョンv0.5bが私のテストと5つのTEST-TEST4オーサリングテストに合格しました。一人でできることは達成しましたが、これは戦いの半分に過ぎないと思います。パブリックテスト用に161eForthコードを開いて、コミュニティに新しいツールを導入する時がきました。改善すべき点と「安定性に取り組む」ための場所のリストがあります。作業を完了してバージョン1.0をリリースするときに、提案とコメントが考慮されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最新バージョンのeForthを国内プラットフォームに移植すると、2つの障害が克服されました。それは、独自の入力言語でプログラムされた8ビットマシンの比較的低速と、使用可能なバイナリメモリ（2.4.1を参照）の適度な量（わずか4096バイト）です。</font></font><br>
<img src="https://habrastorage.org/webt/lx/76/pw/lx76pw2yfjmfnqz4wxg9pp_m6ya.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
161eForthを作成する際、国内のPMKの次世代入力言語であるCallisto向けに用意された既製のソリューションが使用されました。これは、10進ALUと「Harvard」アーキテクチャ、コンソールドライバ、英数字キーボードレイアウトに加えて、RS-232シリアルポートを介して動作するソフトウェアターミナル上にフォートマシンを実装するためのテクノロジーです。 Electronics MK-161および161eForthディストリビューションに加えて、ロシア語と英語のアルファベットの文字がキーに署名されている自家製のパッチキーボードが必要になる場合があります。文字は、左から右へ、上から下へ、行ごとにアルファベット順に配置されます。</font></font><br>
<img src="https://habrastorage.org/webt/ff/pu/ry/ffpury7pflujlbysn28jipoylgg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eForthの最新バージョンの作者であるChen-Hanson Ting博士は、本[1]で砦の2つの構成要素を理解することの重要性を強調しています。これは、機器がフォートの縫製コードを実行できるようにする内部（「アドレス」）インタープリターと、人との対話を担当する外部（「テキスト」）インタープリターです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの記事で、Electronicsでこれら2つのインタープリターのそれぞれの実装に使用される最も過激なソリューションについて詳しく説明します。これらのソリューションを学ぶことは、eForthをメモリとパフォーマンスが限られている他のデバイスに移行するのに役立ち、刺激になる可能性があります。記事を理解すると、プログラム可能なマイクロ計算機（PMC）とFortの最初の紹介に役立ちます。 Electronics MKとeForthトランスレータに固有の困難な瞬間について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、eForthの単語は、一般的なものと体系的なものに分けられます。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文字のサイズが重要です。通常の単語の名前は大文字で定義され、システムは小文字で定義されます。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">また、小文字でeForthの革新を行いました。 eForthの作者は、CAPSモードでメインの対話を行うことを提案しています。システムワードを使用する必要がある場合は、時間を小文字に切り替えます（FPキーの組み合わせ）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事では、すべての単語はテキストから目立つように大文字で書かれています。初期のeForth実装のいくつかでは、システムワードヘッダーが除外され、WORDSコマンドによって出力されませんでした。これにより、eForthの外観が簡素化され、Fortを初めて使用するユーザーの注意が軽減されました。 161eForthでは、これらの単語の見出しは、主にSEEコロンワードデコンパイラー（記事の最後にあるビデオNo. 3を参照）の存在により保存されました。見出しが削除された場合、システムワードの名前は表示されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事を簡素化し、参照として役立つようにするために、定義する前にいくつかの用語を使用する必要がありました。フォートおよびPMKの専門家は、これらの用語に精通している必要があります。初心者は時々、隣のセクション（リンクを適切な場所に配置します）を調べるか、記事を何度か読み直す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
161eForth自体がここに投稿されています。ソーステキスト、キーボードのグラフィック、および実装されているすべての単語の説明を含むヘルプのwords.txt：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ://the-hacker.ru/2019/161eforth0.5b.zip </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、YouTubeに5本の小さな動画を投稿しました。 MK-161をお持ちでない方のための161eForthの操作を示しています。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YouTubeでプレイリスト全体</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">見る</font></a><font style="vertical-align: inherit;">ことができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">以下は最初のもので、残りの4つは記事の最後です。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/RxarUWHdNTE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eForthとその実装</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eForthは、広く知られているFIG-Fortのトランスレータの最新の代替品として開発されました。 MK-161に転送するために、Windowsオペレーティングシステム用のMASMアセンブラーで2016年に書かれた、間接縫製コードを含む86eForthトランスレーターの32ビットバージョン5.2を選択しました。このバージョンは、eForthおよびZenの第3版で詳細に説明されています[1]。英語を知っている人には、この本を見つけて勉強することをお勧めします。161eForthを理解するのに非常に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
個人的な手紙で、著者はこの本の86eForth502.asmがeForthの最新バージョンであることを確認しました。インターネット上で、これと以前のバージョンのeForthに関する多くの英語情報を見つけることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eForthの開発は、彼のプログラミング言語Oberonの例を使用して、Wirth教授によって教えられた科学的道をたどりました。 eForthの後続の各バージョンは、前のバージョンを簡略化したものです。不要なものはすべて舌から取り除かれました。注意深く考え抜かれた強力で表現力豊かな言語構成要素のセットが残っており、その能力はさまざまなプラットフォームの40以上のeForth実装でテストされています。今電卓で！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォートのミニマリストの方言であるeForthは、最小のフォートとの競争に勝つことを目指していません。彼が提供する一連の単語は非常に実用的であり、プログラマーは自分のタスクに必要な方向に簡単に拡張できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eForthの最初のバージョンは、1990年に8086プロセッサ用のMASMアセンブラでリリースされ、MS-DOSで動作しました。 31のマシン依存コアワードと191の上位レベルワードが含まれていました。アイデアは単純でした。31ワードだけをアセンブラーに翻訳し、すぐにコンピューターでeForthを取得しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは、アセンブラーのワード数を最小限に抑える方法が組み込みシステムのパフォーマンスを極端に低下させたため、インターネットで批判されています。 eForthの第2バージョンではすでに、アセンブラーに最大数の単語が実装され始めており、移植性だけでなく、実用的なプログラミングシステムへの傾きもまっすぐになりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数年間、eForthの最初の作者であるBill Munchと彼の同僚であるChen-Hanson Ting博士は、並行してeForthリリースをリリースしました。各バージョンには独自の特性がありました。異なるプラットフォーム用のeForthオプションは、他のプログラマーによっても導入されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2016年にリリースされたバージョン5.2には、71ワードの「コード」と110ワードの「コロン」が含まれています。理想の四半世紀にわたる調査により、単語の総数が大幅に減少しました。同時に、パフォーマンス上の理由から、低レベルで認識される単語の割合が増加しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提案された161eForthはこの進歩の寛大な利益を享受しますが、幹線をさらに発展させるふりはしません。私の実装は、バージョン5.2にあるすべてのツールをプログラマーに提供します。 MK-161アーキテクチャーが86eForthワードの実装を不可能または無意味にする場合、過剰を捨てるのではなく、ANSI / ISO標準[4]から完全に置き換えてプログラマーに提供します。ミニマリズムを求める人は、自分で「余分な」単語を捨てることができます。これは、伝統により、161eForthにはソースコードが付属しているためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eForthを実装するとき、筆者の理解に固執しました。たとえば、私の意見では、初期値がnのFOR NEXTループは、正確にn回実行されるはずです。同じ結論が最終的に出て来たのは、言語ForthとcolorForthの作者であるチャックムーアです。残念ながら、eForthは古い規則を使用し、そのようなループをn + 1回、nから0までのカウンターで実行します。これと他のいくつかの欠点を修正せず、他のプラットフォームの実装との161eForth互換性を優先しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
161eForthはMK-161 Electronicsの最初の実用的なオンボードプログラミングシステムであるため、工場出荷時の言語を除いて、eForthの長い歴史をたどって、他のプラットフォームで有用で現在需要があるかもしれない言語にいくつかの単語を返しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、新旧の変数 'BOOTには単語のトークン（3.1を参照）が含まれています。これは、環境が初期化された後、ダイアログが開始する前に最初に実行されます。デフォルトでは、 'BOOTには、「テキスト領域」からのコードを解釈するためのTLOADトークンが含まれています（2.4.2を参照）。これにより、プログラマーは環境を再コンパイルせずにeForthを自分でカスタマイズできます。これは、「電子機器」上で生成することはまだ不可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装の優先タスクは、バイナリメモリの節約（2.4.1を参照）とパフォーマンスの向上でした。安価なプログラムメモリに実装された高速カーネルワードの数が増えるため（2.4.3を参照）、コードがこの貴重なメモリを占有するため、これらのソリューションにより、高レベルワードの数が劇的に減少しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、161eForthには129のコードワード、78の高レベルワードが含まれ、MK-161バイナリメモリの1816バイトを占めます（つまり、その半分未満）。</font><font style="vertical-align: inherit;">これにより、電子機器に直接搭載された高レベルのパーツのメタコンパイルに希望が与えられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eForth MK-161のソースコードは、2つの大きな部分に分かれています。</font><font style="vertical-align: inherit;">MK-161コマンドシステムで記述されたカーネルは、eForth0.mklファイルに含まれています。</font><font style="vertical-align: inherit;">高レベルの単語はSP-Forthで定義され、eForth.fファイルにあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディストリビューションにはヘルプファイルwords.txtもあり、スタック表記と簡単な説明を含むすべての161eForthワードが1行に記載されています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1カーネルeForth0.mklのソースコード</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eForthカーネルには、MK-161プログラム（2.4.3を参照）のメモリで動作する実行可能コードが含まれています。これは、独自のMKL2MKPコンパイラなどの標準的な方法でコンピュータ上でeForth0.mkpファイルにコンパイルされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eForth0.mklファイルに含まれるカーネルソースコードは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラテン語のニーモニックで</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記述されてい</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。たとえば、レジ​​スタE（別名R14）を読み取るためのIPEコマンドは、RMEとしてこのニーモニックで記述されています。ソビエトPMKの所有者には珍しいラテン語のニーモニックは、コンピューターのキーボードから入力するのに便利です。確かに、奇妙なFX ^ 2を入力することは、子供の頃のFx²に慣れているよりも簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eForth0.mkpファイルはカーネルプリセットです。</font><font style="vertical-align: inherit;">プリミティブのコードに加えて、カーネルヘッダーと名前のテーブルtblNamesが含まれ、eForth.fはデコード中に10進レジスターに転送します（2.4.4を参照）。</font><font style="vertical-align: inherit;">eForth.mkpコアが作成されるのはeForth0.mkpに基づいているため（2.4.3を参照）、最初にeForth0.mklをコンパイルする必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2高水準語eForth.fのソースコード</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eForth.fファイルは、すばらしい国産コンパイラーSP-Forth [5]の入力に供給されます。</font><font style="vertical-align: inherit;">このファイルには、すべての高水準単語の定義が含まれています。</font><font style="vertical-align: inherit;">時間の経過とともに、それらはeForth自体で識別でき、場合によってはElectronics MK-161に直接コンパイルされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイル中、eForth.fはeForth0.mkpコアブランクを読み取り、その助けを借りて、現在のディレクトリに次のMK-161にロードするための3つのファイル、eForth.mkp、eForth.mkd、eForth.mkbを作成します。</font><font style="vertical-align: inherit;">ヘッダーはeForth.mkdファイルにありますが、上位レベルの単語の本文を含むのはeForth.mkbです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4番目のファイルeForth.mktは、eForthで手動で記述され、組み込みのテキストエディターを使用してMK-161のボード上で編集できます。</font><font style="vertical-align: inherit;">これら4つのファイルのそれぞれについて、以下で詳しく分析します（2.4を参照）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.エレクトロニクスMK-161</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノボシビルスクのメーカーは、MK-161を古い頭字語と呼んでいます。それはソ連で最初の電卓の名前でした。 MK-161コマンドシステムは、ソビエト計算機「Electronics B3-34」および「Electronics MK-61」のコマンドシステムを継承しています。つまり、ソビエトの電卓用に作成されたプログラムは、変更なしで、またはマイナーな変更を加えずにMK-161で実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
逆は真実ではありません。 eForthはソビエトPMKに行きません、なぜならMK-152 / 161で初めて登場し、シリーズの以前のモデルでは利用できなかった多くのリソースを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MK-161の入力言語とアーキテクチャの機能を検討してください。これは161eForth（以下、単にeForthと呼びます）に影響を与え、議論されたeForthの実装「ロシア語アクセント」を提供しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの機能の最初の機能は、MK-161で順次維持されます</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シニアからジュニアへの合意</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">たとえば、1000 = 3×256 + 232という数字は、3や232のように2つの連続するバイトで書き込まれます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1間接アドレス指定</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラミングソ連のPMKは、間接的なアドレス指定について聞いた。以下のために</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接アドレッシング、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我々は明示的に我々が参照しているレジスタ番号を示しています。たとえば、P IP 44はレジスタ44の内容を考慮します。MK-152に出現したPキーは、番号15以上のレジスタへのアクセスに使用されます。これらのレジスタはソビエトPMKにはありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
で</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">間接アドレッシング、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要なレジスタの数が事前に知られていません。この番号は別のレジスタにあります。例えば、レジ​​スター8に数値44が含まれている場合、コマンドK PI 8はレジスター44（R44）の内容を考慮します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
KキーとPキーは組み合わせることができます。たとえば、コマンドR K BP 20は、R20に格納されているアドレスに制御（ラテン語ニーモニックのGOTO）を転送します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部のeForthインタープリターにとって重要であることが判明した機能は、間接アドレッシング中のレジスターの予備的な増減に関連しています。この機能は、ソビエトPMKから継承されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、間接読み取りコマンドK PI 0、K PI 1、K PI 2、およびK PI 3は、レジスタ0、1、2、または3の内容を1つずつ目的のレジスタに減らします。コマンドK PI 4、K PI 5およびK PI 6読み取りの前に、レジスタ4、5、または6の内容が1つ増えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなアドレスレジスタの「変更」により、レジスタのグループ全体をサイクルで処理できます。 Cの++ Rおよび--Rに似ています。レジスターレジスター番号は重要です。間接アドレス指定で増加するか（レジスター4〜6）または減少するか（レジスター0〜3）を決定するのは彼です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
161eForthアーキテクチャは、間接アドレス指定によるレジスタ4〜6の増加が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暫定</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的なものであるという事実の影響を受けました</font><font style="vertical-align: inherit;">。その結果、R6にある解釈ポインタ（IP）は常に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">縫い付けられたコードの</font><i><font style="vertical-align: inherit;">最後のバイトを指し</font></i><font style="vertical-align: inherit;">ます。 86eForthでは、IPは常に、まだ読み取られていない後続のバイトを示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、レジスター2に保管されている戻りスタック・ポインター（RP）にも当てはまります。R2は常に戻りスタックの先頭を指します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MK-161の便利な機能は、新しいキーRで間接アドレッシングが発生した場合にレジスターに増減がないことです。たとえば、RKIP02は、ポインターを変更せずにリターンスタックの先頭からの数を考慮します。</font><font style="vertical-align: inherit;">これはフォートR @レディチームです。</font><font style="vertical-align: inherit;">上記のことから、読み取られた値は次のトークンのアドレスよりも1つ少ないことになります。これは、単語「コロン」から戻った後に実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eForthの内部通訳と密接に相互作用する単語を開発または学習する必要がある場合は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">誇張に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関連するこの微妙な点を完全に理解し</font><b><font style="vertical-align: inherit;">てください</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2テーブル、順序付け、関連付け</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MK-161テーブルはプログラムメモリにあります（2.4.3を参照）。それらはノボシビルスクの「エレクトロニクスMK」に登場し、ソビエトPMKの専門家にはまったくなじみがありません。使用されるテーブルのアドレスは常にレジスタ9042に格納されますが、それらへのアクセスは異なります。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">順序付けられたテーブル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、符号なし16ビット整数の配列です。 eForthには、プリミティブ（3.1.1を参照）のアドレスを含むこのようなtblTokensテーブルが含まれています-MK-161コマンドシステムで記述されたフォートワード。アドレスインタープリター（3.2を参照）は、tblTokensを使用してすばやく縫製コードを実行するため、eForthは常にR9042でこのテーブルのアドレスを保持しようとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注文したテーブルにアクセスするには、R9210に目的のアイテムの番号を書き込む必要があります。レジスタXの数値nは、数値nのテーブルの要素の値に置き換えられます。カウントはゼロから始まります。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">連想テーブル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（「値で検索」）は、eForthによってアクティブに使用されます。主に、名前で単語を検索するプリミティブ（FIND）によって使用されます。また、tblCHPUT連想テーブルは、ラインフィードやその他の制御コードを処理するための文字を表示するときに使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
連想テーブルで要素nを検索するには、nをR9212に書き込みます。レジスタXの数値n（管理ではこれを「インデックス」と呼びます）は、テーブルの「インデックス」nの直後に書き込まれた16ビット値で置き換えられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MK-161ファームウェアのアセンブリ言語で実装されたこの迅速でシンプルな検索機能の存在は、eForthが単語名を認識してプログラムをコンパイルするときに許容できるパフォーマンスを達成するのに役立ちました。</font><font style="vertical-align: inherit;">もちろん、このために、この機能のために「シャープ化」された、最も単純な名前認識テーブルを開発する必要はありませんでした。</font><font style="vertical-align: inherit;">これについては、2番目の記事で詳しく説明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.3割り込みとコンソール</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「MK Electronics」を使用すると、その所有者は、ボタンを押したり離したり、タイマーのカウントを終了するなど、特定のイベントに応答するプログラムを入力言語で作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eForth </font><font style="vertical-align: inherit;">は、キーボード入力と点滅カーソル表示の両方に対して</font><font style="vertical-align: inherit;">この</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">割り込みシステム</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">積極的に使用し</font><font style="vertical-align: inherit;">、そのような入力を求められた場合、およびユニバーサルシリアルポート（RS-232）を介した入出力に使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーボードから入力した文字は、キーを押すとbufKbdのキューに入れられます。これは非常に便利で、低速システムで時間を節約できます。アルファベットと大文字と小文字の切り替えはKeyPress割り込みによって処理され、キュースペースを占有しません。キーを長押しすると、オートリピートが呼び出されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8文字の行がいっぱいで、eForthがまだ入力を処理する準備ができていない場合（状況は非常にまれです）、MK-161は不快なきしみ音を発します。もちろん、キーボードのこの自然な作業をすべてトランスレータに実装するのではなく、組み込みプログラム（ファームウェア）のサービスとしてMK-161を箱から出します。しかし、彼らが言うように、何が豊富です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業開始後、eForthの出力全体</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MK-161の</font><i><font style="vertical-align: inherit;">グラフィック画面に</font></i><font style="vertical-align: inherit;">送られ</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。その上の文字の出力は、CNCutの比較的単純なルーチンによって実行されます。ここでの唯一の問題は、BS制御コードの実装である「スペースバック」です。 MK-161はプロポーショナルフォントを使用します。したがって、特別なバッファーtblBSでは、表示された文字の位置を覚えておく必要があり、そこからBS出力コードがそれらを取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
対話中、ユーザーはIO&gt;という単語を使用してすべてのI / OをRS-232シリアルポートにリダイレクトできます。これにより</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、使い慣れたコンピューターのキーボードまたは別のMK-161からMK-161</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><b><font style="vertical-align: inherit;">プログラム</font></b><font style="vertical-align: inherit;">することができ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">CON&gt;という語は、制御を計算機コンソールに戻します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.4メモリ領域とMK-161へのeForthのインストール</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Electronics MK-161のメモリは、個別にアドレス指定可能なプログラムメモリとレジスタデータメモリで構成されています。次に、レジスタメモリは異種であり、3つの大きな領域に分割されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0から999までの数値を持つレジスタには、「10進数」が格納されます。これらは、「Electronics B3-34」やその他の計算機と同様に、通常のレジスタです。単に「仮数」の小数点以下8桁ではなく12桁を格納できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1000から8167までの数値を持つレジスタは、0から255までの整数を格納します。5096から8167までのアドレスを持つこの領域の最後の3 Kバイトは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、テキスト領域</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9000から9999までの番号を</font><i><font style="vertical-align: inherit;">持つレジスタ</font></i><font style="vertical-align: inherit;">は、</font><i><font style="vertical-align: inherit;">関数レジスタ</font></i><font style="vertical-align: inherit;">と呼ばれ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">アドレススペースのこのサービスエリアは、マイクロプロセッサのI / Oポートに似ています。</font><font style="vertical-align: inherit;">書き込みおよび読み取りコマンドの助けを借りて、これらのアドレスはI / Oデバイス、割り込みシステムなどへのアクセスに使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「Electronics MK-161」にeForthをインストールするには、たとえば、製造元MK.EXEのプログラムを使用して、4つのファイルを計算機に転送するだけで十分です。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eForth.mkpをプログラムメモリにページ0から書き込みます。バージョン0.5bは74ページを占有します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eForth.mkdを10進データメモリに書き込む</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eForth.mkbをバイナリデータメモリに書き込む</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eForth.mktをテキストメモリに書き込む</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
電卓に転送した後、すぐに</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらの4つのファイルを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">組み込みの「電子ディスク」の</font><b><font style="vertical-align: inherit;">別のディレクトリ</font></b><font style="vertical-align: inherit;">に</font><b><font style="vertical-align: inherit;">保存する</font></b><font style="vertical-align: inherit;">ことをお勧めし</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それらは同じ名前を持っているため、「パッケージ」として一度にすぐにeForthをダウンロードできます。</font></font><br>
<br>
<h4>2.4.1  («»)  -161: eForth.mkb</h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1000から5095までの数値のMK Electronicsレジスターは、0から255までの数値を格納するために使用されます。計算機のレジスター・メモリーのこの領域は、バイナリーと呼ばれます。 eForthから2つの連続したバイナリレジスタに単一の16ビット「セル」としてアクセスでき、（MK-161のどこでも）上位8ビットが小さい番号のレジスタにあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eForthはこの小さな「バイナリメモリ」をプライマリとして使用します。言葉は彼女と一緒に働く！ @とHEREとALLOTは、ここからのみ、アドレスインタープリターが縫合されたコードを実行します（3.2を参照）。以下は、eForth変数、テキスト入力バッファー（TIB）、辞書、およびバックスペースを実装するためのtblBSロールバックスタックです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4096バイトは、現代の標準では非常に控えめです。したがって、メモリの他の領域に可能な限りすべてのものをもたらすために多大な努力が費やされてきました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.4.2テキスト領域：eForth.mkt</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイナリメモリが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テキスト領域</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">ある直後</font><font style="vertical-align: inherit;">、5095から8167までの番号のレジスタ。これらは技術的には同じバイトレジスタですが、ディスクに書き込んだり、別のファイルとして読み取ることができるため、この領域は特別です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TLOADという単語は、eForthで「テキスト」を処理するために使用されます。</font><font style="vertical-align: inherit;">この領域全体を3072文字の文字列としてテキストインタープリターの入力に供給します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テキストを行に分割する方法について意見の相違があります。</font><font style="vertical-align: inherit;">MK Electronicsに組み込まれたエディターは、24文字の行長を要求します。</font><font style="vertical-align: inherit;">カリストは、64文字の文字列を含むFort規則を使用します。</font><font style="vertical-align: inherit;">eForthは、すべてのテキストを1つの長い行として数える選択肢をユーザーに提供します。</font><font style="vertical-align: inherit;">ビルトインエディターMK-161を使用できます。</font><font style="vertical-align: inherit;">カリストと互換性のある独自のコードを作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、便宜上、eForth.mktの初期コンテンツで、3行に分かれています。</font></font><br>
<br>
<pre><code class="plaintext hljs">: hi  ." , %user%!" CR ;<font></font>
‘ hi  ‘boot !<font></font>
hi \</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の行は、ユーザーに挨拶する新しい単語hiを定義します。</font><font style="vertical-align: inherit;">2行目は、この単語のトークン（3.1を参照）を受け取り、それを変数 'BOOT（1を参照）に入れます。</font><font style="vertical-align: inherit;">これで、テキスト領域はeForthが起動するたびにコンパイルを停止します。</font><font style="vertical-align: inherit;">代わりに、すでにコンパイルされた挨拶が実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後の行はhiという単語で始まり、画面に挨拶が表示されます。</font><font style="vertical-align: inherit;">単語\はテキストの解釈を完了し、制御をコンソールに戻します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
任意のテキストファイルをコンパイルするには、BYEコマンドを使用して計算機に移動し、メインメニューに移動して、目的のファイルをDOSモードでロードする必要があります。</font><font style="vertical-align: inherit;">コンピューターからmktファイルを転送することもできます。</font><font style="vertical-align: inherit;">C / Pキーを押すと、eForthに戻ります。その後、TLOADコマンドを使用して、テキスト領域にロードされたファイルをコンパイルできます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.4.3プログラムメモリ：eForth.mkp</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムメモリMK-161は分離されたアドレス空間です。</font><font style="vertical-align: inherit;">バイトも格納しますが、読み取り専用です。</font><font style="vertical-align: inherit;">プログラムメモリには10,000の「ステップ」が含まれていますが、これはeForthにとって冗長であることがわかりました。</font><font style="vertical-align: inherit;">プログラムメモリの4分の1以上が空きであることが判明しました。これは、トランスレータの開発に十分な予備力を与えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「コードワード」は、プログラムメモリにのみ実装できます。</font><font style="vertical-align: inherit;">また、名前認識テーブルとすべての既知のテキスト文字列がここから取り出されるため、バイナリメモリを節約できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C @、COUNT、TYPEなどの一部の単語は、アドレスが正数でない場合にプログラムメモリをアドレス指定できます。</font><font style="vertical-align: inherit;">たとえば、フレーズ0 C @は、プログラムメモリのアドレス0からの「ステップ」（バイト）としてカウントされます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.4.4 10進メモリ：eForth.mkd</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MK Electronicsのレジスタは0〜999の数値で10進数と呼ばれ、電卓での通常の計算に使用される数値（「仮数」の12桁と「順序」の2桁）が含まれています。砦は最大4バイトの整数で動作するように設計されています。そのようなリソースはeForthにとって明らかに冗長です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10進メモリは、貴重なバイナリメモリを節約するために使用されます。データとリターンのスタックはここで作成されます。単語の見出しも保存されます-ユーザー定義と埋め込みの両方、タイトルごとに1つのレジスター。このアプローチにより、標準的な名前の単語でも再定義できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10進メモリのスタックは、MK-161の砦の特徴である多くの機能につながります。まず、スタック要素の値の範囲は巨大であり、32ビット整数に対応できます。 MK-161で「2倍の整数」を使用する必要はなくなりましたが、互換性のために、対応する単語eForthを実装しました。 「二重整数」は、MK-161で、0から65535までの数値を含む2つのスタック要素として提示され、追加のコードに符号付きの単一の32ビット整数をエンコードします。この数値の上位16ビットは最上位、つまり最下位アドレスに配置されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビット単位の論理演算AND、OR、XOR、およびNOTは、引数を16ビット整数として扱います。 32768から65535の結果は、-32768から-1の負の数に変換されます。 eForthでは、falseはゼロ、trueは1でエンコードされます。また、ゼロ以外の値もtrueです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
161eForthデータスタックの2番目の機能は、符号付きの数値が含まれていることです。単語@が16ビットの「セル」から数値65535を読み取ると、自動的に-1に変換されます。</font><font style="vertical-align: inherit;">65535を直接カウントするために、プラス記号を使用して</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特別な「署名されていない」単語U @が</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供さ</font><font style="vertical-align: inherit;">れています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
速度を上げるため</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ</font><b><font style="vertical-align: inherit;">スタックの上位2つの要素は</font></b><font style="vertical-align: inherit;"> 10進メモリではなく</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、XおよびYレジスタに</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接配置され</font><font style="vertical-align: inherit;">ていることを思い出してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10進レジスターが小数および浮動小数点数を含むことができるという事実は、eForthでは使用されません。</font><font style="vertical-align: inherit;">eForth仮想マシンは、これらのレジスターを使用して、符号付き12ビット10進整数を保管します。</font><font style="vertical-align: inherit;">10進レジスタには、C @およびC！という単語でアクセスします。</font><font style="vertical-align: inherit;">-単一のレジスタで機能するものと同じもの。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.内部通訳</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コアeForthは、入力言語MK-161で書かれたプログラムです。彼女の最初のコマンドであるMAINコントロールユニットは、MAINコードに制御を移します。MAINコードは、最初に再起動の状況を検出します。間違ったトークンが原因である場合、MK-161はきしむ音を立てます。最初の起動時、およびMK-161をオンにした後も、画面はクリアされます。次に、MAINはInitサブルーチンを呼び出して、割り込みシステムおよびMK-161コンソールドライバーに必要なすべてを初期化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データスタックを初期化してリターンすると、スタートの低レベルの部分が完了します。ハーバードアーキテクチャのマシンでは、信じられないようなことが起こります。eForthは、バイトメモリから「ワイヤードコード」を実行します。最初の名誉は、R43にヘッダーアドレスが記録されている単語に属します。これは通常、COLDという単語です。</font><i><font style="vertical-align: inherit;">高レベルの単語</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
はどのように配置され</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ますか？</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（VCA）？任意の単語は、本文と見出しの2つの部分で構成されます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘッダー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は10進数で格納されます。これは、外部インタープリターと逆コンパイラーが単語の名前と本文を見つけるのに役立ちます。見出しには</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、「レキシコン」フィールド（</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外部インタープリターが検出された単語を正しく処理するのに役立つフラグのセット）</font><font style="vertical-align: inherit;">も含まれ</font><i><font style="vertical-align: inherit;">て</font></i><font style="vertical-align: inherit;">います。内部インタープリターは、バイナリー・メモリーにあり、辞書に保管されているVCA本体よりもはるかに重要です。見出しのない単語も実行できます。</font><font style="vertical-align: inherit;">VCA </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の本体は</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><i><font style="vertical-align: inherit;">ハンドラーの</font></i><font style="vertical-align: inherit;">アドレスを含む</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードフィールドの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイトで始まり</font><font style="vertical-align: inherit;">ます</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与えられた言葉。 4つのVCAハンドラーはMK-161入力言語で記述され、プログラムメモリの最初のページから始まります。それらすべてを分析します（3.3を参照）が、主なものはDOLSTと呼ばれ、コマンドMAIN BPがすでに検討された直後のアドレス02にあります。このハンドラは、コロンで定義されたフォートワードを実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールドの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイトの後には</font><i><font style="vertical-align: inherit;">、</font></i><font style="vertical-align: inherit;">任意の長さの</font><i><font style="vertical-align: inherit;">パラメータフィールドがあります</font></i><font style="vertical-align: inherit;">。 「コロンワード」のパラメーターフィールドには、「縫い付けられたコード」-一連の16ビットトークンが含まれます。各トークンは、割り当てられた1つのアクションを表します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、トークンをより詳細に検討します。</font><font style="vertical-align: inherit;">次に、1つのトークンから次のトークンの実行に移行するINEXT内部インタープリターについて検討します。</font><font style="vertical-align: inherit;">EForthはINEXTをプリミティブハンドラーと呼びます。</font><font style="vertical-align: inherit;">この内部インタープリターのツアーは、4つのIEDプロセッサーすべてを分析することで終わります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1トークン</font></font></h3><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トークン</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、縫い付けられたコードとスタック内の単語を表し、すばやく実行できるようにします。</font><font style="vertical-align: inherit;">トークンは単語の本文へのポインタですが、MK-161の厳しいアーキテクチャは、この単純なアイデアに対して独自の調整を行いました。</font><font style="vertical-align: inherit;">プリミティブトークンから始めて、すべてのタイプのトークンを分析しましょう。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1.1プリミティブトークン</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eForthディストリビューションに含まれるすべての単語には、0から206までの番号が付けられます。この番号付けは、プリミティブとVCAの両方を考慮して、エンドツーエンドです。これは、単語の番号によって彼の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を復元するのが簡単になるように行われ</font><font style="vertical-align: inherit;">ます。これらの名前はプログラムメモリに保存されます。目的の名前へのリンクは、ヘッダーテーブルから簡単に見つけることができます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリミティブ番号はそのトークン</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。他のトークンと同様に、プリミティブは縫い付けられたコードで2バイトを使用します。最初はゼロです。 2番目には彼の番号が含まれています。 tblTokensテーブルを使用すると、この番号でプリミティブコードのアドレスをすばやく見つけることができます。 tblTokensアドレスはR9042（2.2を参照）に永続的に保存されます。つまり、プリミティブを実行するためにすべてが常に手元にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XT&gt;という単語を使用すると、プリミティブコードのアドレスをその番号（トークン）で見つけることができます。</font><font style="vertical-align: inherit;">プリミティブのコードは常にプログラムメモリ内にあるため、受信アドレスは常に負になります（2.4.3を参照）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1.2 VCAトークン</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VCAは、独自の番号と関連付けられた標準名を持つことも、ユーザーが作成した完全に新しいものにすることもできます。</font><font style="vertical-align: inherit;">すべての場合において、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VCAトークンはそのコードフィールド</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（3を参照）</font><b><font style="vertical-align: inherit;">のアドレス</font></b><font style="vertical-align: inherit;">、つまり1000から5095までの数値です</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。</font><font style="vertical-align: inherit;">縫製</font><font style="vertical-align: inherit;">コードでは、VCAトークンは非常に珍しい方法で書き込まれます。</font><font style="vertical-align: inherit;">百の数（10から50までの数）は最初のバイトに書き込まれ、残りはトークンを100で除算した残り（0から99までの数）が2番目のバイトに書き込まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、トークン1234は2バイトの12と34で表されます。これと他のトークンのコンパイルは、ANSI標準から取られた単語COMPILEを使用して実行されます。</font><font style="vertical-align: inherit;">縫製コードでVCAトークンを読み書きするには、XT！</font><font style="vertical-align: inherit;">およびXT @。</font><font style="vertical-align: inherit;">それらはアドレスにアクセスし（3.1.4を参照）、XT @という単語もプリミティブトークンを読み取ることができます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1.3整数リテラル</font></font></h4><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リテラル全体</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、一種のプリミティブトークンです。</font><font style="vertical-align: inherit;">それらは、個別に検討するのに十分珍しいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
縫製コードでは、DOLITトークンとDOLITMトークンが4バイトを占めます。</font><font style="vertical-align: inherit;">最初の2バイトには、すでに考慮されているプリミティブトークン、つまり0とプリミティブの番号が含まれています。</font><font style="vertical-align: inherit;">次の2バイトには、指定されたリテラルが実行時にデータスタックに配置される整数が含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DOLITMは、スタックに配置する前に数値の符号を変更する点が異なります。</font><font style="vertical-align: inherit;">負の数を実装するように設計されています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1.4アドレスリテラル</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全体のリテラルと同様に、3つの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アドレスリテラル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> BRANCH 、? BRANCH、およびDONXTは、縫合されたコードでそれぞれ4バイトを占有します。最初の2バイトにはプリミティブトークンが含まれ、最後の2バイトはジャンプアドレスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アドレスは、VCAトークンと同じ形式で書き込まれます（3.1.2を参照）。最初のバイトには数百の数が含まれ、2番目のバイトにはアドレスを100で割った残りが含まれます。誇張（2.1を参照）により、遷移アドレスには目的のトークンのアドレスが含まれず、1だけ少ない数が含まれていることを思い出します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DONXTトークンは、FOR-NEXTの「終了サイクル」の実装に役立ちます（1を参照）。</font><font style="vertical-align: inherit;">無限のBEGIN-AGAINループを実装するには、BRANCH無条件ジャンプが必要です。</font><font style="vertical-align: inherit;">条件付きジャンプ？BRANCHは、ゼロがデータスタックの先頭にある場合（「false」）に制御を移します。</font><font style="vertical-align: inherit;">条件付きIF-THENステートメントを実装し、「無限ループ」のBEGIN-UNTILおよびBEGIN-WHILE-REPEATを終了します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1.5文字列リテラル</font></font></h4><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文字列リテラル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、VCAトークンの一種です。</font><font style="vertical-align: inherit;">文字列リテラルの縫製コードでは、トークンの後に、文字列の長さのバイトがあり、その後に最初のバイトから最後のバイトまでの文字列自体があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EForthには3つの文字列リテラルがあります：$ "| ,." | </font><font style="vertical-align: inherit;">とアボート "|。これらは、それぞれeForth0.mklファイルでSTRQP、DOTQP、ABORQトークンとして定義されています。メインのリテラル"作業は、DO $、DOSTRトークンという単語によって行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事のサイズを妥当なものにするために、あまり詳しく説明しませんこの興味深いトピックですが、eForthでの可用性について知っておくと便利です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2アドレスインタプリタ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今</font><font style="vertical-align: inherit;">こそ、アドレスが常にレジスター9に書き込まれ</font><font style="vertical-align: inherit;">て</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いるトークン・インタープリター</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を検討</font><i><font style="vertical-align: inherit;">する</font></i><font style="vertical-align: inherit;">とき</font><font style="vertical-align: inherit;">です。ほとんどのプリミティブは、制御をINEXTラベルに移すコマンドK BP 9で作業を終了します。</font></font><br>
<br>
<pre><code class="plaintext hljs">INEXT: 6 Fx≠0 NPrime<font></font>
NData:  2 6 + 7 F⟳<font></font>
7 8 F⟳ 8</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、アドレスインタープリターは、KIP6コマンドで次のトークンの最初のバイトを読み取ります。ゼロの場合、これはプリミティブであり、NPrimeというラベルのコードがトークンを処理します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ラベルNDataは、VCAトークンの処理を示します。最初のバイトはVP 2コマンドで100倍され、その後KIP6 +はトークンの2番目のバイトを結果に追加します（3.1.2を参照）。読み取りトークンは、P7チームによってWP（R7）の「ワーキングレジスタ」に入力されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VCAトークンは、プロセッサのアドレスを含むコードフィールドのアドレスであることがわかっています。 KIP7 P8コマンドはR8のコードフィールドのバイトを読み取り、KBP8コマンドは制御をVCAプロセッサに転送します。プロセッサーは、R7に、処理中のワードのパラメーターフィールドのアドレスよりも1少ない数値が含まれていることを認識しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード25のコマンドF⟳は、スタック上で「整理」されています。実際、eForthはデータスタックの上位2つの要素をMK-161スタックのXおよびYレジスタに直接格納します。このようなソリューションは作業をスピードアップしますが、これらの重要なデータが失われないようにする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アドレスインタプリタがプリミティブをどのように実行するかを理解する必要があります。</font></font><br>
<br>
<pre><code class="plaintext hljs">NPrime: F⟳ 6 9210 8 F⟳ 8</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
KIP6コマンドは、プリミティブトークンの2番目のバイトを読み取ります。</font><font style="vertical-align: inherit;">RRP9210 P8コマンドはこのプリミティブのアドレスをtblTokensテーブル（2.2および3.1.1を参照）から読み取り、KBP8は制御をこのプリミティブに転送します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のように、F⟳はスタックから余分な部分を取り除き、XレジスタとYレジスタの内容を復元します</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eForthアドレスインタープリターは非常に小さいため、プログラムメモリで数回複製されます。</font><font style="vertical-align: inherit;">メインコピーはコマンドK BP 9によって実行され、ほとんどのプリミティブが完成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
演習として、EXECUラベルの後にあるEXECUTEという単語の実装を調べることをお勧めします。</font><font style="vertical-align: inherit;">これはINEXTバリアントであり、縫合されたコードからではなくトークンを読み取りますが、データスタックから取得します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3 VCAハンドラー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4種類のVCAには、DOLST、DOVAR、DOCON、およびDOCONMの4つの異なるハンドラーがあります。</font><font style="vertical-align: inherit;">ハンドラーを呼び出す前のアドレスインタープリターが、処理されたワードのコードフィールドのアドレスをR7に残すことは既に確認しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eForth.fは、eForth0.mkpファイルからカーネルヘッダーを読み取ることにより、これらのハンドラーのアドレスを学習します。</font><font style="vertical-align: inherit;">これは、結果をeForth.mkbファイルに配置することにより、MK-161 ElectronicsのVCAを正しくコンパイルするのに役立ちます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3.1コロンの単語：DOLSTおよびEXIT</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
INEXTに続く次の重要なトピックは、コロンで定義された単語のトークンに遭遇したときに内部インタープリターが行うことです。</font><font style="vertical-align: inherit;">そのような単語のコードフィールドには数値2が含まれているため、INEXTは制御をDOLSTハンドラーに移します。DOLSTハンドラーは、トークンの新しいリストの解釈を開始するために必要な作業を行います。</font></font><br>
<br>
<pre><code class="plaintext hljs">DOLST: 6 2 F⟳<font></font>
7 6 F⟳<font></font>
INEXT:</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに説明したように（2.1を参照）、レジスター2にはRP戻りスタックポインターが含まれています。 IP6 KP2コマンドは、解釈ポインター（IP）であるR6の値を戻りスタックに書き込みます。後でこれは、INEXTがコロンの単語に出くわしたトークンの古いリストの現在の位置を思い出すのに役立ちます。ここで、IP7 P6はIPを新しいリストの先頭に再配置します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DOLSTコードの直後にINEXTコードが配置され、新しいトークンリストの最初の単語が実行されます。他の場所と同様に、Fコマンドは、データスタックの上位2つの要素を維持するのに役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コロンワードは通常、EXITTトークンで終わります。これは、DOLSTと比較すると逆の働きをします。リターンスタックから古いIP値を受け取り、古いトークンリストの解釈に戻ります。</font></font><br>
<br>
<pre><code class="plaintext hljs">EXITT: 02 6 x 1 2 + 2 F⟳<font></font>
INEXT:</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コマンドRKIP02 P6は、戻りスタックの最上部から古いIP値を読み取ります（2.1を参照）。</font><font style="vertical-align: inherit;">その後、Cx 1 IP2 + P2チームはRP値を修正し、RP値を1増やします。</font><font style="vertical-align: inherit;">F⟳コマンドはスタックを復元し、その後INEXTは古いトークンリストから次のワードを実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、INEXTは、DOLSTの後とEXITTの後の両方に同時に移動することはできません。</font><font style="vertical-align: inherit;">これを行うために、私はソ連の時代からの1つの古代のトリックを適用しました。</font><font style="vertical-align: inherit;">また、eForth0.mklファイル内の対応する行を調べることによって、それを習得することもできます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3.2 DOVAR、変数、配列ハンドラー</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CREATEとVARIABLEという単語によって生成された単語は、同じDOVARハンドラーを使用します。</font><font style="vertical-align: inherit;">このハンドラは、コードフィールドのバイトの直後に続くパラメータフィールドにある変数のアドレスをスタックにプッシュします。</font><font style="vertical-align: inherit;">VARIABLE変数は2バイトを占め、CREATEを使用して作成された配列には、プログラマーが必要なだけのバイトが含まれます。</font></font><br>
<br>
<pre><code class="plaintext hljs">DOVAR: ⇔ 3 x 1 7 + 9</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コマンド⇔KP3は、レジスタYの内容をデータスタックに保存すると同時に、スタックの先頭からの数がRYに入力され、RXを新しい値に解放します。</font><font style="vertical-align: inherit;">Cx 1 IP7 +コマンドの後、スタックの一番上のこのアドレスは、実行可能ワードのパラメーターフィールドのアドレスになります。</font><font style="vertical-align: inherit;">KBP9は制御をINEXTに転送します。トリックは行われず、次の単語に進みます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3.3定数ハンドラ：DOCONおよびDOCONM</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DOVARとは異なり</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、定数ハンドラー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はその単語自体のパラメーターフィールドにアクセスします。 DOCONは16ビットの定数値を読み取ります。この値は常に正です。</font></font><br>
<br>
<pre><code class="plaintext hljs">DOCON: ⇔ 3 ⇔<font></font>
7 5 x 256<font></font>
5 × 5 + 9</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コマンド⇔KP3⇔RYをデータスタックに保存します。しかし今回は、データスタックの古いトップがRXに戻ります。定数の値を読み取るためにポインターレジスタR5を準備している間、IP7 P5コマンドはそれを強制的にRYに戻します。次に、Cx 256はレジスタXのゴミを数値256に置き換えます</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。Instruments KIP5×KIP5 +は、定数をパラメーターフィールドからデータスタックの最上部、つまりRXに読み取ります。思い出すと、MK-161では、最初のバイトは常にハイです。これに256を掛けた後、定数の最下位バイトが製品に追加されます。すべての作業が完了すると、KBP9は制御を次のワードに移します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DOCONMは同じように機能し、反対の変更を読み取った後の定数記号のみです。負の定数は、速度のために独立したプロセッサとしてMK-161に実装されています。</font></font><br>
<br>
<pre><code class="plaintext hljs">DOCONM: ⇔ 3 ⇔<font></font>
7 5 x 256<font></font>
5 × 5 + /-/ 9</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、eForthがデータ領域からMK-161 Electronicsでコードを実行する方法を完全に理解しました。文字列リテラルのより深いトピック（3.1.5を参照）にも触れました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シリーズの2番目の記事では、外部「テキスト」インタープリター161eForthについて話し、ヘッダーテーブルの構造と名前認識を分析します。</font><font style="vertical-align: inherit;">翻訳者のこの部分は、上記で議論された伝統的な砦、古くて良いものを背景にして、私ははるかに根本的な解決策を開発することを要求しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハッピーフォートプログラミング！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文献</font></font></h2><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">博士 </font><font style="vertical-align: inherit;">チェン・ハンソン・ティン。</font><font style="vertical-align: inherit;">eForthおよびZen-2017年第3版。AmazonKindleで利用できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バラノフS.N.、ノズドロノフN.R. </font><font style="vertical-align: inherit;">フォート言語とその実装。</font><font style="vertical-align: inherit;">-L。：機械工学。</font><font style="vertical-align: inherit;">レニングラ。</font><font style="vertical-align: inherit;">1988年。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セメノフ・ユア </font><font style="vertical-align: inherit;">FORT言語でのプログラミング。</font><font style="vertical-align: inherit;">-M。：ラジオと通信、1991年。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANSフォース規格。</font><font style="vertical-align: inherit;">X3.215-1994。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SP-Forthドキュメンテーション</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offeteストア（Chen-Hanson Ting博士の議事録）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Windows用86eForth v5.2、英語のドキュメントをダウンロードできます。</font></font></li>
</ol><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオイラスト</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの4つの小さな161eForthビデオは続きます。</font><font style="vertical-align: inherit;">記事の最初の最初のビデオ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5のパート2。TEST-TEST4は、MK-161の本「eForth and Zen」第3版からのテストです。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/7UuQSozjuJ8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5のパート3。SEE逆コンパイラ。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/K-mWJuL1fiQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5のパート4。ブレークポイントBYE、RS-232端末、およびMK-161へのリモートアクセス。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Cfj60ICJrHU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5のパート5。最後の言葉。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/oAAX29TpH9c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja452384/index.html">プロセッサは、光学系を800 Gb /秒に加速します。</a></li>
<li><a href="../ja452388/index.html">O（n）を超えたエラトステネスのふるい。証拠</a></li>
<li><a href="../ja452390/index.html">ソフトウェア無線-それはどのように機能しますか？パート3</a></li>
<li><a href="../ja452392/index.html">機械学習データセットの選択</a></li>
<li><a href="../ja452394/index.html">Опусы про Его Величество Клей. Часть вторая — Viva, цианоакрилат! Viva, суперклей</a></li>
<li><a href="../ja452400/index.html">効果のないビジネス</a></li>
<li><a href="../ja452402/index.html">アナログトンネルダイオードの実験</a></li>
<li><a href="../ja452404/index.html">今年の5つの主要なITSMトレンド</a></li>
<li><a href="../ja452408/index.html">メインクーントイレ</a></li>
<li><a href="../ja452410/index.html">バッシュ発売の詳細</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>