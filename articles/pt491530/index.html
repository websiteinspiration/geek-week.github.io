<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏾 🏆 🙍 Mais uma vez cerca de 433 MHz transmissores e receptores 🧗🏽 🕺🏾 👨‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O conjunto mais simples de receptor e transmissor ISM de 433 MHz ganhou popularidade merecida entre os amantes de eletrônicos. Os kits são baratos (me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Mais uma vez cerca de 433 MHz transmissores e receptores</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491530/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O conjunto mais simples de receptor e transmissor </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><font style="vertical-align: inherit;">433 MHz ganhou popularidade merecida entre os amantes de eletrônicos. Os kits são baratos (mesmo no Chip-Deep você pode comprá-los por 300 rublos, e no Ali, dizem eles, geralmente por cinquenta dólares), são simples e confiáveis. Além disso (que você provavelmente não suspeita), este é o método mais abrangente e penetrante de troca de dados sem fio - um sinal a uma frequência de 433 MHz passa muito melhor por obstáculos e opera a uma distância maior do que na popular faixa de 2,4 GHz (433 O MHz é </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">completamente atrasado por uma</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parede de meio metro de concreto e o Wi-Fi já está morrendo 10 centímetros). Eu admito que apareceu recentemente módulos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MBee-868</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por estarem equipados com uma antena (direcional) apropriada, eles “disparam” ainda mais, mas são pelo menos uma ordem de magnitude mais cara, mais difícil de conectar, exigem gerenciamento e pré-configuração de economia de energia. </font><font style="vertical-align: inherit;">Além disso, a frequência de 868 MHz passa por obstáculos duas vezes mais ruins (embora, é claro, seja incomparavelmente melhor que a frequência de 2,4 GHz). </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a04/2bb/c3c/a042bbc3ca312c739041b507e7ca4b5e.png" width="500"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muito foi escrito sobre transmissores e receptores de 433 MHz (inclusive no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hub)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , é claro. </font><font style="vertical-align: inherit;">No entanto, parece que ninguém sabe como incluir corretamente este kit no circuito por algum motivo estranho. </font><font style="vertical-align: inherit;">Quando mais uma vez li </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que o kit “ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tinha 8 metros dentro da linha de visão, o 9º metro não podia ser dominado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">", Minha paciência estalou. </font><font style="vertical-align: inherit;">Que outros 8 metros ?! </font><font style="vertical-align: inherit;">Aos 40-50, eu teria acreditado, embora, na realidade, provavelmente, o alcance seja ainda maior.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vale a pena notar que eu resolvo ainda mais o problema de criar uma linha para transferência de dados arbitrários, e não apenas controlar quaisquer tomadas inteligentes ou modelos de barcos a motor. Minha tarefa é mais complicada, mas ainda assim a distância da operação confiável é muito maior. Além disso, em uma tarefa como essa, é importante não apenas e não tanto a distância dentro da linha de visão (pode servir apenas para comparação), mas a capacidade de penetrar em vários obstáculos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meu kit trabalha fora da cidade a uma distância de cerca de 25 a 30 metros em um ângulo agudo em relação à parede de toras, de modo que aproximadamente um metro (no total) de paredes e divisórias, parcialmente protegidas pelo isolamento da película, esteja no caminho do sinal. A uma distância muito menor, quase diretamente atrás da parede, o WiFi já está perdendo completamente o sinal. Na cidade, o sinal termina de uma extremidade a outra de um apartamento urbano de três quartos através de duas divisórias internas, bem como da varanda, onde em uma linha reta entre o transmissor e o receptor pelo menos 80 centímetros de alvenaria e uma partição de gesso. Não usei opções de kit mais caras mencionadas na análise acima.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma vantagem adicional do kit é que, em pausas, o transmissor não consome nada e sem modos especiais de suspensão, simplesmente pelo princípio de seu dispositivo (a corrente de consumo em repouso é comparável às correntes de fuga do coletor de um transistor bloqueado, ou seja, cerca de 100 nA). </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver quais são as armadilhas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conexão do transmissor</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O transmissor (chamado FS1000A), como podemos ver no diagrama abaixo, é o gerador mais simples baseado em um ressonador SAW de 433 MHz. </font><font style="vertical-align: inherit;">O gerador é montado no transistor Q1, e o transistor Q2, com base no qual os dados digitais são fornecidos, é simplesmente uma chave que conecta o gerador à energia (ao barramento GND) na presença de um nível alto (unidade lógica) na entrada. </font><font style="vertical-align: inherit;">A energia pode variar de 5 a 12 volts e, de acordo com os fabricantes, quanto maior a energia, mais a conexão funciona.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a21/50c/737/a2150c737eb648ed465e060aa2d178ae.png" width="400"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não notei as vantagens fundamentais do aumento da nutrição como parte da minha tarefa. No entanto, não se deve negligenciar o fato de que não há requisitos especiais de energia aqui e, com o aumento da tensão, o dispositivo só funcionará melhor. É conveniente conectar o transmissor diretamente à voltagem de um adaptador de 9-12 volts, bateria ou um conjunto de 6 baterias (pino Vin Arduino). Com uma fonte de alimentação não estabilizada, que pode exceder 12 volts (como, por exemplo, com baterias), costumo desacoplar o transmissor do circuito principal com um estabilizador de 9 volts separado (você pode usar o 78L09 mais simples) e não vejo diferença na operação entre os 9 e 12 volts. Com o Uno ou o Nano, você pode usar o estabilizador de 5 volts incorporado para alimentar o próprio controlador e outros circuitos (por exemplo, sensores)e para o Mini (especialmente seus clones baratos), aconselho a colocar um estabilizador de 5 volts separado, conectando-o ao pino de 5V.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deve-se notar que recentemente surgiram transmissores que parecem um pouco fora do padrão (veja a Fig. Abaixo). Aconteceu que a ausência de um acelerador L1 (três voltas), do qual restavam apenas orifícios - uma ficção, foi simplesmente substituída pelo componente SMD correspondente. O pior nesta opção é diferente: a impressão superficial pode ser enganosa em relação à conexão dos pinos e da alimentação de dados. A conexão correta é mostrada na figura, é a mesma para todas as opções:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/db4/cfc/e17/db4cfce176c768cc5f3504edfbf91513.png" width="250"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O mais impressionante nesse assunto é que, quando os dados e a energia são misturados, o transmissor continua a trabalhar em distâncias curtas! </font><font style="vertical-align: inherit;">Se você olhar para o circuito, entenderá o que é: a base Q2 através do resistor está conectada à fonte de alimentação, o transistor está sempre aberto e não afeta a operação do circuito. </font><font style="vertical-align: inherit;">Um nível lógico alto no barramento de força apenas liga o gerador no momento certo. </font><font style="vertical-align: inherit;">Os absurdos começam a certa distância - é claro que, a partir de uma conclusão lógica, a fonte de energia é ruim.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conexão do receptor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao comprar um receptor (pode ser chamado MX-RM-5V ou XD-RF-5V), preste atenção ao comprimento dos terminais - de alguma maneira encontrei um lote inteiro com pinos encurtados, o que fez com que o </font><font style="vertical-align: inherit;">receptor caísse </font><font style="vertical-align: inherit;">do conector </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PBS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> padrão </font><font style="vertical-align: inherit;">com a menor distorção e sua Eu tive que me conectar especificamente ao quadro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O circuito do receptor é muito mais complicado (não o reproduzirei, mas você pode encontrá-lo, por exemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Ele deve receber e amplificar um sinal de alta frequência, filtrar a frequência de 433 MHz, isolar rajadas e convertê-las em níveis lógicos. O receptor possui um afunilamento de sintonia (no meio da placa), mas sem instrumentos precisos para medir as características de amplitude-frequência, eu não recomendo torcer - provavelmente, você não melhorará nada, mas apenas o estragará.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como já a uma pequena distância o sinal terá muito menos interferência, é claro que devemos lidar com a interferência em todas as frentes: e métodos de circuitos e software. As bibliotecas fazem a última coisa para nós, mas não importa qual matemática seja usada no processamento de software, é aconselhável fazer tudo primeiro para que a unidade lógica na saída apareça apenas quando um sinal útil explodir e não aparecer na presença de interferência. Em outras palavras, seria bom sintonizar ao máximo antecipadamente as interferências durante a recepção.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O método padrão de redução de ruído, conhecido em minha época por todo aluno que montou pelo menos um rádio ou amplificador, é que, para os nós sensíveis à interferência, é necessário fazer uma fonte de alimentação separada, isolada ao máximo de outros circuitos. Você pode fazer isso de maneiras diferentes: depois de instalar um diodo zener separado, agora eles isolam a potência de um nó problemático com um filtro LC (isso é recomendado, por exemplo, para ADCs, consulte as fichas técnicas dos controladores AVR). Porém, em nossas condições, quando os componentes modernos são pequenos e baratos, é mais fácil colocar um estabilizador separado do restante no receptor.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bd3/85b/94a/bd385b94af583fa8c188053297965c1b.png" width="400"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um estabilizador, por exemplo, do tipo LP2950-5.0 mais dois capacitores necessários para ele na opção mais barata (quando os dois capacitores são de cerâmica, na faixa de 1-3,3 microfarads), adicionará sessenta no máximo ao custo do seu circuito. Mas prefiro não economizar: na saída coloquei uma cerâmica comum e na entrada coloquei um eletrólito (10 a 100 microfarads), além disso, no estado sólido (polímero) ou tântalo. Os capacitores de cerâmica podem ser dispensados ​​lá e ali, se a tensão de entrada de 7 a 12 volts vier de baterias ou de outro estabilizador analógico. Fontes estabilizadas pulsadas e os retificadores não estabilizados mais simples requerem filtragem adicional. Você pode usar eletrólito de alumínio barato se colocar um micro-radar 0,1 de cerâmica paralelo a ele,é ainda melhor colocar uma indutância em série na entrada de várias frações ou unidades de miligenri.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O estabilizador deve ser instalado diretamente próximo ao receptor, o comprimento dos condutores deve ser mínimo. Em vez do LP2950, ​​você pode usar o LM2931 ou similar com uma pequena tensão de passagem (isso é especialmente importante se o circuito for alimentado por baterias - para um LM78L05 regular, a tensão de entrada deve ser de pelo menos 7,5 e, de preferência, de 8 a 9 volts).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comparando com o caso de alimentar o receptor diretamente do Arduino, como recomendado em todas as publicações (não vi exceções), você ficará surpreso com o efeito obtido - o alcance e a capacidade de penetrar pelas paredes imediatamente aumentam significativamente. O receptor, juntamente com o estabilizador, pode ser realizado em uma pequena caixa separada por conveniência. Você pode conectar sua saída ao controlador no corpo principal com qualquer fio de três fios (duas fontes de alimentação e um condutor de sinal) de até 3 metros de comprimento e talvez mais. Isso é mais conveniente porque as antenas ainda são necessárias e, de acordo com as regras, será melhor que elas sejam paralelas uma à outra no espaço, e nem sempre é possível colocar caixas grandes para que as antenas fiquem na orientação correta.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na versão mais simples, como antenas, você pode fazer com pedaços de fio de núcleo único com uma seção transversal de pelo menos 0,5 mm e comprimento de 17 cm ± 1-3 mm. </font><font style="vertical-align: inherit;">Não use fios de montagem trançados! </font><font style="vertical-align: inherit;">Antenas espirais mais compactas estão à venda, mas eu pessoalmente não testei sua eficácia. </font><font style="vertical-align: inherit;">A ponta da antena do transmissor e do receptor é selada no orifício correspondente no canto da placa (não se engane na versão atualizada do transmissor - a palavra ANT também está fora do lugar, veja a fig. Acima).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geração e processamento de dados transmitidos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa é a segunda grande desvantagem da maioria das revisões sobre o nosso tópico: os autores limitam-se a algum problema local, sem formulá-lo de uma maneira geral, como transferir dados arbitrários em um pacote. Como você entendeu a partir da descrição acima, apenas uma sequência simples de bits pode ser transmitida pelo nosso conjunto. A biblioteca padrão do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VirtualWire os</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> codifica de maneira especial (cada tetrad é codificado com 6 bits, um cabeçalho de sincronização é adicionado na frente e uma soma de verificação para todo o pacote é adicionada) e transforma a saída em uma seqüência de bytes mais familiar. Mas o programador já tem que lidar com isso sozinho.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, assumimos que o transmissor e o receptor estão conectados ao Arduino. Além do VirtualWire, em conexão com o boom das “casas inteligentes”, existem muitas outras coisas, como o RC-Switch ou o RemoteSwitch, mas eles estão focados em outras tarefas, e claramente não vale a pena usá-los para transferir dados arbitrários. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O comprimento máximo de uma única mensagem no VirtualWire é de 27 bytes (consulte a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). A transmissão de uma mensagem completa (é complementada automaticamente com uma assinatura 0xb38, um valor de comprimento de mensagem e uma soma de verificação) na velocidade escolhida de 1200 bps é de 0,35 segundos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quanto mais, a propósito, a velocidade de transmissão selecionada, o alcance da transmissão será menor. Com a experiência de usar o RS-232, sabe-se que, com o alcance crescente, a velocidade de transmissão permitida diminui exponencialmente: a uma velocidade de 19.200, uma linha não blindada percorre 15 metros, 9600 - 150 metros e a uma velocidade de 1200 - mais de um quilômetro. Seria interessante descobrir experimentalmente a natureza dessa dependência para o nosso caso, porque muito aqui depende da matemática usada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A inicialização do transmissor no VirtualWire é assim:</font></font><br>
<br>
<pre><code class="cpp hljs">. . . . .
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;VirtualWire.h&gt;</span></span><font></font>
. . . . .<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{<font></font>
  vw_setup(<span class="hljs-number">1200</span>); <span class="hljs-comment">//   VirtualWire</span>
  vw_set_tx_pin(<span class="hljs-number">10</span>);   <span class="hljs-comment">//   VirtualWire D10</span><font></font>
. . . . .<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Analisaremos os princípios da geração de dados usando um exemplo específico. Vamos ter um sensor remoto de temperatura e umidade. Fornece valores (variáveis ​​de temperatura e umidade) na forma de um número real com um sinal (float). Para facilitar a compreensão no final de recebimento, todos reduziremos para um número inteiro positivo com o número de casas decimais de pelo menos 4, converteremos os bits individualmente em caracteres ASCII, transferiremos a string resultante e executaremos operações reversas no final de recebimento. Obviamente, você pode simplificar a tarefa (por exemplo, sem conversão para ASCII e encurtar os números), mas dessa forma acaba sendo o mesmo para quase todos os tipos de dados digitais, o que simplifica a desmontagem ao receber. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na prática, é conveniente usar o tipo String para compor uma mensagem, algo como isto:</font></font><br>
<br>
<pre><code class="cpp hljs">. . . . .
<span class="hljs-comment">//    </span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ledPin 13 <span class="hljs-comment">//  (D13,  19 ATmega) </span></span>
<span class="hljs-keyword">char</span> msg[<span class="hljs-number">13</span>];
<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> tmpr=<span class="hljs-number">0</span>;
<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> hum=<span class="hljs-number">0</span>;<font></font>
. . . . .<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{<font></font>
  delay(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 1 c</span>
<span class="hljs-keyword">float</span> temperature;
<span class="hljs-keyword">float</span> humidity;<font></font>
. . . . .  <span class="hljs-comment">//   temperature  humidity  </span>
<span class="hljs-comment">//       4 :</span>
  tmpr = temperature*<span class="hljs-number">10</span>+<span class="hljs-number">2731</span>; <span class="hljs-comment">//2731 =     </span>
<span class="hljs-comment">//    4 :</span>
  hum = humidity*<span class="hljs-number">10</span>+<span class="hljs-number">1000</span>; 
<span class="hljs-comment">//  :</span>
  digitalWrite (ledPin,HIGH); <span class="hljs-comment">//  —  </span>
  String strMsg=<span class="hljs-string">"DAH"</span>; <span class="hljs-comment">// - </span>
  strMsg+=tmpr; <span class="hljs-comment">//  </span>
  strMsg+=hum; <span class="hljs-comment">// </span>
  strMsg.toCharArray(msg,<span class="hljs-number">12</span>); <span class="hljs-comment">//   , 12 –  </span>
<span class="hljs-comment">//  :</span>
  vw_send((<span class="hljs-keyword">uint8_t</span> *)msg, <span class="hljs-built_in">strlen</span>(msg)); <span class="hljs-comment">//  </span>
  vw_wait_tx(); <span class="hljs-comment">//   </span>
  delay(<span class="hljs-number">500</span>); <span class="hljs-comment">// 500 </span>
  digitalWrite (ledPin, LOW); <span class="hljs-comment">//  —  </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você precisar transferir números mais precisos com um grande número de dígitos, basta aumentar o comprimento da matriz msg. As variáveis ​​globais “voláteis” tmpr e hum são necessárias se você calcular a média de várias leituras, caso contrário, elas também podem ser declaradas locais dentro da função loop (). A mensagem, como você vê, consiste nos valores convertidos de temperatura e umidade, em cadeias ASCII de quatro bytes cada, precedidas por uma cadeia de três caracteres “DAH” (os caracteres podem ser outros da tabela ASCII). Essa é uma assinatura que permitirá que você diferencie essa mensagem entre as possíveis outras enviadas por dispositivos semelhantes. Não negligencie a assinatura, mesmo se você acredita que outros dispositivos próximos a esse intervalo não são esperados, ao mesmo tempo em que serve como uma garantia adicional da integridade dos dados recebidos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe também que, ao converter uma string em uma matriz, você deve especificar um caractere a mais que o comprimento total da mensagem (3 + 4 + 4 = 11), isso leva em consideração o caractere zero que fecha a string. </font><font style="vertical-align: inherit;">E o tamanho da matriz msg [] deve ser especificado com uma margem e pode ser qualquer, neste caso de 13 a 27 bytes. </font><font style="vertical-align: inherit;">Ao transferir, ele ainda será enviado exatamente como a função strlen (msg) retornará, ou seja, 11 bytes + um caractere nulo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na parte receptora, a matriz resultante de códigos ASCII deverá ser analisada. </font><font style="vertical-align: inherit;">Mas primeiro você precisa aceitá-lo. </font><font style="vertical-align: inherit;">Para inicializar a recepção, são executadas as seguintes ações:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;VirtualWire.h&gt;</span></span>
<span class="hljs-keyword">char</span> str[<span class="hljs-number">5</span>];     ASCII  
  <span class="hljs-keyword">uint8_t</span> buf [VW_MAX_MESSAGE_LEN];  <span class="hljs-comment">//    </span>
  <span class="hljs-keyword">uint8_t</span> buflen = VW_MAX_MESSAGE_LEN;  <span class="hljs-comment">// max   </span><font></font>
. . . . .<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{<font></font>
  vw_set_rx_pin(<span class="hljs-number">2</span>); <span class="hljs-comment">//D2   VirtualWire</span>
  vw_setup(<span class="hljs-number">1200</span>); <span class="hljs-comment">//   VirtualWire</span><font></font>
. . . . .<font></font>
} <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na verdade, a técnica para analisar uma linha é a seguinte:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{<font></font>
  vw_rx_start();  <span class="hljs-comment">//  </span>
  buflen = VW_MAX_MESSAGE_LEN; <span class="hljs-comment">//    </span>
 <span class="hljs-keyword">if</span> (vw_have_message()) { <span class="hljs-comment">// </span>
 <span class="hljs-keyword">if</span> (vw_get_message(buf, &amp;buflen)) <span class="hljs-comment">//   </span><font></font>
  {<font></font>
    vw_rx_stop(); <span class="hljs-comment">//   :</span>
        <span class="hljs-keyword">for</span> (byte i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++)  <span class="hljs-comment">//    </span>
                str[i]= buf[i]; <span class="hljs-comment">// </span>
                str[<span class="hljs-number">3</span>]=<span class="hljs-string">'\0'</span>;
      <span class="hljs-keyword">if</span> ((str[<span class="hljs-number">0</span>]==<span class="hljs-string">'D'</span>)&amp;&amp;(str[<span class="hljs-number">1</span>]==<span class="hljs-string">'A'</span>)&amp;&amp;(str[<span class="hljs-number">2</span>]==<span class="hljs-string">'H'</span>)) {
<span class="hljs-comment">// ,  </span>
       <span class="hljs-keyword">for</span> (byte i=<span class="hljs-number">3</span>;i&lt;<span class="hljs-number">7</span>;i++)  <span class="hljs-comment">//    </span>
                str[i<span class="hljs-number">-3</span>]= buf[i]; <span class="hljs-comment">//    </span>
      <span class="hljs-keyword">int</span> tmpr=atoi(str); <span class="hljs-comment">//   </span>
      tmpr=tmpr<span class="hljs-number">-2731</span>; <span class="hljs-comment">// 2731,     </span>
. . . . .<span class="hljs-comment">//    10    float,  </span>
. . . . . <span class="hljs-comment">//    -</span>
<span class="hljs-comment">// :</span>
      <span class="hljs-keyword">for</span> (byte i=<span class="hljs-number">7</span>;i&lt;<span class="hljs-number">11</span>;i++)  <span class="hljs-comment">//    </span>
                str[i<span class="hljs-number">-7</span>]= buf[i]; <span class="hljs-comment">//    </span>
      <span class="hljs-keyword">int</span> hh = atoi(str); <span class="hljs-comment">//   </span>
      hh=(hh<span class="hljs-number">-1000</span>)/<span class="hljs-number">10</span>;
      <span class="hljs-keyword">if</span> (hh&gt;<span class="hljs-number">99</span>) hh=<span class="hljs-number">99</span>; <span class="hljs-comment">//   %,  </span>
. . . . . <span class="hljs-comment">// -</span>
   } <span class="hljs-comment">//end   DAT</span>
  } <span class="hljs-comment">//end  </span>
 } <span class="hljs-comment">// </span>
} <span class="hljs-comment">// end loop</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que agora você tenha menos perguntas sobre o uso desses dispositivos baratos e fáceis de usar.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt491518/index.html">Notícias do mundo do OpenStreetMap nº 501 (18/02/2020/24/02/2020)</a></li>
<li><a href="../pt491520/index.html">Converter xls em xlsx e xml em c #</a></li>
<li><a href="../pt491522/index.html">Por que as mulheres vivem mais</a></li>
<li><a href="../pt491524/index.html">Stas Afanasyev. Juno. Pipelines baseados em io.Reader / io.Writer. Parte 2</a></li>
<li><a href="../pt491528/index.html">Minha experiência está realizando 1000 entrevistas. Sinopse do relatório por Yegor Bugaenko</a></li>
<li><a href="../pt491532/index.html">Laravel + Docker + Gitlab. Por onde começar</a></li>
<li><a href="../pt491534/index.html">Um breve guia para usar o GDB</a></li>
<li><a href="../pt491536/index.html">YouTube - Erro. Por favor, tente novamente mais tarde. ID de reprodução: <...></a></li>
<li><a href="../pt491540/index.html">Redes para um especialista em TI iniciante. Base obrigatória</a></li>
<li><a href="../pt491542/index.html">Transformação de cores: pesquisas de tabela de desbaste</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>