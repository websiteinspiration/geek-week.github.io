<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏿 🙅🏽 👃 C # 8 e validade nula. Como vivemos com isso 👨🏻‍🏫 👩‍🎤 👨🏻‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá colegas! É hora de mencionar que temos planos de lançar o livro fundamental de Ian Griffiths sobre C # 8:
 
 
 Enquanto isso, em seu blog, o autor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C # 8 e validade nula. Como vivemos com isso</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/501520/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Olá colegas! </font><font style="vertical-align: inherit;">É hora de mencionar que temos planos de lançar </font><font style="vertical-align: inherit;">o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">livro</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fundamental de </font><font style="vertical-align: inherit;">Ian Griffiths sobre C # 8:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/iw/to/l-/iwtol-20o3gyqy1ppgnewp68giw.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enquanto isso, em seu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blog, o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> autor publicou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dois </font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> relacionados, </font><font style="vertical-align: inherit;">nos quais considera os meandros de novos fenômenos, como anulabilidade, esquecimento nulo e conscientização nula. </font><font style="vertical-align: inherit;">Traduzimos os dois artigos sob um título e sugerimos discuti-los.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O novo recurso mais ambicioso do C # 8.0 é chamado de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">referências anuláveis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O objetivo desse novo recurso é suavizar os danos causados ​​por uma coisa perigosa, que o cientista da computação Tony Hoar chamou de " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erro de bilhão de dólares</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">C # tem uma palavra-chave</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(o equivalente a isso é encontrado em muitos outros idiomas), e as raízes dessa palavra-chave podem ser rastreadas até o idioma Algol W, no desenvolvimento do qual Hoar participou. Nesse idioma antigo (que apareceu em 1966), variáveis ​​que se referem a instâncias de um determinado tipo podem ter um significado especial, indicando que, no momento, essa variável não é referenciada em nenhum lugar. Essa oportunidade foi amplamente emprestada e hoje muitos especialistas (inclusive o próprio Hoar) acreditam que ela se tornou a maior fonte de erros de software dispendiosos de todos os tempos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que há de errado em assumir zero? Em um mundo em que qualquer link pode apontar para zero, você deve considerar isso onde quer que qualquer link seja usado em seu código; caso contrário, você corre o risco de ser recusado em tempo de execução. Às vezes, não é muito oneroso; se você inicializar uma variável com uma expressão </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no mesmo local em que a declara, saberá que essa variável não é igual a zero. Mas mesmo um exemplo tão simples está repleto de alguma carga cognitiva: antes do lançamento do C # 8, o compilador não sabia se você está fazendo algo que possa converter esse valor </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mas, assim que você começa a costurar diferentes fragmentos de código, fica muito mais difícil julgar com certeza sobre essas coisas: qual a probabilidade de que essa propriedade que estou lendo agora possa retornar </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? É permitido transmitir</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nesse método? Em que situações posso ter certeza de que o método que estou chamando definirá esse argumento </font></font><code>out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não para </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas para um valor diferente? Além disso, o assunto não se limita a lembrar de verificar essas coisas; não está totalmente claro o que você deve fazer se chegar a zero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com tipos numéricos em C #, não existe esse problema: se você escrever uma função que recebe alguns números como entrada e retorna um número como resultado, não precisa se perguntar se os valores transmitidos são realmente números e se alguma coisa entre eles pode ser misturada. Ao chamar essa função, não é necessário pensar se ela pode retornar algo em vez de um número. A menos que esse desenvolvimento de eventos lhe interesse como uma opção: nesse caso, você pode declarar parâmetros ou resultados do tipo</font></font><code>int?</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, indicando que, nesse caso específico, você realmente deseja permitir a transmissão ou o retorno de um valor nulo. Assim, para tipos numéricos e, em um sentido mais geral, tipos significativos, a tolerância zero sempre foi uma daquelas coisas que são feitas voluntariamente, como uma opção. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quanto aos tipos de referência, anteriores ao C # 8.0, a permissibilidade de zero não era apenas definida por padrão, mas também não podia ser desativada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De fato, por razões de compatibilidade com versões anteriores, a validade zero continua a operar por padrão, mesmo no C # 8.0, porque os novos recursos de idioma nesta área permanecem desativados até que você os solicite explicitamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, assim que você habilita esse novo recurso - tudo muda. A maneira mais fácil de ativá-lo é adicioná-lo </font></font><code>&lt;Nullablegt;enable&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro do elemento.</font></font><code>&lt;PropertyGroup&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no seu arquivo </font></font><code>.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. (Observo que mais controle de filigrana também está disponível. Se você realmente precisar dele, poderá configurar o comportamento a ser permitido </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separadamente em cada linha. Mas, quando recentemente decidimos incluir esse recurso em todos os nossos projetos, verificou-se que ele seria ativado em uma escala um projeto de cada vez é uma tarefa factível.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando os links permitidos no C # 8.0 são </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">totalmente ativados, a situação muda: agora, por padrão, presume-se que os links não permitam nulo somente se você não especificar o oposto, exatamente como nos tipos significativos ( até a sintaxe é a mesma: você pode escrever int ?, se você realmente deseja que o valor inteiro seja opcional. Agora, você escreve string ?, se quer dizer que deseja um link para uma string ou</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa é uma alteração muito significativa e, em primeiro lugar, devido ao seu significado, esse novo recurso é desativado por padrão. A Microsoft poderia ter projetado esse recurso de linguagem de maneira diferente: você poderia deixar os links padrão anuláveis ​​e introduzir uma nova sintaxe que permitiria especificar que você deseja garantir que isso não seja permitido </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Talvez isso reduza a fasquia ao explorar essa possibilidade, mas a longo prazo essa solução estaria incorreta, pois na prática a maioria dos links na grande massa de código C # não foi projetada para apontar </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assumir que zero é uma exceção, não uma regra, e é por isso que, quando esse novo recurso de idioma é ativado, impedir que nulo se torne um novo padrão. Isso é refletido mesmo no nome do recurso original: "referências anuláveis". O nome é curioso, pois os links podem apontar </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o C # 1.0. Mas os desenvolvedores optaram por enfatizar que agora a suposição nula entra na categoria de coisas que precisam ser explicitamente solicitadas. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O C # 8.0 facilita o processo de introdução de links permissivos </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pois permite que você introduza esse recurso gradualmente. Não é preciso fazer uma escolha sim ou não. Isso é bem diferente do recurso </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adicionado no C # 5.0, que costumava se espalhar: de fato, operações assíncronas obrigam o chamador a ser</font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, portanto, o código que chama esse chamador deve estar </font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e assim por diante, no topo da pilha. Felizmente, os tipos que permitem </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">são construídos de maneira diferente: eles podem ser implementados de maneira seletiva e gradual. Você pode trabalhar com os arquivos um por um, ou mesmo linha por linha, se necessário. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O aspecto mais importante dos tipos que permitem</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(graças à qual a transição para eles é simplificada), é que, por padrão, eles estão desativados. Caso contrário, a maioria dos desenvolvedores se recusaria a usar o C # 8.0, pois essa transição causaria avisos em quase qualquer base de código. No entanto, pelas mesmas razões, o limite de entrada para o uso desse novo recurso parece bastante alto: se um novo recurso faz alterações tão drásticas que é desativado por padrão, é provável que você não queira mexer nele, mas há problemas associados à mudança para ele sempre parecerá um aborrecimento desnecessário. Mas isso seria uma pena, porque o recurso é muito valioso. Ajuda a encontrar erros no código antes que os usuários façam isso por você. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, se você está pensando em introduzir tipos que permitem</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lembre-se de poder introduzir esse recurso passo a passo. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somente avisos</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
O nível mais rígido de controle sobre todo o projeto após um simples ligar / desligar é a capacidade de ativar avisos, independentemente das anotações. Por exemplo, se eu ativar totalmente a suposição zero para </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corvus.ContentHandling.Json</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em nosso repositório </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corvus.ContentHandling</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , adicionando </font></font><code>&lt;Nullablegt;enable&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ao grupo de propriedades no arquivo do projeto, em seu estado atual, 20 avisos do compilador aparecerão imediatamente. No entanto, se eu usá-lo, </font></font><code>&lt;Nullablegt;warnings&lt;/Nullablegt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">receberei apenas um aviso.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas espere! Por que menos avisos serão mostrados para mim? No final, aqui eu apenas pedi avisos. A resposta a essa pergunta não é totalmente óbvia: o fato é que algumas variáveis ​​e expressões podem ser </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulas. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neutralidade nula O</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
C # suporta duas interpretações de validade nula. Em primeiro lugar, qualquer variável de um tipo de referência pode ser declarada como admitindo ou não </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, em segundo lugar, o compilador </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sempre que </font><font style="vertical-align: inherit;">possível conclui logicamente se essa variável pode ou não estar </font><font style="vertical-align: inherit;">em qualquer ponto específico do código. Este artigo trata apenas da primeira variedade de admissibilidade</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ou seja, sobre o tipo estático de uma variável (na verdade, isso se aplica não apenas a variáveis ​​e parâmetros e campos próximos a eles em espírito; a admissibilidade estática e logicamente dedutível é </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determinada para cada expressão em C #.) De fato, a admissibilidade </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em seu primeiro sentido , o que estamos considerando é uma extensão do sistema de tipos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, acontece que, se focarmos apenas na admissibilidade nula para um tipo, a situação não será tão coerente quanto se poderia supor. Este não é apenas um contraste entre "validade nula" e "inválida</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" De fato, existem mais duas possibilidades. Existe uma categoria de "desconhecido", que é obrigatória devido à disponibilidade de genéricos; se você tiver um parâmetro de tipo ilimitado, não será possível descobrir nada sobre a validade </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: código usando o método ou tipo generalizado apropriado pode substituir um argumento neles, permitindo ou não </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Você pode adicionar restrições, mas muitas vezes essas restrições são indesejáveis, pois restringem o escopo do tipo ou método generalizado. Portanto, para variáveis ​​ou expressões de algum parâmetro de tipo ilimitado, a </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(não) validade de zero deve ser desconhecida; talvez, em cada caso, a questão da admissibilidade</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">será decidido separadamente para eles, mas não sabemos qual opção aparecerá no código genérico, pois dependerá do argumento de tipo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A última categoria é chamada "neutra". Pelo princípio da "neutralidade", tudo funcionava antes do advento do C # 8.0, e isso funcionará se você não ativar a capacidade de trabalhar com links anuláveis. (Basicamente, este é um exemplo de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retroatividade</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Embora a idéia de neutralidade nula tenha sido introduzida pela primeira vez no C # 8.0 como um estado natural de código antes de ativar a validade nula para referências, os designers de C # insistiram que essa propriedade nunca era realmente estranha ao C #.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Talvez você não precise explicar o que "neutralidade" significa nesse caso, pois é nesse sentido que o C # sempre funcionou, para que você entenda tudo ... embora, talvez, isso seja um pouco desonesto. Portanto, ouça: em um mundo onde se sabe sobre admissibilidade </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a característica mais importante das </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expressões -eutrais é que elas não causam avisos sobre aceitabilidade nula. Você pode atribuir uma expressão nula-neutra como uma </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variável </font><font style="vertical-align: inherit;">permitida </font><font style="vertical-align: inherit;">, mas não permitida. </font></font><code>Null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variáveis ​​variáveis ​​(assim como propriedades, campos, etc.), você pode atribuir expressões que o compilador considerou "possível </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" ou "não </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por isso, se você ativar os avisos, não haverá muitos alertas novos. Todo o código permanece no contexto de anotações de validade desabilitadas </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, portanto, todas as variáveis, parâmetros, campos e propriedades serão </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutros, o que significa que você não receberá nenhum aviso se tentar usá-lo em conjunto com qualquer entidade que leve em consideração </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que, então, recebo avisos? Um motivo comum é a tentativa de fazer amigos de uma maneira inaceitável dois pedaços de código que levam em consideração </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por exemplo, suponha que eu tenha uma biblioteca em que os links permissivos sejam totalmente incluídos </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e essa biblioteca tenha a seguinte classe profundamente inventada:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NullableAwareClass</span><font></font>
	{<font></font>
	    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">string</span>? GetNullable() =&gt; DateTime.Now.Hour &gt; <span class="hljs-number">12</span> ? <span class="hljs-literal">null</span> : <span class="hljs-string">"morning"</span>;<font></font>
	<font></font>
<font></font>
	    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">RequireNonNull</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> s</span>)</span> =&gt; s.Length;<font></font>
	}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, em outro projeto, eu posso escrever esse código no contexto em que os avisos de validade nula são ativados, mas as anotações correspondentes estão desabilitadas: </font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">UseString</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> x</span>)</span> =&gt; NullableAwareClass.RequireNonNull(x);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como as anotações sobre validade nula estão desativadas, o parâmetro </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui é </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutro. </font><font style="vertical-align: inherit;">Isso significa que o compilador não pode determinar se esse código é verdadeiro ou não. </font><font style="vertical-align: inherit;">Se o compilador emitiu avisos nos casos em que </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expressões neutras são misturadas com aquelas que levam em consideração </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, uma proporção significativa desses avisos pode ser considerada duvidosa - portanto, os avisos não são emitidos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com esse invólucro, eu realmente escondi o fato de que o código leva em consideração a validade </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso significa que agora eu posso escrever assim:</font></font><br>
<br>
<pre><code class="cs hljs">	<span class="hljs-keyword">int</span> x = UseString(NullableAwareClass.GetNullable());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O compilador sabe o que </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode retornar </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas desde que chamei o método com um parâmetro nulo-neutro, o programa não sabe se isso está certo ou errado. Usando o </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wrapper -neutral, desarmei o compilador, que agora não vê nenhum problema aqui. No entanto, se eu combinasse esses dois métodos diretamente, tudo seria diferente:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">int</span> y = NullableAwareClass.RequireNonNull(NullableAwareClass.GetNullable());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui eu passo o resultado </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diretamente para </font></font><code>RequireNonNull</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se eu tentasse fazer isso em um contexto em que hipóteses nulas estão ativadas, o compilador geraria um aviso, independentemente de eu ativar ou desativar o contexto das anotações correspondentes. Nesse caso em particular, o contexto das anotações não importa, pois não há declarações com um tipo de referência. Se você ativar avisos sobre a suposição de nulo, mas desativar as anotações correspondentes, todas as declarações se tornarão </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutras, o que, no entanto, não significa que todas as expressões se tornem tais. Portanto, sabemos que o resultado </font></font><code>GetNullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é nulo. Portanto, recebemos um aviso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resumindo: como todas as declarações no contexto de anotações desativadas que permitem </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">são</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- neutro, não receberemos muitos avisos, pois a maioria das expressões será - </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neutra. Mas o compilador ainda poderá capturar erros relacionados à suposição </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nos casos em que as expressões não passam por algum intermediário nulo-neutro. Além disso, o maior benefício nesse caso será detectar erros associados a tentativas de desreferenciar possíveis valores nulos usando </font></font><code>.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por exemplo:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">int</span> z = NullableAwareClass.GetNullable().Length;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se seu código foi bem projetado, não deve haver um grande número de erros desse tipo. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anotação gradual de todo o projeto</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Depois de dar o primeiro passo - basta ativar os avisos, você pode prosseguir para a ativação gradual das anotações, arquivo por arquivo. É conveniente incluí-los imediatamente em todo o projeto, ver em quais avisos os arquivos aparecem - e depois selecionar um arquivo em que haja relativamente poucos avisos. Novamente, desative-os no nível de todo o projeto e escreva na parte superior do arquivo selecionado </font></font><code>#nullable enable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Isso ativará totalmente a suposição </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(tanto para avisos quanto para anotações) em todo o arquivo (a menos que você as desative novamente usando outra diretiva</font></font><code>#nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Em seguida, você pode percorrer o arquivo inteiro e garantir que todas as entidades que provavelmente são nulas sejam anotadas como permitidas </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ou seja, adicionar </font></font><code>?</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) e, em seguida, lidar com avisos nesse arquivo, se houver algum. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pode acontecer que adicionar todas as anotações necessárias seja o suficiente para eliminar todos os avisos. O inverso também é possível: você pode notar que, quando anota um arquivo sobre validade</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, outros avisos apareceram em outros arquivos que o utilizam. Como regra geral, não existem muitos avisos e você tem tempo para corrigi-los rapidamente. Mas, se por algum motivo, após esta etapa, você se afogar em avisos, ainda terá algumas soluções. Primeiramente, você pode simplesmente cancelar a seleção, deixar este arquivo e escolher outro. Em segundo lugar, você pode desativar seletivamente anotações para os membros que você acha que estão causando mais problemas. ( </font></font><code>#nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você pode usar a </font><font style="vertical-align: inherit;">diretiva </font><font style="vertical-align: inherit;">quantas vezes quiser, para controlar as configurações de validade nula, linha por linha, se desejar.) Talvez se você retornar a esse arquivo mais tarde, quando já ativar a validade nula na maior parte do projeto, verá menos avisos do que a primeira vez.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Há momentos em que os problemas não podem ser resolvidos de maneira tão direta. </font><font style="vertical-align: inherit;">Portanto, em certos cenários relacionados à serialização (por exemplo, ao usar o Json.NET ou o Entity Framework), o trabalho pode ser mais difícil. </font><font style="vertical-align: inherit;">Eu acho que esse problema merece um artigo separado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os links com a suposição </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melhoram a expressividade do seu código e aumentam as chances de o compilador detectar seus erros antes que os usuários os encontrem. </font><font style="vertical-align: inherit;">Portanto, é melhor incluir esse recurso, se possível. </font><font style="vertical-align: inherit;">E, se você incluí-lo seletivamente, seus benefícios começarão a parecer mais rápidos.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt501502/index.html">Nova síntese digital de laboratório continua Harris Book e ajuda a criar videogame FPGA</a></li>
<li><a href="../pt501506/index.html">Sobre vazamentos de GDI e a importância da sorte</a></li>
<li><a href="../pt501508/index.html">Maldito CRM antigo</a></li>
<li><a href="../pt501510/index.html">Uma nova visão do desenvolvimento do Fullstack com a estrutura Ruby on Rails</a></li>
<li><a href="../pt501516/index.html">Vamos desligar o aspirador ?! Alexey Lesovsky</a></li>
<li><a href="../pt501522/index.html">Webinars gratuitos do Skillbox: escrevendo jogos em PHP, Unity e Unreal Engine</a></li>
<li><a href="../pt501524/index.html">Segredos de sincronizar os campos eletromagnéticos da Terra e um organismo vivo</a></li>
<li><a href="../pt501526/index.html">Por que o inglês canadense é considerado "sujo" e o que Keanu Reeves tem a ver com isso?</a></li>
<li><a href="../pt501528/index.html">O livro "Bash e segurança cibernética: ataque, defesa e análise a partir da linha de comando do Linux"</a></li>
<li><a href="../pt501534/index.html">Agora, com o COVID-19, também há uma erupção cutânea</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>