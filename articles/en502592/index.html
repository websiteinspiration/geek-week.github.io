<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçÔ∏è üë®üèæ‚Äç‚öïÔ∏è ü§ì Neomorphism using SwiftUI. Part 1 ‚ÜïÔ∏è üò∞ üò´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salute, Khabrovites! In anticipation of the launch of the advanced course ‚ÄúIOS Developer‚Äù, we have prepared another interesting translation.
 
 
 
 No...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Neomorphism using SwiftUI. Part 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/502592/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salute, Khabrovites! </font><font style="vertical-align: inherit;">In anticipation of the launch of the advanced course </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúIOS Developer‚Äù,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we have prepared another interesting translation.</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/nr/7d/ml/nr7dmlj7ru0rbnazf8ce8wox3ra.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Non-morphic design is perhaps the most interesting trend of recent months, although, in truth, Apple used it as its design motif back at WWDC18. </font><font style="vertical-align: inherit;">In this article, we will look at how you can implement a non-morphic design using SwiftUI, why you might want to do this, and - most importantly - how we can refine this design to increase its accessibility.</font></font><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Important</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Neomorphism - also sometimes called neuromorphism - has serious consequences for accessibility, so despite the temptation to read the first part of this article and skip the rest, I urge you to read the article to the end and study both the advantages and disadvantages so that you can see the whole picture .</font></font><br>
</blockquote><a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/z3tJdxwlo_Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basics of Neomorphism</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before we move on to the code, I want to briefly outline two basic principles of this direction in design, since they will be relevant as we move along:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neomorphism uses glare and shadow to determine the shapes of objects on the screen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contrast tends to decrease; </font><font style="vertical-align: inherit;">completely white or black are not used, which allows you to highlight highlights and shadows.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The end result is a look reminiscent of ‚Äúextruded plastic‚Äù - a user interface design that certainly looks fresh and interesting without bumping into your eyes. </font><font style="vertical-align: inherit;">I cannot but repeat once again that reducing contrast and using shadows to highlight shapes seriously affects accessibility, and we will return to this later. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, I still think the time spent learning about neomorphism in SwiftUI is worth it - even if you don't use it in your own applications, it's like a code writing kata to help hone your skills. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alright, enough idle talk - let's move on to the code.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Building a non-morphic map</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The simplest starting point is to create a non-morphic map: a rounded rectangle that will contain some information. Next, we‚Äôll look at how we can transfer these principles to other parts of SwiftUI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start by creating a new iOS project using the Single View app template. Make sure you use SwiftUI for the user interface, and then name the project Neumorphism. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tip: if you have access to preview SwiftUI in Xcode, I recommend that you activate it right away - it will be much easier for you to experiment.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We'll start by defining a color that represents a creamy hue. </font><font style="vertical-align: inherit;">This is not pure gray, but rather a very subtle shade that adds a little warmth or coolness to the interface. </font><font style="vertical-align: inherit;">You can add it to the asset directory if you want, but now it's easier to do in code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Add this </font></font><code>Color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">outside the structure </font></font><code>ContentView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Color</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> offWhite = <span class="hljs-type">Color</span>(red: <span class="hljs-number">225</span> / <span class="hljs-number">255</span>, green: <span class="hljs-number">225</span> / <span class="hljs-number">255</span>, blue: <span class="hljs-number">235</span> / <span class="hljs-number">255</span>)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yes, it's almost white, but it's dark enough to make real white look like a glow when we need it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we can fill the body </font></font><code>ContentView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by providing it </font></font><code>ZStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that occupies the entire screen, using our new quasi-white color to fill the entire space:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ZStack</span> {
            <span class="hljs-type">Color</span>.offWhite<font></font>
        }<font></font>
        .edgesIgnoringSafeArea(.all)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To represent our map, we will use a rounded rectangle in the resolution of 300x300 to make it beautiful and clear on the screen. </font><font style="vertical-align: inherit;">So add this to </font></font><code>ZStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, under the color:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">25</span>)<font></font>
    .frame(width: <span class="hljs-number">300</span>, height: <span class="hljs-number">300</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By default it will be black, but for the implementation of the neomorphism we want to sharply reduce the contrast, so we will replace it with the same color that we use for the background, in fact making the shape invisible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So change it like this:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">25</span>)<font></font>
    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
    .frame(width: <span class="hljs-number">300</span>, height: <span class="hljs-number">300</span>)</code></pre><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An important point:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we determine the shape using shadows, one dark and one light, as if the light cast rays from the upper left corner of the screen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUI allows us to apply modifiers several times, which facilitates the implementation of neomorphism. </font><font style="vertical-align: inherit;">Add the following two modifiers to your rounded rectangle:</font></font><br>
<br>
<pre><code class="swift hljs">.shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
.shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
They represent the offset of the dark shadow in the lower right corner and the offset of the light shadow in the upper left corner. </font><font style="vertical-align: inherit;">The light shadow is visible because we used a quasi-white background, and now the map becomes visible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have written just a few lines of code, but we already have a non-morphic map - I hope you agree that SwiftUI surprisingly makes the process easier!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/he/_z/0h/he_z0hdu4zlhtftzxwsvxo5k9t8.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creating a simple non-morphic button</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of all the elements of a UI, neomorphism poses a fairly low risk for cards - if the UI inside your cards is clear, the card may not have a clear border, and this will not affect accessibility. Buttons are another matter, because they are designed to interact, so reducing their contrast can do more harm than good. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's deal with this by creating our own button style, as this is the way that SwiftUI allows button configurations to be distributed in many places. This is much more convenient than adding many modifiers to each button you create - we can simply define the style once and use it in many places.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We are going to define a button style that will actually be empty: SwiftUI will give us the label for the button, which may be text, image, or something else, and we will send it back without changes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Add this structure somewhere outside </font></font><code>ContentView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SimpleButtonStyle</span>: <span class="hljs-title">ButtonStyle</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeBody</span><span class="hljs-params">(configuration: <span class="hljs-keyword">Self</span>.Configuration)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        configuration.label<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This </font></font><code>configuration.label</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one is what holds the contents of the button, and soon we will be adding something else. </font><font style="vertical-align: inherit;">First, let's define a button that uses it so you can see how the design is evolving:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">Button</span>(action: {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Button tapped"</span>)<font></font>
}) {<font></font>
    <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">"heart.fill"</span>)<font></font>
        .foregroundColor(.gray)<font></font>
}<font></font>
.buttonStyle(<span class="hljs-type">SimpleButtonStyle</span>())</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You won't see anything special on the screen, but we can fix it by adding our non-morphic effect to the button style. This time we will not use a rounded rectangle, because for simple icons, the circle is better, but we need to add some indentation so that the button click area is large and beautiful. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Change your method </font></font><code>makeBody()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by adding some indentation and then placing our non-morphic effect as the background for the button:</font></font><br>
<br>
<pre><code class="swift hljs">configuration.label<font></font>
    .padding(<span class="hljs-number">30</span>)<font></font>
    .background(<font></font>
        <span class="hljs-type">Circle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
            .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
            .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
    )</code></pre><br>
<img src="https://habrastorage.org/webt/nm/-x/yp/nm-xyp4klovncqtomhthav-za7y.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This brings us close enough to the desired effect, but if you run the application, you will see that in practice the behavior is still not perfect - the button does not react visually when pressed, which looks just weird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To fix this, we need to read the property </font></font><code>configuration.isPressed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inside our custom button style, which tells whether the button is currently pressed or not. We can use this to improve our style to give some visual indication of whether the button is pressed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start with a simple one: we will use </font></font><code>Group</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buttons for the background, then check </font></font><code>configuration.isPressed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and return either a flat circle if the button is pressed, or our current darkened circle otherwise:</font></font><br>
<br>
<pre><code class="swift hljs">configuration.label<font></font>
    .padding(<span class="hljs-number">30</span>)<font></font>
    .background(<font></font>
        <span class="hljs-type">Group</span> {
            <span class="hljs-keyword">if</span> configuration.isPressed {
                <span class="hljs-type">Circle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-type">Circle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
                    .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
                    .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
            }<font></font>
        }<font></font>
    )</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since a </font></font><code>isPressed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">circle with a quasi-white color is used </font><font style="vertical-align: inherit;">in the state </font><font style="vertical-align: inherit;">, it makes our effect invisible when the button is pressed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warning: due to the way that SwiftUI calculates tapable areas, we unintentionally made the click area for our button very small - now you need to tap on the image itself, and not on the unomorphic design around it. </font><font style="vertical-align: inherit;">To fix this, add a modifier </font></font><code>.contentShape(Circle())</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immediately after </font></font><code>.padding(30)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, forcing SwiftUI to use all available tap space. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we can create the effect of artificial concavity by flipping the shadow - by copying two modifiers </font></font><code>shadow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the base effect, exchanging the X and Y values ‚Äã‚Äãfor white and black, as shown here:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">if</span> configuration.isPressed {
    <span class="hljs-type">Circle</span>()<font></font>
        .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-type">Circle</span>()<font></font>
        .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estimate the result.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bk/nz/gv/bknzgvars2r0e4anrdqngo12wr4.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create internal shadows for a button click</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our current code, in principle, already works, but people interpret the effect differently - some see it as a concave button, others see that the button is still not pressed, just the light comes from a different angle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The idea of ‚Äã‚Äãthe improvement is to create an inner shadow that will simulate the effect of pressing the button inward. This is not part of the standard SwiftUI kit, but we can implement it quite easily. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creating an inner shadow requires two linear gradients, and they will be only the first of many internal gradients that we will use in this article, so we will immediately add a small auxiliary extension for </font></font><code>LinearGradient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, to simplify the creation of standard gradients:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">LinearGradient</span> </span>{
    <span class="hljs-keyword">init</span>(<span class="hljs-number">_</span> colors: <span class="hljs-type">Color</span>...) {
        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(gradient: <span class="hljs-type">Gradient</span>(colors: colors), startPoint: .topLeading, endPoint: .bottomTrailing)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With this, we can simply provide a variable list of colors to get back their linear gradient in the diagonal direction. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now about the important point: instead of adding two flipped shadows to our pressed circle, we are going to overlay a new circle with a blur (stroke), and then apply another circle with a gradient as a mask. </font><font style="vertical-align: inherit;">This is a little trickier, but let me explain it piecemeal:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our base circle is our current circle with a neomorphic effect, filled with a quasi-white color.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We place a circle on top of it, framed by a gray frame, and slightly blur to soften its edges.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we apply a mask with another circle to this circle superimposed on top, this time filled with a linear gradient.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When you apply one view as a mask for another, SwiftUI uses the alpha channel of the mask to determine what should be displayed in the base view. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, if we draw a blurry gray stroke, and then mask it with a linear gradient from black to transparent, the blurry stroke will be invisible on one side and gradually increase on the other - we will get a smooth internal gradient. To make the effect more pronounced, we can slightly shift the shaded circles in both directions. Having experimented a bit, I found that drawing a light shadow with a thicker line than a dark one helps maximize the effect.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remember that two shadows are used to create a sense of depth in neomorphism: one light and one dark, so we will add this effect of the inner shadow twice with different colors. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Change the circle </font></font><code>configuration.isPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as follows:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">Circle</span>()<font></font>
    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
    .overlay(<font></font>
        <span class="hljs-type">Circle</span>()<font></font>
            .stroke(<span class="hljs-type">Color</span>.gray, lineWidth: <span class="hljs-number">4</span>)<font></font>
            .blur(radius: <span class="hljs-number">4</span>)<font></font>
            .offset(x: <span class="hljs-number">2</span>, y: <span class="hljs-number">2</span>)<font></font>
            .mask(<span class="hljs-type">Circle</span>().fill(<span class="hljs-type">LinearGradient</span>(<span class="hljs-type">Color</span>.black, <span class="hljs-type">Color</span>.clear)))<font></font>
    )<font></font>
    .overlay(<font></font>
        <span class="hljs-type">Circle</span>()<font></font>
            .stroke(<span class="hljs-type">Color</span>.white, lineWidth: <span class="hljs-number">8</span>)<font></font>
            .blur(radius: <span class="hljs-number">4</span>)<font></font>
            .offset(x: -<span class="hljs-number">2</span>, y: -<span class="hljs-number">2</span>)<font></font>
            .mask(<span class="hljs-type">Circle</span>().fill(<span class="hljs-type">LinearGradient</span>(<span class="hljs-type">Color</span>.clear, <span class="hljs-type">Color</span>.black)))<font></font>
    )</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you run the application again, you will see that the effect of pressing a button is much more pronounced and looks better. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1r/f1/ha/1rf1hanjn-9zhj0xhglha6e4lr0.jpeg"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On this, the first part of the translation came to an end. </font><font style="vertical-align: inherit;">In the coming days we will publish the continuation, and now we invite you to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">learn more about the upcoming course</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en502576/index.html">Apple Watch for inexpensive: how they wanted to ‚Äúbreed‚Äù me on Avito and Yulia</a></li>
<li><a href="../en502578/index.html">On the revolution in radars, deadlines and entering the fourth dimension</a></li>
<li><a href="../en502580/index.html">Commit in open source as a developer? We deal with the rights (hi, nginx)</a></li>
<li><a href="../en502584/index.html">Manufacturer Mi Band will release a self-disinfecting transparent mask to protect against COVID-19</a></li>
<li><a href="../en502588/index.html">The incredible story of PowerPoint</a></li>
<li><a href="../en502594/index.html">7 reasons why web projects are not brought to an end, and how to deal with it</a></li>
<li><a href="../en502596/index.html">Free quarantine educational courses: design</a></li>
<li><a href="../en502598/index.html">Security Week 21: Windows Print Service Vulnerability</a></li>
<li><a href="../en502604/index.html">An Introduction to TLS for Patrik Patrick (Part 1)</a></li>
<li><a href="../en502608/index.html">How we started the marketplace of applications in the SaaS service</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>