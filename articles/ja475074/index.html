<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚳 👨🏽‍🔧 🙋🏿 ECMAScript 2017（ES8）の概要 🖋️ 💉 👒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="目次
 はじめに
 ES7一目で
 1. Object.entries 
 2. Object.values 
 3. String.prototype.padEnd 
 4. String.prototype.padStart 
 5. Object.getOwnPropertyDescripto...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ECMAScript 2017（ES8）の概要</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475074/"><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目次</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はじめに</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ES7一目で</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Object.entries </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Object.values </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. String.prototype.padEnd </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. String.prototype.padStart </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Object.getOwnPropertyDescriptor </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.末尾のカンマ</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. SharedArrayBuffer </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.アトミック</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9.非同期機能</font></font></a><br>
<br>
<a name="section000"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序文</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
こんにちは、以前はES6のイノベーションを検討していましたが、ES8を分解して、多くの新しいものをもたらしました。</font><font style="vertical-align: inherit;">このリリースでは2つのイノベーションしかなかったため、ES7（2016）を個別に検討することはしませんでした。</font><font style="vertical-align: inherit;">これはArray.prototype.includes（）とべき乗演算子です。</font><font style="vertical-align: inherit;">それでも、ES8を開始する前に、ES7のイノベーションを見てみましょう。</font></font><br>
<br>
<a name="section0000"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ES7の概要</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">include（）メソッド</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、配列に特定の要素が含まれているかどうかを判別し、これに応じてtrueまたはfalseを返します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">Array</span>.prototype.includes(searchElement[, fromIndex = <span class="hljs-number">0</span>]) : <span class="hljs-built_in">Boolean</span></code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
searchElement-検索するアイテム。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
fromIndex-searchElement要素の検索を開始する配列内の位置。</font><font style="vertical-align: inherit;">負の値の場合、検索はインデックスarray.length + fromIndexの昇順で実行されます。</font><font style="vertical-align: inherit;">デフォルト値は0です。</font></font><a name="habracut"></a><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b> <br>
<br>
<pre><code class="javascript hljs">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">2</span>);     <span class="hljs-comment">// true</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">4</span>);     <span class="hljs-comment">// false</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// false</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">3</span>, <span class="hljs-number">-1</span>); <span class="hljs-comment">// true</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">NaN</span>].includes(<span class="hljs-literal">NaN</span>); <span class="hljs-comment">// true</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
include（）は、他のタイプのオブジェクト（たとえば、配列のようなオブジェクト）に適用できます。</font><font style="vertical-align: inherit;">例：引数オブジェクトでinclude（）メソッドを使用する。</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log([].includes.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-string">'a'</span>)); <span class="hljs-comment">// true</span>
  <span class="hljs-built_in">console</span>.log([].includes.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-string">'d'</span>)); <span class="hljs-comment">// false</span>
})(<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>);</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指数演算子</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（**）は、底がaで自然指数がbの次数を返します。</font><font style="vertical-align: inherit;">aをbの累乗に上げる。</font></font><br>
<br>
<pre><code class="javascript hljs">a ** b</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b> <br>
<br>
<pre><code class="javascript hljs"><span class="hljs-number">2</span> ** <span class="hljs-number">3</span> <span class="hljs-comment">// 8</span>
<span class="hljs-number">3</span> ** <span class="hljs-number">2</span> <span class="hljs-comment">// 9</span>
<span class="hljs-number">3</span> ** <span class="hljs-number">2.5</span> <span class="hljs-comment">// 15.588457268119896</span>
<span class="hljs-number">10</span> ** <span class="hljs-number">-1</span> <span class="hljs-comment">// 0.1</span>
<span class="hljs-literal">NaN</span> ** <span class="hljs-number">2</span> <span class="hljs-comment">// NaN</span><font></font>
<font></font>
<span class="hljs-number">2</span> ** <span class="hljs-number">3</span> ** <span class="hljs-number">2</span> <span class="hljs-comment">// 512</span>
<span class="hljs-number">2</span> ** (<span class="hljs-number">3</span> ** <span class="hljs-number">2</span>) <span class="hljs-comment">// 512</span>
(<span class="hljs-number">2</span> ** <span class="hljs-number">3</span>) ** <span class="hljs-number">2</span> <span class="hljs-comment">// 64</span><font></font>
<font></font>
-(<span class="hljs-number">2</span> ** <span class="hljs-number">2</span>) <span class="hljs-comment">// -4</span>
(<span class="hljs-number">-2</span>) ** <span class="hljs-number">2</span> <span class="hljs-comment">// 4</span></code></pre><br>
<a name="section001"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Object.entries</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Object.entries（）は、要素がオブジェクトで直接見つかる[key、value]ペアの列挙されたプロパティに対応する配列である配列を返します。</font><font style="vertical-align: inherit;">プロパティの順序は、オブジェクトのプロパティを手動でループする場合と同じです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">Object</span>.entries(obj) : <span class="hljs-built_in">Array</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
obj-列挙されたプロパティが配列[キー、値]として返されるオブジェクト。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Object.entries（）は、for ... inループと同じ順序でプロパティを返します（違いは、for-inもプロトタイプチェーンのプロパティをリストすることです）。</font><font style="vertical-align: inherit;">Object.entries（）が返す配列内の要素の順序は、オブジェクトの宣言方法とは無関係です。</font><font style="vertical-align: inherit;">特定の順序が必要な場合は、メソッドを呼び出す前に配列をソートする必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b> <br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> obj = { <span class="hljs-attr">foo</span>: <span class="hljs-string">"bar"</span>, <span class="hljs-attr">baz</span>: <span class="hljs-number">42</span> };
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.entries(obj)); <span class="hljs-comment">// [ ['foo', 'bar'], ['baz', 42] ]</span><font></font>
<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> obj = { <span class="hljs-number">0</span>: <span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>: <span class="hljs-string">'b'</span>, <span class="hljs-number">2</span>: <span class="hljs-string">'c'</span> };
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.entries(obj)); <span class="hljs-comment">// [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]</span><font></font>
<font></font>
<span class="hljs-comment">//    c random  </span>
<span class="hljs-keyword">var</span> an_obj = { <span class="hljs-number">100</span>: <span class="hljs-string">'a'</span>, <span class="hljs-number">2</span>: <span class="hljs-string">'b'</span>, <span class="hljs-number">7</span>: <span class="hljs-string">'c'</span> };
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.entries(an_obj)); <span class="hljs-comment">// [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]</span><font></font>
<font></font>
<span class="hljs-comment">// getFoo  ,   </span>
<span class="hljs-keyword">var</span> my_obj = <span class="hljs-built_in">Object</span>.create({}, { <span class="hljs-attr">getFoo</span>: { <span class="hljs-attr">value</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.foo; } } });<font></font>
my_obj.foo = <span class="hljs-string">"bar"</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.entries(my_obj)); <span class="hljs-comment">// [ ['foo', 'bar'] ]</span><font></font>
<font></font>
<span class="hljs-comment">// non-object     object</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.entries(<span class="hljs-string">"foo"</span>)); <span class="hljs-comment">// [ ['0', 'f'], ['1', 'o'], ['2', 'o'] ]</span><font></font>
<font></font>
<span class="hljs-keyword">let</span> obj = { <span class="hljs-attr">one</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">two</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [k,v] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(obj))
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(k)}</span>: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(v)}</span>`</span>) 
<span class="hljs-comment">// "one": 1</span>
<span class="hljs-comment">// "two": 2</span></code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトからマップへの変換</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
新しいMap（）コンストラクターは、重複する値を受け入れます。</font><font style="vertical-align: inherit;">Object.entriesを使用すると、オブジェクトをマップに簡単に変換できます。</font><font style="vertical-align: inherit;">これは、2要素配列の配列を使用するよりも簡潔ですが、キーは文字列のみです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> obj = { <span class="hljs-attr">foo</span>: <span class="hljs-string">"bar"</span>, <span class="hljs-attr">baz</span>: <span class="hljs-number">42</span> };
<span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(<span class="hljs-built_in">Object</span>.entries(obj));
<span class="hljs-built_in">console</span>.log(map); <span class="hljs-comment">// Map {"foo" =&gt; "bar", "baz" =&gt; 42}</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Object.entries（）の戻り値がイテレータではなく配列であるのはなぜですか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合の関連するユースケースはObject.keys（）であり、たとえばMap.prototype.entries（）ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Object.entries（）が文字列キーを持つ列挙されたネイティブプロパティのみを返すのはなぜですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しますが、これはObject.keys（）と一致するように行われます。</font><font style="vertical-align: inherit;">このメソッドは、キーが文字であるプロパティも無視します。</font><font style="vertical-align: inherit;">結局のところ、独自のプロパティをすべて返すReflect.ownEntries（）メソッドがあるかもしれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
公式</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様の</font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN Webドキュメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">だけでなく、</font><font style="vertical-align: inherit;">object.entriesも参照してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="section002"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Object.values</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Object.values（）は、要素がオブジェクトにある列挙されたプロパティの値である配列を返します。</font><font style="vertical-align: inherit;">順序は、オブジェクトを手動で循環する場合と同じです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">Object</span>.values(obj) : <span class="hljs-built_in">Array</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
obj-列挙されたプロパティの値が返されるオブジェクト。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Object.values（）メソッドは、オブジェクトの列挙されたプロパティの値の配列をfor ... inループと同じ順序で返します。</font><font style="vertical-align: inherit;">ループとメソッドの違いは、ループがプロトタイプチェーンのプロパティをリストすることです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b> <br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> obj = { <span class="hljs-attr">foo</span>: <span class="hljs-string">"bar"</span>, <span class="hljs-attr">baz</span>: <span class="hljs-number">42</span> };
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.values(obj)); <span class="hljs-comment">// ['bar', 42]</span><font></font>
<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-keyword">var</span> obj = { <span class="hljs-number">0</span>: <span class="hljs-string">'a'</span>, <span class="hljs-number">1</span>: <span class="hljs-string">'b'</span>, <span class="hljs-number">2</span>: <span class="hljs-string">'c'</span> };
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.values(obj)); <span class="hljs-comment">// ['a', 'b', 'c']</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Object.entriesとObject.values（）の違いは、1つ目はプロパティの名前と値を含む配列の配列を返し、2つ目はプロパティの値を持つ配列のみを返すことです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Object.values（）とObject.entries（）の違いの例</font></font></b> <br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> object = {
  <span class="hljs-attr">a</span>: <span class="hljs-string">'somestring'</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-number">42</span>,
  <span class="hljs-attr">c</span>: <span class="hljs-literal">false</span><font></font>
};<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.values(object)); <span class="hljs-comment">//  ["somestring", 42, false]</span><font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.entries(object)); <span class="hljs-comment">//  [ ["a", "somestring"], ["b", 42], ["c", false] ]</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
公式</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Object.values（）</font><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN Web Docsを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="section003"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. String.prototype.padEnd</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
padEnd（）メソッドは、指定された文字列（最終的には繰り返す）で現在の行を完成させ、結果の文字列が指定された長さに達するようにします。</font><font style="vertical-align: inherit;">追加は現在の行の最後（右）に適用されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">String</span>.prototype.padEnd(maxLength [ , fillString ]) : <span class="hljs-built_in">String</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
maxLength-現在の行が埋め込まれた後の結果の行の長さ。</font><font style="vertical-align: inherit;">このパラメーターが現在の行の長さより短い場合、現在の行がそのまま返されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
fillString-現在の行を補完する文字列。</font><font style="vertical-align: inherit;">この行が長すぎる場合は切り捨てられ、その左端が適用されます。</font><font style="vertical-align: inherit;">""（0x0020 SPACE）は、このパラメーターのデフォルト値です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b> <br>
<br>
<pre><code class="javascript hljs"><span class="hljs-string">'abc'</span>.padEnd(<span class="hljs-number">10</span>);         <span class="hljs-comment">// "abc       "</span>
<span class="hljs-string">'abc'</span>.padEnd(<span class="hljs-number">10</span>, <span class="hljs-string">"foo"</span>);  <span class="hljs-comment">// "abcfoofoof"</span>
<span class="hljs-string">'abc'</span>.padEnd(<span class="hljs-number">6</span>,<span class="hljs-string">"123456"</span>); <span class="hljs-comment">// "abc123"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文字列を埋めるための使用例は次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カウンターまたは識別子をファイル名またはURLに追加： 'file 001.txt'</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンソール出力の配置：「テスト001：✓」</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">固定桁数の16進数または2進数を出力します： '0x00FF'</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
公式にString.prototype.padEndを参照してください</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でだけでなく、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDNのWebドキュメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="section004"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. String.prototype.padStart</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
padStart（）メソッドは、結果の行が指定された長さに達するように、現在の行を別の行で（必要に応じて数回）埋めます。</font><font style="vertical-align: inherit;">塗りつぶしは、現在の行の先頭（左）で実行されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">String</span>.prototype.padStart(maxLength [, fillString]) : <span class="hljs-built_in">String</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
maxLength-現在の行の完了後の要約行の長さ。</font><font style="vertical-align: inherit;">値が現在の行の長さより短い場合、現在の行は変更されずに返されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
fillString-現在の行を埋める文字列。</font><font style="vertical-align: inherit;">この文字列が指定された長さに対して長すぎる場合は、切り捨てられます。</font><font style="vertical-align: inherit;">デフォルト値は ""（0x0020スペース）です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-string">'abc'</span>.padStart(<span class="hljs-number">10</span>);         <span class="hljs-comment">// "       abc"</span>
<span class="hljs-string">'abc'</span>.padStart(<span class="hljs-number">10</span>, <span class="hljs-string">"foo"</span>);  <span class="hljs-comment">// "foofoofabc"</span>
<span class="hljs-string">'abc'</span>.padStart(<span class="hljs-number">6</span>,<span class="hljs-string">"123465"</span>); <span class="hljs-comment">// "123abc"</span>
<span class="hljs-string">'abc'</span>.padStart(<span class="hljs-number">8</span>, <span class="hljs-string">"0"</span>);     <span class="hljs-comment">// "00000abc"</span>
<span class="hljs-string">'abc'</span>.padStart(<span class="hljs-number">1</span>);          <span class="hljs-comment">// "abc"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜpadLeftおよびpadRightと呼ばれるパディングメソッドがないのですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
双方向または右から左へ記述する言語の場合、「左」および「右」という用語は機能しません。</font><font style="vertical-align: inherit;">したがって、padStartとpadEndの命名は、startsWithとendWithWithで始まる既存の名前に従います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
公式にString.prototype.padStartを参照してください</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でだけでなく、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDNのWebドキュメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="section005"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Object.getOwnPropertyDescriptor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Object.getOwnPropertyDescriptor（）メソッドは、渡されたオブジェクトの独自のプロパティ（つまり、オブジェクトに直接配置され、プロトタイプチェーンを通じて受信されないプロパティ）のプロパティ記述子を返します。</font><font style="vertical-align: inherit;">プロパティが存在しない場合はundefinedを返します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, prop) : <span class="hljs-built_in">Object</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
obj-プロパティが検索されるオブジェクト。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
prop-説明が返されるプロパティの名前。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドを使用すると、プロパティの正確な説明を表示できます。</font><font style="vertical-align: inherit;">JavaScriptのプロパティは、文字列名とプロパティ記述子で構成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロパティ記述子は、次の属性のいくつかを持つレコードです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value-プロパティに関連付けられた値（データ記述子のみ）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">writable-プロパティに関連付けられた値を変更できる場合はtrue、それ以外の場合はfalse（データ記述子のみ）。</font></font></li>
<li>get — ,   ,  undefined,     (   ).</li>
<li>set — ,   ,  undefined,     (   ).</li>
<li>configurable —  true,                  ,  false.</li>
<li>enumerable —  true,          ,  false.</li>
</ul><br>
<b></b><br>
<br>
<pre><code class="javascript hljs">obj = {
    <span class="hljs-keyword">get</span> <span class="hljs-title">foo</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<font></font>
    }<font></font>
};<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">'foo'</span>)); <span class="hljs-comment">// {set: undefined, enumerable: true, configurable: true, get: ƒ}</span><font></font>
<font></font>
obj2 = { <span class="hljs-attr">bar</span>: <span class="hljs-number">42</span> };
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj2, <span class="hljs-string">'bar'</span>)); <span class="hljs-comment">// {value: 42, writable: true, enumerable: true, configurable: true}</span></code></pre><br>
<h4>  Object.getOwnPropertyDescriptor()</h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用例：プロパティをオブジェクトにコピー</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
するES6以降、JavaScriptにはプロパティをコピーするためのインストルメンタルメソッドObject.assign（）がすでにあります。</font><font style="vertical-align: inherit;">ただし、このメソッドは単純なgetおよびset操作を使用して、キーがキーであるプロパティをコピーします。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> value = source[key]; <span class="hljs-comment">// get</span>
target[key] = value; <span class="hljs-comment">// set</span></code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり、デフォルトで指定されている以外の属性（取得、設定、書き込みなどのメソッド）を持つプロパティは正しくコピーされません。</font><font style="vertical-align: inherit;">次の例は、この制限を示しています。</font><font style="vertical-align: inherit;">オブジェクトのソースには、キーがfooであるインストーラーがあります。</font></font><pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = {
    <span class="hljs-keyword">set</span> <span class="hljs-title">foo</span>(<span class="hljs-params">value</span>) {
        <span class="hljs-built_in">console</span>.log(value);<font></font>
    }<font></font>
};<font></font>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, <span class="hljs-string">'foo'</span>));
<span class="hljs-comment">// { get: undefined, set: [Function: foo], enumerable: true, configurable: true }</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Object.assign（）を使用してfooプロパティをターゲットオブジェクトにコピーすると失敗します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> target1 = {};
<span class="hljs-built_in">Object</span>.assign(target1, source);
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(target1, <span class="hljs-string">'foo'</span>));
<span class="hljs-comment">// { value: undefined, writable: true, enumerable: true, configurable: true }</span></code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 幸い、Object.getOwnPropertyDescriptors（）とObject.defineProperties（）を併用すると機能します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> target2 = {};
<span class="hljs-built_in">Object</span>.defineProperties(target2, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source));
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(target2, <span class="hljs-string">'foo'</span>));
<span class="hljs-comment">// { get: undefined, set: [Function: foo], enumerable: true, configurable: true }</span></code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用例：オブジェクトの複製</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
浅い複製はプロパティのコピーに似ているため、Object.getOwnPropertyDescriptors（）もここで適切な選択です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今回は、2つのパラメーターを持つObject.create（）を使用します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のパラメーターは、返されたオブジェクトのプロトタイプを示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オプションの2番目のパラメーターは、Object.getOwnPropertyDescriptors（）によって返されるものと同様のプロパティ記述子のコレクションです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> clone = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.getPrototypeOf(obj), <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(obj));</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3番目の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用例：任意のプロトタイプを持つクロスプラットフォームオブジェクトリテラル。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトリテラルを使用して任意のプロトタイプを持つオブジェクトを作成する構文的に最適な方法は、特別な__proto__プロパティを使用することです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj = {
    <span class="hljs-attr">__proto__</span>: prot,
    <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span>,<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、この機能はブラウザにのみ存在することが保証されています。</font><font style="vertical-align: inherit;">一般的な回避策はObject.create（）と代入です。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(prot);<font></font>
obj.foo = <span class="hljs-number">123</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、Object.getOwnPropertyDescriptors（）を使用することもできます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(<font></font>
    prot,<font></font>
    <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors({
        <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span>,<font></font>
    })<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の選択肢はObject.assign（）です。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.assign(
    <span class="hljs-built_in">Object</span>.create(prot),<font></font>
    {<font></font>
        <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span>,<font></font>
    }<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
落とし穴：スーパーを使用してメソッドをコピーします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
superが使用するメソッドは、ホームオブジェクト（メソッドが格納されているオブジェクト）に緊密にバインドされています。</font><font style="vertical-align: inherit;">現在、このようなメソッドを別のオブジェクトにコピーまたは移動する方法はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
公式</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN Webドキュメントの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Object.getOwnPropertyDescriptorを参照してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="section006"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.末尾のコンマ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
末尾のコンマは、JavaScriptコードに新しい要素、パラメーター、またはプロパティを追加するときに役立ちます。</font><font style="vertical-align: inherit;">新しいプロパティを追加したい場合は、ハンギングコンマが既に使用されている場合は、前の行を変更せずに新しい行を追加するだけです。</font><font style="vertical-align: inherit;">これにより、バージョン管理の違いが明確になり、コードの変更に伴う問題が軽減されます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リテラルでのコンマのぶら下げ</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
JavaScriptは、配列内のハングしているコンマを無視します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> arr = [ <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ];<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">// [0, 1, 2]</span>
<span class="hljs-built_in">console</span>.log(arr.length); <span class="hljs-comment">// 3</span><font></font>
<font></font>
<span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,,,];
<span class="hljs-built_in">console</span>.log(arr2.length); <span class="hljs-comment">// 5</span>
arr2.forEach(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(e)); <span class="hljs-comment">// 0 1 2</span>
<span class="hljs-built_in">console</span>.log(arr.map(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e)); <span class="hljs-comment">// 0 1 2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のぶら下がりポイントが使用されている場合、穴が作成されます。</font><font style="vertical-align: inherit;">「穴」のある配列はスパースと呼ばれます（密な配列には「穴」はありません）。</font><font style="vertical-align: inherit;">たとえば、Array.prototype.forEach（）またはArray.prototype.map（）を使用して配列を反復する場合、ホールはスキップされます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクト</font></font></b><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> object = { 
  <span class="hljs-attr">foo</span>: <span class="hljs-string">"bar"</span>, 
  <span class="hljs-attr">baz</span>: <span class="hljs-string">"qwerty"</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">42</span>,<font></font>
};<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(object); <span class="hljs-comment">// {foo: "bar", baz: "qwerty", age: 42}</span></code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数でコンマをぶら下げ</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータ</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の定義次の関数のパラメータの定義は有効であり、互いに同等です。</font><font style="vertical-align: inherit;">ダングリングコンマは、関数またはそれらの引数オブ​​ジェクトの長さプロパティに影響を与えません。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">p</span>) </span>{}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">p,</span>) </span>{} <font></font>
<font></font>
(p) =&gt; {};<font></font>
<span class="hljs-function">(<span class="hljs-params">p,</span>) =&gt;</span> {};</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドの定義</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ぶら下がりカンマは、クラスまたはオブジェクトのメソッドの定義にも使用できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>{<font></font>
  one(a,) {},<font></font>
  two(a, b,) {},<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> obj = {<font></font>
  one(a,) {},<font></font>
  two(a, b,) {},<font></font>
};</code></pre><br>
<b><font style="vertical-align: inherit;"></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数</font><b><font style="vertical-align: inherit;">呼び出し</font></b><font style="vertical-align: inherit;">以下の</font><b><font style="vertical-align: inherit;">関数</font></b><font style="vertical-align: inherit;">呼び出しは有効であり、互いに同等です。</font></font><br>
<br>
<pre><code class="javascript hljs">f(p);<font></font>
f(p,);<font></font>
<font></font>
<span class="hljs-built_in">Math</span>.max(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);
<span class="hljs-built_in">Math</span>.max(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>,);</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無効なぶら下げコンマ</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
関数パラメーターを定義するか、コンマのみを含む関数を呼び出すと、SyntaxErrorがスローされます。</font><font style="vertical-align: inherit;">また、残りのパラメーターを使用する場合、コンマをぶら下げることはできません。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">,</span>) </span>{} <span class="hljs-comment">// SyntaxError: missing formal parameter</span>
(,) =&gt; {};       <span class="hljs-comment">// SyntaxError: expected expression, got ','</span>
f(,)             <span class="hljs-comment">// SyntaxError: expected expression, got ','</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">...p,</span>) </span>{} <span class="hljs-comment">// SyntaxError: parameter after rest parameter</span>
(...p,) =&gt; {}        <span class="hljs-comment">// SyntaxError: expected closing parenthesis, got ','</span></code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造破壊におけるカンマの吊り下げ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
破壊的な代入を使用する場合は、左側にコンマを掛けることもできます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     </span>
[a, b,] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<font></font>
<font></font>
<span class="hljs-comment">//     </span>
<span class="hljs-keyword">var</span> o = {
  <span class="hljs-attr">p</span>: <span class="hljs-number">42</span>, 
  <span class="hljs-attr">q</span>: <span class="hljs-literal">true</span>,<font></font>
};<font></font>
<span class="hljs-keyword">var</span> {p, q,} = o;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一度、残りのパラメーターを使用して、SyntaxErrorがスローされます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> [a, ...b,] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-comment">// Uncaught SyntaxError: Rest element must be last element</span></code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSONぶら下がりカンマ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトのダングリングコンマはECMAScript 5でのみ許可されます。JSONはES5より古いJavaScript構文に基づいているため、JSONではダングリング</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンマ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は許可さ</font><b><font style="vertical-align: inherit;">れ</font></b><font style="vertical-align: inherit;">ません</font><b><font style="vertical-align: inherit;">。</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
両方の行でSyntaxErrorがスローされます</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">'[1, 2, 3, 4, ]'</span>);
<span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">'{"foo" : 1, }'</span>);
<span class="hljs-comment">// Uncaught SyntaxError: Unexpected token ] in JSON</span>
<span class="hljs-comment">// Uncaught SyntaxError: Unexpected token } in JSON</span></code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜカンマを掛けるのが便利なのですか？</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの利点があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、最後の要素の位置が変わってもコンマを追加または削除する必要がないため、要素の再配置が簡単になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、バージョン管理システムが実際に何が変更されたかを追跡するのに役立ちます。</font><font style="vertical-align: inherit;">たとえば、次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">[<font></font>
    'Foo'<font></font>
]<font></font>
:<font></font>
[<font></font>
    'Foo',<font></font>
    ''<font></font>
]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際の変更は最後の行を追加することだけですが、「foo」を含む行と「bar」を含む行の両方が変更済みとしてマークされます。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">MDN Web Docsの</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
末尾のコンマを参照してください</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<a name="section007"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. SharedArrayBuffer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SharedArrayBufferオブジェクトは、ArrayBufferオブジェクトと同様に、プリミティブバイナリデータを格納するための固定長の分割バッファーを作成するために使用されますが、対照的に、SharedArrayBufferインスタンスを使用して、共有メモリ上にビューを作成できます。</font><font style="vertical-align: inherit;">SharedArrayBufferは切断できません。</font></font><pre><code class="javascript hljs"><span class="hljs-keyword">new</span> SharedArrayBuffer(length) : <span class="hljs-built_in">Object</span></code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">length-バッファ配列を作成するためのサイズ（バイト単位）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
return-指定された長さの新しいSharedArrayBufferオブジェクト。初期化後のコンテンツは0です</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。SharedArrayBufferオブジェクトを使用してクラスター内のエージェントと別のエージェント（エージェントはWebページのメインプログラムまたはWebワーカーのいずれか）の間でメモリを分割するには、postMessageと構造化クローンを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造化クローニングアルゴリズムは、SharedArrayBuffersと、SharedArrayBuffersにマップされたTypedArraysを受け入れます。どちらの場合も、SharedArrayBufferオブジェクトがレシーバーに渡され、レシーバー内に新しいプライベートSharedArrayBufferオブジェクトが作成されます（ArrayBufferの場合と同様）。ただし、両方のSharedArrayBufferオブジェクトによって参照される共有データブロックは同じデータブロックであり、いずれかのエージェントのブロック内のサードパーティの効果は、最終的に他のエージェントで表示されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> sab = <span class="hljs-keyword">new</span> SharedArrayBuffer(<span class="hljs-number">1024</span>);<font></font>
worker.postMessage(sab);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
共有メモリは、ワーカーまたはメインスレッドで同時に作成および変更できます。</font><font style="vertical-align: inherit;">システム（CPU、OS、ブラウザ）によっては、変更がすべてのコンテキストに反映されるまでに時間がかかる場合があります。</font><font style="vertical-align: inherit;">同期には、アトミック操作が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
共有配列バッファは、より高いレベルの並列処理抽象化のための基本的なビルディングブロックです。</font><font style="vertical-align: inherit;">それらにより、SharedArrayBufferオブジェクトのバイトを複数のワーカーとメインスレッドの間で共有できます（バッファーはバイトにアクセスするために共有され、型付き配列にラップされます）。</font><font style="vertical-align: inherit;">このタイプの交換には2つの利点があり</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。ワーカー間でデータをより速く交換できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ワーカー間の調整はより簡単で高速です（postMessage（）と比較して）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ワーカーの実装は以下の通りです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// worker.js</span><font></font>
<font></font>
self.addEventListener (<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
     <span class="hljs-keyword">const</span> {sharedBuffer} = event.data;
     <span class="hljs-keyword">const</span> sharedArray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int32Array</span> (sharedBuffer);<font></font>
<font></font>
     <span class="hljs-comment">// ···</span><font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、送信された共有配列のバッファーを抽出し、それを型付き配列にラップして、ローカルで使用できるようにします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SharedArrayBufferのプロパティとメソッド。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
SharedArrayBuffer.length-SharedArrayBufferコンストラクターの長さ。値は1です</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。SharedArrayBuffer.prototype-すべてのSharedArrayBufferオブジェクトに追加のプロパティを許可します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SharedArrayBufferインスタンスSharedArrayBuffer.prototype.constructor </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティ</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
-オブジェクトのプロトタイプを作成する関数を定義します。初期値は、標準の組み込みSharedArrayBufferコンストラクターです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SharedArrayBuffer.prototype.byteLength（読み取り専用）-配列のサイズ（バイト単位）。これは、アレイの作成時に設定され、変更できません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SharedArrayBuffer.prototype.slice（）-内容がこのSharedArrayBufferの最初から最後までを含む、Exclusiveのバイトのコピーである新しいSharedArrayBufferを返します。先頭または末尾が負の場合、これは最初からではなく、配列の最後からのインデックスを参照します。このメソッドのアルゴリズムは、Array.prototype.slice（）と同じです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  SharedArrayBuffer    </span>
<span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">new</span> SharedArrayBuffer(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> int32View = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int32Array</span>(buffer); <span class="hljs-comment">//  view</span>
<span class="hljs-comment">// produces Int32Array [0, 0, 0, 0]</span><font></font>
<font></font>
int32View[<span class="hljs-number">1</span>] = <span class="hljs-number">42</span>;
<span class="hljs-keyword">const</span> sliced = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int32Array</span>(buffer.slice(<span class="hljs-number">4</span>,<span class="hljs-number">12</span>));<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(sliced); <span class="hljs-comment">// Int32Array [42, 0]</span></code></pre><br>
<pre><code class="javascript hljs">sab.slice([begin, end]) : <span class="hljs-built_in">Object</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
begin-抽出を開始するゼロのインデックス。シーケンスの最後からのオフセットを示す負のインデックスを使用できます。スライス（-2）は、シーケンスの最後の2つの要素を抽出します。開始が定義されていない場合、スライスはインデックス0から始まります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
終了-抽出を完了する必要があるゼロベースのインデックス。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、スライス（1,4）は、2番目の要素から4番目の要素（インデックス1、2、および3の要素）を取得します。シーケンスの最後からのオフセットを示す負のインデックスを使用できます。 slice（2、-1）は、シーケンスの最後から2番目の要素から3番目の要素を取得します。 endを省略すると、sliceはシーケンスの最後（sab.byteLength）までフェッチします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> sab = <span class="hljs-keyword">new</span> SharedArrayBuffer(<span class="hljs-number">1024</span>);<font></font>
sab.slice();    <span class="hljs-comment">// SharedArrayBuffer { byteLength: 1024 }</span>
sab.slice(<span class="hljs-number">2</span>);   <span class="hljs-comment">// SharedArrayBuffer { byteLength: 1022 }</span>
sab.slice(<span class="hljs-number">-2</span>);  <span class="hljs-comment">// SharedArrayBuffer { byteLength: 2 }</span>
sab.slice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// SharedArrayBuffer { byteLength: 1 }</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
公式</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN Web文書の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SharedArrayBufferを参照してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="section008"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.アトミクス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atomicsオブジェクトは、静的メソッドとしてアトミック操作を提供します。</font><font style="vertical-align: inherit;">SharedArrayBufferオブジェクトで使用されます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atomic操作は、Atomicsモジュールにインストールされます。</font><font style="vertical-align: inherit;">他のグローバルオブジェクトとは異なり、Atomicsはコンストラクタではありません。</font><font style="vertical-align: inherit;">new演算子と共に使用したり、Atomicsオブジェクトを関数として呼び出したりすることはできません。</font><font style="vertical-align: inherit;">すべてのAtomicsプロパティとメソッドは静的です（たとえば、Mathオブジェクトのように）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリを共有すると、複数のスレッドが同じデータをメモリに読み書きできます。</font><font style="vertical-align: inherit;">アトミック操作は、期待値が読み書きされること、および次の操作が作業を開始する前に完了した操作が保証され、中断されません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atomics [Symbol.toStringTag]-このプロパティの値はAtomicsです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原子操作</font></font></b><br>
<br>
<ul>
<li>Atomics.add() —          .      .</li>
<li>Atomics.and() —   AND    .      .</li>
<li>Atomics.compareExchange() —       ,     .   .</li>
<li>Atomics.exchange() —       .   .</li>
<li>Atomics.load() —      .</li>
<li>Atomics.or() —   OR    .      .</li>
<li>Atomics.store() —       .  .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atomics.sub（）-配列の指定された位置にある電流から現在の値を減算します。</font><font style="vertical-align: inherit;">この位置の前の値を返します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atomics.xor（）-指定された配列位置でビットごとのXORを計算します。</font><font style="vertical-align: inherit;">この位置の前の値を返します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atomics.add（）静的メソッドは、配列内の指定された位置にある現在の値に値を追加し、この位置で以前の値を返します。</font><font style="vertical-align: inherit;">このアトミック操作により、変更された値が書き戻されるまで、他の書き込みは行われません。</font></font><br>
<br>
<pre><code class="javascript hljs">Atomics.add(typedArray, index, value) : mixed</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">typedArray-整数の分割配列。</font><font style="vertical-align: inherit;">Int8Array、Uint8Array、Int16Array、Uint16Array、Int32ArrayまたはUint32Array。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">index-値を追加するtypedArray内の位置。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value-追加する数値。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">return-指定された位置の以前の値（typedArray [インデックス]）。</font></font></li>
</ul><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">typedArray型が有効な整数型の1つでない場合、TypeErrorをスローします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">typedArray型がジェネリック型ではない場合、TypeErrorをスローします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスがtypedArrayの外にある場合、RangeErrorをスローします。</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> sab = <span class="hljs-keyword">new</span> SharedArrayBuffer(<span class="hljs-number">1024</span>);
<span class="hljs-keyword">var</span> ta = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(sab);<font></font>
<font></font>
Atomics.add(ta, <span class="hljs-number">0</span>, <span class="hljs-number">12</span>); <span class="hljs-comment">//  0,  </span>
Atomics.load(ta, <span class="hljs-number">0</span>); <span class="hljs-comment">// 12</span></code></pre><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN Web Docsの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Atomics.add（）</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待って通知する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
wait（）メソッドとwake（）メソッドは、futex（「高速ユーザー空間ミューテックス」）Linuxに基づいてモデル化され、特定の状態がtrueにならない瞬間を待機する方法を提供し、通常はブロッキング構造として使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atomics.wait（）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まだ存在する配列</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">値が指定された位置に含まれていて、スリープ状態になっているか、タイムアウトしているかどうかを確認します。 ok、等しくない、またはタイムアウトを返します。呼び出し元のエージェントで待機が許可されていない場合、例外エラーがスローされます（ほとんどのブラウザーは、ブラウザーのメインストリームで待機（）を許可していません）。</font></font><br>
<br>
<ul>
<li>Atomics.wait() — ,               -.  «ok», «not-equal»  «timed-out».       ,     (    wait()    ).</li>
<li>Atomics.wake() —   ,         .   ,   .</li>
<li>Atomics.isLockFree(size) —  ,            .  true,                 (  ).   .</li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適化の問題</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最適化により、コードはワーカー間で予測できなくなります。</font><font style="vertical-align: inherit;">シングルスレッドでは、コンパイラーはマルチスレッドコードを破壊する最適化を実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、次のコードを見てください。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">while</span> (sharedArray [<span class="hljs-number">0</span>] === <span class="hljs-number">123</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シングルスレッドでは、ループの実行中にsharedArray [0]の値が変更されることはありません（sharedArrayが配列または何らかの方法で修正されていない型付き配列の場合）。</font><font style="vertical-align: inherit;">したがって、コードは次のように最適化できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> tmp = sharedArray [<span class="hljs-number">0</span>];
<span class="hljs-keyword">while</span> (tmp === <span class="hljs-number">123</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、マルチスレッドモードでは、この最適化により、このテンプレートを使用して別のスレッドで行われる変更を待つことができません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の例は次のコードです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// main.js</span>
sharedArray [<span class="hljs-number">1</span>] = <span class="hljs-number">11</span>;<font></font>
sharedArray [<span class="hljs-number">2</span>] = <span class="hljs-number">22</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つのスレッドでは、これらの間で何も読み取られないため、これらの書き込み操作を再配置できます。</font><font style="vertical-align: inherit;">記録が特定の順序で実行されることが予想される場合、複数のスレッドで問題が発生します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// worker.js</span>
<span class="hljs-keyword">while</span> (sharedArray [<span class="hljs-number">2</span>]! == <span class="hljs-number">22</span>);
<span class="hljs-built_in">console</span>.log (sharedArray [<span class="hljs-number">1</span>]); <span class="hljs-comment">// 0  11</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのタイプの最適化により、同じバッファーで作業している複数のワーカーのアクションを共通の配列と同期させることがほぼ不可能になります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適化問題の解決</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atomicsグローバル変数の使用。そのメソッドには3つの主な使用例があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の使用例：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atomicsメソッドは、他のワーカーと同期するために使用できます。</font><font style="vertical-align: inherit;">たとえば、次の2つの操作では、データの読み取りと書き込みが可能で、コンパイラによって並べ替えられることはありません。</font></font><br>
<br>
<pre><code class="javascript hljs">Atomics.load (TypedArray &lt;T&gt;, index) : T<font></font>
Atomics.store (TypedArray &lt;T&gt;, index, <span class="hljs-attr">value</span>: T) : T</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイデアは、通常の操作を使用してほとんどのデータを読み書きすることですが、Atomics操作（読み込み、保存など）は、読み取りと書き込みが安全であることを保証します。多くの場合、ロックなど、Atomicsに基づく独自の同期メカニズムを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Atomicsのおかげで常に機能する非常に単純な例です（私はsharedArrayの設定をスキップしました）。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// main.js</span>
<span class="hljs-built_in">console</span>.log (<span class="hljs-string">'notified...'</span>);<font></font>
Atomics.store (sharedArray, <span class="hljs-number">0</span>, <span class="hljs-number">123</span>);<font></font>
<font></font>
<span class="hljs-comment">// worker.js</span>
<span class="hljs-keyword">while</span> (Atomics.load (sharedArray, <span class="hljs-number">0</span>)! == <span class="hljs-number">123</span>);
        <span class="hljs-built_in">console</span>.log (<span class="hljs-string">'notified'</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の使用例：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通知を待つ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
whileループを使用して通知を待機することはあまり効率的ではないため、Atomicsには、Atomics.wait（Int32Array、インデックス、値、タイムアウト）およびAtomics.wake（Int32Array、インデックス、カウント）に役立つ操作があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目のユースケース：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アトミック操作</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
一部のアトミック操作は算術演算を行い、同時に中断できないため、同期に役立ちます。例えば：</font></font><br>
<br>
<pre><code class="javascript hljs">Atomics.add (TypedArray &lt;T&gt;, index, value) : T</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大まかに言えば、この操作は次のことを実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
破れた値の問題。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
共有メモリのもう1つの問題の影響は、値（ガベージ）が破損していることです。読み取り時には、中間値が表示されます。新しい値がメモリに書き込まれる前の値も、新しい値もありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仕様のTear-Free Readsセクションでは、以下の場合にのみギャップがないと述べています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読み取りと書き込みの両方が、（DataViewではなく）型付き配列を介して行われます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">両方の型付き配列は、共有配列バッファーと整列されます：sharedArray.byteOffset％sharedArray.BYTES_PER_ELEMENT === 0</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">両方の型付き配列は、要素ごとに同じバイト数を持っています。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言い換えると、共有配列の同じバッファーに次のようにアクセスすると、破損した値が問題になります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つ以上のDateView;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整列されていない型付き配列が1つ以上あります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素のサイズが異なる型付き配列。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのケースで値のギャップを回避するには、Atomicsまたはsyncを使用します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用中の共有配列バッファー</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
保留中の関数を実行するための共有配列バッファーとJavaScriptセマンティクス。 JavaScriptには、いわゆる「完了」の実行セマンティクスがあります。各関数は、完了するまで別のスレッドによって中断されないことを期待できます。関数はトランザクションになり、完全なアルゴリズムを実行できますが、中間状態で機能するデータは誰にも表示されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
共有アレイバッファは完了（RTC）までサイクルを中断します。関数が処理しているデータは、関数の実行中に別のスレッドによって変更される可能性があります。ただし、コードはこのRTC違反が発生するかどうかを完全に制御します。共有配列バッファーを使用しない場合は安全です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、非同期関数がRTCに違反する方法とほぼ同じです。そこで、awaitキーワードを使用してロック操作を有効にします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
共有配列バッファにより、emscriptenはasm.jsでpthreadをコンパイルできます。 emscriptenドキュメントページの引用：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[En] [共有配列バッファーで許可] Emscriptenアプリケーションは、Webワーカー間でメインメモリヒープを共有できます。これは、低レベルのアトミックのプリミティブおよびfutexサポートとともに、EmscriptenがPthread（POSIXスレッド）APIのサポートを実装できるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Ru] [共有配列バッファーで許可] Emscriptenアプリケーションは、Webワーカー間で大量のメインメモリを共有します。低レベルのアトミックプリミティブとfutexのサポートに加えて、EmscriptenはPthreads API（POSIXスレッド）のサポートを有効にします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、asm.jsでマルチスレッドのCおよびC ++コードをコンパイルできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WebAssemblyでマルチスレッドを使用する最良の方法についての議論が進行中です。</font><font style="vertical-align: inherit;">Webワーカーが比較的重い場合、WebAssemblyが軽量スレッドを導入する可能性があります。</font><font style="vertical-align: inherit;">トピックがWebAssemblyの将来に向かっていることもわかります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整数以外のデータを交換する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現時点では、使用できるのは整数の配列（最大32ビット長）のみです。</font><font style="vertical-align: inherit;">つまり、他の種類のデータを共有する唯一の方法は、それらを整数としてエンコードすることです。</font><font style="vertical-align: inherit;">役立つツールには、次のものがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TextEncoderとTextDecoder：前者は文字列をUint8Arrayインスタンスに変換し、後者はその逆を行います。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stringview.js：文字列を文字の配列として扱うライブラリ。</font><font style="vertical-align: inherit;">バッファの配列を使用します。</font></font></li>
<li>FlatJS:  JavaScript        (,   )    (ArrayBuffer  SharedArrayBuffer). JavaScript + FlatJS    JavaScript. JavaScript  (TypeScript  . .) .</li>
<li>TurboScript:  JavaScript-    .    asm.js  WebAssembly.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終的には、データ交換のための追加の（より高いレベルの）メカニズムが現れる可能性があります。そして、実験はこれらのメカニズムがどのように見えるべきかを理解し続けるでしょう。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共有配列バッファを使用するコードはどれくらい速く動作しますか？</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Lars T. Hansenは、Mandelbrotアルゴリズムの2つの実装を書いています（彼の記事「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Taste of JavaScript's New Parallel Primitives</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」で</font><font style="vertical-align: inherit;">説明されているように</font><font style="vertical-align: inherit;">、シリアルバージョンと複数のWebワーカーを使用するパラレルバージョン。最大4つのWebワーカー、つまり、プロセッサコア、アクセラレーション線形に増加し、毎秒6.9フレーム（1 Webワーカー）から毎秒25.4フレーム（4 Webワーカー）に増加します。Webワーカーが増えると、生産性が向上しますが、適度なものになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハンセンは、加速は印象的であるが、並列作業はより複雑なコードによるものであると指摘しています。</font><font style="vertical-align: inherit;">共有配列バッファーとサポート技術に関する</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加情報</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共有メモリ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Lars T. Hansenによる</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">簡単なチュートリアル</font></a></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lars T. Hansenによる</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">JavaScriptの新しい並列プリミティブの味</font></a></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SharedArrayBufferとAtomicsステージ2.95からステージ3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（PDF）、Shu-yu GuoとLars T. Hansenによるスライド（2016-11-30）[ES文に付随するスライド]</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eric Bidelmanによる</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Webワーカーの基本</font></a><font style="vertical-align: inherit;"> [Webワーカーの紹介]。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その他のJavaScript同時実行テクノロジー：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScriptをパラレルパス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デイブ・ハーマン[JavaScriptがPJSを放棄した後、移動場所の概要]で」</font></font></li>
<li>“<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">Write massively-parallel GPU code for the browser with WebGL</a>” by Steve Sanderson [ , ,   WebGL      GPU].</li>
<li>“<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">Concurrency is not parallelism</a>” by Rob Pike [Rob Pike   «concurrency»  «parallelism»    ].</li>
<li>"<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">Using Web Workers</a>" from MDN [  MDN,      web workers].</li>
<li>"<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">Shared memory and atomics</a>" by Axel Rauschmayer [     js   Shared Array Buffers  Atomics]</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
公式</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN Web Docsの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atomics Objectを参照してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="section009"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9.非同期機能</font></font></h2><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AsyncFunctionコンストラクターを使用して非同期関数を作成する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AsyncFunctionコンストラクターは、新しい非同期関数オブジェクトを作成します。</font><font style="vertical-align: inherit;">JavaScriptでは、非同期関数は実際にはAsyncFunctionオブジェクトです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AsyncFunctionはグローバルオブジェクトではないことに注意してください。</font><font style="vertical-align: inherit;">以下のコードを実行することで取得できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}).constructor</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構文</font></font></b><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">new</span> AsyncFunction([arg1[, arg2[, ...argN]],] functionBody)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
arg1、arg2、... argN-関数が正式な引数名として使用する名前。各名前は、有効なJavaScript識別子に一致する文字列、またはコンマで区切られたそのような文字列のリストである必要があります。たとえば、「x」、「theValue」、「a、b」などです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
functionBody-JavaScriptソースコード内の関数の定義を含む文字列。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AsyncFunctionコンストラクターを使用して作成された非同期関数オブジェクトは、関数の作成時に解析されます。これは、非同期関数式を使用して非同期関数を宣言し、コード内で呼び出すよりも効率的ではありません。これは、そのような関数がコードの残りの部分で解析されるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数に渡されたすべての引数は、作成された関数のパラメーター識別子の名前として、渡された順序で処理されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AsyncFunctionコンストラクターを関数として（new演算子を使用せずに）呼び出すと、コンストラクターとして呼び出すのと同じ効果があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AsyncFunctionコンストラクターを使用して作成された非同期関数は、それらを作成するコンテキストに短絡しません。</font><font style="vertical-align: inherit;">これらは常にグローバルスコープで作成されます。</font><font style="vertical-align: inherit;">起動すると、ローカル変数とグローバル変数のみにアクセスできますが、AsyncFunctionコンストラクターが呼び出されたスコープにはアクセスできません。</font><font style="vertical-align: inherit;">これは、非同期関数のコードでevalを使用する場合とは異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AsyncFunctionコンストラクターを使用して非同期関数を作成する例</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveAfter2Seconds</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {<font></font>
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
      resolve(x);<font></font>
    }, <span class="hljs-number">2000</span>);<font></font>
  });<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">var</span> AsyncFunction = <span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}).constructor<font></font>
<font></font>
<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> AsyncFunction(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'return await resolveAfter2Seconds(a) + await resolveAfter2Seconds(b);'</span>);<font></font>
<font></font>
a(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>).then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(v); <span class="hljs-comment">//  30  4 </span>
});</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期関数宣言</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
async関数宣言は、AsyncFunctionオブジェクトを返す非同期関数を定義します。非同期関数式を使用して非同期関数を定義することもできます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構文</font></font></b><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span>(<span class="hljs-params">[param[, param[, ... param]]]</span>) </span>{
   <span class="hljs-comment">// body</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
name-関数の名前。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
param-関数に渡される引数の名前。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステートメント-関数本体を含む式。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
呼び出し後、async関数はPromiseを返します。結果を受け取るとPromiseが完了し、受け取った値を返します。非同期関数が例外をスローすると、Promiseはスロー値で失敗します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
async関数には、async関数の実行を一時停止し、渡されたPromiseからの応答を待ち、async関数を再開して受信した値を返すawait式を含めることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
awaitキーワードは、非同期関数でのみ有効です。別のコンテキストでは、SyntaxErrorエラーが発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
async / await関数の目的は、Promiseの使用を同期的に単純化し、Promisesグループで何らかのアクションを実行することです。</font><font style="vertical-align: inherit;">Promiseが構造化されたコールバックのように、async / awaitはジェネレーターとpromiseの組み合わせのようなものです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveAfter2Seconds</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {<font></font>
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
      resolve(x);<font></font>
    }, <span class="hljs-number">2000</span>);<font></font>
  });<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add1</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">const</span> a = <span class="hljs-keyword">await</span> resolveAfter2Seconds(<span class="hljs-number">20</span>);
  <span class="hljs-keyword">const</span> b = <span class="hljs-keyword">await</span> resolveAfter2Seconds(<span class="hljs-number">30</span>);
  <span class="hljs-keyword">return</span> x + a + b;<font></font>
}<font></font>
<font></font>
add1(<span class="hljs-number">10</span>).then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(v);  <span class="hljs-comment">//  60  4 </span><font></font>
});<font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add2</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-keyword">const</span> a = resolveAfter2Seconds(<span class="hljs-number">20</span>);
  <span class="hljs-keyword">const</span> b = resolveAfter2Seconds(<span class="hljs-number">30</span>);
  <span class="hljs-keyword">return</span> x + <span class="hljs-keyword">await</span> a + <span class="hljs-keyword">await</span> b;<font></font>
}<font></font>
<font></font>
add2(<span class="hljs-number">10</span>).then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(v);  <span class="hljs-comment">//  60  2 </span>
});</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期とは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSプログラムは1つの.jsファイルで記述できますが、コードは確実にいくつかの部分に分割されます。そして、現在は1つの部分だけが実行され、残りは後で実行されます。関数は、プログラムを部分に分割するために最もよく使用される手法です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSを初めて目にするほとんどの開発者にとっての主な問題は、今すぐに起こらないことを理解できないことです。つまり、現在完了できないタスクは、定義上、非同期で終了します。また、想定しているプログラムのブロック動作はありません。 （You-Dont-Know-JS /非同期＆パフォーマンス、Jake Archibald）。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// ajax(..)  Ajax-,  </span>
<span class="hljs-keyword">var</span> data = ajax( <span class="hljs-string">"http://some.url.1"</span> );<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log( data );<span class="hljs-comment">// !  `data`     Ajax-</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
間違いは何ですか？</font><font style="vertical-align: inherit;">console.log（）は、リクエストからデータを受け取る前に実行されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今から後で「待つ」という明白な決定は、コールバックを使用することです。</font></font><br>
<br>
<pre><code class="javascript hljs">ajax( <span class="hljs-string">"http://some.url.1"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCallbackFunction</span>(<span class="hljs-params">data</span>)</span>{<font></font>
<font></font>
	<span class="hljs-built_in">console</span>.log( data ); <span class="hljs-comment">// ,   !</span><font></font>
<font></font>
} );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同期コード実行を時期尚早に解決するためのさまざまな方法を検討してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
getUser、getPosts、getCommentsの3つの関数があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> { getUser, getPosts, getComments } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./db'</span>);<font></font>
<font></font>
getUser(<span class="hljs-number">1</span>, (error, user) =&gt; {
	<span class="hljs-keyword">if</span>(error) <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.error(error);<font></font>
<font></font>
	getPosts(user.id, (error, posts) =&gt; {<font></font>
		<span class="hljs-keyword">if</span>(error) <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.error(error);<font></font>
<font></font>
		getComments(posts[<span class="hljs-number">0</span>].id, (error, comment) =&gt; {
			<span class="hljs-keyword">if</span>(error) <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.error(error);<font></font>
<font></font>
			<span class="hljs-built_in">console</span>.log(comments);<font></font>
		});<font></font>
	});<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、ピラミッドに新しい機能が追加されて増加することに気づかないのは難しいことです。このコーディングスタイルは、一般に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Callback Hell</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。これは、競合する（非同期）要求を制御する特定のパターンであり、実行のシーケンスを保証します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数の入れ子の問題の解決策の1つは、Promiseを使用することです（これは前回の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">説明しましたが</font><font style="vertical-align: inherit;">、これにより削除され、コードがすっきりします。エラーを処理するためのより便利な方法も提供されます。しかし、多くの人はこの構文を好みませんでした。</font></font><br>
<br>
<pre><code class="javascript hljs">getUser(<span class="hljs-number">1</span>)<font></font>
	.then(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> getPosts(user,id))<font></font>
	.then(<span class="hljs-function"><span class="hljs-params">posts</span> =&gt;</span> getComments(posts[<span class="hljs-number">0</span>].id))<font></font>
	.then(<span class="hljs-function"><span class="hljs-params">comments</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(comments))<font></font>
	.catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(error));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネレーターはPromise（以前の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でも調べました）の代わりになりました</font><font style="vertical-align: inherit;">。ジェネレーター自体は非同期コードの記述には適していませんが、Promiseと一緒に使用すると、ユニークなもの、つまり同期に見える非同期コードが得られます。同時に、ジェネレーターはtry ... catchコンストラクトを使用したおなじみのエラー処理メカニズム。大きなマイナス記号が1つあるのはジェネレーターだけです。Promiseで使用するには、ジェネレーターのプロセスを制御する別の関数が必要です。この関数を自分で作成するか、サードパーティを使用できます。ライブラリー、例えば</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">co</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この例では、そのような関数の実装を作成しました。</font></font><br>
<br>
<pre><code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">try</span> {
		<span class="hljs-keyword">let</span> user = <span class="hljs-keyword">yield</span> getUser(<span class="hljs-number">1</span>);
		<span class="hljs-keyword">let</span> posts = <span class="hljs-keyword">yield</span> getPosts(user.id);
		<span class="hljs-keyword">let</span> comments = <span class="hljs-keyword">yield</span> getComments(posts[<span class="hljs-number">0</span>].id);<font></font>
<font></font>
		<span class="hljs-built_in">console</span>.log(comments);<font></font>
	}<font></font>
	<span class="hljs-keyword">catch</span> (error) {
		<span class="hljs-built_in">console</span>.log(error);<font></font>
	}<font></font>
});<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">co</span>(<span class="hljs-params">generator</span>) </span>{
	<span class="hljs-keyword">const</span> iterator = generator();<font></font>
<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
		<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params">prev</span>) </span>{
			<span class="hljs-keyword">const</span> { value, done } = iterator.next(prev);<font></font>
<font></font>
			<span class="hljs-keyword">if</span> (done)<font></font>
				resolve(value);<font></font>
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>)<font></font>
				value.then(run, reject);<font></font>
			<span class="hljs-keyword">else</span><font></font>
				run(value);<font></font>
		}<font></font>
<font></font>
		run();<font></font>
	});<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期コードを使用する方法にはそれぞれ、長所と短所があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コールバック関数（コールバック関数）-使いやすいが、ネストされた関数が増えると、読みやすさが低下し始めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロミス（Promises）-エレガントで快適ですが、初心者には理解が困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネレーター-非同期コードを同期的に記述できますが、別の関数が必要であり、ジェネレーターの動作メカニズムは非常に混乱します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期コードは、非同期コードを簡単に理解できるようにするために、PromiseとGeneratorsに基づいて作成されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期関数とは何かを理解するために、次の例を検討してください。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUser</span>(<span class="hljs-params">id</span>) </span>{
	<span class="hljs-keyword">return</span> { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">let</span> user = getUser(<span class="hljs-number">1</span>);<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(user); <span class="hljs-comment">// { id: 1 }</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数を非同期にすると（asyncキーワードを追加）、関数はidプロパティを持つオブジェクトを含むPromiseを返します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUser</span>(<span class="hljs-params">id</span>) </span>{
	<span class="hljs-keyword">return</span> { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">let</span> user = getUser(<span class="hljs-number">1</span>);<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(user); <span class="hljs-comment">// Promise { {id: 1} }</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、非同期関数はすべてPromisを返す（つまり、Promisが返す値をラップする）と言えます。</font><font style="vertical-align: inherit;">非同期関数に返された値がすでにpromiseである場合、それは再び方向転換されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
promiseから値を取得するには、then（）メソッドを使用できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUser</span>(<span class="hljs-params">id</span>) </span>{<font></font>
<font></font>
	<span class="hljs-keyword">return</span> { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };<font></font>
}<font></font>
<font></font>
getUser(<span class="hljs-number">1</span>)<font></font>
	.then(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(user)); <span class="hljs-comment">// { id: 1 }</span></code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、後で説明するawaitキーワードを使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の例に戻りましょう（今回のみ、実際の関数を使用してHTTPリクエストを送信します。</font></font><br>
<br>
<pre><code class="javascript hljs">fetch(<span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span>)<font></font>
	.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> data.json())<font></font>
	.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(data));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Promiseを使用した非同期コードの外観です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、非同期関数を使用すれば、非同期コードを同期として書くことができます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendRequest</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">let</span> response= <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span>);<font></font>
<font></font>
	<span class="hljs-keyword">return</span> response.json();<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">await</span> sendRequest();<font></font>
<font></font>
	<span class="hljs-built_in">console</span>.log(a);<font></font>
}<font></font>
<font></font>
main();</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
唯一気に入らないのは、非同期演算子は非同期関数でしか使用できないことです。</font><font style="vertical-align: inherit;">それ以外の場合は、main（）関数を使用する必要はありません。</font><font style="vertical-align: inherit;">もちろん、then（）メソッドを使用することもできますが、その場合、コードは非同期として見えなくなります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendRequest</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">let</span> response= <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span>);<font></font>
<font></font>
	<span class="hljs-keyword">return</span> response.json();<font></font>
}<font></font>
<font></font>
sendRequest()<font></font>
	.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(data));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
肝心なことは、fetch（）からデータを取得するためにコールバック関数を使用しないことです。</font><font style="vertical-align: inherit;">代わりに、awaitキーワードを使用します。これは、言うまでもなく、fetch（）関数が実行されて結果が応答変数に書き込まれるまで待機することをランタイムに通知します。</font><font style="vertical-align: inherit;">そして、コールバック関数を使用して、フェッチ（）関数が実行されるのを待ち、コールバック関数を呼び出してデータを処理します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Promiseとasync関数の使用の明らかな違いは次のとおりです</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  Promise </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendRequest</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span>)<font></font>
		.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> data.json());<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//  async function</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendRequest</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span>);<font></font>
<font></font>
	<span class="hljs-keyword">return</span> response.json();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
await演算子は非同期関数の本体でのみ使用でき、そのアクションはpromiseを返す任意の関数で使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期関数で例外を処理するには、通常、try ... catch構文を使用します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendRequest</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`https://jsonplaceholder.typicode.com/users/1`</span>);
	<span class="hljs-keyword">try</span> {	
	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unexpected error"</span>);<font></font>
<font></font>
	<span class="hljs-keyword">return</span> response.json();<font></font>
	} <span class="hljs-keyword">catch</span>(error) {
		<span class="hljs-built_in">console</span>.log(error); <span class="hljs-comment">// Error: Unexpected error at sendRequest</span><font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に ...</font></font><br>
<br>
<pre><code class="javascript hljs"> <span class="hljs-comment">//   </span>
<span class="hljs-keyword">async</span>; <span class="hljs-keyword">await</span>;
<span class="hljs-keyword">async</span>; <span class="hljs-keyword">await</span>;
<span class="hljs-keyword">async</span>; <span class="hljs-keyword">await</span>;
<span class="hljs-keyword">async</span>; <span class="hljs-keyword">await</span>;<font></font>
In the System();<font></font>
The <span class="hljs-keyword">function</span>.sleep()s tonight~</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
公式</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期関数定義</font><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN Webドキュメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も</font><font style="vertical-align: inherit;">参照してください</font><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja475060/index.html">簡単な通話追跡サービスの作成、パート2</a></li>
<li><a href="../ja475062/index.html">Appleでのサインインの紹介-Apple Authorization System</a></li>
<li><a href="../ja475066/index.html">ブック・ハンガーのクロニクル</a></li>
<li><a href="../ja475068/index.html">すべてのLANトラフィックを速度制限なしでVPNにラップします</a></li>
<li><a href="../ja475072/index.html">会社の目を通してインターン</a></li>
<li><a href="../ja475076/index.html">ソビエトのスーパーヒーロー、チェコのブーガー、オーストラリアのクローン</a></li>
<li><a href="../ja475078/index.html">SwiftUIのプロパティラッパーについて</a></li>
<li><a href="../ja475082/index.html">Habr Weekly＃26/4日間の稼働週、GitLabが政治に参加、Yandexがローバー配信ロボットをテスト中</a></li>
<li><a href="../ja475086/index.html">フロントエンド開発者向けのREST APIタイピング</a></li>
<li><a href="../ja475092/index.html">「後で読む」：Webページのオフラインコレクションの困難な運命</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>