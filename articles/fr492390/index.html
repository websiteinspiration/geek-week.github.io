<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔗 👤 🚷 Guerre aux freins. Optimisation du nombre de rendus de composants dans React Native 👇🏼 🥃 🕴🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je m'appelle Kamo Spertsyan, je suis engagé dans le développement React Native chez Profi.ru. Si vous décidez d' utiliser la technologi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Guerre aux freins. Optimisation du nombre de rendus de composants dans React Native</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492390/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, Habr! Je m'appelle Kamo Spertsyan, je suis engagé dans le développement React Native chez Profi.ru. Si vous décidez d' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliser la technologie React Native</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour fournir rapidement les fonctionnalités du produit et vous concentrer sur la vitesse de développement, vous risquez de rencontrer des problèmes de performances. C'est du moins ce qui nous est arrivé. Après six mois de développement actif, les performances de notre application sont tombées en dessous d'un niveau critique - tout était extrêmement lent. Par conséquent, nous avons repris l'optimisation - supprimé tous les «freins» lors du démarrage, les transitions entre les écrans, le rendu des écrans, les réactions aux actions de l'utilisateur. En conséquence, en trois mois, ils ont amené l'expérience utilisateur au niveau natif. Dans cet article, je veux parler de la façon dont nous avons optimisé l'application sur React Native et résolu le problème des rendus de plusieurs composants.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tv/qy/9b/tvqy9bo_jyqc4cz044_gneepvmw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai rassemblé des recommandations qui aideront à minimiser le nombre de redessins inutiles de composants. </font><font style="vertical-align: inherit;">Pour plus de clarté, dans les exemples, je compare les implémentations «mauvaises» et «bonnes». </font><font style="vertical-align: inherit;">L'article sera utile à ceux qui sont déjà confrontés à de mauvaises performances des applications et à ceux qui ne veulent pas autoriser cela à l'avenir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous utilisons React Native associé à Redux. </font><font style="vertical-align: inherit;">Certains conseils sont liés à cette bibliothèque. </font><font style="vertical-align: inherit;">Toujours dans l'exemple, j'utilise la bibliothèque Redux-thunk - pour simuler le travail avec le réseau.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quand penser à la performance?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, il convient de se rappeler dès le début des travaux sur l'application. Mais si votre application ralentit déjà - ne désespérez pas, tout peut être corrigé. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout le monde le sait, mais juste au cas où, je mentionnerai: il vaut mieux vérifier les performances sur les appareils faibles. Si vous développez sur des appareils puissants, vous ne connaissez peut-être pas les «freins» des utilisateurs finaux. Décidez par vous-même des appareils qui vous guideront. Mesurer le temps ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans les parcelles de contrôle pour comparer avec les résultats après optimisation.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
React Native prêt à l'emploi offre la possibilité de mesurer les applications FPS via Developer Tools → Show perf monitor. </font><font style="vertical-align: inherit;">La valeur de référence est de 60 images par seconde. </font><font style="vertical-align: inherit;">Plus cet indicateur est bas, plus l'application "ralentit" - ne répond pas ou réagit avec retard aux actions de l'utilisateur. </font><font style="vertical-align: inherit;">L'un des principaux effets sur le FPS est le nombre de rendus, dont la «sévérité» dépend de la complexité des composants.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple de description</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je montre toutes les recommandations sur l'exemple d'une application simple avec une liste de nouveautés. </font><font style="vertical-align: inherit;">L'application dispose d'un écran, qui est situé </font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec les nouvelles. </font><font style="vertical-align: inherit;">Une news est un composant </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui se compose de deux composants plus petits - le titre ( </font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) et le corps ( </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">L'exemple complet peut être vu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Plus loin dans le texte se trouvent des liens vers diverses branches du référentiel pour des exemples spécifiques. </font><font style="vertical-align: inherit;">Le référentiel est utilisé pour la commodité des lecteurs qui souhaitent explorer des exemples plus en profondeur. </font><font style="vertical-align: inherit;">Le code dans le référentiel et les exemples ci-dessous ne prétendent pas être parfaits - il est uniquement nécessaire à des fins de démonstration. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ci-dessous, tous les composants sont schématisés avec des liens et des accessoires.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d9/ng/z6/d9ngz6hldmphbkjky1a-7-38nlq.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la méthode de rendu de chaque composant, j'ai ajouté à la console des informations uniques à ce sujet: </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_{no}<font></font>
ITEM_TITLE_{no}<font></font>
ITEM_BODY_{no}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
où </font></font><code>{no}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est le numéro de série des nouvelles afin de faire la distinction entre différents rendus de nouvelles de plusieurs rendus du même. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour tester sur chaque </font></font><code>refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liste de nouvelles, des nouvelles supplémentaires sont ajoutées à son début. </font><font style="vertical-align: inherit;">Dans le même temps, le message suivant s'affiche dans la console:</font></font><br>
<br>
<pre><code class="plaintext hljs">--------------[ REFRESHING ]--------------</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces enregistrements aideront à comprendre s'il y a un problème dans un composant particulier et à déterminer ultérieurement s'il était possible de l'optimiser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S'il est correctement implémenté, notre journal après le lancement et plusieurs mises à jour devraient ressembler à ceci:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_4<font></font>
ITEM_TITLE_4<font></font>
ITEM_BODY_4</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au premier démarrage, l'écran lui-même et deux premières informations sont dessinés. </font><font style="vertical-align: inherit;">Lors de la mise à jour de la carte, l'écran est à nouveau rendu, car ses données ont vraiment changé. </font><font style="vertical-align: inherit;">Plus de nouvelles arrivent. </font><font style="vertical-align: inherit;">Toutes les nouvelles précédentes ne sont pas redessinées, car leurs données n'ont pas changé.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quand un composant est-il rendu?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans React et React Native, il existe deux conditions pour rendre un composant:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changer ses accessoires / état,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rendu du composant parent.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fonction peut être redéfinie dans un composant </font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- elle reçoit de nouveaux accessoires et états en entrée et indique si le composant doit être rendu. Souvent, pour éviter des rendus inutiles, une </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comparaison superficielle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des accessoires et des objets d'état suffit. Par exemple, cela élimine les rendus inutiles lorsque le composant parent change, s'ils n'affectent pas le composant enfant. Afin de ne pas écrire une comparaison de surface manuellement à chaque fois, vous pouvez hériter d'un composant </font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui encapsule cette vérification. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque nous utilisons la fonction de lien de connexion, la bibliothèque Redux crée un nouveau composant qui est «connecté» à l'état global. Les modifications de cet état déclenchent une méthode</font></font><code>mapStateToProps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui renvoie de nouveaux accessoires. </font><font style="vertical-align: inherit;">Ensuite, une comparaison des anciens et des nouveaux accessoires commence, que le composant ait été déclaré </font></font><code>PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou non. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérez ces nuances dans notre exemple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">laisser passer le </font><font style="vertical-align: inherit;">composant </font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hériter de </font></font><code>React.Component</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- de </font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple de code complet</font></font></a><br>
<br>
<pre><code class="plaintext hljs">export class NewsItemTitle extends React.Component<font></font>
export class NewsItemBody extends React.PureComponent</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici à quoi ressemblera le journal après une mise à jour d'une carte:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez voir que les composants d'actualités et de titres sont redessinés. </font><font style="vertical-align: inherit;">Nous les examinerons tour à tour. </font></font><br>
<br>
<code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">déclaré en utilisant </font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En tant qu'accessoire, ce composant reçoit un identifiant, par lequel il reçoit ensuite des nouvelles dans </font></font><code>mapStateToProps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">const mapStateToProps = (state, ownProps) =&gt; ({<font></font>
  item: state.newsMap[ownProps.itemKey],<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que lors de la mise à jour de la carte, toutes les nouvelles sont téléchargées à nouveau, l'objet sera mis à </font></font><code>item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jour et se référera ensuite à diverses cellules de mémoire. En d'autres termes, ce seront des objets différents, même si tous les champs contenus sont les mêmes. Par conséquent, une comparaison entre la composante précédente et la nouvelle composante State'ov renvoie </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Le composant sera restitué, malgré le fait que les données n'ont pas changé. </font></font><br>
<br>
<code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est hérité de </font></font><code>React.Component</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il est donc rendu à chaque fois que le composant parent est rendu. Cela se produit indépendamment des valeurs des anciens et des nouveaux accessoires. </font></font><br>
<br>
<code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hérité de </font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il compare donc les anciens et les nouveaux accessoires. Dans les news 1 et 2, leurs valeurs sont équivalentes, donc le composant est rendu uniquement pour les news 3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour optimiser les rendus</font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">déclarez-le simplement comme </font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans le cas de, vous devez </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">redéfinir la fonction </font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">shouldComponentUpdate(nextProps) {<font></font>
  return !shallowEqual(this.props.item, nextProps.item);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple de code complet</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Voici </font></font><code>shallowEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une fonctionnalité de comparaison de surface d'objets fournie par Redux. </font><font style="vertical-align: inherit;">Vous pouvez écrire comme ceci:</font></font><br>
<br>
<pre><code class="plaintext hljs">shouldComponentUpdate(nextProps) {<font></font>
  return (<font></font>
    this.props.item.title !== nextProps.item.title ||<font></font>
    this.props.item.body !== nextProps.item.body<font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici à quoi ressemblera notre journal après ceci: </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque</font></font></b><div class="spoiler_text"> <code>shouldComponentUpdate</code>  <code>NewsItem</code> ,  <code>NewsItemTitle</code>   .        . <code>NewsItemTitle</code>    -         <code>NewsItem</code>,     .<br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React.memo et composants fonctionnels</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'est </font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas possible de </font><font style="vertical-align: inherit;">remplacer </font><font style="vertical-align: inherit;">un composant fonctionnel. </font><font style="vertical-align: inherit;">Mais cela ne signifie pas que pour optimiser un composant fonctionnel, vous devez le réécrire dans un composant de classe. </font><font style="vertical-align: inherit;">Dans de tels cas, la fonction de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mémorisation React.memo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">fournie</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il accepte une entrée de composant et une fonction de comparaison facultative </font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lorsqu'il est appelé, il </font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obtient des accessoires anciens et nouveaux et devrait renvoyer le résultat de la comparaison. </font><font style="vertical-align: inherit;">La différence avec </font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce qui </font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devrait revenir </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si les accessoires sont égaux, et non l'inverse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, la </font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mémorisation peut ressembler à ceci:</font></font><br>
<br>
<pre><code class="plaintext hljs">areEqual(prevProps, nextProps) {<font></font>
  return shallowEqual(prevProps, nextProps);<font></font>
}<font></font>
export OptimizedNewsItemTitle = React.memo(NewsItemTitle, areEqual)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous ne réussissez pas </font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à </font></font><code>React.memo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis une comparaison superficielle des accessoires sera faite, de </font><font style="vertical-align: inherit;">sorte que </font><font style="vertical-align: inherit;">notre exemple peut être simplifiée:</font></font><br>
<br>
<pre><code class="plaintext hljs">export OptimizedNewsItemTitle = React.memo(NewsItemTitle)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonctions lambda dans les accessoires</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour traiter les événements des composants, les fonctions peuvent être passées à ses accessoires. </font><font style="vertical-align: inherit;">L'exemple le plus frappant est la mise en œuvre </font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Souvent, des fonctions lambda anonymes sont utilisées pour cela. </font><font style="vertical-align: inherit;">Disons que </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous voulons afficher uniquement l'aperçu, et si vous cliquez dessus - tout le texte. </font><font style="vertical-align: inherit;">Pour ce faire, lors du rendu </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous passerons l'hélice suivante:</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;NewsItemBody<font></font>
  ...<font></font>
  onPress={() =&gt; this.props.expandBody()}<font></font>
  ...<font></font>
/&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici à quoi ressemble le journal avec cette implémentation lorsque la méthode </font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">supprimée:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les organes de presse 1 et 2 sont rendus, bien que leurs données n'aient pas changé, mais le </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont </font></font><code>PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cela est dû au fait que pour chaque rendu, la </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur des accessoires </font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est recréée. </font><font style="vertical-align: inherit;">Techniquement, </font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à chaque rendu, il pointe vers une nouvelle zone en mémoire, donc une comparaison superficielle des accessoires en </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retourne faux. </font><font style="vertical-align: inherit;">Le problème est résolu par l'entrée suivante:</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;NewsItemBody<font></font>
  ...<font></font>
  onPress={this.props.expandBody}<font></font>
  ...<font></font>
/&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Journal: </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple de code complet</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Malheureusement, une fonction anonyme ne peut en aucun cas toujours être réécrite en tant que méthode ou champ de classe pour un tel enregistrement. Le cas le plus courant est lorsque, à l'intérieur de la fonction lambda, les variables de portée de la fonction dans laquelle elle est déclarée sont utilisées. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérez ce cas dans notre exemple. Pour passer de la liste générale à l'écran d'une actualité, nous ajoutons le traitement du clic sur le corps de l'actualité. La méthode des </font></font><code>renderItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">composants </font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ressemblera à ceci:</font></font><br>
<br>
<pre><code class="plaintext hljs">const renderItem = ({item}) =&gt; (<font></font>
  &lt;NewsItem<font></font>
    itemKey={item}<font></font>
    onBodyPress={() =&gt; this.onItemBodyPress(item)}<font></font>
  /&gt;<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fonction anonyme ne </font></font><code>onBodyPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut pas être déclarée dans une classe, car alors la variable </font></font><code>item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nécessaire pour accéder à une actualité spécifique </font><font style="vertical-align: inherit;">disparaîtra de la portée </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La solution la plus simple au problème consiste à modifier la signature des accessoires du </font></font><code>onBodyPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">composant </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin que le paramètre requis soit transmis à la fonction lors de son appel. </font><font style="vertical-align: inherit;">Dans ce cas, il s'agit de l'identifiant de news.</font></font><br>
<br>
<pre><code class="plaintext hljs">const renderItem = ({item}) =&gt; (<font></font>
  &lt;NewsItem<font></font>
    itemKey={item}<font></font>
    onBodyPress={item =&gt; this.onItemBodyPress(item)}<font></font>
  /&gt;<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, nous pouvons déjà supprimer la fonction anonyme dans la méthode de classe de composant.</font></font><br>
<br>
<pre><code class="plaintext hljs">const renderItem = ({item}) =&gt; (<font></font>
  &lt;NewsItem<font></font>
    itemKey={item}<font></font>
    onBodyPress={this.onItemBodyPress}<font></font>
  /&gt;<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, une telle solution nous obligera à changer le composant </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="plaintext hljs">class NewsItemComponent extends React.Component {<font></font>
render() {<font></font>
  ...<font></font>
  return (<font></font>
      ...<font></font>
      &lt;NewsItemBody<font></font>
        ...<font></font>
        onPress={() =&gt; this.props.onBodyPress(this.props.item)}<font></font>
        ...<font></font>
      /&gt;<font></font>
      ...<font></font>
  );<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et encore une fois, nous revenons au problème indiqué - nous passons une nouvelle fonction lambda au composant enfant pour chaque rendu du parent. </font><font style="vertical-align: inherit;">Ce n'est que maintenant que nous avons baissé d'un niveau. </font><font style="vertical-align: inherit;">Journal:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour vous débarrasser de ce problème à la racine, vous pouvez utiliser le hook </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">useCallback</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il permet de mémoriser un appel de fonction en passant un argument. </font><font style="vertical-align: inherit;">Si l'argument de la fonction ne change pas, le résultat de l'appel </font></font><code>useCallback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pointera vers la même zone de mémoire. </font><font style="vertical-align: inherit;">Dans notre exemple, cela signifie que lorsque vous redessinez les mêmes nouvelles, le </font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">composant </font><font style="vertical-align: inherit;">prop </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne change pas. </font><font style="vertical-align: inherit;">Les crochets ne peuvent être utilisés que dans les composants fonctionnels, donc l'aspect final du composant </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sera le suivant:</font></font><br>
<br>
<pre><code class="plaintext hljs">function NewsItemComponent(props) {<font></font>
  ...<font></font>
  const {itemKey, onBodyPress} = props.item;<font></font>
  const onPressBody = useCallback(() =&gt; onBodyPress(itemKey), [itemKey, onBodyPress]);<font></font>
  return (<font></font>
    &lt;View&gt;<font></font>
      ...<font></font>
      &lt;NewsItemBody<font></font>
        ...<font></font>
        onPress={onPressBody}<font></font>
        ...<font></font>
      /&gt;<font></font>
    &lt;/View&gt;<font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et le journal: </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple de code complet</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tableaux et objets</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En JavaScript, les fonctions sont représentées comme des objets, avec des tableaux. </font><font style="vertical-align: inherit;">Par conséquent, l'exemple du bloc précédent est un cas particulier de création d'un nouvel objet dans les accessoires. </font><font style="vertical-align: inherit;">C'est assez courant, alors je l'ai mis dans un paragraphe séparé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toute création de nouvelles fonctions, tableaux ou objets dans les accessoires conduit à un nouveau rendu des composants. </font><font style="vertical-align: inherit;">Considérez cette règle dans l'exemple suivant. </font><font style="vertical-align: inherit;">Passons dans un </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">style combiné de deux valeurs:</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;NewsItemBody<font></font>
  ...<font></font>
  style={[styles.body, styles.item]}<font></font>
  ...<font></font>
/&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et encore une fois, le journal montre les rendus de composants supplémentaires:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour résoudre ce problème, vous pouvez sélectionner un style distinct qui se combinera </font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ou, par exemple, déplacera la déclaration du tableau </font></font><code>[styles.body, styles.item]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans une variable globale. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple de code complet</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Réducteurs de réseau</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenons une autre source populaire de «freins» associée à l'utilisation </font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Une application classique qui contient une longue liste d'éléments du serveur implémente la pagination. </font><font style="vertical-align: inherit;">Autrement dit, il charge un ensemble limité d'éléments sous la forme de la première page, lorsque la liste des éléments actuels se termine, il charge la page suivante, etc. </font><font style="vertical-align: inherit;">Un réducteur de liste d'articles pourrait ressembler à ceci:</font></font><br>
<br>
<pre><code class="plaintext hljs">const newsIdList = (state = [], action) =&gt; {<font></font>
  if (action.type === 'GOT_NEWS') {<font></font>
    return action.news.map(item =&gt; item.key);<font></font>
  } else if (action.type === 'GOT_OLDER_NEWS') {<font></font>
    return [...state, ...action.news.map(item =&gt; item.key)];<font></font>
  }<font></font>
  return state;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque chaque page suivante se charge dans le style de l'application, un nouveau tableau d'identificateurs est créé. </font><font style="vertical-align: inherit;">Si nous transmettons ce tableau aux accessoires plus tard </font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, voici à quoi ressembleront les journaux de rendu des composants:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
ITEM_&lt;1..20&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..20&gt;<font></font>
ITEM_&lt;1..30&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour cet exemple, j'ai apporté quelques modifications dans l'application de test.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Définissez la taille de la page sur 10 actualités.</font></font></li>
<li>   <code>item</code>   <code>NewsItem</code>  <code>FlatList</code>-,        connect. <code>NewsItem</code>    <code>React.Component</code>    .</li>
<li>     .</li>
<li>       .       №1     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'exemple montre que lors du chargement de chaque page suivante, tous les anciens éléments sont à nouveau rendus, puis les anciens éléments et les éléments de la nouvelle page sont à nouveau rendus. Pour les amateurs de mathématiques: si la taille de la page est égale </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, alors lorsque la </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ième page est </font><font style="vertical-align: inherit;">chargée, </font><font style="vertical-align: inherit;">au lieu de ne rendre que les </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nouveaux éléments, les éléments sont rendus </font></font><code>(i - 1) * X + i * X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
«D'accord», dites-vous, «je comprends pourquoi tous les éléments sont dessinés après avoir ajouté une nouvelle page: le réducteur a renvoyé un nouveau tableau, une nouvelle zone de mémoire, tout ça. Mais pourquoi devons-nous rendre l'ancienne liste avant d'ajouter de nouveaux éléments? » «Bonne question», je vais vous répondre. Ceci est une conséquence du travail avec l'état du composant </font></font><code>VirtualizedList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur la base duquel</font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Je n'entrerai pas dans les détails, car ils tirent sur un article séparé. </font><font style="vertical-align: inherit;">Peu importe, je vous conseille de vous plonger dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et la source. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment se débarrasser d'une telle non-optimalité? </font><font style="vertical-align: inherit;">Nous réécrivons le réducteur pour qu'il ne retourne pas un nouveau tableau pour chaque page, mais ajoute des éléments à celui existant:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attention! </font><font style="vertical-align: inherit;">Antipattern!</font></font></b><div class="spoiler_text">          .     ,    , ,  <code>PureComponent</code>,          .      ,             .      .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"> Redux</a>.<br>
</div></div><br>
<pre><code class="plaintext hljs">const newsIdList = (state = [], action) =&gt; {<font></font>
  if (action.type === 'GOT_NEWS') {<font></font>
    return action.news.map(item =&gt; item.key);<font></font>
  } else if (action.type === 'GOT_OLDER_NEWS') {<font></font>
    action.news.forEach(item =&gt; state.push(item.key));<font></font>
    return state;<font></font>
    // return [...state, ...action.news.map(item =&gt; item.key)];<font></font>
  }<font></font>
  return state;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après cela, notre journal ressemblera à ceci:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..20&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..30&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous nous sommes débarrassés du rendu des anciens éléments </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avant d'</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ajouter des éléments à une nouvelle page, mais les anciens éléments sont toujours dessinés </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">après la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mise </font><b><font style="vertical-align: inherit;">à</font></b><font style="vertical-align: inherit;"> jour de la liste. Le nombre de rendus pour la page suivante est désormais égal </font></font><code>i * X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La formule est devenue plus simple, mais nous ne nous arrêterons pas là. Nous n'avons que de </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nouveaux éléments et nous voulons seulement de </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nouveaux rendus. Nous utiliserons les astuces déjà connues pour supprimer les rendus d'actualités qui n'ont pas changé d'accessoires. Connectez-vous à </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;11..20&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;21..30&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien! Maintenant, nous pouvons être satisfaits de nous-mêmes. Il n'y a nulle part où optimiser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple de code complet</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Un lecteur attentif indiquera qu'après avoir appliqué la connexion au </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">journal, il ressemblera au dernier exemple, quelle que soit la manière dont vous implémentez le réducteur. Et il aura raison - si le composant news vérifie ses accessoires avant le rendu, peu importe si l'ancien tableau est utilisé par le réducteur ou s'il en crée un nouveau. Seuls de nouveaux éléments sont dessinés et une seule fois. Cependant, changer l'ancien tableau au lieu d'en créer un nouveau nous évite des rendus inutiles du composant </font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisé </font></font><code>VirtualizedList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et des itérations inutiles des vérifications d'équivalence des accessoires </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Avec un grand nombre d'éléments, cela donne également une augmentation des performances.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utiliser des tableaux mutables et des objets dans les réducteurs doit être extrêmement prudent. </font><font style="vertical-align: inherit;">Dans cet exemple, cela est justifié, mais si vous avez, disons, normal </font></font><code>PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, alors lorsque vous ajoutez des éléments au tableau mutable, les composants ne seront pas rendus. </font><font style="vertical-align: inherit;">Ses accessoires restent en fait inchangés, car avant et après la mise à jour du tableau pointe vers la même zone mémoire. </font><font style="vertical-align: inherit;">Cela peut entraîner des conséquences inattendues. </font><font style="vertical-align: inherit;">Pas étonnant que l'exemple décrit viole les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">principes de Redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et quelque chose d'autre...</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous utilisez des bibliothèques de niveau présentation, je vous conseille de vous assurer de bien comprendre comment elles sont implémentées. </font><font style="vertical-align: inherit;">Dans notre application, nous utilisons un composant </font></font><code>Swipeable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de la bibliothèque </font></font><code>react-native-gesture-handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il vous permet d'implémenter un bloc d'actions supplémentaires lors du glissement d'une carte de la liste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En code, cela ressemble à ceci:</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;Swipeable<font></font>
  ...<font></font>
  renderRightActions={this.renderRightActions}<font></font>
  ...<font></font>
&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Méthode </font></font><code>renderRightActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>renderLeftActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retourne le composant qui s'affiche après le balayage. Nous avons déterminé et modifié la hauteur du panneau lors du changement de composants afin de l'adapter au contenu nécessaire. Il s'agit d'un processus gourmand en ressources, mais s'il se produit pendant l'animation de balayage, l'utilisateur ne voit aucune interférence.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/wz/n1/vg/wzn1vghiy6-wjclqcy8itdy1fns.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le problème est que le composant </font></font><code>Swipeable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appelle la méthode </font></font><code>renderRightActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au moment du rendu du composant principal. Tous les calculs et même le rendu de la barre d'action, qui n'est pas visible avant le balayage, se produisent à l'avance. Ainsi, toutes ces actions sont effectuées pour toutes les cartes de la liste en même temps. Cela a provoqué des «freins» importants lors du défilement de la planche. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le problème a été résolu de la manière suivante. Si le panneau d'actions est dessiné avec le composant principal, et non à la suite du balayage, la méthode </font></font><code>renderRightActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoie un vide de la </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">taille du composant principal. Sinon, nous dessinons le panel d'actions supplémentaires comme précédemment.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je donne cet exemple parce que les bibliothèques de support ne fonctionnent pas toujours comme prévu. </font><font style="vertical-align: inherit;">Et s'il s'agit de bibliothèques au niveau de la présentation, il est préférable de s'assurer qu'elles ne gaspillent pas de ressources inutiles.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">résultats</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir éliminé les problèmes décrits dans l'article, nous avons considérablement accéléré l'application sur React Native. </font><font style="vertical-align: inherit;">Il est maintenant difficile de le distinguer en termes de performances d'un modèle similaire, implémenté nativement. </font><font style="vertical-align: inherit;">Les rendus excessifs ont ralenti à la fois le chargement des écrans individuels et la réaction aux actions des utilisateurs. </font><font style="vertical-align: inherit;">Surtout, il était visible sur les listes, où des dizaines de composants sont dessinés à la fois. </font><font style="vertical-align: inherit;">Nous n'avons pas tout optimisé, mais les écrans principaux de l'application ne ralentissent plus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les principaux points de l'article sont brièvement énumérés ci-dessous.</font></font><br>
<br>
<ol>
<li> React Native      :  Props/State-     .</li>
<li>,   <code>React.PureComponent</code>,     ,       .</li>
<li>    ,    <code>shouldComponentUpdate</code>      <code>React.Memo</code>   .</li>
<li>-        .      ,         (shallow compare).               ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La prise en charge des bibliothèques de niveau présentation peut entraîner un gaspillage inattendu de ressources. </font><font style="vertical-align: inherit;">Il convient d'être prudent dans leur application.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout. </font><font style="vertical-align: inherit;">J'espère que vous trouverez ces informations utiles. </font><font style="vertical-align: inherit;">Je serai heureux de toute rétroaction!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sources utiles</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comprendre le rendu dans React + Redux</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparaison d'objets en JavaScript</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Amélioration des performances des composants fonctionnels React à l'aide de React.memo ()</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment Discord atteint les performances iOS natives avec React Native</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr492374/index.html">Expérience: Redux du monde OOP</a></li>
<li><a href="../fr492376/index.html">Comment faire comprendre votre article ou votre documentation rapidement et avec précision</a></li>
<li><a href="../fr492378/index.html">Reactjs, Material-UI avec JSS. Petit guide</a></li>
<li><a href="../fr492384/index.html">Hack The Box - Postman Procédure pas à pas Redis et WebMin</a></li>
<li><a href="../fr492386/index.html">Comment le secteur informatique aide le monde à jeter moins de nourriture</a></li>
<li><a href="../fr492398/index.html">Nous configurons nos appareils pour le travail à distance, le podcasting, la vidéo et le streaming</a></li>
<li><a href="../fr492404/index.html">Flutter + arduino nano 33 BLE sense = capteur BLE très simple</a></li>
<li><a href="../fr492406/index.html">Podcasts pour le geek: quelques programmes éprouvés sur la gestion de projet, l'analyse technologique et le GTD</a></li>
<li><a href="../fr492408/index.html">La fréquentation des ordinateurs de bureau Yandex a diminué: ce qui s'est passé en 2019 et comment cela affectera en 2020</a></li>
<li><a href="../fr492410/index.html">C ++ est plus rapide et plus sûr que Rust, Yandex a pris des mesures</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>