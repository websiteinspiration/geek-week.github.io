<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀 🙆🏽 😭 ゲームシーンの3Dモデルの最適化 😭 ✍🏼 🕺🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事では、クラスノダールスタジオプラリウムからの、Unityでの3Dモデルの操作のさまざまな側面に関する一連の出版物を完成させます。前の記事：「ユニティでのメッシュでの作業の機能」、「ユニティ：メッシュの手続き編集」、「Unityと落とし穴に3Dモデルのインポート」、「テクスチャスキャンの画素イ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ゲームシーンの3Dモデルの最適化</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/484792/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事では、クラスノダールスタジオプラリウムからの、Unityでの3Dモデルの操作のさまざまな側面に関する一連の出版物を完成させます。前の記事：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ユニティでのメッシュでの作業の機能」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ユニティ：メッシュの手続き編集」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「Unityと落とし穴に3Dモデルのインポート」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「テクスチャスキャンの画素インデント」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほぼ2年前に</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">記事</font></a><font style="vertical-align: inherit;">を書きまし</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そこで彼らは、カメラの角度と対応するオブジェクトの回転に制限があるシーンで3Dジオメトリを最適化するオプションについて話しました。</font><font style="vertical-align: inherit;">それ以来、それほど多くは流れていませんが、ソリューションを改善し、さまざまなアプローチを検討し、他のアプローチをスパイする機会は、開発者の心に残りません。</font><font style="vertical-align: inherit;">この記事では、ポリゴンのペイントに基づくアルゴリズムの改良バージョンについて説明するとともに、この作業の一部を3Dパッケージに転送しようとすることについて話します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jl/v-/pz/jlv-pzi5qagnnmqhgkqaddzo1uo.jpeg"><a name="habracut"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーンの切り抜き</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の記事では、このアルゴリズムの基本原理をすでに検討しました。すべてのエフェクトと透明オブジェクトを消し、未処理のポリゴンを1つの色でペイントし、処理済みのポリゴンを別の色でペイントし、レンダリングして結果を抽出します。古いバージョンでは、すべて黒く冗長になるようにペイントされ、1つの三角形だけが赤でマークされていました。</font><font style="vertical-align: inherit;">その記事へ</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のコメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、読者の1人が、ポリゴンのセットと一意の数値のセットの間に1対1の対応を確立することによってアルゴリズムを最適化する可能性を指摘しました。次に、同じ方法で複数の三角形を処理することができます。このオプションを検討してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、前回と同様に、いくつかの事前トレーニングは、ステージ上のすべての口笛オブジェクトと、ターゲットモデルの可視性に影響を及ぼさないことが保証されているオブジェクトを無効にすることに関連していると考えられます。カメラビューはほぼ独立して処理され、可視ポリゴンの共通のインデックスバッファーによってのみ接続されます。また、幾何学前処理は、ポリゴンが回転している間に、各角度に対して行われる背面側でカメラになっていること（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">裏面</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）これは、アルゴリズムの特定の段階で、元のメッシュよりも非常に多くの頂点を持つ一時メッシュが作成されるためです。この数はしきい値の65,535を簡単に超える可能性があり、計算で追加のジェスチャーが必要になり、パフォーマンスが低下します。いずれの場合も、これらのポリゴンは削除されます。これは、それらの色がフレームに該当しないためです。ただし、各三角形は3つの不要な頂点を生成する可能性があるため、事前に不要なポリゴンを削除すると、アルゴリズムのメインステージが容易になり、メモリコストが削減されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジオメトリがメッシュで表現されている3Dモデルがあるとします。特定のポリゴンを一意の色でペイントするには、すべての頂点をこの色でペイントする必要があります。一般的なケースでは、1つの頂点が異なるポリゴンに属している可能性があるため、問題を正面から解決することはできません。頂点をどのように色付けしても、レンダリング時に、ビデオカードの側面にある補間アルゴリズムに従って、その色が頂点を所有するすべての三角形を越えます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ay/td/qo/aytdqo0ah1fzsl7pcasymag9rf8.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共通の頂点を持つポリゴンを表示するときの色補間の例</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、オブジェクトのトポロジーとジオメトリを維持しながら、メッシュを個別の独立したポリゴンに分割する必要があります。</font><font style="vertical-align: inherit;">Dictum factum。</font><font style="vertical-align: inherit;">三角形と頂点の配列を、三角形ごとに3つの一意の頂点が作成されるように変換します。その位置は、元のメッシュの対応する頂点によって決定されます。</font><font style="vertical-align: inherit;">一般的なケースでは、そのようなメッシュは、元のメッシュと比較して非常に多くの頂点を持つことに注意してください。</font><font style="vertical-align: inherit;">また、この数が65 535を超える場合は、メッシュを作成するときに、適切なインデックス形式を指定する必要があります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元のメッシュを、各ポリゴンに固有の頂点を持つメッシュに変換します</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Mesh <span class="hljs-title">GetNotSmoothMesh</span>(<span class="hljs-params">Mesh origin</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> oVertices = origin.vertices;
            <span class="hljs-keyword">var</span> oTriangles = origin.triangles;<font></font>
<font></font>
            <span class="hljs-keyword">var</span> vertices = <span class="hljs-keyword">new</span> Vector3[oTriangles.Length];
            <span class="hljs-keyword">var</span> triangles = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[oTriangles.Length];<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; triangles.Length; i++)<font></font>
            {<font></font>
                vertices[i] = oVertices[oTriangles[i]];<font></font>
                triangles[i] = i;<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Mesh()<font></font>
            {<font></font>
    indexFormat = vertices.Length &gt; <span class="hljs-number">65535</span> ? IndexFormat.UInt32 : IndexFormat.UInt16,<font></font>
                vertices = vertices,<font></font>
                triangles = triangles<font></font>
            };<font></font>
        }</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、このメッシュのポリゴンを指定して、レンダリング操作後に画面に表示されたものを判別できるようにする必要があります。</font><font style="vertical-align: inherit;">すでに述べたように、ポリゴンに一意の色を生成し、3つの頂点をそれぞれ対応する色でペイントします。</font><font style="vertical-align: inherit;">結果は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイトカラーメッシュ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれる新しいメッシュ</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jl/l0/co/jll0coliukddunmhl5kizfzwpzq.jpeg"><br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイト色のメッシュ</font></font></b></i><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各頂点が1つのポリゴンのみに属するメッシュのカラーリング</font></font></b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ColorizePolygons</span>(<span class="hljs-params">Mesh mesh</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> pColors = ColorsOfPolygons(mesh);
            <span class="hljs-keyword">var</span> colors = <span class="hljs-keyword">new</span> Color[mesh.vertexCount];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; colors.Length; i++)<font></font>
            {<font></font>
                colors[i] = pColors[i / <span class="hljs-number">3</span>];<font></font>
            }<font></font>
            mesh.colors = colors;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Color[] <span class="hljs-title">GetColorsOfPolygons</span>(<span class="hljs-params">Mesh mesh</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> colors = <span class="hljs-keyword">new</span> Color[mesh.triangles.Length / <span class="hljs-number">3</span>];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; colors.Length; i++)<font></font>
            {<font></font>
                <span class="hljs-keyword">var</span> color = Int2Color(i);<span class="hljs-comment">//         ,     Color2Int</span>
               <span class="hljs-comment">//      ,       int     Color32</span><font></font>
                colors[i] = color;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> colors;<font></font>
        }</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
着色を覚えておいてください。</font><font style="vertical-align: inherit;">レンダリングの時間です。</font><font style="vertical-align: inherit;">すべてのカメラアングルで3Dレンダリングを実行し、それぞれを処理するときに、フレームで色が検出された一意のポリゴンインデックスのバッファーを補充します。</font><font style="vertical-align: inherit;">カメラの計算時には、隣接するピクセルの補間による新しい色の出現を避けるために、アンチエイリアスをオフにする必要があります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title">       </b><div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-comment">// CameraTransform —        </span>
        <span class="hljs-comment">//      SetCameraTransform</span>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashSet&lt;Color&gt; <span class="hljs-title">GetVisibleColors</span>(<span class="hljs-params">Camera camera, CameraTransform[] cameraTransforms</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">var</span> renderTexture = <span class="hljs-keyword">new</span> RenderTexture(<span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, <span class="hljs-number">24</span>);<span class="hljs-comment">//for example</span>
            <span class="hljs-keyword">var</span> rtRect = <span class="hljs-keyword">new</span> Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, renderTexture.width, renderTexture.height);
            <span class="hljs-keyword">var</span> frame = <span class="hljs-keyword">new</span> Texture2D(renderTexture.width, renderTexture.height, TextureFormat.RGB24, <span class="hljs-literal">false</span>);<span class="hljs-comment">//    -  RGB24   ,    RGBA32</span><font></font>
            <font></font>
            <span class="hljs-keyword">var</span> visibleColorsSet = <span class="hljs-keyword">new</span> HashSet&lt;Color&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> cameraTransform <span class="hljs-keyword">in</span> cameraTransforms)<font></font>
            {<font></font>
                SetCameraTransform(camera, cameraTransform);<font></font>
                CreateScreenShot(camera, renderTexture, frame, rtRect);<font></font>
                visibleColorsSet.UnionWith(GetTextureColors(frame));<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> visibleColorsSet;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetCameraTransform</span>(<span class="hljs-params">Camera camera, CameraTransform camTransform</span>)</span><font></font>
        {<font></font>
            camera.transform.position = camTransform.Position;<font></font>
            camera.transform.rotation = camTransform.Rotation;<font></font>
            camera.fieldOfView = camTransform.FieldOfView;<font></font>
            camera.orthographic = camTransform.IsOrthographic;<font></font>
            camera.nearClipPlane = camTransform.NearClippingPlane;<font></font>
            camera.farClipPlane = camTransform.FarClippingPlane;<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashSet&lt;Color&gt; <span class="hljs-title">GetTextureColors</span>(<span class="hljs-params">Texture2D texture</span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HashSet&lt;Color&gt;(texture.GetPixels());<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateScreenShot</span>(<span class="hljs-params">Camera cam, RenderTexture renderTexture, Texture2D screenShot, Rect renderTextureRect</span>)</span><font></font>
        {<font></font>
            cam.targetTexture = renderTexture;<font></font>
            cam.Render();<font></font>
            RenderTexture.active = cam.targetTexture;<font></font>
            <font></font>
            screenShot.ReadPixels(renderTextureRect, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<font></font>
<font></font>
            RenderTexture.active = <span class="hljs-literal">null</span>;<font></font>
            cam.targetTexture = <span class="hljs-literal">null</span>;<font></font>
        }<font></font>
    }</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプリングのために、画面への投影のサイズが特に小さいために、一部の三角形が表示されない場合があること、および何かがそれらに重なったり、間違った側に向けられたりしているためではないことに言及する価値があります。アルゴリズムの保守的なバージョンを実装しました。この場合、</font><font style="vertical-align: inherit;">画面上の三角形</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投影の</font><b><font style="vertical-align: inherit;">AABB</font></b><font style="vertical-align: inherit;">が計算され</font><font style="vertical-align: inherit;">、その辺の少なくとも1つが画像のテクセル辺よりも小さい場合、そのようなポリゴンは可視としてマークされます。このアプローチは、ターゲットデバイスの画面解像度よりも低い解像度でアルゴリズムを実行するときに、アーチファクトから保護します。小さなポリゴンを無視する場合、使用されるレンダーテクスチャの解像度が目的のデバイスの画面の解像度よりも大きい場合、結果も許容されます。</font><b><font style="vertical-align: inherit;">Unityで</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この剪定アルゴリズムを実装しました</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、それを使用して、さまざまな位置でシーンに複数回見られるモデルを持つ静的オブジェクトを最適化します。これは主に風景です：石、木、彫像、花瓶など、よく使われるプレハブを指します。このようなオブジェクトを3Dパッケージで作成する段階の早い段階で最適化したいと思いますが、レベルデザイナが自分のお気に入りの燭台を配置したいのはどの幻想的なポーズなのか誰が知っていますか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなツールを使用して同じタイプのオブジェクトのセットをトリミングすると、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的なバッチ処理</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">に、一般的な</font><b><font style="vertical-align: inherit;">プレハブ</font></b><font style="vertical-align: inherit;">メッシュのデータがビルド段階でこのメッシュを持つアクティブに描画されたオブジェクトがシーンで表される回数だけコピーされるため</font><font style="vertical-align: inherit;">、シーンのサイズが小さくなります</font><font style="vertical-align: inherit;">。また、</font><b><font style="vertical-align: inherit;">ライトマップ</font></b><font style="vertical-align: inherit;">などのテクスチャアトラスのスペースを解放します。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">節約されたスペースを使用して、洗浄後も残ったモデルのパーツの詳細を増やします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3Dクロップ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでも、アーティストが編集者の不要なものをすべて削除して、コンテンツの準備の段階数を減らすことができれば、より良いでしょう。これは、カメラに対して所定の回転が1つだけあるシーンでモデルが使用される場合に正当化されます。以前は、片側で正確にユーザーに渡されるオブジェクトは、プロジェクトに統合する前に手動で単純化されることがよくありました。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unityで</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムを使用してこのような簡略化を実装することは</font><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発</font><font style="vertical-align: inherit;">のパッケージ化が複雑なため、はるかに困難であるため</font><font style="vertical-align: inherit;">、3Dパッケージの段階での自動化により、アーティストの</font><font style="vertical-align: inherit;">作業が</font><font style="vertical-align: inherit;">楽になる場合があること</font><font style="vertical-align: inherit;">に注意してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当社で3Dモデルを操作するためのツールの1つが</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blender</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。私たちはそれに登りました。それは</font><b><font style="vertical-align: inherit;">Blenderの</font></b><font style="vertical-align: inherit;">ようなそのような「大人の」ソフトウェアのようです</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同様の機能が必要です。しかし、彼はすべきではないことがわかりました。私は自分の自転車を見なければなりませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のアイデアは、使い慣れた選択ツールを使用することでした。基本的に、アーティストの手動作業の一部を1つのカメラアングルで繰り返します。表示されているポリゴンを選択し、選択を反転し、削除します。計画は次のとおりです。カメラを移動し、各位置</font><font style="vertical-align: inherit;">でのモデルの</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AABB</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投影を</font><font style="vertical-align: inherit;">決定し</font><font style="vertical-align: inherit;">、次に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AABB</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">対応する領域のポリゴンの選択結果を要求し</font><font style="vertical-align: inherit;">、現在のビューのポリゴンのセットと以前のものとの結合を取得し、最後に選択されていないポリゴンを削除します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、スクリプトの実装中に、タスクの点で重大な欠点が見つかりました。の選択ツール</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブレンダー（四角形選択、円選択）</font></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、画面の単位面積あたりの選択された要素の数が増えると</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">精度</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">失わ</font></a><font style="vertical-align: inherit;">れ（一部の多角形は選択されないまま）、自動化ツールでの使用が不可能になります。興味深い事実：同じ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3ds Maxでは</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この問題は見られません。</font><i><b><font style="vertical-align: inherit;">Blenderの</font></b></i></font><br>
<br>
<img src="https://habrastorage.org/webt/ai/rr/bf/airrbf1enz0jfiucjtrhrbzv8bw.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遠方からの</font></font><b><font style="vertical-align: inherit;"></font></b></i><br>
<br>
<img src="https://habrastorage.org/webt/gt/vy/mh/gtvymh56yk7vp5lrwsvuav4fjqq.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハイライト</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
次の試みを</font><i><font style="vertical-align: inherit;">ハイライトする</font></i><font style="vertical-align: inherit;">ことは、問題を正面から解決することを目的としました：ビューポートの各ピクセルを通してカメラからレイを送信し、どのポリゴンが最初に少なくとも1つのレイと交差するかを見ました。このアプローチで正確な結果を得ることは望んでいませんでしたが、試してみる価値はありました。一番下の行は明らかです：</font><b><font style="vertical-align: inherit;">CPUで</font></b><font style="vertical-align: inherit;">処理するときの非常に低いパフォーマンス</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または、光線の数が少ない同じ穴。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それにもかかわらず、私たちはより高度なアプローチの実装のための橋頭堡を作りました。</font><font style="vertical-align: inherit;">アイデアは、各ポリゴンで特定の数のランダムなポイントを選択し、カメラからそれらの方向に光線を送信することでした。</font><font style="vertical-align: inherit;">このアプローチはうまく機能しましたが、境界のケースがありました。ポリゴンも切断され、ビームとその法線の間の角度はほぼπ/ 2でした。</font><font style="vertical-align: inherit;">したがって、遠近の歪みのためにカメラがズームすると、カットアウト領域が開く可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アーティストによると、この方法は攻撃的すぎることが判明したため、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">裏面</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のみを</font><b><font style="vertical-align: inherit;">トリミング</font></b><font style="vertical-align: inherit;">することに重点を置くことにしました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームを作成するときのデバイスのリソースに対する注意深い態度が最終製品の品質に影響を与える最も重要な要素であることは秘密ではありません。これは、特にRAMのアクティブな使用に不機嫌なモバイルプラットフォームに当てはまります。ポリゴンの数を減らすと、テクスチャアトラスのスペースをより効果的に埋めることができ、計算負荷がわずかに軽減されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、上記のツールを使用する場合の工数やミスによるコストなども忘れずに。提案されたアプローチには、アート部門、特にプロジェクトへのモデルの統合に関与する従業員の適切に機能するパイプラインが含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、この記事で説明する条件とツールを使用して、以下のルールに従います。</font><font style="vertical-align: inherit;">作成されたモデルが常にユーザーに対して片側を向くと想定され、これらの角度から他のモデルによるモデルの一部のオーバーラップがかなり小さい場合、アーティストは</font><font style="vertical-align: inherit;">3Dエディターで</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">裏面</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トリマー</font><b><font style="vertical-align: inherit;">ツールを</font></b><font style="vertical-align: inherit;">使用し</font><font style="vertical-align: inherit;">、正確さをチェックして</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発</font><font style="vertical-align: inherit;">を続行します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">モデルがさまざまな位置で頻繁に使用されるか、より複雑なジオメトリを持つ場合、プロジェクトにインポートした後、記事の最初の部分で説明されているアルゴリズムを実行して、シーン内のすべての静的オブジェクトを処理します。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja484776/index.html">1月21日から26日までのサンクトペテルブルクでのデジタルイベント</a></li>
<li><a href="../ja484778/index.html">Intel Parallel Studio XE 2020：開発者にとって最高の</a></li>
<li><a href="../ja484782/index.html">Blazorクライアント側オンラインストア：パート2-CI / CD</a></li>
<li><a href="../ja484788/index.html">システムのその他の機能：テレフォニーおよびCRM / ERP /ヘルプデスクの統合。何を、どのように、そしてなぜ？</a></li>
<li><a href="../ja484790/index.html">サーバーWindowsの1つのオプションが原因で、サイトの速度が低下したという話</a></li>
<li><a href="../ja484796/index.html">OSWE認定を取得するにはどうすればよいですか？</a></li>
<li><a href="../ja484798/index.html">なぜ高速ソートが本当に遅いのですか？新しい配列ソート方法</a></li>
<li><a href="../ja484800/index.html">Microsoft Application Inspectorソースコードアナライザー</a></li>
<li><a href="../ja484802/index.html">自己破壊モード：光による内視鏡カプセルの分解</a></li>
<li><a href="../ja484804/index.html">企業システムで何を暗号化しますか？そして、なぜこれを行うのですか？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>