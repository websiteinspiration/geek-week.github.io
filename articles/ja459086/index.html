<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📨 👩🏼‍🚒 🌭 FreeRTOSオブジェクトの静的分布 🏻 🌦️ ♑️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="デフォルトでは、FreeRTOSシステム内のすべてのオブジェクト（キュー、セマフォ、タイマー、タスク（スレッド）、ミューテックス）が動的に分散されます。プログラマは「ヒープ」のみを見ます。つまり、プログラムまたはシステムの要求でメモリが動的に割り当てられる領域であり、内部で何が起こっているのかは明確...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>FreeRTOSオブジェクトの静的分布</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459086/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトでは、FreeRTOSシステム内のすべてのオブジェクト（キュー、セマフォ、タイマー、タスク（スレッド）、ミューテックス）が動的に分散されます。プログラマは「ヒープ」のみを見ます。つまり、プログラムまたはシステムの要求でメモリが動的に割り当てられる領域であり、内部で何が起こっているのかは明確ではありません。残りはどれくらいですか？わからない必要以上のものはありますか？知るか？個人的には、メモリが予期せず終了したときにランタイムエラーが発生することなく、ファームウェアの作成段階でもメモリを整理する問題を解決することを好みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">昨日の</font></a><font style="vertical-align: inherit;">論理的な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">続きです。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロコントローラのメモリ内のオブジェクトの静的分布について、FreeRTOSオブジェクトとの関連でのみ。今日は、FreeRTOSオブジェクトを静的に配置する方法を学習します。これにより、マイクロコントローラーのRAMで何が起こっているか、オブジェクトが正確にどのように配置され、どのくらい占有されているかをより明確に理解できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、FreeRTOSオブジェクトを取得して静的に配置するだけではそれほど気にする必要はありません。バージョン9.0以降、FreeRTOSは静的に配置されたオブジェクトを作成するための関数を提供します。このような関数には、名前にStaticサフィックスが付いており、これらの関数の例を含む優れたドキュメントがあります。オブジェクトを静的に配置するだけでなく、すべてのジブを非表示にするだけでなく、より便利なインターフェイスを提供するFreeRTOS関数の便利で美しいC ++ラッパーを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は初心者プログラマーを対象としていますが、FreeRTOSの基本とマルチスレッドプログラムの同期の基本要素に既に精通しています。</font><font style="vertical-align: inherit;">行け。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FreeRTOSは、マイクロコントローラー用のオペレーティングシステムです。</font><font style="vertical-align: inherit;">そうですね、完全なOSではなく、複数のタスクを並行して実行できるライブラリです。</font><font style="vertical-align: inherit;">FreeRTOSでは、タスクがメッセージキューを介してメッセージを交換し、タイマーを使用し、セマフォとミューテックスを使用してタスクを同期することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では、2つ（またはそれ以上）のタスクを同時に実行する必要があるファームウェアは、FreeRTOSを使用すれば、はるかに簡単かつエレガントに解決できます。</font><font style="vertical-align: inherit;">たとえば、遅いセンサーからの読み取り値を読み取り、同時にディスプレイを提供します。</font><font style="vertical-align: inherit;">センサーが読み取られている間のみブレーキなし。</font><font style="vertical-align: inherit;">一般的に、持っている必要があります！</font><font style="vertical-align: inherit;">勉強を強くお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前の記事で述べたように、コンパイルの段階でオブジェクトの数とサイズがわかっている場合、オブジェクトを動的に作成するアプローチはあまり好きではありません。このようなオブジェクトを静的に配置すると、マイクロコントローラーでのメモリ割り当てをより明確に理解できるため、メモリが突然終了したときの驚きを回避できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、STM32F103C8T6マイクロコントローラーのBluePillボードを使用して、FreeRTOSのメモリ構成の問題を検討します。コンパイラとビルドシステムを気にしないために、このボードのサポートをインストールしてArduinoIDE環境で作業します。 STM32用のArduinoの実装はいくつかあります-原則として、どれでも実装できます。</font><font style="vertical-align: inherit;">Readme.mdプロジェクトの指示に従って</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32duino</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をインストールし</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ました。</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">FreeRTOSバージョン10.0は、ArduinoIDEライブラリマネージャーを通じてインストールされます。</font><font style="vertical-align: inherit;">コンパイラ-gcc 8.2 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小さな実験的な作業を自分で考えます。</font><font style="vertical-align: inherit;">このタスクには実際的な意味はあまりないかもしれませんが、FreeRTOSにあるすべての同期プリミティブが使用されます。</font><font style="vertical-align: inherit;">このようなもの：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つのタスク（スレッド）が並行して動作します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイマーも機能し、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">シグナル待機モードの</font></a><font style="vertical-align: inherit;">セマフォを使用して、最初のタスクに通知を送信することがあり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイマーから通知を受け取った最初のタスクは、キューを介して2番目のタスクにメッセージ（乱数）を送信します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目は、メッセージを受信して​​、コンソールに出力します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のタスクで何かをコンソールに出力し、コンソールがmutexによって保護されるのと競合しないようにします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キューのサイズは1つの要素に制限することができますが、より興味深いものにするために、1000を入れました</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（ドキュメントとチュートリアルによると）標準の実装は次のようになります。 </font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;STM32FreeRTOS.h&gt;</span></span><font></font>
 <font></font>
TimerHandle_t xTimer;<font></font>
xSemaphoreHandle xSemaphore;<font></font>
xSemaphoreHandle xMutex;<font></font>
xQueueHandle xQueue;<font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vTimerCallback</span><span class="hljs-params">(TimerHandle_t pxTimer)</span>
</span>{<font></font>
  xSemaphoreGive(xSemaphore);<font></font>
}<font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vTask1</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *)</span>
</span>{
  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<font></font>
  {<font></font>
	xSemaphoreTake(xSemaphore, portMAX_DELAY);<font></font>
	<span class="hljs-keyword">int</span> value = random(<span class="hljs-number">1000</span>);<font></font>
	xQueueSend(xQueue, &amp;value, portMAX_DELAY);<font></font>
 <font></font>
	xSemaphoreTake(xMutex, portMAX_DELAY);<font></font>
	Serial.println(<span class="hljs-string">"Test"</span>);<font></font>
	xSemaphoreGive(xMutex);<font></font>
  }<font></font>
}<font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vTask2</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *)</span>
</span>{
  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<font></font>
  {<font></font>
	<span class="hljs-keyword">int</span> value;<font></font>
	xQueueReceive(xQueue, &amp;value, portMAX_DELAY);<font></font>
 <font></font>
	xSemaphoreTake(xMutex, portMAX_DELAY);<font></font>
	Serial.println(value);<font></font>
	xSemaphoreGive(xMutex);<font></font>
  }<font></font>
}<font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span>
</span>{<font></font>
  Serial.begin(<span class="hljs-number">9600</span>);<font></font>
 <font></font>
  vSemaphoreCreateBinary(xSemaphore);<font></font>
  xQueue = xQueueCreate(<span class="hljs-number">1000</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<font></font>
  xMutex = xSemaphoreCreateMutex();<font></font>
 <font></font>
  xTimer = xTimerCreate(<span class="hljs-string">"Timer"</span>, <span class="hljs-number">1000</span>, pdTRUE, <span class="hljs-literal">NULL</span>, vTimerCallback);<font></font>
  xTimerStart(xTimer, <span class="hljs-number">0</span>);<font></font>
 <font></font>
  xTaskCreate(vTask1, <span class="hljs-string">"Task 1"</span>, configMINIMAL_STACK_SIZE, <span class="hljs-literal">NULL</span>, tskIDLE_PRIORITY, <span class="hljs-literal">NULL</span>);<font></font>
  xTaskCreate(vTask2, <span class="hljs-string">"Task 2"</span>, configMINIMAL_STACK_SIZE, <span class="hljs-literal">NULL</span>, tskIDLE_PRIORITY, <span class="hljs-literal">NULL</span>);<font></font>
  vTaskStartScheduler();<font></font>
}<font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{}</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなコードをコンパイルした場合、マイクロコントローラーのメモリで何が起こるか見てみましょう。</font><font style="vertical-align: inherit;">デフォルトでは、すべてのFreeRTOSオブジェクトは動的メモリに配置されます。</font><font style="vertical-align: inherit;">FreeRTOSは、実装が難しいメモリマネージャーの実装を5つまで提供しますが、一般に、FreeRTOSとユーザーのニーズに合わせてメモリの一部を切り取るという同じタスクがあります。</font><font style="vertical-align: inherit;">ピースは、（mallocを使用して）マイクロコントローラーの一般的なヒープからカットされるか、独自の個別のヒープを使用してカットされます。</font><font style="vertical-align: inherit;">どのようなヒープが使用されているかは重要ではありません。とにかく、ヒープの内部を調べることはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、FreeRTOSという名前のヒープの場合、次のようになります（objdumpユーティリティからの出力）。</font></font><br>
<br>
<pre><code class="plaintext hljs">...<font></font>
200009dc l 	O .bss      	00002000 ucHeap<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それら。すべてのFreeRTOSオブジェクトがカットされた大きな部分が1つあります-セマフォ、ミューテックス、タイマー、キュー、さらにはタスク自体です。最後の2つのポイントは非常に重要です。要素の数によっては、キューが非常に大きくなる可能性があり、タスクと一緒に割り当てられるスタックにより、タスクは多くのスペースを占めることが保証されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、これはマルチタスクのマイナスです-各タスクには独自のスタックがあります。さらに、スタックは、タスク自体の呼び出しとローカル変数だけでなく、これが発生した場合の割り込みスタックも格納できるように、十分な大きさである必要があります。まあ、いつでも割り込みが発生する可能性があるため、割り込みが発生した場合に備えて、各タスクはスタック上に予約を確保する必要があります。さらに、CortexMマイクロコントローラーは割り込みを入れ子にすることができるため、スタックは、同時に発生するすべての割り込みに対応できる十分な大きさでなければなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクスタックのサイズは、タスクがxTaskCreate関数のパラメーターによって作成されるときに設定されます。</font><font style="vertical-align: inherit;">スタックサイズは、configMINIMAL_STACK_SIZEパラメータ（FreeRTOSConfig.h構成ファイルで指定）より小さくすることはできません。これは、割り込みの予約と同じです。</font><font style="vertical-align: inherit;">ヒープサイズはconfigTOTAL_HEAP_SIZEパラメータで設定され、この場合は8KBです。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、すべてのオブジェクトが8KBのヒープに収まるかどうかを推測してみてください。</font><font style="vertical-align: inherit;">そして、いくつかのオブジェクト？</font><font style="vertical-align: inherit;">そして、さらにいくつかのタスク？</font></font></b><div class="spoiler_text">   FreeRTOS      .    :    . ..  , ,       .         .     12.<br>
</div></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数xTimer、xQueue、xSemaphore、およびxMutexとは何ですか？</font><font style="vertical-align: inherit;">彼らは私たちが必要とするオブジェクトを説明していませんか？</font><font style="vertical-align: inherit;">いいえ、これらは単なるハンドルです-同期オブジェクト自体を記述する特定の（不透明な）構造へのポインター</font></font><br>
<br>
<pre><code class="plaintext hljs">200009cc g 	O .bss     	00000004 xTimer<font></font>
200009d0 g     O .bss    	00000004 xSemaphore<font></font>
200009cc g 	O .bss     	00000004 xQueue<font></font>
200009d4 g 	O .bss    	00000004 xMutex<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに述べたように、私は前の記事と同じ方法でこのすべての混乱を修復することを提案します-コンパイル段階ですべてのオブジェクトを静的に配布します。</font><font style="vertical-align: inherit;">FreeRTOS構成ファイルでconfigSUPPORT_STATIC_ALLOCATIONパラメーターが1に設定されている場合、静的配布機能が使用可能になり</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。キューから始めましょう。</font><font style="vertical-align: inherit;">FreeRTOSのドキュメントがキューを割り当てるために提供する方法は次のとおりです</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AMessage</span>
 {</span>
            	<span class="hljs-keyword">char</span> ucMessageID;
            	<span class="hljs-keyword">char</span> ucData[ <span class="hljs-number">20</span> ];<font></font>
 };<font></font>
 <font></font>
 <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> QUEUE_LENGTH 10</span>
 <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ITEM_SIZE sizeof( uint32_t )</span><font></font>
 <font></font>
 <span class="hljs-comment">// xQueueBuffer will hold the queue structure.</span><font></font>
 StaticQueue_t xQueueBuffer;<font></font>
 <font></font>
 <span class="hljs-comment">// ucQueueStorage will hold the items posted to the queue.  Must be at least</span>
 <span class="hljs-comment">// [(queue length) * ( queue item size)] bytes long.</span>
 <span class="hljs-keyword">uint8_t</span> ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];<font></font>
 <font></font>
 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vATask</span><span class="hljs-params">( <span class="hljs-keyword">void</span> *pvParameters )</span>
 </span>{<font></font>
 QueueHandle_t xQueue1;<font></font>
 <font></font>
            	<span class="hljs-comment">// Create a queue capable of containing 10 uint32_t values.</span>
            	xQueue1 = xQueueCreate( QUEUE_LENGTH, <span class="hljs-comment">// The number of items the queue can hold.</span>
                                                                                                            	ITEM_SIZE       	  <span class="hljs-comment">// The size of each item in the queue</span>
                                                                                                            	&amp;( ucQueueStorage[ <span class="hljs-number">0</span> ] ), <span class="hljs-comment">// The buffer that will hold the items in the queue.</span>
                                                                                                            	&amp;xQueueBuffer ); <span class="hljs-comment">// The buffer that will hold the queue structure.</span><font></font>
 <font></font>
            	<span class="hljs-comment">// The queue is guaranteed to be created successfully as no dynamic memory</span>
            	<span class="hljs-comment">// allocation is used.  Therefore xQueue1 is now a handle to a valid queue.</span><font></font>
 <font></font>
            	<span class="hljs-comment">// ... Rest of task code.</span>
 }</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、キューは3つの変数で記述されています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ucQueueStorage配列は、キュー要素が配置される場所です。</font><font style="vertical-align: inherit;">キューのサイズは、キューごとにユーザーが個別に設定します。</font></font></li>
<li> xQueueBuffer –      ,  ,   ,      ,  FreeRTOS    .   ,   ,   ,   FreeRTOS    QueueDefinition ( ).</li>
<li> xQueue1 –    (handle).    ,     (,     ,   )    .       QueueDefinition,    ( )  ,        .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、例のようにすることは問題になりません。</font><font style="vertical-align: inherit;">しかし、個人的には、エンティティごとに最大3つの変数を持つことは好きではありません。</font><font style="vertical-align: inherit;">それをカプセル化できるクラスはすでにそれを求めています。</font><font style="vertical-align: inherit;">1つの問題のみ-各キューのサイズは異なる場合があります。</font><font style="vertical-align: inherit;">ある場所ではより大きなキューが必要ですが、別の場所ではいくつかの要素で十分です。</font><font style="vertical-align: inherit;">静的にキューに入れたいので、コンパイル時にこのサイズを何らかの方法で指定する必要があります。</font><font style="vertical-align: inherit;">このためのテンプレートを使用できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">size_t</span> <span class="hljs-title">size</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">Queue</span>
{</span><font></font>
  QueueHandle_t xHandle;<font></font>
  StaticQueue_t x QueueDefinition;<font></font>
  T         	xStorage[size];<font></font>
 <font></font>
<span class="hljs-keyword">public</span>:<font></font>
  Queue()<font></font>
  {<font></font>
	xHandle = xQueueCreateStatic(size,<font></font>
                 	<span class="hljs-keyword">sizeof</span>(T),
                     <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uint8_t</span>*&gt;(xStorage),<font></font>
                 	&amp;xQueueDefinition);<font></font>
  }<font></font>
 <font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">receive</span><span class="hljs-params">(T * val, TickType_t xTicksToWait = portMAX_DELAY)</span>
  </span>{
	<span class="hljs-keyword">return</span> xQueueReceive(xHandle, val, xTicksToWait);<font></font>
  }<font></font>
 <font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp; val, TickType_t xTicksToWait = portMAX_DELAY)</span>
  </span>{
	<span class="hljs-keyword">return</span> xQueueSend(xHandle, &amp;val, xTicksToWait);<font></font>
  }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、すぐに便利なメッセージの送受信機能もこのクラスに落ち着きました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キューは、次のようなグローバル変数として宣言されます</font></font><br>
<br>
<pre><code class="cpp hljs">Queue&lt;<span class="hljs-keyword">int</span>, <span class="hljs-number">1000</span>&gt; xQueue;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージ送信</font></font><br>
<br>
<pre><code class="cpp hljs">	xQueue.send(value);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージを受信</font></font><br>
<br>
<pre><code class="cpp hljs">	<span class="hljs-keyword">int</span> value;<font></font>
	xQueue.receive(&amp;value);<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、セマフォを扱いましょう。</font><font style="vertical-align: inherit;">また、技術的には（FreeRTOS内で）セマフォとミューテックスはキューを介して実装されますが、意味的にこれらは3つの異なるプリミティブです。</font><font style="vertical-align: inherit;">したがって、それらを別々のクラスに実装します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セマフォクラスの実装は非常に簡単です。いくつかの変数を格納し、いくつかの関数を宣言するだけです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sema</span>
{</span><font></font>
  SemaphoreHandle_t xSema;<font></font>
  StaticSemaphore_t xSemaControlBlock;<font></font>
 <font></font>
<span class="hljs-keyword">public</span>:<font></font>
  Sema()<font></font>
  {<font></font>
	xSema = xSemaphoreCreateBinaryStatic(&amp;xSemaControlBlock);<font></font>
  }<font></font>
 <font></font>
  <span class="hljs-function">BaseType_t <span class="hljs-title">give</span><span class="hljs-params">()</span>
  </span>{
	<span class="hljs-keyword">return</span> xSemaphoreGive(xSema);<font></font>
  }<font></font>
 <font></font>
  <span class="hljs-function">BaseType_t <span class="hljs-title">take</span><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span>
  </span>{
	<span class="hljs-keyword">return</span> xSemaphoreTake(xSema, xTicksToWait);<font></font>
  }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セマフォ宣言</font></font><br>
<br>
<pre><code class="cpp hljs">Sema xSema;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セマフォキャプチャ</font></font><br>
<br>
<pre><code class="cpp hljs">  xSema.take();</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セマフォの解放</font></font><br>
<br>
<pre><code class="cpp hljs">  xSema.give();</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今ミューテックス</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mutex</span>
{</span><font></font>
  SemaphoreHandle_t xMutex;<font></font>
  StaticSemaphore_t xMutexControlBlock;<font></font>
 <font></font>
<span class="hljs-keyword">public</span>:<font></font>
  Mutex()<font></font>
  {<font></font>
	xMutex = xSemaphoreCreateMutexStatic(&amp;xSemaControlBlock);<font></font>
  }<font></font>
 <font></font>
  <span class="hljs-function">BaseType_t <span class="hljs-title">lock</span><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span>
  </span>{
	<span class="hljs-keyword">return</span> xSemaphoreTake(xMutex, xTicksToWait);<font></font>
  }<font></font>
 <font></font>
  <span class="hljs-function">BaseType_t <span class="hljs-title">unlock</span><span class="hljs-params">()</span>
  </span>{
	<span class="hljs-keyword">return</span> xSemaphoreGive(xMutex);<font></font>
  } <font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、mutexクラスはセマフォクラスとほとんど同じです。</font><font style="vertical-align: inherit;">しかし、意味的に言ったように、これらは異なる実体です。</font><font style="vertical-align: inherit;">さらに、これらのクラスのインターフェースは完全ではなく、完全に異なる方向に拡張されます。</font><font style="vertical-align: inherit;">そのため、giveFromISR（）メソッドとtakeFromISR（）メソッドをセマフォに追加して、割り込みでセマフォを操作できますが、ミューテックスにはtryLock（）メソッドのみが追加されています。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイナリセマフォとミューテックスの違いを知っていただければ幸いです。</font></font></b><div class="spoiler_text">       ,  , 90%     .           .       signal-wait,      ( give()),     ( take()).<br>
<br>
 , ,        (),   .  ,  FreeRTOS  ,     (, Linux)     .</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MutexはスタイルCで使用できます。</font><font style="vertical-align: inherit;">ロック（）/ロック解除（）を直接呼び出します。</font><font style="vertical-align: inherit;">しかし、C ++で記述しているので、RAIIの魅力を利用して、ミューテックス自体をキャプチャして解放するより便利なラッパーを記述できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutexLocker</span>
{</span><font></font>
  Mutex &amp; mtx;<font></font>
 <font></font>
<span class="hljs-keyword">public</span>:<font></font>
  MutexLocker(Mutex &amp; mutex)<font></font>
	: mtx(mutex)<font></font>
  {<font></font>
	mtx.lock();<font></font>
  }<font></font>
 <font></font>
  ~MutexLocker()<font></font>
  {<font></font>
	mtx.unlock();<font></font>
  }<font></font>
};</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スコープを離れると、ミューテックスは自動的に解放されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、関数からいくつかの出口があり、リソースを解放する必要性を常に覚えておく必要がない場合に特に便利です。</font></font><br>
<br>
<pre><code class="cpp hljs">	<span class="hljs-function">MutexLocker <span class="hljs-title">lock</span><span class="hljs-params">(xMutex)</span></span>;<font></font>
	Serial.println(value);<font></font>
  } <span class="hljs-comment">// mutex will be unlocked here</span></code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイマーの番です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Timer</span>
{</span><font></font>
  TimerHandle_t xTimer;<font></font>
  StaticTimer_t xTimerControlBlock;<font></font>
 <font></font>
<span class="hljs-keyword">public</span>:<font></font>
  Timer(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> pcTimerName,
    	<span class="hljs-keyword">const</span> TickType_t xTimerPeriodInTicks,
    	<span class="hljs-keyword">const</span> UBaseType_t uxAutoReload,
    	<span class="hljs-keyword">void</span> * <span class="hljs-keyword">const</span> pvTimerID,<font></font>
    	TimerCallbackFunction_t pxCallbackFunction)<font></font>
	{<font></font>
  	xTimer = xTimerCreateStatic(pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, &amp;xTimerControlBlock);<font></font>
	}<font></font>
 <font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(TickType_t xTicksToWait = <span class="hljs-number">0</span>)</span>
	</span>{<font></font>
  	xTimerStart(xTimer, xTicksToWait);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、ここのすべては前のクラスと似ています。詳しくは説明しません。おそらく、APIには多くの機能が残されていますが、少なくとも拡張が必要です。しかし、私の目標は原則を示すことであり、それを生産準備の状態にすることではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、タスク。各タスクにはスタックがあり、事前にメモリに配置する必要があります。キューと同じテクニックを使用します-テンプレートクラスを作成します</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> ulStackDepth&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span>
{</span>
<span class="hljs-keyword">protected</span>:<font></font>
  StaticTask_t xTaskControlBlock;<font></font>
  StackType_t xStack[ ulStackDepth ];<font></font>
  TaskHandle_t xTask;<font></font>
 <font></font>
<span class="hljs-keyword">public</span>:<font></font>
  Task(TaskFunction_t pxTaskCode,<font></font>
   	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> pcName,
   	<span class="hljs-keyword">void</span> * <span class="hljs-keyword">const</span> pvParameters,<font></font>
   	UBaseType_t uxPriority)<font></font>
  {<font></font>
	xTask = xTaskCreateStatic(pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, xStack, &amp;xTaskControlBlock);<font></font>
  }<font></font>
};</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクオブジェクトはグローバル変数として宣言されているため、main（）を呼び出す前に、グローバル変数として初期化されます。つまり、タスクに転送されるパラメーターもこの段階で認識されている必要があります。タスクを作成する前に計算する必要がある何かが渡された場合、このニュアンスを考慮に入れる必要があります（私はそこにNULLがあるだけです）。それでも問題が解決しない場合</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、前の記事の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローカル静的変数を使用するオプションを検討して</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ください</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイルしてエラーを取得します。</font></font><br>
<br>
<pre><code class="plaintext hljs">tasks.c:(.text.vTaskStartScheduler+0x10): undefined reference to `vApplicationGetIdleTaskMemory'<font></font>
timers.c:(.text.xTimerCreateTimerTask+0x1a): undefined reference to `vApplicationGetTimerTaskMemory'</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまりね。各OSには特別なタスク-アイドルタスク（デフォルトタスク、何もしないタスク）があります。オペレーティングシステムは、他のすべてのタスクを実行できない場合（スリープ状態、何かを待機している場合など）にこのタスクを実行します。一般に、これは最も一般的なタスクであり、優先度は最も低くなります。しかし、ここではFreeRTOSカーネル内で作成されており、その作成に影響を与えることはできません。しかし、タスクを静的に配置し始めたので、コントロールユニットを配置する場所とこのタスクのスタックをOSに何らかの方法で伝える必要があります。これがFreeRTOSの目的であり、特別な関数vApplicationGetIdleTaskMemory（）を定義するように求めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状況はタイマーのタスクと似ています。</font><font style="vertical-align: inherit;">FreeRTOSシステムのタイマーは、それ自体では機能しません。OSで特別なタスクが実行され、これらのタイマーを提供します。</font><font style="vertical-align: inherit;">また、このタスクには制御ブロックとスタックも必要です。</font><font style="vertical-align: inherit;">それと同じように、OSはvApplicationGetTimerTaskMemory（）関数を使用している場所を示すように要求します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数自体は自明であり、静的に割り当てられたオブジェクトへの対応するポインタを返すだけです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vApplicationGetIdleTaskMemory</span><span class="hljs-params">( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, <span class="hljs-keyword">uint32_t</span> *pulIdleTaskStackSize)</span>
</span>{
  <span class="hljs-keyword">static</span> StaticTask_t Idle_TCB;
  <span class="hljs-keyword">static</span> StackType_t  Idle_Stack[configMINIMAL_STACK_SIZE];<font></font>
 <font></font>
  *ppxIdleTaskTCBBuffer = &amp;Idle_TCB;<font></font>
  *ppxIdleTaskStackBuffer = Idle_Stack;<font></font>
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;<font></font>
}<font></font>
 <font></font>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vApplicationGetTimerTaskMemory</span> <span class="hljs-params">(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, <span class="hljs-keyword">uint32_t</span> *pulTimerTaskStackSize)</span>
</span>{
  <span class="hljs-keyword">static</span> StaticTask_t Timer_TCB;
  <span class="hljs-keyword">static</span> StackType_t  Timer_Stack[configTIMER_TASK_STACK_DEPTH];<font></font>
 <font></font>
  *ppxTimerTaskTCBBuffer   = &amp;Timer_TCB;<font></font>
  *ppxTimerTaskStackBuffer = Timer_Stack;<font></font>
  *pulTimerTaskStackSize   = configTIMER_TASK_STACK_DEPTH;<font></font>
}</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何が起きたのか見てみましょう。 </font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私はネタバレの下にヘルパーのコードを隠します、あなたはそれを見ました</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">size_t</span> <span class="hljs-title">size</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">Queue</span>
{</span><font></font>
  QueueHandle_t xHandle;<font></font>
  StaticQueue_t xQueueDefinition;<font></font>
  T         	xStorage[size];<font></font>
 <font></font>
<span class="hljs-keyword">public</span>:<font></font>
  Queue()<font></font>
  {<font></font>
	xHandle = xQueueCreateStatic(size,<font></font>
                 	<span class="hljs-keyword">sizeof</span>(T),
                     <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uint8_t</span>*&gt;(xStorage),<font></font>
                 	&amp;xQueueDefinition);<font></font>
  }<font></font>
 <font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">receive</span><span class="hljs-params">(T * val, TickType_t xTicksToWait = portMAX_DELAY)</span>
  </span>{
	<span class="hljs-keyword">return</span> xQueueReceive(xHandle, val, xTicksToWait);<font></font>
  }<font></font>
 <font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp; val, TickType_t xTicksToWait = portMAX_DELAY)</span>
  </span>{
	<span class="hljs-keyword">return</span> xQueueSend(xHandle, &amp;val, xTicksToWait);<font></font>
  }<font></font>
};<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sema</span>
{</span><font></font>
  SemaphoreHandle_t xSema;<font></font>
  StaticSemaphore_t xSemaControlBlock;<font></font>
 <font></font>
<span class="hljs-keyword">public</span>:<font></font>
  Sema()<font></font>
  {<font></font>
	xSema = xSemaphoreCreateBinaryStatic(&amp;xSemaControlBlock);<font></font>
  }<font></font>
 <font></font>
  <span class="hljs-function">BaseType_t <span class="hljs-title">give</span><span class="hljs-params">()</span>
  </span>{
	<span class="hljs-keyword">return</span> xSemaphoreGive(xSema);<font></font>
  }<font></font>
 <font></font>
  <span class="hljs-function">BaseType_t <span class="hljs-title">take</span><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span>
  </span>{
	<span class="hljs-keyword">return</span> xSemaphoreTake(xSema, xTicksToWait);<font></font>
  }<font></font>
};<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mutex</span>
{</span><font></font>
  SemaphoreHandle_t xMutex;<font></font>
  StaticSemaphore_t xMutexControlBlock;<font></font>
 <font></font>
<span class="hljs-keyword">public</span>:<font></font>
  Mutex()<font></font>
  {<font></font>
	xMutex = xSemaphoreCreateMutexStatic(&amp;xMutexControlBlock);<font></font>
  }<font></font>
 <font></font>
  <span class="hljs-function">BaseType_t <span class="hljs-title">lock</span><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span>
  </span>{
	<span class="hljs-keyword">return</span> xSemaphoreTake(xMutex, xTicksToWait);<font></font>
  }<font></font>
 <font></font>
  <span class="hljs-function">BaseType_t <span class="hljs-title">unlock</span><span class="hljs-params">()</span>
  </span>{
	<span class="hljs-keyword">return</span> xSemaphoreGive(xMutex);<font></font>
  } <font></font>
};<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutexLocker</span>
{</span><font></font>
  Mutex &amp; mtx;<font></font>
 <font></font>
<span class="hljs-keyword">public</span>:<font></font>
  MutexLocker(Mutex &amp; mutex)<font></font>
	: mtx(mutex)<font></font>
  {<font></font>
	mtx.lock();<font></font>
  }<font></font>
 <font></font>
  ~MutexLocker()<font></font>
  {<font></font>
	mtx.unlock();<font></font>
  }<font></font>
};<font></font>
 <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Timer</span>
{</span><font></font>
  TimerHandle_t xTimer;<font></font>
  StaticTimer_t xTimerControlBlock;<font></font>
 <font></font>
<span class="hljs-keyword">public</span>:<font></font>
  Timer(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> pcTimerName,
    	<span class="hljs-keyword">const</span> TickType_t xTimerPeriodInTicks,
    	<span class="hljs-keyword">const</span> UBaseType_t uxAutoReload,
    	<span class="hljs-keyword">void</span> * <span class="hljs-keyword">const</span> pvTimerID,<font></font>
    	TimerCallbackFunction_t pxCallbackFunction)<font></font>
	{<font></font>
  	xTimer = xTimerCreateStatic(pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, &amp;xTimerControlBlock);<font></font>
	}<font></font>
 <font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(TickType_t xTicksToWait = <span class="hljs-number">0</span>)</span>
	</span>{<font></font>
  	xTimerStart(xTimer, xTicksToWait);<font></font>
	}<font></font>
};<font></font>
 <font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> ulStackDepth&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span>
{</span>
<span class="hljs-keyword">protected</span>:<font></font>
  StaticTask_t xTaskControlBlock;<font></font>
  StackType_t xStack[ ulStackDepth ];<font></font>
  TaskHandle_t xTask;<font></font>
 <font></font>
<span class="hljs-keyword">public</span>:<font></font>
  Task(TaskFunction_t pxTaskCode,<font></font>
   	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> pcName,
   	<span class="hljs-keyword">void</span> * <span class="hljs-keyword">const</span> pvParameters,<font></font>
   	UBaseType_t uxPriority)<font></font>
  {<font></font>
	xTask = xTaskCreateStatic(pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, xStack, &amp;xTaskControlBlock);<font></font>
  }<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vApplicationGetIdleTaskMemory</span><span class="hljs-params">( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, <span class="hljs-keyword">uint32_t</span> *pulIdleTaskStackSize)</span>
</span>{
  <span class="hljs-keyword">static</span> StaticTask_t Idle_TCB;
  <span class="hljs-keyword">static</span> StackType_t  Idle_Stack[configMINIMAL_STACK_SIZE];<font></font>
 <font></font>
  *ppxIdleTaskTCBBuffer = &amp;Idle_TCB;<font></font>
  *ppxIdleTaskStackBuffer = Idle_Stack;<font></font>
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;<font></font>
}<font></font>
 <font></font>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vApplicationGetTimerTaskMemory</span> <span class="hljs-params">(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, <span class="hljs-keyword">uint32_t</span> *pulTimerTaskStackSize)</span>
</span>{
  <span class="hljs-keyword">static</span> StaticTask_t Timer_TCB;
  <span class="hljs-keyword">static</span> StackType_t  Timer_Stack[configTIMER_TASK_STACK_DEPTH];<font></font>
 <font></font>
  *ppxTimerTaskTCBBuffer   = &amp;Timer_TCB;<font></font>
  *ppxTimerTaskStackBuffer = Timer_Stack;<font></font>
  *pulTimerTaskStackSize   = configTIMER_TASK_STACK_DEPTH;<font></font>
}</code></pre></div></div><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムコード全体。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">Timer <span class="hljs-title">xTimer</span><span class="hljs-params">(<span class="hljs-string">"Timer"</span>, <span class="hljs-number">1000</span>, pdTRUE, <span class="hljs-literal">NULL</span>, vTimerCallback)</span></span>;<font></font>
Sema xSema;<font></font>
Mutex xMutex;<font></font>
Queue&lt;<span class="hljs-keyword">int</span>, <span class="hljs-number">1000</span>&gt; xQueue;<font></font>
 <font></font>
<span class="hljs-function">Task&lt;configMINIMAL_STACK_SIZE&gt; <span class="hljs-title">task1</span><span class="hljs-params">(vTask1, <span class="hljs-string">"Task 1"</span>, <span class="hljs-literal">NULL</span>, tskIDLE_PRIORITY)</span></span>;
<span class="hljs-function">Task&lt;configMINIMAL_STACK_SIZE&gt; <span class="hljs-title">task2</span><span class="hljs-params">(vTask2, <span class="hljs-string">"Task 2"</span>, <span class="hljs-literal">NULL</span>, tskIDLE_PRIORITY)</span></span>;<font></font>
 <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vTimerCallback</span><span class="hljs-params">(TimerHandle_t pxTimer)</span>
</span>{<font></font>
  xSema.give();<font></font>
 <font></font>
  <span class="hljs-function">MutexLocker <span class="hljs-title">lock</span><span class="hljs-params">(xMutex)</span></span>;<font></font>
  Serial.println(<span class="hljs-string">"Test"</span>);<font></font>
}<font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vTask1</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *)</span>
</span>{
  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<font></font>
  {<font></font>
	xSema.take();<font></font>
	<span class="hljs-keyword">int</span> value = random(<span class="hljs-number">1000</span>);<font></font>
	xQueue.send(value);<font></font>
  }<font></font>
}<font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vTask2</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *)</span>
</span>{
  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<font></font>
  {<font></font>
	<span class="hljs-keyword">int</span> value;<font></font>
	xQueue.receive(&amp;value);<font></font>
 <font></font>
	<span class="hljs-function">MutexLocker <span class="hljs-title">lock</span><span class="hljs-params">(xMutex)</span></span>;<font></font>
	Serial.println(value);<font></font>
  }<font></font>
}<font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span>
</span>{<font></font>
  Serial.begin(<span class="hljs-number">9600</span>);<font></font>
 <font></font>
  xTimer.start();<font></font>
 <font></font>
  vTaskStartScheduler();<font></font>
}<font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果のバイナリを逆アセンブルして、何がどのように配置されているかを確認できます（objdumpの出力は、読みやすくするためにわずかに色付けされています）。</font></font><br>
<br>
<pre><code class="plaintext hljs">0x200000b0    	.bss    	512     	vApplicationGetIdleTaskMemory::Idle_Stack<font></font>
0x200002b0    	.bss    	92       	vApplicationGetIdleTaskMemory::Idle_TCB<font></font>
0x2000030c     	.bss    	1024   	vApplicationGetTimerTaskMemory::Timer_Stack<font></font>
0x2000070c     	.bss    	92       	vApplicationGetTimerTaskMemory::Timer_TCB<font></font>
0x200009c8     	.bss    	608     	task1<font></font>
0x20000c28     	.bss    	608     	task2<font></font>
0x20000e88    	.bss    	84       	xMutex<font></font>
0x20000edc    	.bss    	4084   	xQueue<font></font>
0x20001ed0    	.bss    	84       	xSema<font></font>
0x20001f24     	.bss    	48       	xTimer</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目標は達成されました-今、すべてが完全に見えています。</font><font style="vertical-align: inherit;">各オブジェクトは表示され、そのサイズは理解可能です（ただし、タスクタイプの複合オブジェクトは、すべてのパーツを1つのピースと見なします）。</font><font style="vertical-align: inherit;">コンパイラー統計も非常に正確で、今回は非常に便利です。</font></font><br>
<br>
<pre><code class="plaintext hljs">Sketch uses 20,800 bytes (15%) of program storage space. Maximum is 131,072 bytes.<font></font>
Global variables use 9,332 bytes (45%) of dynamic memory, leaving 11,148 bytes for local variables. Maximum is 20,480 bytes.</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FreeRTOSではタスク、キュー、セマフォ、ミューテックスを即座に作成および削除できますが、多くの場合、これは必要ありません。原則として、最初にすべてのオブジェクトを一度作成すれば十分であり、それらは次の再起動まで機能します。そして、これはコンパイル段階でそのようなオブジェクトを静的に配布する良い理由です。その結果、オブジェクトが占めるメモリ、どこに何があり、どれだけの空きメモリが残っているかを明確に理解できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、提案された方法は、アプリケーション全体の寿命に匹敵する寿命を持つオブジェクトを配置する場合にのみ適しています。それ以外の場合は、動的メモリを使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FreeRTOSオブジェクトの静的配置に加えて、FreeRTOSプリミティブの便利なラッパーも作成しました。これにより、クライアントコードをいくらか簡素化し、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要に応じ</font><font style="vertical-align: inherit;">て</font><font style="vertical-align: inherit;">インターフェイス</font><font style="vertical-align: inherit;">をカプセル化することもできます</font><font style="vertical-align: inherit;">（たとえば、戻りコードをチェックしないか、タイムアウトを使用しない）。実装が不完全であることも注目に値します-キューを介してメッセージを送受信するすべての可能な方法（たとえば、割り込みから、キューの最初または最後まで送信）の実装に悩まされず、割り込みからの同期プリミティブ、カウント（非バイナリ）セマフォを使用しませんでした、そして、はるかに。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はこのコードを「テイクアンドユース」の状態にするのが面倒だったので、アイデアを示したかっただけです。しかし、既製のライブラリが必要な人は、私はちょうど</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">frtライブラリに</font></a><font style="vertical-align: inherit;">出くわしました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">その中のすべてが実質的に同じで、頭に浮かんだだけです。</font><font style="vertical-align: inherit;">まあ、インターフェイスは少し異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の例は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事を最後までお読みいただき、ありがとうございます。</font><font style="vertical-align: inherit;">私は建設的な批評に喜んでいます。</font><font style="vertical-align: inherit;">コメントでニュアンスを議論することも興味深いでしょう。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja459074/index.html">ささいな喜び＃7：1つの価格で3つ-コンソールアニメーション、アルゴリズム、デバッグ</a></li>
<li><a href="../ja459078/index.html">CERNがオープンソースソフトウェアに切り替わりました-なぜですか？</a></li>
<li><a href="../ja459080/index.html">java.netのHttpUrlConnectionの機能</a></li>
<li><a href="../ja459082/index.html">誰がアイデティクスであり、虚偽の記憶がどのように機能するか、そして記憶についての3つの一般的な神話</a></li>
<li><a href="../ja459084/index.html">Google Home Hubについて、または130ユーロでフォトフレームを購入した方法</a></li>
<li><a href="../ja459088/index.html">点群のポイントセグメンテーションメソッド</a></li>
<li><a href="../ja459092/index.html">X.Spectator-.NETでのステータス監視</a></li>
<li><a href="../ja459098/index.html">GitHub Package RegistryはSwiftパッケージをサポートします</a></li>
<li><a href="../ja459102/index.html">コーラとレディーブレックファストの愛好家のためのギフトまたは無料の音楽としてのプレート</a></li>
<li><a href="../ja459104/index.html">C＃またはJava？TypeScriptまたはJavaScript？機械学習に基づくプログラミング言語の分類</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>