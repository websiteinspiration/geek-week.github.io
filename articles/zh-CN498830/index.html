<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏽 🉑 👦🏿 哈希+缓存：流处理优化 🙋🏼 🧘🏾 📀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="如果我想在数据库中写下比其承受的容量大得多的许多“事实”，该怎么办？首先，当然，我们将数据转换为更经济的标准格式，并获得“字典”，我们将编写一次。但是如何最有效地做到这一点？
 
 这正是我们在开发监视和分析PostgreSQL服务器日志时遇到的问题，而在其他方面优化数据库记录的方法也用尽了。
 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>哈希+缓存：流处理优化</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/498830/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我想在数据库中写下比其承受的容量大得多的许多“事实”，该怎么办？首先，当然，我们将数据转换为更经济的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标准格式，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并获得“字典”，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将编写一次</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是如何最有效地做到这一点？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这正是我们在开发</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">监视和分析PostgreSQL服务器日志</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时</font><font style="vertical-align: inherit;">遇到的问题</font><font style="vertical-align: inherit;">，而在其他</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方面优化数据库记录的方法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也用尽了。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/0y/34/cp/0y34cps5t4nqozitxa0xb7urypm.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将立即</font><font style="vertical-align: inherit;">
预约我们的收集器正在运行</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此我们不会以任何方式与处理器寄存器和缓存进行交互。</font><font style="vertical-align: inherit;">使用“数百”或外部缓存服务/数据库的选项给</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数百Mbps的传入流</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带来了太多延迟</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们尝试将</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有内容都缓存在RAM中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，尤其是在JavaScript进程的内存中。</font><font style="vertical-align: inherit;">关于如何更有效地组织此活动，我们将走得更远。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可用性缓存</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的主要任务是确保任何对象的唯一实例进入数据库。这些是SQL查询的重复重复的原始文本，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现计划的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模板</font><font style="vertical-align: inherit;">，这些计划的节点—简而言之，是一些</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文本块</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
历史上，我们使用- </font></font><code>UUID</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">作为标识符</font><font style="vertical-align: inherit;">，该值是</font><font style="vertical-align: inherit;">根据对象文本</font><font style="vertical-align: inherit;">直接计算</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MD5哈希</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值而获得</font><font style="vertical-align: inherit;">的。之后，我们检查</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进程内存中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本地</font><b><font style="vertical-align: inherit;">“字典”中</font></b><font style="vertical-align: inherit;">此类哈希的可用性</font><font style="vertical-align: inherit;">，如果不存在，则仅在“字典”表中写入数据库。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也就是说，我们不需要存储原始文本值本身（有时需要花费数十个千字节），仅</font><font style="vertical-align: inherit;">在字典中</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存在相应哈希的事实</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就足够了</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关键词典</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样的字典可以保留在中</font></font><code>Array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并用于</font></font><code>Array.includes()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查可用性，但这是非常多余的-搜索（至少在V8的早期版本中）从数组大小O（N）线性下降。</font><font style="vertical-align: inherit;">在现代实现中，尽管进行了所有优化，但损失速度为2-3％。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，在ES6之前的时代，存储是传统的解决方案</font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以存储的值作为键。</font><font style="vertical-align: inherit;">但是每个人都为他想要的键分配了值-例如</font></font><code>Boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> dict = {};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">has</span>(<span class="hljs-params">key</span>) </span>{
  <span class="hljs-keyword">return</span> dict[key] !== <span class="hljs-literal">undefined</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">key</span>) </span>{<font></font>
  dict[key] = <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是很明显，我们显然将多余的存储在这里-没人需要的密钥的真正价值。但是，如果根本不存储该怎么办？于是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Set对象</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出现了</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
测试表明，在帮助下进行搜索的</font></font><code>Set.has()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速度比密钥验证c快20-25％</font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但这不是他唯一的优势。由于我们存储较少，因此</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们应该需要较少的内存</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -当涉及成千上万的此类密钥时，这将直接影响性能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，</font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在一个文本表示形式中有100个UUID密钥，它在内存中占用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6,216字节</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1e/n6/ge/1en6gefozucw86wki6odp-j3ria.png"><br>
<br>
<code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有相同的内容</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-2,632字节</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ri/59/cb/ri59cbgqbmmbqhivlopro2gspuu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也就是说，它</font></font><code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工作更快，同时占用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内存减少2.5倍</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -获胜者显而易见。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们优化了UUID密钥的存储</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，在分布式系统的性质中，UUID密钥非常常见- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在我们的VLSI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中，它们至少用于识别</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电子文档管理中的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文档和法规</font><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消息传递</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中的人员…… </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们仔细看一下上图-每个UUID是存储在十六进制表示形式中的密钥“消耗”了我们</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">56个字节的内存</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是我们有成千上万个，所以合理地问：“有可能减少吗？” </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，回想一下UUID是一个16字节的标识符。本质上是二进制数据。对于通过电子邮件进行的传输，例如，二进制数据是在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base64中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编码的</font><font style="vertical-align: inherit;">-尝试应用它：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> str = Buffer.from(uuidstr, <span class="hljs-string">'hex'</span>).toString(<span class="hljs-string">'base64'</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/pd/jc/ks/pdjckslsoycw92xnx4moahgmweg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个字节已经有48个字节更好，但并不完美。</font><font style="vertical-align: inherit;">让我们尝试将十六进制表示形式直接转换为字符串：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> str = Buffer.from(uuidstr, <span class="hljs-string">'hex'</span>).toString(<span class="hljs-string">'binary'</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/6i/nn/_5/6inn_5k8y3pnogatsv-r5ntrdzo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而不是每个密钥56个字节-40个字节，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">节省了将近30％</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主人，工人-在哪里存储词典？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑到来自工作人员的词汇数据相交很强，我们在主流程中进行了字典的存储并将其写入数据库，并通过</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IPC消息机制</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从工作人员传输了数据</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，主机上的大部分时间都花在了</font></font><code>channel.onread</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-即处理来自子进程的带有“字典”信息的数据包的接收上：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/kr/nr/sdkrnrm1c_amswktwm57kl3qsfo.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">双组写屏障</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在让我们想一想-工人向船长发送和发送相同的词汇数据（基本上是计划模板和重复的请求正文），他不厌其烦地解析它们，并且...什么也不做，因为之前它们已经被发送到数据库了！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，如果我们</font></font><code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用字典“保护”数据库以免从主数据库中重新记录数据库，为什么不使用相同的方法“保护”主数据库免于从工作人员那里转移呢？.. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，这样做可以</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">减少三倍</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为交换通道提供服务的</font><b><font style="vertical-align: inherit;">直接成本。</font></b><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y1/h4/aj/y1h4ajs-o3hdg1xfoyf9j_kflpc.png"><br>
<br>
<img src="https://habrastorage.org/webt/vl/be/na/vlbenalj_sd_2jk36xdkhaouhp8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是现在工人似乎还要做更多的工作-存​​储字典并对其进行过滤？</font><font style="vertical-align: inherit;">是不是？..实际上，由于开始大量传输（甚至通过IPC！），它们并不便宜，因此它们开始工作的时间大大减少了。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/dz/7k/mb/dz7kmbdj5jnirhajahmwrpcwzfw.png"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不错的奖金</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于该向导现在开始接收的信息量要少得多，因此开始为这些容器分配更少的内存-这意味着花费在垃圾收集器工作上的时间大大减少，这对整个系统的延迟产生了积极的影响。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fg/af/el/fgafel26_6der0h-knhglqckt8k.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种方案可以防止在收集器级别重复输入，但是如果我们有多个收集器怎么办？</font><font style="vertical-align: inherit;">只有触发器可以帮助您</font></font><code>INSERT ... ON CONFLICT DO NOTHING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加快哈希计算</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的体系结构中，来自一台PostgreSQL服务器的整个日志流由一名工作人员处理。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也就是说，一台服务器是工作人员的一项任务。同时，通过服务器任务的目的来平衡工作者的负载，从而使所有收集器的工作者所消耗的CPU大致相同。这是一个单独的服务调度程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“平均而言”，每个工人处理数十项任务，这些任务产生的总负荷大致相同。但是，有些服务器的日志条目数量大大超过了其余的服务器。即使调度员将这项任务留给了工作人员上的唯一任务，其下载量也比其他任务高得多：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/p1/9a/olp19ahpqzn4e5aaek0oyg1tjt0.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们删除了该工作程序的CPU配置文件：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2q/zk/fs/2qzkfsaqceti_tietxizjhfmioi.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在最上面几行，MD5哈希的计算。</font><font style="vertical-align: inherit;">对于整个传入对象流，它们的计算量确实很大。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xx哈希</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如何优化这部分，除了这些散列，我们不能？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们决定尝试另一个哈希函数</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxHash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">实现了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">极快的非加密哈希算法</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Node.js的模块是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxhash-addon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它使用最新版本的xxHash 0.7.3库和新的XXH3算法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过在一组不同长度的行上运行每个选项来进行检查：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> { XXHash3, XXHash64 } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'xxhash-addon'</span>);
<span class="hljs-keyword">const</span> hasher3 = <span class="hljs-keyword">new</span> XXHash3(<span class="hljs-number">0xDEADBEAF</span>);
<span class="hljs-keyword">const</span> hasher64 = <span class="hljs-keyword">new</span> XXHash64(<span class="hljs-number">0xDEADBEAF</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> getBinFromHash = <span class="hljs-function">(<span class="hljs-params">hash</span>) =&gt;</span> buf.fill(hash, <span class="hljs-string">'hex'</span>).toString(<span class="hljs-string">'binary'</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> funcs = {
  <span class="hljs-attr">xxhash64</span> : <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> hasher64.hash(Buffer.from(str)).toString(<span class="hljs-string">'binary'</span>)<font></font>
, <span class="hljs-attr">xxhash3</span>  : <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> hasher3.hash(Buffer.from(str)).toString(<span class="hljs-string">'binary'</span>)<font></font>
, <span class="hljs-attr">md5</span>      : <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> getBinFromHash(crypto.createHash(<span class="hljs-string">'md5'</span>).update(str).digest(<span class="hljs-string">'hex'</span>))<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">const</span> check = <span class="hljs-function">(<span class="hljs-params">hash</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> log = [];
  <span class="hljs-keyword">let</span> cnt = <span class="hljs-number">10000</span>;
  <span class="hljs-keyword">while</span> (cnt--) log.push(crypto.randomBytes(cnt).toString(<span class="hljs-string">'hex'</span>));<font></font>
<font></font>
  <span class="hljs-built_in">console</span>.time(hash);<font></font>
  log.forEach(funcs[hash]);<font></font>
  <span class="hljs-built_in">console</span>.timeEnd(hash);<font></font>
};<font></font>
<font></font>
<span class="hljs-built_in">Object</span>.keys(funcs).forEach(check);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果：</font></font><br>
<pre><code class="plaintext hljs">xxhash64 : 148.268ms<font></font>
xxhash3  : 108.337ms<font></font>
md5      : 317.584ms<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正如</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预期</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，xxhash3是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比MD5快很多</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仍然需要检查是否有碰撞阻力。</font><font style="vertical-align: inherit;">每天都会为我们创建词典表的各个部分，因此在一天的限制范围之外，我们可以安全地允许散列交集。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但以防万一，我们在三天的间隔内进行了一次边际检查- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有一次冲突</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比我们更适合。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈希替换</font></font></h4><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/rz/ga/3drzgasyjhevujtp-etsjcwlnz8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是我们根本无法采用旧的UUID字段并将其更改为字典表中的新哈希，因为数据库和现有前端都等待对象继续被UUID标识。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们将向收集器添加</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个缓存</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -已计算的MD5。现在将是一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中的键是xxhash3，值是MD5。对于相同的行，我们不再重述“昂贵的” MD5，而是从缓存中获取：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> getHashFromBin = <span class="hljs-function">(<span class="hljs-params">bin</span>) =&gt;</span> Buffer.from(bin, <span class="hljs-string">'binary'</span>).toString(<span class="hljs-string">'hex'</span>);
<span class="hljs-keyword">const</span> dictmd5 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
<span class="hljs-keyword">const</span> getmd5 = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> hash = xxhash(data);
  <span class="hljs-keyword">let</span> md5hash = dictmd5.get(hash);
  <span class="hljs-keyword">if</span> (!md5hash) {<font></font>
    md5hash = md5(data);<font></font>
    dictmd5.set(hash, getBinFromHash(md5hash));<font></font>
    <span class="hljs-keyword">return</span> md5hash;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> getHashFromBin(md5hash);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们删除了配置文件-计算哈希的时间比例明显减少了，干杯！</font></font><br>
<br>
<img src="https://habrastorage.org/webt/el/5q/ce/el5qcei3ahbakyyerswutw2rulk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，现在我们计算xxhash3，然后检查MD5高速缓存并获取所需的MD5，然后检查字典高速缓存-如果此md5不存在，则将其发送到数据库以进行写入。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
太多检查...如果已经检查了MD5缓存，为什么还要检查字典缓存？</font><font style="vertical-align: inherit;">事实证明，不再需要所有字典缓存，而仅拥有一个缓存就足够了-对于MD5，将执行所有基本操作：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wl/e_/uc/wle_ucs0o22wpxmrjlg_2sokzvm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，我们用一个MD5缓存替换了多个“对象”字典中的检查，并且计算MD5的资源密集型操作是哈希仅对新条目执行，对传入流使用效率更高的xxhash。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
谢谢</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基洛</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在撰写本文时寻求帮助。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN498816/index.html">首先是事实，还是为什么需要基于数据库设备来设计系统</a></li>
<li><a href="../zh-CN498820/index.html">有关.NET和C＃的一些更棘手的问题</a></li>
<li><a href="../zh-CN498822/index.html">从零开始为四个玩家开发和创建街机</a></li>
<li><a href="../zh-CN498826/index.html">SIL和Salesforce</a></li>
<li><a href="../zh-CN498828/index.html">食盐和蛋白质如何增加植入物的存活率</a></li>
<li><a href="../zh-CN498832/index.html">Qt Creator 4.12和QBS 1.16用于微控制器编程的可能性概述</a></li>
<li><a href="../zh-CN498834/index.html">一周有33项在线mitaps。选择一个还是有时间做所有事情？</a></li>
<li><a href="../zh-CN498836/index.html">[信息图形]收入超过十亿美元的前50个游戏特许经营权</a></li>
<li><a href="../zh-CN498840/index.html">机器人通过电报监视和控制计算机</a></li>
<li><a href="../zh-CN498842/index.html">评论的中庸：但是，我们可以信任用户吗？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>