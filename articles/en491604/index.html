<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüëß‚Äçüëß ü¶ã ü§öüèø Native FPGA soft-processor with high-level language compiler or Song of the Mouse üë©üèæ‚Äçü§ù‚Äçüë®üèø üìî üõèÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Own FPGA soft-processor with high-level language compiler or Song of the Mouse - experience in adapting a high-level language compiler to the stack pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Native FPGA soft-processor with high-level language compiler or Song of the Mouse</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491604/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Own FPGA soft-processor with high-level language compiler or Song of the Mouse - experience in adapting a high-level language compiler to the stack processor core. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A common problem for software processors is the lack of development tools for them, especially if their instruction system is not a subset of the instructions of one of their popular processor cores. Developers in this case will have to solve this problem. Its direct solution is to create an assembler language compiler. However, in modern realities it is not always convenient to work in Assembler, since in the process of development of the project the command system may change due to, for example, changing requirements. Therefore, the task of easy implementation of a high-level language compiler (JAV) for a software processor is relevant.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python compiler - Uzh seems to be an easy and convenient toolkit for developing software for software processors. The toolkit for defining primitives and macros as functions of the target language allows critical places to be implemented in assembler processor. This paper discusses the main points of compiler adaptation for stack architecture processors.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Instead of an epigraph: </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you take an adult mouse </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
and, carefully holding it, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cram the needles into it </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
you will get a hedgehog. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If this hedgehog, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nose plugged, so as not to breathe, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Where deeper, throw into the river </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You will get a ruff. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If this ruff, </font><font style="vertical-align: inherit;">
Holding your </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
head in a vice, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pull harder by the tail </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You will get a snake. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If this already, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having prepared two knives ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, he will probably die, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But the idea is good!</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introduction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 In many cases, when implementing measuring instruments, research equipment, it is preferable to use reconfigurable FPGA / FPGA solutions as the main core of the system. This approach has many advantages, due to the ability to easily and quickly make changes to the logic of work, as well as due to hardware acceleration of data processing and control signals.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a wide range of tasks, such as digital signal processing, embedded control systems, data acquisition and analysis systems, the approach has proven itself, consisting in combining in one solution blocks implemented by FPGA logic for critical processes and program control elements based on one or several software processors for general management and coordination, as well as for implementing interaction with the user or external devices / nodes. </font><font style="vertical-align: inherit;">The use of software processors in this case allows us to slightly reduce the time spent on debugging and verification of system control algorithms or interaction algorithms of individual nodes.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typical Wishlist</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Often, soft processors in this case do not require ultra-high performance (since it is easier to achieve, I use the FPGA logical and hardware resources). </font><font style="vertical-align: inherit;">They can be quite simple (and from the point of view of modern microcontrollers - almost primitive), because </font><font style="vertical-align: inherit;">they can do without a complex interrupt system, work only with certain nodes or interfaces, there is no need to support a particular command system. </font><font style="vertical-align: inherit;">There can be many of them, while each of them can execute only a certain set of algorithms or subprograms. </font><font style="vertical-align: inherit;">The capacity of soft processors can also be any, including not a multiple of a byte - depending on the requirements of the current task. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typical targets for soft processors are:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sufficient functionality of the command system, possibly optimized for the task;</font></font></li>
<li>   , ..      ;</li>
<li> ‚Äì   ,        .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Of course, a problem for software processors is the lack of development tools for them, especially if their instruction system is not a subset of the instructions of one of their popular processor cores. </font><font style="vertical-align: inherit;">Developers in this case will have to solve this problem. </font><font style="vertical-align: inherit;">Its direct solution is to create an assembler language compiler for the software processor. </font><font style="vertical-align: inherit;">However, in modern realities it is not always convenient to work in Assembler, especially if the team system changes during the development of the project due to, for example, changing requirements. </font><font style="vertical-align: inherit;">Therefore, it is logical to add to the above requirements the requirement of easy implementation of a high-level language compiler (HLV) for the soft processor.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source components</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Stack processors satisfy these requirements with a high percentage of compliance, as </font><font style="vertical-align: inherit;">there is no need to address registers, the bit depth of the command may be small.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The bit depth of the data for them can vary and is not tied to the bit depth of the command system. </font><font style="vertical-align: inherit;">Being a de facto (albeit with a few caveats) hardware implementation of the intermediate representation of the program code during compilation (a virtual stacked machine, or in terms of context-free grammars - a store automaton), it is possible with low labor costs to translate the grammar of any language into executable code. </font><font style="vertical-align: inherit;">In addition, for stack processors, the Fort language is practically the ‚Äúnative‚Äù language. </font><font style="vertical-align: inherit;">The labor costs of implementing a Fort compiler for a stack processor are comparable to those of Assembler, with much greater flexibility and efficiency in the implementation of programs in the future.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Having the task of constructing a system for collecting data from smart sensors in a mode close to real-time, the Fort processor was selected as the reference solution (the so-called Reference Design) of the soft processor, described in [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] (hereinafter it will be sometimes referred to as a whiteTiger processor by its author‚Äôs nickname). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Its main features:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separate data and return stacks</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harvard memory organization architecture (separate program and data memory, including address space);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expansion with peripherals using a simple parallel bus.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The processor does not use a pipeline, the execution of commands is push-pull:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fetch commands and operands;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> execution of the command and saving the result.</font></font></li>
</ol></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 The processor is supplemented by a UART-loader of program code, which allows you to change the executable program without recompiling the project for FPGAs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With regard to the configuration of block memory in the FPGA, the capacity of the instructions is set to 9 bits. The bit depth of the data is set to 32 bits, but can be basically any. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The processor code is written in VHDL without the use of any specific libraries, which allows you to work with this project on FPGAs from any manufacturer.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a relatively widespread use, lowering the "input threshold", as well as for reusing code and applying code developments, it is more expedient to switch to a Java engine other than Fort (this is partly due to the superstitions and misconceptions of mine-stream programmers regarding the complexities of this language and the readability of its code (by the way, one of the authors of this work has a similar opinion about C-like languages)). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Based on a number of factors, the Python language (Python) was chosen for the experiment to ‚Äúbind‚Äù the software processor and the Java Language Engine. This is a high-level general-purpose programming language focused on improving developer productivity and code readability, supporting several programming paradigms, including structural, object-oriented, functional, imperative and aspect-oriented [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For novice developers, its extension MyHDL [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] is </font><font style="vertical-align: inherit;">interesting </font><font style="vertical-align: inherit;">, which allows describing hardware elements and structures in Python and translating them into VHDL or Verilog code. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Some time ago, the Uzh compiler [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">was announced </font><font style="vertical-align: inherit;">- a small compiler for the Zmey FPGA software processor (32-bit stack architecture with multithreading support - if you follow the chain of versions / modifications / verification - Zmey is a distant descendant of the whiteTiger processor). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uzh is also a statically compiled subset of Python, based on the promising raddsl toolkit (a set of tools for quickly creating prototypes of DSL compilers) [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ].</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, the factors that influenced the choice of the direction of work can be formulated approximately like this:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interest in tools that lower the "entry threshold" for novice developers of devices and systems on FPGAs (syntactically Python is not as "scary" for a beginner as VHDL);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> striving for harmony and a single style in the project (it is theoretically possible to describe the required hardware blocks and software of the software processor in Python);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> random coincidence.</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Small, ‚Äúalmost‚Äù meaningless nuances</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 The source code of the Zmey processor is not open, but a description of the principles of its operation and some architecture features is available. </font><font style="vertical-align: inherit;">Although it is also stackable, there are a number of key differences from the whiteTiger processor:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stacks are software - i.e. </font><font style="vertical-align: inherit;">represented by pointers and placed in the data memory at different addresses;</font></font></li>
<li>     ,      - ;</li>
<li>          ;</li>
<li>  ,         .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Accordingly, the Uzh compiler takes these features into account. The compiler accepts Python code and generates a boot stream at the output to initiate program memory and processor data memory, the key point is that all the language functionality is available at the compilation stage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To install the Uzh compiler, just download its archive and unzip it to any convenient folder (it is better to adhere to the general recommendations for specialized software - to avoid paths containing Cyrillic and spaces). You also need to download and unzip the raddsl toolkit to the compiler‚Äôs main folder.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The compiler test folder contains examples of programs for the soft processor; the src folder contains the source texts of the compiler elements. </font><font style="vertical-align: inherit;">For convenience, it is better to create a small batch file (extension .cmd) with the contents:, </font></font><b><code>c.py C:\D\My_Docs\Documents\uzh-master\tests\abc.py</code> </b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where abc.py is the name of the file with the program for the soft processor.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A snake biting its tail or lapping iron and software</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 To adapt Uzh to the whiteTiger processor, some changes will be required, as well as the processor itself will have to be slightly corrected. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortunately, there are not many places to be adjusted in the compiler. </font><font style="vertical-align: inherit;">The main "hardware-dependent" files:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asm.py - assembler and the formation of numbers (literals);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gen.py - low-level code generation rules (functions, variables, transitions and conditions);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream.py - forming a boot stream;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">macro.py - macro definitions, in fact - extensions of the base language with hardware-specific functions.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 In the original whiteTiger processor design, the UART loader only initializes program memory. </font><font style="vertical-align: inherit;">The bootloader algorithm is simple, but well-established and reliable:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> upon receiving a certain control byte, the loader sets the active level on the internal line of the processor reset;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the second byte command resets the memory address counter;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the following is a sequence of notebooks of the transmitted word, starting with the youngest, combined with a notebook-number;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> after each byte with a packed notebook, a pair of control bytes follows, the first of which sets the active level on the memory write permission line, the second resets it;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">upon completion of the sequence of packed notebooks, the active level on the reset line is removed by the control byte. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Since the compiler also uses data memory, it is necessary to modify the loader so that it can also initialize the data memory. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the data memory is involved in the logic of the processor core, it is necessary to multiplex its data and control lines. </font><font style="vertical-align: inherit;">For this, additional signals DataDinBtemp, LoaderAddrB, DataWeBtemp are introduced - data, address and recording resolution for the port In memory. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 The bootloader code now looks like this:</font></font><br>
<br>
<pre><code class="vhdl hljs">uart_unit: <span class="hljs-keyword">entity</span> work.uart
<span class="hljs-comment">--uart_unit: entity uart</span>
  <span class="hljs-keyword">Generic</span> <span class="hljs-keyword">map</span>(<font></font>
    ClkFreq =&gt; <span class="hljs-number">50_000_000</span>,<font></font>
    Baudrate =&gt; <span class="hljs-number">115200</span>)
  <span class="hljs-keyword">port</span> <span class="hljs-keyword">map</span>(<font></font>
    clk =&gt; clk,<font></font>
    rxd =&gt; rx,<font></font>
    txd =&gt; tx,<font></font>
    dout =&gt; receivedByte,<font></font>
    received =&gt; received,<font></font>
    din =&gt; transmitByte,<font></font>
    transmit =&gt; transmit);<font></font>
    <font></font>
<span class="hljs-keyword">process</span>(clk)
<span class="hljs-keyword">begin</span>
  <span class="hljs-keyword">if</span> rising_edge(clk) <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">if</span> received = <span class="hljs-string">'1'</span> <span class="hljs-keyword">then</span>
      <span class="hljs-keyword">case</span> conv_integer(receivedByte) <span class="hljs-keyword">is</span>
      <span class="hljs-comment">-- 0-F   - 0-3 bits</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> <span class="hljs-number">15</span> =&gt; CodeDinA(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<font></font>
		                  DataDinBtemp(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
      <span class="hljs-comment">-- 10-1F -4-7bits</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">16</span> <span class="hljs-keyword">to</span> <span class="hljs-number">31</span> =&gt; CodeDinA(<span class="hljs-number">7</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">4</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<font></font>
		                   DataDinBtemp(<span class="hljs-number">7</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">4</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>); 
      <span class="hljs-comment">-- 20-2F -8bit </span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">32</span> <span class="hljs-keyword">to</span> <span class="hljs-number">47</span> =&gt; CodeDinA(<span class="hljs-number">8</span>) &lt;= receivedByte(<span class="hljs-number">0</span>);<font></font>
	                   DataDinBtemp(<span class="hljs-number">11</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">8</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
	  <span class="hljs-keyword">when</span> <span class="hljs-number">48</span> <span class="hljs-keyword">to</span> <span class="hljs-number">63</span> =&gt; DataDinBtemp(<span class="hljs-number">15</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">12</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
	  <span class="hljs-keyword">when</span> <span class="hljs-number">64</span> <span class="hljs-keyword">to</span> <span class="hljs-number">79</span> =&gt; DataDinBtemp(<span class="hljs-number">19</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">16</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
	  <span class="hljs-keyword">when</span> <span class="hljs-number">80</span> <span class="hljs-keyword">to</span> <span class="hljs-number">95</span> =&gt; DataDinBtemp(<span class="hljs-number">23</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">20</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
	  <span class="hljs-keyword">when</span> <span class="hljs-number">96</span> <span class="hljs-keyword">to</span> <span class="hljs-number">111</span> =&gt; DataDinBtemp(<span class="hljs-number">27</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">24</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
        <span class="hljs-keyword">when</span> <span class="hljs-number">112</span> <span class="hljs-keyword">to</span> <span class="hljs-number">127</span> =&gt; DataDinBtemp(<span class="hljs-number">31</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">28</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<font></font>
<font></font>
      <span class="hljs-comment">-- F0 addr=0</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">240</span> =&gt; CodeAddrA &lt;= (<span class="hljs-keyword">others</span> =&gt; <span class="hljs-string">'0'</span>);
      <span class="hljs-comment">-- F1 - WE=1</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">241</span> =&gt; CodeWeA &lt;= <span class="hljs-string">'1'</span>;
      <span class="hljs-comment">-- F2 WE=0 addr++</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">242</span> =&gt; CodeWeA &lt;= <span class="hljs-string">'0'</span>; CodeAddrA &lt;= CodeAddrA + <span class="hljs-number">1</span>;
      <span class="hljs-comment">-- F3 RESET=1</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">243</span> =&gt; int_reset &lt;= <span class="hljs-string">'1'</span>;
      <span class="hljs-comment">-- F4 RESET=0</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">244</span> =&gt; int_reset &lt;= <span class="hljs-string">'0'</span>;<font></font>
<font></font>
      <span class="hljs-comment">-- F5 addr=0</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">245</span> =&gt; LoaderAddrB &lt;= (<span class="hljs-keyword">others</span> =&gt; <span class="hljs-string">'0'</span>);
      <span class="hljs-comment">-- F6 - WE=1</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">246</span> =&gt; DataWeBtemp &lt;= <span class="hljs-string">'1'</span>;
      <span class="hljs-comment">-- F7 WE=0 addr++</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">247</span> =&gt; DataWeBtemp &lt;= <span class="hljs-string">'0'</span>; LoaderAddrB &lt;= LoaderAddrB + <span class="hljs-number">1</span>;<font></font>
		  <font></font>
		  <font></font>
        <span class="hljs-keyword">when</span> <span class="hljs-keyword">others</span> =&gt; <span class="hljs-keyword">null</span>;
      <span class="hljs-keyword">end</span> <span class="hljs-keyword">case</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;
  <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;
<span class="hljs-keyword">end</span> <span class="hljs-keyword">process</span>;<font></font>
<font></font>
<span class="hljs-comment">---- end of loader</span><font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With an active reset level, the DataDinBtemp, LoaderAddrB, DataWeBtemp signals are connected to the corresponding data memory ports.</font></font><br>
<br>
<pre><code class="vhdl hljs">‚Ä¶
    <span class="hljs-keyword">if</span> reset = <span class="hljs-string">'1'</span> <span class="hljs-keyword">or</span> int_reset = <span class="hljs-string">'1'</span> <span class="hljs-keyword">then</span>
      DSAddrA &lt;= (<span class="hljs-keyword">others</span> =&gt; <span class="hljs-string">'0'</span>);      <font></font>
      <font></font>
      RSAddrA &lt;= (<span class="hljs-keyword">others</span> =&gt; <span class="hljs-string">'0'</span>);<font></font>
      RSAddrB &lt;= (<span class="hljs-keyword">others</span> =&gt; <span class="hljs-string">'0'</span>);<font></font>
      RSWeA &lt;= <span class="hljs-string">'0'</span>;<font></font>
      <font></font>
      DataAddrB &lt;= LoaderAddrB;<font></font>
		DataDinB&lt;=DataDinBtemp;<font></font>
		DataWeB&lt;=DataWeBtemp;<font></font>
      DataWeA &lt;= <span class="hljs-string">'0'</span>;<font></font>
‚Ä¶<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In accordance with the bootloader algorithm, it is necessary to modify the stream.py module. Now it has two functions. The first function - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_val ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - splits the input word into the desired number of tetrads. So, for 9-bit instructions of the whiteTiger processor, they will be transformed into groups of three tetrads, and 32-bit data in a sequence of eight tetrads. The second function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> forms the bootstrap directly. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The final form of the stream module:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_val</span>(<span class="hljs-params">x, by_4</span>):</span><font></font>
  r = []<font></font>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(by_4):<font></font>
    r.append((x &amp; <span class="hljs-number">0xf</span>) | (i &lt;&lt; <span class="hljs-number">4</span>))<font></font>
    x &gt;&gt;= <span class="hljs-number">4</span>
  <span class="hljs-keyword">return</span> r<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make</span>(<span class="hljs-params">code, data, core=<span class="hljs-number">0</span></span>):</span>
  <span class="hljs-comment">#        0  </span>
  stream = [<span class="hljs-number">243</span>,<span class="hljs-number">245</span>] 
  <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data:
    <span class="hljs-comment">#    32- </span>
    <span class="hljs-comment">#         </span>
    stream += get_val(x, <span class="hljs-number">8</span>) + [<span class="hljs-number">246</span>, <span class="hljs-number">247</span>]
  <span class="hljs-comment">#       0</span>
  stream += [<span class="hljs-number">240</span>]
  <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> code:
    <span class="hljs-comment">#    9-  </span>
    <span class="hljs-comment">#         </span>
    stream += get_val(x, <span class="hljs-number">3</span>) + [<span class="hljs-number">241</span>, <span class="hljs-number">242</span>]
  <span class="hljs-comment">#  </span>
  stream.append(<span class="hljs-number">244</span>)<font></font>
<font></font>
  <span class="hljs-keyword">return</span> bytearray(stream)<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 The following changes in the compiler will affect the asm.py module, which describes the processor command system (command mnemonics and command opcodes are written) and the way of representing / compiling numerical values ‚Äã‚Äã- literals. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commands are packed into a dictionary, and the lite () function is responsible for literals. If everything is simple with the command system - the list of mnemonics and the corresponding opcodes just changes, then the situation with literals is a little different. The Zmey processor has 8-bit instructions and there are a number of specialized instructions for working with literals. In whiteTiger, the 9th bit indicates whether the opcode is a command or part of a number.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the highest (9th) bit of a word is 1, then the opcode is interpreted as a number - for example, four consecutive opcodes with a sign of a number form a 32-bit number as a result. </font><font style="vertical-align: inherit;">A sign of the end of a number is the presence of the command opcode - for definiteness and ensuring uniformity, the end of the number determination is the opcode of the NOP command (‚Äúno operations‚Äù). </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, the modified lit () function looks like this:</font></font><br>
<br>
<pre><code class="python hljs">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lit</span>(<span class="hljs-params">x</span>):</span>
  x &amp;= <span class="hljs-number">0xffffffff</span><font></font>
  r = [] <font></font>
  <span class="hljs-keyword">if</span> (x&gt;&gt;<span class="hljs-number">24</span>) &amp; <span class="hljs-number">255</span> :<font></font>
    r.append(int((x&gt;&gt;<span class="hljs-number">24</span>) &amp; <span class="hljs-number">255</span>) | <span class="hljs-number">256</span>)
  <span class="hljs-keyword">if</span> (x&gt;&gt;<span class="hljs-number">16</span>) &amp; <span class="hljs-number">255</span>:<font></font>
    r.append(int((x&gt;&gt;<span class="hljs-number">16</span>) &amp; <span class="hljs-number">255</span>) | <span class="hljs-number">256</span>)
  <span class="hljs-keyword">if</span> (x&gt;&gt;<span class="hljs-number">8</span>) &amp; <span class="hljs-number">255</span>:<font></font>
    r.append(int((x&gt;&gt;<span class="hljs-number">8</span>) &amp; <span class="hljs-number">255</span>) | <span class="hljs-number">256</span>)<font></font>
  r.append(int(x &amp; <span class="hljs-number">255</span>) | <span class="hljs-number">256</span>)<font></font>
  r += asm(<span class="hljs-string">"NOP"</span>)
  <span class="hljs-keyword">return</span> list(r)<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main and most important changes / definitions are in the gen.py module. </font><font style="vertical-align: inherit;">This module defines the basic logic of the work / execution of high-level code at the assembler level:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conditional and unconditional jumps;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calling functions and passing arguments to them;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">return from functions and returning results;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adjustments to the sizes of program memory, data memory and stacks;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sequence of actions at startup of the processor.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 In order to support Java, the processor must be able to work arbitrarily with memory and pointers and have a memory area for storing local variable functions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the Zmey processor, a return stack is used to work with local variables and function arguments - function arguments are transferred to it and during further work, they are accessed through the pointer-register of the return stack (read, modify up / down, read at the pointer address). Since the stack is physically located in the data memory, such operations essentially simply come down to memory operations, and global variables are located within the same memory.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In whiteTiger, return and data stacks are dedicated hardware stacks with their address space and do not have stack pointer instructions. Consequently, operations with passing arguments to functions and work with local variables will need to be organized through data memory. It does not make much sense to increase the volume of data stacks and returns for possible storage of relatively large data arrays in them; it is more logical to have a slightly large data memory. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 To work with local variables, a dedicated LocalReg register was added, the task of which is to store a pointer to the memory area allocated for local variables (a kind of heap). Also added operations for working with it (cpu.vhd file - command definition area):</font></font><br>
<br>
<pre><code class="vhdl hljs">
          <span class="hljs-comment">-- group 1; pop 0; push 1;</span>
          <span class="hljs-keyword">when</span> cmdLOCAL =&gt; DSDinA &lt;= LocalReg;
			 <span class="hljs-keyword">when</span> cmdLOCALadd =&gt; DSDinA &lt;= LocalReg; LocalReg &lt;= LocalReg+<span class="hljs-number">1</span>;
			 <span class="hljs-keyword">when</span> cmdLOCALsubb =&gt; DSDinA &lt;= LocalReg; LocalReg &lt;= LocalReg-<span class="hljs-number">1</span>;<font></font>
‚Ä¶<font></font>
          <span class="hljs-comment">-- group 2; pop 1; push 0;</span>
          <span class="hljs-keyword">when</span> cmdSETLOCAL =&gt; LocalReg &lt;= DSDinA;<font></font>
‚Ä¶<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LOCAL - returns to the data stack the current value of the LocalReg pointer; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SETLOCAL - sets the new pointer value received from the data stack; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LOCALadd - leaves the current value of the pointer on the data stack and increments it by 1; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LOCALsubb - leaves the current value of the pointer on the data stack and decreases it by 1. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LOCALadd and LOCALsubb are added to reduce the number of ticks during operations of passing function parameters and vice versa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unlike the original whiteTiger, the data memory connections were slightly changed - now the In memory port is constantly addressed by the output of the first cell of the data stack, the output of the second cell of the data stack is fed to its input:</font></font><br>
<br>
<pre><code class="vhdl hljs"><span class="hljs-comment">-- ++</span>
DataAddrB &lt;= DSDoutA(DataAddrB<span class="hljs-symbol">'range</span>);<font></font>
DataDinB &lt;= DSDoutB;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 The logic for executing the STORE and FETCH commands was also slightly corrected - FETCH takes the output value of the port In memory to the top of the data stack, and STORE simply controls the write enable signal for port B:</font></font><br>
<br>
<pre><code class="vhdl hljs">‚Ä¶
          <span class="hljs-comment">-- group 3; pop 1; push 1;</span>
          <span class="hljs-keyword">when</span> cmdFETCH =&gt; DSDinA &lt;= DataDoutB;<font></font>
‚Ä¶<font></font>
          <span class="hljs-keyword">when</span> cmdSTORE =&gt;            <font></font>
            DataWeB &lt;= <span class="hljs-string">'1'</span>;<font></font>
‚Ä¶<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As part of the training, as well as for some hardware support for loops at a low level (and at the compiler level of the Fort language), a stack of loop counters was added to the whiteTiger core (actions are similar to those when declaring data and return stacks):</font></font><br>
<br>
<pre><code class="vhdl hljs">‚Ä¶
<span class="hljs-comment">--  </span>
<span class="hljs-keyword">type</span> TCycleStack <span class="hljs-keyword">is</span> <span class="hljs-keyword">array</span>(<span class="hljs-number">0</span> <span class="hljs-keyword">to</span> LocalSize-<span class="hljs-number">1</span>) <span class="hljs-keyword">of</span> DataSignal;
<span class="hljs-keyword">signal</span> CycleStack: TCycleStack;
<span class="hljs-keyword">signal</span> CSAddrA, CSAddrB: StackAddrSignal;
<span class="hljs-keyword">signal</span> CSDoutA, CSDoutB: DataSignal;
<span class="hljs-keyword">signal</span> CSDinA, CSDinB: DataSignal;
<span class="hljs-keyword">signal</span> CSWeA, CSWeB: <span class="hljs-built_in">std_logic</span>;<font></font>
‚Ä¶<font></font>
<span class="hljs-comment">--  </span>
<span class="hljs-keyword">process</span>(clk)
<span class="hljs-keyword">begin</span>
  <span class="hljs-keyword">if</span> rising_edge(clk) <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">if</span> CSWeA = <span class="hljs-string">'1'</span> <span class="hljs-keyword">then</span><font></font>
      CycleStack(conv_integer(CSAddrA)) &lt;= CSDinA;<font></font>
      CSDoutA &lt;= CSDinA;<font></font>
    <span class="hljs-keyword">else</span><font></font>
      CSDoutA &lt;= CycleStack(conv_integer(CSAddrA));<font></font>
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;
  <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;
<span class="hljs-keyword">end</span> <span class="hljs-keyword">process</span>;<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cycle counter commands have been added. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DO - moves the number of iterations of the cycle from the data stack to the counter stack and places the incremented value of the instruction counter on the return stack. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LOOP - checks the counter zeroing, if not reached, the top element of the counter stack is decremented, the transition to the address at the top of the return stack is performed. If the top of the counter stack is zero, the top element is reset, the return address to the beginning of the cycle from the top of the return stack is also reset.</font></font><br>
<br>
<pre><code class="vhdl hljs">
	<span class="hljs-keyword">when</span> cmdDO =&gt; <span class="hljs-comment">-- DO - </span>
               RSAddrA &lt;= RSAddrA + <span class="hljs-number">1</span>; <span class="hljs-comment">-- </span>
               RSDinA &lt;= ip + <span class="hljs-number">1</span>;<font></font>
               RSWeA &lt;= <span class="hljs-string">'1'</span>;<font></font>
				<font></font>
               CSAddrA &lt;= CSAddrA + <span class="hljs-number">1</span>; <span class="hljs-comment">--</span><font></font>
         		CSDinA &lt;= DSDoutA;<font></font>
 		         CSWeA &lt;= <span class="hljs-string">'1'</span>;<font></font>
		         DSAddrA &lt;= DSAddrA - <span class="hljs-number">1</span>; <span class="hljs-comment">--</span>
		         ip &lt;= ip + <span class="hljs-number">1</span>;	<span class="hljs-comment">-- </span><font></font>
<font></font>
      <span class="hljs-keyword">when</span> cmdLOOP =&gt; <span class="hljs-comment">--            </span>
           <span class="hljs-keyword">if</span> conv_integer(CSDoutA) = <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
	          ip &lt;= ip + <span class="hljs-number">1</span>;	<span class="hljs-comment">-- </span>
		         RSAddrA &lt;= RSAddrA - <span class="hljs-number">1</span>; <span class="hljs-comment">-- </span>
		         CSAddrA &lt;= CSAddrA - <span class="hljs-number">1</span>; <span class="hljs-comment">-- </span>
            <span class="hljs-keyword">else</span>
		         CSDinA &lt;= CSDoutA - <span class="hljs-number">1</span>;<font></font>
		         CSWeA &lt;= <span class="hljs-string">'1'</span>;<font></font>
		         ip &lt;= RSDoutA(ip<span class="hljs-symbol">'range</span>);
            <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;<font></font>
			 <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now you can start modifying the code for the gen.py module. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
* _SIZE variables do not need comments and require only the substitution of values ‚Äã‚Äãspecified in the processor core project. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The STUB list is a temporary stub for creating a place for transition addresses and then filling them with the compiler (current values ‚Äã‚Äãcorrespond to the 24-bit address space of the code memory). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
STARTUP list - sets the sequence of actions performed by the kernel after a reset - in this case, the starting address of the memory of local variables is set to 900, and the transition to the start point (if you do not change anything, the start / entry point in the application is written to the compiler in the data memory address 2):</font></font><br>
<br>
<pre><code class="python hljs">STARTUP = asm(<span class="hljs-string">"""
900  SETLOCAL
2 NOP FETCH JMP
"""</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The definition of func () prescribes the actions that are performed when the function is called, namely, the transfer of function arguments to the region of local variables, memory allocation for its own local variables of the function.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">@act</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">t, X</span>):</span><font></font>
  t.c.entry = t.c.globs[X]<font></font>
  t.c.entry[<span class="hljs-string">"offs"</span>] = len(t.c.code) <span class="hljs-comment"># - 1</span>
  args = t.c.entry[<span class="hljs-string">"args"</span>]<font></font>
  temps_size = len(t.c.entry[<span class="hljs-string">"locs"</span>]) - args
<span class="hljs-comment">#      </span>
  t.out = asm(<span class="hljs-string">"LOCALadd STORE "</span> * args)
  <span class="hljs-keyword">if</span> temps_size:
<span class="hljs-comment">#      </span>
    t.out += asm(<span class="hljs-string">"LOCAL %d PLUS SETLOCAL"</span> % temps_size)
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Epilog () defines actions when returning from a function - freeing the memory of temporary variables, returning to the call point.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">epilog</span>(<span class="hljs-params">t, X</span>):</span>
  locs_size = len(t.c.entry[<span class="hljs-string">"locs"</span>])
<span class="hljs-comment">#    </span>
  t.out = asm(<span class="hljs-string">"RET"</span>)
  <span class="hljs-keyword">if</span> locs_size:
<span class="hljs-comment">#    ()  </span>
    t.out = asm(<span class="hljs-string">"LOCAL %d MINUS SETLOCAL"</span> % locs_size) + t.out
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Working with variables is done through their addresses, the key definition for this is push_local (), which leaves the address of the "high-level" variable on the data stack.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push_local</span>(<span class="hljs-params">t, X</span>):</span>
<span class="hljs-comment">#          </span>
<span class="hljs-comment">#  </span>
  t.out = asm(<span class="hljs-string">"LOCAL %d MINUS"</span> % get_loc_offset(t, X))
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following key points are conditional and unconditional transitions. </font><font style="vertical-align: inherit;">The conditional jump in the whiteTiger processor checks the second element of the data stack for 0 and jumps to the address at the top of the stack if the condition is met. </font><font style="vertical-align: inherit;">An unconditional jump simply sets the value of the instruction counter to the value at the top of the stack.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">@act</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">goto_if_0</span>(<span class="hljs-params">t, X</span>):</span><font></font>
  push_label(t, X)<font></font>
  t.out += asm(<span class="hljs-string">"IF"</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><font></font>
<font></font>
<span class="hljs-meta">@act</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">goto</span>(<span class="hljs-params">t, X</span>):</span><font></font>
  push_label(t, X)<font></font>
  t.out += asm(<span class="hljs-string">"JMP"</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following two definitions specify bit shifting operations - just at a low level, loops are applied (it will give some gain in the size of the code - in the original, the compiler simply puts the required number of elementary shift operations in a row.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">@act</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shl_const</span>(<span class="hljs-params">t, X</span>):</span>
  t.out = asm(<span class="hljs-string">"%d DO SHL LOOP"</span> %(X<span class="hljs-number">-1</span>))
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><font></font>
<font></font>
<span class="hljs-meta">@act</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shr_const</span>(<span class="hljs-params">t, X</span>):</span>
  t.out = asm(<span class="hljs-string">"%d DO SHR LOOP"</span> %(X<span class="hljs-number">-1</span>))
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And the main definition of the compiler at a low level is a set of rules for language operations and working with memory:</font></font><br>
<br>
<pre><code class="python hljs">stmt = rule(alt(<font></font>
  seq(Push(Int(X)), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"%d"</span> % v.X))),<font></font>
  seq(Push(Local(X)), push_local),<font></font>
  seq(Push(Global(X)), push_global),<font></font>
  seq(Load(), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"NOP FETCH"</span>))),<font></font>
  seq(Store(), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"STORE"</span>))),<font></font>
  seq(Call(), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"CALL"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"+"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"PLUS"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"-"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"MINUS"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"&amp;"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"AND"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"|"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"OR"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"^"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"XOR"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"*"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"MUL"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"&lt;"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"LESS"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"&gt;"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"GREATER"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"=="</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"EQUAL"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"~"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"NOT"</span>))),<font></font>
  seq(ShlConst(X), shl_const),<font></font>
  seq(ShrConst(X), shr_const),<font></font>
  seq(Func(X), func),<font></font>
  seq(Label(X), label),<font></font>
  seq(Return(X), epilog),<font></font>
  seq(GotoIf0(X), goto_if_0),<font></font>
  seq(Goto(X), goto),<font></font>
  seq(Nop(), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"NOP"</span>))),<font></font>
  seq(Asm(X), to(<span class="hljs-keyword">lambda</span> v: asm(v.X)))<font></font>
))<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The macro.py module allows you to ‚Äúexpand‚Äù the dictionary of the target language somewhat using macro definitions in the assembler of the target processor. </font><font style="vertical-align: inherit;">For the Java Compiler, the definitions in macro.py will not differ from the "native" operators and functions of the language. </font><font style="vertical-align: inherit;">So, for example, in the original compiler, I / O functions of the value in the external port were defined. </font><font style="vertical-align: inherit;">Test sequences of operations with memory and local variables and a time delay operation were added.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">@macro(1,0)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">testasm</span>(<span class="hljs-params">c,x</span>):</span>
  <span class="hljs-keyword">return</span> Asm(<span class="hljs-string">"1 1 OUTPORT 0 1 OUTPORT 11 10 STORE 10 FETCH 1 OUTPORT  15 100 STORE 100  FETCH 1 OUTPORT"</span>)<font></font>
<font></font>
<span class="hljs-meta">@macro(1,0)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">testlocal</span>(<span class="hljs-params">c,x</span>):</span>
   <span class="hljs-keyword">return</span> Asm(<span class="hljs-string">"1 100 STORE 2 101 STORE 100 SETLOCAL LOCAL NOP FETCH 1 OUTPORT LOCAL 1 PLUS NOP FETCH 1 OUTPORT"</span>)<font></font>
<font></font>
<span class="hljs-meta">@prim(1, 0)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delay</span>(<span class="hljs-params">c, val</span>):</span>
  <span class="hljs-keyword">return</span> [val, Asm(<span class="hljs-string">"DO LOOP"</span>)]<font></font>
<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testing </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 A small test high-level program for our processor contains the definition of a function for calculating factorial, and the main function that implements serial output of factorial values ‚Äã‚Äãfrom 1 to 7 to the port in an infinite loop.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fact</span>(<span class="hljs-params">n</span>):</span>
  r = <span class="hljs-number">1</span>
  <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">1</span>:<font></font>
    r *= n<font></font>
    n -= <span class="hljs-number">1</span>
  <span class="hljs-keyword">return</span> r<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
  n=<span class="hljs-number">1</span>
  <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
     digital_write(<span class="hljs-number">1</span>, fact(n))<font></font>
     delay(<span class="hljs-number">10</span>)<font></font>
     n=(n+<span class="hljs-number">1</span>)&amp;<span class="hljs-number">0x7</span><font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It can be </font><font style="vertical-align: inherit;">
launched </font><font style="vertical-align: inherit;">for compilation, for example, by a simple script or from the command line by the sequence: </font><font style="vertical-align: inherit;">As a result, a boot file stream.bin will be generated, which can be transferred to the processor core in the FPGA via the serial port (in modern realities, through any virtual serial port that converters provide USB-UART interfaces). </font><font style="vertical-align: inherit;">The program as a result occupies 146 words (9-bit) of program memory and 3 in data memory.</font></font><br>
<code>c.py C:\D\My_Docs\Documents\uzh-master\tests\fact2.py<br>
</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 In general, the Uzh compiler seems to be an easy and convenient toolkit for developing software for software processors. </font><font style="vertical-align: inherit;">It is a great alternative to assembler, at least in terms of programmer usability. </font><font style="vertical-align: inherit;">The toolkit for defining primitives and macros as functions of the target language allows critical places to be implemented in assembler processor. </font><font style="vertical-align: inherit;">For stack architecture processors, the compiler adaptation procedure is not too complicated and lengthy. </font><font style="vertical-align: inherit;">We can say that this is just the case when the availability of the source code of the compiler helps - the key sections of the compiler are changing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The results of the processor synthesis (32-bit capacity, 4K words of program memory and 1K RAM) for FPGA Altera Cyclone V series gives the following:</font></font><br>
<br>
<pre><code class="plaintext hljs">Family	Cyclone V<font></font>
Device	5CEBA4F23C7<font></font>
Logic utilization (in ALMs)	694 / 18,480 ( 4 % )<font></font>
Total registers	447<font></font>
Total pins	83 / 224 ( 37 % )<font></font>
Total virtual pins	0<font></font>
Total block memory bits	72,192 / 3,153,920 ( 2 % )<font></font>
Total DSP Blocks	2 / 66 ( 3 % )<font></font>
</code></pre><br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literature</font></font></b></i><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forth processor on VHDL // </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m.habr.com/en/post/149686</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python - Wikipedia // </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Python</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We begin FPGA on Python _ Habr // </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m.habr.com/en/post/439638</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MyHDL // </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.myhdl.org</font></font></a> </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub - true-grue_uzh_ Uzh compiler // </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/true-grue/uzh</font></font></a> </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub - true-grue_raddsl_ Tools for rapid prototyping of DSL compilers // </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/true-grue/raddsl</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sovietov.com/txt/dsl_python_conf.pdf</font></font></a> </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The author is grateful to the developers of the Zmey software processor and Uzh compiler for consultations and patience.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en491590/index.html">We analyze recommendations for the protection of personal data and information security - what you should pay attention to</a></li>
<li><a href="../en491592/index.html">From galaxy models to atoms - simple tricks in AI implementation speed up simulations billions of times</a></li>
<li><a href="../en491594/index.html">New cryptography method promising perfect secrecy greeted with skepticism</a></li>
<li><a href="../en491600/index.html">City and data: analysis of the walking distance of objects in Prague using data science</a></li>
<li><a href="../en491602/index.html">Podcast: why the work of a novice IT editor is a kind of ‚Äúmilitary drama‚Äù, and what we do with it</a></li>
<li><a href="../en491606/index.html">How to make a start menu and minimap</a></li>
<li><a href="../en491608/index.html">Animation Tips from Cuphead and God of War</a></li>
<li><a href="../en491610/index.html">Declarative data filtering at the front. Js / ts</a></li>
<li><a href="../en491612/index.html">Comparison of the dynamics of quotes of two stocks in python using the example of preferred and ordinary shares of Sberbank</a></li>
<li><a href="../en491614/index.html">Why Masterhost was doomed: an inside look</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>