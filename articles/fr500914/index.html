<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍒 👩🏿‍🎓 ⏹️ Algorithme de rendu de volume rapide et facile 🌄 👩‍🌾 🤴🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai récemment écrit un petit ShaderToy qui fait un rendu volumétrique simple, puis j'ai décidé de publier un article expliquant son travail. Le Shade...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Algorithme de rendu de volume rapide et facile</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500914/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/8r/iy/wc/8riywca1jhipnzh4e3ycjritfec.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai récemment écrit un petit ShaderToy qui fait un rendu volumétrique simple, puis j'ai décidé de publier un article expliquant son travail. </font><font style="vertical-align: inherit;">Le ShaderToy interactif lui-même peut être consulté </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si vous lisez à partir d'un téléphone ou d'un ordinateur portable, je vous recommande de regarder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> version rapide. </font><font style="vertical-align: inherit;">J'ai inclus des extraits de code dans le message qui vous aideront à comprendre les performances de ShaderToy à un niveau élevé, mais ils n'ont pas tous les détails. </font><font style="vertical-align: inherit;">Si vous voulez creuser plus profondément, je vous recommande de vérifier avec le code ShaderToy. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mon ShaderToy avait trois tâches principales:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exécution en temps réel</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplicité</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exactitude physique (... ou quelque chose comme ça)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vais commencer par cette scène de code vierge. </font><font style="vertical-align: inherit;">Je n'entrerai pas dans les détails de l'implémentation, car ce n'est pas très intéressant, mais je vais vous dire brièvement par où commencer:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ray tracing d'objets opaques. </font><font style="vertical-align: inherit;">Tous les objets sont des primitives avec de simples intersections avec des rayons (1 plan et 3 sphères)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour calculer l'éclairage, l'ombrage Phong est utilisé et, dans trois sources lumineuses sphériques, un coefficient d'atténuation de la lumière personnalisé est utilisé. </font><font style="vertical-align: inherit;">Les rayons d'ombres ne sont pas nécessaires, car nous n'illuminons que l'avion.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici à quoi ça ressemble:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba8/4dc/f82/ba84dcf8277762a067454fb786d266be.jpg" alt="Capture d'écran de ShaderToy"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous rendrons le volume comme un passage séparé qui se mélange à une scène opaque; </font><font style="vertical-align: inherit;">ceci est similaire à la façon dont tous les moteurs de rendu en temps réel traitent individuellement les surfaces opaques et translucides.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 1: simuler le volume</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais d'abord, avant de pouvoir commencer le rendu volumétrique, nous avons besoin de ce même volume! Pour simuler le volume, j'ai décidé d'utiliser des fonctions de distance signée (SDF). Pourquoi précisément les fonctions des champs de distance? Parce que je ne suis pas artiste, mais ils vous permettent de créer des formes très organiques en quelques lignes de code. Je ne parlerai pas en détail des fonctions des distances avec un signe, car Inigo Kiles les a déjà merveilleusement expliquées. Si vous êtes curieux, alors </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y a une grande liste de différentes fonctions de distances de signe et de modificateurs. Et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un autre article sur ces SDF raymarching. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons par une simple et ajoutons une sphère ici:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c03/5c4/536/c035c45368ef0cd0e232041b4ca2eec4.jpg" alt="Capture d'écran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons maintenant ajouter une autre sphère et utiliser la conjugaison lisse pour fusionner les fonctions de distance des sphères. </font><font style="vertical-align: inherit;">Ce code que j'ai pris directement de la page Inigo, mais pour plus de clarté, je vais l'insérer ici:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Taken from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdSmoothUnion</span><span class="hljs-params">( <span class="hljs-keyword">float</span> d1, <span class="hljs-keyword">float</span> d2, <span class="hljs-keyword">float</span> k )</span> 
</span>{
    <span class="hljs-keyword">float</span> h = clamp( <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>*(d2-d1)/k, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> );
    <span class="hljs-keyword">return</span> mix( d2, d1, h ) - k*h*(<span class="hljs-number">1.0</span>-h); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'appariement en douceur est un outil extrêmement puissant, car vous pouvez obtenir quelque chose de très intéressant en le combinant simplement avec quelques formes simples. </font><font style="vertical-align: inherit;">Voici à quoi ressemblent mes nombreuses sphères conjuguées en douceur:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/c3c/4b4/ddcc3c4b4f6d38d509b69cae63088c4a.jpg" alt="Capture d'écran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons donc obtenu quelque chose en forme de larme, mais nous avons besoin de quelque chose de plus comme un nuage qu'une goutte. Une grande caractéristique du SDF est la facilité avec laquelle il est possible de déformer la surface en ajoutant simplement un peu de bruit au SDF. Ajoutons donc un mouvement brownien fractal (fBM) au-dessus du bruit, en utilisant la position pour indexer la fonction de bruit. Inigo Kiles a également couvert ce sujet dans un excellent </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur le bruit fBM. Voici à quoi ressemblera l'image avec du bruit fBM superposé:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a47/bd6/bbd/a47bd6bbd487a37bc5e07a8f65e6436d.jpg" alt="Capture d'écran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien! </font><font style="vertical-align: inherit;">Grâce au bruit fBM, l'objet a soudainement commencé à paraître beaucoup plus intéressant! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous devons créer l'illusion que le volume interagit avec le plan de la terre. </font><font style="vertical-align: inherit;">Pour ce faire, j'ai ajouté une distance du plan signé légèrement en dessous du plan du sol et réutilisé la combinaison d'appariement en douceur avec une valeur d'appariement très agressive (paramètre k). </font><font style="vertical-align: inherit;">Après cela, nous avons obtenu cette image:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/7e9/863/8d27e9863fb9637575e23a4cf593f90e.jpg" alt="Capture d'écran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La touche finale sera le changement de l'indice xz du bruit fBM au fil du temps, de sorte que le volume ressemble à un brouillard tourbillonnant. </font><font style="vertical-align: inherit;">En mouvement, ça a l'air très bien!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/2d6/6fa/1672d66fa4b2760e9e57bd6062281cc2.gif" alt="Capture d'écran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Super, nous avons quelque chose comme un nuage! </font><font style="vertical-align: inherit;">Le code de calcul SDF est également assez compact:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">QueryVolumetricDistanceField</span><span class="hljs-params">( in vec3 pos)</span>
</span>{    <font></font>
    vec3 fbmCoord = (pos + <span class="hljs-number">2.0</span> * vec3(iTime, <span class="hljs-number">0.0</span>, iTime)) / <span class="hljs-number">1.5f</span>;
    <span class="hljs-keyword">float</span> sdfValue = sdSphere(pos, vec3(<span class="hljs-number">-8.0</span>, <span class="hljs-number">2.0</span> + <span class="hljs-number">20.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">-1</span>), <span class="hljs-number">5.6</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue,sdSphere(pos, vec3(<span class="hljs-number">8.0</span>, <span class="hljs-number">8.0</span> + <span class="hljs-number">12.0</span> * <span class="hljs-built_in">cos</span>(iTime), <span class="hljs-number">3</span>), <span class="hljs-number">5.6</span>), <span class="hljs-number">3.0f</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdSphere(pos, vec3(<span class="hljs-number">5.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">3.0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">8.0</span>), <span class="hljs-number">3.0</span>) + <span class="hljs-number">7.0</span> * fbm_4(fbmCoord / <span class="hljs-number">3.2</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdPlane(pos + vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0</span>)), <span class="hljs-number">22.0</span>);
    <span class="hljs-keyword">return</span> sdfValue;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit simplement de rendre un objet opaque. Nous avons besoin d'un magnifique brouillard magnifique! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment le restituer sous forme de volume et non d'objet opaque? Parlons d'abord de la physique que nous simulons. Le volume est un grand nombre de particules dans une certaine zone de l'espace. Et quand je dis «énorme», je veux dire «ÉNORME». À tel point que la modélisation de chacune de ces particules est aujourd'hui une tâche impossible, même pour un rendu hors ligne. Le feu, le brouillard et les nuages ​​en sont de bons exemples. À strictement parler, tout est volume, mais pour des raisons de rapidité des calculs, il est plus facile de fermer les yeux sur cela et de prétendre que ce n'est pas le cas. Nous représentons l'accumulation de ces particules comme des valeurs de densité qui sont généralement stockées dans une sorte de grille 3D (ou quelque chose de plus complexe, par exemple, dans OpenVDB).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque la lumière traverse un volume, une paire de phénomènes peut se produire lorsque la lumière entre en collision avec une particule. </font><font style="vertical-align: inherit;">Il peut soit se disperser et aller dans l'autre sens, soit une partie de la lumière peut être absorbée par la particule et se dissoudre. </font><font style="vertical-align: inherit;">Pour respecter l'exigence d'exécution en temps réel, nous effectuerons ce qu'on appelle la diffusion unique. </font><font style="vertical-align: inherit;">Cela signifie ce qui suit: nous supposerons que la lumière n'est diffusée qu'une seule fois, lorsque la lumière entre en collision avec une particule et vole vers la caméra. </font><font style="vertical-align: inherit;">Autrement dit, nous ne serons pas en mesure de simuler les effets de la diffusion multiple, par exemple le brouillard, dans lequel les objets à distance semblent généralement plus vagues. </font><font style="vertical-align: inherit;">Mais pour notre système, cela suffit. </font><font style="vertical-align: inherit;">Voici à quoi ressemble la diffusion unique lors du raymarching:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2d/19e/00f/f2d19e00fa758b0addc4ca447c0b024e.jpg" alt="Capture d'écran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le pseudocode pour cela ressemble à ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> n steps along the camera ray:<font></font>
   Calculate what % <span class="hljs-function">of your ray hit <span class="hljs-title">particles</span> <span class="hljs-params">(i.e. were absorbed)</span> <span class="hljs-keyword">and</span> needs lighting
   <span class="hljs-keyword">for</span> m lights:
      <span class="hljs-keyword">for</span> k steps towards the light:
         Calculate % of light that were absorbe in <span class="hljs-keyword">this</span> step
      Calculate lighting based on how much light is visible
Blend results on top of opaque objects pass based on % of your ray that made it through the volume</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, nous avons affaire à des calculs de complexité O (n * m * k). </font><font style="vertical-align: inherit;">Le GPU devra donc travailler dur.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous calculons l'absorption</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, examinons l'absorption de la lumière en volume le long du faisceau de la caméra (c'est-à-dire, n'effectuons pas encore de raymarking dans la direction des sources de lumière). </font><font style="vertical-align: inherit;">Pour ce faire, nous avons besoin de deux actions:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Effectuer un raymarching à l'intérieur du volume</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculer l'absorption / l'éclairage à chaque étape</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour calculer la quantité de lumière absorbée en chaque point, nous utilisons </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la loi de Bouguer - Lambert - Beer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui décrit l'atténuation de la lumière lors du passage à travers un matériau. </font><font style="vertical-align: inherit;">Les calculs sont étonnamment simples:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">BeerLambert</span><span class="hljs-params">(<span class="hljs-keyword">float</span> absorptionCoefficient, <span class="hljs-keyword">float</span> distanceTraveled)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span>(-absorptionCoefficient * distanceTraveled);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le coefficient d'absorption est un paramètre matériel. </font><font style="vertical-align: inherit;">Par exemple, dans un volume transparent, par exemple dans l'eau, cette valeur sera faible et pour quelque chose de plus épais, par exemple du lait, le coefficient sera plus élevé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour effectuer un raymarching de volume, nous prenons simplement des étapes d'une taille fixe le long du faisceau et obtenons une absorption à chaque étape. </font><font style="vertical-align: inherit;">Vous ne comprenez peut-être pas pourquoi prendre des mesures fixes au lieu de quelque chose de plus rapide, par exemple, tracer une sphère, mais si vous vous souvenez que la densité dans le volume est hétérogène, alors tout devient clair. </font><font style="vertical-align: inherit;">Vous trouverez ci-dessous le code de raymarching et d'absorption d'accumulation. </font><font style="vertical-align: inherit;">Certaines variables sont en dehors de la portée de cet extrait de code, alors consultez l'implémentation complète dans ShaderToy.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> opaqueVisiblity = <span class="hljs-number">1.0f</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> marchSize = <span class="hljs-number">0.6f</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_VOLUME_MARCH_STEPS; i++) {<font></font>
	volumeDepth += marchSize;<font></font>
	<span class="hljs-keyword">if</span>(volumeDepth &gt; opaqueDepth) <span class="hljs-keyword">break</span>;<font></font>
	<font></font>
	vec3 position = rayOrigin + volumeDepth*rayDirection;<font></font>
	<span class="hljs-keyword">bool</span> isInVolume = QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0f</span>;
	<span class="hljs-keyword">if</span>(isInVolume) 	{
		<span class="hljs-keyword">float</span> previousOpaqueVisiblity = opaqueVisiblity;<font></font>
		opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
		<span class="hljs-keyword">float</span> absorptionFromMarch = previousOpaqueVisiblity - opaqueVisiblity;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> lightIndex = <span class="hljs-number">0</span>; lightIndex &lt; NUM_LIGHTS; lightIndex++) {
			<span class="hljs-keyword">float</span> lightDistance = length((GetLight(lightIndex).Position - position));<font></font>
			vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance);  <font></font>
			volumetricColor += absorptionFromMarch * volumeAlbedo * lightColor;<font></font>
		}<font></font>
		volumetricColor += absorptionFromMarch * volumeAlbedo * GetAmbientLight();<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et voici ce que nous obtenons avec ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/14e/a86/c8714ea862797c656d9c64105c7befed.jpg" alt="Capture d'écran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On dirait de la barbe à papa! </font><font style="vertical-align: inherit;">Peut-être que pour certains effets cela suffira! </font><font style="vertical-align: inherit;">Mais nous manquons d'occultation. </font><font style="vertical-align: inherit;">La lumière atteint également toutes les parties du volume. </font><font style="vertical-align: inherit;">Mais ce n'est pas physiquement correct, selon la taille du volume entre le point rendu et la source lumineuse, nous recevrons une quantité différente de lumière entrante.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auto-ombrage</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons déjà fait le plus difficile. </font><font style="vertical-align: inherit;">Nous devons faire la même chose que nous avons fait pour calculer l'absorption le long du faisceau de la caméra, mais uniquement le long du faisceau de lumière. </font><font style="vertical-align: inherit;">Le code pour calculer la quantité de lumière atteignant chaque point sera essentiellement une répétition du code, mais sa duplication est plus facile que de pirater HLSL pour obtenir la récursion dont nous avons besoin. </font><font style="vertical-align: inherit;">Voici donc à quoi cela ressemblera:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetLightVisiblity</span><span class="hljs-params">(in vec3 rayOrigin, in vec3 rayDirection, in <span class="hljs-keyword">float</span> maxT, in <span class="hljs-keyword">int</span> maxSteps, in <span class="hljs-keyword">float</span> marchSize)</span> </span>{
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0.0f</span>;
    <span class="hljs-keyword">float</span> lightVisiblity = <span class="hljs-number">1.0f</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxSteps; i++) {                       <font></font>
        t += marchSize;<font></font>
        <span class="hljs-keyword">if</span>(t &gt; maxT) <span class="hljs-keyword">break</span>;<font></font>
<font></font>
        vec3 position = rayOrigin + t*rayDirection;<font></font>
        <span class="hljs-keyword">if</span>(QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0</span>) {<font></font>
            lightVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> lightVisiblity;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'ajout de l'observation automatique nous donne les avantages suivants:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/6e0/96e/a4f6e096e2250a9aa17594b59cc7e25d.jpg" alt="Capture d'écran de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adoucir les bords</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour le moment, j'aime déjà assez bien notre volume. </font><font style="vertical-align: inherit;">Je l'ai montré au chef talentueux du département VFX de The Coalition, James Sharp. </font><font style="vertical-align: inherit;">Il a immédiatement remarqué que les bords du volume étaient trop nets. </font><font style="vertical-align: inherit;">Et cela est absolument vrai - des objets comme les nuages ​​sont constamment dispersés dans l'espace qui les entoure, de sorte que leurs bords se mélangent avec l'espace vide autour du volume, ce qui devrait conduire à la création de bords très lisses. </font><font style="vertical-align: inherit;">James m'a proposé une excellente idée - réduire la densité en fonction de la proximité du bord. </font><font style="vertical-align: inherit;">Et puisque nous travaillons avec des fonctions de distance avec un signe, c'est très simple à mettre en œuvre! </font><font style="vertical-align: inherit;">Ajoutons donc une fonction qui peut être utilisée pour demander la densité à n'importe quel point du volume:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">return</span> sdfMultiplier;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et puis nous l'effondrons simplement dans la valeur d'absorption:</font></font><br>
<br>
<pre><code class="cpp hljs">opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position), marchSize);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et voici à quoi ça ressemble:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/7b3/ab5/7887b3ab53afcfc69c33e12bd473de9d.gif" alt="Capture d'écran de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonction densité</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant que nous avons la fonction de densité, vous pouvez facilement ajouter un peu de bruit au volume pour lui donner des détails supplémentaires et de la splendeur. </font><font style="vertical-align: inherit;">Dans ce cas, je réutilise simplement la fonction fBM que nous avons utilisée pour régler la forme du volume.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
   <span class="hljs-keyword">return</span> sdfMultiplier * <span class="hljs-built_in">abs</span>(fbm_4(position / <span class="hljs-number">6.0</span>) + <span class="hljs-number">0.5</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et nous avons donc obtenu ce qui suit:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b9/c0a/1e6/1b9c0a1e68d020206e9567b9044317d9.jpg" alt="Capture d'écran de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auto-ombrage opaque</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le volume est déjà assez joli! </font><font style="vertical-align: inherit;">Mais un peu de lumière y coule encore. </font><font style="vertical-align: inherit;">Ici, nous voyons comment la couleur verte s'infiltre là où le volume devrait l'absorber:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/e16/dbf/051e16dbfa5d9f307c635a6293dcc69f.jpg" alt="Capture d'écran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela se produit car les objets opaques sont rendus avant le rendu du volume, ils ne prennent donc pas en compte l'ombrage provoqué par le volume. </font><font style="vertical-align: inherit;">C'est assez facile à résoudre - nous avons une fonction GetLightVisiblity que nous pouvons utiliser pour calculer l'ombrage, nous avons donc juste besoin de l'appeler pour éclairer un objet opaque. </font><font style="vertical-align: inherit;">Nous obtenons ce qui suit:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cda/1c4/99d/cda1c499d05729265b374378e3da9481.gif" alt="Capture d'écran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus de créer de belles ombres multicolores, cela aide à améliorer les ombres et à augmenter le volume dans la scène. </font><font style="vertical-align: inherit;">De plus, grâce aux bords lisses du volume, nous obtenons des ombres douces, malgré le fait que, à proprement parler, nous travaillons avec des sources ponctuelles d'éclairage. </font><font style="vertical-align: inherit;">C'est tout! </font><font style="vertical-align: inherit;">Beaucoup plus peut être fait ici, mais il me semble que j'ai atteint la qualité visuelle dont j'ai besoin, tout en conservant la relative simplicité de l'exemple.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimisations</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À la fin, je vais énumérer brièvement quelques optimisations possibles:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant d'effectuer le raymarching en direction de la source lumineuse, il est nécessaire de vérifier par la valeur de la décoloration de la lumière si une quantité importante de cette lumière atteint vraiment le point en question. </font><font style="vertical-align: inherit;">Dans mon implémentation, je regarde la luminosité de la lumière multipliée par l'albédo du matériau et je m'assure que la valeur est suffisamment grande pour que le raymarching soit effectué.</font></font></li>
<li>      ,     ,     raymarching   </li>
<li>        raymarching .      ,        .           ,       raymarching ,     .</li>
</ol><br>
<h1></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout! </font><font style="vertical-align: inherit;">Personnellement, j'ai été surpris que vous puissiez créer quelque chose d'assez physiquement correct dans une si petite quantité de code (environ 500 lignes). </font><font style="vertical-align: inherit;">Merci d'avoir lu, j'espère que c'était intéressant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et encore une remarque: voici un changement amusant - j'ai ajouté une émission de lumière basée sur la distance SDF pour créer un effet d'explosion. </font><font style="vertical-align: inherit;">Après tout, les explosions ne sont jamais nombreuses.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/2f1/ab0/c642f1ab0fbc3df3b35cfafa97f9c694.gif" alt="Capture d'écran de ShaderToy"></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr500896/index.html">Que voir en quarantaine? Une sélection de matériaux de Technostream (partie 3)</a></li>
<li><a href="../fr500898/index.html">Plan Crazy SpaceX Moon? Évaluation du programme par U / S_Hirangy (reddit)</a></li>
<li><a href="../fr500902/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 343 (27 avril - 3 mai)</a></li>
<li><a href="../fr500904/index.html">Qui est qui dans l'écosystème des paiements 2020. Partie 1</a></li>
<li><a href="../fr500910/index.html">Système de communications spatiales à longue portée en Chine</a></li>
<li><a href="../fr500918/index.html">Ce à quoi nous prêtons attention lors du calcul de la signification statistique du test A / B</a></li>
<li><a href="../fr500920/index.html">Antiquités: ZX Spectrum et l'igrozhur antique</a></li>
<li><a href="../fr500922/index.html">Un loup déguisé en mouton: comment attraper un pirate qui se déguise soigneusement en utilisateur ordinaire</a></li>
<li><a href="../fr500924/index.html">Rencontre en ligne JUG.ru "Spring-builder" avec Evgeny Borisov</a></li>
<li><a href="../fr500926/index.html">La frappe dynamique n'est pas un outil de développement. C'est absurde (moche)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>