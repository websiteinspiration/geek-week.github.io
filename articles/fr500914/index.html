<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçí üë©üèø‚Äçüéì ‚èπÔ∏è Algorithme de rendu de volume rapide et facile üåÑ üë©‚Äçüåæ ü§¥üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai r√©cemment √©crit un petit ShaderToy qui fait un rendu volum√©trique simple, puis j'ai d√©cid√© de publier un article expliquant son travail. Le Shade...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Algorithme de rendu de volume rapide et facile</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500914/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/8r/iy/wc/8riywca1jhipnzh4e3ycjritfec.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai r√©cemment √©crit un petit ShaderToy qui fait un rendu volum√©trique simple, puis j'ai d√©cid√© de publier un article expliquant son travail. </font><font style="vertical-align: inherit;">Le ShaderToy interactif lui-m√™me peut √™tre consult√© </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si vous lisez √† partir d'un t√©l√©phone ou d'un ordinateur portable, je vous recommande de regarder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> version rapide. </font><font style="vertical-align: inherit;">J'ai inclus des extraits de code dans le message qui vous aideront √† comprendre les performances de ShaderToy √† un niveau √©lev√©, mais ils n'ont pas tous les d√©tails. </font><font style="vertical-align: inherit;">Si vous voulez creuser plus profond√©ment, je vous recommande de v√©rifier avec le code ShaderToy. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mon ShaderToy avait trois t√¢ches principales:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ex√©cution en temps r√©el</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplicit√©</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exactitude physique (... ou quelque chose comme √ßa)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vais commencer par cette sc√®ne de code vierge. </font><font style="vertical-align: inherit;">Je n'entrerai pas dans les d√©tails de l'impl√©mentation, car ce n'est pas tr√®s int√©ressant, mais je vais vous dire bri√®vement par o√π commencer:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ray tracing d'objets opaques. </font><font style="vertical-align: inherit;">Tous les objets sont des primitives avec de simples intersections avec des rayons (1 plan et 3 sph√®res)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour calculer l'√©clairage, l'ombrage Phong est utilis√© et, dans trois sources lumineuses sph√©riques, un coefficient d'att√©nuation de la lumi√®re personnalis√© est utilis√©. </font><font style="vertical-align: inherit;">Les rayons d'ombres ne sont pas n√©cessaires, car nous n'illuminons que l'avion.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici √† quoi √ßa ressemble:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba8/4dc/f82/ba84dcf8277762a067454fb786d266be.jpg" alt="Capture d'√©cran de ShaderToy"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous rendrons le volume comme un passage s√©par√© qui se m√©lange √† une sc√®ne opaque; </font><font style="vertical-align: inherit;">ceci est similaire √† la fa√ßon dont tous les moteurs de rendu en temps r√©el traitent individuellement les surfaces opaques et translucides.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 1: simuler le volume</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais d'abord, avant de pouvoir commencer le rendu volum√©trique, nous avons besoin de ce m√™me volume! Pour simuler le volume, j'ai d√©cid√© d'utiliser des fonctions de distance sign√©e (SDF). Pourquoi pr√©cis√©ment les fonctions des champs de distance? Parce que je ne suis pas artiste, mais ils vous permettent de cr√©er des formes tr√®s organiques en quelques lignes de code. Je ne parlerai pas en d√©tail des fonctions des distances avec un signe, car Inigo Kiles les a d√©j√† merveilleusement expliqu√©es. Si vous √™tes curieux, alors </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y a une grande liste de diff√©rentes fonctions de distances de signe et de modificateurs. Et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un autre article sur ces SDF raymarching. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commen√ßons par une simple et ajoutons une sph√®re ici:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c03/5c4/536/c035c45368ef0cd0e232041b4ca2eec4.jpg" alt="Capture d'√©cran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons maintenant ajouter une autre sph√®re et utiliser la conjugaison lisse pour fusionner les fonctions de distance des sph√®res. </font><font style="vertical-align: inherit;">Ce code que j'ai pris directement de la page Inigo, mais pour plus de clart√©, je vais l'ins√©rer ici:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Taken from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdSmoothUnion</span><span class="hljs-params">( <span class="hljs-keyword">float</span> d1, <span class="hljs-keyword">float</span> d2, <span class="hljs-keyword">float</span> k )</span> 
</span>{
    <span class="hljs-keyword">float</span> h = clamp( <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>*(d2-d1)/k, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> );
    <span class="hljs-keyword">return</span> mix( d2, d1, h ) - k*h*(<span class="hljs-number">1.0</span>-h); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'appariement en douceur est un outil extr√™mement puissant, car vous pouvez obtenir quelque chose de tr√®s int√©ressant en le combinant simplement avec quelques formes simples. </font><font style="vertical-align: inherit;">Voici √† quoi ressemblent mes nombreuses sph√®res conjugu√©es en douceur:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/c3c/4b4/ddcc3c4b4f6d38d509b69cae63088c4a.jpg" alt="Capture d'√©cran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons donc obtenu quelque chose en forme de larme, mais nous avons besoin de quelque chose de plus comme un nuage qu'une goutte. Une grande caract√©ristique du SDF est la facilit√© avec laquelle il est possible de d√©former la surface en ajoutant simplement un peu de bruit au SDF. Ajoutons donc un mouvement brownien fractal (fBM) au-dessus du bruit, en utilisant la position pour indexer la fonction de bruit. Inigo Kiles a √©galement couvert ce sujet dans un excellent </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur le bruit fBM. Voici √† quoi ressemblera l'image avec du bruit fBM superpos√©:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a47/bd6/bbd/a47bd6bbd487a37bc5e07a8f65e6436d.jpg" alt="Capture d'√©cran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien! </font><font style="vertical-align: inherit;">Gr√¢ce au bruit fBM, l'objet a soudainement commenc√© √† para√Ætre beaucoup plus int√©ressant! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous devons cr√©er l'illusion que le volume interagit avec le plan de la terre. </font><font style="vertical-align: inherit;">Pour ce faire, j'ai ajout√© une distance du plan sign√© l√©g√®rement en dessous du plan du sol et r√©utilis√© la combinaison d'appariement en douceur avec une valeur d'appariement tr√®s agressive (param√®tre k). </font><font style="vertical-align: inherit;">Apr√®s cela, nous avons obtenu cette image:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/7e9/863/8d27e9863fb9637575e23a4cf593f90e.jpg" alt="Capture d'√©cran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La touche finale sera le changement de l'indice xz du bruit fBM au fil du temps, de sorte que le volume ressemble √† un brouillard tourbillonnant. </font><font style="vertical-align: inherit;">En mouvement, √ßa a l'air tr√®s bien!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/2d6/6fa/1672d66fa4b2760e9e57bd6062281cc2.gif" alt="Capture d'√©cran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Super, nous avons quelque chose comme un nuage! </font><font style="vertical-align: inherit;">Le code de calcul SDF est √©galement assez compact:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">QueryVolumetricDistanceField</span><span class="hljs-params">( in vec3 pos)</span>
</span>{    <font></font>
    vec3 fbmCoord = (pos + <span class="hljs-number">2.0</span> * vec3(iTime, <span class="hljs-number">0.0</span>, iTime)) / <span class="hljs-number">1.5f</span>;
    <span class="hljs-keyword">float</span> sdfValue = sdSphere(pos, vec3(<span class="hljs-number">-8.0</span>, <span class="hljs-number">2.0</span> + <span class="hljs-number">20.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">-1</span>), <span class="hljs-number">5.6</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue,sdSphere(pos, vec3(<span class="hljs-number">8.0</span>, <span class="hljs-number">8.0</span> + <span class="hljs-number">12.0</span> * <span class="hljs-built_in">cos</span>(iTime), <span class="hljs-number">3</span>), <span class="hljs-number">5.6</span>), <span class="hljs-number">3.0f</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdSphere(pos, vec3(<span class="hljs-number">5.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">3.0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">8.0</span>), <span class="hljs-number">3.0</span>) + <span class="hljs-number">7.0</span> * fbm_4(fbmCoord / <span class="hljs-number">3.2</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdPlane(pos + vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0</span>)), <span class="hljs-number">22.0</span>);
    <span class="hljs-keyword">return</span> sdfValue;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit simplement de rendre un objet opaque. Nous avons besoin d'un magnifique brouillard magnifique! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment le restituer sous forme de volume et non d'objet opaque? Parlons d'abord de la physique que nous simulons. Le volume est un grand nombre de particules dans une certaine zone de l'espace. Et quand je dis ¬´√©norme¬ª, je veux dire ¬´√âNORME¬ª. √Ä tel point que la mod√©lisation de chacune de ces particules est aujourd'hui une t√¢che impossible, m√™me pour un rendu hors ligne. Le feu, le brouillard et les nuages ‚Äã‚Äãen sont de bons exemples. √Ä strictement parler, tout est volume, mais pour des raisons de rapidit√© des calculs, il est plus facile de fermer les yeux sur cela et de pr√©tendre que ce n'est pas le cas. Nous repr√©sentons l'accumulation de ces particules comme des valeurs de densit√© qui sont g√©n√©ralement stock√©es dans une sorte de grille 3D (ou quelque chose de plus complexe, par exemple, dans OpenVDB).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque la lumi√®re traverse un volume, une paire de ph√©nom√®nes peut se produire lorsque la lumi√®re entre en collision avec une particule. </font><font style="vertical-align: inherit;">Il peut soit se disperser et aller dans l'autre sens, soit une partie de la lumi√®re peut √™tre absorb√©e par la particule et se dissoudre. </font><font style="vertical-align: inherit;">Pour respecter l'exigence d'ex√©cution en temps r√©el, nous effectuerons ce qu'on appelle la diffusion unique. </font><font style="vertical-align: inherit;">Cela signifie ce qui suit: nous supposerons que la lumi√®re n'est diffus√©e qu'une seule fois, lorsque la lumi√®re entre en collision avec une particule et vole vers la cam√©ra. </font><font style="vertical-align: inherit;">Autrement dit, nous ne serons pas en mesure de simuler les effets de la diffusion multiple, par exemple le brouillard, dans lequel les objets √† distance semblent g√©n√©ralement plus vagues. </font><font style="vertical-align: inherit;">Mais pour notre syst√®me, cela suffit. </font><font style="vertical-align: inherit;">Voici √† quoi ressemble la diffusion unique lors du raymarching:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2d/19e/00f/f2d19e00fa758b0addc4ca447c0b024e.jpg" alt="Capture d'√©cran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le pseudocode pour cela ressemble √† ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> n steps along the camera ray:<font></font>
   Calculate what % <span class="hljs-function">of your ray hit <span class="hljs-title">particles</span> <span class="hljs-params">(i.e. were absorbed)</span> <span class="hljs-keyword">and</span> needs lighting
   <span class="hljs-keyword">for</span> m lights:
      <span class="hljs-keyword">for</span> k steps towards the light:
         Calculate % of light that were absorbe in <span class="hljs-keyword">this</span> step
      Calculate lighting based on how much light is visible
Blend results on top of opaque objects pass based on % of your ray that made it through the volume</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, nous avons affaire √† des calculs de complexit√© O (n * m * k). </font><font style="vertical-align: inherit;">Le GPU devra donc travailler dur.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous calculons l'absorption</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, examinons l'absorption de la lumi√®re en volume le long du faisceau de la cam√©ra (c'est-√†-dire, n'effectuons pas encore de raymarking dans la direction des sources de lumi√®re). </font><font style="vertical-align: inherit;">Pour ce faire, nous avons besoin de deux actions:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Effectuer un raymarching √† l'int√©rieur du volume</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculer l'absorption / l'√©clairage √† chaque √©tape</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour calculer la quantit√© de lumi√®re absorb√©e en chaque point, nous utilisons </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la loi de Bouguer - Lambert - Beer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui d√©crit l'att√©nuation de la lumi√®re lors du passage √† travers un mat√©riau. </font><font style="vertical-align: inherit;">Les calculs sont √©tonnamment simples:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">BeerLambert</span><span class="hljs-params">(<span class="hljs-keyword">float</span> absorptionCoefficient, <span class="hljs-keyword">float</span> distanceTraveled)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span>(-absorptionCoefficient * distanceTraveled);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le coefficient d'absorption est un param√®tre mat√©riel. </font><font style="vertical-align: inherit;">Par exemple, dans un volume transparent, par exemple dans l'eau, cette valeur sera faible et pour quelque chose de plus √©pais, par exemple du lait, le coefficient sera plus √©lev√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour effectuer un raymarching de volume, nous prenons simplement des √©tapes d'une taille fixe le long du faisceau et obtenons une absorption √† chaque √©tape. </font><font style="vertical-align: inherit;">Vous ne comprenez peut-√™tre pas pourquoi prendre des mesures fixes au lieu de quelque chose de plus rapide, par exemple, tracer une sph√®re, mais si vous vous souvenez que la densit√© dans le volume est h√©t√©rog√®ne, alors tout devient clair. </font><font style="vertical-align: inherit;">Vous trouverez ci-dessous le code de raymarching et d'absorption d'accumulation. </font><font style="vertical-align: inherit;">Certaines variables sont en dehors de la port√©e de cet extrait de code, alors consultez l'impl√©mentation compl√®te dans ShaderToy.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> opaqueVisiblity = <span class="hljs-number">1.0f</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> marchSize = <span class="hljs-number">0.6f</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_VOLUME_MARCH_STEPS; i++) {<font></font>
	volumeDepth += marchSize;<font></font>
	<span class="hljs-keyword">if</span>(volumeDepth &gt; opaqueDepth) <span class="hljs-keyword">break</span>;<font></font>
	<font></font>
	vec3 position = rayOrigin + volumeDepth*rayDirection;<font></font>
	<span class="hljs-keyword">bool</span> isInVolume = QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0f</span>;
	<span class="hljs-keyword">if</span>(isInVolume) 	{
		<span class="hljs-keyword">float</span> previousOpaqueVisiblity = opaqueVisiblity;<font></font>
		opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
		<span class="hljs-keyword">float</span> absorptionFromMarch = previousOpaqueVisiblity - opaqueVisiblity;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> lightIndex = <span class="hljs-number">0</span>; lightIndex &lt; NUM_LIGHTS; lightIndex++) {
			<span class="hljs-keyword">float</span> lightDistance = length((GetLight(lightIndex).Position - position));<font></font>
			vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance);  <font></font>
			volumetricColor += absorptionFromMarch * volumeAlbedo * lightColor;<font></font>
		}<font></font>
		volumetricColor += absorptionFromMarch * volumeAlbedo * GetAmbientLight();<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et voici ce que nous obtenons avec ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/14e/a86/c8714ea862797c656d9c64105c7befed.jpg" alt="Capture d'√©cran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On dirait de la barbe √† papa! </font><font style="vertical-align: inherit;">Peut-√™tre que pour certains effets cela suffira! </font><font style="vertical-align: inherit;">Mais nous manquons d'occultation. </font><font style="vertical-align: inherit;">La lumi√®re atteint √©galement toutes les parties du volume. </font><font style="vertical-align: inherit;">Mais ce n'est pas physiquement correct, selon la taille du volume entre le point rendu et la source lumineuse, nous recevrons une quantit√© diff√©rente de lumi√®re entrante.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auto-ombrage</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons d√©j√† fait le plus difficile. </font><font style="vertical-align: inherit;">Nous devons faire la m√™me chose que nous avons fait pour calculer l'absorption le long du faisceau de la cam√©ra, mais uniquement le long du faisceau de lumi√®re. </font><font style="vertical-align: inherit;">Le code pour calculer la quantit√© de lumi√®re atteignant chaque point sera essentiellement une r√©p√©tition du code, mais sa duplication est plus facile que de pirater HLSL pour obtenir la r√©cursion dont nous avons besoin. </font><font style="vertical-align: inherit;">Voici donc √† quoi cela ressemblera:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetLightVisiblity</span><span class="hljs-params">(in vec3 rayOrigin, in vec3 rayDirection, in <span class="hljs-keyword">float</span> maxT, in <span class="hljs-keyword">int</span> maxSteps, in <span class="hljs-keyword">float</span> marchSize)</span> </span>{
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0.0f</span>;
    <span class="hljs-keyword">float</span> lightVisiblity = <span class="hljs-number">1.0f</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxSteps; i++) {                       <font></font>
        t += marchSize;<font></font>
        <span class="hljs-keyword">if</span>(t &gt; maxT) <span class="hljs-keyword">break</span>;<font></font>
<font></font>
        vec3 position = rayOrigin + t*rayDirection;<font></font>
        <span class="hljs-keyword">if</span>(QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0</span>) {<font></font>
            lightVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> lightVisiblity;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'ajout de l'observation automatique nous donne les avantages suivants:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/6e0/96e/a4f6e096e2250a9aa17594b59cc7e25d.jpg" alt="Capture d'√©cran de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adoucir les bords</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour le moment, j'aime d√©j√† assez bien notre volume. </font><font style="vertical-align: inherit;">Je l'ai montr√© au chef talentueux du d√©partement VFX de The Coalition, James Sharp. </font><font style="vertical-align: inherit;">Il a imm√©diatement remarqu√© que les bords du volume √©taient trop nets. </font><font style="vertical-align: inherit;">Et cela est absolument vrai - des objets comme les nuages ‚Äã‚Äãsont constamment dispers√©s dans l'espace qui les entoure, de sorte que leurs bords se m√©langent avec l'espace vide autour du volume, ce qui devrait conduire √† la cr√©ation de bords tr√®s lisses. </font><font style="vertical-align: inherit;">James m'a propos√© une excellente id√©e - r√©duire la densit√© en fonction de la proximit√© du bord. </font><font style="vertical-align: inherit;">Et puisque nous travaillons avec des fonctions de distance avec un signe, c'est tr√®s simple √† mettre en ≈ìuvre! </font><font style="vertical-align: inherit;">Ajoutons donc une fonction qui peut √™tre utilis√©e pour demander la densit√© √† n'importe quel point du volume:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">return</span> sdfMultiplier;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et puis nous l'effondrons simplement dans la valeur d'absorption:</font></font><br>
<br>
<pre><code class="cpp hljs">opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position), marchSize);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et voici √† quoi √ßa ressemble:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/7b3/ab5/7887b3ab53afcfc69c33e12bd473de9d.gif" alt="Capture d'√©cran de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonction densit√©</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant que nous avons la fonction de densit√©, vous pouvez facilement ajouter un peu de bruit au volume pour lui donner des d√©tails suppl√©mentaires et de la splendeur. </font><font style="vertical-align: inherit;">Dans ce cas, je r√©utilise simplement la fonction fBM que nous avons utilis√©e pour r√©gler la forme du volume.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
   <span class="hljs-keyword">return</span> sdfMultiplier * <span class="hljs-built_in">abs</span>(fbm_4(position / <span class="hljs-number">6.0</span>) + <span class="hljs-number">0.5</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et nous avons donc obtenu ce qui suit:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b9/c0a/1e6/1b9c0a1e68d020206e9567b9044317d9.jpg" alt="Capture d'√©cran de ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auto-ombrage opaque</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le volume est d√©j√† assez joli! </font><font style="vertical-align: inherit;">Mais un peu de lumi√®re y coule encore. </font><font style="vertical-align: inherit;">Ici, nous voyons comment la couleur verte s'infiltre l√† o√π le volume devrait l'absorber:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/e16/dbf/051e16dbfa5d9f307c635a6293dcc69f.jpg" alt="Capture d'√©cran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela se produit car les objets opaques sont rendus avant le rendu du volume, ils ne prennent donc pas en compte l'ombrage provoqu√© par le volume. </font><font style="vertical-align: inherit;">C'est assez facile √† r√©soudre - nous avons une fonction GetLightVisiblity que nous pouvons utiliser pour calculer l'ombrage, nous avons donc juste besoin de l'appeler pour √©clairer un objet opaque. </font><font style="vertical-align: inherit;">Nous obtenons ce qui suit:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cda/1c4/99d/cda1c499d05729265b374378e3da9481.gif" alt="Capture d'√©cran de ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus de cr√©er de belles ombres multicolores, cela aide √† am√©liorer les ombres et √† augmenter le volume dans la sc√®ne. </font><font style="vertical-align: inherit;">De plus, gr√¢ce aux bords lisses du volume, nous obtenons des ombres douces, malgr√© le fait que, √† proprement parler, nous travaillons avec des sources ponctuelles d'√©clairage. </font><font style="vertical-align: inherit;">C'est tout! </font><font style="vertical-align: inherit;">Beaucoup plus peut √™tre fait ici, mais il me semble que j'ai atteint la qualit√© visuelle dont j'ai besoin, tout en conservant la relative simplicit√© de l'exemple.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimisations</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä la fin, je vais √©num√©rer bri√®vement quelques optimisations possibles:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant d'effectuer le raymarching en direction de la source lumineuse, il est n√©cessaire de v√©rifier par la valeur de la d√©coloration de la lumi√®re si une quantit√© importante de cette lumi√®re atteint vraiment le point en question. </font><font style="vertical-align: inherit;">Dans mon impl√©mentation, je regarde la luminosit√© de la lumi√®re multipli√©e par l'alb√©do du mat√©riau et je m'assure que la valeur est suffisamment grande pour que le raymarching soit effectu√©.</font></font></li>
<li>      ,     ,     raymarching   </li>
<li>        raymarching .      ,        .           ,       raymarching ,     .</li>
</ol><br>
<h1></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout! </font><font style="vertical-align: inherit;">Personnellement, j'ai √©t√© surpris que vous puissiez cr√©er quelque chose d'assez physiquement correct dans une si petite quantit√© de code (environ 500 lignes). </font><font style="vertical-align: inherit;">Merci d'avoir lu, j'esp√®re que c'√©tait int√©ressant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et encore une remarque: voici un changement amusant - j'ai ajout√© une √©mission de lumi√®re bas√©e sur la distance SDF pour cr√©er un effet d'explosion. </font><font style="vertical-align: inherit;">Apr√®s tout, les explosions ne sont jamais nombreuses.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/2f1/ab0/c642f1ab0fbc3df3b35cfafa97f9c694.gif" alt="Capture d'√©cran de ShaderToy"></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr500896/index.html">Que voir en quarantaine? Une s√©lection de mat√©riaux de Technostream (partie 3)</a></li>
<li><a href="../fr500898/index.html">Plan Crazy SpaceX Moon? √âvaluation du programme par U / S_Hirangy (reddit)</a></li>
<li><a href="../fr500902/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 343 (27 avril - 3 mai)</a></li>
<li><a href="../fr500904/index.html">Qui est qui dans l'√©cosyst√®me des paiements 2020. Partie 1</a></li>
<li><a href="../fr500910/index.html">Syst√®me de communications spatiales √† longue port√©e en Chine</a></li>
<li><a href="../fr500918/index.html">Ce √† quoi nous pr√™tons attention lors du calcul de la signification statistique du test A / B</a></li>
<li><a href="../fr500920/index.html">Antiquit√©s: ZX Spectrum et l'igrozhur antique</a></li>
<li><a href="../fr500922/index.html">Un loup d√©guis√© en mouton: comment attraper un pirate qui se d√©guise soigneusement en utilisateur ordinaire</a></li>
<li><a href="../fr500924/index.html">Rencontre en ligne JUG.ru "Spring-builder" avec Evgeny Borisov</a></li>
<li><a href="../fr500926/index.html">La frappe dynamique n'est pas un outil de d√©veloppement. C'est absurde (moche)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>