<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏾 📛 🌰 VLSI自動原価計算で行ったように 📪 👊 👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="数年前、クライアントごとにローカルデータベースを使用するデスクトップアプリケーションの開発から、数十万人の顧客をオンラインとするSaaSモデルに切り替えたとき、VLSIにウェアハウスアカウンティング機能を実装するときに、データベースを操作するためのアルゴリズムを真剣に修正する必要がありました。この内...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>VLSI自動原価計算で行ったように</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/504446/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数年前、クライアントごとにローカルデータベースを使用するデスクトップアプリケーションの開発から、数十万人の顧客をオンラインとするSaaSモデルに切り替えたとき</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、VLSIにウェアハウスアカウンティング</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能を実装するときに、データベースを操作するためのアルゴリズムを真剣に修正する必要がありました</font><font style="vertical-align: inherit;">。この内部レポートは、遭遇した困難のアルゴリズム上の理由とそれらを解決する方法に当てられています。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
PostgreSQL DBMSの操作に関する別のセミナー。今日は、ビジネス要件の厳しい実務を高負荷のサービスの開発に移す方法、データへの競争的なアクセスに対処する方法、これを慎重に回避し、「足を踏み外さない」方法について説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日はについて話すよ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原価計算の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VLSI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちの計算方法、</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
一般に「コスト」とは何か、なぜそれが必要なのか、そしてそれをどのように考えるのか</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「アルゴリズムの」ソリューションのアーキテクチャを構築する際の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">アルゴリズムの問​​題の</font></a><font style="vertical-align: inherit;">概念的手法</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技術</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の負荷を最適化すると操作の順序を適用する方法、メイク取引が短く、高速で、データベースや他のアプローチでは、競争力の高いキューを整理する理由</font></font></li>
</ul><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/-lT9yuPAroA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<a name="habracut"></a><br>
<br>
<a name="01"></a><br>
<img src="https://habrastorage.org/webt/es/sx/zz/essxzzw4kvp7hqkrkhj0dx2ixa4.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コストは、</font><font style="vertical-align: inherit;">3つの主要な事柄に必要な</font><font style="vertical-align: inherit;">、ビジネス上</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のコスト</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自己コスト</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><b><font style="vertical-align: inherit;">見積もりです</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ul>
<li><b> </b> —      -  <br>
  ,       ,  ,  .</li>
<li><b> </b>   (    )   <br>
 ,        .</li>
<li><b> </b>     <br>
       : «-,     1000 ,          1000    »</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定義から、コストは単なる</font><b><font style="vertical-align: inherit;">評価の</font></b></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一種で</font></font></i><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あり、評価には多くの異なる方法があることがわかります。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィキペディア</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">見ると</font></a><font style="vertical-align: inherit;">、説明されているさまざまなテクニックが12種類あります。私たちは自分で1つを選択し、それがそれに入るということに気づきました</font><font style="vertical-align: inherit;">。生産コストを計算するとき</font><b><font style="vertical-align: inherit;">は、材料</font></b></font><br>
<br>
<img src="https://habrastorage.org/webt/sb/pf/bw/sbpfbw1v3caplj9uh_quuprpeou.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発生のみを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考慮し</font><font style="vertical-align: inherit;">ます。つまり、給与、家賃、電気代などのすべての費用は考慮していません。それらは自動計算に参加しないという意味で-たとえば、その月の総コストを計算した後で個別に再配分できます。</font><b><font style="vertical-align: inherit;">期末に</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
検討</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：日、月、四半期、または年—これは、組織が使用する会計方法に応じて、ユーザーが構成可能なパラメーターです。そして、一般的なケースで</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、その期間内で、動き</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を必要に応じて</font><b><font style="vertical-align: inherit;">再配置でき</font></b><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
計算は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">倉庫のコンテキストで</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行さ</font><b><font style="vertical-align: inherit;">れます</font></b><font style="vertical-align: inherit;">。つまり、倉庫には多数の倉庫があり、それぞれのコストは個別に考慮されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、具体的には、テンソルと同様に、約100の倉庫があります。これらはすべて</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、電子署名用のメディア</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュデスク、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および販売するその他の商品を</font><font style="vertical-align: inherit;">保管する「ブランチ」倉庫です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ダイニングルームやレストランを利用した</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">倉庫</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの計算アルゴリズムをサポートしています。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「平均」またはバッチ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">による手動のバッチ選択またはFIFOによる自動選択。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これらすべてを究極の精度で検討します-お金の場合は「1ペニー」、数量の場合は「100万分の1」の精度。</font><font style="vertical-align: inherit;">このような正確さ（「トン」で計算すると1グラム）は、どの製品にも十分であるように思えました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d0/a8/n7/d0a8n7uv26afrelyec1upje0hps.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動モードでは材料のみが考慮されるため、4つの操作モデルのみを処理できれば十分です。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">経費は</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">売上、償却、および再評価の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメント</font><i><font style="vertical-align: inherit;">ごとにまとめられ</font></i><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コストは</font><font style="vertical-align: inherit;">、取引時のウェアハウスカードの残高から</font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算さ</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れます。</font></font></li>
<li><b></b><br>
  <i>    </i>.<br>
 <u> </u>    —    .</li>
<li><b></b> (  )<br>
  <i>,   </i>.<br>
  <u>  </u>   .</li>
<li><b></b><br>
             .</li>
</ul><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">経費だけが</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
計算アルゴリズムに依存していることがわかり（平均/ロット単位）</font><font style="vertical-align: inherit;">、他のすべての操作はそれらから「派生」します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ov/3n/y5/ov3ny5ssocxz6u1sqd5wxth4zxc.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
期末に計算します。つまり、「期間内で何が起こったのかは明らかではありませんが、最後に」というような状態ですので、計算してみます。そして、それを計算する</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、それらが実行さ</font><b><font style="vertical-align: inherit;">れた間違った順序</font></b><font style="vertical-align: inherit;">で</font><b><font style="vertical-align: inherit;">操作を考慮し</font></b><font style="vertical-align: inherit;">なければ</font><b><font style="vertical-align: inherit;">なら</font></b><font style="vertical-align: inherit;">ない可能性がかなりあり</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
典型的なビジネス状況-マネージャーは倉庫に走りました。 「Vasya、このテレビ、</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まだ倉庫に入れていませんが</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、今すぐ</font><i><b><font style="vertical-align: inherit;">発送</font></b></i><font style="vertical-align: inherit;">してください。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
午前中は倉庫からの発送があり、夕方入荷となりました。つまり、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">費用は到着前に登録さ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れていたため、正式には、日中は倉庫が「マイナス」</font><b><font style="vertical-align: inherit;">でし</font></b><font style="vertical-align: inherit;">たが、すべてがアルゴリズムに従って計算される必要があります。私たちは世帯の観点から理解しているため-ここでは、キャッシュされたテレビを正確に出荷し、これらの文書を再発行することでユーザーを苦しめる必要はありません！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、最も効率的に計算するために、ユーザー定義の期間のフレームワーク内で操作の順序を「より便利」に、つまりすべてが最大限に機能するように変更するすべての権利があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの2つの図は、フローが到着よりも早いときに最初に操作の順序をとろうとすると、すぐに2つのスケジュールされていない操作が発生することを示しています。最初の「マイナス」の経費の後、または到着後のどちらでも、残高については何も言えないからです。ある種の量的なバランスがあるでしょうが、その原価、金銭的価値については何も言えません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これらの操作を入れ替えれば、問題はありません。私たちの到着が10r / pcであった場合、消費量は同じになることを明確に理解しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4n/ic/x7/4nicx7l0lifhffzjqbikaccoozg.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、1つの問題があります。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">間隔内の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どこか</font><b><font style="vertical-align: inherit;">に在庫</font></b><font style="vertical-align: inherit;">が</font><b><font style="vertical-align: inherit;">ある</font></b><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">、そのような操作をそれを介して転送することはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人生の中でこれはどんな種類の在庫なのですか？誰がメトロにいたのかと彼は見た、時々彼らはいくつかのラックをチェーンでつなぎ合わせてそこで何かをし始めるかもしれない。バースキャナーを持つマネージャーが実行し、商品を「クリック」します。ここで彼はそれを定量的に測定し、在庫を取り、特定の数を取得します。したがって、彼は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定の時点で</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この番号を取得し</font><font style="vertical-align: inherit;">ます。経費が以前に転記された場合-彼はすでにこの在庫のデータを考慮しています。後で実行する場合は、再配置する権利がありません。これにより、在庫に記録された残高が何らかの形で "移動"し始めるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、在庫は計算間隔をセグメントに分解します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wv/51/tk/wv51tkxepytjax7q9kidgvlznoo.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまな商品のコスト-「ネジ」と「釘」-は個別に計算できることは明らかです。しかし、同時に、モスクワの倉庫とヤロスラブリの倉庫に釘がある場合、私たちにとってこれらは計算のための同じオブジェクトであり、完全に独立した原価を持つことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、モスクワの倉庫で12ルーブルの場合とまったく同じ釘を「高額」で購入し、10ルーブルの場合はヤロスラヴリで「安く」購入しました。これは、たとえばここで一括購入し、地元のサプライヤーから最高の割引を受けられるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、各ウェアハウスカード</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の残高とコスト</font><b><font style="vertical-align: inherit;">は</font></b><font style="vertical-align: inherit;">個別に計算されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fz/zx/os/fzzxoszxtn3kdcownat3az541lo.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、1つのアイテムカードでも複数の倉庫</font><b><font style="vertical-align: inherit;">が存在すると、操作とカードの依存関係が</font></b><font style="vertical-align: inherit;">生じる場合</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">互いに離れて。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、移動してモスクワに10箱の釘を入れ、ヤロスラブリの倉庫に持って行った場合、この倉庫でのコストは、この次の操作の後でどういうわけか変化します。そして、それからのさらなる売上高は、モスクワからの場合、サンクトペテルブルグからの場合、別の倉庫から、どのくらい、どのくらいの量の倉庫から移動したかに依存します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
計算手順を決定する操作の「チェーン」があります。この例では、販売前に動きを計算する必要があります。そうしないと、動きを正しく計算できません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/p_/im/of/p_imofn9q4i7cwysdalasknh8ge.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、時にはそのような依存関係がカスケードで発生することもあります。たとえば、最初にモスクワからヤロスラブリに釘を持ち込み、翌日、これらの釘のいくつかがルイビンスクに送られました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、このようなカスケードが発生した場合、操作のすべての間隔をいくつかのセグメントに分割できることを理解しています。これらのセグメントは、</font><font style="vertical-align: inherit;">リソースと競合することなく、互いに独立</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して並列</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><b><font style="vertical-align: inherit;">計算できます</font></b><font style="vertical-align: inherit;">。つまり、最初はこれら3つのカードのすべての「緑」のセグメントを3つの並列フローと見なすことができ、厳密に「黄色」のセグメント、次に「赤」のセグメントと見なすことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/n2/jb/pd/n2jbpdespn6441u9h05mgggcwei.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、問題があります。 1つの計算間隔（たとえば1日）内に、最初にモスクワの卸売倉庫からヤロスラブリの小売倉庫に移動し、一部の製品を返品した場合、これら2つの操作は互いに依存し始めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、それらは共同でのみ計算できます-同じ間隔内でのこれら2つの倉庫のすべての操作の即時。つまり、これらの2枚のカードの計算を中断することはできず、この間隔で両方を同時に計算する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この</font><font style="vertical-align: inherit;">ような操作の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">順列</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><b><font style="vertical-align: inherit;">列挙する</font></b><font style="vertical-align: inherit;">タスクを解決するため</font><font style="vertical-align: inherit;">に、別のアルゴリズムが実装されています。彼はむしろ最適化と数学の関係にあり、データベースの操作とはほとんど関係がないので、今日は彼については触れません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_n/wt/ya/_nwtyavaomxiy04pemmilkczmb4.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが実装した最初の計算アルゴリズムは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「平均」</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。ここではすべてが簡単です。操作時に、カードの合計と量のバランスを取って、1つをもう1つで除算します。単価がわかります。これにオペレーションの商品の量を掛けます。オペレーションのコストを取得します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/__/z6/bf/__z6bfedbbigzycya6ucquthmna.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のアルゴリズム- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロットによる</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">選択</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バッチとは、特定の名前のサプライヤーが私たちに出荷する事実です。つまり、最初に特定の日付に、次に特定の価格で、第三に特定のパラメータを付けて出荷しました。これは、有効期限などのパーティー属性が重要な場合に特に重要です。 「昨日の前日」の牛乳は「今日」に私に出荷されたものとまったく同じではなく、どういうわけか互いに分離する必要があることは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、「バッチ会計」とも呼ばれるバッチ会計などがあります。パーティーでは、特定の属性を「結び付ける」ことができます。したがって、発生するすべての操作は当事者によって説明されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
突然、前の例と同じ導入の場合、異なる初期コストで2つの操作が含まれるため、操作のコストが異なることがわかりました。したがって、パーティショニング会計の場合、操作はパーティによって実行されるだけでなく、ウェアハウスカードの残高も実行されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z7/oq/ai/z7oqaijnfnsq7qzwwggxkzv0gwy.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後の瞬間、なぜ私たちの方法論を説明するとき、私は明確</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に会計</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><b><font style="vertical-align: inherit;">正確さに</font></b><font style="vertical-align: inherit;">焦点を合わせました</font><font style="vertical-align: inherit;">。会計の正確性が不確かなため、ある種の修正を使用することについて話していない場合、非常に予期しない影響が生じる可能性があるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰かが彼らの仕事にすでに出くわしたかもしれない、誰かがまだ直面しているかもしれないが、少なくとも彼らはそのようなことがどのように解決されるか知っているでしょう。そのような式を計算するとき、あなたはゼロを取得するべきであるとロジックがあなたに言っているように見えます、しかし...本当にではありません！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題は、コンピューティングデバイス内の数値の表現の有限ビットネスが原因で発生します。また、実行する計算操作が多いほど（そして前のスライドでは、各倉庫の移動を計算する際に少なくとも乗算と除算を実行する必要があることは明らかです）、ゼロからのこの偏差がより強く蓄積されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、そのような「ゼロではない」を取得しないためには、数値型を操作する必要があります。</font></font><br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1.0</span>::<span class="hljs-built_in">numeric</span> - <span class="hljs-number">0.9</span>::<span class="hljs-built_in">numeric</span> - <span class="hljs-number">0.1</span>::<span class="hljs-built_in">numeric</span>;
<span class="hljs-comment">-- 0.0</span></code></pre><br>
<img src="https://habrastorage.org/webt/ey/en/lu/eyenlu9iwsh7rfwxzvlmi5tugcu.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、計算の驚きの数ははるかに少なくなりますが、完全になくなったわけではありません。</font><font style="vertical-align: inherit;">PLによっては、精度への丸め自体が常に同じではない場合があるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、SQLの場合、「最終5」の端数処理が常に行われる場合、たとえばPythonの場合、そうではありません。</font><font style="vertical-align: inherit;">また</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、計算</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><b><font style="vertical-align: inherit;">同じ動作</font></b><font style="vertical-align: inherit;">を</font><b><font style="vertical-align: inherit;">実現するには、</font></b><font style="vertical-align: inherit;">使用する各言語に余分な労力を費やす必要があります。</font></font><br>
<a name="02"></a><br>
<img src="https://habrastorage.org/webt/hi/qc/79/hiqc79m2uqfih2x2hmxv0wxy_nq.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、アルゴリズムの「普遍的な」説明から、正確に実行する必要があるものに移りましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は考えました-そして結局のところ、VLSI 2.xデスクトップアプリケーションでは、コスト計算はすでに実装されています。それを準備して転送してみませんか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロ：</font></font></b><br>
<ul>
<li><b>  </b>     <br>
    ,  -    .</li>
<li><b>   </b><br>
      .<br>
</li>
<li><b>  - </b><br>
          .      .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、このアルゴリズムは独自の条件のために開発されました。クライアントが専用サーバー上にデータベースを1つ持つ場合、最大数十万の操作がありますが、数百万の操作はありません。</font><font style="vertical-align: inherit;">そして、会計士は、四半期の終わりに「すべての夜」のすべての動きを再計算するプロセスを開始する余裕があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何百ものクライアントが同じPostgreSQLデータベースに共存し、24時間年中無休で動作するオンラインアプリケーションの場合、これは適切ではありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反対：</font></font></b><br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロングトランザクション</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
MVCCの条件下では、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは多くの問題</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">引き起こし</font></a><font style="vertical-align: inherit;">、それを英雄的に解決する必要があります。</font><font style="vertical-align: inherit;">たとえば、増加するロックの「チェーン」。</font></font></li>
<li><b>   </b><br>
            ,          .</li>
<li><b>   </b><br>
         —    /.   «  » — ,       .<br>
</li>
<li><b>  - </b><br>
      , ,     —   300-400MB     .</li>
<li><b>  </b><br>
  «»  ,    CPU —  .</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手動による開始</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
アルゴリズムは計算量が多く、問題を引き起こす可能性があることが判明したため、自動モードで実行すると危険でした。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、オンラインの100万人の顧客ごとに同じアルゴリズムをスケーリングすることは不可能であり、再度発明する必要がありました。</font><font style="vertical-align: inherit;">短いトランザクションを使用し、常に計算済みの値を常に記憶し、いつでも正しく中断するすべての権利を持つ、たとえばサーバーインフラストラクチャの要素の負荷を最適化するなどの、</font><b><font style="vertical-align: inherit;">反復アルゴリズム</font></b><font style="vertical-align: inherit;">が</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ri/af/vh/riafvho6pm1sgxvqep1py-29oqm.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">つまり、以前に計画されたルートに沿ってさらにカウントできるはずです。</font><font style="vertical-align: inherit;">
再帰なし、ネストされたチェックなし- </font><b><font style="vertical-align: inherit;">「効率的でシンプル」な方法</font></b><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは、1つのクライアントのフレームワーク内でも多くのユーザーがすぐに作業できるWebベースのシステムを持っているので、計算の過程で、計算から計算への移動が</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">競争的に削除または</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「足元」に</font><b><font style="vertical-align: inherit;">作成さ</font></b><font style="vertical-align: inherit;">れる状況が簡単に発生する可能性があることを理解しています</font><font style="vertical-align: inherit;">この間隔を計算するまさにその瞬間。そして、私たちの実装はそのような状況からアルゴリズムを保証するべきです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とにかく「すべてをやり直す」ため</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、マルチスレッドモードで</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font><font style="vertical-align: inherit;">してデータベースとの作業を最適化する</font><font style="vertical-align: inherit;">こと</font><b><font style="vertical-align: inherit;">で</font></b><font style="vertical-align: inherit;">、より自由にタスクにアプローチし、計算を高速化することが可能になりました。これ</font><b><font style="vertical-align: inherit;">で</font></b><font style="vertical-align: inherit;">、同じ「マルチカラー」セグメントをより短時間で並列計算できるようになりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後の重要な瞬間-私は減らしたかった</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーの計算時間「ゼロに」</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">つまり、ユーザーはドキュメントを閉じるだけで、彼の動きはすでにパーティショニングアカウンティングのすべてのルールに従って解決されています。</font><font style="vertical-align: inherit;">そして、不幸な会計士は、報告期間の終わりに一晩中計算を開始する必要がなくなりました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hp/wc/lm/hpwclm8zmlodxnjxslhm4ll_x9o.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが順調だと思われます。</font><font style="vertical-align: inherit;">私たちの典型的なケースは単純です-データの変更に関するシグナルを待ち、すべてをすばやく計算して、もう一度待ちます。</font><font style="vertical-align: inherit;">しかし、それを単純に実行することは不可能であり、そうではありません。遅くなるので、ムーブメント自体の操作に加えて、補助エンティティに関連付けられている特定のインフラストラクチャを構築する必要がありました。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本サービスでは、ユーザーが何らかの移動操作を行い</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、データベースに記録されます</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このサービスは、非同期のイベントを</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調整</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コスト計算</font><font style="vertical-align: inherit;">サービスに「スロー」します</font><font style="vertical-align: inherit;">。これにより、個々のデータベースインスタンスに負荷がかかります。これは、このクライアントスキームでのある種の作業です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービス</font><font style="vertical-align: inherit;">は、特定のクライアントのコンテキストで</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反復</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算</font><b><font style="vertical-align: inherit;">プロセスを</font></b><font style="vertical-align: inherit;">開始</font><b><font style="vertical-align: inherit;">し</font></b><font style="vertical-align: inherit;">ます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースで具体的に何が起こるか：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移動操作のトリガーは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">対応するウェアハウスカードの</font><b><font style="vertical-align: inherit;">計算キューに</font></b><font style="vertical-align: inherit;">入り、</font><font style="vertical-align: inherit;">それぞれの操作時間が最小で、優先度も最小になります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼はまた、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存関係テーブルに</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エントリを形成し、</font><font style="vertical-align: inherit;">そのような時点で、そのような動作によって、ウェアハウスカードXがカードYに依存するようになりました。</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...計算プロセスは非同期でベースになり、マルチスレッド化されます...</font></font></i></li>
<li>   <b> </b>     .</li>
<li>    <b> </b>              «» (//...).</li>
<li> «» ,        —    ,     .</li>
<li>  «»    <b> </b>   - —      <u></u> ,    .</li>
<li>  , …<br>
<ol>
<li>    </li>
<li>     </li>
<li><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算結果</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（ロットで分割）を、移動とは別のテーブル</font><font style="vertical-align: inherit;">に入力します。</font><b><font style="vertical-align: inherit;">この場合</font></b><font style="vertical-align: inherit;">、カードのすべての操作は、間隔内でエンドツーエンドの順序になります</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">間隔の終わりにカード</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">データ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を残高</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><b><font style="vertical-align: inherit;">テーブルに</font></b><font style="vertical-align: inherit;">入力し</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;"> -数量、量、ロットごとの分布</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この「クォンタム」のカード結果に依存関係がある場合は、</font><font style="vertical-align: inherit;">優先度</font><font style="vertical-align: inherit;">を</font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小限に</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">してキューに入れます</font></font></li>
</ol></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、このアルゴリズムを実装するには、4つの追加テーブルが必要でした。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カードの優先度を決定する「プラス」と「マイナス」の2方向に「増加」</font><b><font style="vertical-align: inherit;">する計算キュー</font></b></font></li>
<li><b><font style="vertical-align: inherit;"></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各カードの各間隔の終わりに</font><b><font style="vertical-align: inherit;">計算さ</font></b><font style="vertical-align: inherit;">れた</font><b><font style="vertical-align: inherit;">残高</font></b></font></li>
<li><b><font style="vertical-align: inherit;"></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本カードと調査カード間の</font><b><font style="vertical-align: inherit;">依存関係</font></b></font></li>
<li><b><font style="vertical-align: inherit;"></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムによって選択された計算手順で厳密にバッチ</font><b><font style="vertical-align: inherit;">で</font></b><font style="vertical-align: inherit;">粉砕した</font><b><font style="vertical-align: inherit;">計算結果</font></b></font></li>
</ul><br>
<a name="03"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今、私たちは最も興味深いものに目を向けます-上で話したすべてのものを実装する方法、そして同時に結果として生じるすべての「レーキ」を注意深く回避する方法。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このソリューションはPostgreSQL 9.1でも作成されたため、後で</font></font><code>SKIP LOCKED</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">やの</font><font style="vertical-align: inherit;">ような機能は使用されません</font></font><code>lock_timeout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></blockquote><br>
<img src="https://habrastorage.org/webt/9f/vr/ay/9fvrayzfkzj4j122sehhi-7zuxm.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すぐに最初に遭遇するのは、倉庫ドキュメントの「クローズ」時の名前レコードの「保持」です。最も簡単なオプションは</font></font><code>UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、すべてのアイテムに対して</font><font style="vertical-align: inherit;">通常どおり</font><font style="vertical-align: inherit;">すぐ</font><font style="vertical-align: inherit;">に実行することです</font><font style="vertical-align: inherit;">。しかし、ある時点で、同じ倉庫カードの注文が異なる、同時に処理された2つのドキュメントであることが判明した場合- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドロック</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決策は、</font><font style="vertical-align: inherit;">処理中</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にレコードの順序付け</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><b><font style="vertical-align: inherit;">強制することでした</font></b><font style="vertical-align: inherit;">。これは、ストアドプロシージャまたは</font></font><code>DO</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロックの</font><font style="vertical-align: inherit;">いずれか</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="sql hljs">FOR id IN (<span class="hljs-keyword">SELECT</span> … <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> , , @) <span class="hljs-keyword">LOOP</span>
  <span class="hljs-keyword">UPDATE</span> … <span class="hljs-keyword">WHERE</span> @ = <span class="hljs-keyword">id</span>;
<span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、</font><font style="vertical-align: inherit;">この場所だけでなく、アルゴリズムの操作全体を通して</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じ順序</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を維持</font><b><font style="vertical-align: inherit;">する</font></b><font style="vertical-align: inherit;">ことが重要</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yb/ey/dy/ybeydyknqbtlorvcoywe1cwyjnw.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてをうまく行うのに役立った次のポイントは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">短いトランザクション</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは通常、Webベースのシステムを持っているため</font><font style="vertical-align: inherit;">、PostgreSQLで</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長いトランザクションを維持することは適切</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">はありません。</font></a><font style="vertical-align: inherit;">これにより、さまざまな長期ロックが発生し、サーバーに追加の負荷がかかります。</font><font style="vertical-align: inherit;">したがって、小さなトランザクションの助けを借りて何かを実行できる場合は、そうすることをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、サーバー上のantのように、大量の小さなトランザクションが発生しますが、互いに干渉せず、一緒に同じジョブを実行します。</font><font style="vertical-align: inherit;">これを実現するために、以下のアプローチを使用しました。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データはほとんど処理しません</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
が、何度も</font><b><font style="vertical-align: inherit;">処理します</font></b></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すぐに終了します。</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
つまり、誰も邪魔しないように、すべての「ダンバス」の時間を正規化します</font></font></li>
<li><b><font style="vertical-align: inherit;"></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLの内部メカニズムの理解を</font><b><font style="vertical-align: inherit;">できるだけ早く使用する</font></b></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のアルゴリズムに従って、正確に1つの「量子」を計算するためのトランザクションを行うことが最も合理的であることがわかりました。つまり、基本設定では</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、1枚のウェアハウスカードで1日の動きに</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、「量子」を計算するときに「開始」するカード残高が毎回再計算されないようにするため、単純にデータベースに格納します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kj/ps/ly/kjpslyfwaqtvjbz6qhylge0esvo.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、「ここと今」の依存関係に基づいて基本カードの計算を取得するのではなく</font><font style="vertical-align: inherit;">、キューを使用して</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それらを別のトランザクションに転送し</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして一般的に-キューを使用して長いトランザクションを「ブレーク」できる場所。計算されていないベース？順番待ち！それでは結果を計算する必要がありますか？順番待ち！それがターンがそれらに到達したときであり、それから私たちはそれらに対処し、現在のトランザクションではできるだけ早くすべてを行うので、私たちは誰かを</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待っ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て</font><b><font style="vertical-align: inherit;">いません</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">リクエスト</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
の助けを借りて「待つことはできません」が</font></font><code>NOWAIT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ロックが最も頻繁に存在する場合、これはあまり良くありません。そのため</font></font><code>EXCEPTION</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">常に飛んで</font><font style="vertical-align: inherit;">ログに「ゴミ」を受け取るか、その</font></font><code>DO</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ようなリクエストを分離する</font><font style="vertical-align: inherit;">ためにストアドプロシージャ/ </font><font style="vertical-align: inherit;">ブロックを作成する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短いトランザクションの条件では、ブロッキングがあっても長くは続かないことを理解しています。したがって、キーパラメータの設定を使用できます。</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">statement_timeout</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、「まあ、あなたはもっとずっと待つことができる」という私たちに合った価値でそれを再定義します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイムアウト後にロックを待つことができなかった場合は、私たちだけがそれを取得し</font></font><code>EXCEPTION</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。他のすべてのケースでは、少し待たなければならなかったとしても、結果を待っていたとしても、問題はなく、正常に動作し続け、誰もエラーを抱えていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、エラーが発生し、要求の結果を待ちすぎると「落ちる」場合でも、これは悲劇ではなく、ごく普通のことです。取引が短いので、無理</font></font><code>ROLLBACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なくやり直し、成功するまで何度も繰り返します。原則として、1回の繰り返しで十分です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/x6/l5/wl/x6l5wlryaudphkmry_bunou34es.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてができるだけ早く機能するように、データベースへの接続で「カードを修正」します。これは、たとえば、先週の間隔でソルトを計算する必要があり、同時に複数のスレッドを計算することに基づいて（もちろん、それぞれがデータベースへの個別の接続で）、1日のスレッドですべてのソルトを処理する方が効率的であることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは異なるトランザクションになるという事実にもかかわらず、競合する誰にもこの関係を与えない方が良いです。同じウェアハウスカードを計算するときは、「横に少し」を除いて、ほぼ同じデータ、同じインデックスセグメントをデータベースに向ける必要があるためです。そして、このデータはすでにPGプロセスのローカルメモリにあり、データベースへの接続に使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インフラストラクチャ全体がトランザクションモードでpgbouncerを介して機能するように構成されている場合、接続を修正できないという小さな問題があります。したがって、ベースに高い負荷がかかることが予想されるときにタスクが発生する場合は、ベースに</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接接続する</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことをお勧めします。これは、「逃げる」ことなく、「盲目的に」あなたに代わるものもありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/r9/uv/dk/r9uvdkmb3fwij3fl2cf1yclkque.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最大のパフォーマンスを達成するのに役立つ次のポイントは</font><font style="vertical-align: inherit;">、クライアントプロセスがデータベースと交換する</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データの量を最小限に抑えること</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。したがって、中間計算結果を格納するために、トランザクションの最後にクリアされる一時テーブルを使用します。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQLで一時テーブルを操作する機能と、それらを最も効果的に使用する方法について</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すでに</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">別の記事</font></a><font style="vertical-align: inherit;">があります</font><font style="vertical-align: inherit;">。</font></font></blockquote><br>
<img src="https://habrastorage.org/webt/dr/yl/lq/dryllqjss7ojmzeh3taz8rqcidk.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクセラレータの3番目の側面は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準備済みステートメントの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">構文はかなり単純</font></font><code>PREPARE/EXECUTE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですが、リクエストテキストの解析における大幅な遅延がなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時々繰り返され、パラメータ値のみが異なる数千の類似した単純なクエリがある場合、リクエストごとに最大4〜10ミリ秒、場合によってはゼロまで加速できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、実際にパフォーマンスの測定を開始する時点で、同じデータの2つのタイムスタンプ（もちろんミリ秒単位の精度）が得られる場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、データベースは毎回クエリのテキストを分析する必要がないため、接続を処理するプロセスによるCPUの負荷を1.5倍に簡単に削減できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/zm/xf/buzmxfeyfxo55yksedty5carh30.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
計算はマルチスレッドであるため、これらのフロー間でタスクを分散するために、これらのフローの同期ポイントが必要です。</font><font style="vertical-align: inherit;">私たちのケースでは、データベースに直接格納されているタスクの単一のテーブルキューを使用して実装しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
競争の激しいジョブキューを処理するという点では、3つの重要なポイントがあります。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業の全体を作業者間で分割する方法</font><b><font style="vertical-align: inherit;">の処理の分配</font></b></font></li>
<li><b><font style="vertical-align: inherit;"></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第三者のプロセスによるレコードの削除または挿入から</font><b><font style="vertical-align: inherit;">の競合他社に対する保護</font></b></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">負荷の最適化</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
は、作業の調整自体が「高価」であってはなりません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業を分散するには、主に2つの方法があります。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">push </font></font></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">選択したコーディネータープロセス</font></b></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
のみがキュー自体からデータを順次読み取り</font><font style="vertical-align: inherit;">、タスクを各ワーカーに個別に分散します。</font><font style="vertical-align: inherit;">これには2つの制限があります。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コーディネーターのスループットは有限で</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あり、スケーリングされません。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラーが発生した場合、すべての作業がすぐに増加します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コーディネーターがさらに読み取る方法を理解できるよう</font><font style="vertical-align: inherit;">に、キューは厳密に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単一方向である</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要があります</font></font></li>
</ul></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pull</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
独立した</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同一のワーカー</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が自分でデータをキューから引き出します。</font><font style="vertical-align: inherit;">この場合、キューは任意に変更できます-オプションだけです！</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/xw/4z/4g/xw4z4gifmozcvraq7qs8yhbchf4.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLの競合するプロダクションキューオプションは、最初に提案されたモデルに従ってアドバイザリロックを使用して実装できます。 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー・コテロフ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1つ</font><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://web.archive.org/web/20191031145956/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アーカイブ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アドバイザリロック、関連する問題、および解決策の詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ファンタスティックアドバイザリロックとその場所」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の記事を参照してください</font><font style="vertical-align: inherit;">。</font></font></blockquote><blockquote>    «» -     MVCC       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">«DBA:   VACUUM —   »</a>.</blockquote><br>
<img src="https://habrastorage.org/webt/5z/ja/ku/5zjakuajezychl9uo1sqfedmfpq.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセスのアクションはプロセスに基づいて競合するため、キューを処理するときだけでなく、データ自体を処理するときにも問題が発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、計算の繰り返しの開始時にまだ存在していた最後のレコードを誰かが削除する時間がすでにある場合、計算された残差に「穴」が生じる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような状況から身を守るために、私たちはそれを使用してい</font></font><code>SELECT ... FOR UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。この場合、競合他社</font></font><code>DELETE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は私たちの足元から「引っ張る」ことができ</font><font style="vertical-align: inherit;">ません</font><font style="vertical-align: inherit;">。もっと正確に言えば、それはロックに留まろうとします-ええ、ハングさせてください、私たちはそれを長期間保持しませんが、計算されたバランスのチェーン全体は常に固体状態です。</font></font><br>
<img src="https://habrastorage.org/webt/e6/ho/r7/e6hor7qvrfo3a8hyaxvy1vjbumi.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、保護が常に役立つとは限りません。たとえば、ユーザーが現在カウントしている「量子」の動きを同時に削除または追加した場合などです。つまり、計算されたことはなく、ブロックされる可能性のある残高の記録はありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hb/u9/zk/hbu9zk9hnbay1v6x6x4cpxbotqe.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、それでも「量子」の動きの状態が変化したことを知る機会があります。これを行うには、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バージョンをキューレコード</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">入力するだけです。</font><b><font style="vertical-align: inherit;">キューレコード</font></b><font style="vertical-align: inherit;">は、カード上での移動を伴う各操作中にトリガーによって増分されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トランザクションの最初にキューからエントリとともにそれを減算し、最後に再減算し</font></font><code>ROLLBACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">それらが一致しない場合は、に進み</font><font style="vertical-align: inherit;">ます。はい、正確に何がどのように変更されたかを理解することはできませんが、トランザクションが非常に高速であるため、それも必要ありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dl/nk/ae/dlnkaezeukgcee9u83d_z2qvr4o.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、これらの非常に高速なトランザクションがベースを「ヒット」しないようにするには、負荷をかける必要があります。そして、少なくとも、誰もそれを必要としないまで働かないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかのストリームですべてを計算できますが、通常、計算用のカードは1つだけであることが判明し、「ネイバー」に無理に反復させる-ベースのみをロードします。したがって、</font><font style="vertical-align: inherit;">キューに挿入するためのトリガーが</font><font style="vertical-align: inherit;">新しい何かが出現</font><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">たことを</font><font style="vertical-align: inherit;">送信するまで、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらのスレッドを「スリープ」に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">することをお勧めします</font></font><code>NOTIFY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際に示されているように、ほとんどの場合、最初のスレッドはすでに計算を迅速に処理しているため、追加のスレッドを開始する時間すらありません。したがって、ベースへの負荷は最小限であり、作業がまだ到達しているフローからのみ発生します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c8/d3/-i/c8d3-iixe3lr61u3bwxo9n4qo2g.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ベースの負荷を最適化できる2番目のポイントは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">処理の開始の遅延</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。アイデアは、信号が到着したときでも、ストリームが同時にすべて中断して「ストーム」を作成するべきではないということです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、通常、フルロードの場合は存在しないため、作業を取得できるのは原則として1つだけです。したがって、</font><font style="vertical-align: inherit;">作業がまだある間、たとえば10ミリ秒の間隔で、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいワーカーを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">落ち着いて</font><b><font style="vertical-align: inherit;">「ダンプ」</font></b><font style="vertical-align: inherit;">でき</font><font style="vertical-align: inherit;">ます。最初の10ミリ秒ですべてを実行できた場合、追加のフローは関与しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、非常にまれなケースですが、このアプローチは最大処理スループットを低下させる可能性がありますが、ほとんどの一般的な状況では、リソースを節約し、ピーク負荷を回避します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、スレッドの1つで突然エラーが発生した場合は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、少し待って</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">みましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">理由が私たちを妨げるある種の閉塞であった場合、おそらくこの間に「解決」する時間があり、ネイバーフローは、「休憩」している間、キューがアイドル状態になることを許可しません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ok/8u/n2/ok8un28nd7ayd90zf_v8zdykuss.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、これらのアプローチにより、データベース/ BLの総負荷を約4分の1に削減できました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、もう一度、私は皆に強く勧めます- </font><font style="vertical-align: inherit;">あなたが到達できる</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのもの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><b><font style="vertical-align: inherit;">測定し</font></b><font style="vertical-align: inherit;">てください：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソリューションの帯域幅（op / s）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キューの長さとアクティブなワーカーの数</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エントリからキューへの処理前の遅延</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「鉄」に作成される実際の負荷</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja504430/index.html">Everyday Life Tinkoff Security Operations Center：シングルブートローダー分析</a></li>
<li><a href="../ja504434/index.html">親のための教育プログラム：インターネットで子供を危険から守る方法</a></li>
<li><a href="../ja504438/index.html">1週間あたり30ミタップ。2020年夏シーズンオープン</a></li>
<li><a href="../ja504442/index.html">Linuxカーネルでの再配置について少し</a></li>
<li><a href="../ja504444/index.html">docker multi-stageを使用してWindowsイメージを構築する</a></li>
<li><a href="../ja504448/index.html">ゲーマージェネレーションII</a></li>
<li><a href="../ja504450/index.html">最新のJavaScript：側面図</a></li>
<li><a href="../ja504452/index.html">オントロジーがレイヤー2を発表、より統合されたパブリックチェーンプラットフォームに貢献</a></li>
<li><a href="../ja504454/index.html">Web開発者にとって最高のGitHubリポジトリ</a></li>
<li><a href="../ja504456/index.html">LXDコンテナで開発環境を分離する</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>