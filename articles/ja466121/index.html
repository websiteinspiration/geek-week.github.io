<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍🏾 ✌️ 〰️ ポリフォニーをサポートするウェーブテーブル方式を使用したAVRマイクロコントローラーでのサウンド生成 🚣🏿 🗒️ 🤹🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="AVRマイクロコントローラーはかなり安価で普及しています。おそらく、ほとんどすべての組み込み開発者がそれらから始めます。そしてアマチュアの間では、Arduinoのボールが支配し、その中心は通常ATmega328pです。きっと多くの人が疑問に思いました。どうすればそれらを鳴らすことができますか？
 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ポリフォニーをサポートするウェーブテーブル方式を使用したAVRマイクロコントローラーでのサウンド生成</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466121/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVRマイクロコントローラーはかなり安価で普及しています。</font><font style="vertical-align: inherit;">おそらく、ほとんどすべての組み込み開発者がそれらから始めます。</font><font style="vertical-align: inherit;">そしてアマチュアの間では、Arduinoのボールが支配し、その中心は通常ATmega328pです。</font><font style="vertical-align: inherit;">きっと多くの人が疑問に思いました。どうすればそれらを鳴らすことができますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
既存のプロジェクトを見ると、いくつかのタイプがあります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方形パルス発生器。</font><font style="vertical-align: inherit;">割り込みでPWMまたはヤンクピンを使用して生成します。</font><font style="vertical-align: inherit;">いずれにしても、非常に特徴的なきしみ音が得られます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MP3デコーダーなどの外部機器を使用する。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PWMを使用して、PCMまたはADPCM形式で8ビット（場合によっては16ビット）のサウンドを出力します。</font><font style="vertical-align: inherit;">マイクロコントローラのメモリは明らかにこれには十分ではないため、通常、SDカードを使用します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PWMを使用して、MIDIなどのウェーブテーブルに基づいてサウンドを生成します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
後者のタイプは、私にとって特に興味深いものでした。</font><font style="vertical-align: inherit;">追加の機器はほとんど必要ありません。</font><font style="vertical-align: inherit;">私は自分のオプションをコミュニティに提示します。</font><font style="vertical-align: inherit;">まず、小さなデモ：</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://w.soundcloud.com/player/" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
猫の下で興味を持ってください。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、機器：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ATmega8またはATmega328。</font><font style="vertical-align: inherit;">他のATmegaへの移植は難しくありません。</font><font style="vertical-align: inherit;">ATtinyについてもですが、後で詳しく説明します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抵抗器;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンデンサ;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スピーカーまたはヘッドフォン。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">栄養;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それのように見えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マイクロコントローラーの出力には、スピーカー付きのシンプルなRC回路が接続されています。出力は、サンプリング周波数31250Hzの8ビットサウンドです。 8 MHzの水晶周波数では、最大5つのサウンドチャネル+パーカッション用の1つのノイズチャネルを生成できます。この場合、プロセッサ時間のほとんどすべてが使用されますが、バッファを満たした後、プロセッサはサウンドに加えて何か便利なもので占有されます。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/JwqY7FoxYsk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例はATmega8メモリに完全に適合し、5チャネル+ノイズは8 MHzの水晶周波数で処理され、ディスプレイにアニメーションを表示する時間はほとんどありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、ライブラリが通常の音楽のポストカードとしてだけでなく、通知など、既存のプロジェクトにサウンドを接続するためにも使用できることを示したかったのです。</font><font style="vertical-align: inherit;">また、サウンドチャネルを1つだけ使用する場合でも、通知は単純なツイーターよりもはるかに興味深いものになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今、詳細...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウェーブテーブルまたはウェーブテーブル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数学は非常に簡単です。たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トーン（t）= sin（t * freq /（2 * Pi））</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの周期的なトーン関数があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基音の音量を時間とともに変化させる関数もあります。たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音量（t）= e ^（-t）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も単純なケースでは、楽器の音は、これらの機能の製品である</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機器（T）=トーン（T）*ボリューム（T） </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなグラフ上で、それをすべてルックス何か：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pn/dp/pi/pndppihozomu4ep_fxzcho44xx8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、現在鳴っているすべての楽器を取ると、いくつかのボリューム要素とそれらをまとめます（疑似コード）：</font></font><br>
<br>
<pre><code class="cmake hljs">for (i = <span class="hljs-number">0</span>; i &lt; CHANNELS; i++) {<font></font>
  value += channels[i].tone(t) * channels[i].volume(t) * channels[i].volume;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オーバーフローしないようにボリュームを選択するだけで済みます。</font><font style="vertical-align: inherit;">そして、これでほぼすべてです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノイズチャネルはほとんど同じように機能しますが、トーン関数の代わりに、疑似ランダムシーケンスジェネレーターを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーカッションは、約50〜70 Hzのノイズチャネルと低周波の混合です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、この方法で音質を実現することは困難です。</font><font style="vertical-align: inherit;">しかし、すべてに8キロバイトしかありません。</font><font style="vertical-align: inherit;">これが許されることを願っています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8ビットから何を絞り込めますか</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、ATmega8に焦点を合わせました。</font><font style="vertical-align: inherit;">外部クオーツがない場合、8 MHzの周波数で動作し、8ビットPWMを備えているため、8000000/256 = 31250 Hzの基本サンプリング周波数が得られます。</font><font style="vertical-align: inherit;">1つのタイマーはPWMを使用して音声を出力し、オーバーフローすると、割り込みが発生して次の値がPWMジェネレーターに送信されます。</font><font style="vertical-align: inherit;">したがって、割り込みオーバーヘッド、サウンドチャネルパラメータの更新、次のノートを演奏する必要がある時間の追跡など、すべてのサンプル値を計算するための256クロックサイクルがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最適化のために、次のトリックを積極的に使用します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8ビットプロセッサを使用しているので、変数を同じにしようとします。</font><font style="vertical-align: inherit;">時には16ビットを使用します。</font></font></li>
<li>       .      ,  –  ,    / .</li>
<li>         .       ,   .   ,    ,         - .</li>
<li>   C    inline.  ,    .</li>
<li>    ,    ,  .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、時間を4ミリ秒の間隔に分割します（私はそれらをティックと呼びます）。</font><font style="vertical-align: inherit;">31250Hzのサンプリング周波数では、ティックごとに125サンプルを取得します。</font><font style="vertical-align: inherit;">各サンプルを読み取る必要があるという事実は、すべてのサンプルと残りをカウントする必要があります-ティックごとに1回以下。</font><font style="vertical-align: inherit;">たとえば、1ティック内では、楽器の音量は一定になります：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">楽器（t）=トーン（t）* currentVolume</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">currentVolume自体は、ボリューム（t）とサウンドチャネルの選択されたボリュームを考慮して、ティックごとに1回再計算されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純な8ビットの制限に基づいて、4msのティック持続時間が選択されました。8ビットのサンプルカウンターを使用すると、最大64 kHzのサンプリング周波数で作業できます。8ビットのティックカウンターを使用すると、最大1秒の時間を測定できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかのコード</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チャネル自体は次の構造で表されます。</font></font><br>
<br>
<pre><code class="cmake hljs">typedef struct<font></font>
{<font></font>
    // Info about wave<font></font>
    const int8_t* waveForm; // Wave table array<font></font>
    uint16_t waveSample; // High byte is an index in waveForm array<font></font>
    uint16_t waveStep; // Frequency, how waveSample is changed in time<font></font>
<font></font>
    // Info about volume envelope<font></font>
    const uint8_t* volumeForm; // Array of volume change in time<font></font>
    uint8_t volumeFormLength; // Length of volumeForm<font></font>
    uint8_t volumeTicksPerSample; // How many ticks should pass before index of volumeForm is changed<font></font>
    uint8_t volumeTicksCounter; // Counter for volumeTicksPerSample<font></font>
<font></font>
    // Info about volume<font></font>
    uint8_t currentVolume; // Precalculated volume for current tick<font></font>
    uint8_t instrumentVolume; // Volume of channel<font></font>
} waveChannel;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
条件付きで、ここのデータは3つの部分に分かれています。</font></font><br>
<br>
<ol>
<li>    , , .<br>
 <br>
waveForm:    tone(t):     256 .  ,  . <br>
 <br>
waveSample:        waveForm.<br>
 <br>
waveStep:  ,   waveSample      .<br>
 <br>
    :<br>
 <br>
 <pre><code class="cmake hljs">int8_t tone = channelData.waveForm[channelData.waveSample &gt;&gt; <span class="hljs-number">8</span>];<font></font>
channelData.waveSample += channelaData.waveStep;<font></font>
<span class="hljs-keyword">return</span> tone * channelData.currentVolume;</code></pre><br>
</li>
<li>   .      .      ,     ,   .    :<br>
 <br>
 <pre><code class="cmake hljs"><span class="hljs-keyword">if</span> ((channel-&gt;volumeTicksCounter--) == <span class="hljs-number">0</span> &amp;&amp; channel-&gt;volumeFormLength &gt; <span class="hljs-number">0</span>) {<font></font>
    channel-&gt;volumeTicksCounter = channel-&gt;volumeTicksPerSample;<font></font>
    channel-&gt;volumeFormLength--;<font></font>
    channel-&gt;volumeForm++;<font></font>
}<font></font>
channel-&gt;currentVolume = channel-&gt;volumeForm * channel-&gt;instrumentVolume &gt;&gt; <span class="hljs-number">8</span>;</code></pre><br>
</li>
<li>       .<br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意：波形は8ビット、ボリュームも8ビット、結果は16ビットです。</font><font style="vertical-align: inherit;">パフォーマンスが少し低下すると、サウンドを（ほぼ）16ビットにすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パフォーマンスのために戦うとき、私はいくつかの黒魔術に頼らなければなりませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例番号1.チャネルのボリュームを再計算する方法：</font></font><br>
<br>
<pre><code class="cmake hljs"><span class="hljs-keyword">if</span> ((tickSampleCounter--) == <span class="hljs-number">0</span>) {<font></font>
    //   <font></font>
    tickSampleCounter = SAMPLES_PER_TICK – <span class="hljs-number">1</span>;<font></font>
    //   -<font></font>
}<font></font>
// volume recalculation should no be done so often for all channels<font></font>
<span class="hljs-keyword">if</span> (tickSampleCounter &lt; CHANNELS_SIZE) {<font></font>
    recalculateVolume(channels[tickSampleCounter]);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、すべてのチャネルはティックごとにボリュームを再カウントしますが、同時にはカウントしません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例2。静的な構造でチャネル情報を保持する方が、配列よりも安価です。</font><font style="vertical-align: inherit;">wavechannel.hの実装の詳細には触れませんが、このファイルは、さまざまなプリプロセッサディレクティブを使用して、コードに数回（チャネル数と同じ数）挿入されます。</font><font style="vertical-align: inherit;">各挿入により、新しいグローバル変数と新しいチャネル計算関数が作成され、メインコードにインライン化されます。</font></font><br>
<br>
<pre><code class="cmake hljs"><span class="hljs-comment">#if CHANNELS_SIZE &gt;= 1</span><font></font>
    val += channel0NextSample();<font></font>
<span class="hljs-comment">#endif</span>
<span class="hljs-comment">#if CHANNELS_SIZE &gt;= 2</span><font></font>
    val += channel1NextSample();<font></font>
<span class="hljs-comment">#endif</span><font></font>
…<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例番号3.少し遅れて次のノートの演奏を開始すると、誰も気付かないでしょう。</font><font style="vertical-align: inherit;">状況を想像してみましょう。プロセッサを何かで取り上げ、この間、バッファはほとんど空でした。</font><font style="vertical-align: inherit;">次に、それを埋め始めます。突然、新しいメジャーが来ていることがわかります。現在のノートを更新したり、配列から次のものを読み込んだりする必要があります。</font><font style="vertical-align: inherit;">時間がない場合、特徴的な吃音が発生します。</font><font style="vertical-align: inherit;">バッファに古いデータを少し入れてから、チャネルの状態を更新することをお勧めします。</font></font><br>
<br>
<pre><code class="cmake hljs"><span class="hljs-keyword">while</span> ((samplesToWrite) &gt; <span class="hljs-number">4</span>) { //         <font></font>
    fillBuffer(SAMPLES_PER_TICK); //     - <font></font>
    updateMusicData(); //   <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
良い方法では、ループの後にバッファーを再充填する必要がありますが、ほとんどすべてがインラインであるため、コードのサイズは著しく増大します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音楽</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8ビットのティックカウンターが使用されます。ゼロに達すると、新しい小節が始まり、カウンターには小節の持続時間（ティック単位）が割り当てられ、少し後に音楽コマンドの配列がチェックされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
音楽データはバイトの配列に格納されます。それは次のように書かれています：</font></font><br>
<br>
<pre><code class="cmake hljs">const uint8_t demoSample[] PROGMEM = {<font></font>
    DATA_TEMPO(<span class="hljs-number">160</span>), // <span class="hljs-keyword">Set</span> beats per minute<font></font>
    DATA_INSTRUMENT(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), // Assign instrument <span class="hljs-number">1</span> (see setSample) to channel <span class="hljs-number">0</span>
    DATA_INSTRUMENT(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), // Assign instrument <span class="hljs-number">1</span> (see setSample) to channel <span class="hljs-number">1</span>
    DATA_VOLUME(<span class="hljs-number">0</span>, <span class="hljs-number">128</span>), // <span class="hljs-keyword">Set</span> volume <span class="hljs-number">128</span> to channel <span class="hljs-number">0</span>
    DATA_VOLUME(<span class="hljs-number">1</span>, <span class="hljs-number">128</span>), // <span class="hljs-keyword">Set</span> volume <span class="hljs-number">128</span> to channel <span class="hljs-number">1</span>
    DATA_PLAY(<span class="hljs-number">0</span>, NOTE_A4, <span class="hljs-number">1</span>), // Play note A4 <span class="hljs-keyword">on</span> channel <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> wait <span class="hljs-number">1</span> beat <font></font>
    DATA_PLAY(<span class="hljs-number">1</span>, NOTE_A3, <span class="hljs-number">1</span>), // Play note A3 <span class="hljs-keyword">on</span> channel <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> wait <span class="hljs-number">1</span> beat<font></font>
    DATA_WAIT(<span class="hljs-number">63</span>), // Wait <span class="hljs-number">63</span> beats<font></font>
    DATA_END() // End of data stream<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DATA_で始まるものはすべて、パラメーターを必要な数のデータバイトに拡張するプリプロセッサーマクロです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、DATA_PLAYコマンドは2バイトに拡張されて保存されます。コマンドマーカー（1ビット）、次のコマンドの前のポーズ（3ビット）、音符を演奏するチャンネル番号（4ビット）、音符に関する情報（8ビット）。</font><font style="vertical-align: inherit;">最も重要な制限は、このコマンドを最大7小節の長い一​​時停止に使用できないことです。</font><font style="vertical-align: inherit;">さらに必要な場合は、DATA_WAITコマンドを使用する必要があります（最大63クロックサイクル）。</font><font style="vertical-align: inherit;">残念ながら、マクロパラメータに応じて、マクロを配列の異なるバイト数に展開できるかどうかはわかりませんでした。</font><font style="vertical-align: inherit;">と警告しても表示方法がわかりません。</font><font style="vertical-align: inherit;">多分あなたは私に言う。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
demosディレクトリには、さまざまなマイクロコントローラーの例がいくつかあります。</font><font style="vertical-align: inherit;">しかし、要するに、ここにreadmeからの断片があります。</font></font><br>
<br>
<pre><code class="cmake hljs"><span class="hljs-comment">#include "../../microsound/devices/atmega8timer1.h"</span>
<span class="hljs-comment">#include "../../microsound/micromusic.h"</span><font></font>
<font></font>
// Make some settings<font></font>
<span class="hljs-comment">#define CHANNELS_SIZE   5</span>
<span class="hljs-comment">#define SAMPLES_SIZE    16</span>
<span class="hljs-comment">#define USE_NOISE_CHANNEL</span><font></font>
<font></font>
initMusic(); // Init music data <span class="hljs-keyword">and</span> sound control<font></font>
sei(); // Enable interrupts, silence sound should be generated<font></font>
setSample(<span class="hljs-number">0</span>, instrument1); // Use instrument1 as sample <span class="hljs-number">0</span>
setSample(<span class="hljs-number">1</span>, instrument2); // Init all other instruments…<font></font>
<font></font>
playMusic(mySong); // Start playing music at pointer mySong<font></font>
<span class="hljs-keyword">while</span> (!isMusicStopped) {<font></font>
    fillMusicBuffer(); // Fill music buffer in loop<font></font>
    // Do some other stuff<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
音楽以外に何かしたい場合は、BUFFER_SIZEを使用してバッファのサイズを増やすことができます。</font><font style="vertical-align: inherit;">バッファサイズは2 ^ nにする必要がありますが、残念ながら、サイズが256の場合、パフォーマンスが低下します。</font><font style="vertical-align: inherit;">私がそれを理解するまで。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生産性を上げるには、外部クオーツで周波数を上げ、チャネル数を減らし、サンプリング周波数を下げます。</font><font style="vertical-align: inherit;">最後のトリックでは、音質の低下をある程度補う線形補間を使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
遅延は推奨されません。</font><font style="vertical-align: inherit;">CPU時間が浪費されます。</font><font style="vertical-align: inherit;">代わりに、独自のメソッドが</font><i><font style="vertical-align: inherit;">microsound / delay.hファイルに</font></i><font style="vertical-align: inherit;">実装されてい</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、一時停止自体に加えて、バッファの充填に従事しています。</font><font style="vertical-align: inherit;">この方法は、短いポーズではあまり正確に機能しない可能性がありますが、長いポーズでは多少まともです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自分の音楽を作る</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コマンドを手動で記述する場合は、何が起こるかを聞く必要があります。</font><font style="vertical-align: inherit;">特に変更がある場合は、各変更をマイクロコントローラーに流し込むのは便利ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
かなりおもしろいサービス</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wavepot.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります。オンラインJavaScriptエディターでは、サウンド信号の機能を時々設定する必要があり、この信号がサウンドカードに出力されます。</font><font style="vertical-align: inherit;">最も単純な例：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dsp</span>(<span class="hljs-params">t</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">0.1</span> * <span class="hljs-built_in">Math</span>.sin(<span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI * t * <span class="hljs-number">440</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンジンをJavaScriptに移植しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demos / wavepot.jsにあり</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">ファイルの内容をエディター</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wavepot.comに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">挿入する必要があり、</font><font style="vertical-align: inherit;">実験を行うことができます。</font><font style="vertical-align: inherit;">データをsoundData配列に書き込み、リッスンし、保存することを忘れないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数Simulate8bitsについても言及する必要があります。</font><font style="vertical-align: inherit;">彼女はその名前によれば、8ビットのサウンドをシミュレートします。</font><font style="vertical-align: inherit;">突然ドラムの音がしているように見えて、音が静かなダンピングされた楽器にノイズが現れる場合、これは8ビットサウンドの歪みです。</font><font style="vertical-align: inherit;">このオプションを無効にして、違いを聞くことができます。</font><font style="vertical-align: inherit;">音楽に沈黙がない場合、問題はあまり目立ちません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接続</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純なバージョンでは、回路は次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">+5V    <font></font>
 ^      MCU<font></font>
 |   +-------+<font></font>
 +---+VC     |    R1<font></font>
     |    Pin+---/\/\--+-----&gt; OUT<font></font>
     |       |         |<font></font>
 +---+GN     |        === C1<font></font>
 |   +-------+         |<font></font>
 |                     |<font></font>
--- Grnd              --- Grnd</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出力ピンはマイクロコントローラに依存します。</font><font style="vertical-align: inherit;">抵抗R1とコンデンサC1は、負荷、アンプ（存在する場合）などに基づいて選択する必要があります。</font><font style="vertical-align: inherit;">私は電子工学者ではないので、公式は教えません。公式はオンライン計算機で簡単にグーグルできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R1 = 130オーム、C1 = 0.33μFです。</font><font style="vertical-align: inherit;">出力には、通常の中国のヘッドフォンを接続します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16ビットの音はどうでしたか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先に述べたように、8ビットの数値（周波数とボリューム）を2つ乗算すると、16ビットの数値になります。</font><font style="vertical-align: inherit;">8ビットに丸めることはできませんが、2つのPWMチャネルで両方のバイトを出力します。</font><font style="vertical-align: inherit;">これらの2つのチャネルを1/256の割合で混合すると、16ビットのサウンドを得ることができます。</font><font style="vertical-align: inherit;">8ビットとの違いは、1つの楽器だけが鳴る瞬間のスムーズなフェードサウンドとドラムで特に聞きやすいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16ビット出力接続：</font></font><br>
<br>
<pre><code class="plaintext hljs">+5V    <font></font>
 ^      MCU<font></font>
 |   +-------+<font></font>
 +---+VCC    |    R1<font></font>
     |   PinH+---/\/\--+-----&gt; OUT<font></font>
     |       |         |<font></font>
     |       |    R2   |<font></font>
     |   PinL+---/\/\--+<font></font>
 +---+GND    |         |<font></font>
 |   +-------+        === C1<font></font>
 |                     |<font></font>
--- Grnd              --- Grnd</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの出力を正しく混合することが重要です。R2抵抗はR1抵抗の256倍でなければなりません。</font><font style="vertical-align: inherit;">正確であるほど良い。</font><font style="vertical-align: inherit;">残念ながら、誤差が1％の抵抗でさえ、必要な精度が得られません。</font><font style="vertical-align: inherit;">ただし、抵抗をあまり正確に選択しなくても、歪みは著しく減衰する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、16ビットサウンドを使用すると、パフォーマンスが低下し、割り当てられた256クロックサイクルで5チャネル+ノイズを処理できなくなります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arduinoで可能ですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、できます。</font><font style="vertical-align: inherit;">ATmega328pには中国のナノクローンしかありません。</font><font style="vertical-align: inherit;">ほとんどの場合、ATmega328pの他のarduinsも機能するはずです。</font><font style="vertical-align: inherit;">ATmega168は同じﾀｲ control / control ﾝﾀ制御registers ｼﾞｽﾀを持っているようです。</font><font style="vertical-align: inherit;">ほとんどの場合、変更なしで機能します。</font><font style="vertical-align: inherit;">チェックする必要がある他のマイクロコントローラーでは、ドライバーを追加する必要がある場合があります。</font><i><font style="vertical-align: inherit;">demos / arduino328pに</font></i><font style="vertical-align: inherit;">スケッチ</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
があり</font><font style="vertical-align: inherit;">ますが、Arduino IDEで正常に開くには、プロジェクトのルートにコピーする必要があります。</font><font style="vertical-align: inherit;">
この例では、16ビットのサウンドが生成され、出力D9およびD10が使用されます。</font><font style="vertical-align: inherit;">簡単にするために、8ビットサウンドに制限し、1つのD9出力のみを使用できます。</font><font style="vertical-align: inherit;">
ほとんどすべてのarduinは16 MHzで動作するため、必要に応じてチャネル数を8に増やすことができます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ATtinyはどうですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ATtinyにはハードウェア乗算はありません。</font><font style="vertical-align: inherit;">コンパイラが使用するソフトウェア乗算は非常に遅く、使用すべきではありません。</font><font style="vertical-align: inherit;">最適化されたアセンブラー挿入を使用すると、パフォーマンスはATmegaの2倍低下します。</font><font style="vertical-align: inherit;">ATtinyを使用する意味は全くないように思えますが... ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のATtinyには周波数逓倍器、PLLがあります。</font><font style="vertical-align: inherit;">これは、そのようなマイクロコントローラーには2つの興味深い機能があることを意味します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PWMジェネレーターの周波数は64 MHzで、これは250 kHzのPWM周期を提供します。これは、8 MHzでの31 250 Hzまたは任意のATmegaの16 MHzでの水晶での62500 Hzよりもはるかに優れています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じ周波数逓倍器により、水晶は水晶なしで16 MHzでクロックできます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、結論：いくつかのATtinyは音を生成するために使用できます。同じ5つの計器+ノイズチャネルを処理できますが、16 MHzであり、外部クォーツは必要ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不利な点は、周波数をこれ以上上げることができず、計算がほとんどの時間を占めることです。リソースを解放するには、チャネル数またはサンプルレートを減らします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つのマイナス点は、一度に2つのタイマーを使用する必要があることです。1つはPWM用、もう1つは割り込み用です。これは通常、タイマーが終了する場所です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が知っているPLLマイクロコントローラーのうち、ATtiny85 / 45/25（8レッグ）、ATtiny861 / 461/261（20レッグ）、ATtiny26（20レッグ）に言及できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリに関しては、ATmegaとの違いは大きくありません。</font><font style="vertical-align: inherit;">8kbでは、いくつかの楽器とメロディーが完全に収まります。</font><font style="vertical-align: inherit;">4kbでは、1〜2の楽器と1〜2の曲を置くことができます。</font><font style="vertical-align: inherit;">何かを2キロバイトに収めるのは難しいですが、本当にやりたいのなら、可能です。</font><font style="vertical-align: inherit;">メソッドのリンクを解除し、チャンネルのボリュームコントロールなどの一部の機能を無効にし、サンプリング周波数とチャンネル数を減らす必要があります。</font><font style="vertical-align: inherit;">一般的にはアマチュア向けですが、ATtiny26の実用例があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題があります。そして最大の問題はコンピューティングの速度です。コードは完全にCで記述されており、ATtiny用の小さなアセンブラ乗算挿入が含まれています。最適化はコンパイラに与えられ、時々奇妙に振る舞います。何かに影響を与えないように見える小さな変更を加えると、パフォーマンスが著しく低下する可能性があります。さらに、-Osから-O3に変更しても、必ずしも効果があるとは限りません。そのような例の1つは、256バイトのバッファーの使用です。特に不愉快なのは、新しいバージョンのコンパイラでは、同じコードでパフォーマンスが低下しないという保証がないことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の問題は、次のノートの前の減衰メカニズムがまったく実装されていないことです。それら。あるチャンネルでノートを別のノートに置き換えると、古い音が突然途切れ、小さなクリック音が聞こえる場合があります。生産性を失うことなくこれを取り除く方法を見つけたいのですが、これまでのところ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
音量をスムーズに増減するためのコマンドはありません。短い通知音の場合は特に重要です。最終的には、音が急激に途切れないように音量をすばやくフェードインする必要があります。問題の一部は、手動で音量と短いポーズを設定する一連のコマンドを記述することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
選択されたアプローチは、原則として、楽器に自然なサウンドを提供することができません。より自然なサウンドを得るには、楽器のサウンドをアタックサスティンリリースに分割し、少なくとも最初の2つのパートを使用し、1つの振動周期よりもはるかに長い持続時間を使用する必要があります。ただし、ツールのデータにはさらに多くの情報が必要になります。たとえば、256ではなく32バイトの短いウェーブテーブルを使用するというアイデアがありましたが、補間を行わないと音質が大幅に低下し、補間を使用するとパフォーマンスが低下します。そして、さらに8ビットのサンプリングでは、明らかに音楽には不十分ですが、これは回避できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バッファサイズは256サンプルに制限されています。</font><font style="vertical-align: inherit;">これは約8ミリ秒に相当し、これは他のタスクに与えることができる最大の積分時間です。</font><font style="vertical-align: inherit;">同時に、タスクの実行は依然として割り込みによって定期的に中断されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準の遅延の置き換えは、短い一時停止に対しては正確に機能しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは完全なリストではないと思います。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Githubリンク</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PWMフィルターの計算</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここからいくつかのアイデアとデモ曲が取られました</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja466105/index.html">RoadRunnerによるMagento Rest APIのオーバークロック</a></li>
<li><a href="../ja466107/index.html">日曜大工のスマートホームシステム</a></li>
<li><a href="../ja466109/index.html">pwnable.kr 22による問題解決-ブレインファック。Ret2libc攻撃</a></li>
<li><a href="../ja466111/index.html">Cisco 200-125 CCNA v3.0のトレーニング。32日目。パスワード回復、XMODEM / TFTPDNLD、およびシスコライセンスアクティベーション</a></li>
<li><a href="../ja466113/index.html">mb_detect_encodingの代わりにPHPでテキストエンコーディングを定義する</a></li>
<li><a href="../ja466123/index.html">高さ。重量。3人の隣人</a></li>
<li><a href="../ja466127/index.html">コラ原子力発電所または原子炉に立っています</a></li>
<li><a href="../ja466129/index.html">ガソリン、バッテリー、水素の輸送効率</a></li>
<li><a href="../ja466135/index.html">メガパック：Factorio開発者が200プレーヤーのマルチプレーヤー問題をどのように解決したか</a></li>
<li><a href="../ja466139/index.html">ブロックチェーン熱の廃墟またはリソース割り当ての実際的な利点に関する応用技術</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>