<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏽 🌳 📷 Redisストリーム-メッセージングシステムの信頼性とスケーラビリティ 🙋🏼 ㊗️ 🧘🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Redis Streamは、バージョン5.0のリリースでRedisに導入された新しい抽象データ型です。
 概念的には、Redis Streamは、エントリを追加できるリストです。各エントリには一意の識別子があります。デフォルトでは、識別子は自動的に生成され、タイムスタンプが含まれます。したがって、U...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Redisストリーム-メッセージングシステムの信頼性とスケーラビリティ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456270/"><img src="https://habrastorage.org/webt/4z/my/lg/4zmylgmptsa7q0dqxbekaq4gvai.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis Streamは、バージョン5.0のリリースでRedisに導入された新しい抽象データ型です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
概念的には、Redis Streamは、エントリを追加できるリストです。</font><font style="vertical-align: inherit;">各エントリには一意の識別子があります。</font><font style="vertical-align: inherit;">デフォルトでは、識別子は自動的に生成され、タイムスタンプが含まれます。</font><font style="vertical-align: inherit;">したがって、Unix tail -fコマンドがログファイルを読み取り、新しいデータを見込んでフリーズするため、時間で記録範囲を要求したり、ストリームに到着した新しいデータを受信したりできます。</font><font style="vertical-align: inherit;">多くの「tail -f」プロセスが互いに競合することなく同時にファイルを読み取ることができるため、複数のクライアントが同時にストリームをリッスンできることに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいデータ型のすべての利点を理解するために、Redis Streamの機能を部分的に繰り返す、長年存在するRedis構造を簡単に思い出してみましょう。</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">歴史的な遠足</font></font></h1><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis PUB / SUB</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis Pub / Subは、Key-Valueストレージにすでに組み込まれているシンプルなメッセージングシステムです。</font><font style="vertical-align: inherit;">ただし、簡単にするために支払う必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何らかの理由でパブリッシャーが失敗した場合、パブリッシャーはすべてのサブスクライバーを失います</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パブリッシャーは、すべてのサブスクライバーの正確なアドレスを知る必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データが処理されるよりも速く公開された場合、パブリッシャーはサブスクライバーに過負荷をかける可能性があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージは、パブリッシャーの配信後すぐに、パブリッシャーのバッファーから削除されます。パブリッシャーが配信したサブスクライバーの数や、メッセージの処理速度は関係ありません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのサブスクライバーが同時にメッセージを受信します。</font><font style="vertical-align: inherit;">サブスクライバー自身は、同じメッセージを処理する方法について、どういうわけか互いに合意する必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブスクライバーによるメッセージの正常な処理を確認するための組み込みメカニズムはありません。</font><font style="vertical-align: inherit;">サブスクライバーがメッセージを受信し、処理中に脱落した場合、パブリッシャーはそのことを知りません。</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redisリスト</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redisリストは、ロック読み取りコマンドをサポートするデータ構造です。</font><font style="vertical-align: inherit;">リストの最初または最後からメッセージを追加して読むことができます。</font><font style="vertical-align: inherit;">この構造に基づいて、分散システムに適したスタックまたはキューを作成できます。これでほとんどの場合十分です。</font><font style="vertical-align: inherit;">Redis Pub / Subとの主な違い：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージは1つのクライアントに配信されます。</font><font style="vertical-align: inherit;">読み取りによってブロックされた最初のクライアントは、最初にデータを受信します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clintは各メッセージの読み取り操作を開始する必要があります。</font><font style="vertical-align: inherit;">リストはクライアントについて何も知りません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージは、誰かが数えるか、明示的に削除するまで保存されます。</font><font style="vertical-align: inherit;">データをディスクにフラッシュするようにRedisサーバーを設定すると、システムの信頼性が劇的に向上します。</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームの紹介</font></font></h1><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームにレコードを追加する</font></font></h4><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XADD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コマンド</font><font style="vertical-align: inherit;">は、新しいレコードをストリームに追加します。</font><font style="vertical-align: inherit;">レコードは単なる文字列ではなく、1つ以上のキーと値のペアで構成されます。</font><font style="vertical-align: inherit;">したがって、各レコードはすでに構造化されており、CSVファイルの構造に似ています。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XADD mystream * sensor-id <span class="hljs-number">1234</span> temperature <span class="hljs-number">19.8</span>
<span class="hljs-number">1518951480106</span><span class="hljs-number">-0</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例では、「mystream」という名前（キー）を持つ2つのフィールドをストリームに追加します。それぞれ「sensor-id」と「temperature」という値で、それぞれ「1234」と「19.8」です。</font><font style="vertical-align: inherit;">2番目の引数として、コマンドはレコードに割り当てられる識別子を受け入れます。この識別子は、ストリーム内の各レコードを一意に識別します。</font><font style="vertical-align: inherit;">ただし、この場合は、Redisに新しい識別子を生成させたいため、*を渡しました。</font><font style="vertical-align: inherit;">新しい識別子が増えるたびに増加します。</font><font style="vertical-align: inherit;">したがって、新しい各レコードには、以前のレコードと比較してより大きな識別子があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDフォーマット</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
返されたレコード識別子</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XADDの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンドは、</font><font style="vertical-align: inherit;">次の2つの部分から構成さ</font><i><font style="vertical-align: inherit;">millisecondsTime</font></i><font style="vertical-align: inherit;">ミリ秒単位のUNIX時間（Redisのサーバー時刻） - 。ただし、現在の時刻が前のレコードの時刻と同じかそれより短い場合は、前のレコードのタイムスタンプが使用されます。したがって、サーバー時間が過去に戻った場合でも、新しい識別子は増加プロパティを保持します。</font><i><font style="vertical-align: inherit;">sequenceNumberは</font></i><font style="vertical-align: inherit;">、同じミリ秒で作成されたレコードに使用されます。</font><i><font style="vertical-align: inherit;">sequenceNumber</font></i><font style="vertical-align: inherit;">は、前のレコードと比較して1ずつ増加します。</font><i><font style="vertical-align: inherit;">sequenceNumber</font></i><font style="vertical-align: inherit;">以降</font></font><br>
<br>
<code>{millisecondsTime}-{sequenceNumber}<br>
</code><br>
<i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズは64ビットです。実際には、1ミリ秒以内に生成できるレコード数の制限に遭遇しないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような識別子の形式は、一見奇妙に思えるかもしれません。信じられない読者は、なぜ時間が識別子の一部であるのか疑問に思うかもしれません。その理由は、Redisストリームが識別子による範囲リクエストをサポートするためです。識別子はレコードが作成された時間に関連付けられているため、これにより時間範囲を要求できます。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XRANGEコマンドの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学習に移るときに、具体的な例を見ていきます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なんらかの理由でユーザーが自分の識別子を指定する必要がある場合（たとえば、外部システムに関連付けられている場合）、それをコマンドに渡すことができます。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下に示すように、*記号の代わりに</font><b><font style="vertical-align: inherit;">XADD</font></b><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="go hljs">&gt; XADD somestream <span class="hljs-number">0</span><span class="hljs-number">-1</span> field value
<span class="hljs-number">0</span><span class="hljs-number">-1</span>
&gt; XADD somestream <span class="hljs-number">0</span><span class="hljs-number">-2</span> foo bar
<span class="hljs-number">0</span><span class="hljs-number">-2</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、識別子の増加を自分で監視する必要があることに注意してください。</font><font style="vertical-align: inherit;">この例では、最小識別子は「0-1」であるため、チームは「0-1」以下の別の識別子を受け入れません。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XADD somestream <span class="hljs-number">0</span><span class="hljs-number">-1</span> foo bar<font></font>
(error) ERR The ID specified in XADD is equal or smaller than the target stream top item<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーム内のレコード数</font></font></h4><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XLEN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コマンドを使用するだけで、ストリーム内のレコード数を取得できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この例では、このコマンドは次の値を返します。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XLEN somestream<font></font>
(integer) <span class="hljs-number">2</span>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">範囲リクエスト-XRANGEおよびXREVRANGE</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
範囲のデータを要求するには、範囲の最初と最後の2つの識別子を指定する必要があります。返される範囲には、境界線を含むすべての要素が含まれます。また、それぞれ2つの特別な識別子「-」と「+」があり、ストリーム内の最小（最初のレコード）と最大（最後のレコード）の識別子を意味します。以下の例では、すべてのストリームエントリが表示されます。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XRANGE mystream - +
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1518951480106</span><span class="hljs-number">-0</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"sensor-id"</span>
      <span class="hljs-number">2</span>) <span class="hljs-string">"1234"</span>
      <span class="hljs-number">3</span>) <span class="hljs-string">"temperature"</span>
      <span class="hljs-number">4</span>) <span class="hljs-string">"19.8"</span>
<span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1518951482479</span><span class="hljs-number">-0</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"sensor-id"</span>
      <span class="hljs-number">2</span>) <span class="hljs-string">"9999"</span>
      <span class="hljs-number">3</span>) <span class="hljs-string">"temperature"</span>
      <span class="hljs-number">4</span>) <span class="hljs-string">"18.2"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
返される各レコードは、識別子とキーと値のペアのリストという2つの要素の配列です。レコード識別子は時間に関連していると既に述べました。したがって、特定の期間の範囲をリクエストできます。ただし、リクエストでは完全な識別子ではなく、Unix時間のみを指定して、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sequenceNumberに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関連する部分を省略できます</font><font style="vertical-align: inherit;">。識別子の省略された部分は、自動的に範囲の最初はゼロになり、範囲の最後は可能な最大値になります。以下は、2ミリ秒の範囲を要求する方法の例です。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XRANGE mystream <span class="hljs-number">1518951480106</span> <span class="hljs-number">1518951480107</span>
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1518951480106</span><span class="hljs-number">-0</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"sensor-id"</span>
      <span class="hljs-number">2</span>) <span class="hljs-string">"1234"</span>
      <span class="hljs-number">3</span>) <span class="hljs-string">"temperature"</span>
      <span class="hljs-number">4</span>) <span class="hljs-string">"19.8"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この範囲のレコードは1つしかありませんが、実際のデータセットでは、返される結果が膨大になる可能性があります。このため、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XRANGE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はCOUNTオプションをサポートしています。数量を指定することで、最初のN個のレコードを簡単に取得できます。次のNエントリ（ページネーション）を取得する必要がある場合は、最後に受け取った識別子を使用して、彼の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sequenceNumber</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を1 </font><font style="vertical-align: inherit;">増やし、</font><font style="vertical-align: inherit;">再度リクエストできます。次の例でこれを見てみましょう。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XADD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して10個の要素を追加し始め</font><font style="vertical-align: inherit;">ます（mystreamストリームはすでに10個の要素で満たされていると仮定します）。コマンドごとに2つの要素を取得して反復を開始するには、全範囲から始めますが、COUNTは2に等しくなります。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XRANGE mystream - + COUNT <span class="hljs-number">2</span>
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1519073278252</span><span class="hljs-number">-0</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"foo"</span>
      <span class="hljs-number">2</span>) <span class="hljs-string">"value_1"</span>
<span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1519073279157</span><span class="hljs-number">-0</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"foo"</span>
      <span class="hljs-number">2</span>) <span class="hljs-string">"value_2"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の2つの要素で反復を続けるには、最後に受け取った識別子、つまり1519073279157-0を選択し、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sequenceNumber</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に1を追加する必要があります</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果の識別子（この場合は1519073279157-1）は、次の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XRANGE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しの範囲の先頭に対する新しい引数として使用できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XRANGE mystream <span class="hljs-number">1519073279157</span><span class="hljs-number">-1</span> + COUNT <span class="hljs-number">2</span>
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1519073280281</span><span class="hljs-number">-0</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"foo"</span>
      <span class="hljs-number">2</span>) <span class="hljs-string">"value_3"</span>
<span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1519073281432</span><span class="hljs-number">-0</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"foo"</span>
      <span class="hljs-number">2</span>) <span class="hljs-string">"value_4"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
等。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XRANGE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の複雑さは、</font><b><font style="vertical-align: inherit;">検索で</font></b><font style="vertical-align: inherit;">はO（log（N））、M要素を返す場合はO（M）であるため、各反復ステップは高速です。</font><font style="vertical-align: inherit;">したがって、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XRANGE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><b><font style="vertical-align: inherit;">すると、</font></b><font style="vertical-align: inherit;">フローを効率的に</font><b><font style="vertical-align: inherit;">繰り返す</font></b><font style="vertical-align: inherit;">ことができます。</font><b><font style="vertical-align: inherit;">XREVRANGE</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コマンド</font><font style="vertical-align: inherit;">は</font><b><font style="vertical-align: inherit;">XRANGE</font></b><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">同等です</font><font style="vertical-align: inherit;">が、要素を逆の順序で返します。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="go hljs">&gt; XREVRANGE mystream + - COUNT <span class="hljs-number">1</span>
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1519073287312</span><span class="hljs-number">-0</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"foo"</span>
      <span class="hljs-number">2</span>) <span class="hljs-string">"value_10"</span>
</code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XREVRANGE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コマンド</font><font style="vertical-align: inherit;">は、開始範囲と終了範囲の引数を逆の順序で取る</font><font style="vertical-align: inherit;">ことに注意してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XREADによる新しいレコードの読み取り</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合、ストリームをサブスクライブして新しいメッセージのみを受信するタスクがあります。</font><font style="vertical-align: inherit;">この概念はRedis Pub / SubまたはブロッキングRedisリストに似ているように見えるかもしれませんが、Redis Streamの使用方法には基本的な違いがあります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいメッセージは、デフォルトで各サブスクライバーに配信されます。</font><font style="vertical-align: inherit;">この動作は、新しいメッセージが1人のサブスクライバーのみによって読み取られるRedisリストのブロックとは異なります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Pub / Subではすべてのメッセージが忘れられて保存されることはありませんが、Streamではすべてのメッセージが無期限に保存されます（クライアントが明示的に削除を要求しない限り）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Streamを使用すると、1つのストリーム内のメッセージへのアクセスを区別できます。</font><font style="vertical-align: inherit;">特定のサブスクライバーは、自分のメッセージ履歴のみを表示できます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XREAD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コマンドを使用して、ストリームをサブスクライブし、新しいメッセージを受信できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XRANGE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よりも少し複雑なので</font><font style="vertical-align: inherit;">、最初に簡単な例から始めます。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XREAD COUNT <span class="hljs-number">2</span> STREAMS mystream <span class="hljs-number">0</span>
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"mystream"</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1519073278252</span><span class="hljs-number">-0</span>
         <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"foo"</span>
            <span class="hljs-number">2</span>) <span class="hljs-string">"value_1"</span>
      <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1519073279157</span><span class="hljs-number">-0</span>
         <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"foo"</span>
            <span class="hljs-number">2</span>) <span class="hljs-string">"value_2"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例では、非ブロッキング</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XREAD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォームが</font><b><font style="vertical-align: inherit;">指定されています</font></b><font style="vertical-align: inherit;">。 COUNTオプションはオプションであることに注意してください。実際、必須のコマンドオプションはSTREAMSオプションだけです。これは、対応する最大識別子とともにストリームのリストを設定します。 「STREAMS mystream 0」と書いた-「0-0」より大きい識別子を持つmystreamストリームのすべてのレコードを取得したい。例からわかるように、コマンドはストリームの名前を返します。これは、複数のストリームを同時にサブスクライブできるためです。たとえば、「STREAMS mystream otherstream 0 0」と書くことができます。 STREAMSオプションの後、最初に必要なすべてのストリームの名前を指定し、次に識別子のリストを指定する必要があることに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この単純な形式では、コマンドは</font><b><font style="vertical-align: inherit;">XRANGE</font></b><font style="vertical-align: inherit;">と比較して特別なことは何もしません</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ただし、興味深いのは</font><font style="vertical-align: inherit;">、BLOCK引数を指定することにより、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XREAD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をブロッキングコマンドに</font><font style="vertical-align: inherit;">簡単に</font><b><font style="vertical-align: inherit;">変換</font></b><font style="vertical-align: inherit;">できることです。</font><font style="vertical-align: inherit;">
上記の例では、新しいBLOCKオプションが0ミリ秒のタイムアウトで指定されています（これは、無限の待機を意味します）。さらに、mystreamストリームの通常の識別子を渡す代わりに、特別な識別子$が渡されました。この特別な識別子は、</font><b><font style="vertical-align: inherit;">XREAD</font></b><font style="vertical-align: inherit;">がmystreamストリーム内の最大の識別子を識別子として使用</font><font style="vertical-align: inherit;">することを意味し</font><font style="vertical-align: inherit;">ます。ですから、聴き始めた瞬間から新しいメッセージのみを受け取ります。ある意味で、これはUnixのtail -fコマンドに似ています。</font></font><br>
<br>
<code>&gt; XREAD BLOCK 0 STREAMS mystream $<br>
</code><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BLOCKオプションを使用する場合、特別な識別子$を使用する必要がないことに注意してください。</font><font style="vertical-align: inherit;">ストリームに存在する任意の識別子を使用できます。</font><font style="vertical-align: inherit;">チームが要求をブロックせずにすぐに処理できる場合はそれを行い、そうでない場合はブロックされます。</font><b><font style="vertical-align: inherit;">XREAD</font></b><font style="vertical-align: inherit;">を</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロックすると</font><font style="vertical-align: inherit;">、一度に複数のストリームをリッスンすることもできます。名前を指定するだけです。</font><font style="vertical-align: inherit;">この場合、コマンドはデータが到着した最初のストリームのレコードを返します。</font><font style="vertical-align: inherit;">このストリームに対してブロックされた最初のサブスクライバーが最初にデータを受信します。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消費者グループ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定のタスクでは、同じスレッド内のメッセージへのサブスクライバーのアクセスを区別する必要があります。</font><font style="vertical-align: inherit;">これが役立つ例として、ストリームでさまざまなメッセージを受信するワーカーを備えたメッセージキューがあり、メッセージ処理をスケーリングできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つのサブスクライバーC1、C2、C3と、メッセージ1、2、3、4、5、6、7を含むストリームがあると想像すると、次の図のようにメッセージサービスが発生します。</font><font style="vertical-align: inherit;">
この効果を得るには、 Redis Streamは、コンシューマーグループと呼ばれる概念を使用しています。</font><font style="vertical-align: inherit;">この概念は、ストリームからデータを受信する疑似サブスクライバーに似ていますが、実際にはグループ内の複数のサブスクライバーによって処理され、特定の保証が提供されます。</font></font><br>
<br>
<code>1 -&gt; C1<br>
2 -&gt; C2<br>
3 -&gt; C3<br>
4 -&gt; C1<br>
5 -&gt; C2<br>
6 -&gt; C3<br>
7 -&gt; C1<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各メッセージは、グループ内の異なるサブスクライバーに配信されます。</font></font></li>
<li>      ,       .  -     ,          .</li>
<li> Consumer Group   «  ».     ,      ,          .</li>
<li>       .      ,       «pending» .</li>
<li> Consumer Group      ,     ,      (  «pending»)</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ある意味では、グループの状態は次のように表すことができます。</font></font><br>
<br>
<pre><code class="go hljs">+----------------------------------------+<font></font>
| consumer_group_name: mygroup          <font></font>
| consumer_group_stream: somekey        <font></font>
| last_delivered_id: <span class="hljs-number">1292309234234</span><span class="hljs-number">-92</span>    <font></font>
|                                                           <font></font>
| consumers:                                          <font></font>
|    <span class="hljs-string">"consumer-1"</span> with pending messages  <font></font>
|       <span class="hljs-number">1292309234234</span><span class="hljs-number">-4</span>                          
|       <span class="hljs-number">1292309234232</span><span class="hljs-number">-8</span>                          
|    <span class="hljs-string">"consumer-42"</span> with pending messages <font></font>
|       ... (and so forth)                             <font></font>
+----------------------------------------+<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次は、コンシューマグループの主なチーム、つまり次のことを理解するときです。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XGROUPは</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、グループの作成、破棄、および管理に使用されます。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XREADGROUPは</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、グループを介してストリームを読み取るために使用されます。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XACK-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このコマンドにより、サブスクライバーはメッセージを正常に処理されたものとしてマークできます</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消費者グループの創設</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mystreamストリームがすでに存在するとします。次に、グループ作成コマンドは次のよう</font><font style="vertical-align: inherit;">
になります。グループを作成するときは、グループがメッセージを受信するための識別子を渡す必要があります。すべての新しいメッセージを受信するだけの場合は、特別な識別子$を使用できます（上記の例のように）。特別な識別子の代わりに0を指定すると、ストリームのすべてのメッセージがグループで使用できるようになります。</font><font style="vertical-align: inherit;">
グループが作成されたので、</font><b><font style="vertical-align: inherit;">XREADGROUPコマンド</font></b><font style="vertical-align: inherit;">を使用してメッセージの読み取りをすぐに開始できます</font><font style="vertical-align: inherit;">。このコマンドは</font><b><font style="vertical-align: inherit;">XREAD</font></b><font style="vertical-align: inherit;">によく似て</font><font style="vertical-align: inherit;">おり、オプションのBLOCKオプションをサポートしています。ただし、必須のGROUPオプションがあり、常に2つの引数で指定する必要があります。グループの名前とサブスクライバーの名前です。 COUNTオプションもサポートされています。</font></font><br>
<br>
<code>&gt; XGROUP CREATE mystream mygroup $<br>
OK<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリームを読み取る前に、いくつかのメッセージをそこに配置しましょう。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XADD mystream * message apple
<span class="hljs-number">1526569495631</span><span class="hljs-number">-0</span><font></font>
&gt; XADD mystream * message orange<font></font>
<span class="hljs-number">1526569498055</span><span class="hljs-number">-0</span><font></font>
&gt; XADD mystream * message strawberry<font></font>
<span class="hljs-number">1526569506935</span><span class="hljs-number">-0</span><font></font>
&gt; XADD mystream * message apricot<font></font>
<span class="hljs-number">1526569535168</span><span class="hljs-number">-0</span><font></font>
&gt; XADD mystream * message banana<font></font>
<span class="hljs-number">1526569544280</span><span class="hljs-number">-0</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、グループを通じてこのストリームを読み取ってみましょう。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XREADGROUP GROUP mygroup Alice COUNT <span class="hljs-number">1</span> STREAMS mystream &gt;
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"mystream"</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1526569495631</span><span class="hljs-number">-0</span>
         <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"message"</span>
            <span class="hljs-number">2</span>) <span class="hljs-string">"apple"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のコマンドは逐語的に次のようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「私、アリス、サブスクライバー、mygroupグループのメンバーは、これまで誰にも配信されたことのないmystreamストリームから1つのメッセージを読みたい」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サブスクライバーは、グループを使用して操作を実行するたびに、グループ内で自分を一意に識別する名前を示す必要があります。上記のコマンドには、特別な識別子「&gt;」という非常に重要な詳細がもう1つあります。この特別な識別子はメッセージをフィルタリングし、これまで配信されたことがないメッセージのみを残します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、特殊なケースでは、0やその他の有効な識別子などの実際の識別子を指定できます。この場合、</font><b><font style="vertical-align: inherit;">XREADGROUP</font></b><font style="vertical-align: inherit;">コマンド</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定したサブスクライバー（アリス）に配信されたが、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XACKコマンド</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用してまだ確認されていない、ステータスが「保留」のメッセージの履歴が返されます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この動作は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COUNT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプションなしで識別子0をすぐに指定することで確認できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">保留中のメッセージ、つまりリンゴのメッセージだけが表示されます。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XREADGROUP GROUP mygroup Alice STREAMS mystream <span class="hljs-number">0</span>
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"mystream"</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1526569495631</span><span class="hljs-number">-0</span>
         <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"message"</span>
            <span class="hljs-number">2</span>) <span class="hljs-string">"apple"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、メッセージが正常に処理されたことを確認すると、メッセージは表示されなくなります。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XACK mystream mygroup <span class="hljs-number">1526569495631</span><span class="hljs-number">-0</span>
(integer) <span class="hljs-number">1</span>
&gt; XREADGROUP GROUP mygroup Alice STREAMS mystream <span class="hljs-number">0</span>
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"mystream"</span>
   <span class="hljs-number">2</span>) (empty list or set)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今度はボブが何かを読む番です。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XREADGROUP GROUP mygroup Bob COUNT <span class="hljs-number">2</span> STREAMS mystream &gt;
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"mystream"</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1526569498055</span><span class="hljs-number">-0</span>
         <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"message"</span>
            <span class="hljs-number">2</span>) <span class="hljs-string">"orange"</span>
      <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1526569506935</span><span class="hljs-number">-0</span>
         <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"message"</span>
            <span class="hljs-number">2</span>) <span class="hljs-string">"strawberry"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mygroupのメンバーであるBobは、2つまでのメッセージを要求しました。</font><font style="vertical-align: inherit;">このコマンドは、特殊な識別子 "&gt;"が原因で配信不能メッセージのみを報告します。</font><font style="vertical-align: inherit;">ご覧のとおり、「りんご」というメッセージは表示されていません。すでにアリスに配信されているため、ボブは「オレンジ」と「イチゴ」を受け取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、アリス、ボブ、およびその他のグループサブスクライバーは、同じストリームから異なるメッセージを読み取ることができます。</font><font style="vertical-align: inherit;">また、生のメッセージ履歴を読んだり、メッセージに処理済みのマークを付けたりすることもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
覚えておくべきことがいくつかあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブスクライバーがメッセージを</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XREADGROUP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンド</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">あると</font><b><font style="vertical-align: inherit;">見なすと</font></b><font style="vertical-align: inherit;">、このメッセージは「保留」状態になり、この特定のサブスクライバーに割り当てられます。</font><font style="vertical-align: inherit;">他のグループ購読者はこのメッセージを読むことができません。</font></font></li>
<li>     ,      .</li>
<li>  <b>XREADGROUP</b>         , ,   ,              <b>XGROUP</b></li>
</ul><br>
<h4>  </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サブスクライバーは障害から回復し、「保留中」の状況でメッセージのリストを再度読み取ることができます。ただし、現実の世界では、加入者は最終的に失敗する可能性があります。障害の後で回復できない場合、サブスクライバーのぶら下がりメッセージはどうなりますか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンシューマーグループは、メッセージの所有者を変更する必要がある場合など、このような場合に特に使用される機能を提供します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XPENDING</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンドを呼び出す必要があります。</font><b><font style="vertical-align: inherit;">この</font></b><font style="vertical-align: inherit;">コマンド</font><font style="vertical-align: inherit;">は、ステータスが「保留中」のグループのすべてのメッセージを表示します。最も単純な形式では、コマンドは2つの引数のみで呼び出されます。ストリームの名前とグループの名前です。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XPENDING mystream mygroup
<span class="hljs-number">1</span>) (integer) <span class="hljs-number">2</span>
<span class="hljs-number">2</span>) <span class="hljs-number">1526569498055</span><span class="hljs-number">-0</span>
<span class="hljs-number">3</span>) <span class="hljs-number">1526569506935</span><span class="hljs-number">-0</span>
<span class="hljs-number">4</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"Bob"</span>
      <span class="hljs-number">2</span>) <span class="hljs-string">"2"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チームは、グループ全体および各サブスクライバーの未処理メッセージの数を印刷しました。アリスが要求した唯一のメッセージは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XACK</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で確認されたため、ボブには2つの未処理メッセージしかありませ</font><b><font style="vertical-align: inherit;">ん</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より多くの引数を使用して追加情報を要求できます：</font><font style="vertical-align: inherit;">
{start-id} {end-id}-識別子の範囲（「-」と「+」を使用できます）</font><font style="vertical-align: inherit;">
{count}-配信試行回数</font><font style="vertical-align: inherit;">
{consumer-name}-グループ名</font></font><br>
<br>
<code>XPENDING {key} {groupname} [{start-id} {end-id} {count} [{consumer-name}]]<br>
</code><br><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="go hljs">&gt; XPENDING mystream mygroup - + <span class="hljs-number">10</span>
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1526569498055</span><span class="hljs-number">-0</span>
   <span class="hljs-number">2</span>) <span class="hljs-string">"Bob"</span>
   <span class="hljs-number">3</span>) (integer) <span class="hljs-number">74170458</span>
   <span class="hljs-number">4</span>) (integer) <span class="hljs-number">1</span>
<span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1526569506935</span><span class="hljs-number">-0</span>
   <span class="hljs-number">2</span>) <span class="hljs-string">"Bob"</span>
   <span class="hljs-number">3</span>) (integer) <span class="hljs-number">74170458</span>
   <span class="hljs-number">4</span>) (integer) <span class="hljs-number">1</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、各メッセージの詳細（識別子、サブスクライバー名、ミリ秒単位のダウンタイム）、最後に配信試行回数がわかりました。ボブからの2つのメッセージがあり、それらは74170458ミリ秒、約20時間アイドルです。</font><b><font style="vertical-align: inherit;">XRANGE</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を使用するだけで、メッセージの内容を確認することを</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">妨げられる</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人はいないことに注意してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XRANGE mystream <span class="hljs-number">1526569498055</span><span class="hljs-number">-0</span> <span class="hljs-number">1526569498055</span><span class="hljs-number">-0</span>
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1526569498055</span><span class="hljs-number">-0</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"message"</span>
      <span class="hljs-number">2</span>) <span class="hljs-string">"orange"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
引数で同じ識別子を2回繰り返す必要があります。これでアイディアができたので、アリスは20時間が経過してもボブはおそらく回復しないと判断し、ボブの代わりにこれらのメッセージを要求して処理を再開します。これを行うには、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XCLAIM</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンドを使用します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
このコマンドを使用すると、所有者を{consumer}に変更することで、まだ処理されていない「外部」メッセージを取得できます。ただし、最小のダウンタイム{min-idle-time}を提供することもできます。これは、2つのクライアントが同じメッセージの所有者を同時に変更しようとする状況を回避するのに役立ちます。</font><font style="vertical-align: inherit;">
最初のクライアントはダウンタイムをリセットし、配信数のカウンターを増やします。したがって、2番目のクライアントはそれを要求できません。</font></font><br>
<br>
<code>XCLAIM {key} {group} {consumer} {min-idle-time} {ID-1} {ID-2} ... {ID-N}<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>Client 1: XCLAIM mystream mygroup Alice 3600000 1526569498055-0<br>
Clinet 2: XCLAIM mystream mygroup Lora 3600000 1526569498055-0<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="go hljs">&gt; XCLAIM mystream mygroup Alice <span class="hljs-number">3600000</span> <span class="hljs-number">1526569498055</span><span class="hljs-number">-0</span>
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1526569498055</span><span class="hljs-number">-0</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"message"</span>
      <span class="hljs-number">2</span>) <span class="hljs-string">"orange"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージはアリスによって正常に要求されました。アリスはメッセージを処理して確認することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例から、リクエストが正常に実行されると、メッセージ自体のコンテンツが返されることがわかります。</font><font style="vertical-align: inherit;">ただし、これは必須ではありません。</font><font style="vertical-align: inherit;">JUSTIDオプションは、メッセージIDのみを返すために使用できます。</font><font style="vertical-align: inherit;">これは、メッセージの詳細に興味がなく、システムのパフォーマンスを向上させたい場合に役立ちます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配送カウンター</font></font></h3><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XPENDINGの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
出力で確認できるカウンター</font><font style="vertical-align: inherit;">は、各メッセージの配信数です。</font><font style="vertical-align: inherit;">このようなカウンターは、メッセージが</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XCLAIM</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を介して正常に要求された</font><font style="vertical-align: inherit;">とき、または</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XREADGROUP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しが</font><b><font style="vertical-align: inherit;">使用された</font></b><font style="vertical-align: inherit;">ときの2つの方法で増加します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のメッセージが数回配信されるのは正常です。</font><font style="vertical-align: inherit;">その結果、すべてのメッセージが処理されます。</font><font style="vertical-align: inherit;">メッセージを処理するときに、メッセージ自体の損傷やメッセージの処理によって問題が発生し、ハンドラーコードでエラーが発生することがあります。</font><font style="vertical-align: inherit;">この場合、誰もこのメッセージを処理できないことが判明する場合があります。</font><font style="vertical-align: inherit;">配信試行のカウンターがあるため、このカウンターを使用してそのような状況を検出できます。</font><font style="vertical-align: inherit;">したがって、配信カウンタが指定した数に達したらすぐに、そのようなメッセージを別のストリームに入れて、システム管理者に通知を送信する方が合理的です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドのステータス</font></font></h4><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XINFO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コマンド</font><b><font style="vertical-align: inherit;">は</font></b><font style="vertical-align: inherit;">、ストリームとそのグループに関するさまざまな情報を要求するために使用されます。</font><font style="vertical-align: inherit;">たとえば、コマンドの基本的な形式は次のとおりです。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XINFO STREAM mystream
 <span class="hljs-number">1</span>) length
 <span class="hljs-number">2</span>) (integer) <span class="hljs-number">13</span>
 <span class="hljs-number">3</span>) radix-tree-keys
 <span class="hljs-number">4</span>) (integer) <span class="hljs-number">1</span>
 <span class="hljs-number">5</span>) radix-tree-nodes
 <span class="hljs-number">6</span>) (integer) <span class="hljs-number">2</span>
 <span class="hljs-number">7</span>) groups
 <span class="hljs-number">8</span>) (integer) <span class="hljs-number">2</span>
 <span class="hljs-number">9</span>) first-entry
<span class="hljs-number">10</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1524494395530</span><span class="hljs-number">-0</span>
    <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"a"</span>
       <span class="hljs-number">2</span>) <span class="hljs-string">"1"</span>
       <span class="hljs-number">3</span>) <span class="hljs-string">"b"</span>
       <span class="hljs-number">4</span>) <span class="hljs-string">"2"</span>
<span class="hljs-number">11</span>) last-entry
<span class="hljs-number">12</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1526569544280</span><span class="hljs-number">-0</span>
    <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"message"</span>
       <span class="hljs-number">2</span>) <span class="hljs-string">"banana"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のコマンドは、指定されたストリームに関する一般的な情報を表示します。</font><font style="vertical-align: inherit;">次に、もう少し複雑な例を示します。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XINFO GROUPS mystream
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) name
   <span class="hljs-number">2</span>) <span class="hljs-string">"mygroup"</span>
   <span class="hljs-number">3</span>) consumers
   <span class="hljs-number">4</span>) (integer) <span class="hljs-number">2</span>
   <span class="hljs-number">5</span>) pending
   <span class="hljs-number">6</span>) (integer) <span class="hljs-number">2</span>
<span class="hljs-number">2</span>) <span class="hljs-number">1</span>) name
   <span class="hljs-number">2</span>) <span class="hljs-string">"some-other-group"</span>
   <span class="hljs-number">3</span>) consumers
   <span class="hljs-number">4</span>) (integer) <span class="hljs-number">1</span>
   <span class="hljs-number">5</span>) pending
   <span class="hljs-number">6</span>) (integer) <span class="hljs-number">0</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のコマンドは、指定されたストリームのすべてのグループの一般情報を表示します</font></font><br>
<br>
<pre><code class="go hljs">&gt; XINFO CONSUMERS mystream mygroup
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) name
   <span class="hljs-number">2</span>) <span class="hljs-string">"Alice"</span>
   <span class="hljs-number">3</span>) pending
   <span class="hljs-number">4</span>) (integer) <span class="hljs-number">1</span>
   <span class="hljs-number">5</span>) idle
   <span class="hljs-number">6</span>) (integer) <span class="hljs-number">9104628</span>
<span class="hljs-number">2</span>) <span class="hljs-number">1</span>) name
   <span class="hljs-number">2</span>) <span class="hljs-string">"Bob"</span>
   <span class="hljs-number">3</span>) pending
   <span class="hljs-number">4</span>) (integer) <span class="hljs-number">1</span>
   <span class="hljs-number">5</span>) idle
   <span class="hljs-number">6</span>) (integer) <span class="hljs-number">83841983</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のコマンドは、指定されたストリームとグループのすべてのサブスクライバーに関する情報を表示します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コマンド構文を忘れた場合は、コマンドに問い合わせてください。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XINFO HELP
<span class="hljs-number">1</span>) XINFO {subcommand} arg arg ... arg. Subcommands are:
<span class="hljs-number">2</span>) CONSUMERS {key} {groupname}  -- Show consumer groups of group {groupname}.
<span class="hljs-number">3</span>) GROUPS {key}                 -- Show the stream consumer groups.
<span class="hljs-number">4</span>) STREAM {key}                 -- Show information about the stream.
<span class="hljs-number">5</span>) HELP                         -- Print this help.
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームサイズの制限</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くのアプリケーションは、ストリームにデータを永久に収集することを望んでいません。</font><font style="vertical-align: inherit;">多くの場合、ストリーム内に最大数のメッセージを含めると便利です。</font><font style="vertical-align: inherit;">他の場合では、指定されたストリームサイズに達したときに、すべてのメッセージをストリームから別の永続ストレージに転送すると便利です。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XADDコマンドの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MAXLENパラメータを使用して、ストリームのサイズを制限できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XADD mystream MAXLEN <span class="hljs-number">2</span> * value <span class="hljs-number">1</span>
<span class="hljs-number">1526654998691</span><span class="hljs-number">-0</span>
&gt; XADD mystream MAXLEN <span class="hljs-number">2</span> * value <span class="hljs-number">2</span>
<span class="hljs-number">1526654999635</span><span class="hljs-number">-0</span>
&gt; XADD mystream MAXLEN <span class="hljs-number">2</span> * value <span class="hljs-number">3</span>
<span class="hljs-number">1526655000369</span><span class="hljs-number">-0</span><font></font>
&gt; XLEN mystream<font></font>
(integer) <span class="hljs-number">2</span><font></font>
&gt; XRANGE mystream - +<font></font>
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1526654999635</span><span class="hljs-number">-0</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"value"</span>
      <span class="hljs-number">2</span>) <span class="hljs-string">"2"</span>
<span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1526655000369</span><span class="hljs-number">-0</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"value"</span>
      <span class="hljs-number">2</span>) <span class="hljs-string">"3"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MAXLENを使用すると、指定した長さに達すると古いレコードが自動的に削除されるため、ストリームのサイズは一定になります。</font><font style="vertical-align: inherit;">ただし、この場合のトリミングは、Redisメモリでは最も生産的な方法では発生しません。</font><font style="vertical-align: inherit;">状況は次のように</font><font style="vertical-align: inherit;">
改善</font><font style="vertical-align: inherit;">できます。</font><font style="vertical-align: inherit;">上記の例</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">引数〜は、ストリームの長さを特定の値に制限する必要がないことを意味します。</font><font style="vertical-align: inherit;">この例では、これは1000以上の任意の数にすることができます（たとえば、1000、1010、または1030）。</font><font style="vertical-align: inherit;">ストリームに少なくとも1000件のレコードを格納することを明示的に示しました。</font><font style="vertical-align: inherit;">これにより、Redis内でのメモリの操作がより効率的になります。</font><font style="vertical-align: inherit;">同じことを行う</font><font style="vertical-align: inherit;">
別の</font><b><font style="vertical-align: inherit;">XTRIM</font></b><font style="vertical-align: inherit;">コマンドもあります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<code>XADD mystream MAXLEN ~ 1000 * ... entry fields here ...<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<code>&gt; XTRIM mystream MAXLEN 10<br>
<br>
&gt; XTRIM mystream MAXLEN ~ 10<br>
</code><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">永続的なストレージとレプリケーション</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis Streamは非同期でスレーブノードに複製され、AOF（すべてのデータのスナップショット）やRDB（すべての書き込み操作のログ）などのファイルに保存されます。</font><font style="vertical-align: inherit;">コンシューマーグループの状態のレプリケーションもサポートされています。</font><font style="vertical-align: inherit;">したがって、メッセージがマスターノードで「保留」ステータスにある場合、スレーブノードではこのメッセージは同じステータスになります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームから個々のアイテムを削除する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージを削除するには、特別な</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XDEL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンドがあり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">このコマンドは、ストリームの名前を取得し、その後に削除する必要があるメッセージの識別子を取得します。</font></font><br>
<br>
<pre><code class="go hljs">&gt; XRANGE mystream - + COUNT <span class="hljs-number">2</span>
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1526654999635</span><span class="hljs-number">-0</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"value"</span>
      <span class="hljs-number">2</span>) <span class="hljs-string">"2"</span>
<span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1526655000369</span><span class="hljs-number">-0</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"value"</span>
      <span class="hljs-number">2</span>) <span class="hljs-string">"3"</span>
&gt; XDEL mystream <span class="hljs-number">1526654999635</span><span class="hljs-number">-0</span>
(integer) <span class="hljs-number">1</span>
&gt; XRANGE mystream - + COUNT <span class="hljs-number">2</span>
<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-number">1526655000369</span><span class="hljs-number">-0</span>
   <span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">"value"</span>
      <span class="hljs-number">2</span>) <span class="hljs-string">"3"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコマンドを使用する場合、実際にはメモリがすぐには解放されないことを考慮する必要があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長さゼロのストリーム</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリームと他のRedisデータ構造の違いは、他のデータ構造内に要素がなくなった場合、副作用として、データ構造自体がメモリから削除されることです。</font><font style="vertical-align: inherit;">したがって、たとえば、ZREM呼び出しが最後のアイテムを削除すると、ソートされたセットは完全に削除されます。</font><font style="vertical-align: inherit;">代わりに、スレッド内に単一の要素がなくても、スレッドをメモリに残すことができます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis Streamは、メッセージブローカー、メッセージキュー、統合ログ、および履歴を保存するチャットシステムの作成に最適です。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Nicklaus Wirthが</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
かつて言ったように</font><font style="vertical-align: inherit;">、プログラムはアルゴリズムとデータ構造であり、Redisはすでに両方を提供しています。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja456258/index.html">GNU FDL 1.3ライセンスに基づく「Free as in Freedom」のロシア語への翻訳は風のように無料、ビールのように無料</a></li>
<li><a href="../ja456260/index.html">フェアエコノミートーク</a></li>
<li><a href="../ja456262/index.html">ソフトウェア無線-それはどのように機能しますか？パート9</a></li>
<li><a href="../ja456264/index.html">ソースとAndroid NDKを使用してAndroidバイナリファイルをビルドします。screencapユーティリティを起動します</a></li>
<li><a href="../ja456266/index.html">モバイル＃302開発者向けの興味深い資料のダイジェスト（6月10〜16日）</a></li>
<li><a href="../ja456272/index.html">Android Lintとは何ですか？サポートされているコードの記述にどのように役立ちますか？</a></li>
<li><a href="../ja456274/index.html">心理学者：セックスロボットは、他の人々との関係を必要としないカップルがいない場合、人々の数の増加につながります</a></li>
<li><a href="../ja456276/index.html">情報とは？</a></li>
<li><a href="../ja456280/index.html">stm32を使い始めるか、間違いを繰り返さないでください</a></li>
<li><a href="../ja456282/index.html">Pythonの多次元グラフィックス-3次元から6次元へ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>