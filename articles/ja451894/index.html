<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆖 🧑‍🤝‍🧑 ♌️ コンパイラアーキテクチャの簡潔で元気のよい概要 🌱 🎿 👁️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ほとんどのコンパイラには次のアーキテクチャがあります。
 
  
 
 この記事では、このアーキテクチャを要素ごとに詳細に分析します。
 この記事は、コンパイラーのトピックに関する既存の膨大なリソースへの追加であると言えます。これは、プログラミング言語の設計と実装の基本を理解できる自律的なソースです...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>コンパイラアーキテクチャの簡潔で元気のよい概要</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/451894/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/ej/-i/slej-ivpokabgczeqdbgiafc0rw.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどのコンパイラには次のアーキテクチャがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/73e/ff7/c46/73eff7c467213f5de1b9134666f9e569.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、このアーキテクチャを要素ごとに詳細に分析します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、コンパイラーのトピックに関する既存の膨大なリソースへの追加であると言えます。</font><font style="vertical-align: inherit;">これは、プログラミング言語の設計と実装の基本を理解できる自律的なソースです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の対象読者は、コンパイラーの作業の考え方が非常に限られている人々です（最大は、コンパイルに関与していることです）。</font><font style="vertical-align: inherit;">ただし、読者はデータ構造とアルゴリズムを理解する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、何百万行ものコードを備えた最新の量産コンパイラに特化したものでは決してありません。いいえ、これは、コンパイラとは何かを理解するのに役立つ「ダミーのコンパイラ」という短いコースです。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は現在</font><font style="vertical-align: inherit;">、Rust and Goに触発さ</font><font style="vertical-align: inherit;">れた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Krug</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システム言語に取り組んでい</font><font style="vertical-align: inherit;">ます。記事では、私の考えを説明するための例としてクリュッグを参照します。 Krugは開発中ですが、すでに</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">caasper</font></a><font style="vertical-align: inherit;">および</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">krug</font></a><font style="vertical-align: inherit;">リポジトリの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/krug-lang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から</font><font style="vertical-align: inherit;">入手でき</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。この言語は通常のコンパイラアーキテクチャに比べてかなり典型的ではないため、記事を書くきっかけになりましたが、その詳細については後で説明します。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はコンパイラの専門家ではないことを急いでお知らせします！</font><font style="vertical-align: inherit;">私は博士号を取得しておらず、正式なトレーニングも受けていません。自由時間に、この記事に記載されているすべてのことを自分で学びました。</font><font style="vertical-align: inherit;">また、コンパイラを作成するための実際の真のアプローチのみを説明しているのではなく、小さな「おもちゃ」のコンパイラを作成するのに適した基本的な方法を紹介します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロントエンド</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上の図に戻りましょう：フロントエンドフィールドに向けられた左側の矢印は、Cのような有名で愛されている言語です。フロントエンドは、次のようなものです：字句解析-&gt;パーサー。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字句解析</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラと言語設計の研究を始めたとき、字句解析はトークン化と同じであると言われました。この説明を使用します。アナライザーは、文字列または文字のストリームの形式で入力データを取得し、それらのパターンを認識してトークンにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーの場合、入力で書かれたプログラムを受け取ります。ファイルから文字列に読み込まれ、アナライザーがソースコードをトークン化します。</font></font><br>
<br>
<pre><code class="plaintext hljs">enum TokenType {<font></font>
  Identifier,<font></font>
  Number,<font></font>
};<font></font>
<font></font>
struct Token {<font></font>
  std::string Lexeme;<font></font>
  TokenType type;<font></font>
  // ...<font></font>
  // It's also handy to store things in here<font></font>
  // like the position of the token (start to end row:col)<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このフラグメントでは、C字型の言語で記述されており、前述の語彙素と、このトークンを認識する働きをするTokenTypeを含む構造を見ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注：この記事は、例を使用して言語を作成するための手順ではありませんが、理解を深めるために、随時コードスニペットを挿入します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アナライザは通常、最も単純なコンパイラコンポーネントです。実際、フロントエンド全体は、残りのパズルのピースに比べて非常に単純です。これはあなたの仕事に大きく依存しますが。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のCコードを見てみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello world!\n"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルからラインに読み取って線形スキャンを実行すると、トークンをスライスできる場合があります。</font><font style="vertical-align: inherit;">トークンは自然な方法で識別します。intが「単語」であり、returnステートメントの0が「数値」であることがわかります。</font><font style="vertical-align: inherit;">字句解析器は、私たちが行うのと同じ手順を実行します-後でこのプロセスをより詳しく調べます。</font><font style="vertical-align: inherit;">たとえば、数値を分析します。</font></font><br>
<br>
<pre><code class="plaintext hljs">0xdeadbeef — HexNumber ( )<font></font>
1231234234 — WholeNumber ( )<font></font>
3.1412 — FloatingNumber (   )<font></font>
55.5555 — FloatingNumber (   )<font></font>
0b0001 — BinaryNumber ( )</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単語の定義は難しい場合があります。</font><font style="vertical-align: inherit;">ほとんどの言語は単語を文字と数字のシーケンスとして定義し、識別子は通常文字またはアンダースコアで始まる必要があります。</font><font style="vertical-align: inherit;">例えば：</font></font><br>
<br>
<pre><code class="plaintext hljs">123foobar := 3<font></font>
person-age := 5<font></font>
fmt.Println(123foobar)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goでは、このコードは正しくないと見なされ、次のトークンに解析されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">Number(123), Identifier(foobar), Symbol(:=), Number(3) ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
遭遇するほとんどの識別子は次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">foo_bar<font></font>
__uint8_t<font></font>
fooBar123</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アナライザーは、スペース、複数行と単一行のコメント、識別子、数値、数値システム、数値形式（1_000_000など）、およびエンコーディング（ASCIIではなくUTF8のサポートなど）などの他の問題を解決する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、あなたが正規表現に頼ることができると思うなら-それだけの価値はありません。アナライザーを最初から作成する方がはるかに簡単ですが、私は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を私たちの王であり神であるRob Pikeから</font><font style="vertical-align: inherit;">読むことを強くお勧め</font><font style="vertical-align: inherit;">します。 Regexが適さない理由は他の多くの記事で説明されているため、この点は省略します。さらに、アナライザーを作成することは、午前5時24分にregex101.comにアップロードされた長い冗長な式で悩むよりもはるかに興味深いものです。私の最初の言語では、トークン化関数を使用しました</font></font><code>split(str)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -高度からは程遠い。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解析中</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構文解析は字句解析よりもやや複雑です。</font><font style="vertical-align: inherit;">多くのパーサーとパーサージェネレーターがあります-ここでゲームは大きな方法で始まります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラのパーサーは通常、トークンの形式で入力を取り、特定のツリー（抽象構文ツリーまたは構文解析ツリー）を構築します。</font><font style="vertical-align: inherit;">それらの性質上、それらは類似していますが、いくつかの違いがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのステージは、関数として表すことができます。</font></font><br>
<br>
<pre><code class="plaintext hljs">fn lex(string input) []Token {...}<font></font>
fn parse(tokens []Token) AST {...}<font></font>
<font></font>
let input = "int main() { return 0; }";<font></font>
let tokens = lex(input);<font></font>
let parse_tree = parse(tokens);<font></font>
// ....</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、コンパイラは、入力を受け取ったり、変更したり、別の出力に変換したりする多くの小さなコンポーネントから構築されます。</font><font style="vertical-align: inherit;">これが、関数型言語がコンパイラーの作成に適している理由の1つです。</font><font style="vertical-align: inherit;">他の理由は、優れたベンチマークとかなり広範な標準ライブラリです。</font><font style="vertical-align: inherit;">面白い</font><font style="vertical-align: inherit;">事実：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rust</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラの最初の実装</font><font style="vertical-align: inherit;">はOcamlでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのコンポーネントをできるだけシンプルかつ自律的に保つことをお勧めします。モジュール化によりプロセスが大幅に容易になります。</font><font style="vertical-align: inherit;">私の意見では、ソフトウェア開発の他の多くの側面についても同じことが言えます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">木</font></font></h2><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構文解析ツリー</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはなに？</font><font style="vertical-align: inherit;">解析ツリーとも呼ばれるこの厚いツリーは、ソースプログラムを視覚化するのに役立ちます。</font><font style="vertical-align: inherit;">これらには、入力プログラムに関するすべての情報（またはそのほとんど）が含まれており、通常は言語の文法で記述されているものと同じです。</font><font style="vertical-align: inherit;">各ツリーノードは、たとえば、NumberConstantまたはStringConstantのように、後続または非後続になります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象構文木</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
名前が示すように、ASDは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象的な</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構文ツリーです。</font><font style="vertical-align: inherit;">解析ツリーには、プログラムに関する多くの（多くの場合冗長な）情報が含まれており、ASDの場合は必要ありません。</font><font style="vertical-align: inherit;">ASDは、構造と文法に関する不要な情報を必要としません。これは、プログラムのセマンティクスに影響を与えません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツリーに（（5 + 5）-3）+2のような式があるとします。</font><font style="vertical-align: inherit;">解析ツリーでは、ブラケット、演算子、値5、5、3、2とともに完全に格納しますが、ASDに関連付けるだけで済みます。必要なのは、値、演算子、およびその順序だけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の図は、式a + b / cのツリーを示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98c/61a/cb3/98c61acb355e7887b53b5c37de0aa34f.png" width="400"></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ASDは次のように表すことができます。</font></font><br>
<br>
<pre><code class="plaintext hljs">interface Expression { ... };<font></font>
<font></font>
struct UnaryExpression {<font></font>
  Expression value;<font></font>
  char op;<font></font>
};<font></font>
<font></font>
struct BinaryExpression {<font></font>
  Expression lhand, rhand;<font></font>
  string op; // string because the op could be more than 1 char.<font></font>
};<font></font>
<font></font>
interface Node { ... };<font></font>
<font></font>
// or for something like a variable<font></font>
struct Variable : Node {<font></font>
  Token identifier;<font></font>
  Expression value;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このビューは非常に制限されていますが、ノードがどのように構造化されるかがわかると思います。</font><font style="vertical-align: inherit;">解析するには、次の手順を使用できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">Node parseNode() {<font></font>
  Token current = consume();<font></font>
  switch (current.lexeme) {<font></font>
  case "var":<font></font>
    return parseVariableNode();<font></font>
  // ...<font></font>
  }<font></font>
  panic("unrecognized input!");<font></font>
}<font></font>
<font></font>
Node n = parseNode();<font></font>
if (n != null) {<font></font>
  // append to some list of top level nodes?<font></font>
  // or append to a block of nodes!<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高水準言語構造から始めて、残りのノードの段階的な解析がどのように進むかについての要点を理解していただければ幸いです。</font><font style="vertical-align: inherit;">再帰的下降を伴うパーサーがどのように正確に実装されるかについては、自分で学ぶ必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一連のトークンからのADSの解析は困難な場合があります。通常、言語の文法から始める必要があります。本質的に、文法はあなたの言語の構造を決定します。自分自身を記述（または解析）できる言語を定義するためのいくつかの言語があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言語を決定するための言語の例は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Backus-Naur</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（RBNF）の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">拡張形式です</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">山かっこが少ない</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BNFの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バリエーションです</font><font style="vertical-align: inherit;">。 Wikipediaの記事のRBNFの例を次に示します。</font></font><br>
<br>
<pre><code class="plaintext hljs">digit excluding zero = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;<font></font>
digit                = "0" | digit excluding zero ;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロダクションルールが定義されています。これらは、どのターミナルテンプレートが「非ターミナル」であるかを示します。</font><font style="vertical-align: inherit;">端末はアルファベットの一部です。たとえば、上記の例のifトークンまたは0と1は端末です。</font><font style="vertical-align: inherit;">非ターミナルはそれらの反対であり、それらはプロダクションルールの左側にあり、変数またはターミナルおよび非ターミナルのグループへの「名前付きポインター」と見なすことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの言語には、文法を含む仕様があります。</font><font style="vertical-align: inherit;">たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rust</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、および</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dの場合</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再帰降下アナライザー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再帰的降下は、多くの解析手法の中で最も簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再帰降下アナライザー-再帰的手順に基づいて下降します。</font><font style="vertical-align: inherit;">文法には</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再帰</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">残っ</font></a><font style="vertical-align: inherit;">ていないため、パーサーを作成する方がはるかに簡単</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">ほとんどの「おもちゃ」の言語では、この手法は解析に十分です。</font><font style="vertical-align: inherit;">GCCは手動で書き留められたパーサーを使用しますが、以前はYACCが使用されていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、これらの言語を解析すると問題が発生する可能性があります。</font><font style="vertical-align: inherit;">特に、C</font></font><br>
<br>
<pre><code class="cpp hljs">foo * bar</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
として解釈することができます</font></font><br>
<br>
<pre><code class="plaintext hljs">int foo = 3;<font></font>
int bar = 4;<font></font>
foo * bar; // unused expression</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
またはどうやって </font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct {<font></font>
int b;<font></font>
} foo;<font></font>
foo* bar;<font></font>
bar.b = 3;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Clangの実装では再帰降下アナライザーも使用します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは通常のC ++コードであるため、再帰降下により初心者は簡単に理解できます。</font><font style="vertical-align: inherit;">C / C ++が必要とするカスタムルールやその他の奇妙なことをサポートし、エラーの診断と修正を容易にします。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のアプローチにも注意を払う価値があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">降順LL、再帰降下</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">昇順LR、シフト、昇順降下</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パーサージェネレーター</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の良い方法。もちろん、デメリットもありますが、これは、ソフトウェアを作成するときにプログラマが行うその他の選択についても言えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーサージェネレーターは非常に活発に動作します。独自のアナライザーを作成して高品質の結果を取得するよりも、それらを使用する方が簡単です。ただし、ユーザーフレンドリーではなく、常にエラーメッセージを表示するわけではありません。さらに、パーサージェネレーターの使用方法を習得する必要があり、コンパイラーを昇格するときは、おそらくパーサージェネレーターを巻き戻す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーサージェネレーターの例は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANTLRですが</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、他にもたくさんあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このツールは、フロントエンドの作成に時間をかけたくない方、コンパイラー/インタープリターの中間とバックエンドを作成して何でも分析したい方に適していると思います。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解析アプリケーション</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたはまだ自分自身を理解していない場合。</font><font style="vertical-align: inherit;">コンパイラのフロントエンド（lex / parse）でも他の問題を解決するために使用できます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構文の強調表示</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリングエンジンのHTML / CSS解析</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トランスパイラー：TypeScript、CoffeeScript</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンカー</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正規表現</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェースデータ分析</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">URL解析</font></font></li>
<li><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">gofmtの</font></i><font style="vertical-align: inherit;">ようなフォーマットツール</font></font><i><font style="vertical-align: inherit;"></font></i></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL解析など。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ミッド</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セマンティック分析！</font><font style="vertical-align: inherit;">言語のセマンティクスの分析は、コンパイラーを作成するときに最も困難なタスクの1つです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての入力プログラムが正しく動作することを確認する必要があります。</font><font style="vertical-align: inherit;">これまでのところ、セマンティック分析に関連する側面は私のクルーグ言語に含まれていません。それがないと、プログラマーは常に正しいコードを書く必要があります。</font><font style="vertical-align: inherit;">実際には、これは不可能であり、私たちは常にエラーを記述し、コンパイルし、時には実行し、修正します。</font><font style="vertical-align: inherit;">このスパイラルは無限です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、プログラムのコンパイルは、コンパイルの適切な段階でセマンティクスの正しさを分析しないと不可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
むかしむかし、フロントエンド、ミッドランド、バックエンドの割合に特化したチャートに出くわしました。</font><font style="vertical-align: inherit;">それからそれはのように見えました</font></font><br>
<br>
<pre><code class="plaintext hljs">F: 20% M: 20%: B: 60%</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 今日のようなものです</font></font><br>
<br>
<pre><code class="plaintext hljs">F: 5% M: 60% B: 35%</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フロントエンドは主にジェネレーターに関係しており、文法の二重性を持たないコンテキストレス言語では、それらは非常に迅速に完了することができます-再帰的降下が役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLVMテクノロジーを使用すると、最適化作業のほとんどをフレームワークにロードでき、既成の最適化の数が示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のステップは、コンパイルフェーズの重要な部分であるセマンティック分析です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、Rustでは、メモリ管理モデルを使用して、コンパイラーは大規模で強力なマシンとして機能し、導入フォームでさまざまなタイプの静的分析を実行します。このタスクの一部は、分析のために入力データをより便利な形式に変換することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このため、コンパイラーのアーキテクチャーではセマンティック分析が重要な役割を果たし、生成されたアセンブリーの最適化やASDの入力データの読み取りなど、準備作業がすべて行われます。 </font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セマンティックパッセージ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セマンティック分析の過程で、ほとんどのコンパイラーは、SDAまたはその他の抽象的な形式のコード式に対して多数の「セマンティックパス」を実行します。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、.NET C＃コンパイラで行われたほとんどのパスについて詳しく</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">説明し</font></a><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特にパッセージは言語によって異なるため、各パッセージについては説明しませんが、いくつかのステップについては、Krugで説明しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トップレベルの広告</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーは、モジュール内のすべての「トップレベル」アナウンスを通過し、それらの存在を認識します。</font><font style="vertical-align: inherit;">彼はブロックを深く掘り下げることはありません-彼は単にどの構造、関数などを宣言するだけです。</font><font style="vertical-align: inherit;">いずれかのモジュールで使用できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前/記号の解決</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーは、関数などのコードのすべてのブロックを通過します。</font><font style="vertical-align: inherit;">それらを解決します-つまり、許可を必要とする文字を見つけます。</font><font style="vertical-align: inherit;">これは一般的なパスであり、</font><font style="vertical-align: inherit;">Goコードのコンパイル時に</font><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このようなシンボルXYZ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラーは通常発生し</font><i><font style="vertical-align: inherit;">ません</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この依存関係の実行は、特に依存関係図に循環依存関係がある場合、非常に難しい場合があります。</font><font style="vertical-align: inherit;">一部の言語では許可されていません。たとえば、Krug言語のように、パッケージの1つがループを形成するとGoがエラーをスローします。</font><font style="vertical-align: inherit;">循環的な依存関係は、貧弱なアーキテクチャの副作用と見なすことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ループは、依存関係図でDFSを変更するか、</font><font style="vertical-align: inherit;">（Krugによって行われた）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarjanアルゴリズム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して（複数の）ループを定義する</font><font style="vertical-align: inherit;">ことによって決定でき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型推論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラはすべての変数を調べ、それらの型を表示します。 Krugの型推論は非常に弱く、単に値に基づいて変数を出力します。 Haskellのような関数型言語で見られるような奇妙なシステムではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプは、「統合」プロセスまたは「タイプ統合」を使用して導出できます。より単純な型システムの場合、非常に単純な実装を使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプは次のようにKrugに実装されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">interface Type {};<font></font>
<font></font>
struct IntegerType : Type {<font></font>
  int width;<font></font>
  bool signed;<font></font>
};<font></font>
<font></font>
struct FloatingType : Type {<font></font>
  int width;<font></font>
};<font></font>
<font></font>
struct ArrayType : Type {<font></font>
  Type base_type;<font></font>
  uint64 length;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、式ノードに型を割り当てる単純な型推論を持つことも</font></font><code>IntegerConstantNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">できます。</font><font style="vertical-align: inherit;">たとえば、</font><font style="vertical-align: inherit;">IntegerType（64）型に</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">ことができます。</font><font style="vertical-align: inherit;">そして、</font></font><code>unify(t1, t2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">より複雑な式、たとえばバイナリ式の型を推測するために使用できる最も広い型を選択</font><font style="vertical-align: inherit;">する関数が</font><font style="vertical-align: inherit;">あるとします。</font><font style="vertical-align: inherit;">したがって、左側の変数を右側の特定の型の値に割り当てることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はかつて</font><font style="vertical-align: inherit;">Goで</font><font style="vertical-align: inherit;">シンプルな</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型キャスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">書いて</font><font style="vertical-align: inherit;">、それがKrugのプロトタイプ実装になりました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可変パス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（Rustのような）Krugはデフォルトで不変の言語です。つまり、特に指定されない限り、変数は変更されません。</font></font><br>
<br>
<pre><code class="plaintext hljs">let x = 3;<font></font>
x = 4; // BAD!<font></font>
<font></font>
mut y = 5;<font></font>
y = 6; // OK!</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーはすべてのブロックと関数を調べ、それらの「変数が正しい」ことを確認します。つまり、従わないものは変更せず、特定の関数に渡されるすべての変数は定数または必要に応じて変更可能であることを確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、以前のパスで収集されたシンボリック情報を利用して行われます。</font><font style="vertical-align: inherit;">セマンティックパスの結果に基づくシンボルテーブルには、トークン名と可変変数の符号が含まれています。</font><font style="vertical-align: inherit;">これには他のデータが含まれる場合があります。たとえば、C ++では、テーブルはシンボルが外部か静的かに関する情報を格納できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャラクターテーブル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文字テーブル、つまり「スタブ」は、プログラムで使用される文字を見つけるためのテーブルです。</font><font style="vertical-align: inherit;">スコープごとに1つのテーブルが作成され、すべてのテーブルに特定のスコープに存在する文字に関する情報が含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この情報には、シンボル名、タイプ、可変性の兆候、外部通信の存在、スタティックメモリ内の場所などのプロパティが含まれます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可視領域</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、プログラミング言語における重要な概念です。</font><font style="vertical-align: inherit;">もちろん、言語でネストされたスコープを作成できるようにする必要はありません。すべてを1つの共通の名前空間に配置できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スコープの表現はコンパイラアーキテクチャにとって興味深いタスクですが、ほとんどのC言語のような言語では、スコープはスタックデータ構造のように動作します（または動作します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、スコープを作成して破棄します。スコープは通常、名前の管理に使用されます。つまり、スコープを使用して変数を非表示（シャドウ）できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">{ // push scope<font></font>
  let x = 3;<font></font>
  { // push scope<font></font>
    let x = 4; // OK!<font></font>
  } // pop scope<font></font>
} // pop scope</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の方法で表すことができます。</font></font><br>
<br>
<pre><code class="plaintext hljs">struct Scope {<font></font>
  Scope* outer;<font></font>
  SymbolTable symbols;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小さなオフトピックですが、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スパゲッティスタック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について読むことをお勧めし</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、反対側のブロックのASDノードに可視領域を格納するために使用されるデータ構造です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型システム</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下のセクションの多くは個別の記事に発展させることができますが、このタイトルがこれに最もふさわしいように思えます。</font><font style="vertical-align: inherit;">今日、多くのコピーが壊れる型システム、およびシステム自体の多様性に関する多くの情報が利用可能です。</font><font style="vertical-align: inherit;">このトピックについては</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">深く掘り下げ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ません</font><font style="vertical-align: inherit;">。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">スティーブクラブニックの優れた記事</font></a><font style="vertical-align: inherit;">へのリンクを残してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
型システムとは、コンパイラー表現とこれらの表現の分析を使用して、コンパイラーで提供され、意味的に定義されるものです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所持</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この概念はプログラミングでますます使用されます。所有権と運動のセマンティクスの原則は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rust</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">言語に組み込まれており、</font><font style="vertical-align: inherit;">それらが他の言語で表示されることを期待しています。 Rustはさまざまな種類の静的分析を実行し、入力がメモリに関する一連のルールを満たすかどうかを確認します。つまり、誰がどのメモリを所有し、いつメモリが破壊され、これらの値またはメモリへの参照（または借用）がいくつ存在するかを確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rustの優れている点は、これらすべてがコンパイラーの内部でコンパイル中に行われるため、プログラマーがガベージコレクションやリンクカウントを処理する必要がないことです。これらすべてのセマンティクスは型システムに割り当てられ、プログラムが完全なバイナリファイルとして提供される前でも提供できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが内部でどのように機能するかは言えませんが、これはすべて、Mozillaチームと</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cyclone</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトの参加者による静的分析とすばらしい研究の結果です</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制御フローグラフ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムフローを表すために、プログラム実行がたどることができるすべてのパスを含む制御フローグラフ（CFG）を使用します。</font><font style="vertical-align: inherit;">これはセマンティック分析で使用され、コードの機能していないセクション、つまり、プログラムの実行中に決して達成されないブロック、関数、さらにはモジュールを除外します。</font><font style="vertical-align: inherit;">グラフを使用して、中断できないサイクルを特定することもできます。</font><font style="vertical-align: inherit;">または、たとえば「パニック」（パニックを呼び出す）を引き起こしたり、ループに戻ったりして、ループ外のコードが実行されない場合など、アクセスできないコードを検索するため。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データフロー分析</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、コンパイラーのセマンティックフェーズで重要な役割を果たすため、実行できる分析の種類、それらがどのように機能するか、最適化によって何ができるかについて読むことをお勧めします。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックエンド</font></font></h2><br>
<img src="https://habrastorage.org/getpro/habr/post_images/330/914/1b9/3309141b9d53be1d9e5c8f77fb46d982.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アーキテクチャスキームの最後の部分。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行可能なバイナリを生成する作業のほとんどを実行しました。</font><font style="vertical-align: inherit;">これは、以下で説明するさまざまな方法で実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツリーに含まれる情報により、意味解析のフェーズを大幅に変更する必要はありません。</font><font style="vertical-align: inherit;">「スパゲッティ」の発生を避けるために、まったく変更しない方がよいでしょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トランスパイラーに関する一言</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ある言語のコードを別の言語のソースコードに変換するタイプのコンパイラです。たとえば、Cでソースにコンパイルするコードを書くことができます。私の意見では、あなたの言語がそれがコンパイルされる言語よりもはるかに劣っていない限り、事はかなり無意味です。通常、トランスプリケーションは、比較的高級な言語、または障害のある言語に対して理にかなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、コンパイラーの歴史では、Cコードへの変換は非常に一般的であり、実際、最初のC ++コンパイラー-Cfront-はCコードに変換されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
良い例がJavaScriptです。</font><font style="vertical-align: inherit;">TypeScriptや他の多くの言語は、より多くの機能、さらに重要なのは、実行時にバグやエラーに遭遇する前にバグやエラーをキャッチするためのさまざまなタイプの静的分析を備えた機密タイプシステムを提供するために、コードに転置します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはコンパイラーの「目標」の1つであり、ほとんどの場合最も単純です。これは、変数の割り当て、最適化の操作など、より低いレベルの概念について考える必要がないためです。</font><font style="vertical-align: inherit;">ただし、このアプローチには明らかな欠点があります。多くのオーバーヘッドが発生するだけでなく、通常、コードの翻訳先の言語の機能によって制限されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの最新のコンパイラーは通常、バックエンドとしてLLVMを使用します：Rust、Swift、C / C ++（clang）、D、Haskell。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの作業は幅広いアーキテクチャをサポートするために行われており、トップレベルの最適化を利用できるため、これは「簡単な方法」と考えることができます。</font><font style="vertical-align: inherit;">前述の翻訳と比較して、LLVMは優れた管理機能も提供します。</font><font style="vertical-align: inherit;">Cでコンパイルした場合よりも確かに多くなります。たとえば、型の大きさを1、4、8、16ビットなどに決定できます。</font><font style="vertical-align: inherit;">Cでは、これはそれほど単純ではなく、時には不可能であり、プラットフォームによっては定義することさえ不可能です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブラコードの生成</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定のアーキテクチャ用のコードの生成、つまりマシンコードの生成は、多くのプログラミング言語で使用されている技術的に最も一般的な方法です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goは、LLVMフレームワーク（この記事の執筆時点）を利用しない現代の言語の例です。 Goは、Windows、Linux、MacOSなど、いくつかのプラットフォーム用のコードを生成します。 Krugプロトタイプがアセンブラコードの生成にも使用していたのはおかしいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチには多くの利点と欠点があります。ただし、今日、LLVMなどのテクノロジーが利用できる場合、独自のアセンブラーを生成するのは賢明ではありません。独自のバックエンドを備えたおもちゃのコンパイラーが、いくつかのプラットフォームはもちろんのこと、1つのプラットフォームの最適化レベルでLLVMを超える可能性は低いためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、自己アセンブラー生成の大きな利点は、LLVMのようなフレームワークを使用した場合よりもコンパイラーがはるかに高速になる可能性が高いことです。LLVMは、最初にIRのアセンブル、最適化などを行い、最後にアセンブラーを生成できる必要があります。 （またはあなたが選択したもの）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、それでも試してみるのは良いことです。</font><font style="vertical-align: inherit;">さらに、アセンブリ言語プログラミングについて、またはプログラミング言語が低レベルでどのように機能するかについて詳しく知りたい場合は、興味深いでしょう。</font><font style="vertical-align: inherit;">最も簡単な方法は、ASDまたは生成されたIR（ある場合）を開き、fprintfまたは別のユーティリティを使用してファイルにアセンブラー命令を「発行」することです。</font><font style="vertical-align: inherit;">これが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8ccの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕組み</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイトコードの生成</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定のタイプの仮想マシンまたはバイトコードインタープリターのバイトコードを生成することもできます。</font><font style="vertical-align: inherit;">印象的な例はJavaです。実際、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はKotlinなどのバイトコード生成言語のファミリー全体を生成しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイトコード生成には多くの利点があり、移植性がJavaの主なものでした。</font><font style="vertical-align: inherit;">仮想マシンをどこでも実行できる場合、仮想マシン上で実行されるコードはどこでも機能します。</font><font style="vertical-align: inherit;">さらに、いくつかのコンピュータアーキテクチャでコードを生成するよりも、マシンでバイトコード命令の抽象的なセットを実行する方がはるかに簡単です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の知る限り、JITを使用するJVMは、頻繁に使用されるコードをネイティブ関数に変換し、他のJITトリックを適用してさらに多くのパフォーマンスを絞り出します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらはコンパイラーの不可欠な部分であり、実行速度の遅いコードは必要ありません。通常、最適化はバックエンドの大部分を占め、開発者はパフォーマンスの向上に多大な努力を注ぎます。 Cコードをコンパイルしてすべての最適化で実行すると、それがどれほどクレイジーであるかに驚くでしょう。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Godbolt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、最新のコンパイラがコードを生成する方法と、どの命令がどのソースコードに関連するかを理解するための優れたツールです。また、最適化のレベル、目標、コンパイラのバージョンなどを設定することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラを作成したことがある場合は、簡単なCプログラムを作成し、すべての最適化をオフにしてデバッグシンボルを取り除き、GCCが生成するものを確認できます。その後、問題が発生した場合にそれをリマインダーとして使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最適化を調整する場合、プログラムの正確さと速度の間の妥協点を見つけることができます。しかし、適切なバランスを見つけることはそれほど簡単ではありません。一部の最適化は非常に具体的であり、場合によっては誤った結果につながる可能性があります。明らかな理由により、これらは本番コンパイラには含まれていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別のリソースに関するこの記事で、ユーザーrwmjは、コンパイラーの最大パフォーマンスの80％を得るには8つの最適化パスだけで十分であることに気付きました。</font><font style="vertical-align: inherit;">そして、これらすべての最適化は1971年に説明されました！</font><font style="vertical-align: inherit;">私たちは</font><font style="vertical-align: inherit;">、Rustの首謀者で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ある</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Graydon Hoar </font><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">出版</font></a><font style="vertical-align: inherit;">について話している</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IR</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中間表現（IR）は必須ではありませんが、役立ちます。 ASDからコードを生成できますが、非常に面倒で面倒な場合があり、結果の最適化は困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IRは、生成されたコードのより高いレベルの表現と考えることができます。それはそれが表すものを非常に正確に反映し、コードの生成に必要なすべての情報を含む必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IRには特定のタイプの「フォーム」があり、IRを使用して作成して、最適化を簡素化できます。たとえば、SSAは静的単一割り当てであり、各変数が一度だけ割り当てられる唯一の静的割り当てです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goでは、コードを生成する前にSSAベースのIRが構築されます。 LLVM IRはSSAに基づいて最適化を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、SSAはいくつかの最適化を提供します。たとえば、一定の伝播、機能しないコードの除外、および（非常に重要な）レジスタ割り当てなどです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レジスター割り当て</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはコード生成の要件ではなく、最適化です。与えられたと考える抽象化の1つは、プログラムに必要なだけ変数を定義できることです。ただし、アセンブラーでは、注意が必要な有限数のレジスター（通常は16から32まで）を持っているか、スタックを使用する（スタックに注ぐ）ことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レジスター割り当ては、特定の時点で（他の値を上書きせずに）特定の変数の特定のレジスターを選択する試みです。これはスタックを使用するよりもはるかに効率的ですが、追加のコストが発生する可能性があり、コンピューターが常に理想的な分散スキームを計算できるとは限りません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかのレジスタ割り当てアルゴリズムがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グラフのカラーリング（グラフのカラーリング）は、計算が複雑です（NP完全問題）。</font><font style="vertical-align: inherit;">変数の寿命の範囲を計算するには、コードをグラフの形で提示する必要があります。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラインスキャン-変数をスキャンし、それらの寿命範囲を決定します。</font></font><br>
</li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">覚えておくべきこと</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーについてはたくさん書かれています。</font><font style="vertical-align: inherit;">それはどんな記事にも適合しません。</font><font style="vertical-align: inherit;">今後のプロジェクトの過程で覚えておく必要があるいくつかの重要な点を思い出させるか、少なくとも触れておきたいと思います。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前のゆがみ（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Name Mangling</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スコープや名前空間が実際に存在しないアセンブラコードを生成すると、文字の競合が頻繁に発生します。</font><font style="vertical-align: inherit;">特に、言語が関数やクラスのオーバーライドなどをサポートしている場合。</font></font><br>
<br>
<pre><code class="plaintext hljs">fn main() int {<font></font>
  let x = 0;<font></font>
  {<font></font>
    let x = 0;<font></font>
    {<font></font>
      let x = 0;<font></font>
    }<font></font>
  }<font></font>
  return 0;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、このコードでは（変数が何らかの方法で最適化されていない場合:)）アセンブラーで競合しないように、これらの文字の名前を変形する必要があります。</font><font style="vertical-align: inherit;">また、歪みは通常、情報のタイプを示すために使用されます。または、名前空間情報が含まれる場合もあります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デバッグ情報</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LLDBのようなツールは通常</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DWARFの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ような標準を使用します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">LLVMの優れた点の1つは、DWARFを使用すると、既存のGNUデバッグツールキットと比較的簡単に統合できることです。</font><font style="vertical-align: inherit;">言語によってはデバッグツールが必要になる場合があります。また、独自のツールを作成するよりも既製のツールを使用する方が常に簡単です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外部関数インターフェース（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、libcはどこにも行けません。このライブラリについて読んで、それを自分の言語に埋め込む方法を考える必要があります。</font><font style="vertical-align: inherit;">Cコードにどのように接続しますか、またはCのコードをどのように開きますか？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンカ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リンカーの作成は別のタスクです。</font><font style="vertical-align: inherit;">コンパイラーがコードを生成するとき、それはマシン命令を（.s / .asmファイルで）生成しますか？</font><font style="vertical-align: inherit;">オブジェクトファイルに直接コードを書き込みますか？</font><font style="vertical-align: inherit;">たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jai</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラミング言語では、</font><font style="vertical-align: inherit;">すべてのコードが単一のオブジェクトファイルに書き込まれていると考えられます。</font><font style="vertical-align: inherit;">妥協点が特徴的なさまざまなオプションがあります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスとしてのコンパイラ（CaaS）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、上記のすべてのコンパイラフェーズは、APIルートによって配布されます。つまり、テキストエディターはKrugサーバーにアクセスしてファイルをトークン化し、応答としてトークンを返すことができます。さらに、すべての静的解析パスが開いているため、ツールが簡単になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、このアプローチには、ファイルの送受信の遅延などの欠点があります。さらに、APIルートのコンテキストで機能するには、コンパイラアーキテクチャの多くの側面を再考する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CaaSアプローチを使用する本番コンパイラはほとんどありません。 Microsofts Roslynが思い浮かびますが、私はこのコンパイラについてほとんど知らないので、自分で調べてください。そして私は間違っているかもしれませんが、多くのコンパイラーがこのアプローチを実装しているようですが、それらの作成者は既存のコンパイラーに接続するAPIルートを作成します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">たとえば、Rustには</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RLSがあり</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のKrug言語では-まだ活発に開発されており、不安定です-CaasperコンパイラーはCaaSアーキテクチャーを使用しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Caasperはマシン上でローカルに（または必要に応じてサーバー上で）実行され、フロントエンドまたはクライアント（krugなど）がこのサービスと対話します。プラスは、多くのフロントエンド実装があり、コンパイラ全体を書き直す前に、言語自体にロードできる唯一のフロントエンド（ブートストラップ）があることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
KrugのフロントエンドはJavaScriptで実装されていますが、Go *だけでなく、Krug自体にも別の実装があるでしょう。 JavaScriptはその可用性のために選択されたもので、非常に人気のあるyarn / npmパッケージマネージャーでダウンロードできます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*当初、フロントエンドはGoで記述され、JSバージョンよりもはるかに高速である（予想される）ことがわかりました。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Caasperコンパイラのソースコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。私の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">個人的な</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GithubはKrugのプロトタイプであり、Dで記述され、LLVMでコンパイルされます。</font><font style="vertical-align: inherit;">デモはYouTube </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チャンネルで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もご覧いただけ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クルーグのマニュアル（中級）は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">役立つリンク</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jack Crenshaw</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、プログラミング言語の世界への私の個人的な扉です。</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通訳の作成</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM入門（Go付き）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -私！</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL / 0</font></font></a><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドラゴンブックはそれをすべて持っている古典的な本です。</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8cc</font></font></a><br>
</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja451878/index.html">VRグラス（Oculus Go）へのステレオビデオのライブストリーミング</a></li>
<li><a href="../ja451880/index.html">DevPRO'19：Wrikeブースからの眺め</a></li>
<li><a href="../ja451884/index.html">開発者としての7年間の仕事：私が学んだ教訓</a></li>
<li><a href="../ja451886/index.html">テストで離散数学を使用する</a></li>
<li><a href="../ja451890/index.html">BINDの24未満の逆サブネットゾーンの委任。使い方</a></li>
<li><a href="../ja451896/index.html">「壊れない」eyeDiskはアイリススキャンによって保護されていますが、パスワードをクリアテキストで送信します</a></li>
<li><a href="../ja451898/index.html">ロシア語でのイノベーション</a></li>
<li><a href="../ja451900/index.html">FacebookからのブラウザーAPIへの最初の貢献</a></li>
<li><a href="../ja451902/index.html">Microsoft Azure開発者キャンプロシア</a></li>
<li><a href="../ja451904/index.html">時々、多くは少ないです。負荷の減少が遅延の増加につながる場合</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>