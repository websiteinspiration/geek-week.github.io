<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíáüèΩ üê∑ üò≤ Fast and easy volume rendering algorithm ü§üüèæ üåã üë∑üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I recently wrote a small ShaderToy that does simple volumetric rendering, and then decided to publish a post explaining its work. The interactive Shad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Fast and easy volume rendering algorithm</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500914/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/8r/iy/wc/8riywca1jhipnzh4e3ycjritfec.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I recently wrote a small ShaderToy that does simple volumetric rendering, and then decided to publish a post explaining its work. </font><font style="vertical-align: inherit;">The interactive ShaderToy itself can be viewed </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If you are reading from a phone or laptop, I recommend watching </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quick version. </font><font style="vertical-align: inherit;">I included code snippets in the post that will help you understand ShaderToy‚Äôs performance at a high level, but they don‚Äôt have all the details. </font><font style="vertical-align: inherit;">If you want to dig deeper, I recommend checking with the ShaderToy code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My ShaderToy had three main tasks:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Real time execution</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplicity</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Physical correctness (... or something like that)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will start with this blank code scene. </font><font style="vertical-align: inherit;">I will not go into details of the implementation, because it is not very interesting, but I will briefly tell you where we start:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ray tracing of opaque objects. </font><font style="vertical-align: inherit;">All objects are primitives with simple intersections with rays (1 plane and 3 spheres)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To calculate the lighting, Phong shading is used, and in three spherical light sources, a custom light attenuation coefficient is used. </font><font style="vertical-align: inherit;">Rays of shadows are not required, because we illuminate only the plane.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here's what it looks like:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba8/4dc/f82/ba84dcf8277762a067454fb786d266be.jpg" alt="ShaderToy screenshot"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will render the volume as a separate passage that mixes with an opaque scene; </font><font style="vertical-align: inherit;">this is similar to how all real-time rendering engines individually process opaque and translucent surfaces.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 1: simulate volume</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But first, before we can start volumetric rendering, we need this same volume! To simulate volume, I decided to use signed distance functions (SDF). Why precisely the functions of distance fields? Because I'm not an artist, but they allow you to create very organic forms in just a few lines of code. I will not talk in detail about the functions of distances with a sign, because Inigo Kiles has already explained them wonderfully. If you are curious, then </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a great list of different func- tions of sign distances and modifiers. And </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is another article about these raymarching SDF. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start with a simple one and add a sphere here:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c03/5c4/536/c035c45368ef0cd0e232041b4ca2eec4.jpg" alt="ShaderToy screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we will add another sphere and use smooth conjugation to merge the distance functions of the spheres. </font><font style="vertical-align: inherit;">This code I took directly from the Inigo page, but for clarity, I will insert it here:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Taken from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdSmoothUnion</span><span class="hljs-params">( <span class="hljs-keyword">float</span> d1, <span class="hljs-keyword">float</span> d2, <span class="hljs-keyword">float</span> k )</span> 
</span>{
    <span class="hljs-keyword">float</span> h = clamp( <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>*(d2-d1)/k, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> );
    <span class="hljs-keyword">return</span> mix( d2, d1, h ) - k*h*(<span class="hljs-number">1.0</span>-h); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Smooth pairing is an extremely powerful tool, because you can get something quite interesting by simply combining it with a few simple shapes. </font><font style="vertical-align: inherit;">Here's what my many smoothly conjugate spheres look like:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/c3c/4b4/ddcc3c4b4f6d38d509b69cae63088c4a.jpg" alt="ShaderToy screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we got something teardrop-shaped, but we need something more like a cloud than a drop. A great feature of SDF is how easy it is to distort the surface by simply adding a bit of noise to the SDF. So let's add some fractal Brownian motion (fBM) on top of the noise, using the position to index the noise function. Inigo Kiles also covered this topic in a great </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on fBM noise. Here's what the image with fBM noise superimposed will look like:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a47/bd6/bbd/a47bd6bbd487a37bc5e07a8f65e6436d.jpg" alt="ShaderToy screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fine! </font><font style="vertical-align: inherit;">Thanks to fBM noise, the object suddenly began to look much more interesting! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we need to create the illusion that the volume interacts with the plane of the earth. </font><font style="vertical-align: inherit;">To do this, I added a distance of the signed plane slightly below the ground plane and reused the combination of smooth pairing with a very aggressive pairing value (parameter k). </font><font style="vertical-align: inherit;">After that, we got this picture:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/7e9/863/8d27e9863fb9637575e23a4cf593f90e.jpg" alt="ShaderToy screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The final touch will be the change in the xz index of fBM noise over time, so that the volume looks like swirling fog. </font><font style="vertical-align: inherit;">On the move, it looks very good!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/2d6/6fa/1672d66fa4b2760e9e57bd6062281cc2.gif" alt="ShaderToy screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Great, we got something like a cloud! </font><font style="vertical-align: inherit;">The SDF calculation code is also quite compact:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">QueryVolumetricDistanceField</span><span class="hljs-params">( in vec3 pos)</span>
</span>{    <font></font>
    vec3 fbmCoord = (pos + <span class="hljs-number">2.0</span> * vec3(iTime, <span class="hljs-number">0.0</span>, iTime)) / <span class="hljs-number">1.5f</span>;
    <span class="hljs-keyword">float</span> sdfValue = sdSphere(pos, vec3(<span class="hljs-number">-8.0</span>, <span class="hljs-number">2.0</span> + <span class="hljs-number">20.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">-1</span>), <span class="hljs-number">5.6</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue,sdSphere(pos, vec3(<span class="hljs-number">8.0</span>, <span class="hljs-number">8.0</span> + <span class="hljs-number">12.0</span> * <span class="hljs-built_in">cos</span>(iTime), <span class="hljs-number">3</span>), <span class="hljs-number">5.6</span>), <span class="hljs-number">3.0f</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdSphere(pos, vec3(<span class="hljs-number">5.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">3.0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">8.0</span>), <span class="hljs-number">3.0</span>) + <span class="hljs-number">7.0</span> * fbm_4(fbmCoord / <span class="hljs-number">3.2</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdPlane(pos + vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0</span>)), <span class="hljs-number">22.0</span>);
    <span class="hljs-keyword">return</span> sdfValue;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is just rendering an opaque object. We need a beautiful magnificent fog! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How do we render it in the form of volume, and not an opaque object? Let's first talk about the physics we simulate. Volume is a huge number of particles in a certain area of ‚Äã‚Äãspace. And when I say ‚Äúhuge‚Äù, I mean ‚ÄúHUGE‚Äù. So much so that modeling each of these particles today is an impossible task, even for offline rendering. Good examples of this are fire, fog, and clouds. Strictly speaking, everything is volume, but for the sake of speed of calculations it is easier to close our eyes to this and pretend that it is not. We represent the accumulation of these particles as density values ‚Äã‚Äãthat are usually stored in some kind of 3D grid (or something more complex, for example, in OpenVDB).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When light passes through a volume, a pair of phenomena can occur when light collides with a particle. </font><font style="vertical-align: inherit;">It can either scatter and go in the other direction, or part of the light can be absorbed by the particle and dissolve. </font><font style="vertical-align: inherit;">To comply with the real-time execution requirement, we will perform what is called single scattering. </font><font style="vertical-align: inherit;">This means the following: we will assume that light is scattered only once, when the light collides with a particle and flies towards the camera. </font><font style="vertical-align: inherit;">That is, we will not be able to simulate the effects of multiple scattering, for example, fog, in which objects at a distance usually look more vague. </font><font style="vertical-align: inherit;">But for our system this is quite enough. </font><font style="vertical-align: inherit;">Here's what single scattering looks like when raymarching:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2d/19e/00f/f2d19e00fa758b0addc4ca447c0b024e.jpg" alt="ShaderToy screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The pseudocode for it looks something like this:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> n steps along the camera ray:<font></font>
   Calculate what % <span class="hljs-function">of your ray hit <span class="hljs-title">particles</span> <span class="hljs-params">(i.e. were absorbed)</span> <span class="hljs-keyword">and</span> needs lighting
   <span class="hljs-keyword">for</span> m lights:
      <span class="hljs-keyword">for</span> k steps towards the light:
         Calculate % of light that were absorbe in <span class="hljs-keyword">this</span> step
      Calculate lighting based on how much light is visible
Blend results on top of opaque objects pass based on % of your ray that made it through the volume</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, we are dealing with calculations with complexity O (n * m * k). </font><font style="vertical-align: inherit;">So the GPU will have to work hard.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We calculate the absorption</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, let's look at the absorption of light in volume along the beam of the camera (i.e., let's not perform raymarching in the direction of the light sources yet). </font><font style="vertical-align: inherit;">To do this, we need two actions:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perform raymarching inside the volume</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculate absorption / lighting at each step</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To calculate how much light is absorbed at each point, we use </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Bouguer ‚Äì Lambert ‚Äì Beer law</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which describes the attenuation of light when passing through a material. </font><font style="vertical-align: inherit;">The calculations are surprisingly simple:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">BeerLambert</span><span class="hljs-params">(<span class="hljs-keyword">float</span> absorptionCoefficient, <span class="hljs-keyword">float</span> distanceTraveled)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span>(-absorptionCoefficient * distanceTraveled);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The absorption coefficient is a material parameter. </font><font style="vertical-align: inherit;">For example, in a transparent volume, for example, in water, this value will be low, and for something thicker, for example, milk, the coefficient will be higher. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To perform volume raymarching, we simply take steps of a fixed size along the beam and get absorption at every step. </font><font style="vertical-align: inherit;">You may not understand why to take fixed steps instead of something faster, for example, tracing a sphere, but if you remember that the density within the volume is heterogeneous, then everything becomes clear. </font><font style="vertical-align: inherit;">Below is the raymarching and accumulation absorption code. </font><font style="vertical-align: inherit;">Some variables are outside the scope of this code snippet, so check out the full implementation in ShaderToy.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> opaqueVisiblity = <span class="hljs-number">1.0f</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> marchSize = <span class="hljs-number">0.6f</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_VOLUME_MARCH_STEPS; i++) {<font></font>
	volumeDepth += marchSize;<font></font>
	<span class="hljs-keyword">if</span>(volumeDepth &gt; opaqueDepth) <span class="hljs-keyword">break</span>;<font></font>
	<font></font>
	vec3 position = rayOrigin + volumeDepth*rayDirection;<font></font>
	<span class="hljs-keyword">bool</span> isInVolume = QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0f</span>;
	<span class="hljs-keyword">if</span>(isInVolume) 	{
		<span class="hljs-keyword">float</span> previousOpaqueVisiblity = opaqueVisiblity;<font></font>
		opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
		<span class="hljs-keyword">float</span> absorptionFromMarch = previousOpaqueVisiblity - opaqueVisiblity;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> lightIndex = <span class="hljs-number">0</span>; lightIndex &lt; NUM_LIGHTS; lightIndex++) {
			<span class="hljs-keyword">float</span> lightDistance = length((GetLight(lightIndex).Position - position));<font></font>
			vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance);  <font></font>
			volumetricColor += absorptionFromMarch * volumeAlbedo * lightColor;<font></font>
		}<font></font>
		volumetricColor += absorptionFromMarch * volumeAlbedo * GetAmbientLight();<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And here is what we get with this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/14e/a86/c8714ea862797c656d9c64105c7befed.jpg" alt="ShaderToy screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Looks like candy floss! </font><font style="vertical-align: inherit;">Perhaps for some effects this will be enough! </font><font style="vertical-align: inherit;">But we lack self-shadowing. </font><font style="vertical-align: inherit;">Light reaches all parts of the volume equally. </font><font style="vertical-align: inherit;">But this is not physically correct, depending on the size of the volume between the rendered point and the light source, we will receive a different amount of incoming light.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Self shadowing</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have already done the most difficult. </font><font style="vertical-align: inherit;">We need to do the same thing as we did to calculate the absorption along the beam of the camera, but only along the beam of light. </font><font style="vertical-align: inherit;">The code for calculating the amount of light reaching each point will essentially be a repetition of the code, but duplicating it is easier than hacking HLSL to get the recursion we need. </font><font style="vertical-align: inherit;">So here is what it will look like:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetLightVisiblity</span><span class="hljs-params">(in vec3 rayOrigin, in vec3 rayDirection, in <span class="hljs-keyword">float</span> maxT, in <span class="hljs-keyword">int</span> maxSteps, in <span class="hljs-keyword">float</span> marchSize)</span> </span>{
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0.0f</span>;
    <span class="hljs-keyword">float</span> lightVisiblity = <span class="hljs-number">1.0f</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxSteps; i++) {                       <font></font>
        t += marchSize;<font></font>
        <span class="hljs-keyword">if</span>(t &gt; maxT) <span class="hljs-keyword">break</span>;<font></font>
<font></font>
        vec3 position = rayOrigin + t*rayDirection;<font></font>
        <span class="hljs-keyword">if</span>(QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0</span>) {<font></font>
            lightVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> lightVisiblity;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adding self-shadowing gives us the following:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/6e0/96e/a4f6e096e2250a9aa17594b59cc7e25d.jpg" alt="ShaderToy screenshot"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soften the edges</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the moment, I already quite like our volume. </font><font style="vertical-align: inherit;">I showed him to the talented leader of The Coalition's VFX department, James Sharp. </font><font style="vertical-align: inherit;">He immediately noticed that the edges of the volume looked too sharp. </font><font style="vertical-align: inherit;">And this is absolutely true - objects like clouds are constantly scattered in the space surrounding them, so their edges mix with the empty space around the volume, which should lead to the creation of very smooth edges. </font><font style="vertical-align: inherit;">James offered me a great idea - to reduce the density depending on how close we are to the edge. </font><font style="vertical-align: inherit;">And since we are working with distance functions with a sign, it is very easy to implement! </font><font style="vertical-align: inherit;">So let's add a function that can be used to request density at any point in the volume:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">return</span> sdfMultiplier;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And then we simply collapse it into the absorption value:</font></font><br>
<br>
<pre><code class="cpp hljs">opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position), marchSize);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And here is what it looks like:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/7b3/ab5/7887b3ab53afcfc69c33e12bd473de9d.gif" alt="ShaderToy screenshot"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Density function</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now that we have the density function, you can easily add a little noise to the volume to give it extra details and splendor. </font><font style="vertical-align: inherit;">In this case, I just reuse the fBM function that we used to adjust the volume shape.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
   <span class="hljs-keyword">return</span> sdfMultiplier * <span class="hljs-built_in">abs</span>(fbm_4(position / <span class="hljs-number">6.0</span>) + <span class="hljs-number">0.5</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And so we got the following:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b9/c0a/1e6/1b9c0a1e68d020206e9567b9044317d9.jpg" alt="ShaderToy screenshot"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opaque self-shadowing</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The volume already looks pretty pretty! </font><font style="vertical-align: inherit;">But a little light still leaks through it. </font><font style="vertical-align: inherit;">Here we see how the green color seeps where the volume should definitely absorb it:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/e16/dbf/051e16dbfa5d9f307c635a6293dcc69f.jpg" alt="ShaderToy screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This happens because opaque objects are rendered before the volume is rendered, so they do not take into account the shading caused by the volume. </font><font style="vertical-align: inherit;">This is quite simple to fix - we have a GetLightVisiblity function that can be used to calculate the shading, so we just need to call it to illuminate an opaque object. </font><font style="vertical-align: inherit;">We get the following:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cda/1c4/99d/cda1c499d05729265b374378e3da9481.gif" alt="ShaderToy screenshot"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to creating beautiful multi-colored shadows, this helps to improve the shadows and build volume into the scene. </font><font style="vertical-align: inherit;">In addition, thanks to the smooth edges of the volume, we get soft shadows, despite the fact that, strictly speaking, we work with point sources of illumination. </font><font style="vertical-align: inherit;">That's all! </font><font style="vertical-align: inherit;">Much more can be done here, but it seems to me that I have achieved the visual quality I need, while preserving the relative simplicity of the example.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimizations</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the end, I will briefly list some possible optimizations:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before performing raymarching in the direction of the light source, it is necessary to check by the value of the extinction of the light whether a significant amount of this light really reaches the point in question. </font><font style="vertical-align: inherit;">In my implementation, I look at the brightness of the light, multiplied by the albedo of the material, and make sure that the value is large enough for raymarching to be performed.</font></font></li>
<li>      ,     ,     raymarching   </li>
<li>        raymarching .      ,        .           ,       raymarching ,     .</li>
</ol><br>
<h1></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's all! </font><font style="vertical-align: inherit;">Personally, I was surprised that you can create something quite physically correct in such a small amount of code (about 500 lines). </font><font style="vertical-align: inherit;">Thank you for reading, I hope it was interesting. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And one more note: here's a fun change - I added light emission based on the SDF distance to create an explosion effect. </font><font style="vertical-align: inherit;">After all, explosions are never many.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/2f1/ab0/c642f1ab0fbc3df3b35cfafa97f9c694.gif" alt="ShaderToy screenshot"></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en500896/index.html">What to see in quarantine? A selection of materials from Technostream (part 3)</a></li>
<li><a href="../en500898/index.html">Crazy SpaceX Moon Plan? Program Evaluation by U / S_Hirangy (reddit)</a></li>
<li><a href="../en500902/index.html">The digest of interesting materials for the mobile developer # 343 (April 27 - May 3)</a></li>
<li><a href="../en500904/index.html">Who is who in the payment ecosystem 2020. Part 1</a></li>
<li><a href="../en500910/index.html">China long-range space communications system</a></li>
<li><a href="../en500918/index.html">What we pay attention to when calculating the statistical significance of the A / B test</a></li>
<li><a href="../en500920/index.html">Antiquities: ZX Spectrum and the ancient igrozhur</a></li>
<li><a href="../en500922/index.html">A wolf in sheep's clothing: how to catch a hacker who carefully disguises himself as an ordinary user</a></li>
<li><a href="../en500924/index.html">Online meeting JUG.ru "Spring-builder" with Evgeny Borisov</a></li>
<li><a href="../en500926/index.html">Dynamic typing is not a development tool. This is nonsense (lousy)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>