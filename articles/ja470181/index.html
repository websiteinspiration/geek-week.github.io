<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚇 👩🏼‍🎨 💰 Levenberg-Marquardtメソッドのしくみ 🤗 👂🏿 🕸️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Levenberg-Marquardtアルゴリズムは単純です。Levenberg-Marquardtアルゴリズムは効率的です。
 
 そして、彼らは彼について、彼が勾配降下法とニュートン法の真ん中のどこかにいると言っています。まあ、それは一種のニュートンの方法と勾配降下法との関係で分類されています。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Levenberg-Marquardtメソッドのしくみ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470181/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Levenberg-Marquardtアルゴリズムは単純です。</font><font style="vertical-align: inherit;">Levenberg-Marquardtアルゴリズムは効率的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、彼らは彼について、彼が勾配降下法とニュートン法の真ん中のどこかにいると言っています。</font><font style="vertical-align: inherit;">まあ、それは一種のニュートンの方法と勾配降下法との関係で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分類され</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">てい</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">しかし、彼らがこの深いフレーズを発するとき、彼らはどういう意味ですか？</font><font style="vertical-align: inherit;">ちょっとこっそりしてみましょう。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼の記事では、レーベンバーグ同志[K.ラストスクエアの特定の問題を解決するための方法。クォート。アプリケーション数学。 1944年。 2. P. 164-168。]、そして彼の後に市民マーカード[Marquardt、Donald（1963）。 「非線形パラメータの最小二乗推定のためのアルゴリズム。」応用数学に関するSIAMジャーナル。 ：11（2）431-441]は次のようになり最小二乗問題、考え</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e47/8ff/bd3/e478ffbd37ce67d12a8efa37326ce496.gif" title="&quot;\ sum_ {i = 1} ^ {N} \ left（f（x_ {i}、\ theta）-d_ {i} \ right）^ {2} \ rightarrow \ min&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
容易ベクトル形式で書くことができます</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/43a/e3d/87f/43ae3d87f8c0662510f39e6a7e1453a0.gif" title="&quot;\ parallel f（\ theta）-d \ parallel_ {2} ^ {2} \ rightarrow \ min&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、最小二乗法で完全にスコアリングすることで、さらに簡単になります。これはストーリーには影響しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、問題が考慮され</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/573/d8c/243/573d8c243893d6b70f894859eebc6e22.gif" title="&quot;\ dfrac {1} {2} \ parallel f（x）\ parallel_ {2} ^ {2} = \ dfrac {1} {2} f ^ {T}（x）f（x）\ rightarrow \ min&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような問題は頻繁に発生するため、それを解決するための効果的な方法を見つけることの重要性を過大評価することはできません。しかし、私たちは別のものから始めます。前回の記事では、次の考慮事項から、よく知られている勾配降下法だけでなく、勾配降下法も利用できることを示しました。</font></font><img src="https://habrastorage.org/getpro/habr/post_images/779/0dd/0ef/7790dd0efb4a03a4c876741804d9b559.gif" title="バツ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小化された関数が重要になる</font><font style="vertical-align: inherit;">ある時点に到達したとし</font></font><img src="https://habrastorage.org/getpro/habr/post_images/903/406/15f/90340615fd75f4a3550a82c374838b6b.gif" title="「f（x）」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。この時点で、補助関数</font></font><img src="https://habrastorage.org/getpro/habr/post_images/8bf/1d5/4e1/8bf1d54e1f36dd4c9dfd5720437af51c.gif" title="「g（p）= f（x + p）」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とそのいくつかのモデル</font><font style="vertical-align: inherit;">を定義します</font></font><img src="https://habrastorage.org/getpro/habr/post_images/c5b/160/400/c5b1604002da7b2c951dd57929933d24.gif" title="「\ bar {g}（p）\約g（p）」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このモデルのために、我々は補助問題置く</font><font style="vertical-align: inherit;">-問題は、単純な解決策であるように、可能な値の事前に割り当てられたセットが選択されているが、これにより機能が</font><font style="vertical-align: inherit;">かなり正確に近似した</font><font style="vertical-align: inherit;">上で</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5ab/24f/2cd/5ab24f2cdd939fb1186c5ebc91807432.gif" title="「\\\ bar {g}（p）\ rightarrow \ min \\ p \ in \ Omega」"><br>
<br><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/7e0/838/1ee/7e08381eec55a31db8263ce4d9b04120.gif" title="「\オメガ」"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/462/957/dda/462957dda265f4fb8be04327f1c12b0f.gif" title="「\バー{g}」"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/da7/7c5/b48/da77c5b4891cf3d059f1b04a28b230ef.gif" title="g"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/7e0/838/1ee/7e08381eec55a31db8263ce4d9b04120.gif" title="「\オメガ」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このようなスキームは信頼領域法と呼ばれ、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/7e0/838/1ee/7e08381eec55a31db8263ce4d9b04120.gif" title="「\オメガ」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデル関数の値が最小化さ</font><font style="vertical-align: inherit;">れるセットは</font><font style="vertical-align: inherit;">、この関数の信頼領域</font><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。勾配降下</font></font><img src="https://habrastorage.org/getpro/habr/post_images/c7e/85c/48e/c7e85c48eb16123c23a9e08714f50a0e.gif" title="&quot;\ Omega = \ left \ {p \ quad | \ parallel p \ parallel_ {2} = \ Delta \ right \}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">法では、ニュートン法</font><font style="vertical-align: inherit;">で、テイラー級数の展開の線形部分の</font></font><img src="https://habrastorage.org/getpro/habr/post_images/7cf/b4b/920/7cfb4b9203c4faccd18c1837b9c0e59f.gif" title="&quot;\Omega=\left\{ p\quad|\parallel p\parallel_{H(x)}=\Delta\right\}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルとしてを採用しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
を使ってモデルを複雑にするとどうなるか見てみましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
このモデル関数を楕円信頼領域で最小化します</font><font style="vertical-align: inherit;">（計算の便宜のために係数が追加されます）。ラグランジュ乗数法を適用すると、我々は問題得る</font><font style="vertical-align: inherit;">その</font><font style="vertical-align: inherit;">
解決策を満たす平等</font><font style="vertical-align: inherit;">
や</font><font style="vertical-align: inherit;">
、線形モデルを使用するときに我々が以前に見たものとは対照的に、方向。ここに</font><i><font style="vertical-align: inherit;">pは</font></i></font><img src="https://habrastorage.org/getpro/habr/post_images/da7/7c5/b48/da77c5b4891cf3d059f1b04a28b230ef.gif" title="&quot;g&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/a98/a08/49f/a98a0849fa75ac2a6bbcbbc2bbda3054.gif" title="&quot;\bar{g}=f(x)+\bigtriangledown f^{T}(x)p&quot;"><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b2a/d63/f01/b2ad63f0162c3cad2512d187035cbf2d.gif" title="&quot;\bar{g}(p)=f(x)+\bigtriangledown f^{T}(x)p+\dfrac{1}{2}p^{T}H(x)p&quot;"><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/e99/c58/ecc/e99c58ecc60ed62c044f7690e444d1d2.gif" title="&quot;\dfrac{1}{2}\parallel p\parallel_{B}^{2}=\Delta&quot;"><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/44c/4c6/050/44c4c6050ba6f69f94a8c222d68c95f3.gif" title="&quot;\bigtriangledown f^{T}(x)p+\dfrac{1}{2}p^{T}H(x)p+\dfrac{\lambda}{2}p^{T}Bp-\lambda\Delta\rightarrow\min&quot;"><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4a3/851/c83/4a3851c834bc50c9b670673f6665f792.gif" title="&quot;H(x)p+\lambda Bp+\bigtriangledown f(x)=0&quot;"><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2c4/7f5/3d4/2c47f53d4e43da14ea21b9fe9d7bb533.gif" title="&quot;\left(H(x)+\lambda B\right)p=-\bigtriangledown f(x)&quot;"><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メトリックだけでなく</font></font></i> <font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">、信頼領域のサイズの</font></i></font><img src="https://habrastorage.org/getpro/habr/post_images/dab/ea9/01c/dabea901c4b1a4079aa96d47bcee4e75.gif" title="&quot;B&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">選択にも</font><font style="vertical-align: inherit;">依存</font><font style="vertical-align: inherit;">することがわかります。つまり、線形検索手法は（少なくとも合理的に）適用できません。また、値に</font><font style="vertical-align: inherit;">対応する</font><font style="vertical-align: inherit;">値を明示的に決定することは難しいことがわかり</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。ただし、</font><font style="vertical-align: inherit;">長さ</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">長く</font><font style="vertical-align: inherit;">なると減少する</font><font style="vertical-align: inherit;">ことは明らかです</font><font style="vertical-align: inherit;">。それでも同時に条件を課す</font><font style="vertical-align: inherit;">場合、ステップ長はニュートンの方法で得られるものより長くなることはありません（非常に合理的で、変更や条件なし）。</font><font style="vertical-align: inherit;">
したがって、代わりに</font><font style="vertical-align: inherit;">探して</font><font style="vertical-align: inherit;">与えられたために</font><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">与えられたため</font><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">、我々はできる</font><font style="vertical-align: inherit;">正反対の操作を行います。1つの検索する</font><font style="vertical-align: inherit;">条件の下での</font></font><i><font style="vertical-align: inherit;"></font></i> <img src="https://habrastorage.org/getpro/habr/post_images/a2b/068/6ad/a2b0686adbc103ad9f96be85cca5d418.gif" title="&quot;\Delta&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/99d/394/e7d/99d394e7d0b74248114405067e0ffd51.gif" title="&quot;\lambda&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/a2b/068/6ad/a2b0686adbc103ad9f96be85cca5d418.gif" title="&quot;\Delta&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/99d/394/e7d/99d394e7d0b74248114405067e0ffd51.gif" title="&quot;\lambda&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="&quot;p&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/d64/14f/5fb/d6414f5fbe0850f1d6cd0710c69a89fe.gif" title="&quot;\lambda\geq0&quot;"><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/a2b/068/6ad/a2b0686adbc103ad9f96be85cca5d418.gif" title="&quot;\Delta&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/99d/394/e7d/99d394e7d0b74248114405067e0ffd51.gif" title="&quot;\lambda&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/d64/14f/5fb/d6414f5fbe0850f1d6cd0710c69a89fe.gif" title="&quot;\lambda\geq0&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/553/80b/dc5/55380bdc5a434366df6d181078d6a8b7.gif" title="&quot;g(p) &amp;lt; g(0)&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、この場合の遅延検索の一種の置き換えです。</font><font style="vertical-align: inherit;">Marquardtは、次の簡単な手順を提案しました。</font></font><br>
<br>
<ol>
<li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ある値について</font></font><img src="https://habrastorage.org/getpro/habr/post_images/99d/394/e7d/99d394e7d0b74248114405067e0ffd51.gif" title="&quot;\lambda&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件が</font></font><img src="https://habrastorage.org/getpro/habr/post_images/eca/77f/2af/eca77f2af789bf09851ed403e71813c5.gif" title="&quot;g(p(\lambda)) &amp;lt; g(0)&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">満たされて</font><font style="vertical-align: inherit;">いる</font><font style="vertical-align: inherit;">場合は</font><font style="vertical-align: inherit;">、それ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/cc3/5f3/35e/cc35f335e8bf25ccc19e392f3311591a.gif" title="&amp;quot;\lambda'\leftarrow\alpha\lambda,\lambda\leftarrow\lambda'&amp;quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まで</font><font style="vertical-align: inherit;">繰り返します</font></font><img src="https://habrastorage.org/getpro/habr/post_images/3aa/df9/299/3aadf929956784b2e081f8a634cff90f.gif" title="&amp;quot;g(p(\lambda') &amp;lt; g(p(\lambda))&amp;quot;"></i></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もしそうなら</font></font><img src="https://habrastorage.org/getpro/habr/post_images/22b/75c/294/22b75c29456939ef738c81e53f52db6b.gif" title="&quot;g(p(\lambda))\geq g(0)&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、受け入れ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/434/e0a/742/434e0a742c4ad3ae7e4cea8c1289d363.gif" title="&quot;\lambda\leftarrow\beta\lambda&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て繰り返します。</font></font></i></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/4f2/68e/81e/4f268e81e07eb6a87b5798903d82f2c0.gif" title="&quot;0 &amp;lt; \alpha &amp;lt; 1&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><img src="https://habrastorage.org/getpro/habr/post_images/0ea/d14/4f2/0ead144f2f1591e5747e51404639631f.gif" title="&quot;\beta &amp;gt; 1&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドのパラメータの定数です。乗算</font></font><img src="https://habrastorage.org/getpro/habr/post_images/389/a99/83e/389a9983ea24ad0b3af0559c2aca381b.gif" title="&quot;\alpha&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、信頼領域の拡張、および</font></font><img src="https://habrastorage.org/getpro/habr/post_images/76d/0eb/69b/76d0eb69ba026a58bbe3edd275fee712.gif" title="&quot;\beta&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その狭め</font><font style="vertical-align: inherit;">による</font><font style="vertical-align: inherit;">乗算に</font><font style="vertical-align: inherit;">対応し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指定された手法は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目的関数に</font><font style="vertical-align: inherit;">適用できます</font><font style="vertical-align: inherit;">。ニュートン法が逐次降下法の特別な場合として提示されたとき、以前に考慮された場合とは対照的に、ここではヘッセ行列の正定性はもはや必要ではないことに注意してください。その非縮退さえも必要とされず、場合によっては非常に重要です。ただし、この場合、変更ごと</font></font><img src="https://habrastorage.org/getpro/habr/post_images/99d/394/e7d/99d394e7d0b74248114405067e0ffd51.gif" title="&quot;\lambda&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に決定のための線形システムを解く必要があるため</font><font style="vertical-align: inherit;">、方向を見つけるコストは増加し</font></font><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="&quot;p&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチを最小二乗問題に適用するとどうなるか見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラデーション機能</font></font><img src="https://habrastorage.org/getpro/habr/post_images/f58/e0b/7a5/f58e0b7a5457a6f69dd3c16e2d5aadc5.gif" title="&quot;\bigtriangledown\left(\dfrac{1}{2}f^{T}f\right)=J^{T}f&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そのヘッセ</font><font style="vertical-align: inherit;">。検索の方向を決定する次のシステムに置き換えて取得します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
それはかなり受け入れられますが、ベクトル関数の二次導関数を計算することはかなり高価になる可能性があります。この問題を回避するために、Marquardtは、関数自体を使用するのではなく</font><font style="vertical-align: inherit;">、行列</font><font style="vertical-align: inherit;">が消える</font><font style="vertical-align: inherit;">線形近似</font><font style="vertical-align: inherit;">を使用することを提案しました</font><font style="vertical-align: inherit;">。あなたは今のように場合は</font><font style="vertical-align: inherit;">単位行列を取るために</font><font style="vertical-align: inherit;">、我々は最小二乗問題を解決するためのLevenberg-Marquardtアルゴリズムの標準形式を取得します：</font><font style="vertical-align: inherit;">。</font></font><img src="https://habrastorage.org/getpro/habr/post_images/9da/93e/f0a/9da93ef0ae8eda326c977d890c97beac.gif" title="&quot;H=J^{T}J+G&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/c7a/314/465/c7a31446512540e721403b61686e91ba.gif" title="&quot;J_{ij}=\dfrac{\partial f_{i}}{\partial x_{j}}, G_{ij}=\sum_{k=1}^{M}\dfrac{\partial^{2}f_{i}}{\partial x_{j}\partial x_{k}}f_{k}&quot;"><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/148/b56/06f/148b5606f695c8a52b629f69f8c167c5.gif" title="&quot;\left(J^{T}J+G+\lambda B\right)p=-J^{T}f&quot;"><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/188/ee6/44e/188ee644e8202aad30eac11166858841.gif" title="&quot;f&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/205/c97/755/205c97755529c6a19a04851f7ec3d7f7.gif" title="&quot;\bar{f}(x)=f(x_{0})+J(x_{0})(x-x_{0})&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/338/ec0/451/338ec0451e1b4b7e7decd0b4443a8828.gif" title="&quot;G&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/dab/ea9/01c/dabea901c4b1a4079aa96d47bcee4e75.gif" title="&quot;B&quot;"><font style="vertical-align: inherit;"></font><img src="https://habrastorage.org/getpro/habr/post_images/809/326/43e/80932643e100c59ad091cdf4d90a2bd5.gif" title="&quot;I&quot;"><font style="vertical-align: inherit;"></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d3e/6e4/48a/d3e6e448ae5465d70cded093a02fdb69.gif" title="&quot;\left(J^{T}J+\lambda I\right)p=-J^{T}f&quot;"><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
降下の方向を決定するこの方法の場合、マルカートは、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/99d/394/e7d/99d394e7d0b74248114405067e0ffd51.gif" title="&quot;\lambda&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無限</font><font style="vertical-align: inherit;">に</font></font><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="&quot;p&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向かう傾向がある</font><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">、方向</font><font style="vertical-align: inherit;">が逆勾配になる傾向がある</font><font style="vertical-align: inherit;">という定理を証明しました</font><font style="vertical-align: inherit;">。興味のある読者はベース記事で厳密な証拠を見つけることができますが、このステートメント自体がメソッドのロジックから非常に明白になったことを願っています。ある程度、ラムダの増加（これは何らかの理由で私はしばしば正則化パラメーターと呼ばれます）によって勾配降下が得られるという事実への遍在参照を正当化します。実際、そのようなものは何もありません。ステップ長がゼロになりがちなものだけで、限界でしか得られません。さらに重要なことは、ラムダ値が十分に大きい場合、得られる</font><i><font style="vertical-align: inherit;">方向は降下</font></i><font style="vertical-align: inherit;">の</font><i><font style="vertical-align: inherit;">方向に</font></i><font style="vertical-align: inherit;">なります</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、メソッドのグローバル収束</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を取得することを意味し</font><font style="vertical-align: inherit;">ます。そして、これがラムダがゼロになる傾向があるときにニュートン法が得られるということは明らかに真実ですが、代わりに</font></font><img src="https://habrastorage.org/getpro/habr/post_images/188/ee6/44e/188ee644e8202aad30eac11166858841.gif" title="&quot;f&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その線形近似</font><font style="vertical-align: inherit;">を取る場合にのみ、ステートメントの2番目の部分です</font></font><img src="https://habrastorage.org/getpro/habr/post_images/9dc/1fa/a9c/9dc1faa9cf4e8d569afaf161ac627568.gif" title="&quot;\bar{f}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはすべてのようです。楕円計量のベクトル関数のノルムを最小化します-レーベンバーグマルカートを使用します。私たちは一般的な形の関数を扱っており、二次導関数の行列を計算する能力を持っています-ウェルズの場合、領域の一般的な信頼度法を使用します。しかし、変態者がいます... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数を最小化するためのLevenberg-Marquardtアルゴリズム</font></font><img src="https://habrastorage.org/getpro/habr/post_images/188/ee6/44e/188ee644e8202aad30eac11166858841.gif" title="&quot;f&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、次のような式になる</font><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">があります</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/438/a2f/22b/438a2f22ba381c85087a26d2125d1dac.gif" title="&quot;\left(H^{T}H+\lambda I\right)p=-H^{T}\bigtriangledown f&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはすべて同じように見えますが、これ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/bc8/190/17b/bc819017bab0b9f9d995f262f3f76a42.gif" title="&quot;H&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は2番目のマトリックスです！微分関数</font></font><img src="https://habrastorage.org/getpro/habr/post_images/188/ee6/44e/188ee644e8202aad30eac11166858841.gif" title="&quot;f&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。正式には、これには存在する権利がありますが、それは倒錯です。そしてそれが理由です。同じMarquardtは彼の記事で、説明されている方法で</font></font><img src="https://habrastorage.org/getpro/habr/post_images/0a0/ec7/804/0a0ec780406efe57ca6444290ccfde09.gif" title="&quot;F(x)=0&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を最小化することによって</font><font style="vertical-align: inherit;">方程式系を解く方法を提案しました</font></font><img src="https://habrastorage.org/getpro/habr/post_images/128/aa6/0b3/128aa60b3bc0593a797bd9ebd308b402.gif" title="&quot;\parallel F(x)\parallel_{2}^{2}&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><img src="https://habrastorage.org/getpro/habr/post_images/59b/464/0f5/59b4640f5bad6b14066d718cf44e9f9c.gif" title="&quot;F(x)&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果として目的関数の勾配</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">採用すると、実際には減少した式が得られます。そして、</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小化問題によって生成された非線形方程式のシステムによって生成された最小化問題が解決される</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、これは倒錯</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ダブルストライク。そのような式は、少なくとも、球面信頼領域の最初の方程式よりは良くありませんが、一般に、生産性の観点（不必要な乗算演算、および通常の実装-因数分解）と、メソッドの安定性の観点（マトリックス乗算自体が悪化する）の両方の点ではるかに劣ります。そのコンディショニング）。ここでは</font></font><img src="https://habrastorage.org/getpro/habr/post_images/e98/c6b/bd7/e98c6bbd7a088cd46c2ed68aac4943ba.gif" title="&quot;H^{T}H&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、明確に定義されて</font><font style="vertical-align: inherit;">いることが</font><font style="vertical-align: inherit;">保証され</font><font style="vertical-align: inherit;">ていることに反対することがあり</font><font style="vertical-align: inherit;">ますが、この場合は問題ではありません。 Levenberg-Marquardt法を逐次降下法の観点から見てみましょう。この場合、マトリックスをメトリックとして使用したいことがわかります。</font></font><img src="https://habrastorage.org/getpro/habr/post_images/64b/dbe/dcb/64bdbedcbd61e0741f92025fb7c4a1f8.gif" title="&quot;H(x)+\lambda B&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この能力で機能できるように、値</font></font><img src="https://habrastorage.org/getpro/habr/post_images/99d/394/e7d/99d394e7d0b74248114405067e0ffd51.gif" title="&quot;\lambda&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はその正定性を保証する必要があります。それが</font></font><img src="https://habrastorage.org/getpro/habr/post_images/dab/ea9/01c/dabea901c4b1a4079aa96d47bcee4e75.gif" title="&quot;B&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明確に定義されているとすると、望ましい値</font></font><img src="https://habrastorage.org/getpro/habr/post_images/99d/394/e7d/99d394e7d0b74248114405067e0ffd51.gif" title="&quot;\lambda&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常に見つけることができます-つまり、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/bc8/190/17b/bc819017bab0b9f9d995f262f3f76a42.gif" title="&quot;H&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">確実な確実性</font><font style="vertical-align: inherit;">から要求する必要はありませ</font><font style="vertical-align: inherit;">ん。</font><font style="vertical-align: inherit;">単一のもの</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
を行列として</font></font><img src="https://habrastorage.org/getpro/habr/post_images/dab/ea9/01c/dabea901c4b1a4079aa96d47bcee4e75.gif" title="&quot;B&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取る必要</font><font style="vertical-align: inherit;">はあり</font><font style="vertical-align: inherit;">ませんが、目的関数の2次モデルの場合、適切な信頼領域を指定することは、線形モデルの場合ほど簡単ではありません。ヘッセ行列によって誘導された楕円領域をとると、メソッドは（まあ、ほぼ）ニュートン法に退化し</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f31/f2c/82f/f31f2c82f904fd2c95ab33daa112168b.gif" title="&quot;\左（J ^ {T} J + \ラムダJ ^ {T} J \右）p = \左（1+ \ラムダ\右）J ^ {T} Jp = -J ^ {T} f \約\左（1+ \ラムダ\右）Hp =-\ bigtriangledown \左（\ dfrac {1} {2} f ^ {T} f \右） &quot;"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。もちろん、ヘッセ行列が正定である場合。そうでない場合は、以前と同様に、修正されたヘッセ行列をメトリック、または何らかの意味でそれに近い行列として使用できます。メトリックとしてマトリックスを使用することも推奨されています</font></font><img src="https://habrastorage.org/getpro/habr/post_images/e83/ae4/134/e83ae41347e08ce41ff17ee556a7e06b.gif" title="「diag（J ^ {T} J）」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、これは構造上、正定であることが保証されています。残念ながら、私はこの選択の厳密な根拠を少なくとも知りませんが、経験的な推奨としてかなり頻繁に言及されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、メソッドが同じRosenbrock関数でどのように動作するかを見てみましょう。フォーム</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b78/272/e1a/b78272e1a4bce3b65e55a7737fd2a1ee.gif" title="&quot;f（x、y）=（1-x）^ {2} +100（yx ^ {2}）^ {2} \ rightarrow \ min&quot;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">記述された単純な関数</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
として</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">および最小二乗問題として、</font><font style="vertical-align: inherit;">これを2つの方法で検討します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/05c/c5a/49e/05cc5a49e94d86e2929c86264cd76f6f.gif" title="&quot;\\ f（x、y）= \ left \ Vert \ begin {array} {c} 1-x \\ 100（yx ^ {2}）\ end {array} \ right \ Vert _ {2} ^ { 2} \右矢印\分 &quot;"><br>
<br>
<img src="https://habrastorage.org/webt/0d/bo/bo/0dbobokk7lwzjkd69j9d-wmotks.gif" width="600"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、球状の信頼領域を持つメソッドの動作です。</font></font><br>
<img src="https://habrastorage.org/webt/l9/57/xb/l957xbscmthhqno0yneburansf4.gif" width="600"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、Davidon-Fletcher-Powell規則に従って構築された行列によって信頼領域の形状が指定されている場合、同じ方法が動作します。</font><font style="vertical-align: inherit;">収束には影響がありますが、目的関数の線形モデルを使用すると、同様の場合よりもはるかに穏やかになります。</font></font><br>
<img src="https://habrastorage.org/webt/rn/n2/uz/rnn2uzvfkpd7fdrxa26qvdlkcfs.gif" width="600"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これは最小二乗問題に適用される方法の振る舞いです。</font><font style="vertical-align: inherit;">5回の反復で収束します。</font><font style="vertical-align: inherit;">ただ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、この結論から、この種の関数の2番目の公式が最初の公式よりも常に優れているという結論を出さないで</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これはそうではなく、この特定のケースで発生しただけです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Levenberg-Marquardt法は、私の知る限り、信頼できる領域という考えに基づく最初の方法です。最小二乗問題を解くとき、彼は実際に自分自身を非常によく見せました。ほとんどの場合（私が見た場合）、この方法は収束します（以前の記事で、それが良いか悪いかについて述べました）。ただし、一般的な機能を最小限に抑えながら、球体を信頼できる領域として選択することは、最善の選択肢とは言えません。さらに、（ここで説明した基本的な定式化における）メソッドの重大な欠点は、信頼領域のサイズが暗黙的に設定されることです。欠点は、値を知っていれ</font></font><img src="https://habrastorage.org/getpro/habr/post_images/99d/394/e7d/99d394e7d0b74248114405067e0ffd51.gif" title="「\ラムダ」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ば、もちろん、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/a2b/068/6ad/a2b0686adbc103ad9f96be85cca5d418.gif" title="「\ Delta」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステップ長を計算するだけで</font><font style="vertical-align: inherit;">現在のポイントをカウントできること</font><font style="vertical-align: inherit;">です。</font></font><img src="https://habrastorage.org/getpro/habr/post_images/4b2/8c1/3d5/4b28c13d5f5d658adb7478fbc9efc923.gif" title="「p」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、新しいポイントに移動すると、</font></font><img src="https://habrastorage.org/getpro/habr/post_images/99d/394/e7d/99d394e7d0b74248114405067e0ffd51.gif" title="「\ラムダ」"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全に異なる信頼領域の値はすでに</font><font style="vertical-align: inherit;">同じ値に</font><font style="vertical-align: inherit;">対応</font><font style="vertical-align: inherit;">しています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、信頼領域の「タスクの特性」値を決定する能力が失われ、新しいポイントごとに新しい方法でそのサイズを決定せざるを得なくなります。</font><font style="vertical-align: inherit;">これは、収束に十分な数の反復が必要であり、関数の値の計算にコストがかかる場合に重要になります。</font><font style="vertical-align: inherit;">信頼する地域という考えに基づいて、より高度な方法で同様の問題が解決されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これはまったく別の話です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
貴重なコメントのおかげで </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dark_Daiver</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以上を補足するため、次の点に留意した。もちろん、別の純粋に経験的な方法でレーベンバーグ・マルカート法に到達することができます。つまり、前の記事で説明した逐次降下法のスキームに戻り、目的関数の線形モデルに適切なメトリックを構築することについて、もう一度考えてみましょう。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーチスペースの現在の点でのヘッセ行列が正定ではなく、メトリックとして機能できないとします（さらに、これがそうであるかどうかを確認するために、能力も欲望もありません）。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/f06/ee0/4fd/f06ee04fdb8676c6297784f2cc24291b.gif" title="\ラムダ_ {\分}"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小の固有値で</font><font style="vertical-align: inherit;">表し</font><font style="vertical-align: inherit;">ます。次に、すべての固有値を値だけシフトすることで、ヘッセ行列を修正できます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/0b6/187/138/0b61871385159f5f8dff9d81de5171b5.gif" title="\ lambda>-\ lambda _ {\ min}"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これを行うには、行列をヘッセ行列に追加します</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/09f/c07/1d5/09fc071d5e509fe24bd70ca553a899cf.gif" title="\ラムダI"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。次に、降下の方向を決定する方程式は次の形式</font><font style="vertical-align: inherit;">
になります。に適切な下限がある場合</font><font style="vertical-align: inherit;">、逐次降下法で行われたすべてのことを実行できます。ただし、そのような推定値がない場合は、</font><font style="vertical-align: inherit;">長さ</font><i><font style="vertical-align: inherit;">p</font></i><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">増加</font><font style="vertical-align: inherit;">すると減少する</font><font style="vertical-align: inherit;">ことを考慮に入れると、</font><font style="vertical-align: inherit;">正定</font><font style="vertical-align: inherit;">である</font><font style="vertical-align: inherit;">ほど十分に大きく、であると自信を持って言え</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/3a7/b20/19b/3a7b2019b8c7a99b85121b3512c3fa19.gif" title="\\（H（x）+ \ lambda I）p =-\ bigtriangledown f（x）\\ \ lambda>-\ lambda _ {\ min}"></a><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/f06/ee0/4fd/f06ee04fdb8676c6297784f2cc24291b.gif" title="\ラムダ_ {\分}"></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/99d/394/e7d/99d394e7d0b74248114405067e0ffd51.gif" title="\ラムダ"></a><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/99d/394/e7d/99d394e7d0b74248114405067e0ffd51.gif" title="\ラムダ"></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/cc1/d36/8a7/cc1d368a7e0d0614441998db48983d70.gif" title="H（x）+ \ラムダI"></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/553/80b/dc5/55380bdc5a434366df6d181078d6a8b7.gif" title="g（p）<g（0）"></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこのような方法の結論があまりにも成功していないと私が考えるのか。まず、このように構築されたメトリックが実際の使用に適しているかどうかは、まったく明らかではありません。もちろん、これは2次導関数に関する情報を使用しますが、固有値を特定の値だけシフトしても使用できなくなるわけではありません。同僚がコメントで述べたように、ヘッセ行列にスケーリングされた単位行列を追加すると、楕円信頼領域が球形になる傾向があり、ここでも（思われるように）峡谷での詰まりの問題とその他の勾配降下と近接の楽しみが生じることが明らかになったようです彼にメソッド。しかし、実際にはこれは起こりません。いずれにせよ、私はそのような振る舞いを説明する例を見ることはできませんでした。この場合、問題が発生します。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、実際には、なぜ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、この方法を降下法の特別なケースとしてではなく、目的関数の2次モデルを使用した信頼領域法として見る場合、そのような問題は発生しません。答えが明らかであるためです。ラムダが増加すると、球体-モデルの信頼領域のみを圧縮します。曲率に関する情報はどこにも行きませんし、何によっても洗い流されません-二次モデルが目的関数を適切に記述する領域のサイズを選択するだけです。このことから、目的関数についてのすべての情報がモデルですでに考慮されているため、メトリック、つまり信頼領域の形状の変化による大きな影響を期待することはほとんど価値がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして第二に、方法を検討するとき、マルカートをこの方法に導いた主要なアイデア、つまり信頼する地域のアイデアを理解することが重要です。</font><font style="vertical-align: inherit;">実際、最終的な分析では、数値的方法の内外を理解することだけが、なぜそれが機能するのか、さらに重要なことにはなぜ機能しないのかを理解することができます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja470169/index.html">アイデアが死に、彼女を殺さないチームを作るのを防ぐ方法</a></li>
<li><a href="../ja470171/index.html">Habr Weekly＃21 / Dobroshrift、猫の技術、家電製品を修理する権利、EU、および「透明」Cookie</a></li>
<li><a href="../ja470173/index.html">サービスとしての統合プラットフォーム</a></li>
<li><a href="../ja470175/index.html">Appleでのサインインをバックエンドに追加する</a></li>
<li><a href="../ja470179/index.html">PDDM-高度なスケジューラを備えた新しいモデルベースの強化学習アルゴリズム</a></li>
<li><a href="../ja470187/index.html">オンラインサービスの設計と設計の価格帯は、10万から500万ルーブルです。原因</a></li>
<li><a href="../ja470189/index.html">PeerJSを使用したピアツーピアメッセージの送信</a></li>
<li><a href="../ja470191/index.html">ウェブ r0ot-miによる問題解決。パート1</a></li>
<li><a href="../ja470193/index.html">XSS攻撃とSQLインジェクションに対する普遍的な保護</a></li>
<li><a href="../ja470195/index.html">F＃4：させる/使う/する</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>