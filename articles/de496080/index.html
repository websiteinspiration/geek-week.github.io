<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôåüèΩ ‚ù§Ô∏è üöµ Erstellen einfacher KI-Interaktionen mit Umgebungsobjekten üêÉ üåã üç£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei der Erstellung k√ºnstlicher Intelligenz f√ºr Videospiele ist der Standort einer der wichtigsten Aspekte. Die Position des KI-Charakters kann seine V...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Erstellen einfacher KI-Interaktionen mit Umgebungsobjekten</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496080/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b5/840/cec/6b5840cec8e3b42adad879472c47930d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Erstellung k√ºnstlicher Intelligenz f√ºr Videospiele ist der Standort einer der wichtigsten Aspekte. Die Position des KI-Charakters kann seine Verhaltensweisen und zuk√ºnftigen Entscheidungen vollst√§ndig ver√§ndern. In diesem Tutorial werden wir verstehen, wie sich die Spielumgebung auf die KI auswirken kann und wie man sie richtig verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel stammt aus dem Buch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Practical Game AI Programming</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das von Michael Dagrack geschrieben und von Packt Publishing ver√∂ffentlicht wurde. In diesem Buch erfahren Sie, wie Sie eine Spiel-KI erstellen und die fortschrittlichsten KI-Algorithmen von Grund auf neu implementieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visuelle Interaktionen sind grundlegend, sie wirken sich nicht direkt auf das Gameplay aus, aber Sie k√∂nnen das Videospiel und seine Charaktere verbessern, indem Sie sie zu einem Teil der von uns erstellten Umgebung machen, was das Eintauchen des Spielers in das Spiel stark beeinflusst. </font><font style="vertical-align: inherit;">Dies zeigt uns, wie wichtig es ist, dass die Umgebung Teil des Spiels ist und nicht nur dazu beitr√§gt, den Platz auf dem Bildschirm auszuf√ºllen. </font><font style="vertical-align: inherit;">√Ñhnliche Interaktionen finden sich zunehmend in Spielen, und die Spieler erwarten, sie zu sehen. </font><font style="vertical-align: inherit;">Wenn es ein Objekt im Spiel gibt, muss es eine Funktion erf√ºllen, wenn auch nicht die wichtigste.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eines der ersten Beispiele f√ºr die Interaktion mit Umgebungen ist das erste Castlevania, das 1986 f√ºr das Nintendo Entertainment System ver√∂ffentlicht wurde. </font><font style="vertical-align: inherit;">Von Anfang an kann der Spieler mit der Peitsche Kerzen und Feuer zerst√∂ren, die urspr√ºnglich Teil des Hintergrunds waren.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90c/a93/19c/90ca9319cffa8e665c51bc56297876a5.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses und einige Spiele dieser Zeit er√∂ffneten viele T√ºren und M√∂glichkeiten in Bezug auf die moderne Wahrnehmung der Hintergr√ºnde und Umgebungen der Charaktere im Spiel. </font><font style="vertical-align: inherit;">Aufgrund der Hardwarebeschr√§nkungen dieser Konsolengeneration war es offensichtlich viel schwieriger, einfache Dinge zu erstellen, die von den aktuellen Standards allgemein akzeptiert werden. </font><font style="vertical-align: inherit;">Aber jede Generation von Konsolen brachte neue Funktionen mit und Entwickler verwendeten sie, um erstaunliche Spiele zu erstellen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser erstes Beispiel f√ºr visuelle Interaktion ist also ein Objekt im Hintergrund, das zerst√∂rt werden kann, ohne das Gameplay direkt zu beeinflussen. </font><font style="vertical-align: inherit;">Diese Art der Interaktion findet man in vielen Spielen. </font><font style="vertical-align: inherit;">Die Implementierung ist einfach. Animieren Sie das Objekt nur, wenn es angegriffen wird. </font><font style="vertical-align: inherit;">Danach k√∂nnen wir entscheiden, ob Punkte oder Objekte von dem Objekt entfernt werden sollen, die den Spieler f√ºr die Erkundung des Spiels belohnen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt k√∂nnen wir mit dem n√§chsten Beispiel fortfahren - Objekten im Spiel, die animiert sind oder sich bewegen, wenn Charaktere sie passieren. Das Prinzip ist hier dasselbe wie bei zerst√∂rbaren Objekten, aber diesmal ist die Interaktion subtiler - der Charakter muss sich zu dem Punkt bewegen, an dem sich das Objekt befindet. Dies kann auf verschiedene Elemente des Spiels angewendet werden, von der Bewegung von Gras, Staub oder Wasser bis hin zu fliegenden V√∂geln oder Menschen, die lustige Gesten machen. Die M√∂glichkeiten sind endlos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Analyse dieser Interaktionen k√∂nnen wir leicht feststellen, dass sie nicht unbedingt KI verwenden. In den meisten F√§llen handelt es sich nur um eine Boolesche Funktion, die gem√§√ü einer bestimmten Aktion aktiviert wird. Sie sind jedoch Teil der Umgebung und sollten daher bei der Implementierung einer qualitativ hochwertigen Interaktion zwischen Umgebung und KI ber√ºcksichtigt werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie einfache Interaktionen mit der Umgebung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie wir bereits gesehen haben, wurde die Umgebung einst Teil des Gameplays, und dies f√ºhrte zu vielen neuen Konzepten und Ideen f√ºr zuk√ºnftige Spiele. </font><font style="vertical-align: inherit;">Der n√§chste Schritt war die Integration dieser kleinen √Ñnderungen in das Gameplay und ihre Verwendung, um das Verhalten des Spielers im Spiel zu √§ndern. </font><font style="vertical-align: inherit;">Dies wirkte sich definitiv positiv auf die Geschichte der Videospiele aus, da alle Elemente der Szene allm√§hlich zum Leben erweckt wurden und der Spieler erkannte, wie reich die Umgebung war. </font><font style="vertical-align: inherit;">Die Verwendung von Umgebungen zum Erreichen von Zielen im Spiel ist Teil des Gameplays geworden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/0c6/39f/ad20c639fd190d338f6e2e72847338b1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ein Beispiel f√ºr eine Umgebung zu demonstrieren, die sich direkt auf das Gameplay auswirkt, nehmen wir ein hervorragendes Beispiel - das Tomb Raider-Franchise. In diesem Beispiel muss unsere Figur Lara Croft den W√ºrfel schieben, bis er auf dem markierten Bereich landet. Dies wird die Umgebung ver√§ndern und einen neuen Pfad er√∂ffnen, so dass sich der Spieler weiter im Level bewegen kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solche R√§tsel gibt es in vielen Spielen: Sie m√ºssen eine Aktion an einem bestimmten Punkt auf der Karte ausf√ºhren, damit in einem anderen Teil etwas passiert, und dies kann verwendet werden, um ein bestimmtes Ziel im Spiel zu erreichen. Normalerweise m√ºssen wir die Umgebung selbst √§ndern, um das Niveau weiter zu verbessern. Wenn Entwickler eine Karte oder Ebene planen, ber√ºcksichtigen sie dies und erstellen alle Regeln f√ºr jede Interaktion. Zum Beispiel:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(cube.transform.position == mark.transform.position)<font></font>
{<font></font>
  openDoor = <span class="hljs-literal">true</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich jetzt f√ºr einen Moment vor, dass Lara Croft einen Verb√ºndeten hat, dessen Hauptaufgabe es ist, ihr zu helfen, diese Kiste an ihre Stelle zu setzen. </font><font style="vertical-align: inherit;">Und in diesem Kapitel werden wir genau diese Art der Interaktion betrachten: Der KI-Charakter versteht, wie die Umgebung funktioniert und wie man sie verwendet.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bewegliche Umgebung in Tomb Raider</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gehen wir direkt zu diesem Szenario und versuchen, eine Situation nachzubilden, in der es einen KI-Charakter gibt, der dem Spieler helfen kann, sein Ziel zu erreichen. </font><font style="vertical-align: inherit;">In diesem Beispiel stellen wir uns vor, dass ein Spieler gefangen ist, von dem er keinen Zugriff auf ein interaktives Objekt erh√§lt, das ihn befreien kann. </font><font style="vertical-align: inherit;">Der Charakter, den wir erstellen, muss in der Lage sein, den W√ºrfel zu finden und in die richtige Richtung zu schieben.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b5/840/cec/6b5840cec8e3b42adad879472c47930d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt haben wir also alle Charaktere und Objekte. Lassen Sie uns planen, wie sich der KI-Charakter in dieser Situation verhalten soll. Zuerst sollte er sehen, dass der Spieler in der N√§he ist, damit er beginnen kann, den W√ºrfel zu suchen und an die gew√ºnschte Position zu bewegen. Angenommen, wenn sich der W√ºrfel an der Markierung befindet, erscheint ein neuer Block aus dem Sand, der es dem Spieler erm√∂glicht, weiter im Level voranzukommen. Ein KI-Charakter kann einen W√ºrfel in vier Richtungen schieben: links, rechts, vorw√§rts und r√ºckw√§rts, so dass er perfekt zur Positionsmarkierung passt.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/804/463/982/8044639827005d84bcf50014f095b46e.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der KI-Charakter muss jede in diesem Verhaltensbaum angezeigte Aktion √ºberpr√ºfen und validieren. Das erste und wichtigste f√ºr die Fortsetzung der Aufgabe ist, dass der Charakter sicher sein muss, dass sich der Spieler auf seiner Marke befindet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Spieler dort noch nicht angekommen ist, muss unser Charakter warten und an Ort und Stelle bleiben. Wenn der Spieler bereits an der Marke angekommen ist, setzt der KI-Charakter die Ausf√ºhrung fort und fragt sich, wie weit er vom W√ºrfelobjekt entfernt ist. Wenn nicht, sollte sich der Charakter in Richtung des W√ºrfels bewegen und sobald diese Aktion best√§tigt ist, sollte er dieselbe Frage stellen. Wenn die Antwort positiv wird und sich der Charakter neben dem W√ºrfel befindet, muss er herausfinden, in welche Richtung Sie den W√ºrfel zuerst schieben m√ºssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann beginnt er, den W√ºrfel entlang der Y- oder X-Achse zu schieben, bis er mit der Markierungsposition √ºbereinstimmt und die Aufgabe abgeschlossen ist.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueYplayerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir beginnen, dem Code Informationen hinzuzuf√ºgen, mit denen der Charakter √ºberpr√ºfen kann, ob sich der Spieler neben seiner markierten Position befindet. Dazu erstellen wir alle Variablen, die zur Berechnung der Abst√§nde zwischen dem Spieler und der Position, in der er sich befinden sollte, erforderlich sind. </font></font><code>playerMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bezieht sich auf das 3D-Modell des Spielers, aus dem wir seine Position extrahieren und als verwenden </font></font><code>currentPlayerPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu wissen, ob es nahe an der Marke liegt, ben√∂tigen wir eine Variable, die die Position der Marke darstellt. In unserem Beispiel haben wir eine Variable erstellt, </font></font><code>playerMark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in die wir die Position schreiben k√∂nnen, an der sich der Spieler befinden soll. Dann haben wir drei Variablen hinzugef√ºgt, die uns mitteilen, ob der Spieler in der N√§he ist. </font></font><code>proximityValueX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berechnet den Abstand zwischen dem Spieler und der X-Achsen-Markierung. </font></font><code>proximityValueY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berechnet den Abstand zwischen dem Spieler und der Y-Achsen-Markierung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als n√§chstes haben wir </font></font><code>nearValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, in dem wir bestimmen k√∂nnen, wie weit der Spieler von der Position der Marke entfernt sein kann, wenn der KI-Charakter beginnen kann, an der Erreichung des Ziels zu arbeiten. Sobald sich der Spieler der Marke n√§hert, </font></font><code>playerOnMark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√§ndert die </font><font style="vertical-align: inherit;">Boolesche Variable </font><font style="vertical-align: inherit;">den Wert in </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Abstand zwischen dem Spieler und der Marke zu berechnen, haben wir Folgendes verwendet: den Abstand zwischen dem Spieler und seiner Marke, √§hnlich </font></font><code>(mark.position - player.position)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um festzustellen, ob sich das AI-Zeichen in der N√§he des W√ºrfels befindet, berechnen wir dieselbe Gleichung, indem wir den Abstand zwischen der AI und dem W√ºrfel berechnen. Zus√§tzlich haben wir den Code mit Positionen auf beiden Markierungen (Spieler und W√ºrfel) erg√§nzt:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
   Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
   Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
   nearValue = <span class="hljs-number">0.5f</span>;<font></font>
   nearCube = <span class="hljs-number">0.5f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt, da unser KI-Charakter wei√ü, ob er sich neben dem W√ºrfel befindet, k√∂nnen wir die Frage beantworten und feststellen, ob er zum n√§chsten von uns geplanten Zweig √ºbergehen kann. </font><font style="vertical-align: inherit;">Aber was passiert, wenn sich der Charakter nicht neben dem W√ºrfel befindet? </font><font style="vertical-align: inherit;">Er muss sich dem W√ºrfel n√§hern. </font><font style="vertical-align: inherit;">Deshalb werden wir dies dem Code hinzuf√ºgen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform cubeMesh;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> Finding;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
   Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
   Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
   nearValue = <span class="hljs-number">0.5f</span>;<font></font>
   nearCube = <span class="hljs-number">0.5f</span>;<font></font>
   speed = <span class="hljs-number">1.3f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  { <font></font>
      playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
      cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
      cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">false</span> &amp;&amp; Finding == <span class="hljs-literal">false</span>)<font></font>
  {<font></font>
     PositionChanging();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">true</span>)<font></font>
  {<font></font>
     Finding = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PositionChanging</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  Finding = <span class="hljs-literal">true</span>;<font></font>
  Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
  Vector3 positionB = cubeMesh.transform.position;<font></font>
  <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bisher kann unser KI-Charakter die Entfernung zwischen sich und dem W√ºrfel berechnen. </font><font style="vertical-align: inherit;">Wenn sie zu weit voneinander entfernt sind, geht er zum W√ºrfel. </font><font style="vertical-align: inherit;">Nach Abschluss dieser Aufgabe kann er mit der n√§chsten Phase fortfahren und den W√ºrfel schieben. </font><font style="vertical-align: inherit;">Als letztes muss er berechnen, wie weit der W√ºrfel von der Position der Marke entfernt ist. Danach entscheidet er, in welche Richtung er schieben soll, wobei er ber√ºcksichtigt, auf welcher Seite des W√ºrfels sich die Marke befindet.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de1/be5/bf7/de1be5bf7e65540dfaeb6ab186a8e3c8.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der W√ºrfel kann nur entlang der X- und Z-Achse geschoben werden, und seine Drehung ist f√ºr uns noch nicht wichtig, da die Schaltfl√§che aktiviert wird, wenn der W√ºrfel darauf installiert ist. In Anbetracht dessen muss der KI-Charakter berechnen, wie weit der W√ºrfel von der Position der Markierung auf X und der Position der Markierung auf Z entfernt ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann vergleicht er die beiden Werte auf den beiden Achsen und w√§hlt aus, welche weiter von der gew√ºnschten Position entfernt ist, und beginnt dann, diese zu verschieben Achse. Der Charakter dr√ºckt weiter in diese Richtung, bis der W√ºrfel an der Position der Marke ausgerichtet ist, wechselt dann zur anderen Seite und dr√ºckt ihn, bis er vollst√§ndig √ºber der Position der Marke liegt:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> GameObject playerMesh;
<span class="hljs-keyword">public</span> Transform playerMark;
<span class="hljs-keyword">public</span> Transform cubeMark;
<span class="hljs-keyword">public</span> Transform cubeMesh;
<span class="hljs-keyword">public</span> Transform currentPlayerPosition;
<span class="hljs-keyword">public</span> Transform currentCubePosition;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeProximityY;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> nearCube;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeMarkProximityX;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> cubeMarkProximityZ;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> playerOnMark;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> cubeIsNear;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> Finding;<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        Vector3 playerMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.2f</span>, <span class="hljs-number">32.6f</span>, <span class="hljs-number">-31.3f</span>);<font></font>
        Vector3 cubeMark = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">81.9f</span>, <span class="hljs-number">-8.3f</span>, <span class="hljs-number">-2.94f</span>);<font></font>
        nearValue = <span class="hljs-number">0.5f</span>;<font></font>
        nearCube = <span class="hljs-number">0.5f</span>;<font></font>
        speed = <span class="hljs-number">1.3f</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the current position of the player</span><font></font>
  currentPlayerPosition.transform.position = playerMesh.transform.position;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the X axis</span><font></font>
  proximityValueX = playerMark.transform.position.x - currentPlayerPosition.transform.position.x;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates the distance between the player and the player mark of the Y axis</span><font></font>
  proximityValueY = playerMark.transform.position.y - currentPlayerPosition.transform.position.y;<font></font>
<font></font>
  <span class="hljs-comment">// Calculates if the player is near of his MARK POSITION</span>
  <span class="hljs-keyword">if</span>((proximityValueX + proximityValueY) &lt; nearValue)<font></font>
  {<font></font>
     playerOnMark = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  cubeProximityX = currentCubePosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  cubeProximityY = currentCubePosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>((cubeProximityX + cubeProximityY) &lt; nearCube)<font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">true</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
     cubeIsNear = <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">false</span> &amp;&amp; Finding == <span class="hljs-literal">false</span>)<font></font>
  {<font></font>
      PositionChanging();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(playerOnMark == <span class="hljs-literal">true</span> &amp;&amp; cubeIsNear == <span class="hljs-literal">true</span>)<font></font>
  {<font></font>
      Finding = <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
   cubeMarkProximityX = cubeMark.transform.position.x - currentCubePosition.transform.position.x;<font></font>
   cubeMarkProximityZ = cubeMark.transform.position.z - currentCubePosition.transform.position.z;<font></font>
<font></font>
   <span class="hljs-keyword">if</span>(cubeMarkProximityX &gt; cubeMarkProximityZ)<font></font>
   {<font></font>
     PushX();<font></font>
   }<font></font>
<font></font>
   <span class="hljs-keyword">if</span>(cubeMarkProximityX &lt; cubeMarkProximityZ)<font></font>
   {<font></font>
     PushZ();<font></font>
   }<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PositionChanging</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  Finding = <span class="hljs-literal">true</span>;<font></font>
  Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
  Vector3 positionB = cubeMesh.transform.position;<font></font>
  <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Hinzuf√ºgen der neuesten Aktionen zum Code muss der Charakter lernen, sein Ziel zu bestimmen, den W√ºrfel zu finden und an die gew√ºnschte Position zu schieben, damit der Spieler das Level durchlaufen und beenden kann. </font><font style="vertical-align: inherit;">In diesem Beispiel haben wir uns darauf konzentriert, wie Entfernungen zwischen Szenenobjekten und Charakteren berechnet werden. </font><font style="vertical-align: inherit;">Dies wird uns helfen, √§hnliche Arten von Interaktionen zu erstellen, bei denen wir das Spielobjekt an einer bestimmten Position platzieren m√ºssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Beispiel zeigt einen freundlichen KI-Charakter, der dem Spieler hilft, aber die gleichen Prinzipien k√∂nnen angewendet werden, wenn wir den gegenteiligen Effekt ben√∂tigen (wenn der Charakter ein Feind ist), bei dem der Charakter den W√ºrfel so schnell wie m√∂glich finden muss, um den Spieler zu stoppen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hindernisobjekte in Umgebungen am Beispiel von Age of Empires</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie wir bereits gesehen haben, k√∂nnen Sie Objekte im Spiel verwenden oder verschieben, um Ziele zu erreichen. Was passiert jedoch, wenn ein Objekt den Weg des Charakters blockiert? Das Objekt kann vom Spieler platziert oder einfach vom Designer an dieser Position der Karte platziert werden. In jedem Fall sollte der KI-Charakter bestimmen k√∂nnen, was in dieser Situation zu tun ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen dieses Verhalten beispielsweise in einer Strategie namens Age of Empires II beobachten, die von Ensemble Studios entwickelt wurde. Jedes Mal, wenn ein Spielcharakter das feindliche Gebiet nicht erreichen kann, weil er von befestigten Mauern umgeben ist, wechselt die KI dazu, einen Teil der Mauer zu zerst√∂ren, um weiterzumachen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Art der Interaktion ist auch sehr klug und wichtig, da die Charaktere sonst nur auf der Suche nach einem Eingang an der Wand entlang wandern w√ºrden und dies nicht nach vern√ºnftigem Verhalten aussehen w√ºrde. </font><font style="vertical-align: inherit;">Da die verst√§rkte Wand vom Spieler erstellt wird, kann sie √ºberall platziert werden und jede Form haben. </font><font style="vertical-align: inherit;">Daher m√ºssen Sie bei der Entwicklung einer feindlichen KI dar√ºber nachdenken.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/137/655/f44137655e3220988033bcb97db85b96.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Beispiel bezieht sich auch auf das Thema unseres Artikels, da wir in der Planungsphase beim Erstellen von Verhaltensb√§umen dar√ºber nachdenken m√ºssen, was passieren wird, wenn etwas dem Charakter im Weg steht und er seine Ziele nicht erreichen kann. </font><font style="vertical-align: inherit;">Wir werden diesen Aspekt in den folgenden Kapiteln des Buches ausf√ºhrlich betrachten, aber jetzt vereinfachen wir die Situation und analysieren, wie sich der KI-Charakter verhalten soll, wenn das Umgebungsobjekt ihn daran hindert, sein Ziel zu erreichen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfb/464/89b/dfb46489b482f383bc95662246308536.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Beispiel muss der KI-Charakter das Haus betreten, aber als er sich n√§hert, stellt er fest, dass er von einem Holzzaun umgeben ist, durch den Sie nicht gehen k√∂nnen. Wir m√∂chten, dass der Charakter zu diesem Zeitpunkt ein Ziel ausw√§hlt und angreift, bis dieser Teil des Zauns zerst√∂rt ist und er das Haus betreten kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel m√ºssen wir berechnen, welchen Zaun der Charakter angesichts der Entfernung und des aktuellen Gesundheitszustands des Zauns angreifen soll. Ein Zaun mit niedrigen HP sollte eine h√∂here Priorit√§t f√ºr Angriffe haben als ein Zaun mit vollen HP, daher werden wir dies in unseren Berechnungen ber√ºcksichtigen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/223/23f/ac4/22323fac4373a3556b58383bfb6b36fe.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wollen die Nachbarschaft um den Charakter herum festlegen, in der die n√§chsten Z√§une ihre Informationen an k√ºnstliche Intelligenz √ºbertragen, damit sie entscheiden k√∂nnen, welche leichter zu zerst√∂ren ist. Dies kann auf verschiedene Arten implementiert werden, entweder durch Erkennen von Kollisionen von Z√§unen mit dem Spieler oder durch Erzwingen der Berechnung des Abstands zwischen Z√§unen / Objekten und dem Spieler. Wir legen den Wert der Entfernung fest, ab der der Spieler den Zustand des Zauns wahrnimmt. In unserem Beispiel berechnen wir die Entfernung und verwenden sie, um den Charakter √ºber HP Z√§une zu informieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit der Erstellung des Codes, der auf das Zaunobjekt angewendet wird. Alle haben das gleiche Skript:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> HP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> distanceValue;
<span class="hljs-keyword">private</span> Transform characterPosition;
<span class="hljs-keyword">private</span> GameObject characterMesh;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> nearValue;<font></font>
<font></font>
<span class="hljs-comment">// Use this for initialization</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  HP = <span class="hljs-number">100f</span>;<font></font>
  distanceValue = <span class="hljs-number">1.5f</span>;<font></font>
<font></font>
  <span class="hljs-comment">// Find the Character Mesh</span>
  characterMesh = GameObject.Find(<span class="hljs-string">"AICharacter"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Update is called once per frame</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">// Obtain the Character Mesh Position</span><font></font>
  characterPosition = characterMesh.transform;<font></font>
<font></font>
  <span class="hljs-comment">//Calculate the distance between this object and the AI Character</span>
  proximityValueX = characterPosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
  proximityValueY = characterPosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
  nearValue = proximityValueX + proximityValueY;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Skript haben wir grundlegende Informationen zu HP und Entfernungen hinzugef√ºgt, die zur Verbindung mit dem KI-Charakter verwendet werden. Dieses Mal f√ºgen wir das Skript zur Entfernungsberechnung nicht dem Zeichen, sondern den Umgebungsobjekten hinzu. Dies gibt dem Objekt mehr Dynamik und erm√∂glicht es uns, mehr M√∂glichkeiten zu schaffen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Charaktere des Spiels beispielsweise auch Z√§une bauen, haben sie unterschiedliche Zust√§nde, z. B. "im Bau", "abgeschlossen" oder "besch√§digt". dann kann der Charakter diese Informationen empfangen und f√ºr seine eigenen Zwecke verwenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns den Charakter so einstellen, dass er mit dem Umgebungsobjekt interagiert. Sein Hauptziel wird es sein, Zugang zum Haus zu erhalten, aber als er sich ihm n√§hert, stellt er fest, dass er nicht hineinkommen kann, weil er von Holzz√§unen umgeben ist. Wir wollen, dass unser Charakter, nachdem er die Situation analysiert hat, den Zaun zerst√∂rt, um sein Ziel zu erreichen und ins Haus zu gelangen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Charakterskript f√ºgen wir eine statische Funktion hinzu, zu deren Eingabe Z√§une Informationen √ºber ihre aktuelle "Gesundheit" √ºbertragen k√∂nnen. Dies wird dem Charakter helfen, den am besten geeigneten Zaun f√ºr die Zerst√∂rung auszuw√§hlen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> fenceHP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> lowerFenceHP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> fencesAnalyzed;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameObject bestFence;<font></font>
<font></font>
<span class="hljs-keyword">private</span> Transform House;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> timeWasted;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;<font></font>
<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        fenceHP = <span class="hljs-number">100f</span>;<font></font>
        lowerFenceHP = fenceHP;<font></font>
        fencesAnalyzed = <span class="hljs-number">0</span>;<font></font>
        speed = <span class="hljs-number">0.8</span>;<font></font>
<font></font>
        Vector3 House = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">300.2f</span>, <span class="hljs-number">83.3f</span>, <span class="hljs-number">-13.3f</span>);<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        timeWasted += Time.deltaTime;<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(fenceHP &gt; lowerFenceHP)<font></font>
        {<font></font>
            lowerFenceHP = fenceHP;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(timeWasted &gt; <span class="hljs-number">30f</span>)<font></font>
        {<font></font>
            GoToFence();  <font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GoToFence</span><span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        Vector3 positionA = <span class="hljs-keyword">this</span>.transform.position;<font></font>
        Vector3 positionB = bestFence.transform.position;<font></font>
        <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(positionA, positionB, Time.deltaTime * speed);<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/970/af0/7a8970af0c9b5aa303ba32d6dc021ec8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben dem Charakter bereits die grundlegendsten Informationen hinzugef√ºgt. </font></font><code>fenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird eine statische Variable sein, bei der jeder Zaun, der in den Radius der Nachbarschaft des Charakters f√§llt, Informationen √ºber die aktuellen HP aufzeichnet. Dann analysiert der KI-Charakter die empfangenen Informationen und vergleicht sie mit dem Zaun mit den geringsten pr√§sentierten HP </font></font><code>lowerFenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Charakter hat eine Variable, </font></font><code>timeWasted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die die Anzahl der Sekunden darstellt, die er bereits auf der Suche nach einem geeigneten Zaun zur Zerst√∂rung verbracht hat. </font></font><code>fencesAnalyzed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird verwendet, um herauszufinden, ob der Code bereits einen Zaun enth√§lt, und wenn nicht, wird der erste vom Charakter gefundene Zaun hinzugef√ºgt. Falls Z√§une den gleichen HP-Wert haben, greift der Charakter sie zuerst an. F√ºgen wir nun den Code der Z√§une hinzu, damit sie auf das Skript des Charakters zugreifen und n√ºtzliche Informationen eingeben k√∂nnen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> HP;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> distanceValue;
<span class="hljs-keyword">private</span> Transform characterPosition;
<span class="hljs-keyword">private</span> GameObject characterMesh;<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueX;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> proximityValueY;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> nearValue;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        HP = <span class="hljs-number">100f</span>;<font></font>
        distanceValue = <span class="hljs-number">1.5f</span>;<font></font>
<font></font>
        <span class="hljs-comment">// Find the Character Mesh</span>
        characterMesh = GameObject.Find(<span class="hljs-string">"AICharacter"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> <span class="hljs-params">()</span> </span>{<font></font>
<font></font>
        <span class="hljs-comment">// Obtain the Character Mesh Position</span><font></font>
        characterPosition = characterMesh.transform;<font></font>
<font></font>
        <span class="hljs-comment">//Calculate the distance between this object and the AI Character</span>
        proximityValueX = characterPosition.transform.position.x - <span class="hljs-keyword">this</span>.transform.position.x;<font></font>
        proximityValueY = characterPosition.transform.position.y - <span class="hljs-keyword">this</span>.transform.position.y;<font></font>
<font></font>
        nearValue = proximityValueX + proximityValueY;<font></font>
<font></font>
        <span class="hljs-keyword">if</span>(nearValue &lt;= distanceValue){
            <span class="hljs-keyword">if</span>(AICharacter.fencesAnalyzed == <span class="hljs-number">0</span>){<font></font>
                AICharacter.fencesAnalyzed = <span class="hljs-number">1</span>;<font></font>
                AICharacter.bestFence = <span class="hljs-keyword">this</span>.gameObject;<font></font>
            }<font></font>
<font></font>
            AICharacter.fenceHP = HP;<font></font>
<font></font>
            <span class="hljs-keyword">if</span>(HP &lt; AICharacter.lowerFenceHP){<font></font>
                AICharacter.bestFence = <span class="hljs-keyword">this</span>.gameObject;<font></font>
            }<font></font>
        }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben dieses Beispiel endlich fertiggestellt. </font><font style="vertical-align: inherit;">Jetzt vergleicht der Zaun seine aktuellen HP mit den Daten des Charakters ( </font></font><code>lowerFenceHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Wenn seine HP niedriger als der niedrigste Wert des Charakters sind, wird dieser Zaun ber√ºcksichtigt </font></font><code>bestFence</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Beispiel zeigt, wie ein KI-Charakter an verschiedene dynamische Objekte im Spiel angepasst wird. </font><font style="vertical-align: inherit;">Das gleiche Prinzip kann erweitert und verwendet werden, um mit fast jedem Objekt zu interagieren. </font><font style="vertical-align: inherit;">Es ist auch anwendbar und n√ºtzlich, wenn Objekte verwendet werden, um mit einem Charakter zu interagieren und Informationen zwischen ihnen zu verkn√ºpfen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beitrag haben wir verschiedene Arten der Interaktion mit der Umgebung untersucht. </font><font style="vertical-align: inherit;">Die in diesem Kapitel vorgestellten Techniken k√∂nnen auf viele verschiedene Spielgenres erweitert und zur Durchf√ºhrung einfacher und komplexer Interaktionen zwischen KI-Charakteren und der Umgebung verwendet werden.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de496046/index.html">3D-Grafik auf dem STM32F103</a></li>
<li><a href="../de496050/index.html">Tiger und L√∂wen bekommen in New York Coronavirus</a></li>
<li><a href="../de496052/index.html">Wie kann ein Dienstleistungsunternehmen Bu√ügelder von Kunden vermeiden? Einige offensichtliche Vorteile der Prozessautomatisierung</a></li>
<li><a href="../de496056/index.html">Digital: Wie Zahlen und Begriffe uns t√§uschen</a></li>
<li><a href="../de496058/index.html">Warum es notwendig ist, landwirtschaftliche M√§hdrescher zu roboterisieren, was sind die Schwierigkeiten und wie wir es in zwei Jahren gemacht haben</a></li>
<li><a href="../de496082/index.html">Data Engineer und Data Scientist: Was ist der Unterschied?</a></li>
<li><a href="../de496084/index.html">Blazor Client Side Online Store: Teil 6 - Erstellen einer Bestellung und Arbeiten mit Ausgleichsma√ünahmen</a></li>
<li><a href="../de496086/index.html">Organisieren der Remote-Arbeit mit digitalen Zextras-Jobs</a></li>
<li><a href="../de496088/index.html">21. April Live! Badoo Lokalisierungstreffen</a></li>
<li><a href="../de496090/index.html">Mit Zyxel gel√∂scht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>