<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🚀 👨🏼 👨🏾‍🤝‍👨🏽 上架的SwiftUI：动画，第2部分 🐤 📁 🆚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这是SwiftUI中动画故事的第二部分。在第一篇文章中，我们看了一些简单的示例来了解SwiftUI中动画工作原理的基础。在这一部分中，我们将进行更进一步，并且将详细分析彩虹动画所宣布的示例。
 
 
 
 在剪切下，您将发现动画的时序分析，创建用于循环线性动画的自己的时序曲线机制，不同渐变的实现示例...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>上架的SwiftUI：动画，第2部分</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506672/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是SwiftUI中动画故事的第二部分。在第一</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">篇文章中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们看了一些简单的示例来了解SwiftUI中动画工作原理的基础。在这一部分中，我们将进行更进一步，并且将详细分析彩虹动画所宣布的示例。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在剪切下，您将发现动画的时序分析，创建用于循环线性动画的自己的时序曲线机制，不同渐变的实现示例以及一些有趣的技巧，这些技巧将帮助您了解动画在幕后的工作方式。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我提醒您，我在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">侦察过实现这种动画的想法</font><font style="vertical-align: inherit;">。在那儿，作者采取了阻力最小的途径，并通过对形状进行动画处理，实现了最明显的方法来实现此概念。原理很简单：每个波都是贝塞尔曲线所勾勒的轮廓，“时间”参数会影响该波右边界的位置。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是完成的动画的外观：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了清楚起见，我将波浪稍微垂直地散开。这很容易做到，我只是在NotchWave的结尾处添加了根据动画的当前阶段将整个轮廓向下移动到波浪高度的方法：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">return</span> p.applying(.<span class="hljs-keyword">init</span>(translationX: <span class="hljs-number">0</span>, y: height * <span class="hljs-keyword">self</span>.phase))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同样，.drowingGroup（）也有必要不要忘记断开连接-这并不意味着图像超出了固定框架的边界。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z3/zv/bi/z3zvbiseywno8t1fnt-i0ugcqgm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种方法很简单，可以产生预期的结果……但是在我看来，这太无聊了。</font><font style="vertical-align: inherit;">事实证明，我的道路要长得多，我不会说最终结果至少会好一些，但在此过程中会很有趣。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您仍然不太了解SwiftUI中的动画工作原理，我强烈建议您阅读</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上一篇文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我想深入研究</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上的源代码</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用渐变</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一开始，我选择了另一种方法。我发现处理对象位移的动画比处理表单的动画要有用得多（我仍然称呼表单的形状结构）。偏移可以处理任何内容-各种形状，图像，其他视图。作为一项教育任务，我想实现从一个波形到另一个波形的平滑颜色过渡。在最初的概念中，就是这样。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总的来说，SwiftIUI提供了三种可能的渐变用法-线性，圆形和角度。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t7/o6/7d/t7o67dwcm_v5svufist7tfp0kwe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在代码中，这看起来像某种块构造函数。注意整个波如何分割。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wa/af/el/waafeltt9cgiasfzxg1gjexwc8i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
线性渐变的特征是渐变的起点和终点。</font><font style="vertical-align: inherit;">这些不是具有绝对坐标（x：y :)的CGPoint点，而是UnitPoint点，即 </font><font style="vertical-align: inherit;">相对坐标，其中x：y：以为此视图选择的区域的宽度和高度的分数指定。</font><font style="vertical-align: inherit;">还存在对应于角的预定义点（.topLeading，.bottomTrailing等）和边的中点（.top，.trailing等）。</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
    .fill(<span class="hljs-type">LinearGradient</span>(<font></font>
         gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
          startPoint: .leading,<font></font>
          endPoint: .trailing))<font></font>
    .frame(width: <span class="hljs-keyword">self</span>.gradientLength)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
线性梯度线段是“橡胶”。</font><font style="vertical-align: inherit;">它具有固定的宽度，但未指定其高度。</font><font style="vertical-align: inherit;">因此，它将填满所提供的全部金额。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个稍微复杂的故事，带有圆形渐变。</font><font style="vertical-align: inherit;">我们指出点-圆心，渐变起点的半径和渐变终点的半径。</font><font style="vertical-align: inherit;">半径已经是绝对值，即 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">点</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
圆心仍设置为UnitPoint。</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
     .fill(<span class="hljs-type">RadialGradient</span>(<font></font>
          gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">0</span>),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">1</span>)]),<font></font>
          center: .bottomTrailing,<font></font>
          startRadius: <span class="hljs-keyword">self</span>.topRadius,<font></font>
          endRadius: <span class="hljs-keyword">self</span>.topRadius + <span class="hljs-keyword">self</span>.gradientLength)<font></font>
                )<font></font>
    .frame(height: <span class="hljs-keyword">self</span>.topRadius)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
带有顶部圆圈的片段具有固定的高度，但水平延伸。毕竟，我们以点为单位设置了特定的固定半径，因此不需要像线性渐变那样粘合基本颜色的其他拉伸矩形。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最难应用的是角度梯度。它由起点和终点角度以及方向给出。从代码清单中可以看到，使用角不是很方便。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您需要在一个点开始角度梯度并在另一个点结束，则必须记住三角学的课程以便计算所需的角度。</font></font><br>
<br>
<pre><code class="swift hljs">       
<span class="hljs-type">Rectangle</span>()<font></font>
      .fill(<span class="hljs-type">AngularGradient</span>(<font></font>
            gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.angularGradientMiddleStop(blockWidth: geometry.size.width)),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
            center: .bottomLeading,<font></font>
            startAngle: <span class="hljs-keyword">self</span>.directionTo(gradientPart: <span class="hljs-keyword">self</span>.start, blockWidth: geometry.size.width),<font></font>
            endAngle: <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)))<font></font>
<font></font>
...<font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">directionTo</span><span class="hljs-params">(gradientPart: Color, blockWidth: CGFloat)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> angleOf = gradientAngles(blockWidth: blockWidth)
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>.zero
        <span class="hljs-keyword">switch</span> gradientPart{
            <span class="hljs-keyword">case</span> start: angle = angleOf.start
            <span class="hljs-keyword">case</span> middle: angle = angleOf.middle
            <span class="hljs-keyword">case</span> end: angle = angleOf.end
            <span class="hljs-keyword">default</span>: <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"there is no gradient stop with that color: \(gradientPart)"</span>)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gradientAngles</span><span class="hljs-params">(blockWidth: CGFloat)</span></span> -&gt; (start: <span class="hljs-type">Angle</span>, middle: <span class="hljs-type">Angle</span>, end: <span class="hljs-type">Angle</span>){
        <span class="hljs-keyword">let</span> blockHeight = <span class="hljs-keyword">self</span>.bottomRadius
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: blockHeight)
        <span class="hljs-keyword">let</span> topRight = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength)
        <span class="hljs-keyword">let</span> topGradientStarts = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength * (<span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop))
        <span class="hljs-keyword">let</span> startAngle = center.radialDirection(to: topRight)
        <span class="hljs-keyword">let</span> middleAngle = center.radialDirection(to: topGradientStarts)
        <span class="hljs-keyword">let</span> endAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)
        <span class="hljs-keyword">return</span> (start: startAngle, middle: middleAngle, end: endAngle)<font></font>
    }<font></font>
<font></font>
...<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">CGPoint</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">radialDirection</span><span class="hljs-params">(to point: CGPoint)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> deltaX =  point.x - <span class="hljs-keyword">self</span>.x
        <span class="hljs-keyword">let</span> deltaY =  point.y - <span class="hljs-keyword">self</span>.y
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span> deltaX == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaY == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaX / -deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(-deltaX / deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
角梯度是波浪的尾部，也是橡胶的，但已经很宽了-占剩余大小的一半。实际上，这就是为什么三角函数如此之多的原因。我知道屏幕边界上特定颜色应为特定点的位置（因为我将圆形渐变胶粘到一个角度）。而且，角度的值不仅取决于较低梯度的半径，还取决于具有梯度的块本身的宽度。自从放学以来，我第一次拿起铅笔，回忆起代数:)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有这三个选项都使用渐变中颜色的单一描述。</font><font style="vertical-align: inherit;">这是数组中颜色的简单列表。</font><font style="vertical-align: inherit;">它们在给定段上的分布将是均匀的。</font><font style="vertical-align: inherit;">您可以使用Stop元素数组来优化分布。</font><font style="vertical-align: inherit;">实际上，这是相同的颜色枚举，只是针对每种颜色，还指示了将要定位的单个线段上的坐标。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我创造了与原始概念大致相同形状的波浪。</font><font style="vertical-align: inherit;">但是，从一种颜色到另一种颜色的过渡现在不是很锐利，而是平滑的，这可能会使动画更平滑。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">颜色不是看起来</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有一点与颜色有关。</font><font style="vertical-align: inherit;">为了产生滚动波的效果，我决定使颜色之间的过渡不是很线性。</font><font style="vertical-align: inherit;">如果仔细观察，您会发现渐变在边缘本身处更加尖锐，并且距离边缘越远，渐变到主色中的平滑度就越高。</font></font><br>
<img src="https://habrastorage.org/webt/hb/k-/f-/hbk-f-u1tcrri8furxdgeg8tx50.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我通过计算中间颜色并使用此分布创建渐变来实现此目的：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始颜色-0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中间颜色-0.3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最终颜色-1</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
问题在于计算两种颜色的平均值。 SwiftUI的意思是将Color对象用于渐变，这很吸引我。实际上，如果您要像处理RGB对象一样使用颜色，请首先在模型中使用UIColor，因为Color无法直接访问颜色。您也不能轻易将其转换回UIColor。</font><font style="vertical-align: inherit;">我在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">这里</font></a><font style="vertical-align: inherit;">找到</font><font style="vertical-align: inherit;">的唯一</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（不是）</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">适当的解决方案</font><font style="vertical-align: inherit;">是通过分析其字符串表示形式来获得Mirror反射。这样的样板，但没有其他选择。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这不是错误，也不是遗漏。</font><font style="vertical-align: inherit;">关键是Color对象中的SwiftUI不会重复UIColor的功能。</font><font style="vertical-align: inherit;">如果您需要使用rgb频道-请使用它。</font><font style="vertical-align: inherit;">SwiftUI中的颜色是一种具有一些基本颜色的视图，其特定值可能会根据天空中星星的位置而略有不同-特定的rgb颜色仅在在屏幕上绘制时才能确定。</font><font style="vertical-align: inherit;">该文件说</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SwiftUI仅在将其在给定环境中使用之前将其解析为具体值。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但环境的含义是：用户背后的墙面颜色或iOS设计主题不清楚。</font><font style="vertical-align: inherit;">如果这不适合您，请本机使用UIColor。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无尽的动画</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
动画由.animation（）修饰符指定，并在</font></font><code>.onAppear()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过更改</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">在修饰符中初始化View之后开始</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">结果，</font></font><code>.rotationEffect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与系统计时器一致</font><font style="vertical-align: inherit;">，修饰符</font><font style="vertical-align: inherit;">订阅从“是”到“成为”的时间间隔接收animatableData。</font><font style="vertical-align: inherit;">我们在最后一部分谈到了这一点。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
       <span class="hljs-keyword">return</span> <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>))
            <span class="hljs-type">Spacer</span>()<font></font>
       }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/fl/dw/_0/fldw_0xguydvz5fe_-2tpcp3qkm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过以这种方式运行无尽的动画，您应该理解，随后对动画修改器所做的任何更改都会“破坏”它。</font><font style="vertical-align: inherit;">例如，如果由于某种原因在启动后将angle的值更改为0，则会得到以下效果：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ad/vi/iv/adviivgxhwuw0rwwv1itknh2kie.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么？答案是从一种动画过渡到另一种动画的动画机制。在我们的示例中，当View第一次出现在屏幕上时，我们开始了从0到90的动画过渡。该View实际上仅存储最终值90，而原始值0则不存储在任何地方。动画引擎知道动画的当前时间位置以及AnimatableData的当前值。在时间点0.5，它将是45。如果此时用户将值更改为0，会发生什么？答案：将值从45更改为0的动画将开始，所有内容仍然循环播放。但仅在视觉上，该循环不是封闭的，而是破裂的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，在某些情况下，如果您的视图使用@ObservedObject或其他导致视图重新渲染的参数，动画也会“中断”。若要解决此问题，.animation修饰符具有一个.animation（：value :)参数。在此传递值时，我们指示渲染器仅当此值更改时才需要重新启动动画。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，让我们弄清楚如果不再需要动画时如何停止动画。为此，您需要提供两件事。显然，我们必须告诉SwiftUI不再需要无尽的动画，而用通常的最终动画代替。但这还不够。 .animation（）修饰符是有关要使用的计时的指令，但是旋转本身在.rotationEffect（）修饰符内部进行了描述，并且它已经被计时器接收以接收新的旋转角度值。要停止旋转，我们还需要更改其值。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animation)<font></font>
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.angle == <span class="hljs-number">90</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">self</span>.animation = .<span class="hljs-keyword">default</span>
                }<span class="hljs-keyword">else</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span>
                    <span class="hljs-keyword">self</span>.animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/-o/-d/ui/-o-dui_0ep12qm5zwovo2iedvjm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
和以前一样，更改角度值会导致一个新动画的开始（看上去很糟），这个变化也将被动画化，但是现在是正常动画的时间。这就是为什么我们的方块不会立即停止旋转，而是好像变慢了一样。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您将所有功能暂停</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在on / off类型的</font><font style="vertical-align: inherit;">一个</font><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">上，则可以更简洁地编写相同的代码</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isStarted = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
到目前为止，一切都相对容易。但是请注意，这里的所有事件都是在视图内部生成的。</font></font><code>.onAppear{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它由系统调用</font></font><code>onTapGesture{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，当然也由用户</font><font style="vertical-align: inherit;">调用</font><font style="vertical-align: inherit;">。但是，如果要将整个动画封装在一个View中，仅将其传递/传递，该怎么办？ SwiftUI并不暗示父视图中可能存在任何父方法。从理论上讲，您可以将子视图存储为结构并调用其变异方法，但是</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无法以这种方式更改子视图的变量，我尝试过-它不起作用。像在本文中一样，执行此操作的唯一方法是使用Combine的PassthroughSubject。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，一切都简单得多。如果清楚地放在头上的架子上，那</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这是View的内部状态，而不是试图从外部操纵它，正确的解决方案将非常简单：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButtonFromOutside</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectParentView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isOn = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">AnimatedRectStopButtonFromOutside</span>(isStarted: isOn)
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isOn.toggle()<font></font>
            }<font></font>
        }.onAppear(){<font></font>
            <span class="hljs-keyword">self</span>.isOn = <span class="hljs-literal">true</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，我们不需要</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">订阅即可更新子视图内的视图-当其外部参数更改时，它已经作为一个整体进行了更新。</font><font style="vertical-align: inherit;">有时不方便。</font><font style="vertical-align: inherit;">有时我们不想再次初始化子视图-例如，为了不破坏动画，或者在init（）中会发生一些复杂且占用大量资源的计算（例如查询）。</font><font style="vertical-align: inherit;">在这些情况下，最好使用对象实体，可以使用onReceive修饰符监视对象的更改。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在视图更新期间修改状态</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有另一件事值得报道。我们仅使用0和90度这两个值进行运算。关闭动画会将角度重置为0。但是是否可以在我们单击按钮时立即暂停动画，并在恢复时从同一位置再次继续动画？让我们看一下允许这样做的代码：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRect</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> externalStarted = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(started externalStarted: <span class="hljs-type">Bool</span>){
        <span class="hljs-keyword">self</span>.externalStarted = externalStarted
        <span class="hljs-keyword">self</span>._internalStarted = <span class="hljs-type">State</span>(initialValue: !externalStarted)<span class="hljs-comment">//forse to start animation</span><font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-comment">//thats wrong. It just hiding a problem from SwiftUI not solving it</span>
        <span class="hljs-type">DispatchQueue</span>.main.async {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted == <span class="hljs-literal">false</span>{
                <span class="hljs-comment">// print("stop animation")</span>
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">false</span>
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted {
             <span class="hljs-comment">//    print("start animation")</span>
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">true</span>
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
       }<font></font>
         <font></font>
       <span class="hljs-keyword">return</span>  <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.red)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(internalStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e9/ci/ge/e9cigegcoxid1l9skuw2qxle238.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主要思想是在动画开始时跟踪时间。一段时间后，当我们决定停止动画播放时，我们将能够检查经过了多少个完整的动画播放周期，并猜测当前所看到的正方形旋转角度。之后，我们可以将该</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值精确</font><font style="vertical-align: inherit;">分配给</font><font style="vertical-align: inherit;">旋转角度变量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了使这种方法起作用，我们需要跟踪动画的开始和结束。初始化（）将不起作用。我们无法访问现有</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数来获取动画的先前开始时间。这是</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">的标记</font><font style="vertical-align: inherit;">。在init内，您只能设置此变量的初始状态，但是在初始化结束时，如果在init（）之前已经存在View，</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">则将恢复变量</font><font style="vertical-align: inherit;">的值</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，这里实现了let externalStarted参数（由外部控制）和内部参数</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var internalStarted，通过它们我们可以直接控制动画。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仅缺少一个-某些修改器将检查其符合性并在必要时进行更新，例如.onRecieve（），仅用于处理每个渲染。</font><font style="vertical-align: inherit;">然后我想-毕竟，每张图纸都要调用主体，所以为什么不直接在图纸中进行检查呢？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事实证明，SwiftUI发誓，如果在渲染过程中View更改了</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">的值</font><font style="vertical-align: inherit;">，它会给出</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在视图更新期间修改状态，这将导致未定义的行为。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并阻止这种变化。然后我去了一个肮脏的黑客，并使用DispatchQueue.main.async。但是，让我们看看为什么这是一个肮脏的hack，为什么不应该这样做呢？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这实际上是问题所在。如果我们在体内写一些明显的愚蠢，例如i + = 1，那么我就是某种</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量，那么我们得到一个无限循环。在渲染时，我们使内存中的视图不相关-因为我们更改了要渲染的初始数据。这意味着渲染完成后，我们的视图将立即排队等待重新渲染，但是即使那样我们也将立即使其不再相关。我们用自己的双手创造一个无尽的循环。在这种情况下，异步调用不会更改任何内容。它仅将下一轮的开始稍微移至“渲染后立即”。因此，异步调用不能解决问题，而只能掩饰它，从而阻止SwiftUI用鼻子戳我们。就像在汽车上，“检查引擎”灯泡被撕掉了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方面，这有什么问题？在任何编程语言中，如果您不了解自己在做什么，都有无数种方法可以使自己陷入困境。但另一方面，这种方法根本不是SwiftUI应该如何工作的。在运行时使用View是不好的。是的，您可以在胸前beat脚，确保始终编写正确的代码，而这些代码永远不会陷入无休止的循环中……但这就像对选项的不安全检索一样，这是一种不好的做法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正如我所说，在这种情况下，您应该使用Combine，并使用PassthroughSubject传递新值。但是您可以通过订阅它的willChange事件来使用通常的ObservableObject。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandlerTest</span>
    <span class="hljs-keyword">let</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandlerTest</span>){
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)<font></font>
       }.onReceive(animationHandler.objectWillChange){<font></font>
            <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
            <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                withAnimation(.<span class="hljs-keyword">none</span>){<span class="hljs-comment">//not working:(((</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
                }<font></font>
            }<span class="hljs-keyword">else</span> {
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
        }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span>
            <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里有争议的一点是在订阅对象将只被更改的通知中使用对象本身的值。</font><font style="vertical-align: inherit;">到目前为止，在我的示例中，我已经修改了一个对象。</font><font style="vertical-align: inherit;">显然，通知会有些滞后。</font><font style="vertical-align: inherit;">但是我不能保证会一直如此，因此我建议您使用自制的didChange通知或PassthroughSubject，将新值传递给它。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wj/ou/nd/wjoundfihtxhnar7iucx7rrkvnm.gif"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动画动画更改</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正如您在gif上看到的那样，动画不会立即停止。</font><font style="vertical-align: inherit;">她需要一些时间。</font><font style="vertical-align: inherit;">这是因为当我们为角度分配中间值时，我们还使用了某种动画-默认动画。</font></font><br>
<br>
<pre><code class="swift hljs">.animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这导致异常行为。</font><font style="vertical-align: inherit;">尽管我所描述的一切都相对简单，但即使在粗心的程序员没有指出任何内容的情况下，也仍然保留了许多细微的交互作用，从而使画面始终看起来很平滑。</font><font style="vertical-align: inherit;">因此，默认动画是spring。</font><font style="vertical-align: inherit;">它最适合于模拟物理定律。</font><font style="vertical-align: inherit;">而且，这是一个相当短的动画，大约0.2秒。</font><font style="vertical-align: inherit;">如果过渡到新状态的动画（由我们计算和指示的角度）没有时间完美地适应默认的0.2秒，以便从当前的动画速度（以缓慢的速度）切换到完全停止，则SwiftUI本身将添加另一循环的无尽动画，以加速版本播放。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z0/b0/so/z0b0soljlzjqudxhek_irdxgyoy.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为避免这种情况，不使用默认动画就足够了。</font><font style="vertical-align: inherit;">对于底部正方形，我关闭了旋转停止动画，如下所示：</font></font><br>
<br>
<pre><code class="swift hljs">                
.animation(animationHandler.isStarted ? animation : <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
或者，您可以在停止时更准确地计算所需的参数值，但是为此，您不仅需要大致假定动画的当前时刻，还需要确切地知道它。</font><font style="vertical-align: inherit;">我将在下面显示如何执行此操作。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个动画中几波的运动</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回到彩虹动画。</font><font style="vertical-align: inherit;">因此，我们本身就有波浪，让我们教它们前进。</font><font style="vertical-align: inherit;">我想做的第一件事是运行无尽的动画。</font><font style="vertical-align: inherit;">我决定这样做：我将有一个</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量负责动画的当前位置。</font><font style="vertical-align: inherit;">在状态0处，第一个波浪将在开始处，最后一个波浪将在末端处。</font><font style="vertical-align: inherit;">波浪本身将重叠。</font><font style="vertical-align: inherit;">因此，每个波的可见部分的长度将取决于波的数量。</font><font style="vertical-align: inherit;">我使用ZStack（列出所有波形）和我自己的.wavePosition修改器实现了此功能，在其中我计算了动画时每个波形的当前位置以及它们重叠的顺序。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很多代码</font></font></b>
                        <div class="spoiler_text"><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpWavePosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">let</span> wave: <span class="hljs-type">WaveDescription</span>
    <span class="hljs-keyword">let</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    <span class="hljs-keyword">var</span> time: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> currentPosition: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
                <span class="hljs-keyword">self</span>.time = newValue
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(wave: <span class="hljs-type">WaveDescription</span>, time: <span class="hljs-type">CGFloat</span>, animationHandler: <span class="hljs-type">AnimationHandler</span>){
        <span class="hljs-keyword">self</span>.wave = wave
        <span class="hljs-keyword">self</span>.time = time
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-number">0</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(forWave: Int, ofWaves: Int, overTime: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{<font></font>
<font></font>
        <span class="hljs-keyword">let</span> time = overTime - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(overTime))
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(ofWaves)
        <span class="hljs-keyword">let</span> initialPosition = oneWaveWidth * <span class="hljs-type">CGFloat</span>(forWave)
        <span class="hljs-keyword">let</span> currentPosition = initialPosition + time
        <span class="hljs-keyword">let</span> fullRounds = <span class="hljs-type">Int</span>(currentPosition)
        <span class="hljs-keyword">var</span> result = currentPosition - <span class="hljs-type">CGFloat</span>(fullRounds)
        <span class="hljs-keyword">if</span> fullRounds &gt; <span class="hljs-number">0</span> &amp;&amp; result == <span class="hljs-number">0</span>{
            <span class="hljs-comment">// at the end of the round it should be 1, not 0</span>
            result = <span class="hljs-number">1</span><font></font>
        }<font></font>
 <span class="hljs-comment">//       print("wave \(forWave) in time \(overTime) was at position \(result)")</span>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(wave.totalWavesCount)
        <span class="hljs-keyword">var</span> thisIsFirstWave = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> currentPosition &lt; oneWaveWidth{<font></font>
            thisIsFirstWave = <span class="hljs-literal">true</span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span>
            <span class="hljs-type">Group</span>{<font></font>
                content<font></font>
                            .offset(x: -wave.width + currentPosition * (wave.width +  wave.gradientLength),<font></font>
                            <span class="hljs-comment">//to watch how waves move uncoment this</span>
                           <span class="hljs-comment">// y: CGFloat(self.waveInd * 20))</span>
                        y:<span class="hljs-number">0</span>)<font></font>
                    .zIndex(-<span class="hljs-type">Double</span>(currentPosition))<font></font>
                    .transition(.identity)<font></font>
                    .animation(<span class="hljs-literal">nil</span>)<font></font>
<font></font>
                <span class="hljs-keyword">if</span> thisIsFirstWave{<font></font>
                    content<font></font>
                        .offset(x: wave.gradientLength, y: <span class="hljs-number">0</span>)<font></font>
                        .zIndex(-<span class="hljs-number">2</span>)<font></font>
                        .transition(.identity)<font></font>
                        .animation(<span class="hljs-literal">nil</span>)<font></font>
                }<font></font>
            }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">positionOfSharp</span><span class="hljs-params">(wave: WaveDescription, inTime: CGFloat, animationHandler: AnimationHandler)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">SharpWavePosition</span>(wave: wave, time: inTime, animationHandler: animationHandler))<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpRainbowView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">let</span> waves: [<span class="hljs-type">SharpGradientBorder</span>]
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> rainbowPosition: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandler</span>,<font></font>
        backgroundColor: <span class="hljs-type">Color</span> = .clear<font></font>
    ){<font></font>
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">let</span> bottomRadius = animationHandler.waveGeometry.bottomRadius
        <span class="hljs-keyword">let</span> topRadius = animationHandler.waveGeometry.topRadius
        <span class="hljs-keyword">let</span> gradientLength = animationHandler.waveGeometry.gradientLength
        <span class="hljs-keyword">let</span> rainbowColors = animationHandler.rainbowColors
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">var</span> lastColor = rainbowColors.last <span class="hljs-keyword">else</span> {<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"no colors to display in rainbow"</span>)}
        <span class="hljs-keyword">var</span> allWaves = [<span class="hljs-type">SharpGradientBorder</span>]()
        <span class="hljs-keyword">for</span> color <span class="hljs-keyword">in</span> rainbowColors{
            <span class="hljs-keyword">let</span> view = <span class="hljs-type">SharpGradientBorder</span>(start: color,<font></font>
                                      end: lastColor,<font></font>
                                      bottomRadius: bottomRadius,<font></font>
                                      topRadius: topRadius,<font></font>
                                      gradientLength: gradientLength)<font></font>
            allWaves.append(view)<font></font>
            lastColor = color<font></font>
        }<font></font>
        <span class="hljs-keyword">self</span>.waves = allWaves<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">VStack</span>{
                <span class="hljs-type">ZStack</span>{
                    <span class="hljs-type">ForEach</span>(<span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){ind <span class="hljs-keyword">in</span>
                        <span class="hljs-keyword">self</span>.waves[ind]<font></font>
                            .positionOfSharp(wave: <span class="hljs-type">WaveDescription</span>(ind: ind,<font></font>
                                                    totalWavesCount: <span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">count</span>,<font></font>
                                                    width: geometry.size.width,<font></font>
                                                    baseColor: <span class="hljs-keyword">self</span>.waves[ind].end,<font></font>
                                                    gradientLength: <span class="hljs-keyword">self</span>.waves[ind].bottomRadius + <span class="hljs-keyword">self</span>.waves[ind].topRadius),<font></font>
                                             inTime: <span class="hljs-keyword">self</span>.rainbowPosition,<font></font>
                                             animationHandler: <span class="hljs-keyword">self</span>.animationHandler)<font></font>
                            .animation(<span class="hljs-keyword">self</span>.animationHandler.isStarted ? <span class="hljs-keyword">self</span>.animation : .linear(duration: <span class="hljs-number">0</span>))<font></font>
                    }<font></font>
                }<font></font>
     <span class="hljs-comment">//           .clipped()</span><font></font>
            }<font></font>
<font></font>
        }<font></font>
        .onAppear(){<font></font>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.rainbowPosition = <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
        .onReceive(animationHandler.objectWillChange){<font></font>
             <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
             <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                <span class="hljs-keyword">let</span> newPosition = <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"animated from \(self.rainbowPosition - 1) to \(self.rainbowPosition) stopped at \(newPosition)"</span>)
                    <span class="hljs-keyword">self</span>.rainbowPosition = newPosition<font></font>
             }<span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">self</span>.rainbowPosition += <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
 </code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一次在屏幕上显示“视图”时，我们将状态从0更改为1，这考虑到声明的线性动画，使波浪在屏幕上无限循环。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/vr/ym/bgvrymyoubpekjmpgnsrtxxgco8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当波的边缘到达右边缘时，其下一个位置将位于屏幕边缘的最开始。看起来好像它只是从波的末端消失了，暴露了我们想避免的背景底物。为此，在body（）函数的修饰符中出现了if {...}块，其中绘制了屏幕上缺少的第一个wave的副本。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/6m/vt/si6mvtiimlv73kxy4c4imperxc4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，我必须以修改器参数的形式传递每个波的几何特征。</font><font style="vertical-align: inherit;">问题是我需要根据当前动画阶段重新定义每个波的z索引。</font><font style="vertical-align: inherit;">我可以通过使用内部的GeometryReader {}修饰符来提取可见区域的宽度，但是，我面临这样一个事实，即它会阻止更改波的叠加顺序。</font><font style="vertical-align: inherit;">.zIndex（）修饰符仅在View层次结构中的第一个ZStack {}容器的上下文中起作用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GeometryReader切断了此连接，并且zIndex（）停止工作。</font><font style="vertical-align: inherit;">到目前为止，如果您认为GeometryReader是获取有关当前View大小的数据的一种无害方法，则并不完全正确。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流动画</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一个要点是了解您自己的修改器中内置修改器的动画。在某个点，每个波都接近屏幕边缘，获得最大的水平偏移，然后到达起始位置，获得最小的偏移。此更改与其他更改相同，并且即使在动画内部也已设置动画。毕竟，动画只是将频率值非常频繁地传递给修改器，并且无论它听起来多么奇怪，它也将与动画一起执行。事实证明，在动画内部，在此修饰符内部传递新值，我们仅更改当前运动动画的终点。事实证明，每次到达屏幕边缘的波浪都会转身并向后漂浮。但是它也没有达到开始，但是迟早要赶上所需的位置，然后再次开始从左向右移动。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/aj/xp/ky/ajxpkyp6nxn-e6ixzzrv7y-g-c4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以通过插入.animation（nil）修饰符来解决此问题。因此，我关闭了文本中上面应用的所有修改器的动画。这是任何修饰符工作的一般逻辑：它会更改其输入上的内容，并且在输入上我们会获得所有先前修饰符的结果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般而言，不同动画的整个层次结构在这里起作用。除非您为View另行指定，否则默认值为将用于显示所有修改器的更改的默认设置。我们有一个执行线程（假设这是主线程），在其中调用了主体。我们假定它具有.animation参数，每次修改器收到新值时都会检查该参数。如果修改器支持动画（符合AnimatableModifier协议），并且为流启用了动画（使用了某些特定的动画，而不是.none或nil），则更改将被动画化。这就是我们的工作，</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在withAnimation {}块中</font><font style="vertical-align: inherit;">包含了一些用于更改</font><font style="vertical-align: inherit;">参数的</font><font style="vertical-align: inherit;">代码</font><font style="vertical-align: inherit;">-我们在当前线程中开了一个特定的动画，然后进行某种更改</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量。在这种情况下，withAnimation {}是一种等效的事务，对此事务所做的所有更改都将被动画化。结果，在同一个流中，将这些更改转换为所有相关View的周期开始，这些View的修饰符接收一个新值，并订阅以接收AnimatableData的中间值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，动画上还有一些元素无法影响。例如，滑块的位置是通过自身，内部机制来设置动画的，因此无需执行任何操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，withAnimation（）是一种为正在执行的动作启动默认动画的方法。但是对于某些视图，您可以使用.animation（）修饰符来显式指定自己的动画。在这种情况下，组成传递给.animation（）的内容的修饰符和形式（应用.animation（）之前代码中列出的所有内容）将接收您描述的时间，并忽略流动画。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我的WavePosition修改器中，我使用.animation（nil）摆脱内置偏移动画，从而指示我忽略当前的流动画。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尾盖也一样。让我提醒您上一篇文章的结论。实际上，我们的内存中有N个WavePosition修改器结构，每个波形一个。它们都从系统计时器中获得新的位置值，从而计算出每个波在给定时间点的位置。这意味着每个波我们也有N个端盖。多亏了if {}块，在任何给定时间仅显示了其中一个。但是，同一街区给我们放了一头猪。视图的消失和外观也与流的动画一起执行。这意味着.transition修饰符用于在更改条件后为视图的外观和消失设置动画。通常，默认情况下使用.opacity，但是出于某种原因，我使用.slide代替。都不适合我，所以我只是取消了这个动画，使用.transition（.identity）。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新。</font><font style="vertical-align: inherit;">在准备本文时，Xcode 11.4出现了，其中似乎默认情况下对过渡进行了重新设计。</font><font style="vertical-align: inherit;">至少现在我注释掉.transition（.identity）没有任何问题，也没有收到导致我添加它的问题。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动画时间</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们终于得出了一个最有趣的问题：如何使海浪加速运动？</font><font style="vertical-align: inherit;">和往常一样，我会从很远的地方来。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，动画是对给定动画速度的描述。我们可以确定修改器本身内部从A点到B点的路线，但是SwiftUI决定何时以及将哪种AnimatableData值传递给它。他用时间曲线来做到这一点。假设我们以A点为原点，并以B点为坐标（1; 1）。在水平方向上，我们将标记经过的时间（从A点到B点的运动恰好占用1个时间单位）。垂直-行进的距离，单位为分数。当使用线性动画时，我们可以直接使用。如果我们想使运动有点类似于现在，那么首先我们需要花一点时间在加速上，最后花些时间在刹车上。就</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以通过绘制自己的曲线并将其运动动画与标准曲线进行比较来使用不同的选项。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在SwiftUI中，贝塞尔曲线用于各种类型的动画。</font><font style="vertical-align: inherit;">无论如何，它都应从（0; 0）开始，到（1; 1）结束。</font><font style="vertical-align: inherit;">线的曲率由控制点确定。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线性无尽动画中的嵌套时序曲线</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那么，我们需要做些什么来实现线性循环动画中每个波（easeIn）的加速运动？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我能想到的最细分的选项是实现自己的时序曲线，并将线性的时间流转换为.easeIn。</font><font style="vertical-align: inherit;">通过此示例，您可以很好地理解其工作原理。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个想法很简单。我们将基于路径-贝塞尔曲线创建自己的类，通过该曲线我们将确定从A点到B点的距离，需要在每个特定时间点显示该距离。实际上，这正是动画在SwiftUI和任何其他具有类似功能的框架中的工作方式。借助时序曲线，将实际的秒和毫秒（尽管最常见的是线性流动的）转换为距离的分数（更准确地说，是动画片段的分数-AnimatableData矢量，它表示所做的更改）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是我的第一个实现：</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getActualPosition</span><span class="hljs-params">(of position: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-keyword">let</span> correctPosition = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">min</span>(position, <span class="hljs-number">1</span>), <span class="hljs-number">0</span>) / duration
        <span class="hljs-keyword">let</span> trimmingCurve = <span class="hljs-type">TimingCurve</span>.superEaseInPath
        <span class="hljs-keyword">if</span> correctPosition &lt; <span class="hljs-number">0.0000001</span>{
            <span class="hljs-keyword">let</span> reversedCurve = <span class="hljs-type">Path</span>(<span class="hljs-type">UIBezierPath</span>(cgPath: trimmingCurve.cgPath).reversing().cgPath)
            <span class="hljs-comment">//trim to start point is impossible, so reverce the curve and get last point</span>
            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = reversedCurve.currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve start point"</span>)}
            <span class="hljs-keyword">return</span> point.y<font></font>
        }<font></font>
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = trimmingCurve.trimmedPath(from: <span class="hljs-number">0</span>, to: correctPosition).currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve point at \(position)"</span>)}
        <span class="hljs-keyword">return</span> point.y * <span class="hljs-keyword">self</span>.duration<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
显然，我有点愚蠢。根据定义，我必须在曲线上找到一个与X的给定值相对应的点，然后将其返回给Y。我找不到任何标准的内置方法来解决此问题，也无法找到一种流行的模式，因此我决定将现有的修整方法用于这些目的（ ）我决定我可以很好地重新考虑该方法，并通过获取与行进距离的分数相对应的路径部分来获得所需的点。对于零，此方法将返回0，对于1，它将返回1，那么在中间，可能所有内容都将大致正确。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我知道这种方法不会给出非常准确的结果，但是，当我尝试以标准方式复制完全相同的动画时，问题的严重性浮出水面。我很惊讶它的不同之处，因此决定在图形上检查以这种方式获得的点距原始曲线有多远。结果不令我满意。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fl/ed/s-/fleds-cdj4f8ellnui32gn-kiyk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些点不仅远离所需曲线，而且曲线的本质也失真了。有一个额外的纽结，我根本不需要。结果，我仍然不得不想出一种相对准确的方法来在贝塞尔曲线上找到一个点，只知道一个坐标：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我必须在内存中存储许多段，这些段的末端位于给定的曲线上。用这种方法通过给定的X搜索Y就是搜索相应的段，如果需要的话，将其分成两半，直到该段的边界之一足够接近所需的点。在这种情况下，我们找到在该线段上具有所需X坐标的点，并将其返回Y。如果您知道使用给定的坐标在任意Bezier曲线上查找点的更简单方法，请在注释中输入。我认为这可能对许多人有用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，这些点非常接近图表：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/bk/qi/wxbkqitda0fmf516tl1vjarqgoq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我创建了一个singlton对象，以创建控制点的时序曲线并缓存要搜索Y的线段阵列，因此，我需要在曲线上找到特定点的方法是找到该点将位于其中的线段，并将其分成两半直到线段的末端之一足够靠近此点以落入给定的误差，然后沿线X沿给定的X线性内插Y的值，用该线段替换部分曲线。我并不是说这是最好的方法，并且在所有情况下都可以使用。同样，如果您知道更好的方法，请在评论中写下。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
借助于这样的工具，线性动画到非线性的转换变得简单。</font><font style="vertical-align: inherit;">所需要的只是通过两个控制点描述曲线，并根据该曲线重新计算线段上的位置。</font><font style="vertical-align: inherit;">如果需要制作各种持续时间的动画，我们仍将使用对X坐标使用适当系数的单位曲线。</font></font><br>
<br>
<pre><code class="swift hljs">        
<span class="hljs-keyword">self</span>.timing = <span class="hljs-type">TimingCurve</span>.superEaseIn(duration: <span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> animatedPosition = timing.getY(onX: currentPosition)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是动画的样子，以及我们的时序曲线：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vf/f0/fe/vff0fe07bgvlvqhhuok5vy_w8ga.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有关完整代码，欢迎来到</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，观看TimingCurveView文件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
了解了此示例之后，您将100％理解动画时间的安排方式。</font><font style="vertical-align: inherit;">顺便说一下，您可以利用这些知识，因为SwiftUI允许您使用TimingCurve（）函数为控制点创建自己的时序曲线，并像其他任何动画一样使用它。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过渡</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们有了可以忍受的无尽动画。剩下的只是弄清楚应该如何打开和关闭它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
动画外观的想法是使动画块仅出现在已经打开的位置上，但是窗帘会像在剧院中的窗帘一样从中拉回。如果我们将窗帘的速度与动画中的波速同步，并且在窗帘本身中从背景色到当前入射波的颜色进行渐变，我们将获得视觉效果，就好像该窗帘是第一个滚动波一样。为了使运动速度同步，我们只需使用与为波的运动设置动画相同的TimingCurve。幸运的是，我们现在知道如何执行此操作。</font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.timingCurve(<span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.y),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.y),<font></font>
                                duration: <span class="hljs-number">1</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animation.timingCurve（x：y :)允许您根据Bezier曲线的控制点设置自己的动画定时。</font><font style="vertical-align: inherit;">在输出中，我们获得了完整的Animation对象，例如熟悉的.linear（持续时间：1），可以不受限制地使用它。</font><font style="vertical-align: inherit;">考虑到我对波动画使用完全相同的控制点，动画将是同步的。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组织代码会更方便...</font></font></b>
                        <div class="spoiler_text">   .<br>
<br>
 ,           ,    ,          …     ,     ,     .  -  ,        —    .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
禁用动画的方法可以相同，只有窗帘应爬到动画块上，然后逐渐将其关闭。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我需要获取动画的当前状态以选择窗帘的颜色时，出现了第一个问题。</font><font style="vertical-align: inherit;">为此，我创建了一个ObservableObject，将其传递到修饰符内部，并将其在AnimatableData setter内部进行更改。</font><font style="vertical-align: inherit;">在这里必须了解，每秒更改@Published属性60次根本不是您所需要的。</font><font style="vertical-align: inherit;">这是更改</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主体块内变量的方法。</font><font style="vertical-align: inherit;">动画状态更改时，我们无需启动任何操作。</font><font style="vertical-align: inherit;">但是，如果需要，我们可以随时找出动画的状态。</font></font><br>
<br>
<pre><code class="swift hljs">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">if</span> animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.time = newValue
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.time != <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition{
                    <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition = <span class="hljs-keyword">self</span>.time<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)
            <span class="hljs-keyword">if</span> currentPosition &lt; <span class="hljs-number">0.01</span>{<font></font>
                animationHandler.currentWaveBaseColor = wave.baseColor<font></font>
            }<font></font>
        }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是为什么我没有注册SharpRainbowView来跟踪AnimationHendler更改的原因： </font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了说明这些窗帘的操作，我将通过注释掉.clipped（）来打开View外部正在发生的事情的显示。另外，为清楚起见，我将窗帘移到动画上方。现在更清楚了，不是吗？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/uf/0k/6suf0klfghhgxj95qfnrxd29zpe.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
窗帘必须很短，以便每个波浪和窗帘所经过的路径都重合（否则它将变成一个异步动画），但是与此同时，她设法从屏幕上完全消失了。同时，窗帘以三种颜色的渐变排列。这在关闭窗帘上清晰可见。这是因为一开始我非常喜欢长尾巴。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事实是，第一个波是传输阵列的最后一个和第一个颜色的渐变。它们均不能与背景色匹配。因此，总体上需要窗帘。为了使窗帘具有两个色调，从背景颜色到第一波的基色，窗帘的长度使我无法使用。它根本不与第一波的长尾巴重叠，并且获得了一种颜色的边界，而另一种颜色的尾巴得到了。因此，我必须将窗帘制成尽可能多的三色-首先是从背景到最后一波的颜色，然后是从最后一波的颜色到第一波。然后，第一波的尾巴与窗帘的边缘非常吻合。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出于相同的原因，他们也将关闭窗帘也设为三色。否则，边界看起来不自然。但是结果是，第一个“波浪”（现在我们知道这实际上是Transition.truncate中描述的帷幕）显得很短。尽管它与第一波完全同步移动，即尽管随后的波的宽度在视觉上有所增加，但它的宽度并没有随时间变化，而是加速且不是线性的。可以通过动态更改窗帘的宽度来克服这种情况，但坦率地说我很懒。对于那些想深入研究这些机制并抽出代码的人来说，这是一项家庭作业（我事先向这类人致歉，我的实验中有很多痕迹可能会使您感到困惑）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有一个问题。</font><font style="vertical-align: inherit;">如果在不成功的时间按下按钮，则关闭的窗帘将几乎无法遮盖下一波。</font><font style="vertical-align: inherit;">看起来不太好。</font><font style="vertical-align: inherit;">您可以通过在隐藏带有动画的视图时稍加延迟来解决该问题。</font><font style="vertical-align: inherit;">我们有一种方法可以找出动画的当前位置，我们只需要稍微推迟过渡的开始，最后一浪就将被完全显示出来。</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle animation"</span>).onTapGesture {<font></font>
                withAnimation(){<font></font>
                    <span class="hljs-keyword">var</span> delay: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.isShown{
                        <span class="hljs-keyword">let</span> waveChangeTime: <span class="hljs-type">Double</span> = <span class="hljs-type">Double</span>(<span class="hljs-number">1</span>) /  <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.rainbowColors.<span class="hljs-built_in">count</span>)
                        <span class="hljs-keyword">let</span> currentTime = <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition)
                        <span class="hljs-keyword">let</span> wavesPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(currentTime / waveChangeTime))<font></font>
                        delay =  (wavesPassed + <span class="hljs-number">1</span>) * waveChangeTime - currentTime<font></font>
                        delay = <span class="hljs-built_in">max</span>(delay - <span class="hljs-number">0.05</span>, <span class="hljs-number">0</span>)
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">"currentTime: \(currentTime); delay \(delay)"</span>)<font></font>
                    }<font></font>
                    <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + delay) {
                        <span class="hljs-keyword">self</span>.isShown.toggle()<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，您也可以制作可变宽度的窗帘，以产生背景和窗帘之间以及边框和第一波之间边界速度不同的错觉，但是现在第一波看起来有点不自然，但是我已经懒得打扰了。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过渡爱衬一头猪</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，对我而言，外观和消失的动画是非常酷的工具。但似乎这个概念是新概念，并非所有工具都能正常处理。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，.rotation3DEffect（）修饰符非常成功地反转了其中包含一些复杂动画的View，但它不知道如何反转.transition。编写简洁的代码，看到波如何从屏幕中心散射开，然后在左侧看到，真是令人失望。查看窗帘从左到右。我必须写一堆样板文件，以便transition修改器可以在两个方向上工作。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pn/3c/fg/pn3cfg8f6zsersnfgdv5_ixrqu8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，您无法连接过渡金属drowingGroup（）修饰符来将Metal连接到GPU，以将具有大量嵌套View（尤其是带有渐变的View）的ZStack渲染传输到GPU。</font><font style="vertical-align: inherit;">他不了解您描述的外观和消失的动画，并用自己的动画代替了它。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，我们如何隐藏状态栏？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
很简单。 SwiftUI具有.statisBar（隐藏：）修饰符。这只是SwiftUI不提供的用于控制状态栏过渡的api。为此，我们将不得不利用UIKit的功能。 SceneDelegate文件使用UIHostingController将SwiftUI视图变成UIKit ViewController。在此阶段，使用某些全局UIKit功能最为方便，例如使用状态栏或禁用与屏幕边缘关联的系统手势（preferredScreenEdgesDeferringSystemGestures）。您可以从UIHostingController继承，覆盖某些系统属性的值，然后使用此后代将View传递给rootViewController。不幸的是，只有有限数量的转换可以接受状态栏：.fade，.slide和.none。默认值为淡入淡出，它最适合这里，所以让它保持原样。我们希望该功能将继续得到扩展。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了使状态栏的隐藏和外观与wave的移动同步，我创建了一个单独的View，在其中使用暂停功能更改了此参数的值：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarHider</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isShown: <span class="hljs-type">Bool</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalIsShown = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">true</span>{
            <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="hljs-number">0.7</span>){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">false</span>{
            <span class="hljs-type">DispatchQueue</span>.main.async(){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-type">Spacer</span>()<font></font>
            .statusBar(hidden: internalIsShown)<font></font>
            .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0.3</span>))<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，这里已经形成了一个简单的Spacer（），我已经需要它了，但是statusBar修饰符缠绕在它的顶部。当然，总的来说，Apple将此功能输出到修饰符是不合逻辑的，因为这不适用于您要修改的特定视图，但是显然只是没有弄清楚如何做得更好。更有趣的是另一个。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它使用了我们之前考虑的相同技巧：在体内，我在运行时执行一些操作，同时更改</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">的值</font><font style="vertical-align: inherit;">。总体上来说，逻辑是相同的，有一个从外部传输的结构参数，还有一个</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在一段时间后被修改</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">变量，导致状态栏消失或出现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，我需要此技巧，因为控制状态栏动画是一种UIKit功能，而在SwiftUI中仍然开发得很差。</font><font style="vertical-align: inherit;">从理论上讲，我会将延迟的开始动画固定到.statusBar（hidden :)修饰符，但这不起作用。</font><font style="vertical-align: inherit;">隐藏动画和状态栏外观是固定的，不能由SwiftUI更改。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，没有什么可以阻止我以所需的延迟异步地进行相同的更改，而不是在此View内部，而是在父级中，即使用户单击了该按钮-还是让它作为我试图弄清楚是什么的纪念碑（还有一个理由来告诉我）则不应这样做）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态栏的大小和位置如何填充到@Environment中？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
@Environment（不要与@EnvironmentObject混淆）是一个包装器，它可以访问固定的变量列表，这些变量列表反映了我们应用程序的环境。例如，屏幕方向或OS颜色主题。相同的包装器允许您订阅视图以更改这些参数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此列表可以扩展。我认为拥有@Environment可以访问状态栏的大小和位置是正确的。这是我的做法：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarFrame</span>: <span class="hljs-title">EnvironmentKey</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> defaultValue: <span class="hljs-type">CGRect</span> {
        <span class="hljs-type">CGRect</span>()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">EnvironmentValues</span> </span>{
    <span class="hljs-keyword">var</span> statusBarFrame: <span class="hljs-type">CGRect</span>{
        <span class="hljs-keyword">get</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>]<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>] = newValue<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我创建了具有静态默认值的结构。</font><font style="vertical-align: inherit;">然后，我通过添加自己的计算属性来扩展SystemValues系统结构，该属性的getter和setter引用我创建的类型。</font><font style="vertical-align: inherit;">在这里使用类型，因为EnvironmentValues实现一个下标，您可以将类型传递给该下标并获取与此类型相对应的存储值。</font><font style="vertical-align: inherit;">不是此类型的值，而是存储在条件字典中的值，其中类型本身是键。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
@Environment中的值使用keyPath \ .statusBarFrame访问。</font><font style="vertical-align: inherit;">例如，要将环境值传递给层次结构中的所有视图：</font></font><br>
<br>
<pre><code class="swift hljs">.environment(\.statusBarFrame, statusBarFrame) 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并在View本身中从存储中检索值：</font></font><br>
<br>
<pre><code class="swift hljs">@<span class="hljs-type">Environment</span>(\.statusBarFrame) <span class="hljs-keyword">var</span> statusBarframe: <span class="hljs-type">CGRect</span> 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顺便说一句，为了使用IOS 13中UIWindowScene对象中的状态栏，已经出现了statusBarManager属性。</font><font style="vertical-align: inherit;">可以从中得出一些参数。</font><font style="vertical-align: inherit;">但是现在您无法管理它们。</font><font style="vertical-align: inherit;">据我了解，之前可以访问ViewController状态栏并为其添加一个子视图。</font><font style="vertical-align: inherit;">显然，他们关闭了长凳。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般来说，我将完全在这里转移.statusBar（hidden :)修饰符的功能，这里对我来说更合适。</font><font style="vertical-align: inherit;">我认为开发人员迟早会达到这一点。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，我认为在这个引人入胜的示例中，可以认为使用SwiftUI工具进行Animation之旅是完整的。通过简单的示例，我讨论了主要的动画工具，并告诉了它们在引擎盖下的工作方式，应如何使用以及为什么要使用它们。通过使用更复杂的示例，我展示了您可能遇到的典型困难以及克服这些困难的方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与上一篇文章的示例相比，我的代码是否更干净，更清晰，更短，或者更易于维护？也许不是。它消耗更少的资源吗？ las，不。也许我的方法更通用，但这并不准确。但是，有一项任务他肯定表现更好。它更深入地说明了SwiftUI的幕后操作。有了它，您可以将动画放在头上的架子上，然后将其自由地应用到您的应用程序中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUI积极活跃。</font><font style="vertical-align: inherit;">即使是现在，在为第一篇文章编写代码两周之后，现在，检查当前版本的Xcode上的代码，我仍然看到如何解决一些我必须规避的错误。</font><font style="vertical-align: inherit;">因此，我对这篇文章保留了一些意见。</font><font style="vertical-align: inherit;">为了不相关，必须删减某些内容，并进行其他检查-再次检查。</font><font style="vertical-align: inherit;">而且很高兴。</font><font style="vertical-align: inherit;">SwiftUI绝对是原生iOS开发的未来，站在它的起源并观察它的发展方式方面非常有帮助。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">后记</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在准备本文的材料的过程中，我还在脑海中投入了很多东西。</font><font style="vertical-align: inherit;">我发现很多细微之处，甚至在刚开始编写时都不知道。</font><font style="vertical-align: inherit;">因此，我敦促每个已经有SwiftUI开发经验的人-不要害羞，分享您的经验和知识。</font><font style="vertical-align: inherit;">这对于社区和您自己知识的完整性都是非常有用的。</font><font style="vertical-align: inherit;">这比</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小鸭方法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要凉爽</font><font style="vertical-align: inherit;">，而且还需要制定答案。</font><font style="vertical-align: inherit;">最主要的是不要懒惰地寻找这样的答案，以免</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">男孩子露面</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN506644/index.html">远程工作中的经理面临的新挑战。第2部分</a></li>
<li><a href="../zh-CN506648/index.html">Laravel Digest（2020年6月8日至14日）</a></li>
<li><a href="../zh-CN506662/index.html">二阶和三阶Bezier曲线的自适应划分</a></li>
<li><a href="../zh-CN506664/index.html">上周第419期（2020年6月8日至14日）从前端世界中提取的新鲜材料的摘要</a></li>
<li><a href="../zh-CN506666/index.html">ORM纹理，但这值得吗？</a></li>
<li><a href="../zh-CN506676/index.html">卡塔尔：世界移植和夜城中心</a></li>
<li><a href="../zh-CN506680/index.html">.NET Core与Node.js 论点与事实</a></li>
<li><a href="../zh-CN506684/index.html">我如何将dedic.ru转移到github页面并感到满意</a></li>
<li><a href="../zh-CN506686/index.html">6月15日至21日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN506688/index.html">6月15日至21日在圣彼得堡举行的数字活动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>