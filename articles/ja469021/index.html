<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛎️ 👩🏿‍🤝‍👨🏻 🏛️ 単一リポジトリでの開発。Yandexレポート 🤴🏻 💖 👵🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私の名前はAzat Razetdinovです。Yandexに12年間勤務し、Y。Real Estateでインターフェース開発サービスを管理しています。今日は、単一リポジトリについてお話ししたいと思います。作業中のリポジトリが1つしかない場合-おめでとうございます。すでに1つのリポジトリに住んでいます...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>単一リポジトリでの開発。Yandexレポート</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/469021/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私の名前はAzat Razetdinovです。Yandexに12年間勤務し、Y。Real Estateでインターフェース開発サービスを管理しています。</font><font style="vertical-align: inherit;">今日は、単一リポジトリについてお話ししたいと思います。</font><font style="vertical-align: inherit;">作業中のリポジトリが1つしかない場合-おめでとうございます。すでに1つのリポジトリに住んでいます。</font><font style="vertical-align: inherit;">なぜ他の人がそれを必要とするのかについて。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/v_/vr/gi/v_vrgiiye4emmloccesmmogxlim.jpeg"></a><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex.Map API開発サービスの責任者であるマリーナペレスココバによれば、祖父はモノレパを植えました。モノレパは大きく、大きくなりました。</font></font></blockquote><br>
<a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-私たちYandexは、いくつかのサービスを使用してさまざまな方法を試してみましたが、複数のサービスがあるとすぐに、必然的に一般的なパーツ（モデル、ユーティリティ、ツール、コードの一部、テンプレート、コンポーネント）が現れ始めます。</font><font style="vertical-align: inherit;">問題は、これらすべてをどこに置くかです。</font><font style="vertical-align: inherit;">もちろん、コピーして貼り付けることもできますが、私たちはそれを行うことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
覚えている人のために、SVN外部のようなエンティティも試しました。 gitサブモジュールを試しました。彼らが現れたとき、私たちはnpmパッケージを試しました。しかし、これはすべて、どういうわけか長い、または何かでした。すべてのパッケージをサポートし、エラーを見つけ、修正します。次に、新しいバージョンをリリースし、サービスを通過し、このバージョンにアップグレードし、すべてが機能することを確認し、テストを実行し、エラーを見つけ、ライブラリリポジトリに戻り、エラーを修正し、新しいバージョンをリリースし、サービスを通過し、アップデートなどを行う必要があります。サークル。ただ痛みに変わっただけです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rq/ie/uo/rqieuoverzzoq6wrhpujf4qz8vw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、1つのリポジトリにまとめるかどうかを検討しました。すべてのサービスとライブラリを利用して、1つのリポジトリで転送および開発します。多くの利点がありました。このアプローチが理想的であると言っているわけではありませんが、会社の観点といくつかのグループの部門でさえ、大きな利点が現れます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私にとって個人的に最も重要なことは、コミットのアトミック性です。開発者として、1つのコミットでライブラリを修正し、すべてのサービスをバイパスし、変更を加え、テストを実行し、すべてが機能することを確認し、それをマスターにプッシュし、1つの変更ですべてを実行できます。何も再構築、公開、更新する必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、すべてがとても良ければ、なぜ誰もがまだ単一リポジトリーに移行していないのでしょうか。もちろん、それには欠点もあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bb/1u/pv/bb1upvyscjzd_csjkvxce0yh9a0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex.Mart API開発サービスの責任者であるマリーナペレスココバが言ったように、祖父はモノレパを植え、モノレパは大きく、大きくなりました。これは事実であり、冗談ではありません。 1つのリポジトリに多数のサービスを収集すると、必然的に大きくなります。そして、私たちがgitについて話している場合、これはすべてのファイルに加えて、コードの存在全体の履歴全体を引き出すので、これはかなり大きなディスク領域です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の問題は、マスターへの注入です。プールリクエストを準備し、レビューを行い、それをマージする準備ができました。そして、誰かがなんとか先を行って、あなたは衝突を解決する必要があることがわかりました。あなたは衝突を解決し、再び注ぐ準備ができました、そしてまたあなたには時間がありませんでした。この問題は解決中です。マージキューシステムがあり、特別なロボットがこの作業を自動化し、プールリクエストをキューに配置し、可能であれば競合の解決を試みます。できない場合は、作者に連絡します。しかし、そのような問題が存在します。それを平準化する解決策がありますが、あなたはそれを覚えておく必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは技術的なポイントですが、組織的なものもあります。複数の異なるサービスを提供する複数のチームがあるとします。彼らが単一のリポジトリに移動すると、彼らの責任は侵食され始めます。彼らがリリースしたため、本番環境で公開された-何かが壊れた。報告を始めます。それは共通のコードに何かをコミットした別のチームの開発者であることがわかりました、私たちはそれをプルし、リリースしませんでした、見ませんでした、すべてが壊れました。そして、誰が責任を負うかは明らかではない。単体テスト、統合テスト、リンター-他のすべてのサービスに対する1つのコードの影響のこの問題を軽減するために可能なすべての方法を理解し、使用することが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味深いことに、Yandexや他のプレイヤー以外に誰がモノリポジトリを使用していますか？かなりたくさんの人。これらは、React、Jest、Babel、Ember、Meteor、Angularです。人々は理解しています-単一のリポジトリから複数の小さなリポジトリよりもnpmパッケージを開発して公開する方が簡単、安価、高速です。最も興味深いのは、このプロセスとともに、単一リポジトリを操作するためのツールが開発され始めたことです。ちょうどそれらについて、私は話をしたいと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべては、単一リポジトリーの作成から始まります。このための世界で最も有名なフロントエンドツールは、lernaと呼ばれます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2a/n9/my/2an9myv3k_dokzcizjfhshporh0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リポジトリを開いてnpx lerna initを実行するだけで、示唆的な質問がいくつか表示され、作業コピーにいくつかのエンティティが追加されます。最初のエンティティはlerna.json構成で、少なくとも2つのフィールドを示します。すべてのパッケージのエンドツーエンドバージョンと、ファイルシステム内のパッケージの場所です。デフォルトでは、すべてのパッケージがpackagesフォルダーに追加されますが、これは好きなように構成できます。ルートに追加することもできます。lernaはそれを取得することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のステップは、リポジトリをモノリポジトリに追加する方法、それらを転送する方法ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何を達成したいですか？ほとんどの場合、すでに何らかのリポジトリ、この場合はAとBがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/yl/d0/gdyld0xwsgytno9mhaz7g-t-ikc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは2つのサービスで、それぞれが独自のリポジトリにあります。できればcommitの履歴を付けて、パッケージフォルダー内の新しいモノリポジトリに転送します。これにより、git blameやgit logなどを作成できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rd/td/z1/rdtdz1-3hqxrjvgsgf4tb4wq5fy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このためのlernaインポートツールがあります。リポジトリの場所を指定するだけで、lernaはそれをmonorepoに転送します。同時に、彼女はまず、すべてのコミットのリストを取得し、各コミットを変更して、ファイルへのパスをルートからpackages / package_nameに変更し、それらを次々に適用して、それらをモノリポジトリに適用します。実際、各コミットは準備を行い、その中のファイルパスを変更します。基本的に、lernaはgit magicを実行します。ソースコードを読むと、gitコマンドが特定の順序で実行されるだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが最初の方法です。それには欠点があります：生産プロセスがあり、人々がすでにある種のコードを書いている会社で働いていて、それらをモノレップに翻訳しようとしているなら、あなたは一日でそれをすることはほとんどありません。すべてを開始し、テストして、把握し、構成し、検証する必要があります。しかし、人々には仕事がなく、何かを続けています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/u5/w4/je/u5w4jenpjqspns44ok1grkidxug.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モノラップへのスムーズな移行のために、git subtreeなどのツールがあります。これはより洗練されたものですが、同時にgitのネイティブです。これにより、個々のリポジトリをある種の接頭辞によって単一のリポジトリにインポートできるだけでなく、変更を相互に交換することもできます。つまり、サービスを作成するチームは、独自のリポジトリでさらに簡単に開発できますが、gitサブツリーのプルで変更をプルし、独自の変更を加えて、gitサブツリーのプッシュでプッシュすることができます。そして、あなたが好きな限り、移行期間にこのように生きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、すべてをセットアップし、すべてのテストが実行されていること、デプロイが機能していること、CI / CD全体が構成されていることを確認したら、次に進む準備ができたと言えます。移行期間については、素晴らしい解決策をお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、私たちはリポジトリを1つの単一リポジトリに移動しましたが、魔法はどこにあるのでしょうか？しかし、私たちは共通部分を強調して、どういうわけかそれらを使用したいと思います。このため、「依存関係をバインドする」メカニズムがあります。依存関係バインディングとは何ですか？ lernaブートストラップツールがあります。これはnpm installに似たコマンドで、すべてのパッケージでnpm installを実行するだけです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kh/tg/cw/khtgcwjnzf2kjxoy61wgmkevopo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、それだけではありません。さらに、彼女は内部の依存関係を探しています。リポジトリ内の1つのパッケージで別のパッケージを使用できます。たとえば、この場合、Jestに依存するパッケージAがある場合、JestとパッケージAに依存するパッケージBがあります。パッケージAが共通ツール、共通コンポーネントである場合、パッケージBはそれを持つサービスです。使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lernaはそのような内部依存関係を定義し、この依存関係をファイルシステム上のシンボリックリンクに物理的に置き換えます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/or/lk/am/orlkampii1gcc_kxupnpc5k-hxy.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/ia/dp/oo/iadpoole-lvonlr_o30aqvbc8no.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
物理フォルダーAではなく、node_modulesフォルダー内にあるlernaブートストラップを実行すると、パッケージAのフォルダーにつながるシンボリックリンクが表示されます。パッケージA内のコードを編集し、パッケージBの結果をすぐに確認できるため、これは非常に便利です、テスト、統合、ユニットなど、好きなように実行します。開発が大幅に簡素化され、パッケージAを再ビルドして発行し、パッケージBを接続する必要がなくなりました。ここで修正し、チェックしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
node_modulesフォルダーを見て、そこにjestがある場合は、インストールされたモジュールが複製されていることに注意してください。一般に、lernaブートストラップを開始し、すべてが停止するまで待機するのは非常に長い時間です。あらゆる種類の繰り返し作業が多数あるため、各パッケージで重複した依存関係が取得されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
依存関係のインストールを高速化するために、依存関係を発生させるメカニズムが使用されます。考え方は非常に簡単です。ルートnode_modulesへの一般的な依存関係を取得できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/so/lj/kr/soljkrixddhlkrth4w95b1bk5ek.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
--hoistオプションを指定した場合（これは英語からのアップグレードです）、ほとんどすべての依存関係は単にルートnode_modulesに移動します。そして、それはほとんど常に機能します。野田は、彼女が自分のレベルで依存関係を見つけられなかった場合、1つ上のレベルを検索し始めます。見つからない場合は、さらに高いレベルなどを検索します。ほとんど何も変わりません。しかし実際には、依存関係を取得して重複排除し、依存関係をルートに転送しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、lernaは十分に賢いです。競合がある場合、たとえば、パッケージAがJestバージョン1を使用し、パッケージBがバージョン2を使用した場合、そのうちの1つがポップアップし、2つ目はそのレベルのままになります。これは、npmが通常のnode_modulesフォルダー内で実際に行っていることとほぼ同じです。また、依存関係を重複排除し、最大限にそれらをルートに転送しようとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、この魔法は、特にツール、バベル、ジェストで常に機能するとは限りません。 Jestはモジュールを解決するための独自のシステムを持っているため、彼が開始することがよくあります。野田は遅れ始め、エラーをスローします。特に、ルートに移動した依存関係にツールが対応しないような場合には、nohoistオプションがあり、これらのパッケージがルートに転送されないことを指摘して、そのままにしておくことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2z/sx/9z/2zsx9zvtkofxy_2uk4au8x1uxbu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
--nohoist = jestを指定すると、jestを除くすべての依存関係がルートに移動し、jestはパケットレベルのままになります。何のためにも私はそのような例を挙げませんでした-この振る舞いに問題があるのは冗談であり、nohoistがこれを手助けします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
依存関係の回復の他のプラス：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yp/1n/ur/yp1nurrr-zokokzjy7rgzvmozzi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その前に、サービスごと、パッケージごとに個別のpackage-lock.jsonがあった場合、夢中になったとき、すべてが上に移動し、唯一のpackage-lock.jsonが残ります。これは、マスターに注ぎ込み、競合を解決するという観点からは便利です。誰もが殺されたら、それだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、lernaはこれをどのように達成しますか？彼女はnpmにかなり積極的です。ホイストを指定すると、package.jsonをルートに取り、バックアップし、別のものに置き換え、すべての依存関係をそれに集約し、npm installを実行します。ほとんどすべてがルートに置かれます。次に、この一時的なpackage.jsonがあなたのものを削除、復元します。その後、npmを使用してコマンドを実行した場合（npm removeなど）、npmは何が起こったかを理解できません。なぜすべての依存関係が突然ルートに現れたのでしょうか。 Lernaは抽象化のレベルに違反し、彼女は自分のレベルの下にあるツールにクロールします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヤーンの人たちはこの問題に最初に気づき、言った：私たちが苦しんでいることは、私たちがあなたのためにすべてをネイティブにして、箱から出してすべてがうまくいくようにしましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4l/0q/yb/4l0qybezxp0nwi_fulfgleb11oe.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yarnはすでに同じことを箱から出してすぐに行うことができます。依存関係を結びます。パッケージBがパッケージAに依存していることがわかった場合、無料でシンボリックリンクを作成します。</font><font style="vertical-align: inherit;">彼は依存関係を上げる方法を知っています。デフォルトでそれを行い、すべてがルートに追加されます。</font><font style="vertical-align: inherit;">lernaと同様に、リポジトリのルートに唯一のyarn.lockを残すことができます。</font><font style="vertical-align: inherit;">他のすべての人は、もはや必要ありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wj/bu/e7/wjbue7nf67iucirzohdpfxk75xe.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様の方法で構成されます。</font><font style="vertical-align: inherit;">残念ながら、yarnはすべての設定がpackage.jsonに追加されることを前提としています。ツールのすべての設定をそこから取り除こうとする人がいることを知っています。</font><font style="vertical-align: inherit;">残念ながら、yarnはこれを別のファイルで指定することをまだ学習していません。package.jsonのみです。</font><font style="vertical-align: inherit;">新しいオプションと必須のオプションの2つがあります。</font><font style="vertical-align: inherit;">ルートリポジトリは公開されないことが想定されているため、yarnでprivate = trueを指定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ワークスペースの設定は同じキーに保存されます。</font><font style="vertical-align: inherit;">設定はlerna設定と非常によく似ています。パッケージの場所を指定するpackagesフィールドがあり、lernaのnohoistオプションと非常によく似たnohoistオプションがあります。</font><font style="vertical-align: inherit;">これらの設定を指定するだけで、lernaと同じ構造になります。</font><font style="vertical-align: inherit;">すべての一般的な依存関係はルートに行き、nohoistキーで指定された依存関係はそれらのレベルのままでした。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6w/rj/8c/6wrj8cm-b68sgcbsm0gstgmwzm8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最良の部分は、lernaが糸を使用してその設定を取得できることです。</font><font style="vertical-align: inherit;">lerna.jsonで2つのフィールドを指定するだけで十分です。lernaは、yarnを使用していることをすぐに理解し、package.jsonに移動して、そこからすべての設定を取得して操作します。</font><font style="vertical-align: inherit;">これらの2つのツールはすでに相互に認識しており、連携して動作します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/q5/hs/em/q5hsemi5za3meeg_s7zjj0sak4g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの大企業が単一リポジトリを使用しているのに、なぜnpmでサポートが行われていないのですか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h1/al/n6/h1aln6qeuati1bbhmojwgtao1xo.jpeg"><br>
<h5><sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スライドからリンク</font></font></a></sub></sup></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らはすべてがそうなるだろうと言いますが、第7版では。</font><font style="vertical-align: inherit;">7番目の基本的なサポート、拡張-8番目。</font><font style="vertical-align: inherit;">この投稿は1か月前にリリースされましたが、7番目のnpmがリリースされる日付はまだ不明です。</font><font style="vertical-align: inherit;">やっと糸に追いつくのを待っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つの単一リポジトリーに複数のサービスがある場合、コマンドを実行せずに、各フォルダーに移動しないようにサービスを管理する方法に関する疑問が必ず生じます。</font><font style="vertical-align: inherit;">これには大規模な操作があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8f/9z/lk/8f9zlkf-hdow1itwrmkiczqm5pk.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/ux/z_/ed/uxz_edv1rkl4bjlydo8q8pndty8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yarnには、ヤーンワークスペースコマンドがあり、その後にパッケージの名前とコマンドの名前が続きます。ボックスからの糸はnpmとは異なり、独自のコマンドを実行する、jestへの依存関係を追加する、testのようにpackage.jsonからスクリプトを実行する、node_modules / .binフォルダーから実行可能ファイルを実行するなど、3つのことすべてを実行できます。彼は、ヒューリスティックスの助けを借りて、あなたが何を望んでいるかを理解するように教えてくれます。 1つのパッケージでポイント操作を行うには、yarnワークスペースを使用すると非常に便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有しているすべてのパッケージでコマンドを実行できる同様のコマンドがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-e/yn/vd/-eynvdikhrjyxn0we1fkw0loqcw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての引数を使用してコマンドを単純に示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qk/_t/lx/qk_tlxutn7it2owurvm5ne444o8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロの立場からすると、さまざまなチームを運営することは非常に便利です。たとえば、マイナスについては、シェルコマンドを実行することは不可能です。すべてのノードモジュールフォルダーを削除したいとしますが、rmを実行してyarn workspaceを実行することはできません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パッケージのリストを指定することはできません。たとえば、2つだけのパッケージ、一度に1つだけ、または個別に依存関係を削除したいとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、彼は最初のミスでクラッシュします。すべてのパッケージから依存関係を削除したい場合-そして実際には2つだけがそれを持っていますが、それがどこにあるのかを考えたくはありませんが、それを削除したいだけの場合-糸はそれを許可せず、最初の状況でクラッシュしますこのパッケージは依存関係にありません。これはあまり便利ではありません。時には、エラーを無視してすべてのパッケージを実行したい場合があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gv/bj/ax/gvbjax1gepdak6jwcxpf7q9u8ea.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lernaにはもっと興味深いツールキットがあり、2つのrunコマンドとexecコマンドがあります。 runはpackage.jsonからスクリプトを実行できます。yarnとは異なり、パッケージですべてをフィルターできます。--scopeを指定できます。アスタリスク、グロブを使用でき、すべてが非常に普遍的です。これらの操作は並行して実行でき、-no-bailスイッチを使用してエラーを無視できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j9/f_/km/j9f_kmpn1tkhfr88nsjykrunm5g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行は非常に似ています。ヤーンとは異なり、node_modules.binから実行可能ファイルを実行できるだけでなく、任意のシェルコマンドを実行できます。たとえば、node_modulesを削除したり、makeを実行したりできます。また、同じオプションがサポートされています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t4/f4/tv/t4f4tv2z0646cgezhzwamag6qgm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非常に便利なツール、いくつかのプラス。これは、レルナが糸を引き裂く場合であり、抽象化の適切なレベルにあります。これはまさにlernaが必要とするものです。monorep内のいくつかのパッケージで作業を簡素化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
monorepsでは、もう1つマイナスがあります。 CI / CDがある場合、それを最適化することはできません。サービスが多いほど、時間がかかります。プール要求ごとにすべてのサービスのテストを開始し、その数が多いほど、作業に時間がかかると想定します。選択操作を使用して、このプロセスを最適化できます。 3つの方法を挙げます。最初の2つは、monorepだけでなく、何らかの理由でこれらのメソッドを使用しない場合でもプロジェクトで使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つ目はlint-stagesです。これにより、変更またはこのコミットでコミットされるファイルに対してのみ、リンター、テスト、必要なすべてを実行できます。プロジェクト全体ではなく、変更されたファイルに対してのみlint全体を実行します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7v/qj/4z/7vqj4zxxvjc3fyt_bs5nfbk85nc.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/dx/if/eu/dxifeu43kvhxy7kthspwefr2o8m.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セットアップはとても簡単です。 lint-staged、husky、pre-commit-hooksを置き、js-fileを変更するときはeslintを実行する必要があると言います。したがって、プリコミット検証が大幅に高速化されます。特に、多くのサービスがある場合、非常に大規模な単一リポジトリー。次に、すべてのファイルでeslintを実行するとコストがかかりすぎます。このようにして、lintのプリコミットフックを最適化できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/x9/n7/dg/x9n7dgdih-y-zepifpkfd9czys8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jestでテストを作成する場合は、テストを選択的に実行するためのツールも含まれています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/fp/op/gdfpopeopfjlht4excpli5ec0d8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このオプションを使用すると、ソースファイルのリストを提供し、何らかの方法でこれらのファイルに影響を与えるすべてのテストを見つけることができます。 lint-stagedと組み合わせて何を使用できますか？ここで、すべてのjsファイルを指定するのではなく、ソースのみを指定していることに注意してください。内部のテストでjs-files自体を除外し、ソースのみを調べます。 findRelatedTestsを開始し、必要に応じて、ユニットの実行を大幅に高速化してプリコミットまたはプリプッシュします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目の方法は、モノリポジトリに関連付けられています。これはlernaであり、ベースコミットと比較して変更されたパッケージを判別できます。ここでは、フックについてではなく、CI / CD：Travisまたは使用する別のサービスについての可能性が高いです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bn/is/ij/bnisijuykjzbkbi6-mhd19lwvmq.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/ul/d4/u2/uld4u2saou9lwemuj2ky4usffyu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
runコマンドとexecコマンドにはsinceオプションがあり、何らかのコミット以降に変更されたパッケージでのみコマンドを実行できます。単純なケースでは、ウィザードにすべてを注ぐことでウィザードを指定できます。より正確にしたい場合は、CI / CDツールを使用してプールリクエストのベースコミットを指定することをお勧めします。これは、より正直なテストになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lernaはパッケージ内のすべての依存関係を知っているため、間接的な依存関係も検出できます。サービスCで使用されるライブラリBで使用されるライブラリAを変更すると、lernaはこれを理解します。ライブラリAのコードを変更するとします。次に、たとえば、作成した統合テストを使用して、パッケージCをテストする必要があると推移的に判断します。そしてlernaはパッケージCでこのコマンドを実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
役立つリンクは次の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とおり</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">。lernaWebサイト</font></a><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">糸のワークスペースに関する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推奨</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事項、原則として単一リポジトリの賛否両論の</font><font style="vertical-align: inherit;">理論的な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モノリポジトリを愛する人がいます。マルチリポジトリを愛する人がいます。常に妥協の問題があります。どちらが簡単ですか？個人で作業するチームは独立して作業する傾向があると私は自分で判断しました。独立性が高ければ高いほど、チームは幸福になるからです。しかし、誰もが独立して独立している部門や小さな会社のトップのレベルに上がったとしましょう。その後、各チームが別々に行ういくつかのことのために、会社は負け始めます。新しいバージョンのBabelにアップグレードする必要があるとしましょう。各チームは、そこで何が変更されたか、コードで何を変更する必要があるかを個別に理解します。そして起業家や部門長は、5つの異なる場所で同じ活動に会社のリソースを費やしています。単一リポジトリになると、次に、この一般的なアクティビティをブラケットから外して、リソースを節約できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の同僚に感謝したい：ミシャ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ミシャンガ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トロシェフとゴーシャベセディン。</font><font style="vertical-align: inherit;">彼らは私たちが今日レビューしたツールの研究にかなりの時間を費やし、彼らの経験と知識を共有しました。</font><font style="vertical-align: inherit;">これで全部です、ありがとう。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja469007/index.html">RubyRussia2019。代数効果に関するNikita Shilnikov</a></li>
<li><a href="../ja469009/index.html">ソフトウェア開発における貨物カルト</a></li>
<li><a href="../ja469011/index.html">USB Type-Cに関する11の神話</a></li>
<li><a href="../ja469015/index.html">スラム：モスクワはKubernetesおよび他の発表によって集中しました</a></li>
<li><a href="../ja469019/index.html">SPA Meetup 5：JestのQAとの統合、強力なUIKit、コンポーネントライブラリ、スケーリング用DI、プラットフォームコマンド</a></li>
<li><a href="../ja469023/index.html">ヨーロッパへの移転を伴う仕事を見つける方法：ITプロフェッショナルのための実践的なガイド</a></li>
<li><a href="../ja469025/index.html">ワインを素早く冷やす！ロシアの発明</a></li>
<li><a href="../ja469027/index.html">イヴァノヴォ！ミタップ：デジタルでキャリアを築くには？</a></li>
<li><a href="../ja469031/index.html">12の新しいAzure Media Services人工知能</a></li>
<li><a href="../ja469033/index.html">ElbrusでのPuzzleLibニューラルネットワークプラットフォームの立ち上げ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>