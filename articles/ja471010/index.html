<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏿 🖖🏼 📚 Groverアルゴリズムとデータ検索 ♣️ 👆🏽 🌳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、habrozhiteli！最近、Chris Bernhardの本「Quantum Computing for Real IT」を手に入れました。ここでは、「グローバーのアルゴリズムとデータ検索」という本の抜粋を共有することにし、
 
 ビッグデータの時代に突入しています。巨大なデータセッ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Groverアルゴリズムとデータ検索</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/471010/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/webt/xu/vp/8q/xuvp8q2m4cv20akrl-tdi11e650.png" alt="画像"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
こんにちは、habrozhiteli！</font><font style="vertical-align: inherit;">最近、Chris Bernhardの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本「Quantum Computing for Real IT」を手に入れました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ここでは、「グローバーのアルゴリズムとデータ検索」という本の抜粋を共有することにし、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビッグデータの時代に突入しています。</font><font style="vertical-align: inherit;">巨大なデータセットを効率的に検索することは、現在多くの大企業にとって燃えている懸念事項です。</font><font style="vertical-align: inherit;">Groverのアルゴリズムは、理論的にはデータ検索を高速化できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Love Groverは、1996年に彼のアルゴリズムを発明しました。</font><font style="vertical-align: inherit;">DeutschとSimonのアルゴリズムと同様に、クエリの複雑さの点で、従来のアルゴリズムと比較して実行速度が高速です。</font><font style="vertical-align: inherit;">ただし、現在のデータ取得アルゴリズムを実装するには、質問をするオラクルが必要です。</font><font style="vertical-align: inherit;">私たちは神託の仕事を実行するアルゴリズムを構築しなければなりません。</font><font style="vertical-align: inherit;">ただし、Groverアルゴリズムの実装について説明する前に、Groverアルゴリズムが何をどのように実行するかを見てみましょう。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバーアルゴリズム</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トランプが4枚あるとします。彼らはシャツになっています。あなたはそれらの1つがワームのエースであり、それを見つける必要があることを知っています。ハートのエースがどこにあるかがわかるまで、何枚のカードをめくる必要がありますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
運が良ければ、最初の試行で目的のカードを見つけることができます。運が悪ければ、3枚のカードを反転させることができますが、そのうちの1枚はワームのエースにはなりません。最悪の場合、3枚のカードをめくると、最後のカードが探しているワームのエースであることが確実にわかります。つまり、1枚から3枚のカードを裏返すことで、エースがどこにあるかを知ることができます。平均すると、2.25枚のカードをめくる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、グローバーのアルゴリズムが解決するタスクの1つです。アルゴリズムの説明を始める前に、問題を再定式化します。 4つのバイナリシーケンス、00、01、10、11があります。これらのシーケンスの3つに対して0を返し、4番目のシーケンスに対して1を返す関数fがあります。出力値1に対応するバイナリシーケンスを見つける必要があります。たとえば、次の結果を得ることができます：f（00）= 0、f（01）= 0、f（10）= 1およびf（11）=0。今問題は結果f（10）= 1を取得するために関数を計算する必要がある回数を調べることです。ここでは、トランプを関数に置き換えることで問題を再定式化しました。したがって、この質問に対する答えはすでにわかっています。以前と同様に、平均して関数を計算する必要があります。 2.25回。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての複雑なクエリアルゴリズムと同様に、オラクル（関数をカプセル化するゲート）を構築します。</font><font style="vertical-align: inherit;">バイナリシーケンスが4つしかないこの例のオラクルを図4に示します。</font><font style="vertical-align: inherit;">9.1。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Groverアルゴリズムのチェーンを図4に示します。</font><font style="vertical-align: inherit;">9.2。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムは2つのステップを実行します。</font><font style="vertical-align: inherit;">最初に、確率振幅の符号が反転し、検索しようとしている場所に関連付けられます。</font><font style="vertical-align: inherit;">2番目は、この確率の振幅を補強します。</font><font style="vertical-align: inherit;">チェーンがこれを行う方法を見てみましょう。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/n_/0g/gy/n_0ggyb6_pma_97-qs66mvt-kri.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アダマールバルブを介した伝送後、2つの上部キュービットは状態を取得します</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mn/x8/l-/mnx8l-are9pmkr7vhqgei894uca.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、より低いキュビットは状態を持っています</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yt/av/sf/ytavsf_fwicnuaick1ix2wenkoo.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結合された状態は次のように書くことができます</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/yd/-q/ybyd-qncd1qely0j24fm1gaovtq.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、キュビットはゲートFを通過します。3番目のキュビットの0と1を、見つけようとしている位置に反転させます。</font><font style="vertical-align: inherit;">この場合、f（10）= 1が得られます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rb/oe/rq/rboerqt-qdwrzyq3iwr6ytvrj18.png" alt="画像"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のように書き直すことができます</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rl/eo/ih/rleoihdnyso6gcvgiig9unrahqu.png" alt="画像"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、2つの上位量子ビットが得られ、下位ビットと混同されることはありませんが、確率振幅は</font></font><img src="https://habrastorage.org/webt/s4/yi/2c/s4yi2ctlx8zymvvj02ush4y6tz4.png" alt="画像"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">符号</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">変更し、目的の場所を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このステップで上位2つのキュービットを測定すると、4つの位置の1つが得られますが、考えられる4つの答えはすべて同じ確率です。確率の振幅を増やすために、もう1つのステップを実行する必要があります。増幅は、数値のシーケンスをそれらの平均に対して逆にすることによって実行されます。数値が平均を超えている場合は、反転して平均を下回ります。数値が平均を下回っている場合は、反転して平均を上回ります。いずれの場合も、平均からの距離は維持されます。説明のために、1、1、1、および–1の4つの数値を使用します。それらの合計は2で、平均は2/4、つまり1/2です。次に、シーケンスの番号を並べ替えます。最初の数値は1です。これは、平均の1/2です。クーデター後、それは平均よりも1/2低いはずです。この場合、0になります。数値–1は、平均より3/2低くなります。クーデター後、それは平均値の3/2になる、つまり2になるはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの上位キュービットには現在状態があります</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mi/eb/zx/miebzxscvcaw8r6hdj3oudogmsk.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
平均に対して振幅を回すと、が得られ</font></font><img src="https://habrastorage.org/webt/vc/3k/hv/vc3khv7pp6csf5n9u4skjqz5rfq.png" alt="画像"> <img src="https://habrastorage.org/webt/7f/tt/7z/7ftt7zqz5rtqjb7qebqxblbamyc.png" alt="画像"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
測定が完了すると、確実に10が得られます。つまり、平均に対する革命により、必要なものが正確に得られます。</font><font style="vertical-align: inherit;">私たちがしなければならないことは、ゲートが存在すること、または平均と比較して回転を表す直交行列があることを確認することだけです。</font><font style="vertical-align: inherit;">そのようなマトリックスが存在します：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/3b/wm/lq/3bwmlqywrtg8jv3pknydbbzagh0.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上部の2つのキュビットに対するバルブの作用の結果、</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/1y/oq/ly/1yoqlylytnhsdqrjiqfaf04zyqs.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、キュービットが2つしかないため、oracleを1回だけ使用する必要があります。</font><font style="vertical-align: inherit;">唯一の質問をするだけで十分です。</font><font style="vertical-align: inherit;">n = 2の場合、Groverアルゴリズムは単一の質問の後に正確な回答を提供しますが、古典的な場合、平均して2.25の質問をする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この考え方は、任意の数のnキュビットの場合にまで及びます。まず、希望の場所に対応する確率振幅の符号を回転させます。次に、平均と比較して革命を実行します。ただし、この場合、振幅の増幅は2つのキュービットの場合ほど大きくは発生しません。たとえば、8つの数値を取り上げます。そのうちの7つは1で、1つは-1です。それらの合計は6で、平均は6/8です。反転後、平均1は1/2になり、–1は10/4になります。結果として、3つのキュビットが存在し、振幅の増幅後に1つのキュビットを測定すると、他の位置よりも高い確率で目的の位置が得られます。問題は、間違った答えが出る可能性が高いことです。正しい答えが得られる確率を高くする必要があります。測定する前に、振幅をさらに増幅する必要があります。解決策は、すべてのキュービットをチェーンを通して転送することです。目的の位置に関連付けられた確率振幅の符号を再度反転し、平均に対して相対的に反転します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的なケースを考えてみましょう。</font><font style="vertical-align: inherit;">m可能な場所の1つで何かを見つける必要があります。</font><font style="vertical-align: inherit;">古典的な方法でそれを見つけるには、最悪の場合、m-1個の質問をする必要があります。</font><font style="vertical-align: inherit;">質問の数はmに比例して増加します。</font><font style="vertical-align: inherit;">グローバーは、正解の最大確率を取得するためにチェーンを使用する必要がある回数を決定する式を計算しました。</font><font style="vertical-align: inherit;">この式が与える数は比例して増加し</font></font><img src="https://habrastorage.org/webt/zf/wk/uv/zfwkuvnbn6kqnmfr05edx02rudw.png" alt="画像"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これは二次加速度です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Groverアルゴリズムアプリケーション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムの実装にはいくつかの問題があります。最初に、2次加速度が複雑さの要求と比較して評価されます。オラクルを使用するには、オラクルを作成する必要があります。このタスクを慎重に行わない場合、オラクルによって実行されるステップの数は、アルゴリズムが保存するステップの数を上回ります。その結果、アルゴリズムは従来のものよりも遅くなります。もう1つの問題は、加速度を決定することにより、データセットが無秩序であると想定することです。データセットに特定の構造がある場合、この構造を使用してソリューションをはるかに高速に検索する古典的なアルゴリズムを見つけることができます。最後の問題は加速に関連しています。二次加速度は、他のアルゴリズムで観察された指数加速度にすぎません。もっと達成することは可能ですか？これらの問題を見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オラクルの実装に関連する問題とデータセット内の構造の存在の両方が正当化され、ほとんどの場合、Groverアルゴリズムにはデータベースを検索するための実用的なアプリケーションがないことが示されています。しかし、状況によっては、データに構造を持たせることで、高い効率で動作するオラクルを作成できるようになります。このような状況では、アルゴリズムは従来のアルゴリズムを追い抜くことができます。より大きな成功を収める可能性についての質問への回答はすでに出されています。 Groverのアルゴリズムが最適であることが証明されています。二次加速度以上の問題を解決できる量子アルゴリズムはありません。二次加速度は、指数関数ほどではありませんが、いくつかの利点があります。大きなデータセットを扱う場合、スピードアップは価値があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、Groverアルゴリズムは、上記で示したように、検索ではなく、そのバリエーションでメインアプリケーションを見つけます。</font><font style="vertical-align: inherit;">特に、振幅を増幅するという考え方は役に立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかのアルゴリズムのみを検討しましたが、ShoreおよびGroverアルゴリズムが最も重要であると考えられています。</font><font style="vertical-align: inherit;">これら2つに固有のアイデアに基づく他の多くのアルゴリズムがあります。1ここで、量子アルゴリズムから量子コンピューティングの他の応用分野に注意を向けましょう。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja470998/index.html">木製おもちゃ、パート10-1996</a></li>
<li><a href="../ja471000/index.html">木のおもちゃ、最後の部分-1997</a></li>
<li><a href="../ja471004/index.html">木のおもちゃ-天井に釘付けされたままのエピローグ</a></li>
<li><a href="../ja471006/index.html">1か月あたり500ドル：無条件のベーシックインカムの受給者は何にお金を使いますか？</a></li>
<li><a href="../ja471008/index.html">監視について話そう：10月23日の会議でNew Relicを使ったDevops Deflopeポッドキャストのライブ録音</a></li>
<li><a href="../ja471012/index.html">ソフトウェア開発へのエンジニアリングアプローチ。理論から実践へ</a></li>
<li><a href="../ja471014/index.html">私たちは自律水ドローンを作っています、または私がバイカルを助けることを夢見ていましたが、私はガスプロムではありません。パート1</a></li>
<li><a href="../ja471016/index.html">データベース設計。ベストプラクティス</a></li>
<li><a href="../ja471018/index.html">iPhone 11を含むPCとスマートフォンのパフォーマンスの比較</a></li>
<li><a href="../ja471020/index.html">35年前にリリースされたマイクロプロセッサのエラーを見つける方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>