<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîû üë©üèΩ‚Äçüé® üò∏ Algorithmes de traitement rapide des cha√Ænes HTTP üöì ü§òüèø üêÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La compression des en-t√™tes standard est apparue dans HTTP / 2, mais le corps des valeurs URI, Cookie, User-Agent peut encore √™tre de plusieurs dizain...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Algorithmes de traitement rapide des cha√Ænes HTTP</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/493242/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La compression des en-t√™tes standard est apparue dans HTTP / 2, mais le corps des valeurs URI, Cookie, User-Agent peut encore √™tre de plusieurs dizaines de kilo-octets et n√©cessite une tokenisation, une recherche et une comparaison des sous-cha√Ænes. </font><font style="vertical-align: inherit;">La t√¢che devient critique si un analyseur HTTP doit g√©rer un trafic malveillant important. </font><font style="vertical-align: inherit;">Les biblioth√®ques standard fournissent des outils de traitement de cha√Ænes √©tendus, mais les cha√Ænes HTTP ont leurs propres sp√©cificit√©s. </font><font style="vertical-align: inherit;">C'est pour cette sp√©cificit√© que l'analyseur HTTP Tempesta FW a √©t√© d√©velopp√©. </font><font style="vertical-align: inherit;">Ses performances sont plusieurs fois sup√©rieures √† celles des solutions Open Source modernes et surpassent les plus rapides d'entre elles.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GcAJF4648JI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Krizhanovsky</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">krizhanovsky</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) fondateur et architecte syst√®me Tempesta Technologies, expert en calcul haute performance sous Linux / x86-64. Alexander parlera des particularit√©s de la structure des cha√Ænes HTTP, expliquera pourquoi les biblioth√®ques standard sont mal adapt√©es pour les traiter et pr√©sentera la solution Tempesta FW. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sous la coupe: comment HTTP Flood transforme votre analyseur HTTP en goulot d'√©tranglement, probl√®mes x86-64 avec des erreurs de pr√©diction de branche, la mise en cache et la m√©moire insuffisante sur les t√¢ches typiques de l'analyseur HTTP, comparaison FSM avec sauts directs, optimisation GCC, vectorisation automatique, strspn () - et des algorithmes de type strcasecmp () pour les cha√Ænes HTTP, SSE, AVX2 et les attaques par filtrage par injection utilisant AVX2.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chez Tempesta Technologies, nous d√©veloppons des logiciels personnalis√©s: nous nous sp√©cialisons dans des domaines complexes li√©s √† la haute performance. </font><font style="vertical-align: inherit;">Nous sommes particuli√®rement fiers du d√©veloppement du c≈ìur de la premi√®re version WAF de Positive Technologies. </font><font style="vertical-align: inherit;">Le Web Application Firewall (WAF) est un proxy HTTP: il traite une analyse tr√®s approfondie du trafic HTTP pour les attaques (Web et DDoS). </font><font style="vertical-align: inherit;">Nous en avons √©crit le premier noyau. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus de la consultation, nous d√©veloppons </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta FW</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - il s'agit d'Application Delivery Controller (ADC). </font><font style="vertical-align: inherit;">Nous allons parler de lui.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contr√¥leur de livraison d'applications</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Application Delivery Controller est un proxy HTTP avec des fonctionnalit√©s am√©lior√©es. </font><font style="vertical-align: inherit;">Mais je vais parler d'une fonctionnalit√© li√©e √† la s√©curit√© - le filtrage des attaques DDoS et Web. </font><font style="vertical-align: inherit;">Je mentionnerai √©galement les limitations, et je montrerai le travail et les fonctions avec des exemples de code.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mg/gf/tw/mggftw9mux_ycaxzjbfqe6hpdc0.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempesta FW est int√©gr√© au noyau Linux TCP / IP Stack. </font><font style="vertical-align: inherit;">Gr√¢ce √† cela et √† un certain nombre d'autres optimisations, c'est tr√®s rapide - il peut traiter 1,8 million de requ√™tes par seconde sur du mat√©riel bon march√©. </font><font style="vertical-align: inherit;">Ceci est 3 fois plus rapide que Nginx √† la charge maximale et est √©galement rapide par rapport √† l' </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">approche de contournement du noyau. </font></font></strong><br>
<br>
<img src="https://habrastorage.org/webt/te/md/pe/temdpec1gcgnm98ktgwr4gewn-8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur un petit nombre de c≈ìurs, il affiche des performances similaires avec le projet Seastar, qui est utilis√© dans ScyllaDB (√©crit en DPDK).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probl√®me</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le projet est n√© lorsque nous avons commenc√© √† travailler sur PT AF - en 2013. </font><font style="vertical-align: inherit;">Ce WAF √©tait bas√© sur un acc√©l√©rateur HTTP Open Source populaire. </font><font style="vertical-align: inherit;">Nginx, HAProxy, Varnish ou Apache Traffic sont de bons acc√©l√©rateurs HTTP: ils fournissent du contenu fin, mettent en cache, modifient, mais aucun d'entre eux </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'est con√ßu pour le traitement et le filtrage massifs du trafic</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par cons√©quent, nous avons pens√© que s'il existe un pare-feu au niveau du r√©seau, pourquoi ne pas poursuivre cette id√©e et l'int√©grer dans la pile TCP / IP en tant que pare-feu au niveau de l'application? </font><font style="vertical-align: inherit;">En fait, il s'est av√©r√© que Tempesta FW - un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hybride d'acc√©l√©rateur HTTP et de pare-feu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque: Nginx sera utilis√© comme exemple dans le rapport car il s'agit d'un serveur Web simple et populaire. </font><font style="vertical-align: inherit;">Au lieu de cela, il pourrait y avoir tout autre serveur HTTP Open Source.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons notre </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requ√™te HTTP</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (HTTP / (1, ~ 2)) </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_o/3z/tq/_o3ztqvtwrv-7epdryhdztg8wsq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons avoir un URI tr√®s grand. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les s√©parateurs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui sont importants au moment de l'analyse HTTP </font><font style="vertical-align: inherit;">sont mis en √©vidence en rouge gras </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Je vais mettre en √©vidence les fonctionnalit√©s: grandes cha√Ænes de plusieurs kilo-octets, ainsi que diff√©rents d√©limiteurs, par exemple, des "points-virgules" suppl√©mentaires que nous devons analyser, ou la s√©quence "\ r \ n". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un petit mot sur HTTP / 2 doit √©galement √™tre dit.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonctionnalit√©s HTTP / 2</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2 est un m√©lange de cha√Ænes et de donn√©es binaires</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ce m√©lange consiste davantage √† optimiser la bande passante d'une connexion qu'√† √©conomiser les ressources du serveur. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2 dans HPACK utilise une table dynamique</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La premi√®re requ√™te du client n'est pas optimis√©e, elle n'est pas dans le tableau. Vous devez l'analyser pour qu'il soit ajout√© √† la table. Si HTTP / 2 DDoS vient √† vous, ce sera juste le cas. Dans le cas normal, HTTP / 2 est un protocole binaire, mais vous devez toujours analyser le texte: noms d'en-t√™te de texte, donn√©es. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encodage Huffman</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il s'agit d'un codage simple, mais Huffman est monstrueusement difficile √† programmer rapidement pour la compression: le codage Huffman franchit la limite d'octets, vous ne pouvez pas utiliser d'extensions vectorielles et vous devez passer par octets. </font><font style="vertical-align: inherit;">Vous ne pourrez pas traiter rapidement les donn√©es en 32 ou 16 octets. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les cookies, User-Agent, Referer, URI peuvent √™tre tr√®s volumineux</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tout d'abord, supprimez Huffman, puis envoyez-le √† un analyseur HTTP normal, comme dans HTTP / 1. </font><font style="vertical-align: inherit;">Bien que cela soit autoris√© par le RFC, il n'est pas recommand√© de compresser les cookies, car il s'agit de donn√©es confidentielles - vous ne devez pas donner √† l'attaquant des informations sur leur taille. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traitement HTTP lent</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tous les serveurs HTTP d√©codent d'abord HTTP / 2, puis envoient ces lignes √† l'analyseur HTTP / 1 que HTTP / 1 utilise d√©j√†. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quel est le probl√®me avec l'analyse HTTP / 1?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous devez programmer rapidement la machine d'√©tat.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous devez traiter rapidement des lignes cons√©cutives.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le trafic malveillant cible la partie la plus lente (la plus faible) du processus. </font><font style="vertical-align: inherit;">Par cons√©quent, si nous voulons faire un filtre, nous devons faire attention aux pi√®ces lentes afin qu'elles fonctionnent √©galement rapidement.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Profil Nginx</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons le profil nginx sous le d√©luge HTTP. </font><font style="vertical-align: inherit;">D√©sactivez le journal d'acc√®s pour que le syst√®me de fichiers ne ralentisse pas. </font><font style="vertical-align: inherit;">Quand m√™me une page d'index r√©guli√®re est demand√©e, l'analyseur monte en haut.</font></font><br>
<div class="scrollable-table"><table>
<tbody>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">%</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nom du symbole</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,5719</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_http_parse_header_line</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1,0303</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_vslprintf</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,6401</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcpy</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5807</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recv</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5156</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_linux_sendfile_chain</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,4990</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ngx_http_limit_req_handler</font></font></td>
</tr>
</tbody>
</table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gauche - "Profil plat". </font><font style="vertical-align: inherit;">Fait int√©ressant, l'endroit le plus chaud n'est pas beaucoup plus lourd que le suivant, et apr√®s cela, le profil descend en douceur. </font><font style="vertical-align: inherit;">Cela signifie, par exemple, qu'optimiser deux fois la premi√®re fonction n'aidera pas √† am√©liorer consid√©rablement les performances. </font><font style="vertical-align: inherit;">C'est pourquoi nous n'avons pas optimis√© le m√™me Nginx, mais avons fait un nouveau projet qui am√©liorera les performances de toute la queue du profil.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment les analyseurs HTTP r√©guliers sont encod√©s</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Habituellement, nous avons une boucle ( </font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) qui longe la ligne et deux variables: state ( </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) et current data ( </font></font><code>str_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous entrons dans le cycle (1) et regardons l'√©tat actuel (v√©rifier l'√©tat). Nous passons aux donn√©es re√ßues (symbole </font></font><code><em>'b'</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et impl√©mentons une logique. On passe au deuxi√®me √©tat (2). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hi/z7/s2/hiz7s2e3yw5bpqqz-qbir5hbteq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aller √† la fin </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3) - il s'agit de la deuxi√®me transition par rapport au d√©but de notre code et, √©ventuellement, de la deuxi√®me absence dans le cache d'instructions. Ensuite, nous allons au d√©but </font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4), mangeons le caract√®re suivant ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gk/zs/17/gkzs17hdxtyfcaife8j1pms7wbi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... et recherchons √† nouveau l'√©tat dans les instructions √† l'int√©rieur </font></font><code>case 2:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsqu'une variable a d√©j√† re√ßu une </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur</font></font><code>2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous pourrions simplement passer √† l'instruction suivante. </font><font style="vertical-align: inherit;">Mais au lieu de cela, ils ont remont√© et redescendu. </font><font style="vertical-align: inherit;">Nous ¬´coupons les cercles¬ª par code au lieu de simplement descendre. </font><font style="vertical-align: inherit;">Les analyseurs normaux ne produisent pas, par exemple, Ragel un analyseur avec des transitions directes.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mc/ba/3w/mcba3wgxqkflqjvq1mxytcy_kwo.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyseur HTTP Nginx</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelques mots sur l'analyseur nginx et son environnement. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nginx fonctionne avec l'API socket normale</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - les donn√©es qui vont √† l'adaptateur sont copi√©es dans l'espace utilisateur. </font><font style="vertical-align: inherit;">En cons√©quence, nous avons un gros morceau de donn√©es dans lequel nous recherchons ce dont nous avons besoin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx utilise un algorithme qui fonctionne en deux passes: d'abord il recherche la longueur, puis il v√©rifie. </font><font style="vertical-align: inherit;">Dans la premi√®re √©tape, il scanne la cha√Æne √† la recherche de jetons, recherche le premier jeton (¬´essai¬ª). </font><font style="vertical-align: inherit;">Sur le second, il tokens, v√©rifie la fin de la requ√™te ( </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) et d√©marre </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, selon la taille du token.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (p = b-&gt;pos; p &lt; b-&gt;last; p++) {<font></font>
    ...<font></font>
    <span class="hljs-keyword">switch</span> (state) {<font></font>
    ...<font></font>
    <span class="hljs-keyword">case</span> sw_method:
        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">' '</span>) {<font></font>
            m = r-&gt;request_start;<font></font>
            <span class="hljs-keyword">switch</span> (p - m) {         <span class="hljs-comment">// switch on token length!</span>
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                <span class="hljs-keyword">if</span> (ngx_str3_cmp(m, <span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>)) {<font></font>
                ...<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> ((ch &lt; <span class="hljs-string">'A'</span> || ch &gt; <span class="hljs-string">'Z'</span>) &amp;&amp; ch != <span class="hljs-string">'_'</span> &amp;&amp; ch != <span class="hljs-string">'-'</span>)
                <span class="hljs-keyword">return</span> NGX_HTTP_PARSE_INVALID_METHOD;
            <span class="hljs-keyword">break</span>;<font></font>
    ...</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬´Get¬ª est toujours dans le m√™me bloc de donn√©es</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tempesta FW fonctionne avec z√©ro copie. </font><font style="vertical-align: inherit;">Cela signifie que les donn√©es peuvent avoir une taille compl√®tement arbitraire: 1 octet ou 1000 octets chacune. </font><font style="vertical-align: inherit;">Ce "m√©canisme" ne nous convient pas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment cela fonctionne </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans GCC.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gcc</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table de recherche</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . √Ä gauche se trouve un exemple typique d'√©num√©ration: commencez par 0, puis des √©tiquettes cons√©cutives, 26 constantes, puis du code qui traite tout cela. √Ä droite, le code g√©n√©r√© par le compilateur. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ac/1n/hh/ac1nhhz9jqe87hdqb6bxfv541vu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, comparez la variable </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">du registre EAX avec une constante. Ensuite, nous pr√©sentons toutes les √©tiquettes sous la forme d'un tableau s√©quentiel de pointeurs de 8 octets (table de correspondance). Sur cette instruction, nous transmettons le d√©calage dans ce tableau - c'est un double d√©r√©f√©rencement des pointeurs. En bas √† droite se trouve le code vers lequel nous sommes pass√©s de ce tableau. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'av√®re que le d√©r√©f√©rencement double de la m√©moire: si nous avons re√ßu des donn√©es secr√®tes, alors par octets nous trouvons l'adresse dans le tableau et allons √† ce pointeur. Il est important de savoir que dans la vie, c'est encore pire que dans l'exemple - pour la table de recherche, le compilateur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g√©n√®re</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le code est plus compliqu√© dans le cas d'un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">script</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour une attaque Spectre. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recherche binaire</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Le cas suivant n'est </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas avec des constantes s√©quentielles, mais avec des constantes arbitraires. Le code est le m√™me, mais maintenant GCC ne peut pas compiler un si grand tableau et utiliser des constantes comme index du tableau. Il passe √† la recherche binaire. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/as/mo/7p/asmo7pb4lxsv7pchnafv-qjz7u4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur la droite, nous voyons une comparaison s√©quentielle, le passage √† l'adresse et la poursuite de la comparaison - la recherche binaire se fait par code. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyseur HTTP Nginx.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voyons ce qu'est la machine √† √©tats nginx. Il a 9 kilo-octets de code - c'est trois fois moins que le cache de premier niveau sur la machine sur laquelle les tests ont √©t√© lanc√©s (comme sur la plupart des processeurs x86-64).</font></font><br>
<br>
<pre><code class="bash hljs">$ nm -S /opt/nginx-1.11.5/sbin/nginx<font></font>
| grep http_parse | cut -d<span class="hljs-string">' '</span> -f 2<font></font>
| perl -le <span class="hljs-string">'$a += hex($_) while (&lt;&gt;); print $a'</span><font></font>
9220<font></font>
<font></font>
$ getconf LEVEL1_ICACHE_SIZE<font></font>
32768<font></font>
<font></font>
$ grep -c <span class="hljs-string">'case sw_'</span> src/http/ngx_http_parse.c<font></font>
84</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'analyseur d'en-t√™te nginx </font></font><code>ngx_http_parse_header_line ()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est un simple tokenizer. </font><font style="vertical-align: inherit;">Il ne fait rien avec les valeurs des en-t√™tes et leurs noms, mais met simplement les jetons des en-t√™tes HTTP dans un hachage. </font><font style="vertical-align: inherit;">Si vous avez besoin d'une valeur d'en-t√™te, scannez le tableau d'en-t√™te et r√©p√©tez l'analyse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous devons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v√©rifier strictement les noms et les valeurs des en-t√™tes</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour des raisons de s√©curit√© </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></strong><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempesta FW: validation de cha√Æne de cha√Ænes HTTP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre machine d'√©tat est d'un ordre de grandeur plus puissant: nous faisons la validation d'en-t√™te RFC et imm√©diatement, dans l'analyseur, nous traitons presque tout. </font><font style="vertical-align: inherit;">Si nginx a 80 √©tats, alors nous en avons 520, et il y en a plus. </font><font style="vertical-align: inherit;">Si nous continuions </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce serait 10 fois plus grand. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des E / S sans copie</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - des morceaux de diff√©rentes tailles peuvent couper des donn√©es √† diff√©rents endroits. </font><font style="vertical-align: inherit;">diff√©rents morceaux peuvent couper nos donn√©es. </font><font style="vertical-align: inherit;">Dans les E / S √† copie nulle, par exemple, ¬´GET¬ª peut (rarement) appara√Ætre comme ¬´GET¬ª, ¬´GE¬ª et ¬´T¬ª ou ¬´G¬ª, ¬´E¬ª et ¬´T¬ª, vous devez donc stocker l'√©tat entre les √©l√©ments de donn√©es . </font><font style="vertical-align: inherit;">Nous supprimons pratiquement les co√ªts d'E / S, mais dans le profil, cela vole - tout va mal. </font><font style="vertical-align: inherit;">Le grand analyseur HTTP est l'un des endroits les plus critiques du projet.</font></font><br>
<br>
<pre><code class="bash hljs">$ grep -c <span class="hljs-string">'__FSM_STATE\|__FSM_TX\|__FSM_METH_MOVE\|__TFW_HTTP_PARSE_'</span> http_parser.c<font></font>
520<font></font>
    7.64% [tempesta_fw]     [k] tfw_http_parse_req<font></font>
    2.79% [e1000]           [k] e1000_xmit_frame<font></font>
    2.32% [tempesta_fw]     [k] __tfw_strspn_simd<font></font>
    2.31% [tempesta_fw]     [k] __tfw_http_msg_add_str_data<font></font>
    1.60% [tempesta_fw]     [k] __new_pgfrag<font></font>
    1.58% [kernel]          [k] skb_release_data<font></font>
    1.55% [tempesta_fw]     [k] __str_grow_tree<font></font>
    1.41% [kernel]          [k] __inet_lookup_established<font></font>
    1.35% [tempesta_fw]     [k] tfw_cache_do_action<font></font>
    1.35% [tempesta_fw]     [k] __tfw_strcmpspn</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que faire pour am√©liorer cette situation?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parrainages directs FSM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La premi√®re chose que nous faisons n'est </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas d'utiliser une boucle, mais des transitions directes par labels ( </font></font></strong><code>go to</code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Les g√©n√©rateurs d'analyseurs normaux comme Ragel le font. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bq/di/pr/bqdipr9bt6au4ifisfpvjli2p_e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous codons chacun de nos √©tats avec une √©tiquette en </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et une √©tiquette en C avec </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le m√™me nom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Chaque fois que nous voulons y aller, nous trouvons une √©tiquette </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou acc√©dons au m√™me √©tat directement √† partir du code. La premi√®re fois que nous traversons </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis √† l'int√©rieur, nous allons directement √† l'√©tiquette souhait√©e. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inconv√©nient</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : lorsque nous voulons passer √† l'√©tat suivant, nous devons imm√©diatement √©valuer si nous avons encore des donn√©es disponibles (car des E / S √† copie nulle). Conditionner le corps</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est copi√© dans chaque √©tat: au lieu d'une condition dans un FSM standard avec interrupteur, nous en avons 500 selon le nombre d'√©tats. G√©n√©rer du code pour chaque √©tat n'est pas g√©nial. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cas de grandes machines d'√©tat, car </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec un grand </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int√©rieur, GTC r√©p√®te √©galement la condition </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plusieurs fois dans le code. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remplacez par </font></font></strong><code><strong>switch</strong></code><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des transitions directes.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'optimisation suivante consiste √† ne pas l'utiliser </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et √† basculer pour diriger les sauts vers les m√©ta-adresses enregistr√©es. Nous voulons aller imm√©diatement au point souhait√© d√®s que nous entrons dans la fonction. GCC vous permet de le faire. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/i3/x5/7m/i3x57mb0tahhz99szccnfdbxde0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GCC a une extension standard qui peut vous aider. Nous prenons le nom de l'√©tiquette (le voici </font></font><code>from</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) et attribuons son adresse √† une variable C via une double esperluette (&amp;&amp;). Maintenant, nous pouvons faire une instruction de saut direct</font></font><code>jmp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† l'adresse de cette √©tiquette avec </font></font><code>goto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons ce qui en sort.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performances de conversion directe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur un petit nombre d'√©tats, le g√©n√©rateur de code de transition directe est m√™me un peu plus lent que la normale </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais pour les grandes machines d'√©tat, la productivit√© double. </font><font style="vertical-align: inherit;">Si la machine d'√©tat est petite, il vaut mieux utiliser celle habituelle </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="bash hljs">$ grep -m 2 <span class="hljs-string">'model name\|bugs'</span> /proc/cpuinfo<font></font>
model name : Intel(R) Core(TM) i7-6500U CPU @ 2.50GHz<font></font>
bugs       : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf<font></font>
<font></font>
$ gcc --version|head -1<font></font>
gcc (GCC) 8.2.1 20181105 (Red Hat 8.2.1-5)<font></font>
<font></font>
States     Switch-driven automaton     Goto-driven automaton<font></font>
     7     header_line:      139ms     header_line:          156ms<font></font>
    27     request_line:     210ms     request_line:         186ms<font></font>
   406     big_header_line: 1406ms     goto_big_header_line: 727ms</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque: le code Tempesta est plus compliqu√© que les exemples. </font><font style="vertical-align: inherit;">GitHub a toutes les </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://github.com/tempesta-tech/blog/tree/master/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©f√©rences</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> afin que vous puissiez tout voir en d√©tail. </font><font style="vertical-align: inherit;">Le code de l'analyseur d'origine est disponible </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur le lien</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (analyseur HTTP principal). </font><font style="vertical-align: inherit;">En plus de cela, dans Tempesta FW, il y a </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des analyseurs plus petits</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui utilisent FSM plus facilement.</font></font></em><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi les transitions directes peuvent √™tre plus lentes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la machine d'√©tat, nous passons par beaucoup de code, donc (attendu) il y aura beaucoup de mauvaises pr√©dictions de branche. </font><font style="vertical-align: inherit;">R√©alisons le ¬´profilage¬ª en fonction de la pr√©diction des rat√©s de branchement:</font></font><br>
<br>
<pre><code class="bash hljs">perf record -e branch-misses -g ./http_benchmark<font></font>
406 states:    switch       - 38% on switch(),<font></font>
               direct jumps - 13% on header value parsing<font></font>
			   <font></font>
7,27 states:   switch       - &lt;18% switch(), up to 40% <span class="hljs-keyword">for</span>()<font></font>
               direct jumps ‚Äì up to 46% on header &amp; URI parsing</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur une grande machine d'√©tat avec 406 √©tats, nous passons 38% du temps √† traiter les transitions </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sur une machine √† √©tats avec des transitions directes, les hotspots sont une analyse de ligne. </font><font style="vertical-align: inherit;">L'analyse d'une cha√Æne dans chaque √©tat comprend la v√©rification de la condition de fin de cha√Æne: la condition </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la machine d'√©tat activ√©e </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="bash hljs">perf <span class="hljs-built_in">stat</span> -e L1-icache-load-misses ./http_benchmark<font></font>
<font></font>
                       Switch-driven automaton  Goto-driven automaton<font></font>
big FSM code size:                       29156                  49202<font></font>
L1-icache-load-misses:                      4M                     2M</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, examinons le profilage des deux types de machine d'√©tat par les √©v√©nements du cache d'instructions L1 manqu√©s - pr√®s de 30 kilo-octets pour </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et 50 kilo-octets pour les sauts directs (plus que le cache des instructions de premier niveau). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il semble que si nous ne rentrons pas dans le cache, il devrait y avoir beaucoup de rat√©s de cache pour une telle machine d'√©tat. </font><font style="vertical-align: inherit;">Mais non, ils sont 2 fois moins. </font><font style="vertical-align: inherit;">C'est parce que le cache fonctionne mieux: nous travaillons avec le code de mani√®re s√©quentielle et r√©ussissons √† extraire les donn√©es des anciens caches.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le compilateur change l'ordre du code</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque nous programmons le code de la machine √† √©tats </font></font><code>go to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous avons d'abord les √©tats qui seront appel√©s en premier lors de la r√©ception des donn√©es: la m√©thode HTTP, l'URI, puis les en-t√™tes HTTP. Il semble logique que le code soit charg√© dans le cache du processeur de mani√®re s√©quentielle, de haut en bas, tout comme nous parcourons les donn√©es. Mais c'est compl√®tement faux. Si vous regardez le code assembleur, vous verrez des choses incroyables. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tg/uf/zr/tgufzrnfusabmvn1gg9ulzjgvgo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä gauche se trouve ce que nous avons programm√©: nous analysons d'abord les m√©thodes </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puis quelque part bien en dessous de la m√©thode improbable </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Par cons√©quent, nous nous attendons √† voir l'analyse </font></font><code> GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font><font style="vertical-align: inherit;">au d√©but de l'assembleur </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mais tout est tout √† fait le contraire: </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au milieu, </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† la fin et </font></font><code>UNLOCK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">dessus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En effet, le compilateur ne comprend pas comment les donn√©es nous parviennent. </font><font style="vertical-align: inherit;">Il distribue le code selon sa photo de beau code. </font><font style="vertical-align: inherit;">Pour qu'il puisse organiser le code dans le bon ordre, nous devons utiliser la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">barri√®re</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> du </font><strong><font style="vertical-align: inherit;">compilateur</font></strong><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La barri√®re du compilateur est un mannequin d'assemblage par lequel le compilateur ne se r√©ordonnera pas. </font><font style="vertical-align: inherit;">En pla√ßant simplement ces barri√®res, nous avons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am√©lior√© la productivit√© de 4%</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">STATE(sw_method) {<font></font>
    ... <span class="hljs-comment">// the most frequent states</span>
    MATCH(NGX_HTTP_GET, <span class="hljs-string">"GET "</span>);<font></font>
    MATCH(NGX_HTTP_POST, <span class="hljs-string">"POST"</span>);<font></font>
    <font></font>
    __asm__ __volatile__(<span class="hljs-string">""</span>: : :<span class="hljs-string">"memory"</span>);<font></font>
    ... <span class="hljs-comment">// many other states</span><font></font>
    <font></font>
    <span class="hljs-comment">// Improbable states</span>
    METH_MOVE(Req_MethU, <span class="hljs-string">'N'</span>, Req_MethUn);<font></font>
    METH_MOVE(Req_MethUn, <span class="hljs-string">'L'</span>, Req_MethUnl);<font></font>
    METH_MOVE(Req_MethUnl, <span class="hljs-string">'O'</span>, Req_MethUnlo);<font></font>
    METH_MOVE(Req_MethUnlo, <span class="hljs-string">'C'</span>, Req_MethUnloc);<font></font>
    METH_MOVE_finish(Req_MethUnloc, <span class="hljs-string">'K'</span>, NGX_HTTP_UNLOCK)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Composez le code √† votre fa√ßon</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisque le compilateur n'organise pas les donn√©es comme nous le voulons, nous ferons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une optimisation guid√©e par le profileur</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (optimisation sous le contr√¥le du profileur). </font><font style="vertical-align: inherit;">L'optimisation guid√©e par le profileur (PGO) est le nombre total d'√©chantillons, pas une s√©quence d'appels. </font><font style="vertical-align: inherit;">Par exemple, un URI re√ßoit plus d'√©chantillons qu'une analyse de m√©thode, il positionnera donc le code de traitement URI avant de traiter la m√©thode.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment √ßa fonctionne? </font><font style="vertical-align: inherit;">Nous allons √©crire le code, ex√©cuter les benchmarks dessus, donner le r√©sultat du profilage au compilateur, et il g√©n√©rera le code optimal pour nos charges. </font><font style="vertical-align: inherit;">Mais le probl√®me est qu'il compile simplement les sections de code les plus chaudes, mais ne suit pas la d√©pendance temporelle. </font><font style="vertical-align: inherit;">Si le plus grand URI de la charge, ce sera l'endroit le plus chaud. </font><font style="vertical-align: inherit;">L'URI montera en haut de la fonction et PGO ne montrera pas que le nom de la m√©thode est toujours avant l'URI. </font><font style="vertical-align: inherit;">Par cons√©quent, PGO ne fonctionne pas.</font></font><br>
<br>
<pre><code class="cpp hljs">Req_Method: {
    <span class="hljs-keyword">if</span> (likely(PI(p) == CHAR4_INT(<span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>))) {<font></font>
        ...<font></font>
        <span class="hljs-keyword">goto</span> Req_Uri;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (likely(PI(p) == CHAR4_INT(<span class="hljs-string">'P'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'T'</span>))) {<font></font>
        ...<font></font>
        <span class="hljs-keyword">goto</span> Req_UriSpace;<font></font>
    }<font></font>
    <span class="hljs-keyword">goto</span> Req_Meth_SlowPath;<font></font>
}<font></font>
... <span class="hljs-comment">// other methods: POST, PUT etc.</span><font></font>
Req_Uri:<font></font>
    ... <span class="hljs-comment">// URI processing</span><font></font>
Req_Meth_SlowPath:<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qu'est-ce qui fonctionne? </font></font><br>
<br>
<code><strong>likely</strong></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code><strong>unlikely</strong></code> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">macros</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (pour le code du noyau Linux, les intrins√®ques GCC sont disponibles dans l'espace utilisateur </font></font><code>__builtin_expect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Ils disent quel code placer plus pr√®s. Par exemple, il est probable que le corps de la demande devrait √™tre imm√©diatement derri√®re </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ensuite, la pr√©lecture du code (la pr√©lecture du processeur) s√©lectionnera ce code et tout sera rapide. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7x/4u/05/7x4u057of2wmtq310wflcuyvlei.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'image montre le d√©but de la m√©thode d'analyse, la fin et la barri√®re. Nous ne nous attendions pas √† voir le code derri√®re la barri√®re. Il semble que cela ne devrait pas √™tre le cas - nous avons √©rig√© une barri√®re. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais que se passe-t-il en r√©alit√©? Le compilateur voit la </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">condition - il est tr√®s probable que nous entrions dans le corps de la condition et l√† nous basculerons vers un saut inconditionnel vers l'√©tiquette</font></font><code>Req_Uri</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il s'av√®re que le code qui se trouve apr√®s notre condition n'est pas trait√© dans le "hot path". </font><font style="vertical-align: inherit;">Le compilateur d√©place le code sous l'√©tiquette derri√®re </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, malgr√© la barri√®re, car la condition de code actif est remplie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ce n'√©tait pas le cas, GCC a une extension: les attributs </font></font><code>hot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>cold</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les √©tiquettes. </font><font style="vertical-align: inherit;">Ils disent quelle √©tiquette est chaude (le plus probable) et laquelle est froide (le moins probable). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/ra/uh/bwrauhxesqvk_ke22cw67cqwuja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous convenons de ce qui est le </font></font><code>GET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plus probable </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et nous le laissons </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sous cette condition, le traitement URI augmente et </font></font><code>POST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descend en dessous. </font><font style="vertical-align: inherit;">Tous les autres codes de la machine d'√©tat la moins probable restent en dessous car l'√©tiquette est froide.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambigu -O3</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regardons l'optimisation du compilateur. </font><font style="vertical-align: inherit;">La premi√®re chose qui vient √† l'esprit est d'utiliser non pas O2, mais O3 - cela devrait √™tre plus rapide. </font><font style="vertical-align: inherit;">Mais ce n'est pas le cas - O3 g√©n√®re parfois un code pire. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vc/-p/q8/vc-pq8a078kyofsx7cj1ukorbta.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O3 est une collection de quelques optimisations</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si nous les ajoutons √† O2 s√©par√©ment, nous obtenons diff√©rentes options: certaines optimisations aident, d'autres interf√®rent. </font><font style="vertical-align: inherit;">Pour notre code sp√©cifique, nous s√©lectionnons uniquement les optimisations qui g√©n√®rent mieux le code. </font><font style="vertical-align: inherit;">Nous laissons le meilleur r√©sultat - voici 1 820 secondes par rapport √† 1 838 et 1 858. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certaines options sont surlign√©es en vert - il s'agit de la vectorisation automatique.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autovectorisation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un exemple de cycle du </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">guide GCC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> a[<span class="hljs-number">256</span>], b[<span class="hljs-number">256</span>], c[<span class="hljs-number">256</span>];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<font></font>
        a[i] = b[i] + c[i];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous avons un tableau variable qui se r√©p√®te, nous pouvons optimiser le cycle - d√©composer en vecteurs. </font><font style="vertical-align: inherit;">Par d√©faut, l'auto- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vectorisation est</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> activ√©e au troisi√®me niveau d'optimisation -O3 </font><font style="vertical-align: inherit;">: GCC g√©n√®re du code vectoriel l√† o√π il le peut. </font><font style="vertical-align: inherit;">Mais </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tout le code</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne peut pas √™tre vectoris√© automatiquement (m√™me s'il est vectoris√© en principe). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons activer l'option GCC </font></font><code>-fopt-info-vec-all</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui montre ce qui a √©t√© vectoris√© et ce qui ne l'est pas. </font><font style="vertical-align: inherit;">Nous obtenons que pour notre benchmark, rien n'est vectoris√©, mais le code est toujours g√©n√©r√© pire. </font><font style="vertical-align: inherit;">Par cons√©quent, la vectorisation ne fonctionne pas toujours: elle ralentit parfois le code. </font><font style="vertical-align: inherit;">Mais nous pouvons toujours voir ce qui a √©t√© vectoris√© et ce qui ne l'est pas, et d√©sactiver la vectorisation, si n√©cessaire.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alignement: comment comparer une cha√Æne avec GET?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous faisons un petit hack, comme dans nginx: nous n'analysons pas les lignes par octets, mais calculons </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et comparons les lignes avec elles.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAR4_INT(a, b, c, d)    ((d &lt;&lt; 24) | (c &lt;&lt; 16) | (b &lt;&lt; 8) | a)</span>
<span class="hljs-keyword">if</span> (p == CHAR4_INT(<span class="hljs-string">'G'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">' '</span>)))
    <span class="hljs-comment">// we have GET as method</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous savons que s'il n'est </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas align√©, il ralentit 2-3 fois. </font><font style="vertical-align: inherit;">Nous avons √©crit une petite </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©f√©rence</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui le prouve.</font></font><br>
<br>
<pre><code class="cpp hljs">$ ./int_align<font></font>
Unaligned access = <span class="hljs-number">6.20482</span>
Aligned access = <span class="hljs-number">2.87012</span>
Read four bytes = <span class="hljs-number">2.45249</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayez ensuite de vous aligner </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous allons regarder, si l'adresse est </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">align√©e, puis comparer par </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sinon, octets.</font></font><br>
<br>
<pre><code class="cpp hljs"> (((<span class="hljs-keyword">long</span>)(p) &amp; <span class="hljs-number">3</span>)<font></font>
  ? ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">0</span>]) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span>)<font></font>
  | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span>) | ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)((p)[<span class="hljs-number">3</span>]) &lt;&lt; <span class="hljs-number">24</span>))<font></font>
  : *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)(p));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais il s'av√®re que cette approche fonctionne moins bien:</font></font><br>
<br>
<pre><code class="bash hljs">full request line:     no difference<font></font>
method only:           unaligned      - 214ms<font></font>
                       aligned        - 231ms<font></font>
                       bytes          - 216ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En bref: il existe une diff√©rence entre le code de r√©f√©rence isol√©, non optimisable, et le code de l'analyseur en ligne, qui perd son optimisation en raison de la grande quantit√© de code. </font><font style="vertical-align: inherit;">Il n'y avait aucune p√©nalit√© dans le profilage. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque: une discussion d√©taill√©e des raisons pour lesquelles cela se produit dans notre t√¢che peut √™tre </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lue sur GitHub</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi les cha√Ænes HTTP sont-elles importantes pour nous?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, il s'agit d'un URI normal: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pw/_d/tw/pw_dtwjndt-xro47gvj3qehvpm4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
si vous √™tes assez pointilleux sur l'h√¥tel, allez dans R√©servation et d√©finissez des filtres, obtenez un URI de plus d'un kilo-octet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx a une machine d'analyse assez massive sur </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">√áa ne marche pas tr√®s vite. </font><font style="vertical-align: inherit;">De plus, dans le cas de Tempesta FW, nous devons non seulement analyser l'URI, mais √©galement le v√©rifier pour les injections.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">case</span> sw_check_uri:
    <span class="hljs-keyword">if</span> (usual[ch &gt;&gt; <span class="hljs-number">5</span>] &amp; (<span class="hljs-number">1U</span> &lt;&lt; (ch &amp; <span class="hljs-number">0x1f</span>)))
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">switch</span> (ch) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:<font></font>
        r-&gt;uri_ext = <span class="hljs-literal">NULL</span>;<font></font>
        state = sw_after_slash_in_uri;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'.'</span>:<font></font>
        r-&gt;uri_ext = p + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">' '</span>:<font></font>
        r-&gt;uri_end = p;<font></font>
        state = sw_check_uri_http_09;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> CR:<font></font>
        r-&gt;uri_end = p;<font></font>
        r-&gt;http_minor = <span class="hljs-number">9</span>;<font></font>
        state = sw_almost_done;<font></font>
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> LF:<font></font>
        r-&gt;uri_end = p;<font></font>
        r-&gt;http_minor = <span class="hljs-number">9</span>;
        <span class="hljs-keyword">goto</span> done;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'%'</span>:<font></font>
    r-&gt;quoted_uri = <span class="hljs-number">1</span>;<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre URI: /redir_lang.jsp?lang=foobar%0d%0aContent-Length:%200%0d% </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0a% 0d% 0aHTTP / 1.1% 20200% 20OK% 0d% 0aContent-Type:% 20text / </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
html% 0d% 0aContent -Longueur:% 2019% 0d% 0a% 0d% 0aShazam &lt;/ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
html&gt;. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il ressemble au premier, mais il a une injection. Vous devrez creuser suffisamment pour comprendre cela. </font><font style="vertical-align: inherit;">Lan√ßons </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un test</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : prenez le premier URI, alimentez wrk, r√©glez-le sur nginx et voyez que l'analyse de nginx devient tr√®s chaude. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m-/y1/id/m-y1idxtawyq5rjayodyb_r2tgq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si lors de la pr√©c√©dente requ√™te d'index standard, il √©tait clair que l'analyseur est d√©j√† en haut, il devient encore plus chaud.</font></font><br>
<br>
<pre><code class="bash hljs">8.62%  nginx         [.] ngx_http_parse_request_line<font></font>
2.52%  nginx         [.] ngx_http_parse_header_line<font></font>
1.42%  nginx         [.] ngx_palloc<font></font>
0.90%  [kernel]      [k] copy_user_enhanced_fast_string<font></font>
0.85%  nginx         [.] ngx_strstrn<font></font>
0.78%  libc-2.24.so  [.] _int_malloc<font></font>
0.69%  nginx         [.] ngx_hash_find<font></font>
0.66%  [kernel]      [k] tcp_recvmsg</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle est la particularit√© des cha√Ænes HTTP? </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe diff√©rents s√©parateurs </font></font><code>' : '</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>' , '</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et m√™me la fin des lignes, qui peuvent √™tre √† deux octets </font></font><code>\r\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou √† un octet </font></font><code>\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui a √©t√© discut√© au d√©but. </font><font style="vertical-align: inherit;">Il n'y a pas de terminaison 0 des lignes C - pour des raisons de s√©curit√©, nous voulons v√©rifier plus pr√©cis√©ment ce qui nous arrive. </font><font style="vertical-align: inherit;">Nous avons deux fonctions standard qui aident dans l'analyseur.</font></font><br>
<br>
<ul>
<li><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: v√©rifie l'alphabet, les caract√®res disponibles dans une cha√Æne, compile dynamiquement un alphabet valide, bien qu'il soit connu au stade de la compilation du programme.</font></font></li>
<li><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il n'y a pas besoin de convertir cas de comparer </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec </font></font><code>Foo:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans la plupart des cas </font></font><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, seule la conformit√© / non-conformit√© est requise </font><font style="vertical-align: inherit;">pour </font><font style="vertical-align: inherit;">, et vous n'avez pas besoin de conna√Ætre la position dans la ligne.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ils travaillent lentement. </font><font style="vertical-align: inherit;">Voyons les rep√®res et comprenons ce qui ne va pas avec eux.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyseurs rapides</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a plusieurs analyseurs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nginx est l'analyseur le plus simple, l'analyseur. Il v√©rifie strictement la conformit√© RFC. Il existe √©galement des analyseurs PicoHTTPParser (H2O) et Cloudflare. Ils traitent les donn√©es plus rapidement, mais peuvent </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://blog.cloudflare.com/improving-pico"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ignorer les caract√®res</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui ne sont pas autoris√©s par le RFC. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PCMESTRI.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les analyseurs utilisent plusieurs approches diff√©rentes. La premi√®re est l'instruction PCMESTRI, qui est utilis√©e dans l'analyseur Pico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous d√©finissons des plages dans les instructions. Malheureusement, nous pouvons charger 16 caract√®res ou 8 plages. Si la plage se compose d'un seul caract√®re - r√©p√©tez simplement. En raison de cette limitation, l'analyseur Pico ne peut pas enti√®rement v√©rifier la conformit√© RFC, car le RFC a plus de 8 plages √† cet emplacement.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ks/x8/m_/ksx8m_ixc0oy3kzucdwzumppaus.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous chargeons l'alphabet dans le registre, chargeons la cha√Æne, ex√©cutons l'instruction. A la sortie, on voit rapidement s'il y a une co√Øncidence ou non. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX2 - Approche CloudFlare.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'analyseur CloudFlare, utilisant AVX2, traite 32 octets d'une cha√Æne √† la fois, au lieu de 16 octets avec un analyseur Pico. L'analyse est meilleure dans CloudFlare car elle a √©t√© transf√©r√©e vers AVX2. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/b8/3j/g1/b83jg1epzz6ec6dllxv1j4a-0lo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous v√©rifions tous les caract√®res dans un espace de la table ASCII, tous les caract√®res sont sup√©rieurs √† 128 et prenons la plage entre eux. Le code simple est rapide. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparez PCMESTRI et AVX2.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour nous, la limite actuelle est de 1500. Il s'agit de la taille maximale du colis qui nous vient. Nous voyons que le code AVX2 sur les m√©gadonn√©es est beaucoup plus rapide que l'analyseur Pico. Mais cela fonctionne plus lentement sur les petites donn√©es, car les instructions sont plus lourdes dans AVX2. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/se/5t/c2/se5tc2npli1yed8ypqkdkk3z-pm.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comparable √†</font></font><code><strong>strspn</strong></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si nous d√©cidons d'utiliser </font></font><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, les choses empirent, en particulier sur les m√©gadonn√©es. </font><font style="vertical-align: inherit;">Dans l'analyseur "combat" ne peut pas √™tre utilis√© </font></font><code>strspn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/08/vq/bf08vqlzni3dcjzxgiuj73zgszo.png"><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'allumeur Tempesta est plus rapide et plus pr√©cis</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre analyseur de vitesse est comme ces deux-l√†. Sur les petites donn√©es, il est aussi rapide qu'un analyseur Pico, sur les gros comme CloudFlare. Cependant, il n'ignore pas les caract√®res non valides. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5t/ns/lw/5tnslwsd-ywmrv1d4xaj5_ypwbw.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment l'analyseur est-il organis√©?</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous, en tant que nginx, d√©finissons un tableau d'octets et v√©rifions les donn√©es d'entr√©e par celui-ci - c'est le prologue de la fonction. Ici, nous ne travaillons qu'avec des termes courts, nous l'utilisons </font></font><code>likely</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">car une mauvaise pr√©diction de branche est plus douloureuse pour les lignes courtes que pour les lignes longues. Nous reprenons ce code. Nous avons une limite de 4 √† cause de la derni√®re ligne - nous devons √©crire une condition assez puissante. Si nous traitons plus de 4 octets, la condition sera plus difficile et le code plus lent.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> uri_a[] __attribute__((aligned(<span class="hljs-number">64</span>))) = {
        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
        <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,
        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<font></font>
        ...<font></font>
        <span class="hljs-comment">// Branch misprediction is more crucial for short strings</span>
        <span class="hljs-keyword">if</span> (likely(len &lt;= <span class="hljs-number">4</span>)) {
                <span class="hljs-keyword">switch</span> (len) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<font></font>
                    c3 = uri_a[s[<span class="hljs-number">3</span>]];
                    <span class="hljs-comment">// fall through to process other chars</span>
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    c2 = uri_a[s[<span class="hljs-number">2</span>]];
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    c1 = uri_a[s[<span class="hljs-number">1</span>]];
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
                }<font></font>
                <span class="hljs-keyword">return</span> (c0 &amp; c1) == <span class="hljs-number">0</span> ? c0 : <span class="hljs-number">2</span> + (c2 ? c2 + c3 : <span class="hljs-number">0</span>);<font></font>
        }</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boucle principale et grande queue. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le cycle de traitement principal, nous divisons les donn√©es: si elles sont suffisamment longues, nous traitons 128, 64, 32 ou 16 octets chacune. </font><font style="vertical-align: inherit;">Il est logique de traiter 128 chacun: en parall√®le, nous utilisons plusieurs canaux de processeur (plusieurs pipelines) et un processeur superscalaire.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> ( ; unlikely(s + <span class="hljs-number">128</span> &lt;= end); s += <span class="hljs-number">128</span>) {<font></font>
        n = match_symbols_mask128_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">128</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">64</span> &lt;= end)) {<font></font>
        n = match_symbols_mask64_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">64</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">64</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">32</span> &lt;= end)) {<font></font>
        n = match_symbols_mask32_c(__C.URI_BM, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">32</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">32</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (unlikely(s + <span class="hljs-number">16</span> &lt;= end)) {<font></font>
        n = match_symbols_mask16_c(__C.URI_BM128, s);<font></font>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">16</span>)
                <span class="hljs-keyword">return</span> s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str + n;<font></font>
        s += <span class="hljs-number">16</span>;<font></font>
}</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queue. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fin de la fonction est similaire au d√©but. </font><font style="vertical-align: inherit;">Si nous avons moins de 16 octets, nous traitons 4 octets en boucle, puis pas plus de 3 octets √† la fin.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">while</span> (s + <span class="hljs-number">4</span> &lt;= end) {<font></font>
        c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
        c1 = uri_a[s[<span class="hljs-number">1</span>]];<font></font>
        c2 = uri_a[s[<span class="hljs-number">2</span>]];<font></font>
        c3 = uri_a[s[<span class="hljs-number">3</span>]];
        <span class="hljs-keyword">if</span> (!(c0 &amp; c1 &amp; c2 &amp; c3)) {<font></font>
                n = s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str;
                <span class="hljs-keyword">return</span> !(c0 &amp; c1) ? n + c0 : n + <span class="hljs-number">2</span> + (c2 ? c2 + c3 : <span class="hljs-number">0</span>);<font></font>
        }<font></font>
        s += <span class="hljs-number">4</span>;<font></font>
}<font></font>
<font></font>
c0 = c1 = c2 = <span class="hljs-number">0</span>;
<span class="hljs-keyword">switch</span> (end - s) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                c2 = uri_a[s[<span class="hljs-number">2</span>]];
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                c1 = uri_a[s[<span class="hljs-number">1</span>]];
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                c0 = uri_a[s[<span class="hljs-number">0</span>]];<font></font>
}<font></font>
<font></font>
n = s - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)str;
<span class="hljs-keyword">return</span> !(c0 &amp; c1) ? n + c0 : n + <span class="hljs-number">2</span> + c2;</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous chargeons des masques de bits et des donn√©es -</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> c'est l'algorithme principal du corps principal de la fonction. Nous pr√©sentons un tableau ASCII (comme dans l'image) avec 16 lignes et 8 colonnes. Tout d'abord, nous codons nos lignes de table dans le premier registre de BM URI: la premi√®re et la deuxi√®me ligne. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9l/cv/k2/9lcvk2_wg7qs6svdibpx9m1b09c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les symboles r√©els que nous autorisons sont </font></font><code>0 @ P p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>2 B R q R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ils sont cod√©s comme suit: </font></font><code>b8 = inv(1011 1000) = 0 @ P p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>f8 = inv(1111 1000) = 2 B R q R</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous encodons dans l'ordre inverse: nous commen√ßons √† 0, le premier caract√®re de service n'est pas autoris√©, puis les unit√©s sont ce qui est autoris√©. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©finissez les masques de bits ASCII.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Par exemple, une ligne entre </font></font><code>"pr"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: le premier caract√®re de la premi√®re ligne est ASCII, le second de la deuxi√®me ligne. Nous ex√©cutons l'instruction shuffle, qui m√©lange nos lignes de table cod√©es conform√©ment √† l'ordre de ces caract√®res dans l'entr√©e.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_i/zr/ol/_izrolii19qo5olblx0zzjgq_iu.jpeg"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ID de colonne pour l'entr√©e.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ensuite, nous pla√ßons les colonnes de la table ASCII dans un registre diff√©rent. Ensuite, nous ¬´croisons¬ª les registres de colonnes et de lignes, et nous obtenons une correspondance: notre caract√®re ou non. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme les colonnes sont les 4 bits les plus significatifs de l'octet, nous nous d√©pla√ßons vers la gauche. AVX a un d√©calage de seulement 2 octets, donc d√©placez d'abord l'octet, puis n avec notre masque pour obtenir uniquement des bits significatifs. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d9/xy/xr/d9xyxrmjyplbnhkpwrxbqblians.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disposition des colonnes ASCII</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ex√©cutez le deuxi√®me m√©lange, d√©placez la colonne vers les positions souhait√©es. Dans les deux cas, l'octet d'entr√©e de la derni√®re colonne, donc dans la premi√®re et la deuxi√®me position, nous obtenons la m√™me colonne. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/g1/2s/hxg12sn4xw-qlt7miq97k0pnwgy.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intersection de colonnes et de rang√©es de masques</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nous faisons </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(¬´croiser¬ª les colonnes avec des colonnes) et nous obtenons que les donn√©es d'entr√©e sont valides - le r√©sultat</font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de l'intersection des colonnes et des lignes n'est pas z√©ro. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cd/oa/kw/cdoakwgjf-oipltg_xeyyglobn8.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comptez le nombre de z√©ros √† la fin. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous collectons tout cela √† partir du vecteur </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et le renvoyons √† la sortie - tout simplement. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/f9/ci/tl/f9citlkgsjvtxifi9qe3pdxu7su.png"><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personnalisez les alphabets. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En travaillant avec la table ASCII, nous obtenons une fonctionnalit√© bon march√©: nous utilisons des tables statiques, mais rien ne nous emp√™che de demander √† l'utilisateur quel alphabet est disponible pour les URI, les noms et les valeurs des diff√©rents en-t√™tes. </font><font style="vertical-align: inherit;">La demande d'URI HTTP et l'en-t√™te utilisent 8 alphabets (plus ou moins) pour analyser une demande HTTP. </font><font style="vertical-align: inherit;">Ces tables peuvent √™tre charg√©es dans le m√™me code et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compar√©es dans un seul alphabet sp√©cifi√© par l'utilisateur, un</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> URI valide. </font><font style="vertical-align: inherit;">Sinon, c'est diff√©rent.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attaques</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelques cas o√π cela peut √™tre utile. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attaque SSRF avec BlackHat'17</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (¬´Une nouvelle √®re de SSRF¬ª): </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://foo@evil.com:80@google.com/</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- un symbole esperluette improbable. </font><font style="vertical-align: inherit;">Dans certaines applications, il est utilis√©, dans d'autres non. </font><font style="vertical-align: inherit;">Mais si vous ne l'utilisez pas, vous pouvez l'exclure de l'alphabet valide et l'attaque sera bloqu√©e. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-Attaque RCE:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬´efficace est l'effectuer des </font><font style="vertical-align: inherit;">attaques par injection de commandes comme¬ª, BSides'16: </font></font><code>User-Agent: ...;echo NAELBD$((26+58))$echo(echo NAELBD)NAELBD...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">L'agent utilisateur est un en-t√™te statique, mais il existe des cas d'attaque RCE lorsque certains sont livr√©s </font></font><code>shell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec des caract√®res atypiques pour l'agent utilisateur. </font><font style="vertical-align: inherit;">Nous nous prot√©geons sauf pour le signe dollar. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âcrasement du chemin relatif</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Le dernier cas est celui de Google en 2016. </font><font style="vertical-align: inherit;">Des accolades, des deux points, sont venus √† l'URI </font></font><code>.../gallery?q=%0a{}*{background:red}/..//apis/howto_guide.html</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ce sont des caract√®res improbables qui peuvent √™tre exclus de l'alphabet.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strcasecmp ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci est un code assez trivial. </font><font style="vertical-align: inherit;">Nous comparons √©galement des cha√Ænes de 32 octets, deux tableaux chacune.</font></font><br>
<br>
<pre><code class="cpp hljs">__m256i CASE = _mm256_set1_epi8(<span class="hljs-number">0x20</span>);<font></font>
<font></font>
<span class="hljs-comment">// Hacker‚Äôs Delight for signed comparison: -0x80 for both operands</span>
__m256i A = _mm256_set1_epi8(<span class="hljs-string">'A'</span> ‚Äì <span class="hljs-number">0x80</span>);<font></font>
__m256i D = _mm256_set1_epi8(<span class="hljs-string">'Z'</span> - <span class="hljs-string">'A'</span> + <span class="hljs-number">1</span> ‚Äì <span class="hljs-number">0x80</span>);<font></font>
<font></font>
<span class="hljs-comment">// Hacker‚Äôs Delight: 'a' &lt;= v &lt;= 'z' to</span>
<span class="hljs-comment">// v - ('a' ‚Äì 0x80) &lt; 'z' - 'a' + 1 - 0x80</span><font></font>
__m256i sub = _mm256_sub_epi8(str1, A);<font></font>
__m256i cmp_r = _mm256_cmpgt_epi8(D, sub);<font></font>
__m256i lc = _mm256_and_si256(cmp_r, CASE);<font></font>
__m256i vl = _mm256_or_si256(str1, lc);<font></font>
__m256i eq = _mm256_cmpeq_epi8(vl, str2);<font></font>
<span class="hljs-keyword">return</span> ~_mm256_movemask_epi8(eq);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous ne donnons au registre qu'une seule ligne, car dans la seconde nous avons programm√© les constantes dans notre analyseur en minuscules. </font><font style="vertical-align: inherit;">Puisque nous avons des comparaisons significatives, nous soustrayons 128 de chaque octet (une astuce de Hacker's Delight). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous comparons √©galement la plage d'un caract√®re valide: que nous puissions nous inscrire pour cette cha√Æne ou non, est-ce une lettre ou non. </font><font style="vertical-align: inherit;">Au moment de v√©rifier cela, au lieu de deux comparaisons de a √† z, nous pouvons utiliser une seule comparaison (une astuce de Hacker's Delight) et passer √† une constante.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performances strcasecmp ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempesta est beaucoup plus rapide que GLIBC, m√™me la nouvelle version (18 ou 19). </font><font style="vertical-align: inherit;">Le code </font></font><code>strcasecmp()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilise √©galement AVX, mais pas la deuxi√®me version. </font><font style="vertical-align: inherit;">AVX2 est plus rapide, donc Tempesta a un code plus rapide.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/zi/pb/wxzipbzdsbvge8u_abhsnok-gfa.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPU du noyau Linux</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous utilisons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des extensions de processeur vectoriel</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - elles sont disponibles dans le noyau. Les instructions vectorielles sont trait√©es par le module processeur FPU. Ce n'est pas le module processeur principal, pas les registres principaux, mais assez volumineux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par cons√©quent, il existe une optimisation sous Linux. Si nous passons du noyau √† l'espace utilisateur et vice-versa, nous ne sauvegardons pas le contexte des registres FPU (XMM, YMM, ZMM): nous changeons le contexte des seuls registres du module processeur principal. Il est suppos√© que le noyau du syst√®me d'exploitation ne fonctionne pas avec l'extension vectorielle du processeur. Mais si vous en avez besoin, par exemple, la cryptographie peut le faire, mais vous devez utiliser </font></font><code>fpu_begin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>fpu_end</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enregistrer et restaurer le contexte du registre FPU:</font></font><br>
<br>
<pre><code class="cpp hljs">__kernel_fpu_begin_bh();<font></font>
memcpy_avx(dst, src, n);<font></font>
__kernel_fpu_end_bh();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce sont des macros natives qui </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enregistrent et restaurent l'√©tat du module processeur</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est responsable des registres vectoriels. </font><font style="vertical-align: inherit;">Ce sont des ressources assez lentes.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX et SSE</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant les rep√®res de sauvegarde et de restauration du contexte FPU, quelques mots sur les op√©rations vectorielles. </font><font style="vertical-align: inherit;">Pourquoi parfois il est logique de travailler avec un assembleur? </font><font style="vertical-align: inherit;">Parfois, GCC g√©n√®re du code sous-optimal. </font><font style="vertical-align: inherit;">Le probl√®me est que sur les anciens mod√®les de processeurs, la transition de SSE √† AVX pr√©sente une p√©nalit√© importante. </font><font style="vertical-align: inherit;">GCC a une nouvelle cl√© </font></font><code>vzeroupper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- utilisez-la pour qu'elle ne g√©n√®re pas cette instruction </font></font><code>vzeroupper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui efface les registres et supprime cette p√©nalit√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous devez utiliser cette instruction uniquement si vous travaillez avec un ancien code qui a √©t√© compil√© pour SSE par un tiers. </font><font style="vertical-align: inherit;">Ce n'est pas notre cas et nous pouvons jeter ces instructions en toute s√©curit√©.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vectorisation automatique</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans le processeur. Cela signifie que dans tout code d'espace utilisateur, il y aura des op√©rations vectorielles. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/n9/vy/0w/n9vy0wal4alh1eelo1rbdjabavc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deux processus du syst√®me utilisent des extensions de processeur vectoriel. Lorsque votre processus passe au noyau et vice-versa, vous ne perdez pas de temps √† √©conomiser et √† restaurer l'√©tat vectoriel du processeur. Mais si vous passez d'un espace utilisateur √† un autre (changement de contexte), en plus du fait que les caches de premier niveau y sont d√©sactiv√©s, le module de changement de contexte sur FPU begin / end fonctionne √©galement mal. L'op√©ration est assez co√ªteuse - une micro-r√©f√©rence.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les microbenchmarks, tout est toujours dramatique, mais l'op√©ration co√ªte tr√®s cher. </font><font style="vertical-align: inherit;">Par cons√©quent, dans l'espace utilisateur, changez le contexte pendant longtemps. </font><font style="vertical-align: inherit;">Dans le noyau, nous n'avons pas de changement de contexte, donc tout est rapide. </font><font style="vertical-align: inherit;">Nous enregistrons et restaurons le processeur vectoriel une seule fois pour un ensemble de packages suffisamment volumineux.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intelpocalypse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au d√©but, j'ai montr√© une option de table de recherche pour optimiser le code du commutateur: un long processus, √©num√©rer, compiler la table de commutateur dans un tableau et suivre le double d√©r√©f√©rencement du pointeur qui saute sur ce tableau. Il s'agit d'un sc√©nario pour une attaque Spectre qui exploite l'ex√©cution sp√©culative. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google a un bon </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur la fa√ßon dont le double d√©r√©f√©rencement des pointeurs dans les compilateurs modernes est organis√© en ce moment (depuis le d√©but de 2018). Cela ne fonctionne pas tr√®s bien. Si plus t√¥t dans le registre, une adresse a √©t√© enregistr√©e et que nous sommes all√©s √† cette adresse, nous avons maintenant un code diff√©rent.</font></font><br>
<br>
<pre><code class="cpp hljs">jmp *%r11 <font></font>
    call l1<font></font>
l0: pause<font></font>
    lfence<font></font>
    jmp l0<font></font>
l1: mov %r11, (%rsp)<font></font>
    ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment √ßa marche? On ¬´appelle¬ª la fonction sur l1, le processus passe √† cette √©tiquette et on fait un hack: comme si on revenait d'une fonction (qui ne l'est pas), mais on r√©√©crit l'adresse de retour. Lorsque nous faisons l'instruction </font></font><code>call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">nous pla√ßons </font><font style="vertical-align: inherit;">l'adresse de retour, l'adresse actuelle sur la pile, la r√©√©crivons avec le contenu n√©cessaire du registre et passons √† l1. Mais le processeur, lorsque son pr√©fet est en cours d'ex√©cution, voit qu'il y a une fonction, puis une barri√®re. En cons√©quence, tout sera lent - il jette la pr√©lecture et nous nous d√©barrassons de la vuln√©rabilit√© Spectre. Le code est lent, les performances baissent de 15%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La prochaine attaque relativement nouvelle est </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meltdown.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il est sp√©cifique aux processus de l'espace utilisateur uniquement. </font><font style="vertical-align: inherit;">La lecture de la m√©moire du noyau depuis l'espace utilisateur est tr√®s p√©nible. </font><font style="vertical-align: inherit;">L'attaque est emp√™ch√©e par le Kernel Pate Table Isolation (KPTI), qui se compile dans les nouveaux noyaux par d√©faut. </font><font style="vertical-align: inherit;">Mais KPTI est tr√®s cher, jusqu'√† 30-40% de d√©gradation des performances ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tel que mesur√© par MariaDB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela est d√ª au fait que vous n'avez plus d'optimisation TLB paresseuse: l'espace d'adressage du noyau et du processeur est compl√®tement s√©par√© dans diff√©rentes tables de pages (avant, TLB paresseux continuait de mapper l'espace du noyau √† la table de pages de chaque processus). </font><font style="vertical-align: inherit;">C'est p√©nible pour l'espace utilisateur, mais pas pour Tempesta FW, qui fonctionne compl√®tement dans le noyau. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelques liens utiles:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://natsys-lab.blogspot.com/2014/11/the-fast-finite-state-machine-for-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machine √† √©tats finis rapide pour l'analyse HTTP</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://natsys-lab.blogspot.com/2016/10/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traitement des cha√Ænes HTTP √† l'aide de C, SSE4.2 et AVX2</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©lice du pirate</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meltdown et Specter attaquent les documents</font></font></a></li>
</ul><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Intelpocalypse: goodbye fast system calls</a></li>
</ul><br>
<blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Saint HighLoad++</a>        .       , 6   -- (  ,      Saint HighLoad++)  ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> web </a>. <br>
<br>
     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PHP Russia</a>: 13   ,  .       ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">KnowledgeConf</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">++</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TechLead Conf</a> ‚Äî     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>  , ,    .<br>
</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr493226/index.html">Comment lire et corriger 100 000 lignes de code par semaine</a></li>
<li><a href="../fr493230/index.html">Nouveau Google PageSpeed ‚Äã‚ÄãInsights optimis√© par Lighthouse 6 (b√™ta): v√©rifiez les performances de votre site</a></li>
<li><a href="../fr493232/index.html">L'histoire de mon travail chez Open Product LLC</a></li>
<li><a href="../fr493234/index.html">ING lance Lion: une biblioth√®que de composants Web productifs, abordables et flexibles</a></li>
<li><a href="../fr493236/index.html">Ast√©risque: troncs externes √† l'√©tat Demande envoy√©e</a></li>
<li><a href="../fr493244/index.html">Que peut un ordinateur quantique</a></li>
<li><a href="../fr493248/index.html">Webinaire "Opportunit√©s de Winnum pour l'analyse industrielle"</a></li>
<li><a href="../fr493250/index.html">Que se passe-t-il avec les voyages en ce moment - et comment vous prot√©ger dans les transports</a></li>
<li><a href="../fr493252/index.html">Exp√©rience d'enseignement dans une √©cole de d√©veloppement, ou pourquoi vous devez aller √† l'√©cole apr√®s l'universit√©</a></li>
<li><a href="../fr493254/index.html">Le syst√®me d'√©coute √©lectronique de masse de la population √©tait pratiquement inutile pour le FBI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>