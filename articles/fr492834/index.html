<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👩🏾 👃 👩🏾‍✈️ Qu'est-ce qui est commun entre LVM et matriochka? 🖖🏿 💕 💇🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonne journée. 
 Je veux partager avec la communauté une expérience pratique dans la construction d'un système de stockage pour KVM utilisant md RAID ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Qu'est-ce qui est commun entre LVM et matriochka?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492834/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonne journée. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je veux partager avec la communauté une expérience pratique dans la construction d'un système de stockage pour KVM utilisant md RAID + LVM. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le programme:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Construisez md RAID 1 à partir du SSD NVMe.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créez md RAID 6 à partir de disques SSD SATA et de disques ordinaires.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caractéristiques du TRIM / DISCARD sur SSD RAID 1/6.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Création d'une matrice RAID 1/6 md amorçable sur un ensemble commun de disques.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installation du système sur NVMe RAID 1 s'il n'y a pas de prise en charge NVMe dans le BIOS.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation du cache LVM et du LVM thin.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation d'instantanés BTRFS et envoi / réception pour la sauvegarde.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation d'instantanés légers LVM et thin_delta pour la sauvegarde de style BTRFS.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous êtes intéressé, s'il vous plaît, sous cat.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Déclaration</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'auteur n'assume aucune responsabilité pour les conséquences de l'utilisation ou de la non-utilisation des matériaux / exemples / code / conseils / données de cet article. </font><font style="vertical-align: inherit;">En lisant ou en utilisant ce matériel de quelque manière que ce soit, vous assumez la responsabilité de toutes les conséquences de ces actions. </font><font style="vertical-align: inherit;">Les conséquences possibles incluent:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSD Crispy Fried NVMe.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complètement épuisé les ressources d'enregistrement et les pannes de disques SSD.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perte complète de toutes les données sur tous les disques, y compris les sauvegardes.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matériel informatique défectueux.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A passé du temps, des nerfs et de l'argent.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout autre effet non mentionné ci-dessus.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le fer</font></font></h2><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En stock était:</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La carte mère est vers 2013 sur le chipset Z87 complet avec Intel Core i7 / Haswell.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CPU 4 cœurs, 8 threads</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 32 gigaoctets de RAM DDR3</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 x 16 ou 2 x 8 PCIe 3.0</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 x 4 + 1 x 1 PCIe 2.0</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Connecteurs SATA 3 6 x 6 Go / s </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'adaptateur SAS LSI SAS9211-8I a flashé en mode IT / HBA. </font><font style="vertical-align: inherit;">Le micrologiciel compatible RAID a été intentionnellement remplacé par le micrologiciel HBA pour:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il était possible à tout moment de jeter cet adaptateur et de le remplacer par tout autre premier.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TRIM / Discard fonctionnait normalement sur les disques, </font><font style="vertical-align: inherit;">dans le firmware RAID, ces commandes ne sont pas du tout prises en charge et HBA, en général, ne se soucie pas des commandes à envoyer sur le bus.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Disques durs - 8 pièces de HGST Travelstar 7K1000 avec un volume de 1 To au format 2,5, comme pour les ordinateurs portables. </font><font style="vertical-align: inherit;">Ces disques étaient auparavant dans une matrice RAID 6. </font><font style="vertical-align: inherit;">Dans le nouveau système, ils trouveront également une application. </font><font style="vertical-align: inherit;">Pour stocker des sauvegardes locales.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, il a été ajouté:</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 pièces de SSD SATA modèle Samsung 860 QVO 2 To. </font><font style="vertical-align: inherit;">Ces SSD nécessitaient une grande quantité, la présence d'un cache SLC, la fiabilité est souhaitable et un prix bas. </font><font style="vertical-align: inherit;">Obligatoire était la prise en charge de la suppression / zéro qui est vérifiée par une ligne en dmesg: </font></font><br>
<br>
<code>kernel: ata1.00: Enabling discard_zeroes_data</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 pièces de modèle NVMe SSD Samsung SSD 970 EVO 500GB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ces SSD, une vitesse de lecture / écriture aléatoire et une ressource adaptée à vos besoins sont importantes. </font><font style="vertical-align: inherit;">Radiateur à eux. </font><font style="vertical-align: inherit;">Obligatoire. </font><font style="vertical-align: inherit;">Absolument nécessaire. </font><font style="vertical-align: inherit;">Sinon, faites-les frire jusqu'à ce qu'elles soient croustillantes lors de la première synchronisation RAIDa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adaptateur StarTech PEX8M2E2 pour 2 disques SSD NVMe avec emplacement PCIe 3.0 8x. Encore une fois, ce n'est que du HBA, mais pour NVMe. Il diffère des adaptateurs bon marché en l'absence de la prise en charge de la bifurcation PCIe depuis la carte mère en raison de la présence d'un commutateur PCIe intégré. Il fonctionnera même dans le système le plus ancien où il y a PCIe, même s'il s'agit d'un emplacement x1 PCIe 1.0. Naturellement, avec la vitesse appropriée. Il n'y a pas de RAID là-bas. Il n'y a pas de BIOS intégré à bord. Ainsi, votre système n'apprendra pas par magie à démarrer à partir de NVMe, et encore moins à faire NVMe RAID grâce à cet appareil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce composant a été causé uniquement par la présence d'un seul PCIe 3.0 8x gratuit dans le système et, en présence de 2 emplacements libres, il est facilement remplacé par deux PEX4M2E1 ou analogues bon marché, qui peuvent être achetés n'importe où au prix de 600 roubles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le refus de tout type de matériel ou de chipsets RAID / BIOS intégrés a été fait délibérément, afin de pouvoir remplacer complètement l'ensemble du système, à l'exception du SSD / HDD lui-même, en sauvegardant toutes les données. </font><font style="vertical-align: inherit;">Idéalement, il serait possible de conserver même le système d'exploitation installé lors du passage à un matériel complètement nouveau / différent. </font><font style="vertical-align: inherit;">L'essentiel est qu'il existe des ports SATA et PCIe. </font><font style="vertical-align: inherit;">C'est comme un CD live ou un lecteur flash amorçable, seulement très rapide et un peu surdimensionné.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Humour</font></font></b><div class="spoiler_text"> ,   , —          .     .            5.25  .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, et, bien sûr, pour expérimenter différentes méthodes de mise en cache SSD sous Linux.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les incursions matérielles, c'est ennuyeux. </font><font style="vertical-align: inherit;">Allumer. </font><font style="vertical-align: inherit;">Cela fonctionne ou non. </font><font style="vertical-align: inherit;">Et avec mdadm, il y a toujours des options.</font></font></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doux</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auparavant, Debian 8 Jessie était installée sur le matériel, qui est proche d'EOL. </font><font style="vertical-align: inherit;">Le RAID 6 des disques durs mentionnés ci-dessus a été associé à LVM. </font><font style="vertical-align: inherit;">Il exécutait des machines virtuelles dans kvm / libvirt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parce que </font><font style="vertical-align: inherit;">L'auteur a l'expérience appropriée dans la création de lecteurs flash SATA / NVMe portables et également, afin de ne pas déchirer le modèle apt habituel, Ubuntu 18.04 a été choisi comme système cible, qui s'est déjà suffisamment stabilisé, mais a encore 3 ans de support à l'avenir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le système mentionné, tous les pilotes matériels dont nous avons besoin sont prêts à l'emploi. </font><font style="vertical-align: inherit;">Nous n'avons besoin d'aucun logiciel et pilote tiers.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Préparation pour l'installation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour installer le système, nous avons besoin d'Ubuntu Desktop Image. </font><font style="vertical-align: inherit;">Le système serveur possède une sorte de programme d'installation vigoureux qui présente une indépendance excessive et non déconnectable, poussant toujours la partition système UEFI sur l'un des disques, gâchant toute la beauté. </font><font style="vertical-align: inherit;">Par conséquent, il est installé uniquement en mode UEFI. </font><font style="vertical-align: inherit;">Il n'offre pas d'options. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela ne nous convient pas.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi?</font></font></b><div class="spoiler_text"> , UEFI        RAID, ..   UEFI ESP     .    ,    ESP     USB , ,   .      mdadm RAID 1    0.9    UEFI BIOS   , ,       BIOS       -  ESP     .<br>
<br>
 ,  UEFI   NVRAM,         , ..    .<br>
<br>
 ,      .     ,       Legacy/BIOS boot,    CSM  UEFI- .      , ,      .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La version de bureau d'Ubuntu ne sait pas non plus comment s'installer normalement avec le chargeur de démarrage hérité, mais ici, comme on dit, il y a au moins des options. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et donc, collectez le matériel et chargez le système à partir du lecteur flash Ubuntu Live amorçable. </font><font style="vertical-align: inherit;">Nous devrons télécharger des packages, nous avons donc mis en place le réseau qui vous a valu. </font><font style="vertical-align: inherit;">Si cela ne fonctionne pas, vous pouvez télécharger à l'avance les packages nécessaires sur la clé USB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons dans l'environnement de bureau, exécutons l'émulateur de terminal et allons-y:</font></font><br>
<br>
<code>#sudo bash</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment...?</font></font></b><div class="spoiler_text">       sudo.  <b></b>    <b></b> .   ,       .     sudo   ,     . :<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/W-tPTmdnc7E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
</div></div><br>
<code>#apt-get install mdadm lvm2 thin-provisioning-tools btrfs-tools util-linux lsscsi nvme-cli mc</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi pas ZFS ...?</font></font></b><div class="spoiler_text">       , —  ,         . <br>
        , —        ,   -  .<br>
<br>
    ZFS —  ,  mdadm+lvm    .<br>
<br>
           .      .   .  .  .  .      ,       . <br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi alors BTRFS ...?</font></font></b><div class="spoiler_text">            Legacy/BIOS GRUB  , ,  ,   -.      /boot .  ,       / ()   ,           LVM     . <br>
<br>
   ,          .<br>
                       send/recieve.<br>
<br>
 ,                        GPU  PCI-USB Host-  KVM  IOMMU.<br>
<br>
    —  ,    .<br>
<br>
    ZFS, ,  ,     .<br>
<br>
  ,       / RAID      ZFS, BRTFS  LVM.<br>
<br>
   , BTRFS       ,         /    HDD.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Analyser à nouveau tous les appareils: regardons autour de nous </font></font><br>
<br>
<code>#udevadm control --reload-rules &amp;&amp; udevadm trigger</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
:</font></font><br>
<br>
<code>#lsscsi &amp;&amp; nvme list<br>
[0:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sda <br>
[1:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sdb <br>
[2:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sdc <br>
[3:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sdd <br>
[4:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sde <br>
[5:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sdf <br>
[6:0:0:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdg <br>
[6:0:1:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdh <br>
[6:0:2:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdi <br>
[6:0:3:0] disk ATA HGST HTS721010A9 A3B0 /dev/sdj <br>
[6:0:4:0] disk ATA HGST HTS721010A9 A3B0 /dev/sdk <br>
[6:0:5:0] disk ATA HGST HTS721010A9 A3B0 /dev/sdl <br>
[6:0:6:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdm <br>
[6:0:7:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdn <br>
Node SN Model Namespace Usage Format FW Rev <br>
---------------- -------------------- ---------------------------------------- --------- -------------------------- ---------------- --------<br>
/dev/nvme0n1 S466NXXXXXXX15L Samsung SSD 970 EVO 500GB 1 0,00 GB / 500,11 GB 512 B + 0 B 2B2QEXE7<br>
/dev/nvme1n1 S5H7NXXXXXXX48N Samsung SSD 970 EVO 500GB 1 0,00 GB / 500,11 GB 512 B + 0 B 2B2QEXE7<br>
</code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partitionnement des "lecteurs"</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVMe SSD</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais en aucun cas nous ne les annotons. </font><font style="vertical-align: inherit;">Tout de même, notre BIOS ne voit pas ces disques. </font><font style="vertical-align: inherit;">Ainsi, ils iront entièrement au RAID logiciel. </font><font style="vertical-align: inherit;">Nous n'y créerons même pas de partitions. </font><font style="vertical-align: inherit;">Si vous voulez selon le "canon" ou le "principe" - créez une grande partition, comme un disque dur.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disque dur SATA</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'y a rien de spécial à inventer. </font><font style="vertical-align: inherit;">Nous créerons une section pour tout. </font><font style="vertical-align: inherit;">Nous allons créer la section car le BIOS voit ces disques et peut même essayer de démarrer à partir d'eux. </font><font style="vertical-align: inherit;">Nous installerons même GRUB plus tard sur ces disques afin que le système réussisse soudainement.</font></font><br>
<br>
<code>#cat &gt;hdd.part &lt;&lt; EOF<br>
label: dos<br>
label-id: 0x00000000<br>
device: /dev/sdg<br>
unit: sectors<br>
<br>
/dev/sdg1 : start= 2048, size= 1953523120, type=fd, bootable<br>
EOF<br>
#sfdisk /dev/sdg &lt; hdd.part<br>
#sfdisk /dev/sdh &lt; hdd.part<br>
#sfdisk /dev/sdi &lt; hdd.part<br>
#sfdisk /dev/sdj &lt; hdd.part<br>
#sfdisk /dev/sdk &lt; hdd.part<br>
#sfdisk /dev/sdl &lt; hdd.part<br>
#sfdisk /dev/sdm &lt; hdd.part<br>
#sfdisk /dev/sdn &lt; hdd.part<br>
</code><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSD SATA</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous avons le plus intéressant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Premièrement, nous avons 2 disques TB. </font><font style="vertical-align: inherit;">Ceci est dans les limites autorisées pour MBR, que nous utiliserons. </font><font style="vertical-align: inherit;">Si nécessaire, peut être remplacé par GPT. </font><font style="vertical-align: inherit;">Les disques GPT ont une couche de compatibilité qui permet aux systèmes compatibles MBR de voir les 4 premières partitions si elles se trouvent dans les 2 premiers téraoctets. </font><font style="vertical-align: inherit;">L'essentiel est que la partition de démarrage et la partition bios_grub sur ces disques soient au début. </font><font style="vertical-align: inherit;">Cela vous permet même de démarrer à partir du lecteur GPT Legacy / BIOS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais ce n'est pas notre cas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous allons créer deux sections. </font><font style="vertical-align: inherit;">Le premier sera de 1 Go et utilisé pour RAID 1 / boot. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le second sera utilisé pour RAID 6 et occupera tout l'espace libre restant à l'exception d'une petite zone non allouée à la fin du lecteur.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle est la zone non allouée?</font></font></b><div class="spoiler_text">     SATA SSD      SLC    6  78 . 6    «»     «»  «»   .  72      . <br>
<br>
  ,     SLC,      4 bit MLC.     ,    4       1  SLC .<br>
<br>
 72   4   288 .           ,       SLC .<br>
<br>
 ,     312  SLC     .    2    RAID  .<br>
<br>
            ,      .        QLC , —          .      , ,       ,    SSD     TBW  .<br>
</div></div><br>
<code>#cat &gt;ssd.part &lt;&lt; EOF<br>
label: dos<br>
label-id: 0x00000000<br>
device: /dev/sda<br>
unit: sectors<br>
<br>
/dev/sda1 : start= 2048, size= 2097152, type=fd, bootable<br>
/dev/sda2 : start= 2099200, size= 3300950016, type=fd<br>
EOF<br>
#sfdisk /dev/sda &lt; ssd.part<br>
#sfdisk /dev/sdb &lt; ssd.part<br>
#sfdisk /dev/sdc &lt; ssd.part<br>
#sfdisk /dev/sdd &lt; ssd.part<br>
#sfdisk /dev/sde &lt; ssd.part<br>
#sfdisk /dev/sdf &lt; ssd.part<br>
</code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Création de tableaux</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous devons d'abord renommer la voiture. </font><font style="vertical-align: inherit;">Cela est nécessaire car le nom d'hôte fait partie du nom du tableau quelque part dans mdadm et affecte quelque chose quelque part. </font><font style="vertical-align: inherit;">Les tableaux, bien sûr, peuvent être renommés plus tard, mais ce sont des actions inutiles.</font></font><br>
<br>
<code>#mcedit /etc/hostname <br>
#mcedit /etc/hosts<br>
#hostname<br>
vdesk0<br>
</code><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVMe SSD</font></font></h4><br>
<code>#mdadm --create --verbose --assume-clean /dev/md0 --level=1 --raid-devices=2 /dev/nvme[0-1]n1</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi - assumer-nettoyer ...?</font></font></b><div class="spoiler_text">   .    RAID 1  6  .      ,    .  ,   SSD   —     TBW.   TRIM/DISCARD      SSD   «».<br>
<br>
  SSD RAID 1 DISCARD   .<br>
<br>
  SSD RAID 6 DISCARD      . <br>
<br>
      ,    SSD     4/5/6       discard_zeroes_data.    ,       , , -,  ,     .       , ,       .     DISCARD -   RAID 6.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Attention, la commande suivante détruira toutes les données sur les disques NVMe en «initialisant» la baie avec des «zéros». </font></font><br>
<br>
<code>#blkdiscard /dev/md0</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cas de problème, essayez de spécifier une étape.</font></font><br>
<br>
<code>#blkdiscard --step 65536 /dev/md0</code><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSD SATA</font></font></h4><br>
<code>#mdadm --create --verbose --assume-clean /dev/md1 --level=1 --raid-devices=6 /dev/sd[a-f]1</code><br>
<code>#blkdiscard /dev/md1</code><br>
<code>#mdadm --create --verbose --assume-clean /dev/md2 --chunk-size=512 --level=6 --raid-devices=6 /dev/sd[a-f]2</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi si gros ...?</font></font></b><div class="spoiler_text"> chunk-size         chunk-size .   ,              . , IOPS    .   99% IO   512K.<br>
<br>
 RAID 6 IOPS   <b></b>    IOPS   .      IOPS          ,       . <br>
           RAID 6 by-design     ,   RAID 6   .<br>
   RAID 6      NVMe    thin-provisioning.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous n'avons pas encore activé DISCARD pour RAID 6. Nous n'allons donc pas encore «initialiser» cette baie. </font><font style="vertical-align: inherit;">Nous le ferons plus tard, après avoir installé le système d'exploitation.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disque dur SATA</font></font></h4><br>
<code>#mdadm --create --verbose --assume-clean /dev/md3 --chunk-size=512 --level=6 --raid-devices=8 /dev/sd[g-n]1</code><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LVM sur NVMe RAID</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour la vitesse, nous voulons placer la racine FS sur NVMe RAID 1 qui est / dev / md0. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Néanmoins, nous avons toujours besoin de ce tableau rapide pour d'autres besoins, tels que le swap, les métadonnées et le cache LVM et les métadonnées LVM-thin, par conséquent, sur ce tableau, nous créerons LVM VG. </font><font style="vertical-align: inherit;">
Créez une partition pour le FS racine. </font><font style="vertical-align: inherit;">
Créez une section pour échanger la taille de la RAM.</font></font><br>
<br>
<code>#pvcreate /dev/md0<br>
#vgcreate root /dev/md0</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 128G --name root root</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 32G --name swap root</code><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installation du système d'exploitation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au total, nous avons tout le nécessaire pour installer le système. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lancez l'assistant d'installation à partir de l'environnement Ubuntu Live. </font><font style="vertical-align: inherit;">Installation normale. </font><font style="vertical-align: inherit;">Seulement au stade de la sélection des lecteurs pour l'installation, vous devez spécifier les éléments suivants:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / md1, - point de montage / démarrage, FS - BTRFS </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / root / root (alias / dev / mapper / root-root), - point de montage / (root), FS - BTRFS</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / root / swap (alias / dev / mapper / root-swap), - utiliser comme partition de swap</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installation du chargeur de démarrage sur / dev / sda</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous sélectionnez BTRFS comme racine FS, le programme d'installation crée automatiquement deux volumes BTRFS avec les noms "@" pour / (root) et "@home" pour / home. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous commençons l'installation ... L' </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
installation se terminera par une boîte de dialogue modale informant de l'erreur d'installation du chargeur de démarrage. </font><font style="vertical-align: inherit;">Malheureusement, sortir de ce dialogue par des moyens réguliers et poursuivre l'installation échouera. </font><font style="vertical-align: inherit;">Nous nous déconnectons du système et nous nous connectons à nouveau, en entrant dans le bureau Ubuntu Live propre. </font><font style="vertical-align: inherit;">Ouvrez le terminal, puis à nouveau: </font></font><br>
<br>
<code>#sudo bash</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
créez un environnement chroot pour continuer l'installation: configurez le </font><font style="vertical-align: inherit;">
réseau et le nom d'hôte dans chroot: </font><font style="vertical-align: inherit;">
accédez à l'environnement chroot: </font><font style="vertical-align: inherit;">
commencez par livrer les packages: </font><font style="vertical-align: inherit;">
vérifiez et réparez tous les packages qui ont été tordus en raison de l'installation incomplète du système:</font></font><br>
<br>
<code>#mkdir /mnt/chroot<br>
#mount -o defaults,space_cache,noatime,nodiratime,discard,subvol=@ /dev/mapper/root-root /mnt/chroot<br>
#mount -o defaults,space_cache,noatime,nodiratime,discard,subvol=@home /dev/mapper/root-root /mnt/chroot/home<br>
#mount -o defaults,space_cache,noatime,nodiratime,discard /dev/md1 /mnt/chroot/boot<br>
#mount --bind /proc /mnt/chroot/proc <br>
#mount --bind /sys /mnt/chroot/sys<br>
#mount --bind /dev /mnt/chroot/dev<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#cat /etc/hostname &gt;/mnt/chroot/etc/hostname<br>
#cat /etc/hosts &gt;/mnt/chroot/etc/hosts<br>
#cat /etc/resolv.conf &gt;/mnt/chroot/etc/resolv.conf<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#chroot /mnt/chroot<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>apt-get install --reinstall mdadm lvm2 thin-provisioning-tools btrfs-tools util-linux lsscsi nvme-cli mc debsums hdparm</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#CORRUPTED_PACKAGES=$(debsums -s 2&gt;&amp;1 | awk '{print $6}' | uniq)<br>
#apt-get install --reinstall $CORRUPTED_PACKAGES<br>
</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si quelque chose ne se développe pas ensemble, vous devrez peut-être </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
modifier </font><font style="vertical-align: inherit;">/etc/apt/sources.list avant cela. </font><font style="vertical-align: inherit;">Modifions les paramètres du module RAID 6 pour activer TRIM / DISCARD: Nous </font><font style="vertical-align: inherit;">
ajusterons légèrement nos tableaux:</font></font><br>
<br>
<code>#cat &gt;/etc/modprobe.d/raid456.conf &lt;&lt; EOF<br>
options raid456 devices_handle_discard_safely=1<br>
EOF<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#cat &gt;/etc/udev/rules.d/60-md.rules &lt;&lt; EOF<br>
SUBSYSTEM=="block", KERNEL=="md*", ACTION=="change", TEST=="md/stripe_cache_size", ATTR{md/stripe_cache_size}="32768"<br>
SUBSYSTEM=="block", KERNEL=="md*", ACTION=="change", TEST=="md/sync_speed_min", ATTR{md/sync_speed_min}="48000"<br>
SUBSYSTEM=="block", KERNEL=="md*", ACTION=="change", TEST=="md/sync_speed_max", ATTR{md/sync_speed_max}="300000"<br>
EOF<br>
#cat &gt;/etc/udev/rules.d/62-hdparm.rules &lt;&lt; EOF<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="1", RUN+="/sbin/hdparm -B 254 /dev/%k"<br>
EOF<br>
#cat &gt;/etc/udev/rules.d/63-blockdev.rules &lt;&lt; EOF<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="1", RUN+="/sbin/blockdev --setra 1024 /dev/%k"<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="0", RUN+="/sbin/blockdev --setra 0 /dev/%k"<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="nvme[0-9]n1", RUN+="/sbin/blockdev --setra 0 /dev/%k"<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="dm-*", ATTR{queue/rotational}=="0", RUN+="/sbin/blockdev --setra 0 /dev/%k"<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="md*", RUN+="/sbin/blockdev --setra 0 /dev/%k"<br>
<br>
EOF<br>
</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce que c'était..?</font></font></b><div class="spoiler_text">   udev     :<br>
<br>
<ul>
<li>    2020-      RAID 6.  -, ,      Linux,     .</li>
<li>    /   IO.  ,           .</li>
<li>    /   IO.  ,  / SSD RAID-       .    NVMe. (   ?    . )</li>
<li>   APM     (HDD)         7 .    APM      (-B 255).   -      .      ,   , ,  -.       .    -        .     , , - «»,    -,    RAID-   mini-MAID-.</li>
<li> readahead   ()  1  —   /chunk RAID 6</li>
<li> readahead  SATA SSD</li>
<li> readahead  NVMe SSD</li>
<li> readahead   LVM    SSD.</li>
<li> readahead   RAID .</li>
</ul><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modifiez / etc / fstab:</font></font><br>
<br>
<code>#cat &gt;/etc/fstab &lt;&lt; EOF<br>
# /etc/fstab: static file system information.<br>
#<br>
# Use 'blkid' to print the universally unique identifier for a<br>
# device; this may be used with UUID= as a more robust way to name devices<br>
# that works even if disks are added and removed. See fstab(5).<br>
# file-system mount-point type options dump pass<br>
/dev/mapper/root-root / btrfs defaults,space_cache,noatime,nodiratime,discard,subvol=@ 0 1<br>
UUID=$(blkid -o value -s UUID /dev/md1) /boot btrfs defaults,space_cache,noatime,nodiratime,discard 0 2<br>
/dev/mapper/root-root /home btrfs defaults,space_cache,noatime,nodiratime,discard,subvol=@home 0 2<br>
/dev/mapper/root-swap none swap sw 0 0<br>
EOF</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi donc..?</font></font></b><div class="spoiler_text"> /boot     UUID ..     .<br>
<br>
      LVM    /dev/mapper/vg-lv, ..     . <br>
<br>
  UUID  LVM .. UUID  LVM      .</div></div><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous montons deux fois / dev / mapper / root-root ..?</font></font></b><div class="spoiler_text">.  .  BTRFS.         subvol.<br>
<br>
  -      LVM   BTRFS .     .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous régénérons la configuration mdadm: </font><font style="vertical-align: inherit;">
Corrigez les paramètres LVM:</font></font><br>
<br>
<code>#/usr/share/mdadm/mkconf | sed 's/#DEVICE/DEVICE/g' &gt;/etc/mdadm/mdadm.conf<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#cat &gt;&gt;/etc/lvm/lvmlocal.conf &lt;&lt; EOF<br>
<br>
activation {<br>
 thin_pool_autoextend_threshold=90<br>
 thin_pool_autoextend_percent=5<br>
}<br>
allocation {<br>
 cache_pool_max_chunks=2097152<br>
}<br>
devices {<br>
 global_filter=["r|^/dev/.*_corig$|","r|^/dev/.*_cdata$|","r|^/dev/.*_cmeta$|","r|^/dev/.*gpv$|","r|^/dev/images/.*$|","r|^/dev/mapper/images.*$|","r|^/dev/backup/.*$|","r|^/dev/mapper/backup.*$|"]<br>
 issue_discards=1<br>
}<br>
EOF<br>
</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce que c'était..?</font></font></b><div class="spoiler_text">     LVM thin   90%    5%  .<br>
<br>
       LVM cache.<br>
<br>
  LVM  LVM  (PV) :<br>
<br>
<ul>
<li>   LVM cache (cdata)</li>
<li>     LVM cache    (&lt;lv_name&gt;_corig).            ( &lt;lv_name&gt;).</li>
<li>    LVM cache (cmeta)</li>
<li>    VG   images.        , ,     LVM       .</li>
<li>    VG   backup.         .</li>
<li>       «gpv» ( guest physical volume )</li>
</ul><br>
   DISCARD      LVM VG.  .    LV  SSD  .     SSD RAID 6. ,  ,    thin provisioning,  ,     .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mettez à jour l'image initramfs: </font></font><br>
<br>
<code>#update-initramfs -u -k all</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Installez et configurez grub:</font></font><br>
<br>
<code>#apt-get install grub-pc<br>
#apt-get purge os-prober<br>
#dpkg-reconfigure grub-pc</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelles motivations choisir?</font></font></b><div class="spoiler_text">  sd*.         SATA   SSD.<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi os-prober cloué ..?</font></font></b><div class="spoiler_text">     . <br>
<br>
       RAID-    .      ,         .<br>
<br>
   ,   , ,    .         .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec cela, nous avons terminé l'installation initiale. </font><font style="vertical-align: inherit;">Il est temps de redémarrer dans le système d'exploitation nouvellement installé. </font><font style="vertical-align: inherit;">N'oubliez pas de retirer le Live CD / USB amorçable. </font><font style="vertical-align: inherit;">
Pour démarrer, sélectionnez l'un des SSD SATA.</font></font><br>
<br>
<code>#exit<br>
#reboot</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LVM vers SSD SATA</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À ce stade, nous avons déjà démarré dans le nouveau système d'exploitation, configuré le réseau, apt, ouvert l'émulateur de terminal et commencé: </font></font><br>
<br>
<code>#sudo bash</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Continuer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Initialiser" une matrice à partir d'un SSD SATA: </font></font><br>
<br>
<code>#blkdiscard /dev/md2</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si ce n'est pas le cas, essayez: </font></font><br>
<br>
<code>#blkdiscard --step 65536 /dev/md2</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créer LVM VG sur un SSD SATA:</font></font><br>
<br>
<code>#pvcreate /dev/md2<br>
#vgcreate data /dev/md2</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi un autre vg ..?</font></font></b><div class="spoiler_text">  ,     VG   root.        VG?<br>
<br>
  VG   PV,     VG  PV   (online).   LVM RAID,     .<br>
<br>
  ,    (  )    RAID 6           .<br>
<br>
 ,           «»   VG.<br>
<br>
 -,   RAID     « ».         ,    VG.<br>
<br>
 LVM  «»        RAID  -  . , —  <b></b> bcache + LVM thin, bcache + BTRFS, LVM cache + LVM thin,   ZFS       ,      .<br>
<br>
 «»   ,  - «» LVM-,   .    , ,     .<br>
<br>
,   ,     -   .<br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disque dur LVM vers SATA</font></font></h3><br>
<code>#pvcreate /dev/md3<br>
#vgcreate backup /dev/md3</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encore une fois le nouveau VG ..?</font></font></b><div class="spoiler_text">  ,     ,        ,      , -     . , -   VG, —    VG.<br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configurer le cache LVM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créez LV sur NVMe RAID 1 pour l'utiliser comme périphérique de mise en cache.</font></font><br>
<br>
<code>#lvcreate -L 70871154688B --name cache root</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi si peu ...?</font></font></b><div class="spoiler_text">  ,    NVMe SSD   SLC . 4  «»  18         3-bit MLC. -   NVMe SSD       SATA SSD  . ,        LVM cache      SLC  NVMe .   NVMe      32-64  . <br>
<br>
      64  ,       .<br>
<br>
 ,      LVM         .  ,       lvchange       . ,      .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créons LV sur SATA RAID 6 pour l'utiliser comme périphérique mis en cache.</font></font><br>
<br>
<code>#lvcreate -L 3298543271936B --name cache data</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi seulement trois téraoctets ..?</font></font></b><div class="spoiler_text">,  ,    SATA SSD RAID 6  -  .      ,  ,    .         , ,   LVM-cache , , bcache,  ,      .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créez un nouveau VG pour la mise en cache. </font><font style="vertical-align: inherit;">
Créez LV sur le périphérique mis en cache. </font><font style="vertical-align: inherit;">
Ici, nous avons immédiatement pris tout l'espace libre sur / dev / data / cache afin que toutes les autres partitions nécessaires soient créées immédiatement sur / dev / root / cache. </font><font style="vertical-align: inherit;">Si vous avez quelque chose qui n'y est pas créé, vous pouvez le déplacer à l'aide de pvmove. </font><font style="vertical-align: inherit;">
Créez et activez le cache:</font></font><br>
<br>
<code>#pvcreate /dev/root/cache<br>
#pvcreate /dev/data/cache<br>
#vgcreate cache /dev/root/cache /dev/data/cache</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 3298539077632B --name cachedata cache /dev/data/cache</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -y -L 64G -n cache cache /dev/root/cache<br>
#lvcreate -y -L 1G -n cachemeta cache /dev/root/cache<br>
#lvconvert -y --type cache-pool --cachemode writeback --chunksize 64k --poolmetadata cache/cachemeta cache/cache<br>
#lvconvert -y --type cache --cachepool cache/cache cache/cachedata<br>
</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi tant de gros morceaux ..?</font></font></b><div class="spoiler_text">     ,        LVM cache     LVM thin.  ,   ,        . <br>
<br>
64 —       LVM thin.<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attention l'écriture différée ..!</font></font></b><div class="spoiler_text">.         .    , ,    ,      .   ,  ,  NVMe RAID 1  ,    . <br>
<br>
    ,     RAID 6   .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vérifions que nous avons réussi: </font><font style="vertical-align: inherit;">
seul [cachedata_corig] doit se trouver sur / dev / data / cache. </font><font style="vertical-align: inherit;">Si quelque chose ne va pas, utilisez pvmove. </font><font style="vertical-align: inherit;">
Si nécessaire, vous pouvez désactiver le cache avec une seule commande: </font><font style="vertical-align: inherit;">
cela se fait en ligne. </font><font style="vertical-align: inherit;">LVM synchronise simplement le cache sur le disque, le supprime et renomme cachedata_corig en cachedata.</font></font><br>
<br>
<code>#lvs -a -o lv_name,lv_size,devices --units B cache<br>
 LV LSize Devices <br>
 [cache] 68719476736B cache_cdata(0) <br>
 [cache_cdata] 68719476736B /dev/root/cache(0) <br>
 [cache_cmeta] 1073741824B /dev/root/cache(16384)<br>
 cachedata 3298539077632B cachedata_corig(0) <br>
 [cachedata_corig] 3298539077632B /dev/data/cache(0) <br>
 [lvol0_pmspare] 1073741824B /dev/root/cache(16640)<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvconvert -y --uncache cache/cachedata</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuration fine LVM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons </font><font style="vertical-align: inherit;">
approximativement </font><font style="vertical-align: inherit;">estimer l'espace dont nous aurons besoin pour les métadonnées minces LVM </font><font style="vertical-align: inherit;">
: arrondir </font><font style="vertical-align: inherit;">à 4 gigaoctets: 4294967296B </font><font style="vertical-align: inherit;">Multiplier par deux et ajouter 4194304B pour les métadonnées LVM PV: 8594128896B </font><font style="vertical-align: inherit;">
Créez une partition distincte sur NVMe RAID 1 pour y délimiter les métadonnées minces LVM et les sauvegarder:</font></font><br>
<br>
<code>#thin_metadata_size --block-size=64k --pool-size=6terabytes --max-thins=100000 -u bytes<br>
thin_metadata_size - 3385794560 bytes estimated metadata area size for "--block-size=64kibibytes --pool-size=6terabytes --max-thins=100000"</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 8594128896B --name images root</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi..?</font></font></b><div class="spoiler_text">   ,    LVM thin ,        NVMe    .<br>
<br>
     ,     .    ,  ,   .    - , ,   LVM thin  ,      .         .<br>
<br>
-    -,  , ,          .             ,      .           .<br>
<br>
 ,        , ,  ,       , ,      LVM thin,        . <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créez un nouveau VG qui sera responsable de l'allocation dynamique: </font><font style="vertical-align: inherit;">
Créez un pool:</font></font><br>
<br>
<code>#pvcreate /dev/root/images<br>
#pvcreate /dev/cache/cachedata<br>
#vgcreate images /dev/root/images /dev/cache/cachedata</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 274877906944B --poolmetadataspare y --poolmetadatasize 4294967296B --chunksize 64k -Z y -T images/thin-pool</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi -Z y</font></font></b><div class="spoiler_text"> ,       , —               , — zeroing          64k.    64k           64K    .          .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Déplaçons LV vers les PV correspondants: </font><font style="vertical-align: inherit;">
Vérifiez: </font><font style="vertical-align: inherit;">
Créez un volume mince pour les tests: </font><font style="vertical-align: inherit;">
Mettez des packages pour les tests et les observations: </font><font style="vertical-align: inherit;">
Voici comment vous pouvez observer le comportement de notre configuration de stockage en temps réel: </font><font style="vertical-align: inherit;">
Voici comment vous pouvez tester notre configuration:</font></font><br>
<br>
<code>#pvmove -n images/thin-pool_tdata /dev/root/images /dev/cache/cachedata<br>
#pvmove -n images/lvol0_pmspare /dev/cache/cachedata /dev/root/images<br>
#pvmove -n images/thin-pool_tmeta /dev/cache/cachedata /dev/root/images <br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvs -a -o lv_name,lv_size,devices --units B images<br>
 LV LSize Devices <br>
 [lvol0_pmspare] 4294967296B /dev/root/images(0) <br>
 thin-pool 274877906944B thin-pool_tdata(0) <br>
 [thin-pool_tdata] 274877906944B /dev/cache/cachedata(0) <br>
 [thin-pool_tmeta] 4294967296B /dev/root/images(1024)<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -V 64G --thin-pool thin-pool --name test images</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#apt-get install sysstat fio</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#watch 'lvs --rows --reportformat basic --quiet -ocache_dirty_blocks,cache_settings cache/cachedata &amp;&amp; (lvdisplay cache/cachedata | grep Cache) &amp;&amp; (sar -p -d 2 1 | grep -E "sd|nvme|DEV|md1|md2|md3|md0" | grep -v Average | sort)'</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#fio --loops=1 --size=64G --runtime=4 --filename=/dev/images/test --stonewall --ioengine=libaio --direct=1 \<br>
--name=4kQD32read --bs=4k --iodepth=32 --rw=randread \<br>
--name=8kQD32read --bs=8k --iodepth=32 --rw=randread \<br>
--name=16kQD32read --bs=16k --iodepth=32 --rw=randread \<br>
--name=32KQD32read --bs=32k --iodepth=32 --rw=randread \<br>
--name=64KQD32read --bs=64k --iodepth=32 --rw=randread \<br>
--name=128KQD32read --bs=128k --iodepth=32 --rw=randread \<br>
--name=256KQD32read --bs=256k --iodepth=32 --rw=randread \<br>
--name=512KQD32read --bs=512k --iodepth=32 --rw=randread \<br>
--name=4Kread --bs=4k --rw=read \<br>
--name=8Kread --bs=8k --rw=read \<br>
--name=16Kread --bs=16k --rw=read \<br>
--name=32Kread --bs=32k --rw=read \<br>
--name=64Kread --bs=64k --rw=read \<br>
--name=128Kread --bs=128k --rw=read \<br>
--name=256Kread --bs=256k --rw=read \<br>
--name=512Kread --bs=512k --rw=read \<br>
--name=Seqread --bs=1m --rw=read \<br>
--name=Longread --bs=8m --rw=read \<br>
--name=Longwrite --bs=8m --rw=write \<br>
--name=Seqwrite --bs=1m --rw=write \<br>
--name=512Kwrite --bs=512k --rw=write \<br>
--name=256Kwrite --bs=256k --rw=write \<br>
--name=128Kwrite --bs=128k --rw=write \<br>
--name=64Kwrite --bs=64k --rw=write \<br>
--name=32Kwrite --bs=32k --rw=write \<br>
--name=16Kwrite --bs=16k --rw=write \<br>
--name=8Kwrite --bs=8k --rw=write \<br>
--name=4Kwrite --bs=4k --rw=write \<br>
--name=512KQD32write --bs=512k --iodepth=32 --rw=randwrite \<br>
--name=256KQD32write --bs=256k --iodepth=32 --rw=randwrite \<br>
--name=128KQD32write --bs=128k --iodepth=32 --rw=randwrite \<br>
--name=64KQD32write --bs=64k --iodepth=32 --rw=randwrite \<br>
--name=32KQD32write --bs=32k --iodepth=32 --rw=randwrite \<br>
--name=16KQD32write --bs=16k --iodepth=32 --rw=randwrite \<br>
--name=8KQD32write --bs=8k --iodepth=32 --rw=randwrite \<br>
--name=4kQD32write --bs=4k --iodepth=32 --rw=randwrite \<br>
 | grep -E 'read|write|test' | grep -v ioengine<br>
</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mise en garde! </font><font style="vertical-align: inherit;">Ressource!</font></font></b><div class="spoiler_text">   36  ,       4 .     .  4   NVMe     .  3   .  ,           216   SSD.<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lecture et écriture aléatoire?</font></font></b><div class="spoiler_text">.          .  ,   ,    ,        .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les résultats varient considérablement au premier démarrage et aux suivants à mesure que le cache et le volume léger se remplissent, et également, selon que le système a réussi à synchroniser les caches remplis au dernier démarrage.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entre autres choses, je recommande de mesurer la vitesse sur le volume mince déjà rempli à partir duquel l'instantané vient d'être réalisé. </font><font style="vertical-align: inherit;">L'auteur a eu l'occasion d'observer comment un enregistrement aléatoire accélère fortement immédiatement après la création du premier instantané, en particulier lorsque le cache n'est pas encore plein. </font><font style="vertical-align: inherit;">Cela est dû à la sémantique d'écriture sur copie, à l'alignement des blocs de cache et des volumes minces, et au fait que l'écriture aléatoire sur RAID 6 se transforme en lecture aléatoire sur RAID 6, puis écrit dans le cache. </font><font style="vertical-align: inherit;">Dans notre configuration, la lecture aléatoire de RAID 6 à 6 fois (le nombre de SSD SATA dans la baie) est plus rapide que l'écriture. </font><font style="vertical-align: inherit;">Parce que </font><font style="vertical-align: inherit;">Étant donné que les blocs CoW sont alloués séquentiellement à partir d'un pool mince, l'enregistrement, pour la plupart, devient également séquentiel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces deux fonctionnalités peuvent être avantageusement utilisées.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mettre en cache des instantanés «cohérents»</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour réduire le risque de perte de données en cas d'endommagement / perte de cache, l'auteur suggère d'introduire la pratique des instantanés tournants pour garantir leur intégrité dans ce cas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Premièrement, du fait que les métadonnées des volumes minces sont situées sur un périphérique non mis en cache, les métadonnées seront cohérentes et les éventuelles pertes seront isolées à l'intérieur des blocs de données. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le cycle de rotation des instantanés suivant garantit l'intégrité des données à l'intérieur des instantanés en cas de perte de cache:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour chaque volume léger portant le nom &lt;nom&gt;, créez un instantané avec le nom &lt;nom&gt; .cached</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Définissez le seuil de migration sur une valeur élevée raisonnable: </font></font><code>#lvchange --quiet --cachesettings "migration_threshold=16384" cache/cachedata</code> </li>
<li>       : <code>#lvs --rows --reportformat basic --quiet -ocache_dirty_blocks cache/cachedata | awk '{print $2}'</code>    .     ,        writethrough . ,      SATA  NVMe SSD,  ,   TBW,            ,           . -          100%    .  NVMe SSD  100%        <b>3-4 </b>. SATA SSD  -    . ,   ,       ,     , —             .</li>
<li>   ( )  —  &lt;&gt;.cached  &lt;&gt;.committed.  &lt;&gt;.committed   .</li>
<li>,     100%,    ,   .         .</li>
<li> migration threshold  : <code>#lvchange --quiet --cachesettings "migration_threshold=0" cache/cachedata</code>        . </li>
<li>,        <code>#lvs --rows --reportformat basic --quiet -ocache_dirty_blocks cache/cachedata | awk '{print $2}'</code>   .</li>
<li> . </li>
</ol><br>
<div class="spoiler"><b class="spoiler_title">   migration threshold...?</b><div class="spoiler_text">   ,     «»       .    -    4 ,   ,         -     (+- 32K) .<br>
<br>
 migration threshold        SATA SSD       64K  .      SATA SSD.<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title">  ..?</b><div class="spoiler_text"> ,         bash     100%    «google»-driven development,  ,    ,      ,     .<br>
<br>
,               , ,  ,      systemd ,     .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un tel schéma de rotation simple pour les instantanés nous permettra non seulement d'avoir constamment un instantané complètement synchronisé sur le SSD SATA, mais il nous permettra également d'utiliser l'utilitaire thin_delta pour savoir quels blocs ont été modifiés après sa création et, ainsi, localiser les dommages sur les volumes principaux, simplifiant grandement la récupération .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TRIM / DISCARD dans libvirt / KVM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parce que </font><font style="vertical-align: inherit;">Étant donné que l'entrepôt de données sera utilisé pour KVM exécutant libvirt, il serait bon d'apprendre à nos machines virtuelles non seulement à occuper de l'espace libre, mais aussi à libérer ce qui n'est plus nécessaire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela se fait en émulant le support TRIM / DISCARD sur les disques virtuels. </font><font style="vertical-align: inherit;">Pour ce faire, changez le type de contrôleur en virtio-scsi et modifiez le xml. </font><font style="vertical-align: inherit;">
Les DISCARDs similaires des OS invités sont correctement traités par LVM et les blocs sont correctement libérés à la fois dans le cache et dans le thin pool. </font><font style="vertical-align: inherit;">Dans notre cas, cela se produit, principalement, reporté, lorsque vous supprimez l'instantané suivant.</font></font><br>
<br>
<code>#virsh edit vmname<br>
&lt;disk type='block' device='disk'&gt;<br>
 &lt;driver name='qemu' type='raw' cache='writethrough' io='threads' <b>discard='unmap'</b>/&gt;<br>
 &lt;source dev='/dev/images/vmname'/&gt;<br>
 &lt;backingStore/&gt;<br>
 &lt;target dev='sda' bus='scsi'/&gt;<br>
 &lt;alias name='scsi0-0-0-0'/&gt;<br>
 &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;<br>
&lt;/disk&gt;<br>
<br>
&lt;controller type='scsi' index='0' <b>model='virtio-scsi'</b>&gt;<br>
 &lt;alias name='scsi0'/&gt;<br>
 &lt;address type='pci' domain='0x0000' bus='0x04' slot='0x00' function='0x0'/&gt;<br>
&lt;/controller&gt;<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sauvegarde BTRFS</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilisez des scripts prêts à l'emploi avec une </font></font><u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extrême</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> prudence et </font></font><u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à vos risques et périls</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">L'auteur a écrit ce code lui-même et exclusivement pour lui-même. </font><font style="vertical-align: inherit;">Je suis sûr que de nombreux utilisateurs Linux expérimentés ont de telles </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">béquilles d'</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> expérience et que d'autres n'en auront pas besoin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créer un volume sur le périphérique de sauvegarde: le </font></font><br>
<br>
<code>#lvcreate -L 256G --name backup backup</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
formater en BTRFS: </font></font><br>
<br>
<code>#mkfs.btrfs /dev/backup/backup</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
créer des points de montage et monter des sous-clés racine du FS: </font><font style="vertical-align: inherit;">
créer des répertoires pour les sauvegardes: </font><font style="vertical-align: inherit;">
créer un répertoire pour les scripts de sauvegarde: copier le </font><font style="vertical-align: inherit;">
script:</font></font><br>
<br>
<code>#mkdir /backup<br>
#mkdir /backup/btrfs<br>
#mkdir /backup/btrfs/root<br>
#mkdir /backup/btrfs/back<br>
#ln -s /boot /backup/btrfs<br>
# cat &gt;&gt;/etc/fstab &lt;&lt; EOF<br>
<br>
/dev/mapper/root-root /backup/btrfs/root btrfs defaults,space_cache,noatime,nodiratime 0 2<br>
/dev/mapper/backup-backup /backup/btrfs/back btrfs defaults,space_cache,noatime,nodiratime 0 2<br>
EOF<br>
#mount -a<br>
#update-initramfs -u<br>
#update-grub<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#mkdir /backup/btrfs/back/remote<br>
#mkdir /backup/btrfs/back/remote/root<br>
#mkdir /backup/btrfs/back/remote/boot<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#mkdir /root/btrfs-backup</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beaucoup de code bash effrayant. </font><font style="vertical-align: inherit;">À utiliser à vos risques et périls. </font><font style="vertical-align: inherit;">L'auteur n'écrit pas de lettres en colère ...</font></font></b><div class="spoiler_text"><code>#cat &gt;/root/btrfs-backup/btrfs-backup.sh &lt;&lt; EOF<br>
#!/bin/bash<br>
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"<br>
<br>
SCRIPT_FILE="$(realpath $0)"<br>
SCRIPT_DIR="$(dirname $SCRIPT_FILE)"<br>
SCRIPT_NAME="$(basename -s .sh $SCRIPT_FILE)"<br>
<br>
LOCK_FILE="/dev/shm/$SCRIPT_NAME.lock"<br>
DATE_PREFIX='%Y-%m-%d'<br>
DATE_FORMAT=$DATE_PREFIX'-%H-%M-%S'<br>
DATE_REGEX='[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]'<br>
BASE_SUFFIX=".@base"<br>
PEND_SUFFIX=".@pend"<br>
SNAP_SUFFIX=".@snap"<br>
MOUNTS="/backup/btrfs/"<br>
BACKUPS="/backup/btrfs/back/remote/"<br>
<br>
function terminate ()<br>
{<br>
 echo "$1" &gt;&amp;2<br>
 exit 1<br>
}<br>
<br>
function wait_lock()<br>
{<br>
 flock 98<br>
}<br>
<br>
function wait_lock_or_terminate()<br>
{<br>
 echo "Wating for lock..."<br>
 wait_lock || terminate "Failed to get lock. Exiting..."<br>
 echo "Got lock..."<br>
}<br>
<br>
function suffix()<br>
{<br>
 FORMATTED_DATE=$(date +"$DATE_FORMAT")<br>
 echo "$SNAP_SUFFIX.$FORMATTED_DATE"<br>
}<br>
<br>
function filter()<br>
{<br>
 FORMATTED_DATE=$(date --date="$1" +"$DATE_PREFIX")<br>
 echo "$SNAP_SUFFIX.$FORMATTED_DATE"<br>
}<br>
<br>
function backup()<br>
{<br>
SOURCE_PATH="$MOUNTS$1"<br>
TARGET_PATH="$BACKUPS$1"<br>
SOURCE_BASE_PATH="$MOUNTS$1$BASE_SUFFIX"<br>
TARGET_BASE_PATH="$BACKUPS$1$BASE_SUFFIX"<br>
TARGET_BASE_DIR="$(dirname $TARGET_BASE_PATH)"<br>
SOURCE_PEND_PATH="$MOUNTS$1$PEND_SUFFIX"<br>
TARGET_PEND_PATH="$BACKUPS$1$PEND_SUFFIX"<br>
 if [ -d "$SOURCE_BASE_PATH" ]<br>
 then<br>
 echo "$SOURCE_BASE_PATH found"<br>
 else<br>
 echo "$SOURCE_BASE_PATH File not found creating snapshot of $SOURCE_PATH to $SOURCE_BASE_PATH"<br>
 btrfs subvolume snapshot -r $SOURCE_PATH $SOURCE_BASE_PATH<br>
 sync<br>
 if [ -d "$TARGET_BASE_PATH" ]<br>
 then<br>
 echo "$TARGET_BASE_PATH found out of sync with source... removing..."<br>
 btrfs subvolume delete -c $TARGET_BASE_PATH<br>
 sync<br>
 fi<br>
 fi<br>
 if [ -d "$TARGET_BASE_PATH" ]<br>
 then<br>
 echo "$TARGET_BASE_PATH found"<br>
 else<br>
 echo "$TARGET_BASE_PATH not found. Synching to $TARGET_BASE_DIR"<br>
 btrfs send $SOURCE_BASE_PATH | btrfs receive $TARGET_BASE_DIR<br>
 sync<br>
 fi<br>
 if [ -d "$SOURCE_PEND_PATH" ]<br>
 then<br>
 echo "$SOURCE_PEND_PATH found removing..."<br>
 btrfs subvolume delete -c $SOURCE_PEND_PATH<br>
 sync<br>
 fi<br>
 btrfs subvolume snapshot -r $SOURCE_PATH $SOURCE_PEND_PATH<br>
 sync<br>
 if [ -d "$TARGET_PEND_PATH" ]<br>
 then<br>
 echo "$TARGET_PEND_PATH found removing..."<br>
 btrfs subvolume delete -c $TARGET_PEND_PATH<br>
 sync<br>
 fi<br>
 echo "Sending $SOURCE_PEND_PATH to $TARGET_PEND_PATH"<br>
 btrfs send -p $SOURCE_BASE_PATH $SOURCE_PEND_PATH | btrfs receive $TARGET_BASE_DIR<br>
 sync<br>
 TARGET_DATE_SUFFIX=$(suffix)<br>
 btrfs subvolume snapshot -r $TARGET_PEND_PATH "$TARGET_PATH$TARGET_DATE_SUFFIX"<br>
 sync<br>
 btrfs subvolume delete -c $SOURCE_BASE_PATH<br>
 sync<br>
 btrfs subvolume delete -c $TARGET_BASE_PATH<br>
 sync<br>
 mv $SOURCE_PEND_PATH $SOURCE_BASE_PATH<br>
 mv $TARGET_PEND_PATH $TARGET_BASE_PATH<br>
 sync<br>
}<br>
<br>
function list()<br>
{<br>
LIST_TARGET_BASE_PATH="$BACKUPS$1$BASE_SUFFIX"<br>
LIST_TARGET_BASE_DIR="$(dirname $LIST_TARGET_BASE_PATH)"<br>
LIST_TARGET_BASE_NAME="$(basename -s .$BASE_SUFFIX $LIST_TARGET_BASE_PATH)"<br>
find "$LIST_TARGET_BASE_DIR" -maxdepth 1 -mindepth 1 -type d -printf "%f\n" | grep "${LIST_TARGET_BASE_NAME/$BASE_SUFFIX/$SNAP_SUFFIX}.$DATE_REGEX"<br>
}<br>
<br>
function remove()<br>
{<br>
REMOVE_TARGET_BASE_PATH="$BACKUPS$1$BASE_SUFFIX"<br>
REMOVE_TARGET_BASE_DIR="$(dirname $REMOVE_TARGET_BASE_PATH)"<br>
btrfs subvolume delete -c $REMOVE_TARGET_BASE_DIR/$2<br>
sync<br>
}<br>
<br>
function removeall()<br>
{<br>
DATE_OFFSET="$2"<br>
FILTER="$(filter "$DATE_OFFSET")"<br>
while read -r SNAPSHOT ; do<br>
 remove "$1" "$SNAPSHOT"<br>
done &lt; &lt;(list "$1" | grep "$FILTER")<br>
<br>
}<br>
<br>
(<br>
 COMMAND="$1"<br>
 shift<br>
 <br>
 case "$COMMAND" in<br>
 "--help") <br>
 echo "Help"<br>
 ;;<br>
 "suffix") <br>
 suffix<br>
 ;;<br>
 "filter") <br>
 filter "$1"<br>
 ;;<br>
 "backup") <br>
 wait_lock_or_terminate<br>
 backup "$1"<br>
 ;;<br>
 "list") <br>
 list "$1"<br>
 ;;<br>
 "remove") <br>
 wait_lock_or_terminate<br>
 remove "$1" "$2"<br>
 ;;<br>
 "removeall") <br>
 wait_lock_or_terminate<br>
 removeall "$1" "$2"<br>
 ;;<br>
 *)<br>
 echo "None.."<br>
 ;;<br>
 esac<br>
) 98&gt;$LOCK_FILE <br>
<br>
EOF<br>
</code><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que fait-il même ..?</font></font></b><div class="spoiler_text">       BTRFS        BTRFS send/recieve.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier lancement peut être relativement long, car </font><font style="vertical-align: inherit;">au début, toutes les données seront copiées. </font><font style="vertical-align: inherit;">D'autres lancements seront très rapides, car </font><font style="vertical-align: inherit;">seules les modifications seront copiées. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre script à entasser en cron:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un peu plus de code bash</font></font></b><div class="spoiler_text"><code>#cat &gt;/root/btrfs-backup/cron-daily.sh &lt;&lt; EOF<br>
#!/bin/bash<br>
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"<br>
<br>
SCRIPT_FILE="$(realpath $0)"<br>
SCRIPT_DIR="$(dirname $SCRIPT_FILE)"<br>
SCRIPT_NAME="$(basename -s .sh $SCRIPT_FILE)"<br>
<br>
BACKUP_SCRIPT="$SCRIPT_DIR/btrfs-backup.sh"<br>
RETENTION="-60 day"<br>
$BACKUP_SCRIPT backup root/@<br>
$BACKUP_SCRIPT removeall root/@ "$RETENTION"<br>
$BACKUP_SCRIPT backup root/@home<br>
$BACKUP_SCRIPT removeall root/@home "$RETENTION"<br>
$BACKUP_SCRIPT backup boot/<br>
$BACKUP_SCRIPT removeall boot/ "$RETENTION"<br>
EOF<br>
</code><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce que ça fait ..?</font></font></b><div class="spoiler_text">     backup     BTRFS-.       60  .     /backup/btrfs/back/remote/     . <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donnons au code le droit d'exécuter: </font><font style="vertical-align: inherit;">
Vérifier et entasser les couronnes:</font></font><br>
<br>
<code>#chmod +x /root/btrfs-backup/cron-daily.sh<br>
#chmod +x /root/btrfs-backup/btrfs-backup.sh<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#/usr/bin/nice -n 19 /usr/bin/ionice -c 3 /root/btrfs-backup/cron-daily.sh 2&gt;&amp;1 | /usr/bin/logger -t btrfs-backup<br>
#cat /var/log/syslog | grep btrfs-backup<br>
#crontab -e<br>
0 2 * * * /usr/bin/nice -n 19 /usr/bin/ionice -c 3 /root/btrfs-backup/cron-daily.sh 2&gt;&amp;1 | /usr/bin/logger -t btrfs-backup<br>
</code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sauvegarde légère LVM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créez un pool léger sur le périphérique de sauvegarde: </font></font><br>
<br>
<code>#lvcreate -L 274877906944B --poolmetadataspare y --poolmetadatasize 4294967296B --chunksize 64k -Z y -T backup/thin-pool</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
installez ddrescue, car </font><font style="vertical-align: inherit;">les scripts utiliseront cet outil: </font></font><br>
<br>
<code>#apt-get install gddrescue</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créez un répertoire pour les scripts: </font></font><br>
<br>
<code>#mkdir /root/lvm-thin-backup</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Copiez les scripts:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beaucoup de coups à l'intérieur ...</font></font></b><div class="spoiler_text"><code>#cat &gt;/root/lvm-thin-backup/lvm-thin-backup.sh &lt;&lt; EOF<br>
#!/bin/bash<br>
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"<br>
<br>
SCRIPT_FILE="$(realpath $0)"<br>
SCRIPT_DIR="$(dirname $SCRIPT_FILE)"<br>
SCRIPT_NAME="$(basename -s .sh $SCRIPT_FILE)"<br>
<br>
LOCK_FILE="/dev/shm/$SCRIPT_NAME.lock"<br>
DATE_PREFIX='%Y-%m-%d'<br>
DATE_FORMAT=$DATE_PREFIX'-%H-%M-%S'<br>
DATE_REGEX='[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]'<br>
BASE_SUFFIX=".base"<br>
PEND_SUFFIX=".pend"<br>
SNAP_SUFFIX=".snap"<br>
BACKUPS="backup"<br>
BACKUPS_POOL="thin-pool"<br>
<br>
export LVM_SUPPRESS_FD_WARNINGS=1<br>
<br>
function terminate ()<br>
{<br>
 echo "$1" &gt;&amp;2<br>
 exit 1<br>
}<br>
<br>
function wait_lock()<br>
{<br>
 flock 98<br>
}<br>
<br>
function wait_lock_or_terminate()<br>
{<br>
 echo "Wating for lock..."<br>
 wait_lock || terminate "Failed to get lock. Exiting..."<br>
 echo "Got lock..."<br>
}<br>
<br>
function suffix()<br>
{<br>
 FORMATTED_DATE=$(date +"$DATE_FORMAT")<br>
 echo "$SNAP_SUFFIX.$FORMATTED_DATE"<br>
}<br>
<br>
function filter()<br>
{<br>
 FORMATTED_DATE=$(date --date="$1" +"$DATE_PREFIX")<br>
 echo "$SNAP_SUFFIX.$FORMATTED_DATE"<br>
}<br>
<br>
function read_thin_id {<br>
lvs --rows --reportformat basic --quiet -othin_id "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_pool_lv {<br>
lvs --rows --reportformat basic --quiet -opool_lv "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_lv_dm_path {<br>
lvs --rows --reportformat basic --quiet -olv_dm_path "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_lv_active {<br>
lvs --rows --reportformat basic --quiet -olv_active "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_lv_chunk_size {<br>
lvs --rows --reportformat basic --quiet --units b --nosuffix -ochunk_size "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_lv_size {<br>
lvs --rows --reportformat basic --quiet --units b --nosuffix -olv_size "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function activate_volume {<br>
lvchange -ay -Ky "$1/$2"<br>
}<br>
<br>
function deactivate_volume {<br>
lvchange -an "$1/$2"<br>
}<br>
<br>
function read_thin_metadata_snap {<br>
dmsetup status "$1" | awk '{print $7}'<br>
}<br>
<br>
function thindiff()<br>
{<br>
DIFF_VG="$1"<br>
DIFF_SOURCE="$2"<br>
DIFF_TARGET="$3"<br>
DIFF_SOURCE_POOL=$(read_pool_lv $DIFF_VG $DIFF_SOURCE)<br>
DIFF_TARGET_POOL=$(read_pool_lv $DIFF_VG $DIFF_TARGET)<br>
<br>
if [ "$DIFF_SOURCE_POOL" == "" ]<br>
then<br>
 (&gt;&amp;2 echo "Source LV is not thin.")<br>
 exit 1<br>
fi<br>
<br>
if [ "$DIFF_TARGET_POOL" == "" ]<br>
then<br>
 (&gt;&amp;2 echo "Target LV is not thin.")<br>
 exit 1<br>
fi<br>
<br>
if [ "$DIFF_SOURCE_POOL" != "$DIFF_TARGET_POOL" ]<br>
then<br>
 (&gt;&amp;2 echo "Source and target LVs belong to different thin pools.")<br>
 exit 1<br>
fi<br>
<br>
DIFF_POOL_PATH=$(read_lv_dm_path $DIFF_VG $DIFF_SOURCE_POOL)<br>
DIFF_SOURCE_ID=$(read_thin_id $DIFF_VG $DIFF_SOURCE)<br>
DIFF_TARGET_ID=$(read_thin_id $DIFF_VG $DIFF_TARGET)<br>
DIFF_POOL_PATH_TPOOL="$DIFF_POOL_PATH-tpool"<br>
DIFF_POOL_PATH_TMETA="$DIFF_POOL_PATH"_tmeta<br>
DIFF_POOL_METADATA_SNAP=$(read_thin_metadata_snap $DIFF_POOL_PATH_TPOOL)<br>
<br>
if [ "$DIFF_POOL_METADATA_SNAP" != "-" ]<br>
then<br>
 (&gt;&amp;2 echo "Thin pool metadata snapshot already exist. Assuming stale one. Will release metadata snapshot in 5 seconds.")<br>
 sleep 5<br>
 dmsetup message $DIFF_POOL_PATH_TPOOL 0 release_metadata_snap<br>
fi<br>
<br>
dmsetup message $DIFF_POOL_PATH_TPOOL 0 reserve_metadata_snap<br>
DIFF_POOL_METADATA_SNAP=$(read_thin_metadata_snap $DIFF_POOL_PATH_TPOOL)<br>
<br>
if [ "$DIFF_POOL_METADATA_SNAP" == "-" ]<br>
then<br>
 (&gt;&amp;2 echo "Failed to create thin pool metadata snapshot.")<br>
 exit 1<br>
fi<br>
<br>
#We keep output in variable because metadata snapshot need to be released early.<br>
DIFF_DATA=$(thin_delta -m$DIFF_POOL_METADATA_SNAP --snap1 $DIFF_SOURCE_ID --snap2 $DIFF_TARGET_ID $DIFF_POOL_PATH_TMETA)<br>
<br>
dmsetup message $DIFF_POOL_PATH_TPOOL 0 release_metadata_snap<br>
<br>
echo $"$DIFF_DATA" | grep -E 'different|left_only|right_only' | sed 's/&lt;/"/g' | sed 's/ /"/g' | awk -F'\"' '{print $6 "\t" $8 "\t" $11}' | sed 's/different/copy/g' | sed 's/left_only/copy/g' | sed 's/right_only/discard/g'<br>
<br>
}<br>
<br>
function thinsync()<br>
{<br>
SYNC_VG="$1"<br>
SYNC_PEND="$2"<br>
SYNC_BASE="$3"<br>
SYNC_TARGET="$4"<br>
SYNC_PEND_POOL=$(read_pool_lv $SYNC_VG $SYNC_PEND)<br>
SYNC_BLOCK_SIZE=$(read_lv_chunk_size $SYNC_VG $SYNC_PEND_POOL)<br>
SYNC_PEND_PATH=$(read_lv_dm_path $SYNC_VG $SYNC_PEND)<br>
<br>
activate_volume $SYNC_VG $SYNC_PEND<br>
<br>
while read -r SYNC_ACTION SYNC_OFFSET SYNC_LENGTH ; do<br>
 SYNC_OFFSET_BYTES=$((SYNC_OFFSET * SYNC_BLOCK_SIZE))<br>
 SYNC_LENGTH_BYTES=$((SYNC_LENGTH * SYNC_BLOCK_SIZE))<br>
 if [ "$SYNC_ACTION" == "copy" ]<br>
 then<br>
 ddrescue --quiet --force --input-position=$SYNC_OFFSET_BYTES --output-position=$SYNC_OFFSET_BYTES --size=$SYNC_LENGTH_BYTES "$SYNC_PEND_PATH" "$SYNC_TARGET"<br>
 fi<br>
<br>
if [ "$SYNC_ACTION" == "discard" ]<br>
 then<br>
 blkdiscard -o $SYNC_OFFSET_BYTES -l $SYNC_LENGTH_BYTES "$SYNC_TARGET"<br>
 fi<br>
done &lt; &lt;(thindiff "$SYNC_VG" "$SYNC_PEND" "$SYNC_BASE")<br>
}<br>
<br>
function discard_volume()<br>
{<br>
DISCARD_VG="$1"<br>
DISCARD_LV="$2"<br>
DISCARD_LV_PATH=$(read_lv_dm_path "$DISCARD_VG" "$DISCARD_LV")<br>
if [ "$DISCARD_LV_PATH" != "" ]<br>
then<br>
 echo "$DISCARD_LV_PATH found"<br>
else<br>
 echo "$DISCARD_LV not found in $DISCARD_VG"<br>
 exit 1<br>
fi<br>
DISCARD_LV_POOL=$(read_pool_lv $DISCARD_VG $DISCARD_LV)<br>
DISCARD_LV_SIZE=$(read_lv_size "$DISCARD_VG" "$DISCARD_LV")<br>
lvremove -y --quiet "$DISCARD_LV_PATH" || exit 1<br>
lvcreate --thin-pool "$DISCARD_LV_POOL" -V "$DISCARD_LV_SIZE"B --name "$DISCARD_LV" "$DISCARD_VG" || exit 1<br>
}<br>
<br>
function backup()<br>
{<br>
SOURCE_VG="$1"<br>
SOURCE_LV="$2"<br>
TARGET_VG="$BACKUPS"<br>
TARGET_LV="$SOURCE_VG-$SOURCE_LV"<br>
SOURCE_BASE_LV="$SOURCE_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV="$TARGET_LV$BASE_SUFFIX"<br>
SOURCE_PEND_LV="$SOURCE_LV$PEND_SUFFIX"<br>
TARGET_PEND_LV="$TARGET_LV$PEND_SUFFIX"<br>
SOURCE_BASE_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
SOURCE_PEND_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_PEND_LV")<br>
TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
TARGET_PEND_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_PEND_LV")<br>
<br>
if [ "$SOURCE_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$SOURCE_BASE_LV_PATH found"<br>
 else<br>
 echo "Source base not found creating snapshot of $SOURCE_VG/$SOURCE_LV to $SOURCE_VG/$SOURCE_BASE_LV"<br>
 lvcreate --quiet --snapshot --name "$SOURCE_BASE_LV" "$SOURCE_VG/$SOURCE_LV" || exit 1<br>
 SOURCE_BASE_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
 activate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 echo "Discarding $SOURCE_BASE_LV_PATH as we need to bootstrap."<br>
 SOURCE_BASE_POOL=$(read_pool_lv $SOURCE_VG $SOURCE_BASE_LV)<br>
 SOURCE_BASE_CHUNK_SIZE=$(read_lv_chunk_size $SOURCE_VG $SOURCE_BASE_POOL)<br>
 discard_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 sync<br>
 if [ "$TARGET_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_BASE_LV_PATH found out of sync with source... removing..."<br>
 lvremove -y --quiet $TARGET_BASE_LV_PATH || exit 1<br>
 TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
 sync<br>
 fi<br>
 fi<br>
SOURCE_BASE_SIZE=$(read_lv_size "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
 if [ "$TARGET_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_BASE_LV_PATH found"<br>
 else<br>
 echo "$TARGET_VG/$TARGET_LV not found. Creating empty volume."<br>
 lvcreate --thin-pool "$BACKUPS_POOL" -V "$SOURCE_BASE_SIZE"B --name "$TARGET_BASE_LV" "$TARGET_VG" || exit 1<br>
 echo "Have to rebootstrap. Discarding source at $SOURCE_BASE_LV_PATH"<br>
 activate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 SOURCE_BASE_POOL=$(read_pool_lv $SOURCE_VG $SOURCE_BASE_LV)<br>
 SOURCE_BASE_CHUNK_SIZE=$(read_lv_chunk_size $SOURCE_VG $SOURCE_BASE_POOL)<br>
 discard_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 TARGET_BASE_POOL=$(read_pool_lv $TARGET_VG $TARGET_BASE_LV)<br>
 TARGET_BASE_CHUNK_SIZE=$(read_lv_chunk_size $TARGET_VG $TARGET_BASE_POOL)<br>
 TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
 echo "Discarding target at $TARGET_BASE_LV_PATH"<br>
 discard_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 sync<br>
 fi<br>
 if [ "$SOURCE_PEND_LV_PATH" != "" ]<br>
 then<br>
 echo "$SOURCE_PEND_LV_PATH found removing..."<br>
 lvremove -y --quiet "$SOURCE_PEND_LV_PATH" || exit 1<br>
 sync<br>
 fi<br>
 lvcreate --quiet --snapshot --name "$SOURCE_PEND_LV" "$SOURCE_VG/$SOURCE_LV" || exit 1<br>
SOURCE_PEND_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_PEND_LV")<br>
 sync<br>
 if [ "$TARGET_PEND_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_PEND_LV_PATH found removing..."<br>
 lvremove -y --quiet $TARGET_PEND_LV_PATH<br>
 sync<br>
 fi<br>
 lvcreate --quiet --snapshot --name "$TARGET_PEND_LV" "$TARGET_VG/$TARGET_BASE_LV" || exit 1<br>
TARGET_PEND_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_PEND_LV")<br>
SOURCE_PEND_LV_SIZE=$(read_lv_size "$SOURCE_VG" "$SOURCE_PEND_LV")<br>
 lvresize -L "$SOURCE_PEND_LV_SIZE"B "$TARGET_PEND_LV_PATH"<br>
 activate_volume "$TARGET_VG" "$TARGET_PEND_LV"<br>
 echo "Synching $SOURCE_PEND_LV_PATH to $TARGET_PEND_LV_PATH"<br>
 thinsync "$SOURCE_VG" "$SOURCE_PEND_LV" "$SOURCE_BASE_LV" "$TARGET_PEND_LV_PATH" || exit 1<br>
 sync<br>
<br>
TARGET_DATE_SUFFIX=$(suffix)<br>
 lvcreate --quiet --snapshot --name "$TARGET_LV$TARGET_DATE_SUFFIX" "$TARGET_VG/$TARGET_PEND_LV" || exit 1<br>
 sync<br>
 lvremove --quiet -y "$SOURCE_BASE_LV_PATH" || exit 1<br>
 sync<br>
 lvremove --quiet -y "$TARGET_BASE_LV_PATH" || exit 1<br>
 sync<br>
 lvrename -y "$SOURCE_VG/$SOURCE_PEND_LV" "$SOURCE_BASE_LV" || exit 1<br>
 lvrename -y "$TARGET_VG/$TARGET_PEND_LV" "$TARGET_BASE_LV" || exit 1<br>
 sync<br>
 deactivate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 deactivate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
}<br>
<br>
function verify()<br>
{<br>
SOURCE_VG="$1"<br>
SOURCE_LV="$2"<br>
TARGET_VG="$BACKUPS"<br>
TARGET_LV="$SOURCE_VG-$SOURCE_LV"<br>
SOURCE_BASE_LV="$SOURCE_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV="$TARGET_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
SOURCE_BASE_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
<br>
if [ "$SOURCE_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$SOURCE_BASE_LV_PATH found"<br>
 else<br>
 echo "$SOURCE_BASE_LV_PATH not found"<br>
 exit 1<br>
 fi<br>
 if [ "$TARGET_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_BASE_LV_PATH found"<br>
 else<br>
 echo "$TARGET_BASE_LV_PATH not found"<br>
 exit 1<br>
 fi<br>
 activate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 activate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 echo Comparing "$SOURCE_BASE_LV_PATH" with "$TARGET_BASE_LV_PATH"<br>
 cmp "$SOURCE_BASE_LV_PATH" "$TARGET_BASE_LV_PATH"<br>
 echo Done...<br>
 deactivate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 deactivate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
}<br>
<br>
function resync()<br>
{<br>
SOURCE_VG="$1"<br>
SOURCE_LV="$2"<br>
TARGET_VG="$BACKUPS"<br>
TARGET_LV="$SOURCE_VG-$SOURCE_LV"<br>
SOURCE_BASE_LV="$SOURCE_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV="$TARGET_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
SOURCE_BASE_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
<br>
if [ "$SOURCE_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$SOURCE_BASE_LV_PATH found"<br>
 else<br>
 echo "$SOURCE_BASE_LV_PATH not found"<br>
 exit 1<br>
 fi<br>
 if [ "$TARGET_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_BASE_LV_PATH found"<br>
 else<br>
 echo "$TARGET_BASE_LV_PATH not found"<br>
 exit 1<br>
 fi<br>
 activate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 activate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 SOURCE_BASE_POOL=$(read_pool_lv $SOURCE_VG $SOURCE_BASE_LV)<br>
 SYNC_BLOCK_SIZE=$(read_lv_chunk_size $SOURCE_VG $SOURCE_BASE_POOL)<br>
<br>
echo Syncronizing "$SOURCE_BASE_LV_PATH" to "$TARGET_BASE_LV_PATH"<br>
<br>
CMP_OFFSET=0<br>
 while [[ "$CMP_OFFSET" != "" ]] ; do<br>
 CMP_MISMATCH=$(cmp -i "$CMP_OFFSET" "$SOURCE_BASE_LV_PATH" "$TARGET_BASE_LV_PATH" | grep differ | awk '{print $5}' | sed 's/,//g' )<br>
 if [[ "$CMP_MISMATCH" != "" ]] ; then<br>
 CMP_OFFSET=$(( CMP_MISMATCH + CMP_OFFSET ))<br>
 SYNC_OFFSET_BYTES=$(( ( CMP_OFFSET / SYNC_BLOCK_SIZE ) * SYNC_BLOCK_SIZE ))<br>
 SYNC_LENGTH_BYTES=$(( SYNC_BLOCK_SIZE ))<br>
 echo "Synching $SYNC_LENGTH_BYTES bytes at $SYNC_OFFSET_BYTES from $SOURCE_BASE_LV_PATH to $TARGET_BASE_LV_PATH"<br>
 ddrescue --quiet --force --input-position=$SYNC_OFFSET_BYTES --output-position=$SYNC_OFFSET_BYTES --size=$SYNC_LENGTH_BYTES "$SOURCE_BASE_LV_PATH" "$TARGET_BASE_LV_PATH"<br>
 else<br>
 CMP_OFFSET=""<br>
 fi<br>
 done<br>
 echo Done...<br>
 deactivate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 deactivate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
}<br>
<br>
function list()<br>
{<br>
LIST_SOURCE_VG="$1"<br>
LIST_SOURCE_LV="$2"<br>
LIST_TARGET_VG="$BACKUPS"<br>
LIST_TARGET_LV="$LIST_SOURCE_VG-$LIST_SOURCE_LV"<br>
LIST_TARGET_BASE_LV="$LIST_TARGET_LV$SNAP_SUFFIX"<br>
lvs -olv_name | grep "$LIST_TARGET_BASE_LV.$DATE_REGEX"<br>
}<br>
<br>
function remove()<br>
{<br>
REMOVE_TARGET_VG="$BACKUPS"<br>
REMOVE_TARGET_LV="$1"<br>
lvremove -y "$REMOVE_TARGET_VG/$REMOVE_TARGET_LV"<br>
sync<br>
}<br>
<br>
function removeall()<br>
{<br>
DATE_OFFSET="$3"<br>
FILTER="$(filter "$DATE_OFFSET")"<br>
while read -r SNAPSHOT ; do<br>
 remove "$SNAPSHOT"<br>
done &lt; &lt;(list "$1" "$2" | grep "$FILTER")<br>
<br>
}<br>
<br>
(<br>
 COMMAND="$1"<br>
 shift<br>
 <br>
 case "$COMMAND" in<br>
 "--help") <br>
 echo "Help"<br>
 ;;<br>
 "suffix") <br>
 suffix<br>
 ;;<br>
 "filter") <br>
 filter "$1"<br>
 ;;<br>
 "backup") <br>
 wait_lock_or_terminate<br>
 backup "$1" "$2"<br>
 ;;<br>
 "list") <br>
 list "$1" "$2"<br>
 ;;<br>
 "thindiff") <br>
 thindiff "$1" "$2" "$3"<br>
 ;;<br>
 "thinsync") <br>
 thinsync "$1" "$2" "$3" "$4"<br>
 ;;<br>
 "verify") <br>
 wait_lock_or_terminate<br>
 verify "$1" "$2"<br>
 ;;<br>
 "resync") <br>
 wait_lock_or_terminate<br>
 resync "$1" "$2"<br>
 ;;<br>
 "remove") <br>
 wait_lock_or_terminate<br>
 remove "$1"<br>
 ;;<br>
 "removeall") <br>
 wait_lock_or_terminate<br>
 removeall "$1" "$2" "$3"<br>
 ;;<br>
 *)<br>
 echo "None.."<br>
 ;;<br>
 esac<br>
) 98&gt;$LOCK_FILE <br>
<br>
EOF<br>
</code><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce que ça fait ...?</font></font></b><div class="spoiler_text">             ,   thin_delta,       ddrescue  blkdiscard.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre script que nous allons entasser en couronnes:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un peu plus bash</font></font></b><div class="spoiler_text"><code>#cat &gt;/root/lvm-thin-backup/cron-daily.sh &lt;&lt; EOF<br>
#!/bin/bash<br>
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"<br>
<br>
SCRIPT_FILE="$(realpath $0)"<br>
SCRIPT_DIR="$(dirname $SCRIPT_FILE)"<br>
SCRIPT_NAME="$(basename -s .sh $SCRIPT_FILE)"<br>
<br>
BACKUP_SCRIPT="$SCRIPT_DIR/lvm-thin-backup.sh"<br>
RETENTION="-60 days"<br>
<br>
$BACKUP_SCRIPT backup images linux-dev<br>
$BACKUP_SCRIPT backup images win8<br>
$BACKUP_SCRIPT backup images win8-data<br>
#etc<br>
<br>
$BACKUP_SCRIPT removeall images linux-dev "$RETENTION"<br>
$BACKUP_SCRIPT removeall images win8 "$RETENTION"<br>
$BACKUP_SCRIPT removeall images win8-data "$RETENTION"<br>
#etc<br>
<br>
EOF<br>
</code><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce que ça fait ...?</font></font></b><div class="spoiler_text">  ,         .      ,        .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce script doit être modifié, indiquant une liste de volumes légers pour lesquels des sauvegardes sont requises. </font><font style="vertical-align: inherit;">Les noms donnés sont à titre indicatif seulement. </font><font style="vertical-align: inherit;">Si vous le souhaitez, vous pouvez écrire un script qui synchronisera tous les volumes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donnons des droits: </font><font style="vertical-align: inherit;">
Vérifiez et fourrez dans les couronnes: </font><font style="vertical-align: inherit;">
Le premier lancement sera long, car </font><font style="vertical-align: inherit;">les volumes minces seront entièrement synchronisés en copiant tout l'espace utilisé. </font><font style="vertical-align: inherit;">Grâce aux métadonnées minces LVM, nous savons quels blocs sont réellement utilisés, donc seuls les blocs réels de volumes minces seront copiés. </font><font style="vertical-align: inherit;">
Les lancements suivants copieront les données de manière incrémentielle en suivant les modifications via les métadonnées fines LVM.</font></font><br>
<br>
<code>#chmod +x /root/lvm-thin-backup/cron-daily.sh<br>
#chmod +x /root/lvm-thin-backup/lvm-thin-backup.sh</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#/usr/bin/nice -n 19 /usr/bin/ionice -c 3 /root/lvm-thin-backup/cron-daily.sh 2&gt;&amp;1 | /usr/bin/logger -t lvm-thin-backup<br>
#cat /var/log/syslog | grep lvm-thin-backup<br>
#crontab -e<br>
0 3 * * * /usr/bin/nice -n 19 /usr/bin/ionice -c 3 /root/lvm-thin-backup/cron-daily.sh 2&gt;&amp;1 | /usr/bin/logger -t lvm-thin-backup<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyons ce qui se passe:</font></font></h3><br>
<code>#time /root/btrfs-backup/cron-daily.sh<br>
real 0m2,967s<br>
user 0m0,225s<br>
sys 0m0,353s<br>
<br>
#time /root/lvm-thin-backup/cron-daily.sh<br>
real 1m2,710s<br>
user 0m12,721s<br>
sys 0m6,671s<br>
<br>
#ls -al /backup/btrfs/back/remote/*<br>
/backup/btrfs/back/remote/boot:<br>
total 0<br>
drwxr-xr-x 1 root root 1260  26 09:11 .<br>
drwxr-xr-x 1 root root 16  6 09:30 ..<br>
drwxr-xr-x 1 root root 322  26 02:00 .@base<br>
drwxr-xr-x 1 root root 516  6 09:39 .@snap.2020-03-06-09-39-37<br>
drwxr-xr-x 1 root root 516  6 09:39 .@snap.2020-03-06-09-39-57<br>
...<br>
/backup/btrfs/back/remote/root:<br>
total 0<br>
drwxr-xr-x 1 root root 2820  26 09:11 .<br>
drwxr-xr-x 1 root root 16  6 09:30 ..<br>
drwxr-xr-x 1 root root 240  26 09:11 @.@base<br>
drwxr-xr-x 1 root root 22  26 09:11 @home.@base<br>
drwxr-xr-x 1 root root 22  6 09:39 @home.@snap.2020-03-06-09-39-35<br>
drwxr-xr-x 1 root root 22  6 09:39 @home.@snap.2020-03-06-09-39-57<br>
...<br>
drwxr-xr-x 1 root root 240  6 09:39 @.@snap.2020-03-06-09-39-26<br>
drwxr-xr-x 1 root root 240  6 09:39 @.@snap.2020-03-06-09-39-56<br>
...<br>
<br>
#lvs -olv_name,lv_size images &amp;&amp; lvs -olv_name,lv_size backup<br>
 LV LSize <br>
 linux-dev 128,00g<br>
 linux-dev.base 128,00g<br>
 thin-pool 1,38t<br>
 win8 128,00g<br>
 win8-data 2,00t<br>
 win8-data.base 2,00t<br>
 win8.base 128,00g<br>
 LV LSize <br>
 backup 256,00g<br>
 images-linux-dev.base 128,00g<br>
 images-linux-dev.snap.2020-03-08-10-09-11 128,00g<br>
 images-linux-dev.snap.2020-03-08-10-09-25 128,00g<br>
...<br>
 images-win8-data.base 2,00t<br>
 images-win8-data.snap.2020-03-16-14-11-55 2,00t<br>
 images-win8-data.snap.2020-03-16-14-19-50 2,00t<br>
...<br>
 images-win8.base 128,00g<br>
 images-win8.snap.2020-03-17-04-51-46 128,00g<br>
 images-win8.snap.2020-03-18-03-02-49 128,00g<br>
...<br>
 thin-pool &lt;2,09t<br>
</code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et les poupées gigognes?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Très probablement, bien que les volumes logiques LVM LV puissent être des volumes PV LVM physiques pour d'autres VG. </font><font style="vertical-align: inherit;">LVM peut être récursif, comme les poupées gigognes. </font><font style="vertical-align: inherit;">Cela donne à LVM une extrême flexibilité.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le prochain article, nous allons essayer d'utiliser plusieurs systèmes de stockage mobiles / KVM similaires comme base pour créer un cluster de stockage / vm géo-distribué avec redondance sur plusieurs continents via des ordinateurs de bureau à domicile, Internet à domicile et des réseaux P2P.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr492820/index.html">.Net Core Api: obtenir des données dans une demande de différentes sources</a></li>
<li><a href="../fr492822/index.html">Développeurs CSS - pourquoi le monde en a-t-il besoin?</a></li>
<li><a href="../fr492828/index.html">Comment survivre dans un monde enfermé</a></li>
<li><a href="../fr492830/index.html">SameSite = Lax par défaut - déjà dans Chrome 80 stable (mais pas encore pour tout le monde)</a></li>
<li><a href="../fr492832/index.html">Passerelle IoT pour les protocoles industriels basés sur i.MX6 et Linux</a></li>
<li><a href="../fr492838/index.html">Connectez M5Stack au téléviseur</a></li>
<li><a href="../fr492844/index.html">Comment visualiser et animer des modèles (géophysiques). Animation 3D et visualisation des données 4D</a></li>
<li><a href="../fr492850/index.html">Tout le monde ne veut pas passer au travail à distance</a></li>
<li><a href="../fr492856/index.html">Covid19, Votre société et vous êtes du point de vue de la Data Science. Article traduit par Jeremy Howard et Rachel Thomas (fast.ai)</a></li>
<li><a href="../fr492862/index.html">15 meilleurs conseils d'optimisation des performances Oracle APEX pour les développeurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>