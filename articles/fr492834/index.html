<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë©üèæ üëÉ üë©üèæ‚Äç‚úàÔ∏è Qu'est-ce qui est commun entre LVM et matriochka? üññüèø üíï üíáüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonne journ√©e. 
 Je veux partager avec la communaut√© une exp√©rience pratique dans la construction d'un syst√®me de stockage pour KVM utilisant md RAID ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Qu'est-ce qui est commun entre LVM et matriochka?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492834/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonne journ√©e. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je veux partager avec la communaut√© une exp√©rience pratique dans la construction d'un syst√®me de stockage pour KVM utilisant md RAID + LVM. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le programme:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Construisez md RAID 1 √† partir du SSD NVMe.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ez md RAID 6 √† partir de disques SSD SATA et de disques ordinaires.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caract√©ristiques du TRIM / DISCARD sur SSD RAID 1/6.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ation d'une matrice RAID 1/6 md amor√ßable sur un ensemble commun de disques.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installation du syst√®me sur NVMe RAID 1 s'il n'y a pas de prise en charge NVMe dans le BIOS.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation du cache LVM et du LVM thin.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation d'instantan√©s BTRFS et envoi / r√©ception pour la sauvegarde.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation d'instantan√©s l√©gers LVM et thin_delta pour la sauvegarde de style BTRFS.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous √™tes int√©ress√©, s'il vous pla√Æt, sous cat.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©claration</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'auteur n'assume aucune responsabilit√© pour les cons√©quences de l'utilisation ou de la non-utilisation des mat√©riaux / exemples / code / conseils / donn√©es de cet article. </font><font style="vertical-align: inherit;">En lisant ou en utilisant ce mat√©riel de quelque mani√®re que ce soit, vous assumez la responsabilit√© de toutes les cons√©quences de ces actions. </font><font style="vertical-align: inherit;">Les cons√©quences possibles incluent:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSD Crispy Fried NVMe.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compl√®tement √©puis√© les ressources d'enregistrement et les pannes de disques SSD.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perte compl√®te de toutes les donn√©es sur tous les disques, y compris les sauvegardes.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mat√©riel informatique d√©fectueux.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pass√© du temps, des nerfs et de l'argent.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout autre effet non mentionn√© ci-dessus.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le fer</font></font></h2><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En stock √©tait:</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La carte m√®re est vers 2013 sur le chipset Z87 complet avec Intel Core i7 / Haswell.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CPU 4 c≈ìurs, 8 threads</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 32 gigaoctets de RAM DDR3</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 x 16 ou 2 x 8 PCIe 3.0</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 x 4 + 1 x 1 PCIe 2.0</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Connecteurs SATA 3 6 x 6 Go / s </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'adaptateur SAS LSI SAS9211-8I a flash√© en mode IT / HBA. </font><font style="vertical-align: inherit;">Le micrologiciel compatible RAID a √©t√© intentionnellement remplac√© par le micrologiciel HBA pour:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il √©tait possible √† tout moment de jeter cet adaptateur et de le remplacer par tout autre premier.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TRIM / Discard fonctionnait normalement sur les disques, </font><font style="vertical-align: inherit;">dans le firmware RAID, ces commandes ne sont pas du tout prises en charge et HBA, en g√©n√©ral, ne se soucie pas des commandes √† envoyer sur le bus.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Disques durs - 8 pi√®ces de HGST Travelstar 7K1000 avec un volume de 1 To au format 2,5, comme pour les ordinateurs portables. </font><font style="vertical-align: inherit;">Ces disques √©taient auparavant dans une matrice RAID 6. </font><font style="vertical-align: inherit;">Dans le nouveau syst√®me, ils trouveront √©galement une application. </font><font style="vertical-align: inherit;">Pour stocker des sauvegardes locales.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, il a √©t√© ajout√©:</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 pi√®ces de SSD SATA mod√®le Samsung 860 QVO 2 To. </font><font style="vertical-align: inherit;">Ces SSD n√©cessitaient une grande quantit√©, la pr√©sence d'un cache SLC, la fiabilit√© est souhaitable et un prix bas. </font><font style="vertical-align: inherit;">Obligatoire √©tait la prise en charge de la suppression / z√©ro qui est v√©rifi√©e par une ligne en dmesg: </font></font><br>
<br>
<code>kernel: ata1.00: Enabling discard_zeroes_data</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 pi√®ces de mod√®le NVMe SSD Samsung SSD 970 EVO 500GB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ces SSD, une vitesse de lecture / √©criture al√©atoire et une ressource adapt√©e √† vos besoins sont importantes. </font><font style="vertical-align: inherit;">Radiateur √† eux. </font><font style="vertical-align: inherit;">Obligatoire. </font><font style="vertical-align: inherit;">Absolument n√©cessaire. </font><font style="vertical-align: inherit;">Sinon, faites-les frire jusqu'√† ce qu'elles soient croustillantes lors de la premi√®re synchronisation RAIDa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adaptateur StarTech PEX8M2E2 pour 2 disques SSD NVMe avec emplacement PCIe 3.0 8x. Encore une fois, ce n'est que du HBA, mais pour NVMe. Il diff√®re des adaptateurs bon march√© en l'absence de la prise en charge de la bifurcation PCIe depuis la carte m√®re en raison de la pr√©sence d'un commutateur PCIe int√©gr√©. Il fonctionnera m√™me dans le syst√®me le plus ancien o√π il y a PCIe, m√™me s'il s'agit d'un emplacement x1 PCIe 1.0. Naturellement, avec la vitesse appropri√©e. Il n'y a pas de RAID l√†-bas. Il n'y a pas de BIOS int√©gr√© √† bord. Ainsi, votre syst√®me n'apprendra pas par magie √† d√©marrer √† partir de NVMe, et encore moins √† faire NVMe RAID gr√¢ce √† cet appareil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce composant a √©t√© caus√© uniquement par la pr√©sence d'un seul PCIe 3.0 8x gratuit dans le syst√®me et, en pr√©sence de 2 emplacements libres, il est facilement remplac√© par deux PEX4M2E1 ou analogues bon march√©, qui peuvent √™tre achet√©s n'importe o√π au prix de 600 roubles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le refus de tout type de mat√©riel ou de chipsets RAID / BIOS int√©gr√©s a √©t√© fait d√©lib√©r√©ment, afin de pouvoir remplacer compl√®tement l'ensemble du syst√®me, √† l'exception du SSD / HDD lui-m√™me, en sauvegardant toutes les donn√©es. </font><font style="vertical-align: inherit;">Id√©alement, il serait possible de conserver m√™me le syst√®me d'exploitation install√© lors du passage √† un mat√©riel compl√®tement nouveau / diff√©rent. </font><font style="vertical-align: inherit;">L'essentiel est qu'il existe des ports SATA et PCIe. </font><font style="vertical-align: inherit;">C'est comme un CD live ou un lecteur flash amor√ßable, seulement tr√®s rapide et un peu surdimensionn√©.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Humour</font></font></b><div class="spoiler_text"> ,   , ‚Äî          .     .            5.25  .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, et, bien s√ªr, pour exp√©rimenter diff√©rentes m√©thodes de mise en cache SSD sous Linux.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les incursions mat√©rielles, c'est ennuyeux. </font><font style="vertical-align: inherit;">Allumer. </font><font style="vertical-align: inherit;">Cela fonctionne ou non. </font><font style="vertical-align: inherit;">Et avec mdadm, il y a toujours des options.</font></font></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doux</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auparavant, Debian 8 Jessie √©tait install√©e sur le mat√©riel, qui est proche d'EOL. </font><font style="vertical-align: inherit;">Le RAID 6 des disques durs mentionn√©s ci-dessus a √©t√© associ√© √† LVM. </font><font style="vertical-align: inherit;">Il ex√©cutait des machines virtuelles dans kvm / libvirt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parce que </font><font style="vertical-align: inherit;">L'auteur a l'exp√©rience appropri√©e dans la cr√©ation de lecteurs flash SATA / NVMe portables et √©galement, afin de ne pas d√©chirer le mod√®le apt habituel, Ubuntu 18.04 a √©t√© choisi comme syst√®me cible, qui s'est d√©j√† suffisamment stabilis√©, mais a encore 3 ans de support √† l'avenir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le syst√®me mentionn√©, tous les pilotes mat√©riels dont nous avons besoin sont pr√™ts √† l'emploi. </font><font style="vertical-align: inherit;">Nous n'avons besoin d'aucun logiciel et pilote tiers.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√©paration pour l'installation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour installer le syst√®me, nous avons besoin d'Ubuntu Desktop Image. </font><font style="vertical-align: inherit;">Le syst√®me serveur poss√®de une sorte de programme d'installation vigoureux qui pr√©sente une ind√©pendance excessive et non d√©connectable, poussant toujours la partition syst√®me UEFI sur l'un des disques, g√¢chant toute la beaut√©. </font><font style="vertical-align: inherit;">Par cons√©quent, il est install√© uniquement en mode UEFI. </font><font style="vertical-align: inherit;">Il n'offre pas d'options. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela ne nous convient pas.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi?</font></font></b><div class="spoiler_text"> , UEFI        RAID, ..   UEFI ESP     .    ,    ESP     USB , ,   .      mdadm RAID 1    0.9    UEFI BIOS   , ,       BIOS       -  ESP     .<br>
<br>
 ,  UEFI   NVRAM,         , ..    .<br>
<br>
 ,      .     ,       Legacy/BIOS boot,    CSM  UEFI- .      , ,      .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La version de bureau d'Ubuntu ne sait pas non plus comment s'installer normalement avec le chargeur de d√©marrage h√©rit√©, mais ici, comme on dit, il y a au moins des options. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et donc, collectez le mat√©riel et chargez le syst√®me √† partir du lecteur flash Ubuntu Live amor√ßable. </font><font style="vertical-align: inherit;">Nous devrons t√©l√©charger des packages, nous avons donc mis en place le r√©seau qui vous a valu. </font><font style="vertical-align: inherit;">Si cela ne fonctionne pas, vous pouvez t√©l√©charger √† l'avance les packages n√©cessaires sur la cl√© USB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons dans l'environnement de bureau, ex√©cutons l'√©mulateur de terminal et allons-y:</font></font><br>
<br>
<code>#sudo bash</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment...?</font></font></b><div class="spoiler_text">       sudo.  <b></b>    <b></b> .   ,       .     sudo   ,     . :<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/W-tPTmdnc7E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
</div></div><br>
<code>#apt-get install mdadm lvm2 thin-provisioning-tools btrfs-tools util-linux lsscsi nvme-cli mc</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi pas ZFS ...?</font></font></b><div class="spoiler_text">       , ‚Äî  ,         . <br>
        , ‚Äî        ,   -  .<br>
<br>
    ZFS ‚Äî  ,  mdadm+lvm    .<br>
<br>
           .      .   .  .  .  .      ,       . <br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi alors BTRFS ...?</font></font></b><div class="spoiler_text">            Legacy/BIOS GRUB  , ,  ,   -.      /boot .  ,       / ()   ,           LVM     . <br>
<br>
   ,          .<br>
                       send/recieve.<br>
<br>
 ,                        GPU  PCI-USB Host-  KVM  IOMMU.<br>
<br>
    ‚Äî  ,    .<br>
<br>
    ZFS, ,  ,     .<br>
<br>
  ,       / RAID      ZFS, BRTFS  LVM.<br>
<br>
   , BTRFS       ,         /    HDD.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Analyser √† nouveau tous les appareils: regardons autour de nous </font></font><br>
<br>
<code>#udevadm control --reload-rules &amp;&amp; udevadm trigger</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
:</font></font><br>
<br>
<code>#lsscsi &amp;&amp; nvme list<br>
[0:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sda <br>
[1:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sdb <br>
[2:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sdc <br>
[3:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sdd <br>
[4:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sde <br>
[5:0:0:0] disk ATA Samsung SSD 860 2B6Q /dev/sdf <br>
[6:0:0:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdg <br>
[6:0:1:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdh <br>
[6:0:2:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdi <br>
[6:0:3:0] disk ATA HGST HTS721010A9 A3B0 /dev/sdj <br>
[6:0:4:0] disk ATA HGST HTS721010A9 A3B0 /dev/sdk <br>
[6:0:5:0] disk ATA HGST HTS721010A9 A3B0 /dev/sdl <br>
[6:0:6:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdm <br>
[6:0:7:0] disk ATA HGST HTS721010A9 A3J0 /dev/sdn <br>
Node SN Model Namespace Usage Format FW Rev <br>
---------------- -------------------- ---------------------------------------- --------- -------------------------- ---------------- --------<br>
/dev/nvme0n1 S466NXXXXXXX15L Samsung SSD 970 EVO 500GB 1 0,00 GB / 500,11 GB 512 B + 0 B 2B2QEXE7<br>
/dev/nvme1n1 S5H7NXXXXXXX48N Samsung SSD 970 EVO 500GB 1 0,00 GB / 500,11 GB 512 B + 0 B 2B2QEXE7<br>
</code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partitionnement des "lecteurs"</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVMe SSD</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais en aucun cas nous ne les annotons. </font><font style="vertical-align: inherit;">Tout de m√™me, notre BIOS ne voit pas ces disques. </font><font style="vertical-align: inherit;">Ainsi, ils iront enti√®rement au RAID logiciel. </font><font style="vertical-align: inherit;">Nous n'y cr√©erons m√™me pas de partitions. </font><font style="vertical-align: inherit;">Si vous voulez selon le "canon" ou le "principe" - cr√©ez une grande partition, comme un disque dur.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disque dur SATA</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'y a rien de sp√©cial √† inventer. </font><font style="vertical-align: inherit;">Nous cr√©erons une section pour tout. </font><font style="vertical-align: inherit;">Nous allons cr√©er la section car le BIOS voit ces disques et peut m√™me essayer de d√©marrer √† partir d'eux. </font><font style="vertical-align: inherit;">Nous installerons m√™me GRUB plus tard sur ces disques afin que le syst√®me r√©ussisse soudainement.</font></font><br>
<br>
<code>#cat &gt;hdd.part &lt;&lt; EOF<br>
label: dos<br>
label-id: 0x00000000<br>
device: /dev/sdg<br>
unit: sectors<br>
<br>
/dev/sdg1 : start= 2048, size= 1953523120, type=fd, bootable<br>
EOF<br>
#sfdisk /dev/sdg &lt; hdd.part<br>
#sfdisk /dev/sdh &lt; hdd.part<br>
#sfdisk /dev/sdi &lt; hdd.part<br>
#sfdisk /dev/sdj &lt; hdd.part<br>
#sfdisk /dev/sdk &lt; hdd.part<br>
#sfdisk /dev/sdl &lt; hdd.part<br>
#sfdisk /dev/sdm &lt; hdd.part<br>
#sfdisk /dev/sdn &lt; hdd.part<br>
</code><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSD SATA</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous avons le plus int√©ressant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Premi√®rement, nous avons 2 disques TB. </font><font style="vertical-align: inherit;">Ceci est dans les limites autoris√©es pour MBR, que nous utiliserons. </font><font style="vertical-align: inherit;">Si n√©cessaire, peut √™tre remplac√© par GPT. </font><font style="vertical-align: inherit;">Les disques GPT ont une couche de compatibilit√© qui permet aux syst√®mes compatibles MBR de voir les 4 premi√®res partitions si elles se trouvent dans les 2 premiers t√©raoctets. </font><font style="vertical-align: inherit;">L'essentiel est que la partition de d√©marrage et la partition bios_grub sur ces disques soient au d√©but. </font><font style="vertical-align: inherit;">Cela vous permet m√™me de d√©marrer √† partir du lecteur GPT Legacy / BIOS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais ce n'est pas notre cas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous allons cr√©er deux sections. </font><font style="vertical-align: inherit;">Le premier sera de 1 Go et utilis√© pour RAID 1 / boot. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le second sera utilis√© pour RAID 6 et occupera tout l'espace libre restant √† l'exception d'une petite zone non allou√©e √† la fin du lecteur.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle est la zone non allou√©e?</font></font></b><div class="spoiler_text">     SATA SSD      SLC    6  78 . 6    ¬´¬ª     ¬´¬ª  ¬´¬ª   .  72      . <br>
<br>
  ,     SLC,      4 bit MLC.     ,    4       1  SLC .<br>
<br>
 72   4   288 .           ,       SLC .<br>
<br>
 ,     312  SLC     .    2    RAID  .<br>
<br>
            ,      .        QLC , ‚Äî          .      , ,       ,    SSD     TBW  .<br>
</div></div><br>
<code>#cat &gt;ssd.part &lt;&lt; EOF<br>
label: dos<br>
label-id: 0x00000000<br>
device: /dev/sda<br>
unit: sectors<br>
<br>
/dev/sda1 : start= 2048, size= 2097152, type=fd, bootable<br>
/dev/sda2 : start= 2099200, size= 3300950016, type=fd<br>
EOF<br>
#sfdisk /dev/sda &lt; ssd.part<br>
#sfdisk /dev/sdb &lt; ssd.part<br>
#sfdisk /dev/sdc &lt; ssd.part<br>
#sfdisk /dev/sdd &lt; ssd.part<br>
#sfdisk /dev/sde &lt; ssd.part<br>
#sfdisk /dev/sdf &lt; ssd.part<br>
</code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ation de tableaux</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous devons d'abord renommer la voiture. </font><font style="vertical-align: inherit;">Cela est n√©cessaire car le nom d'h√¥te fait partie du nom du tableau quelque part dans mdadm et affecte quelque chose quelque part. </font><font style="vertical-align: inherit;">Les tableaux, bien s√ªr, peuvent √™tre renomm√©s plus tard, mais ce sont des actions inutiles.</font></font><br>
<br>
<code>#mcedit /etc/hostname <br>
#mcedit /etc/hosts<br>
#hostname<br>
vdesk0<br>
</code><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVMe SSD</font></font></h4><br>
<code>#mdadm --create --verbose --assume-clean /dev/md0 --level=1 --raid-devices=2 /dev/nvme[0-1]n1</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi - assumer-nettoyer ...?</font></font></b><div class="spoiler_text">   .    RAID 1  6  .      ,    .  ,   SSD   ‚Äî     TBW.   TRIM/DISCARD      SSD   ¬´¬ª.<br>
<br>
  SSD RAID 1 DISCARD   .<br>
<br>
  SSD RAID 6 DISCARD      . <br>
<br>
      ,    SSD     4/5/6       discard_zeroes_data.    ,       , , -,  ,     .       , ,       .     DISCARD -   RAID 6.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Attention, la commande suivante d√©truira toutes les donn√©es sur les disques NVMe en ¬´initialisant¬ª la baie avec des ¬´z√©ros¬ª. </font></font><br>
<br>
<code>#blkdiscard /dev/md0</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cas de probl√®me, essayez de sp√©cifier une √©tape.</font></font><br>
<br>
<code>#blkdiscard --step 65536 /dev/md0</code><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSD SATA</font></font></h4><br>
<code>#mdadm --create --verbose --assume-clean /dev/md1 --level=1 --raid-devices=6 /dev/sd[a-f]1</code><br>
<code>#blkdiscard /dev/md1</code><br>
<code>#mdadm --create --verbose --assume-clean /dev/md2 --chunk-size=512 --level=6 --raid-devices=6 /dev/sd[a-f]2</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi si gros ...?</font></font></b><div class="spoiler_text"> chunk-size         chunk-size .   ,              . , IOPS    .   99% IO   512K.<br>
<br>
 RAID 6 IOPS   <b></b>    IOPS   .      IOPS          ,       . <br>
           RAID 6 by-design     ,   RAID 6   .<br>
   RAID 6      NVMe    thin-provisioning.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous n'avons pas encore activ√© DISCARD pour RAID 6. Nous n'allons donc pas encore ¬´initialiser¬ª cette baie. </font><font style="vertical-align: inherit;">Nous le ferons plus tard, apr√®s avoir install√© le syst√®me d'exploitation.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disque dur SATA</font></font></h4><br>
<code>#mdadm --create --verbose --assume-clean /dev/md3 --chunk-size=512 --level=6 --raid-devices=8 /dev/sd[g-n]1</code><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LVM sur NVMe RAID</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour la vitesse, nous voulons placer la racine FS sur NVMe RAID 1 qui est / dev / md0. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√©anmoins, nous avons toujours besoin de ce tableau rapide pour d'autres besoins, tels que le swap, les m√©tadonn√©es et le cache LVM et les m√©tadonn√©es LVM-thin, par cons√©quent, sur ce tableau, nous cr√©erons LVM VG. </font><font style="vertical-align: inherit;">
Cr√©ez une partition pour le FS racine. </font><font style="vertical-align: inherit;">
Cr√©ez une section pour √©changer la taille de la RAM.</font></font><br>
<br>
<code>#pvcreate /dev/md0<br>
#vgcreate root /dev/md0</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 128G --name root root</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 32G --name swap root</code><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installation du syst√®me d'exploitation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au total, nous avons tout le n√©cessaire pour installer le syst√®me. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lancez l'assistant d'installation √† partir de l'environnement Ubuntu Live. </font><font style="vertical-align: inherit;">Installation normale. </font><font style="vertical-align: inherit;">Seulement au stade de la s√©lection des lecteurs pour l'installation, vous devez sp√©cifier les √©l√©ments suivants:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / md1, - point de montage / d√©marrage, FS - BTRFS </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / root / root (alias / dev / mapper / root-root), - point de montage / (root), FS - BTRFS</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ dev / root / swap (alias / dev / mapper / root-swap), - utiliser comme partition de swap</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installation du chargeur de d√©marrage sur / dev / sda</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous s√©lectionnez BTRFS comme racine FS, le programme d'installation cr√©e automatiquement deux volumes BTRFS avec les noms "@" pour / (root) et "@home" pour / home. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous commen√ßons l'installation ... L' </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
installation se terminera par une bo√Æte de dialogue modale informant de l'erreur d'installation du chargeur de d√©marrage. </font><font style="vertical-align: inherit;">Malheureusement, sortir de ce dialogue par des moyens r√©guliers et poursuivre l'installation √©chouera. </font><font style="vertical-align: inherit;">Nous nous d√©connectons du syst√®me et nous nous connectons √† nouveau, en entrant dans le bureau Ubuntu Live propre. </font><font style="vertical-align: inherit;">Ouvrez le terminal, puis √† nouveau: </font></font><br>
<br>
<code>#sudo bash</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cr√©ez un environnement chroot pour continuer l'installation: configurez le </font><font style="vertical-align: inherit;">
r√©seau et le nom d'h√¥te dans chroot: </font><font style="vertical-align: inherit;">
acc√©dez √† l'environnement chroot: </font><font style="vertical-align: inherit;">
commencez par livrer les packages: </font><font style="vertical-align: inherit;">
v√©rifiez et r√©parez tous les packages qui ont √©t√© tordus en raison de l'installation incompl√®te du syst√®me:</font></font><br>
<br>
<code>#mkdir /mnt/chroot<br>
#mount -o defaults,space_cache,noatime,nodiratime,discard,subvol=@ /dev/mapper/root-root /mnt/chroot<br>
#mount -o defaults,space_cache,noatime,nodiratime,discard,subvol=@home /dev/mapper/root-root /mnt/chroot/home<br>
#mount -o defaults,space_cache,noatime,nodiratime,discard /dev/md1 /mnt/chroot/boot<br>
#mount --bind /proc /mnt/chroot/proc <br>
#mount --bind /sys /mnt/chroot/sys<br>
#mount --bind /dev /mnt/chroot/dev<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#cat /etc/hostname &gt;/mnt/chroot/etc/hostname<br>
#cat /etc/hosts &gt;/mnt/chroot/etc/hosts<br>
#cat /etc/resolv.conf &gt;/mnt/chroot/etc/resolv.conf<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#chroot /mnt/chroot<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>apt-get install --reinstall mdadm lvm2 thin-provisioning-tools btrfs-tools util-linux lsscsi nvme-cli mc debsums hdparm</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#CORRUPTED_PACKAGES=$(debsums -s 2&gt;&amp;1 | awk '{print $6}' | uniq)<br>
#apt-get install --reinstall $CORRUPTED_PACKAGES<br>
</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si quelque chose ne se d√©veloppe pas ensemble, vous devrez peut-√™tre </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
modifier </font><font style="vertical-align: inherit;">/etc/apt/sources.list avant cela. </font><font style="vertical-align: inherit;">Modifions les param√®tres du module RAID 6 pour activer TRIM / DISCARD: Nous </font><font style="vertical-align: inherit;">
ajusterons l√©g√®rement nos tableaux:</font></font><br>
<br>
<code>#cat &gt;/etc/modprobe.d/raid456.conf &lt;&lt; EOF<br>
options raid456 devices_handle_discard_safely=1<br>
EOF<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#cat &gt;/etc/udev/rules.d/60-md.rules &lt;&lt; EOF<br>
SUBSYSTEM=="block", KERNEL=="md*", ACTION=="change", TEST=="md/stripe_cache_size", ATTR{md/stripe_cache_size}="32768"<br>
SUBSYSTEM=="block", KERNEL=="md*", ACTION=="change", TEST=="md/sync_speed_min", ATTR{md/sync_speed_min}="48000"<br>
SUBSYSTEM=="block", KERNEL=="md*", ACTION=="change", TEST=="md/sync_speed_max", ATTR{md/sync_speed_max}="300000"<br>
EOF<br>
#cat &gt;/etc/udev/rules.d/62-hdparm.rules &lt;&lt; EOF<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="1", RUN+="/sbin/hdparm -B 254 /dev/%k"<br>
EOF<br>
#cat &gt;/etc/udev/rules.d/63-blockdev.rules &lt;&lt; EOF<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="1", RUN+="/sbin/blockdev --setra 1024 /dev/%k"<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/rotational}=="0", RUN+="/sbin/blockdev --setra 0 /dev/%k"<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="nvme[0-9]n1", RUN+="/sbin/blockdev --setra 0 /dev/%k"<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="dm-*", ATTR{queue/rotational}=="0", RUN+="/sbin/blockdev --setra 0 /dev/%k"<br>
SUBSYSTEM=="block", ACTION=="add|change", KERNEL=="md*", RUN+="/sbin/blockdev --setra 0 /dev/%k"<br>
<br>
EOF<br>
</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce que c'√©tait..?</font></font></b><div class="spoiler_text">   udev     :<br>
<br>
<ul>
<li>    2020-      RAID 6.  -, ,      Linux,     .</li>
<li>    /   IO.  ,           .</li>
<li>    /   IO.  ,  / SSD RAID-       .    NVMe. (   ?    . )</li>
<li>   APM     (HDD)         7 .    APM      (-B 255).   -      .      ,   , ,  -.       .    -        .     , , - ¬´¬ª,    -,    RAID-   mini-MAID-.</li>
<li> readahead   ()  1  ‚Äî   /chunk RAID 6</li>
<li> readahead  SATA SSD</li>
<li> readahead  NVMe SSD</li>
<li> readahead   LVM    SSD.</li>
<li> readahead   RAID .</li>
</ul><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modifiez / etc / fstab:</font></font><br>
<br>
<code>#cat &gt;/etc/fstab &lt;&lt; EOF<br>
# /etc/fstab: static file system information.<br>
#<br>
# Use 'blkid' to print the universally unique identifier for a<br>
# device; this may be used with UUID= as a more robust way to name devices<br>
# that works even if disks are added and removed. See fstab(5).<br>
# file-system mount-point type options dump pass<br>
/dev/mapper/root-root / btrfs defaults,space_cache,noatime,nodiratime,discard,subvol=@ 0 1<br>
UUID=$(blkid -o value -s UUID /dev/md1) /boot btrfs defaults,space_cache,noatime,nodiratime,discard 0 2<br>
/dev/mapper/root-root /home btrfs defaults,space_cache,noatime,nodiratime,discard,subvol=@home 0 2<br>
/dev/mapper/root-swap none swap sw 0 0<br>
EOF</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi donc..?</font></font></b><div class="spoiler_text"> /boot     UUID ..     .<br>
<br>
      LVM    /dev/mapper/vg-lv, ..     . <br>
<br>
  UUID  LVM .. UUID  LVM      .</div></div><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous montons deux fois / dev / mapper / root-root ..?</font></font></b><div class="spoiler_text">.  .  BTRFS.         subvol.<br>
<br>
  -      LVM   BTRFS .     .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous r√©g√©n√©rons la configuration mdadm: </font><font style="vertical-align: inherit;">
Corrigez les param√®tres LVM:</font></font><br>
<br>
<code>#/usr/share/mdadm/mkconf | sed 's/#DEVICE/DEVICE/g' &gt;/etc/mdadm/mdadm.conf<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#cat &gt;&gt;/etc/lvm/lvmlocal.conf &lt;&lt; EOF<br>
<br>
activation {<br>
 thin_pool_autoextend_threshold=90<br>
 thin_pool_autoextend_percent=5<br>
}<br>
allocation {<br>
 cache_pool_max_chunks=2097152<br>
}<br>
devices {<br>
 global_filter=["r|^/dev/.*_corig$|","r|^/dev/.*_cdata$|","r|^/dev/.*_cmeta$|","r|^/dev/.*gpv$|","r|^/dev/images/.*$|","r|^/dev/mapper/images.*$|","r|^/dev/backup/.*$|","r|^/dev/mapper/backup.*$|"]<br>
 issue_discards=1<br>
}<br>
EOF<br>
</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce que c'√©tait..?</font></font></b><div class="spoiler_text">     LVM thin   90%    5%  .<br>
<br>
       LVM cache.<br>
<br>
  LVM  LVM  (PV) :<br>
<br>
<ul>
<li>   LVM cache (cdata)</li>
<li>     LVM cache    (&lt;lv_name&gt;_corig).            ( &lt;lv_name&gt;).</li>
<li>    LVM cache (cmeta)</li>
<li>    VG   images.        , ,     LVM       .</li>
<li>    VG   backup.         .</li>
<li>       ¬´gpv¬ª ( guest physical volume )</li>
</ul><br>
   DISCARD      LVM VG.  .    LV  SSD  .     SSD RAID 6. ,  ,    thin provisioning,  ,     .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mettez √† jour l'image initramfs: </font></font><br>
<br>
<code>#update-initramfs -u -k all</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Installez et configurez grub:</font></font><br>
<br>
<code>#apt-get install grub-pc<br>
#apt-get purge os-prober<br>
#dpkg-reconfigure grub-pc</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelles motivations choisir?</font></font></b><div class="spoiler_text">  sd*.         SATA   SSD.<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi os-prober clou√© ..?</font></font></b><div class="spoiler_text">     . <br>
<br>
       RAID-    .      ,         .<br>
<br>
   ,   , ,    .         .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec cela, nous avons termin√© l'installation initiale. </font><font style="vertical-align: inherit;">Il est temps de red√©marrer dans le syst√®me d'exploitation nouvellement install√©. </font><font style="vertical-align: inherit;">N'oubliez pas de retirer le Live CD / USB amor√ßable. </font><font style="vertical-align: inherit;">
Pour d√©marrer, s√©lectionnez l'un des SSD SATA.</font></font><br>
<br>
<code>#exit<br>
#reboot</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LVM vers SSD SATA</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä ce stade, nous avons d√©j√† d√©marr√© dans le nouveau syst√®me d'exploitation, configur√© le r√©seau, apt, ouvert l'√©mulateur de terminal et commenc√©: </font></font><br>
<br>
<code>#sudo bash</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Continuer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Initialiser" une matrice √† partir d'un SSD SATA: </font></font><br>
<br>
<code>#blkdiscard /dev/md2</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si ce n'est pas le cas, essayez: </font></font><br>
<br>
<code>#blkdiscard --step 65536 /dev/md2</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cr√©er LVM VG sur un SSD SATA:</font></font><br>
<br>
<code>#pvcreate /dev/md2<br>
#vgcreate data /dev/md2</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi un autre vg ..?</font></font></b><div class="spoiler_text">  ,     VG   root.        VG?<br>
<br>
  VG   PV,     VG  PV   (online).   LVM RAID,     .<br>
<br>
  ,    (  )    RAID 6           .<br>
<br>
 ,           ¬´¬ª   VG.<br>
<br>
 -,   RAID     ¬´ ¬ª.         ,    VG.<br>
<br>
 LVM  ¬´¬ª        RAID  -  . , ‚Äî  <b></b> bcache + LVM thin, bcache + BTRFS, LVM cache + LVM thin,   ZFS       ,      .<br>
<br>
 ¬´¬ª   ,  - ¬´¬ª LVM-,   .    , ,     .<br>
<br>
,   ,     -   .<br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disque dur LVM vers SATA</font></font></h3><br>
<code>#pvcreate /dev/md3<br>
#vgcreate backup /dev/md3</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encore une fois le nouveau VG ..?</font></font></b><div class="spoiler_text">  ,     ,        ,      , -     . , -   VG, ‚Äî    VG.<br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configurer le cache LVM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cr√©ez LV sur NVMe RAID 1 pour l'utiliser comme p√©riph√©rique de mise en cache.</font></font><br>
<br>
<code>#lvcreate -L 70871154688B --name cache root</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi si peu ...?</font></font></b><div class="spoiler_text">  ,    NVMe SSD   SLC . 4  ¬´¬ª  18         3-bit MLC. -   NVMe SSD       SATA SSD  . ,        LVM cache      SLC  NVMe .   NVMe      32-64  . <br>
<br>
      64  ,       .<br>
<br>
 ,      LVM         .  ,       lvchange       . ,      .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cr√©ons LV sur SATA RAID 6 pour l'utiliser comme p√©riph√©rique mis en cache.</font></font><br>
<br>
<code>#lvcreate -L 3298543271936B --name cache data</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi seulement trois t√©raoctets ..?</font></font></b><div class="spoiler_text">,  ,    SATA SSD RAID 6  -  .      ,  ,    .         , ,   LVM-cache , , bcache,  ,      .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cr√©ez un nouveau VG pour la mise en cache. </font><font style="vertical-align: inherit;">
Cr√©ez LV sur le p√©riph√©rique mis en cache. </font><font style="vertical-align: inherit;">
Ici, nous avons imm√©diatement pris tout l'espace libre sur / dev / data / cache afin que toutes les autres partitions n√©cessaires soient cr√©√©es imm√©diatement sur / dev / root / cache. </font><font style="vertical-align: inherit;">Si vous avez quelque chose qui n'y est pas cr√©√©, vous pouvez le d√©placer √† l'aide de pvmove. </font><font style="vertical-align: inherit;">
Cr√©ez et activez le cache:</font></font><br>
<br>
<code>#pvcreate /dev/root/cache<br>
#pvcreate /dev/data/cache<br>
#vgcreate cache /dev/root/cache /dev/data/cache</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 3298539077632B --name cachedata cache /dev/data/cache</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -y -L 64G -n cache cache /dev/root/cache<br>
#lvcreate -y -L 1G -n cachemeta cache /dev/root/cache<br>
#lvconvert -y --type cache-pool --cachemode writeback --chunksize 64k --poolmetadata cache/cachemeta cache/cache<br>
#lvconvert -y --type cache --cachepool cache/cache cache/cachedata<br>
</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi tant de gros morceaux ..?</font></font></b><div class="spoiler_text">     ,        LVM cache     LVM thin.  ,   ,        . <br>
<br>
64 ‚Äî       LVM thin.<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attention l'√©criture diff√©r√©e ..!</font></font></b><div class="spoiler_text">.         .    , ,    ,      .   ,  ,  NVMe RAID 1  ,    . <br>
<br>
    ,     RAID 6   .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V√©rifions que nous avons r√©ussi: </font><font style="vertical-align: inherit;">
seul [cachedata_corig] doit se trouver sur / dev / data / cache. </font><font style="vertical-align: inherit;">Si quelque chose ne va pas, utilisez pvmove. </font><font style="vertical-align: inherit;">
Si n√©cessaire, vous pouvez d√©sactiver le cache avec une seule commande: </font><font style="vertical-align: inherit;">
cela se fait en ligne. </font><font style="vertical-align: inherit;">LVM synchronise simplement le cache sur le disque, le supprime et renomme cachedata_corig en cachedata.</font></font><br>
<br>
<code>#lvs -a -o lv_name,lv_size,devices --units B cache<br>
 LV LSize Devices <br>
 [cache] 68719476736B cache_cdata(0) <br>
 [cache_cdata] 68719476736B /dev/root/cache(0) <br>
 [cache_cmeta] 1073741824B /dev/root/cache(16384)<br>
 cachedata 3298539077632B cachedata_corig(0) <br>
 [cachedata_corig] 3298539077632B /dev/data/cache(0) <br>
 [lvol0_pmspare] 1073741824B /dev/root/cache(16640)<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvconvert -y --uncache cache/cachedata</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuration fine LVM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons </font><font style="vertical-align: inherit;">
approximativement </font><font style="vertical-align: inherit;">estimer l'espace dont nous aurons besoin pour les m√©tadonn√©es minces LVM </font><font style="vertical-align: inherit;">
: arrondir </font><font style="vertical-align: inherit;">√† 4 gigaoctets: 4294967296B </font><font style="vertical-align: inherit;">Multiplier par deux et ajouter 4194304B pour les m√©tadonn√©es LVM PV: 8594128896B </font><font style="vertical-align: inherit;">
Cr√©ez une partition distincte sur NVMe RAID 1 pour y d√©limiter les m√©tadonn√©es minces LVM et les sauvegarder:</font></font><br>
<br>
<code>#thin_metadata_size --block-size=64k --pool-size=6terabytes --max-thins=100000 -u bytes<br>
thin_metadata_size - 3385794560 bytes estimated metadata area size for "--block-size=64kibibytes --pool-size=6terabytes --max-thins=100000"</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 8594128896B --name images root</code><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi..?</font></font></b><div class="spoiler_text">   ,    LVM thin ,        NVMe    .<br>
<br>
     ,     .    ,  ,   .    - , ,   LVM thin  ,      .         .<br>
<br>
-    -,  , ,          .             ,      .           .<br>
<br>
 ,        , ,  ,       , ,      LVM thin,        . <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cr√©ez un nouveau VG qui sera responsable de l'allocation dynamique: </font><font style="vertical-align: inherit;">
Cr√©ez un pool:</font></font><br>
<br>
<code>#pvcreate /dev/root/images<br>
#pvcreate /dev/cache/cachedata<br>
#vgcreate images /dev/root/images /dev/cache/cachedata</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -L 274877906944B --poolmetadataspare y --poolmetadatasize 4294967296B --chunksize 64k -Z y -T images/thin-pool</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi -Z y</font></font></b><div class="spoiler_text"> ,       , ‚Äî               , ‚Äî zeroing          64k.    64k           64K    .          .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D√©pla√ßons LV vers les PV correspondants: </font><font style="vertical-align: inherit;">
V√©rifiez: </font><font style="vertical-align: inherit;">
Cr√©ez un volume mince pour les tests: </font><font style="vertical-align: inherit;">
Mettez des packages pour les tests et les observations: </font><font style="vertical-align: inherit;">
Voici comment vous pouvez observer le comportement de notre configuration de stockage en temps r√©el: </font><font style="vertical-align: inherit;">
Voici comment vous pouvez tester notre configuration:</font></font><br>
<br>
<code>#pvmove -n images/thin-pool_tdata /dev/root/images /dev/cache/cachedata<br>
#pvmove -n images/lvol0_pmspare /dev/cache/cachedata /dev/root/images<br>
#pvmove -n images/thin-pool_tmeta /dev/cache/cachedata /dev/root/images <br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvs -a -o lv_name,lv_size,devices --units B images<br>
 LV LSize Devices <br>
 [lvol0_pmspare] 4294967296B /dev/root/images(0) <br>
 thin-pool 274877906944B thin-pool_tdata(0) <br>
 [thin-pool_tdata] 274877906944B /dev/cache/cachedata(0) <br>
 [thin-pool_tmeta] 4294967296B /dev/root/images(1024)<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#lvcreate -V 64G --thin-pool thin-pool --name test images</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#apt-get install sysstat fio</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#watch 'lvs --rows --reportformat basic --quiet -ocache_dirty_blocks,cache_settings cache/cachedata &amp;&amp; (lvdisplay cache/cachedata | grep Cache) &amp;&amp; (sar -p -d 2 1 | grep -E "sd|nvme|DEV|md1|md2|md3|md0" | grep -v Average | sort)'</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#fio --loops=1 --size=64G --runtime=4 --filename=/dev/images/test --stonewall --ioengine=libaio --direct=1 \<br>
--name=4kQD32read --bs=4k --iodepth=32 --rw=randread \<br>
--name=8kQD32read --bs=8k --iodepth=32 --rw=randread \<br>
--name=16kQD32read --bs=16k --iodepth=32 --rw=randread \<br>
--name=32KQD32read --bs=32k --iodepth=32 --rw=randread \<br>
--name=64KQD32read --bs=64k --iodepth=32 --rw=randread \<br>
--name=128KQD32read --bs=128k --iodepth=32 --rw=randread \<br>
--name=256KQD32read --bs=256k --iodepth=32 --rw=randread \<br>
--name=512KQD32read --bs=512k --iodepth=32 --rw=randread \<br>
--name=4Kread --bs=4k --rw=read \<br>
--name=8Kread --bs=8k --rw=read \<br>
--name=16Kread --bs=16k --rw=read \<br>
--name=32Kread --bs=32k --rw=read \<br>
--name=64Kread --bs=64k --rw=read \<br>
--name=128Kread --bs=128k --rw=read \<br>
--name=256Kread --bs=256k --rw=read \<br>
--name=512Kread --bs=512k --rw=read \<br>
--name=Seqread --bs=1m --rw=read \<br>
--name=Longread --bs=8m --rw=read \<br>
--name=Longwrite --bs=8m --rw=write \<br>
--name=Seqwrite --bs=1m --rw=write \<br>
--name=512Kwrite --bs=512k --rw=write \<br>
--name=256Kwrite --bs=256k --rw=write \<br>
--name=128Kwrite --bs=128k --rw=write \<br>
--name=64Kwrite --bs=64k --rw=write \<br>
--name=32Kwrite --bs=32k --rw=write \<br>
--name=16Kwrite --bs=16k --rw=write \<br>
--name=8Kwrite --bs=8k --rw=write \<br>
--name=4Kwrite --bs=4k --rw=write \<br>
--name=512KQD32write --bs=512k --iodepth=32 --rw=randwrite \<br>
--name=256KQD32write --bs=256k --iodepth=32 --rw=randwrite \<br>
--name=128KQD32write --bs=128k --iodepth=32 --rw=randwrite \<br>
--name=64KQD32write --bs=64k --iodepth=32 --rw=randwrite \<br>
--name=32KQD32write --bs=32k --iodepth=32 --rw=randwrite \<br>
--name=16KQD32write --bs=16k --iodepth=32 --rw=randwrite \<br>
--name=8KQD32write --bs=8k --iodepth=32 --rw=randwrite \<br>
--name=4kQD32write --bs=4k --iodepth=32 --rw=randwrite \<br>
 | grep -E 'read|write|test' | grep -v ioengine<br>
</code><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mise en garde! </font><font style="vertical-align: inherit;">Ressource!</font></font></b><div class="spoiler_text">   36  ,       4 .     .  4   NVMe     .  3   .  ,           216   SSD.<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lecture et √©criture al√©atoire?</font></font></b><div class="spoiler_text">.          .  ,   ,    ,        .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les r√©sultats varient consid√©rablement au premier d√©marrage et aux suivants √† mesure que le cache et le volume l√©ger se remplissent, et √©galement, selon que le syst√®me a r√©ussi √† synchroniser les caches remplis au dernier d√©marrage.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entre autres choses, je recommande de mesurer la vitesse sur le volume mince d√©j√† rempli √† partir duquel l'instantan√© vient d'√™tre r√©alis√©. </font><font style="vertical-align: inherit;">L'auteur a eu l'occasion d'observer comment un enregistrement al√©atoire acc√©l√®re fortement imm√©diatement apr√®s la cr√©ation du premier instantan√©, en particulier lorsque le cache n'est pas encore plein. </font><font style="vertical-align: inherit;">Cela est d√ª √† la s√©mantique d'√©criture sur copie, √† l'alignement des blocs de cache et des volumes minces, et au fait que l'√©criture al√©atoire sur RAID 6 se transforme en lecture al√©atoire sur RAID 6, puis √©crit dans le cache. </font><font style="vertical-align: inherit;">Dans notre configuration, la lecture al√©atoire de RAID 6 √† 6 fois (le nombre de SSD SATA dans la baie) est plus rapide que l'√©criture. </font><font style="vertical-align: inherit;">Parce que </font><font style="vertical-align: inherit;">√âtant donn√© que les blocs CoW sont allou√©s s√©quentiellement √† partir d'un pool mince, l'enregistrement, pour la plupart, devient √©galement s√©quentiel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces deux fonctionnalit√©s peuvent √™tre avantageusement utilis√©es.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mettre en cache des instantan√©s ¬´coh√©rents¬ª</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour r√©duire le risque de perte de donn√©es en cas d'endommagement / perte de cache, l'auteur sugg√®re d'introduire la pratique des instantan√©s tournants pour garantir leur int√©grit√© dans ce cas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Premi√®rement, du fait que les m√©tadonn√©es des volumes minces sont situ√©es sur un p√©riph√©rique non mis en cache, les m√©tadonn√©es seront coh√©rentes et les √©ventuelles pertes seront isol√©es √† l'int√©rieur des blocs de donn√©es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le cycle de rotation des instantan√©s suivant garantit l'int√©grit√© des donn√©es √† l'int√©rieur des instantan√©s en cas de perte de cache:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour chaque volume l√©ger portant le nom &lt;nom&gt;, cr√©ez un instantan√© avec le nom &lt;nom&gt; .cached</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©finissez le seuil de migration sur une valeur √©lev√©e raisonnable: </font></font><code>#lvchange --quiet --cachesettings "migration_threshold=16384" cache/cachedata</code> </li>
<li>       : <code>#lvs --rows --reportformat basic --quiet -ocache_dirty_blocks cache/cachedata | awk '{print $2}'</code>    .     ,        writethrough . ,      SATA  NVMe SSD,  ,   TBW,            ,           . -          100%    .  NVMe SSD  100%        <b>3-4 </b>. SATA SSD  -    . ,   ,       ,     , ‚Äî             .</li>
<li>   ( )  ‚Äî  &lt;&gt;.cached  &lt;&gt;.committed.  &lt;&gt;.committed   .</li>
<li>,     100%,    ,   .         .</li>
<li> migration threshold  : <code>#lvchange --quiet --cachesettings "migration_threshold=0" cache/cachedata</code>        . </li>
<li>,        <code>#lvs --rows --reportformat basic --quiet -ocache_dirty_blocks cache/cachedata | awk '{print $2}'</code>   .</li>
<li> . </li>
</ol><br>
<div class="spoiler"><b class="spoiler_title">   migration threshold...?</b><div class="spoiler_text">   ,     ¬´¬ª       .    -    4 ,   ,         -     (+- 32K) .<br>
<br>
 migration threshold        SATA SSD       64K  .      SATA SSD.<br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title">  ..?</b><div class="spoiler_text"> ,         bash     100%    ¬´google¬ª-driven development,  ,    ,      ,     .<br>
<br>
,               , ,  ,      systemd ,     .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un tel sch√©ma de rotation simple pour les instantan√©s nous permettra non seulement d'avoir constamment un instantan√© compl√®tement synchronis√© sur le SSD SATA, mais il nous permettra √©galement d'utiliser l'utilitaire thin_delta pour savoir quels blocs ont √©t√© modifi√©s apr√®s sa cr√©ation et, ainsi, localiser les dommages sur les volumes principaux, simplifiant grandement la r√©cup√©ration .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TRIM / DISCARD dans libvirt / KVM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parce que </font><font style="vertical-align: inherit;">√âtant donn√© que l'entrep√¥t de donn√©es sera utilis√© pour KVM ex√©cutant libvirt, il serait bon d'apprendre √† nos machines virtuelles non seulement √† occuper de l'espace libre, mais aussi √† lib√©rer ce qui n'est plus n√©cessaire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela se fait en √©mulant le support TRIM / DISCARD sur les disques virtuels. </font><font style="vertical-align: inherit;">Pour ce faire, changez le type de contr√¥leur en virtio-scsi et modifiez le xml. </font><font style="vertical-align: inherit;">
Les DISCARDs similaires des OS invit√©s sont correctement trait√©s par LVM et les blocs sont correctement lib√©r√©s √† la fois dans le cache et dans le thin pool. </font><font style="vertical-align: inherit;">Dans notre cas, cela se produit, principalement, report√©, lorsque vous supprimez l'instantan√© suivant.</font></font><br>
<br>
<code>#virsh edit vmname<br>
&lt;disk type='block' device='disk'&gt;<br>
 &lt;driver name='qemu' type='raw' cache='writethrough' io='threads' <b>discard='unmap'</b>/&gt;<br>
 &lt;source dev='/dev/images/vmname'/&gt;<br>
 &lt;backingStore/&gt;<br>
 &lt;target dev='sda' bus='scsi'/&gt;<br>
 &lt;alias name='scsi0-0-0-0'/&gt;<br>
 &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;<br>
&lt;/disk&gt;<br>
<br>
&lt;controller type='scsi' index='0' <b>model='virtio-scsi'</b>&gt;<br>
 &lt;alias name='scsi0'/&gt;<br>
 &lt;address type='pci' domain='0x0000' bus='0x04' slot='0x00' function='0x0'/&gt;<br>
&lt;/controller&gt;<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sauvegarde BTRFS</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilisez des scripts pr√™ts √† l'emploi avec une </font></font><u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extr√™me</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> prudence et </font></font><u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† vos risques et p√©rils</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">L'auteur a √©crit ce code lui-m√™me et exclusivement pour lui-m√™me. </font><font style="vertical-align: inherit;">Je suis s√ªr que de nombreux utilisateurs Linux exp√©riment√©s ont de telles </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b√©quilles d'</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> exp√©rience et que d'autres n'en auront pas besoin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cr√©er un volume sur le p√©riph√©rique de sauvegarde: le </font></font><br>
<br>
<code>#lvcreate -L 256G --name backup backup</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
formater en BTRFS: </font></font><br>
<br>
<code>#mkfs.btrfs /dev/backup/backup</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cr√©er des points de montage et monter des sous-cl√©s racine du FS: </font><font style="vertical-align: inherit;">
cr√©er des r√©pertoires pour les sauvegardes: </font><font style="vertical-align: inherit;">
cr√©er un r√©pertoire pour les scripts de sauvegarde: copier le </font><font style="vertical-align: inherit;">
script:</font></font><br>
<br>
<code>#mkdir /backup<br>
#mkdir /backup/btrfs<br>
#mkdir /backup/btrfs/root<br>
#mkdir /backup/btrfs/back<br>
#ln -s /boot /backup/btrfs<br>
# cat &gt;&gt;/etc/fstab &lt;&lt; EOF<br>
<br>
/dev/mapper/root-root /backup/btrfs/root btrfs defaults,space_cache,noatime,nodiratime 0 2<br>
/dev/mapper/backup-backup /backup/btrfs/back btrfs defaults,space_cache,noatime,nodiratime 0 2<br>
EOF<br>
#mount -a<br>
#update-initramfs -u<br>
#update-grub<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#mkdir /backup/btrfs/back/remote<br>
#mkdir /backup/btrfs/back/remote/root<br>
#mkdir /backup/btrfs/back/remote/boot<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#mkdir /root/btrfs-backup</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beaucoup de code bash effrayant. </font><font style="vertical-align: inherit;">√Ä utiliser √† vos risques et p√©rils. </font><font style="vertical-align: inherit;">L'auteur n'√©crit pas de lettres en col√®re ...</font></font></b><div class="spoiler_text"><code>#cat &gt;/root/btrfs-backup/btrfs-backup.sh &lt;&lt; EOF<br>
#!/bin/bash<br>
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"<br>
<br>
SCRIPT_FILE="$(realpath $0)"<br>
SCRIPT_DIR="$(dirname $SCRIPT_FILE)"<br>
SCRIPT_NAME="$(basename -s .sh $SCRIPT_FILE)"<br>
<br>
LOCK_FILE="/dev/shm/$SCRIPT_NAME.lock"<br>
DATE_PREFIX='%Y-%m-%d'<br>
DATE_FORMAT=$DATE_PREFIX'-%H-%M-%S'<br>
DATE_REGEX='[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]'<br>
BASE_SUFFIX=".@base"<br>
PEND_SUFFIX=".@pend"<br>
SNAP_SUFFIX=".@snap"<br>
MOUNTS="/backup/btrfs/"<br>
BACKUPS="/backup/btrfs/back/remote/"<br>
<br>
function terminate ()<br>
{<br>
 echo "$1" &gt;&amp;2<br>
 exit 1<br>
}<br>
<br>
function wait_lock()<br>
{<br>
 flock 98<br>
}<br>
<br>
function wait_lock_or_terminate()<br>
{<br>
 echo "Wating for lock..."<br>
 wait_lock || terminate "Failed to get lock. Exiting..."<br>
 echo "Got lock..."<br>
}<br>
<br>
function suffix()<br>
{<br>
 FORMATTED_DATE=$(date +"$DATE_FORMAT")<br>
 echo "$SNAP_SUFFIX.$FORMATTED_DATE"<br>
}<br>
<br>
function filter()<br>
{<br>
 FORMATTED_DATE=$(date --date="$1" +"$DATE_PREFIX")<br>
 echo "$SNAP_SUFFIX.$FORMATTED_DATE"<br>
}<br>
<br>
function backup()<br>
{<br>
SOURCE_PATH="$MOUNTS$1"<br>
TARGET_PATH="$BACKUPS$1"<br>
SOURCE_BASE_PATH="$MOUNTS$1$BASE_SUFFIX"<br>
TARGET_BASE_PATH="$BACKUPS$1$BASE_SUFFIX"<br>
TARGET_BASE_DIR="$(dirname $TARGET_BASE_PATH)"<br>
SOURCE_PEND_PATH="$MOUNTS$1$PEND_SUFFIX"<br>
TARGET_PEND_PATH="$BACKUPS$1$PEND_SUFFIX"<br>
 if [ -d "$SOURCE_BASE_PATH" ]<br>
 then<br>
 echo "$SOURCE_BASE_PATH found"<br>
 else<br>
 echo "$SOURCE_BASE_PATH File not found creating snapshot of $SOURCE_PATH to $SOURCE_BASE_PATH"<br>
 btrfs subvolume snapshot -r $SOURCE_PATH $SOURCE_BASE_PATH<br>
 sync<br>
 if [ -d "$TARGET_BASE_PATH" ]<br>
 then<br>
 echo "$TARGET_BASE_PATH found out of sync with source... removing..."<br>
 btrfs subvolume delete -c $TARGET_BASE_PATH<br>
 sync<br>
 fi<br>
 fi<br>
 if [ -d "$TARGET_BASE_PATH" ]<br>
 then<br>
 echo "$TARGET_BASE_PATH found"<br>
 else<br>
 echo "$TARGET_BASE_PATH not found. Synching to $TARGET_BASE_DIR"<br>
 btrfs send $SOURCE_BASE_PATH | btrfs receive $TARGET_BASE_DIR<br>
 sync<br>
 fi<br>
 if [ -d "$SOURCE_PEND_PATH" ]<br>
 then<br>
 echo "$SOURCE_PEND_PATH found removing..."<br>
 btrfs subvolume delete -c $SOURCE_PEND_PATH<br>
 sync<br>
 fi<br>
 btrfs subvolume snapshot -r $SOURCE_PATH $SOURCE_PEND_PATH<br>
 sync<br>
 if [ -d "$TARGET_PEND_PATH" ]<br>
 then<br>
 echo "$TARGET_PEND_PATH found removing..."<br>
 btrfs subvolume delete -c $TARGET_PEND_PATH<br>
 sync<br>
 fi<br>
 echo "Sending $SOURCE_PEND_PATH to $TARGET_PEND_PATH"<br>
 btrfs send -p $SOURCE_BASE_PATH $SOURCE_PEND_PATH | btrfs receive $TARGET_BASE_DIR<br>
 sync<br>
 TARGET_DATE_SUFFIX=$(suffix)<br>
 btrfs subvolume snapshot -r $TARGET_PEND_PATH "$TARGET_PATH$TARGET_DATE_SUFFIX"<br>
 sync<br>
 btrfs subvolume delete -c $SOURCE_BASE_PATH<br>
 sync<br>
 btrfs subvolume delete -c $TARGET_BASE_PATH<br>
 sync<br>
 mv $SOURCE_PEND_PATH $SOURCE_BASE_PATH<br>
 mv $TARGET_PEND_PATH $TARGET_BASE_PATH<br>
 sync<br>
}<br>
<br>
function list()<br>
{<br>
LIST_TARGET_BASE_PATH="$BACKUPS$1$BASE_SUFFIX"<br>
LIST_TARGET_BASE_DIR="$(dirname $LIST_TARGET_BASE_PATH)"<br>
LIST_TARGET_BASE_NAME="$(basename -s .$BASE_SUFFIX $LIST_TARGET_BASE_PATH)"<br>
find "$LIST_TARGET_BASE_DIR" -maxdepth 1 -mindepth 1 -type d -printf "%f\n" | grep "${LIST_TARGET_BASE_NAME/$BASE_SUFFIX/$SNAP_SUFFIX}.$DATE_REGEX"<br>
}<br>
<br>
function remove()<br>
{<br>
REMOVE_TARGET_BASE_PATH="$BACKUPS$1$BASE_SUFFIX"<br>
REMOVE_TARGET_BASE_DIR="$(dirname $REMOVE_TARGET_BASE_PATH)"<br>
btrfs subvolume delete -c $REMOVE_TARGET_BASE_DIR/$2<br>
sync<br>
}<br>
<br>
function removeall()<br>
{<br>
DATE_OFFSET="$2"<br>
FILTER="$(filter "$DATE_OFFSET")"<br>
while read -r SNAPSHOT ; do<br>
 remove "$1" "$SNAPSHOT"<br>
done &lt; &lt;(list "$1" | grep "$FILTER")<br>
<br>
}<br>
<br>
(<br>
 COMMAND="$1"<br>
 shift<br>
 <br>
 case "$COMMAND" in<br>
 "--help") <br>
 echo "Help"<br>
 ;;<br>
 "suffix") <br>
 suffix<br>
 ;;<br>
 "filter") <br>
 filter "$1"<br>
 ;;<br>
 "backup") <br>
 wait_lock_or_terminate<br>
 backup "$1"<br>
 ;;<br>
 "list") <br>
 list "$1"<br>
 ;;<br>
 "remove") <br>
 wait_lock_or_terminate<br>
 remove "$1" "$2"<br>
 ;;<br>
 "removeall") <br>
 wait_lock_or_terminate<br>
 removeall "$1" "$2"<br>
 ;;<br>
 *)<br>
 echo "None.."<br>
 ;;<br>
 esac<br>
) 98&gt;$LOCK_FILE <br>
<br>
EOF<br>
</code><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que fait-il m√™me ..?</font></font></b><div class="spoiler_text">       BTRFS        BTRFS send/recieve.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier lancement peut √™tre relativement long, car </font><font style="vertical-align: inherit;">au d√©but, toutes les donn√©es seront copi√©es. </font><font style="vertical-align: inherit;">D'autres lancements seront tr√®s rapides, car </font><font style="vertical-align: inherit;">seules les modifications seront copi√©es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre script √† entasser en cron:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un peu plus de code bash</font></font></b><div class="spoiler_text"><code>#cat &gt;/root/btrfs-backup/cron-daily.sh &lt;&lt; EOF<br>
#!/bin/bash<br>
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"<br>
<br>
SCRIPT_FILE="$(realpath $0)"<br>
SCRIPT_DIR="$(dirname $SCRIPT_FILE)"<br>
SCRIPT_NAME="$(basename -s .sh $SCRIPT_FILE)"<br>
<br>
BACKUP_SCRIPT="$SCRIPT_DIR/btrfs-backup.sh"<br>
RETENTION="-60 day"<br>
$BACKUP_SCRIPT backup root/@<br>
$BACKUP_SCRIPT removeall root/@ "$RETENTION"<br>
$BACKUP_SCRIPT backup root/@home<br>
$BACKUP_SCRIPT removeall root/@home "$RETENTION"<br>
$BACKUP_SCRIPT backup boot/<br>
$BACKUP_SCRIPT removeall boot/ "$RETENTION"<br>
EOF<br>
</code><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce que √ßa fait ..?</font></font></b><div class="spoiler_text">     backup     BTRFS-.       60  .     /backup/btrfs/back/remote/     . <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donnons au code le droit d'ex√©cuter: </font><font style="vertical-align: inherit;">
V√©rifier et entasser les couronnes:</font></font><br>
<br>
<code>#chmod +x /root/btrfs-backup/cron-daily.sh<br>
#chmod +x /root/btrfs-backup/btrfs-backup.sh<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#/usr/bin/nice -n 19 /usr/bin/ionice -c 3 /root/btrfs-backup/cron-daily.sh 2&gt;&amp;1 | /usr/bin/logger -t btrfs-backup<br>
#cat /var/log/syslog | grep btrfs-backup<br>
#crontab -e<br>
0 2 * * * /usr/bin/nice -n 19 /usr/bin/ionice -c 3 /root/btrfs-backup/cron-daily.sh 2&gt;&amp;1 | /usr/bin/logger -t btrfs-backup<br>
</code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sauvegarde l√©g√®re LVM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cr√©ez un pool l√©ger sur le p√©riph√©rique de sauvegarde: </font></font><br>
<br>
<code>#lvcreate -L 274877906944B --poolmetadataspare y --poolmetadatasize 4294967296B --chunksize 64k -Z y -T backup/thin-pool</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
installez ddrescue, car </font><font style="vertical-align: inherit;">les scripts utiliseront cet outil: </font></font><br>
<br>
<code>#apt-get install gddrescue</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cr√©ez un r√©pertoire pour les scripts: </font></font><br>
<br>
<code>#mkdir /root/lvm-thin-backup</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Copiez les scripts:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beaucoup de coups √† l'int√©rieur ...</font></font></b><div class="spoiler_text"><code>#cat &gt;/root/lvm-thin-backup/lvm-thin-backup.sh &lt;&lt; EOF<br>
#!/bin/bash<br>
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"<br>
<br>
SCRIPT_FILE="$(realpath $0)"<br>
SCRIPT_DIR="$(dirname $SCRIPT_FILE)"<br>
SCRIPT_NAME="$(basename -s .sh $SCRIPT_FILE)"<br>
<br>
LOCK_FILE="/dev/shm/$SCRIPT_NAME.lock"<br>
DATE_PREFIX='%Y-%m-%d'<br>
DATE_FORMAT=$DATE_PREFIX'-%H-%M-%S'<br>
DATE_REGEX='[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]'<br>
BASE_SUFFIX=".base"<br>
PEND_SUFFIX=".pend"<br>
SNAP_SUFFIX=".snap"<br>
BACKUPS="backup"<br>
BACKUPS_POOL="thin-pool"<br>
<br>
export LVM_SUPPRESS_FD_WARNINGS=1<br>
<br>
function terminate ()<br>
{<br>
 echo "$1" &gt;&amp;2<br>
 exit 1<br>
}<br>
<br>
function wait_lock()<br>
{<br>
 flock 98<br>
}<br>
<br>
function wait_lock_or_terminate()<br>
{<br>
 echo "Wating for lock..."<br>
 wait_lock || terminate "Failed to get lock. Exiting..."<br>
 echo "Got lock..."<br>
}<br>
<br>
function suffix()<br>
{<br>
 FORMATTED_DATE=$(date +"$DATE_FORMAT")<br>
 echo "$SNAP_SUFFIX.$FORMATTED_DATE"<br>
}<br>
<br>
function filter()<br>
{<br>
 FORMATTED_DATE=$(date --date="$1" +"$DATE_PREFIX")<br>
 echo "$SNAP_SUFFIX.$FORMATTED_DATE"<br>
}<br>
<br>
function read_thin_id {<br>
lvs --rows --reportformat basic --quiet -othin_id "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_pool_lv {<br>
lvs --rows --reportformat basic --quiet -opool_lv "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_lv_dm_path {<br>
lvs --rows --reportformat basic --quiet -olv_dm_path "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_lv_active {<br>
lvs --rows --reportformat basic --quiet -olv_active "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_lv_chunk_size {<br>
lvs --rows --reportformat basic --quiet --units b --nosuffix -ochunk_size "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function read_lv_size {<br>
lvs --rows --reportformat basic --quiet --units b --nosuffix -olv_size "$1/$2" | awk '{print $2}'<br>
}<br>
<br>
function activate_volume {<br>
lvchange -ay -Ky "$1/$2"<br>
}<br>
<br>
function deactivate_volume {<br>
lvchange -an "$1/$2"<br>
}<br>
<br>
function read_thin_metadata_snap {<br>
dmsetup status "$1" | awk '{print $7}'<br>
}<br>
<br>
function thindiff()<br>
{<br>
DIFF_VG="$1"<br>
DIFF_SOURCE="$2"<br>
DIFF_TARGET="$3"<br>
DIFF_SOURCE_POOL=$(read_pool_lv $DIFF_VG $DIFF_SOURCE)<br>
DIFF_TARGET_POOL=$(read_pool_lv $DIFF_VG $DIFF_TARGET)<br>
<br>
if [ "$DIFF_SOURCE_POOL" == "" ]<br>
then<br>
 (&gt;&amp;2 echo "Source LV is not thin.")<br>
 exit 1<br>
fi<br>
<br>
if [ "$DIFF_TARGET_POOL" == "" ]<br>
then<br>
 (&gt;&amp;2 echo "Target LV is not thin.")<br>
 exit 1<br>
fi<br>
<br>
if [ "$DIFF_SOURCE_POOL" != "$DIFF_TARGET_POOL" ]<br>
then<br>
 (&gt;&amp;2 echo "Source and target LVs belong to different thin pools.")<br>
 exit 1<br>
fi<br>
<br>
DIFF_POOL_PATH=$(read_lv_dm_path $DIFF_VG $DIFF_SOURCE_POOL)<br>
DIFF_SOURCE_ID=$(read_thin_id $DIFF_VG $DIFF_SOURCE)<br>
DIFF_TARGET_ID=$(read_thin_id $DIFF_VG $DIFF_TARGET)<br>
DIFF_POOL_PATH_TPOOL="$DIFF_POOL_PATH-tpool"<br>
DIFF_POOL_PATH_TMETA="$DIFF_POOL_PATH"_tmeta<br>
DIFF_POOL_METADATA_SNAP=$(read_thin_metadata_snap $DIFF_POOL_PATH_TPOOL)<br>
<br>
if [ "$DIFF_POOL_METADATA_SNAP" != "-" ]<br>
then<br>
 (&gt;&amp;2 echo "Thin pool metadata snapshot already exist. Assuming stale one. Will release metadata snapshot in 5 seconds.")<br>
 sleep 5<br>
 dmsetup message $DIFF_POOL_PATH_TPOOL 0 release_metadata_snap<br>
fi<br>
<br>
dmsetup message $DIFF_POOL_PATH_TPOOL 0 reserve_metadata_snap<br>
DIFF_POOL_METADATA_SNAP=$(read_thin_metadata_snap $DIFF_POOL_PATH_TPOOL)<br>
<br>
if [ "$DIFF_POOL_METADATA_SNAP" == "-" ]<br>
then<br>
 (&gt;&amp;2 echo "Failed to create thin pool metadata snapshot.")<br>
 exit 1<br>
fi<br>
<br>
#We keep output in variable because metadata snapshot need to be released early.<br>
DIFF_DATA=$(thin_delta -m$DIFF_POOL_METADATA_SNAP --snap1 $DIFF_SOURCE_ID --snap2 $DIFF_TARGET_ID $DIFF_POOL_PATH_TMETA)<br>
<br>
dmsetup message $DIFF_POOL_PATH_TPOOL 0 release_metadata_snap<br>
<br>
echo $"$DIFF_DATA" | grep -E 'different|left_only|right_only' | sed 's/&lt;/"/g' | sed 's/ /"/g' | awk -F'\"' '{print $6 "\t" $8 "\t" $11}' | sed 's/different/copy/g' | sed 's/left_only/copy/g' | sed 's/right_only/discard/g'<br>
<br>
}<br>
<br>
function thinsync()<br>
{<br>
SYNC_VG="$1"<br>
SYNC_PEND="$2"<br>
SYNC_BASE="$3"<br>
SYNC_TARGET="$4"<br>
SYNC_PEND_POOL=$(read_pool_lv $SYNC_VG $SYNC_PEND)<br>
SYNC_BLOCK_SIZE=$(read_lv_chunk_size $SYNC_VG $SYNC_PEND_POOL)<br>
SYNC_PEND_PATH=$(read_lv_dm_path $SYNC_VG $SYNC_PEND)<br>
<br>
activate_volume $SYNC_VG $SYNC_PEND<br>
<br>
while read -r SYNC_ACTION SYNC_OFFSET SYNC_LENGTH ; do<br>
 SYNC_OFFSET_BYTES=$((SYNC_OFFSET * SYNC_BLOCK_SIZE))<br>
 SYNC_LENGTH_BYTES=$((SYNC_LENGTH * SYNC_BLOCK_SIZE))<br>
 if [ "$SYNC_ACTION" == "copy" ]<br>
 then<br>
 ddrescue --quiet --force --input-position=$SYNC_OFFSET_BYTES --output-position=$SYNC_OFFSET_BYTES --size=$SYNC_LENGTH_BYTES "$SYNC_PEND_PATH" "$SYNC_TARGET"<br>
 fi<br>
<br>
if [ "$SYNC_ACTION" == "discard" ]<br>
 then<br>
 blkdiscard -o $SYNC_OFFSET_BYTES -l $SYNC_LENGTH_BYTES "$SYNC_TARGET"<br>
 fi<br>
done &lt; &lt;(thindiff "$SYNC_VG" "$SYNC_PEND" "$SYNC_BASE")<br>
}<br>
<br>
function discard_volume()<br>
{<br>
DISCARD_VG="$1"<br>
DISCARD_LV="$2"<br>
DISCARD_LV_PATH=$(read_lv_dm_path "$DISCARD_VG" "$DISCARD_LV")<br>
if [ "$DISCARD_LV_PATH" != "" ]<br>
then<br>
 echo "$DISCARD_LV_PATH found"<br>
else<br>
 echo "$DISCARD_LV not found in $DISCARD_VG"<br>
 exit 1<br>
fi<br>
DISCARD_LV_POOL=$(read_pool_lv $DISCARD_VG $DISCARD_LV)<br>
DISCARD_LV_SIZE=$(read_lv_size "$DISCARD_VG" "$DISCARD_LV")<br>
lvremove -y --quiet "$DISCARD_LV_PATH" || exit 1<br>
lvcreate --thin-pool "$DISCARD_LV_POOL" -V "$DISCARD_LV_SIZE"B --name "$DISCARD_LV" "$DISCARD_VG" || exit 1<br>
}<br>
<br>
function backup()<br>
{<br>
SOURCE_VG="$1"<br>
SOURCE_LV="$2"<br>
TARGET_VG="$BACKUPS"<br>
TARGET_LV="$SOURCE_VG-$SOURCE_LV"<br>
SOURCE_BASE_LV="$SOURCE_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV="$TARGET_LV$BASE_SUFFIX"<br>
SOURCE_PEND_LV="$SOURCE_LV$PEND_SUFFIX"<br>
TARGET_PEND_LV="$TARGET_LV$PEND_SUFFIX"<br>
SOURCE_BASE_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
SOURCE_PEND_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_PEND_LV")<br>
TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
TARGET_PEND_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_PEND_LV")<br>
<br>
if [ "$SOURCE_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$SOURCE_BASE_LV_PATH found"<br>
 else<br>
 echo "Source base not found creating snapshot of $SOURCE_VG/$SOURCE_LV to $SOURCE_VG/$SOURCE_BASE_LV"<br>
 lvcreate --quiet --snapshot --name "$SOURCE_BASE_LV" "$SOURCE_VG/$SOURCE_LV" || exit 1<br>
 SOURCE_BASE_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
 activate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 echo "Discarding $SOURCE_BASE_LV_PATH as we need to bootstrap."<br>
 SOURCE_BASE_POOL=$(read_pool_lv $SOURCE_VG $SOURCE_BASE_LV)<br>
 SOURCE_BASE_CHUNK_SIZE=$(read_lv_chunk_size $SOURCE_VG $SOURCE_BASE_POOL)<br>
 discard_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 sync<br>
 if [ "$TARGET_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_BASE_LV_PATH found out of sync with source... removing..."<br>
 lvremove -y --quiet $TARGET_BASE_LV_PATH || exit 1<br>
 TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
 sync<br>
 fi<br>
 fi<br>
SOURCE_BASE_SIZE=$(read_lv_size "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
 if [ "$TARGET_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_BASE_LV_PATH found"<br>
 else<br>
 echo "$TARGET_VG/$TARGET_LV not found. Creating empty volume."<br>
 lvcreate --thin-pool "$BACKUPS_POOL" -V "$SOURCE_BASE_SIZE"B --name "$TARGET_BASE_LV" "$TARGET_VG" || exit 1<br>
 echo "Have to rebootstrap. Discarding source at $SOURCE_BASE_LV_PATH"<br>
 activate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 SOURCE_BASE_POOL=$(read_pool_lv $SOURCE_VG $SOURCE_BASE_LV)<br>
 SOURCE_BASE_CHUNK_SIZE=$(read_lv_chunk_size $SOURCE_VG $SOURCE_BASE_POOL)<br>
 discard_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 TARGET_BASE_POOL=$(read_pool_lv $TARGET_VG $TARGET_BASE_LV)<br>
 TARGET_BASE_CHUNK_SIZE=$(read_lv_chunk_size $TARGET_VG $TARGET_BASE_POOL)<br>
 TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
 echo "Discarding target at $TARGET_BASE_LV_PATH"<br>
 discard_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 sync<br>
 fi<br>
 if [ "$SOURCE_PEND_LV_PATH" != "" ]<br>
 then<br>
 echo "$SOURCE_PEND_LV_PATH found removing..."<br>
 lvremove -y --quiet "$SOURCE_PEND_LV_PATH" || exit 1<br>
 sync<br>
 fi<br>
 lvcreate --quiet --snapshot --name "$SOURCE_PEND_LV" "$SOURCE_VG/$SOURCE_LV" || exit 1<br>
SOURCE_PEND_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_PEND_LV")<br>
 sync<br>
 if [ "$TARGET_PEND_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_PEND_LV_PATH found removing..."<br>
 lvremove -y --quiet $TARGET_PEND_LV_PATH<br>
 sync<br>
 fi<br>
 lvcreate --quiet --snapshot --name "$TARGET_PEND_LV" "$TARGET_VG/$TARGET_BASE_LV" || exit 1<br>
TARGET_PEND_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_PEND_LV")<br>
SOURCE_PEND_LV_SIZE=$(read_lv_size "$SOURCE_VG" "$SOURCE_PEND_LV")<br>
 lvresize -L "$SOURCE_PEND_LV_SIZE"B "$TARGET_PEND_LV_PATH"<br>
 activate_volume "$TARGET_VG" "$TARGET_PEND_LV"<br>
 echo "Synching $SOURCE_PEND_LV_PATH to $TARGET_PEND_LV_PATH"<br>
 thinsync "$SOURCE_VG" "$SOURCE_PEND_LV" "$SOURCE_BASE_LV" "$TARGET_PEND_LV_PATH" || exit 1<br>
 sync<br>
<br>
TARGET_DATE_SUFFIX=$(suffix)<br>
 lvcreate --quiet --snapshot --name "$TARGET_LV$TARGET_DATE_SUFFIX" "$TARGET_VG/$TARGET_PEND_LV" || exit 1<br>
 sync<br>
 lvremove --quiet -y "$SOURCE_BASE_LV_PATH" || exit 1<br>
 sync<br>
 lvremove --quiet -y "$TARGET_BASE_LV_PATH" || exit 1<br>
 sync<br>
 lvrename -y "$SOURCE_VG/$SOURCE_PEND_LV" "$SOURCE_BASE_LV" || exit 1<br>
 lvrename -y "$TARGET_VG/$TARGET_PEND_LV" "$TARGET_BASE_LV" || exit 1<br>
 sync<br>
 deactivate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 deactivate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
}<br>
<br>
function verify()<br>
{<br>
SOURCE_VG="$1"<br>
SOURCE_LV="$2"<br>
TARGET_VG="$BACKUPS"<br>
TARGET_LV="$SOURCE_VG-$SOURCE_LV"<br>
SOURCE_BASE_LV="$SOURCE_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV="$TARGET_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
SOURCE_BASE_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
<br>
if [ "$SOURCE_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$SOURCE_BASE_LV_PATH found"<br>
 else<br>
 echo "$SOURCE_BASE_LV_PATH not found"<br>
 exit 1<br>
 fi<br>
 if [ "$TARGET_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_BASE_LV_PATH found"<br>
 else<br>
 echo "$TARGET_BASE_LV_PATH not found"<br>
 exit 1<br>
 fi<br>
 activate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 activate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 echo Comparing "$SOURCE_BASE_LV_PATH" with "$TARGET_BASE_LV_PATH"<br>
 cmp "$SOURCE_BASE_LV_PATH" "$TARGET_BASE_LV_PATH"<br>
 echo Done...<br>
 deactivate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 deactivate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
}<br>
<br>
function resync()<br>
{<br>
SOURCE_VG="$1"<br>
SOURCE_LV="$2"<br>
TARGET_VG="$BACKUPS"<br>
TARGET_LV="$SOURCE_VG-$SOURCE_LV"<br>
SOURCE_BASE_LV="$SOURCE_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV="$TARGET_LV$BASE_SUFFIX"<br>
TARGET_BASE_LV_PATH=$(read_lv_dm_path "$TARGET_VG" "$TARGET_BASE_LV")<br>
SOURCE_BASE_LV_PATH=$(read_lv_dm_path "$SOURCE_VG" "$SOURCE_BASE_LV")<br>
<br>
if [ "$SOURCE_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$SOURCE_BASE_LV_PATH found"<br>
 else<br>
 echo "$SOURCE_BASE_LV_PATH not found"<br>
 exit 1<br>
 fi<br>
 if [ "$TARGET_BASE_LV_PATH" != "" ]<br>
 then<br>
 echo "$TARGET_BASE_LV_PATH found"<br>
 else<br>
 echo "$TARGET_BASE_LV_PATH not found"<br>
 exit 1<br>
 fi<br>
 activate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 activate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
 SOURCE_BASE_POOL=$(read_pool_lv $SOURCE_VG $SOURCE_BASE_LV)<br>
 SYNC_BLOCK_SIZE=$(read_lv_chunk_size $SOURCE_VG $SOURCE_BASE_POOL)<br>
<br>
echo Syncronizing "$SOURCE_BASE_LV_PATH" to "$TARGET_BASE_LV_PATH"<br>
<br>
CMP_OFFSET=0<br>
 while [[ "$CMP_OFFSET" != "" ]] ; do<br>
 CMP_MISMATCH=$(cmp -i "$CMP_OFFSET" "$SOURCE_BASE_LV_PATH" "$TARGET_BASE_LV_PATH" | grep differ | awk '{print $5}' | sed 's/,//g' )<br>
 if [[ "$CMP_MISMATCH" != "" ]] ; then<br>
 CMP_OFFSET=$(( CMP_MISMATCH + CMP_OFFSET ))<br>
 SYNC_OFFSET_BYTES=$(( ( CMP_OFFSET / SYNC_BLOCK_SIZE ) * SYNC_BLOCK_SIZE ))<br>
 SYNC_LENGTH_BYTES=$(( SYNC_BLOCK_SIZE ))<br>
 echo "Synching $SYNC_LENGTH_BYTES bytes at $SYNC_OFFSET_BYTES from $SOURCE_BASE_LV_PATH to $TARGET_BASE_LV_PATH"<br>
 ddrescue --quiet --force --input-position=$SYNC_OFFSET_BYTES --output-position=$SYNC_OFFSET_BYTES --size=$SYNC_LENGTH_BYTES "$SOURCE_BASE_LV_PATH" "$TARGET_BASE_LV_PATH"<br>
 else<br>
 CMP_OFFSET=""<br>
 fi<br>
 done<br>
 echo Done...<br>
 deactivate_volume "$TARGET_VG" "$TARGET_BASE_LV"<br>
 deactivate_volume "$SOURCE_VG" "$SOURCE_BASE_LV"<br>
}<br>
<br>
function list()<br>
{<br>
LIST_SOURCE_VG="$1"<br>
LIST_SOURCE_LV="$2"<br>
LIST_TARGET_VG="$BACKUPS"<br>
LIST_TARGET_LV="$LIST_SOURCE_VG-$LIST_SOURCE_LV"<br>
LIST_TARGET_BASE_LV="$LIST_TARGET_LV$SNAP_SUFFIX"<br>
lvs -olv_name | grep "$LIST_TARGET_BASE_LV.$DATE_REGEX"<br>
}<br>
<br>
function remove()<br>
{<br>
REMOVE_TARGET_VG="$BACKUPS"<br>
REMOVE_TARGET_LV="$1"<br>
lvremove -y "$REMOVE_TARGET_VG/$REMOVE_TARGET_LV"<br>
sync<br>
}<br>
<br>
function removeall()<br>
{<br>
DATE_OFFSET="$3"<br>
FILTER="$(filter "$DATE_OFFSET")"<br>
while read -r SNAPSHOT ; do<br>
 remove "$SNAPSHOT"<br>
done &lt; &lt;(list "$1" "$2" | grep "$FILTER")<br>
<br>
}<br>
<br>
(<br>
 COMMAND="$1"<br>
 shift<br>
 <br>
 case "$COMMAND" in<br>
 "--help") <br>
 echo "Help"<br>
 ;;<br>
 "suffix") <br>
 suffix<br>
 ;;<br>
 "filter") <br>
 filter "$1"<br>
 ;;<br>
 "backup") <br>
 wait_lock_or_terminate<br>
 backup "$1" "$2"<br>
 ;;<br>
 "list") <br>
 list "$1" "$2"<br>
 ;;<br>
 "thindiff") <br>
 thindiff "$1" "$2" "$3"<br>
 ;;<br>
 "thinsync") <br>
 thinsync "$1" "$2" "$3" "$4"<br>
 ;;<br>
 "verify") <br>
 wait_lock_or_terminate<br>
 verify "$1" "$2"<br>
 ;;<br>
 "resync") <br>
 wait_lock_or_terminate<br>
 resync "$1" "$2"<br>
 ;;<br>
 "remove") <br>
 wait_lock_or_terminate<br>
 remove "$1"<br>
 ;;<br>
 "removeall") <br>
 wait_lock_or_terminate<br>
 removeall "$1" "$2" "$3"<br>
 ;;<br>
 *)<br>
 echo "None.."<br>
 ;;<br>
 esac<br>
) 98&gt;$LOCK_FILE <br>
<br>
EOF<br>
</code><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce que √ßa fait ...?</font></font></b><div class="spoiler_text">             ,   thin_delta,       ddrescue  blkdiscard.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre script que nous allons entasser en couronnes:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un peu plus bash</font></font></b><div class="spoiler_text"><code>#cat &gt;/root/lvm-thin-backup/cron-daily.sh &lt;&lt; EOF<br>
#!/bin/bash<br>
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"<br>
<br>
SCRIPT_FILE="$(realpath $0)"<br>
SCRIPT_DIR="$(dirname $SCRIPT_FILE)"<br>
SCRIPT_NAME="$(basename -s .sh $SCRIPT_FILE)"<br>
<br>
BACKUP_SCRIPT="$SCRIPT_DIR/lvm-thin-backup.sh"<br>
RETENTION="-60 days"<br>
<br>
$BACKUP_SCRIPT backup images linux-dev<br>
$BACKUP_SCRIPT backup images win8<br>
$BACKUP_SCRIPT backup images win8-data<br>
#etc<br>
<br>
$BACKUP_SCRIPT removeall images linux-dev "$RETENTION"<br>
$BACKUP_SCRIPT removeall images win8 "$RETENTION"<br>
$BACKUP_SCRIPT removeall images win8-data "$RETENTION"<br>
#etc<br>
<br>
EOF<br>
</code><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce que √ßa fait ...?</font></font></b><div class="spoiler_text">  ,         .      ,        .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce script doit √™tre modifi√©, indiquant une liste de volumes l√©gers pour lesquels des sauvegardes sont requises. </font><font style="vertical-align: inherit;">Les noms donn√©s sont √† titre indicatif seulement. </font><font style="vertical-align: inherit;">Si vous le souhaitez, vous pouvez √©crire un script qui synchronisera tous les volumes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donnons des droits: </font><font style="vertical-align: inherit;">
V√©rifiez et fourrez dans les couronnes: </font><font style="vertical-align: inherit;">
Le premier lancement sera long, car </font><font style="vertical-align: inherit;">les volumes minces seront enti√®rement synchronis√©s en copiant tout l'espace utilis√©. </font><font style="vertical-align: inherit;">Gr√¢ce aux m√©tadonn√©es minces LVM, nous savons quels blocs sont r√©ellement utilis√©s, donc seuls les blocs r√©els de volumes minces seront copi√©s. </font><font style="vertical-align: inherit;">
Les lancements suivants copieront les donn√©es de mani√®re incr√©mentielle en suivant les modifications via les m√©tadonn√©es fines LVM.</font></font><br>
<br>
<code>#chmod +x /root/lvm-thin-backup/cron-daily.sh<br>
#chmod +x /root/lvm-thin-backup/lvm-thin-backup.sh</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<code>#/usr/bin/nice -n 19 /usr/bin/ionice -c 3 /root/lvm-thin-backup/cron-daily.sh 2&gt;&amp;1 | /usr/bin/logger -t lvm-thin-backup<br>
#cat /var/log/syslog | grep lvm-thin-backup<br>
#crontab -e<br>
0 3 * * * /usr/bin/nice -n 19 /usr/bin/ionice -c 3 /root/lvm-thin-backup/cron-daily.sh 2&gt;&amp;1 | /usr/bin/logger -t lvm-thin-backup<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyons ce qui se passe:</font></font></h3><br>
<code>#time /root/btrfs-backup/cron-daily.sh<br>
real 0m2,967s<br>
user 0m0,225s<br>
sys 0m0,353s<br>
<br>
#time /root/lvm-thin-backup/cron-daily.sh<br>
real 1m2,710s<br>
user 0m12,721s<br>
sys 0m6,671s<br>
<br>
#ls -al /backup/btrfs/back/remote/*<br>
/backup/btrfs/back/remote/boot:<br>
total 0<br>
drwxr-xr-x 1 root root 1260  26 09:11 .<br>
drwxr-xr-x 1 root root 16  6 09:30 ..<br>
drwxr-xr-x 1 root root 322  26 02:00 .@base<br>
drwxr-xr-x 1 root root 516  6 09:39 .@snap.2020-03-06-09-39-37<br>
drwxr-xr-x 1 root root 516  6 09:39 .@snap.2020-03-06-09-39-57<br>
...<br>
/backup/btrfs/back/remote/root:<br>
total 0<br>
drwxr-xr-x 1 root root 2820  26 09:11 .<br>
drwxr-xr-x 1 root root 16  6 09:30 ..<br>
drwxr-xr-x 1 root root 240  26 09:11 @.@base<br>
drwxr-xr-x 1 root root 22  26 09:11 @home.@base<br>
drwxr-xr-x 1 root root 22  6 09:39 @home.@snap.2020-03-06-09-39-35<br>
drwxr-xr-x 1 root root 22  6 09:39 @home.@snap.2020-03-06-09-39-57<br>
...<br>
drwxr-xr-x 1 root root 240  6 09:39 @.@snap.2020-03-06-09-39-26<br>
drwxr-xr-x 1 root root 240  6 09:39 @.@snap.2020-03-06-09-39-56<br>
...<br>
<br>
#lvs -olv_name,lv_size images &amp;&amp; lvs -olv_name,lv_size backup<br>
 LV LSize <br>
 linux-dev 128,00g<br>
 linux-dev.base 128,00g<br>
 thin-pool 1,38t<br>
 win8 128,00g<br>
 win8-data 2,00t<br>
 win8-data.base 2,00t<br>
 win8.base 128,00g<br>
 LV LSize <br>
 backup 256,00g<br>
 images-linux-dev.base 128,00g<br>
 images-linux-dev.snap.2020-03-08-10-09-11 128,00g<br>
 images-linux-dev.snap.2020-03-08-10-09-25 128,00g<br>
...<br>
 images-win8-data.base 2,00t<br>
 images-win8-data.snap.2020-03-16-14-11-55 2,00t<br>
 images-win8-data.snap.2020-03-16-14-19-50 2,00t<br>
...<br>
 images-win8.base 128,00g<br>
 images-win8.snap.2020-03-17-04-51-46 128,00g<br>
 images-win8.snap.2020-03-18-03-02-49 128,00g<br>
...<br>
 thin-pool &lt;2,09t<br>
</code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et les poup√©es gigognes?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tr√®s probablement, bien que les volumes logiques LVM LV puissent √™tre des volumes PV LVM physiques pour d'autres VG. </font><font style="vertical-align: inherit;">LVM peut √™tre r√©cursif, comme les poup√©es gigognes. </font><font style="vertical-align: inherit;">Cela donne √† LVM une extr√™me flexibilit√©.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le prochain article, nous allons essayer d'utiliser plusieurs syst√®mes de stockage mobiles / KVM similaires comme base pour cr√©er un cluster de stockage / vm g√©o-distribu√© avec redondance sur plusieurs continents via des ordinateurs de bureau √† domicile, Internet √† domicile et des r√©seaux P2P.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr492820/index.html">.Net Core Api: obtenir des donn√©es dans une demande de diff√©rentes sources</a></li>
<li><a href="../fr492822/index.html">D√©veloppeurs CSS - pourquoi le monde en a-t-il besoin?</a></li>
<li><a href="../fr492828/index.html">Comment survivre dans un monde enferm√©</a></li>
<li><a href="../fr492830/index.html">SameSite = Lax par d√©faut - d√©j√† dans Chrome 80 stable (mais pas encore pour tout le monde)</a></li>
<li><a href="../fr492832/index.html">Passerelle IoT pour les protocoles industriels bas√©s sur i.MX6 et Linux</a></li>
<li><a href="../fr492838/index.html">Connectez M5Stack au t√©l√©viseur</a></li>
<li><a href="../fr492844/index.html">Comment visualiser et animer des mod√®les (g√©ophysiques). Animation 3D et visualisation des donn√©es 4D</a></li>
<li><a href="../fr492850/index.html">Tout le monde ne veut pas passer au travail √† distance</a></li>
<li><a href="../fr492856/index.html">Covid19, Votre soci√©t√© et vous √™tes du point de vue de la Data Science. Article traduit par Jeremy Howard et Rachel Thomas (fast.ai)</a></li>
<li><a href="../fr492862/index.html">15 meilleurs conseils d'optimisation des performances Oracle APEX pour les d√©veloppeurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>