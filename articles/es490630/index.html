<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚙 👨🏽‍🚒 🧑🏿‍🤝‍🧑🏻 Carga de matrices NumPy desde disco: comparación de memmap () y Zarr / HDF5 👩🏼‍🎤 🛌🏽 🤬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si su matriz NumPy es demasiado grande para caber en la RAM, puede procesarla dividiéndola en fragmentos . Puede hacer esto en modo transparente o exp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Carga de matrices NumPy desde disco: comparación de memmap () y Zarr / HDF5</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/490630/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si su matriz NumPy es demasiado grande para caber en la RAM, puede procesarla dividiéndola en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fragmentos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Puede hacer esto en modo transparente o explícitamente cargando estos fragmentos del disco uno a la vez. </font><font style="vertical-align: inherit;">
En esta situación, puede recurrir a dos clases de herramientas:</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/2n/8r/ck/2n8rckf95tnhx1yrkvvlfy2cf_4.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Método NumPy </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, un mecanismo transparente que le permite percibir un archivo ubicado en un disco como si estuviera todo en la memoria.&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formatos de almacenamiento de datos Zarr y HDF5 que son similares entre sí, que permiten, si es necesario, cargar desde el disco y guardar fragmentos comprimidos de la matriz en el disco.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada uno de estos métodos tiene sus propias fortalezas y debilidades.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El material, cuya traducción publicamos hoy, está dedicado al análisis de las características de estos métodos de trabajo con datos, y la historia de en qué situaciones pueden ser útiles. </font><font style="vertical-align: inherit;">En particular, se prestará especial atención a los formatos de datos que están optimizados para realizar cálculos y no están necesariamente diseñados para transferir estos datos a otros programadores.</font></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué sucede al leer datos de un disco o al escribir datos en un disco?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando se lee un archivo del disco por primera vez, el sistema operativo no solo copia los datos en la memoria de proceso. </font><font style="vertical-align: inherit;">Primero, copia estos datos en su memoria, almacenando una copia de ellos en el llamado "caché de búfer". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿De qué sirve aquí? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El hecho es que el sistema operativo almacena datos en la memoria caché en caso de que necesite leer los mismos datos del mismo archivo nuevamente.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c5/896/e36/8c5896e36f5312d8e00b92103b7d037f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si los datos se leen nuevamente, ingresan a la memoria del programa no desde el disco, sino desde la RAM, que es un orden de magnitud más rápido.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf3/382/7a3/cf33827a346960cbcc33f54835b9bce3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si la memoria ocupada por el caché es necesaria para otra cosa, el caché se borrará automáticamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando los datos se escriben en el disco, se mueven en la dirección opuesta. </font><font style="vertical-align: inherit;">Al principio se escriben solo en la memoria caché del búfer. </font><font style="vertical-align: inherit;">Esto significa que las operaciones de escritura suelen ser muy rápidas, ya que el programa no necesita enfocarse en un disco lento. </font><font style="vertical-align: inherit;">Ella, durante la grabación, solo necesita trabajar con RAM.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed3/6be/592/ed36be592685ca4f42954971e000eb89.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, los datos se vacían al disco desde el caché.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffc/0bb/0fc/ffc0bb0fc60c346671dfba89e8c78c1c.png"></div><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabajando con una matriz usando memmap ()</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestro caso, </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nos permite percibir un archivo en el disco como si fuera una matriz almacenada en la memoria. </font><font style="vertical-align: inherit;">El sistema operativo, transparente para el programa, realiza operaciones de lectura / escritura, accediendo a la memoria caché del búfer o al disco duro, dependiendo de si los datos solicitados se almacenan en la memoria caché o no. </font><font style="vertical-align: inherit;">Aquí se ejecuta un algoritmo como este:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Están los datos en el caché? </font><font style="vertical-align: inherit;">Si es así, genial, puede contactarlos directamente.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Están los datos en el disco? </font><font style="vertical-align: inherit;">El acceso a ellos será más lento, pero no tendrá que preocuparse por eso, se cargarán en modo transparente.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como una ventaja adicional, </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se puede observar que en la mayoría de los casos, la memoria caché del búfer para el archivo se integrará en la memoria del programa. </font><font style="vertical-align: inherit;">Esto significa que el sistema no tiene que mantener una copia adicional de los datos en la memoria del programa fuera del búfer.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47e/922/86e/47e92286e0761142e8f411c84d188e76.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">está integrado en NumPy:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<font></font>
array = np.memmap(<span class="hljs-string">"mydata/myarray.arr"</span>, mode=<span class="hljs-string">"r"</span>,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtype=np.int16, shape=(<span class="hljs-number">1024</span>, <span class="hljs-number">1024</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ejecute este código y tendrá una matriz a su disposición, cuyo trabajo será completamente transparente para el programa, independientemente de si el trabajo se realiza con la memoria caché del búfer o con el disco duro.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limitaciones de Memmap ()</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aunque en ciertas situaciones </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede mostrarse bastante bien, este método también tiene limitaciones:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los datos deben almacenarse en el sistema de archivos. </font><font style="vertical-align: inherit;">Los datos no se pueden descargar del almacenamiento binario como AWS S3.</font></font></li>
<li>        ,      .   ,       . ,           ,  ,      .</li>
<li>   N-        ,      ,        ,        .         .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Expliquemos el último punto. </font><font style="vertical-align: inherit;">Imagine que tenemos una matriz bidimensional que contiene enteros de 32 bits (4 bytes). </font><font style="vertical-align: inherit;">Se leen 4096 bytes por disco. </font><font style="vertical-align: inherit;">Si lee datos ubicados en un archivo secuencialmente desde un disco (por ejemplo, dichos datos están en líneas de matriz), luego de cada operación de lectura tendremos 1024 enteros. </font><font style="vertical-align: inherit;">Pero si lee datos cuya ubicación en el archivo no coincide con su ubicación en la matriz (por ejemplo, datos ubicados en columnas), cada operación de lectura le permitirá obtener solo 1 número requerido. </font><font style="vertical-align: inherit;">Como resultado, resulta que para obtener la misma cantidad de datos, debe realizar mil veces más operaciones de lectura.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr y HDF5</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para superar las limitaciones anteriores, puede usar los formatos de almacenamiento de datos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o HDF5, que son muy similares:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede trabajar con archivos HDF5 en Python usando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pytables</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h5py</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este formato es más antiguo que Zarr y tiene más restricciones, pero su ventaja es que puede usarse en programas escritos en diferentes idiomas.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr es un formato implementado usando el paquete Python del mismo nombre. </font><font style="vertical-align: inherit;">Es mucho más moderno y flexible que HDF5, pero puede usarlo (al menos por ahora) solo en el entorno Python. </font><font style="vertical-align: inherit;">Según mis sentimientos, en la mayoría de las situaciones, si no hay necesidad de soporte multilingüe para HDF5, vale la pena elegir Zarr. </font><font style="vertical-align: inherit;">Zarr, por ejemplo, tiene un mejor soporte de subprocesos múltiples.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, discutiremos solo sobre Zarr, pero si está interesado en el formato HDF5 y su comparación más profunda con Zarr, puede ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> video.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando Zarr</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zarr le permite almacenar datos y cargarlos en la memoria en forma de matrices y, además, escribir estos datos en forma de matrices. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí se explica cómo cargar una matriz con Zarr:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> zarr, numpy <span class="hljs-keyword">as</span> np
<span class="hljs-meta">&gt;&gt;&gt; </span>z = zarr.open(<span class="hljs-string">'example.zarr'</span>, mode=<span class="hljs-string">'a'</span>,
<span class="hljs-meta">... </span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shape=(<span class="hljs-number">1024</span>, <span class="hljs-number">1024</span>),
<span class="hljs-meta">... </span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunks=(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>), dtype=np.int16)
<span class="hljs-meta">&gt;&gt;&gt; </span>type(z)<font></font>
&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">zarr</span>.<span class="hljs-title">core</span>.<span class="hljs-title">Array</span>'&gt;
&gt;&gt;&gt; <span class="hljs-title">type</span>(<span class="hljs-params">z[<span class="hljs-number">100</span>:<span class="hljs-number">200</span>]</span>)
&lt;<span class="hljs-title">class</span> '<span class="hljs-title">numpy</span>.<span class="hljs-title">ndarray</span>'&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que hasta que se reciba una porción del objeto, no estaremos a nuestra disposición </font></font><code>numpy.ndarray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Una entidad </font></font><code>zarr.core.array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es solo metadatos. </font><font style="vertical-align: inherit;">Solo los datos que se incluyen en el segmento se cargan desde el disco.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Por qué elegí Zarr?</font></font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr evita las limitaciones </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">discutidas anteriormente:</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los fragmentos de datos se pueden almacenar en el disco, en el almacenamiento de AWS S3 o en algún sistema de almacenamiento que brinde la capacidad de trabajar con registros de formato de clave / valor.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El programador determina el tamaño y la estructura del fragmento de datos. </font><font style="vertical-align: inherit;">Por ejemplo, los datos se pueden organizar de tal manera que puedan leer de manera eficiente la información ubicada en diferentes ejes de una matriz multidimensional. </font><font style="vertical-align: inherit;">Esto es cierto para HDF5.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los fragmentos pueden ser comprimidos. </font><font style="vertical-align: inherit;">Lo mismo puede decirse de HDF5.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Detengámonos en los dos últimos puntos con más detalle.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dimensiones de fragmentos</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supongamos que estamos trabajando con una matriz de 30,000 x 3,000 elementos de tamaño. </font><font style="vertical-align: inherit;">Si necesita leer esta matriz y moverse a lo largo de su eje </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y moverse a lo largo de su eje </font></font><code>Y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puede guardar fragmentos que contengan los datos de esta matriz, como se muestra a continuación (en la práctica, lo más probable es que necesite más de 9 fragmentos):</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c3/ef4/df7/8c3ef4df7f8f782bbc28e998913f8e34.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, los datos ubicados tanto en el eje </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como en el eje </font></font><code>Y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se pueden cargar de manera eficiente. </font><font style="vertical-align: inherit;">Dependiendo de qué tipo de datos se necesitan en el programa, puede descargar, por ejemplo, fragmentos (1, 0), (1, 1), (1, 2) o fragmentos (0, 1), (1, 1), (2, 1).</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compresión de datos</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada fragmento puede ser comprimido. </font><font style="vertical-align: inherit;">Esto significa que los datos pueden ingresar al programa más rápido de lo que el disco le permite leer información sin comprimir. </font><font style="vertical-align: inherit;">Si los datos se comprimen 3 veces, esto significa que se pueden descargar del disco 3 veces más rápido que los datos sin comprimir, menos el tiempo que le toma al procesador desempaquetarlos.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/677/f42/f3f/677f42f3fc5539051f4adeb8f391684a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de descargar los fragmentos, se pueden eliminar de la memoria del programa.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resumen: memmap () o Zarr?</font></font></font></h2><br><font style="vertical-align: inherit;"></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cuál es </font><font style="vertical-align: inherit;">
mejor usar, </font><font style="vertical-align: inherit;">o Zarr? </font></font><br>
<br>
<code>Memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece interesante en tales casos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay muchos procesos que leen partes del mismo archivo. </font><font style="vertical-align: inherit;">Estos procesos, gracias a la aplicación </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, podrán compartir la misma caché de búfer. </font><font style="vertical-align: inherit;">Esto significa que solo una copia de los datos debe mantenerse en la memoria, sin importar cuántos procesos se estén ejecutando.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El desarrollador no desea administrar manualmente la memoria. </font><font style="vertical-align: inherit;">Planea confiar simplemente en las capacidades del sistema operativo, que resolverá todos los problemas de administración de memoria de forma automática e invisible para el desarrollador.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zarr es especialmente útil en las siguientes situaciones (en algunas de ellas, como se observará, el formato HDF5 también es aplicable):</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los datos se descargan de fuentes remotas, no del sistema de archivos local.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es muy probable que el cuello de botella del sistema se lea desde el disco. </font><font style="vertical-align: inherit;">La compresión de datos permitirá un uso más eficiente de las capacidades de hardware. </font><font style="vertical-align: inherit;">Esto también se aplica a HDF5.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si necesita obtener segmentos de matrices multidimensionales a lo largo de diferentes ejes, Zarr ayuda a optimizar dichas operaciones seleccionando el tamaño y la estructura apropiados de los fragmentos. </font><font style="vertical-align: inherit;">Esto es cierto para HDF5.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elegiría entre </font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr y, en primer lugar, trataría de usar Zarr, debido a la flexibilidad que brinda este paquete y al formato de almacenamiento de datos que implementa. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Queridos lectores! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cómo resuelve el problema de trabajar con grandes matrices NumPy?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es490620/index.html">Cuando escucho las palabras "restauró la red neuronal", subo para verificar las copias de seguridad</a></li>
<li><a href="../es490622/index.html">Combatir pérdidas de memoria en aplicaciones web</a></li>
<li><a href="../es490624/index.html">Encabezado HTTP de característica-política y control del navegador web</a></li>
<li><a href="../es490626/index.html">Una guía completa de datos- * atributos HTML</a></li>
<li><a href="../es490628/index.html">¿Qué hacer cuando CSS bloquea el análisis de páginas?</a></li>
<li><a href="../es490634/index.html">Eventos digitales en Moscú del 2 al 8 de marzo.</a></li>
<li><a href="../es490636/index.html">Eventos digitales en San Petersburgo del 2 al 8 de marzo.</a></li>
<li><a href="../es490640/index.html">Sobrecarga en C ++. Parte III Sobrecarga de declaraciones nuevas / eliminar</a></li>
<li><a href="../es490642/index.html">Plugin para monitorear aplicaciones K8s DevOpsProdigy KubeGraf v1.3.0: nueva versión y nuevas características</a></li>
<li><a href="../es490644/index.html">Repositorio rpm simple usando Inotify y webdav</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>