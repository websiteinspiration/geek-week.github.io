<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏽 ⚓️ 😽 Apache Kafka for Dummies 🗼 🐲 👸🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="对于那些刚刚开始了解微服务架构和Apache Kafka服务的人来说，本文将是有用的。该材料并不声称是详细的教程，但是可以帮助您快速入门该技术。我将讨论如何在Windows 10上安装和配置Kafka。我们还将使用Intellij IDEA和Spring Boot创建一个项目。
 
 做什么的？
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Apache Kafka for Dummies</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496182/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于那些刚刚开始了解微服务架构和Apache Kafka服务的人来说，本文将是有用的。</font><font style="vertical-align: inherit;">该材料并不声称是详细的教程，但是可以帮助您快速入门该技术。</font><font style="vertical-align: inherit;">我将讨论如何在Windows 10上安装和配置Kafka。我们还将使用Intellij IDEA和Spring Boot创建一个项目。</font></font><a name="habracut"></a><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做什么的？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
开发人员从未遇到过可能需要这些工具的情况，这往往会使人们难以理解各种工具。对于Kafka，这是完全相同的。我们描述了这种技术将有用的情况。如果您具有整体应用程序架构，那么您当然不需要任何Kafka。一切都随着向微服务的过渡而改变。实际上，每个微服务都是执行一个或另一个功能的独立程序，可以独立于其他微服务启动。可以将微服务与办公室中的员工进行比较，后者坐在分开的办公桌旁并独立解决他们的问题。如果没有中央协调，这样一个分散的团队的工作是不可想象的。员工应该能够彼此交换信息和工作结果。用于微服务的Apache Kafka旨在解决此问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apache Kafka是一个消息代理。借助它，微服务可以彼此交互，发送和接收重要信息。出现了一个问题，为什么不为此使用常规POST-请求，就可以在其主体中以相同的方式传输必要的数据并获得答案？这种方法有许多明显的缺点。例如，生产者（发送消息的服务）只能响应于消费者（接收数据的服务）的请求以响应的形式发送数据。假设使用者发送了一个POST请求，而生产者回答了该请求。此时，由于某种原因，消费者无法接受答案。数据将如何处理？他们会迷路的。使用者将再次必须发送请求，并希望在此期间他想要接收的数据没有改变，生产者仍准备接受该请求。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apache Kafka解决了在微服务之间交换消息时出现的这个问题和许多其他问题。</font><font style="vertical-align: inherit;">不能忘记，不中断和方便的数据交换是确保微服务体系结构稳定运行所必须解决的关键问题之一。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Windows 10上安装和配置ZooKeeper和Apache Kafka</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，您需要知道的第一件事是Apache Kafka在ZooKeeper服务之上运行。 ZooKeeper是一种分布式配置和同步服务，在这种情况下，我们需要了解的一切。在开始使用Kafka之前，我们必须下载，配置和运行它。在开始使用ZooKeeper之前，请确保已安装并配置了JRE。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以从官方网站下载最新版本的ZooKeeper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将文件从下载的ZooKeeper存档中提取到磁盘上的文件夹中。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在带有版本号的zookeeper文件夹中，我们找到conf文件夹，并在其中找到文件“ zoo_sample.cfg”。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ho/ke/pz/hokepzidcuiupzigc3i3wtlxi6s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
复制它，并将副本名称更改为“ zoo.cfg”。打开复制文件，然后在其中找到行dataDir = / tmp / zookeeper。在这一行中，我们将完整路径写入到zookeeper-x.x.x文件夹中。对我来说看起来像这样：dataDir = C：\\ ZooKeeper \\ zookeeper-3.6.0 </font></font><br>
<img src="https://habrastorage.org/webt/ri/sk/2h/risk2h-3u771fpod5vvxodydrhy.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们添加系统环境变量：ZOOKEEPER_HOME = C：\ ZooKeeper \ zookeeper-3.4.9，并在系统变量Path的末尾添加条目：;％ZOOKEEPER_HOME ％\ bin; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
运行命令行并编写命令：</font></font><br>
<br>
<pre><code class="cs hljs">zkserver</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 如果一切操作正确，您将看到类似以下的内容。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/b-/rs/i6/b-rsi6uqc40e77tchqnimmhsgo8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这意味着ZooKeeper正常启动。我们直接进行Apache Kafka服务器的安装和配置。从官方网站下载最新版本并提取存档的内容：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kafka.apache.org/downloads</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在Kafka文件夹中，我们找到config文件夹，在其中找到server.properties文件并打开它。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/px/o5/m0/pxo5m032s0lvvmjqbhmfaazfnog.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们找到行log.dirs = / tmp / kafka-logs，并在其中指出Kafka将保存日志的路径：log.dirs = c：/ kafka / kafka-logs。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gh/bi/mg/ghbimgkxct-2ox1a8s8klpackco.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在同一文件夹中，编辑zookeeper.properties文件。我们将行dataDir = / tmp / zookeeper更改为dataDir = c：/ kafka / zookeeper-data，而不会忘记在磁盘名称后指出指向Kafka文件夹的路径。如果一切正确，则可以运行ZooKeeper和Kafka。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yd/nd/mr/ydndmrfkovlk4z75mc99lbs3clk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于某些人来说，没有GUI来控制Kafka可能令人不快。</font><font style="vertical-align: inherit;">也许这是因为该服务是专为苛刻的书呆子设计的，专门用于控制台。</font><font style="vertical-align: inherit;">一种或另一种方式，要运行Kafka，我们需要一个命令行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，您需要启动ZooKeeper。</font><font style="vertical-align: inherit;">在包含kafka的文件夹中，找到bin / windows文件夹，在其中找到启动zookeeper-server-start.bat服务的文件，单击该文件。</font><font style="vertical-align: inherit;">什么都没发生？</font><font style="vertical-align: inherit;">应该是这样。</font><font style="vertical-align: inherit;">打开此文件夹中的控制台，然后输入：</font></font><br>
<br>
<pre><code class="cs hljs"> start zookeeper-server-start.bat</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 不再工作了吗？</font><font style="vertical-align: inherit;">这是常态。</font><font style="vertical-align: inherit;">这是因为zookeeper-server-start.bat需要使用zookeeper.properties文件中指定的参数，正如我们回想的那样，该文件位于config文件夹中以进行工作。</font><font style="vertical-align: inherit;">我们写到控制台：</font></font><br>
<br>
<pre><code class="cs hljs">start zookeeper-server-start.bat c:\kafka\config\zookeeper.properties </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在一切应该正常开始。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wn/q1/hr/wnq1hrvtfit6o_mgsqkdkrzcjiw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再次打开此文件夹中的控制台（不要关闭ZooKeeper！），然后运行kafka：</font></font><br>
<br>
<pre><code class="cs hljs">start kafka-server-start.bat c:\kafka\config\server.properties</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了不每次都在命令行上编写命令，可以使用旧的行之有效的方法并创建一个具有以下内容的批处理文件：</font></font><br>
<br>
<pre><code class="cs hljs">start C:\kafka\bin\windows\zookeeper-server-start.bat C:\kafka\config\zookeeper.properties<font></font>
timeout <span class="hljs-number">10</span>
start C:\kafka\bin\windows\kafka-server-start.bat C:\kafka\config\server.properties</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
需要超时10行来设置启动zookeeper和kafka之间的暂停。</font><font style="vertical-align: inherit;">如果一切正确，单击批处理文件时，将打开两个控制台，分别运行zookeeper和kafka，现在我们可以直接从命令行创建带有必需参数的消息生产者和使用者。</font><font style="vertical-align: inherit;">但是，实际上，除非测试服务，否则可能需要它。</font><font style="vertical-align: inherit;">我们将对如何使用IDEA的kafka更加感兴趣。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与IDEA的kafka一起使用</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将编写最简单的应用程序，该应用程序将同时是消息的生产者和使用者，然后向其添加有用的功能。</font><font style="vertical-align: inherit;">创建一个新的spring项目。</font><font style="vertical-align: inherit;">最方便的方法是使用弹簧初始化器。</font><font style="vertical-align: inherit;">添加依赖项org.springframework.kafka和spring-boot-starter-web </font></font><br>
<br>
<img src="https://habrastorage.org/webt/n8/tv/vd/n8tvvda_h1eedp1j7iodblqnv3u.png"><br>
<br>
<img src="https://habrastorage.org/webt/so/kb/pw/sokbpw-hvkzn8ihnzsokhqn0-yo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，pom.xml文件应如下所示：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gw/oc/ub/gwocubssaaqvggzlya-mgdwso24.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了发送消息，我们需要KafkaTemplate &lt;K，V&gt;对象。</font><font style="vertical-align: inherit;">如我们所见，对象已输入。</font><font style="vertical-align: inherit;">第一个参数是密钥的类型，第二个参数是消息本身。</font><font style="vertical-align: inherit;">现在，我们将两个参数都表示为String。</font><font style="vertical-align: inherit;">我们将在类控制器中创建对象。</font><font style="vertical-align: inherit;">声明KafkaTemplate并要求Spring通过注释对其进行初始化</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自动接线</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原则上，我们的生产者已经准备就绪。剩下要做的就是在其上调用send（）方法。此方法有多个重载版本。我们在项目中使用具有3个参数的选项-发送（字符串主题，K键，V数据）。由于KafkaTemplate是用字符串键入的，因此send方法中的键和数据将是字符串。第一个参数指定主题，即消息将发送到的主题，以及消费者可以订阅以接收消息的主题。如果send方法中指定的主题不存在，它将自动创建。完整的类文本如下所示。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping("msg")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgController</span> </span>{<font></font>
<font></font>
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;<font></font>
<font></font>
    <span class="hljs-meta">@PostMapping</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendOrder</span><span class="hljs-params">(String msgId, String msg)</span></span>{<font></font>
        kafkaTemplate.send(<span class="hljs-string">"msg"</span>, msgId, msg);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
控制器映射到</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本地主机</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：8080 / msg，密钥和消息本身在请求主体中传输。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
消息发送者已准备就绪，现在创建一个侦听器。</font><font style="vertical-align: inherit;">Spring还可以让您轻松完成此操作。</font><font style="vertical-align: inherit;">创建一个方法并用@KafkaListener批注对其进行标记就足够了，在该批注的参数中，您仅可以指定要收听的主题。</font><font style="vertical-align: inherit;">在我们的情况下，它看起来像这样。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@KafkaListener(topics="msg")</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
标有注释的方法本身可以指定一个可接受的参数，该参数具有生产者发送的消息类型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将在其中创建使用者的类必须用@EnableKafka批注标记。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@EnableKafka</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleKafkaExampleApplication</span> </span>{<font></font>
<font></font>
    <span class="hljs-meta">@KafkaListener(topics="msg")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">msgListener</span><span class="hljs-params">(String msg)</span></span>{<font></font>
        System.out.println(msg);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<font></font>
        SpringApplication.run(SimpleKafkaExampleApplication.class, args);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，在application.property设置文件中，您必须指定礼宾参数groupe-id。</font><font style="vertical-align: inherit;">如果不这样做，该应用程序将无法启动。</font><font style="vertical-align: inherit;">该参数的类型为String，可以是任何值。</font></font><br>
<br>
<pre><code class="cs hljs">spring.kafka.consumer.<span class="hljs-keyword">group</span>-id=app<span class="hljs-number">.1</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们最简单的kafka项目已准备就绪。</font><font style="vertical-align: inherit;">我们有消息的发送者和接收者。</font><font style="vertical-align: inherit;">它仍然只能运行。</font><font style="vertical-align: inherit;">首先，使用我们先前编写的批处理文件启动ZooKeeper和Kafka，然后启动我们的应用程序。</font><font style="vertical-align: inherit;">使用Postman发送请求最方便。</font><font style="vertical-align: inherit;">在请求的正文中，不要忘记指定参数msgId和msg。</font></font><br>
<img src="https://habrastorage.org/webt/_o/og/jt/_oogjtlzajgbbnpsf8sjg8k0num.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们在IDEA中看到这样的图片，则一切正常：生产者发送了一条消息，消费者收到了该消息并将其显示在控制台上。</font></font><br>
<img src="https://habrastorage.org/webt/kg/zq/j3/kgzqj38qw5q67mmr0fa2ijucflw.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使项目复杂化</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用Kafka的实际项目肯定比我们创建的项目复杂。现在我们已经弄清了服务的基本功能，请考虑它提供了哪些附加功能。首先，我们将改善生产者。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果打开send（）方法，您可能会注意到其所有变体的返回值均为ListenableFuture &lt;SendResult &lt;K，V &gt;&gt;。现在，我们将不详细考虑此接口的功能。在这里足以说出需要查看发送消息的结果。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@PostMapping</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(String msgId, String msg)</span></span>{<font></font>
    ListenableFuture&lt;SendResult&lt;String, String&gt;&gt; future = kafkaTemplate.send(<span class="hljs-string">"msg"</span>, msgId, msg);<font></font>
    future.addCallback(System.out::println, System.err::println);<font></font>
    kafkaTemplate.flush();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
addCallback（）方法接受两个参数-SuccessCallback和FailureCallback。</font><font style="vertical-align: inherit;">它们都是功能接口。</font><font style="vertical-align: inherit;">从名称中您可以理解，第一个方法将由于成功发送消息而被调用，第二个方法将由于错误而被调用。现在，如果我们运行该项目，我们将在控制台上看到类似以下内容的内容：</font></font><br>
<br>
<pre><code class="cs hljs">SendResult [producerRecord=ProducerRecord(topic=msg, partition=<span class="hljs-literal">null</span>, headers=RecordHeaders(headers = [], isReadOnly = <span class="hljs-literal">true</span>), key=<span class="hljs-number">1</span>, <span class="hljs-keyword">value</span>=Hello, world!, timestamp=<span class="hljs-literal">null</span>), recordMetadata=msg<span class="hljs-number">-0</span>@<span class="hljs-number">6</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们再次仔细看看我们的制作人。</font><font style="vertical-align: inherit;">有趣的是，如果密钥不是String，而是Long，但是作为传输的消息，甚至更糟-某种复杂的DTO，会发生什么？</font><font style="vertical-align: inherit;">首先，</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hl/3m/81/hl3m81wnp81kngs_abmdx9wemlm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们</font><font style="vertical-align: inherit;">尝试将键更改为数字值... </font><font style="vertical-align: inherit;">如果在生产者中将Long指定为键，则应用程序将正常启动，但是当您尝试发送消息时，将抛出ClassCastException并且将报告Long类无法转换为String类。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fe/ti/tz/fetitzsqvkjsetoigt8lwodxcbk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果尝试手动创建KafkaTemplate对象，则会看到ProducerFactory &lt;K，V&gt;接口对象（例如DefaultKafkaProducerFactory &lt;&gt;）作为参数传递给构造函数。为了创建DefaultKafkaProducerFactory，我们需要将包含其生产者设置的Map传递给其构造函数。用于配置和创建生产者的所有代码都将放在单独的类中。为此，请创建配置包，并在其中创建KafkaProducerConfig类。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaProducerConfig</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">private</span> String kafkaServer=<span class="hljs-string">"localhost:9092"</span>;<font></font>
<font></font>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">producerConfigs</span><span class="hljs-params">()</span> </span>{<font></font>
        Map&lt;String, Object&gt; props = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<font></font>
        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,<font></font>
                kafkaServer);<font></font>
        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,<font></font>
                LongSerializer.class);<font></font>
        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,<font></font>
                StringSerializer.class);<font></font>
        <span class="hljs-keyword">return</span> props;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ProducerFactory&lt;Long, String&gt; <span class="hljs-title">producerFactory</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultKafkaProducerFactory&lt;&gt;(producerConfigs());<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> KafkaTemplate&lt;Long, String&gt; <span class="hljs-title">kafkaTemplate</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> KafkaTemplate&lt;&gt;(producerFactory());<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在producerConfigs（）方法中，使用配置创建一个映射，并指定LongSerializer.class作为密钥的序列化器。</font><font style="vertical-align: inherit;">我们开始，发送来自Postman的请求，然后看到一切正常运行：生产者发送消息，而消费者接收消息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们更改传输值的类型。</font><font style="vertical-align: inherit;">如果我们没有Java库中的标准类，而是某种自定义DTO，该怎么办？</font><font style="vertical-align: inherit;">这么说吧。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDto</span> </span>{
    <span class="hljs-keyword">private</span> Long age;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Address address;<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>{
    <span class="hljs-keyword">private</span> String country;
    <span class="hljs-keyword">private</span> String city;
    <span class="hljs-keyword">private</span> String street;
    <span class="hljs-keyword">private</span> Long homeNumber;
    <span class="hljs-keyword">private</span> Long flatNumber;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要将DTO作为消息发送，您需要对生产者配置进行一些更改。</font><font style="vertical-align: inherit;">将JsonSerializer.class指定为消息值的序列化器，并且不要忘记在所有地方都将String类型更改为UserDto。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaProducerConfig</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">private</span> String kafkaServer=<span class="hljs-string">"localhost:9092"</span>;<font></font>
<font></font>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">producerConfigs</span><span class="hljs-params">()</span> </span>{<font></font>
        Map&lt;String, Object&gt; props = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<font></font>
        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,<font></font>
                kafkaServer);<font></font>
        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,<font></font>
                LongSerializer.class);<font></font>
        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,<font></font>
                JsonSerializer.class);<font></font>
        <span class="hljs-keyword">return</span> props;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ProducerFactory&lt;Long, UserDto&gt; <span class="hljs-title">producerFactory</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultKafkaProducerFactory&lt;&gt;(producerConfigs());<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> KafkaTemplate&lt;Long, UserDto&gt; <span class="hljs-title">kafkaTemplate</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> KafkaTemplate&lt;&gt;(producerFactory());<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
发送信息。控制台中将显示以下行：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/e8/2f/xu/e82fxufwzg_yai2rs5vx5athbts.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们将使使用者复杂化。在此之前，带有注释@KafkaListener（topics =“ msg”）标记的方法public void msgListener（String msg）将String作为参数并将其显示在控制台上。如果我们想获取传输消息的其他参数，例如密钥或分区，该怎么办？在这种情况下，必须更改传输值的类型。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@KafkaListener(topics="msg")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">orderListener</span><span class="hljs-params">(ConsumerRecord&lt;Long, UserDto&gt; record)</span></span>{<font></font>
    System.out.println(record.partition());<font></font>
    System.out.println(record.key());<font></font>
    System.out.println(record.value());<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从ConsumerRecord对象中，我们可以获得我们感兴趣的所有参数。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zq/ml/pw/zqmlpw7o5xzb0fxxzq7rez5qjpa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们看到代替控制台上的键，而是显示了某种krakozyabry。这是因为默认情况下使用StringDeserializer来反序列化键，并且如果我们希望以整数格式正确显示键，则必须将其更改为LongDeserializer。要在config包中配置使用者，请创建KafkaConsumerConfig类。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaConsumerConfig</span> </span>{<font></font>
<font></font>
    <span class="hljs-meta">@Value("${spring.kafka.bootstrap-servers}")</span>
    <span class="hljs-keyword">private</span> String kafkaServer;<font></font>
<font></font>
    <span class="hljs-meta">@Value("${spring.kafka.consumer.group-id}")</span>
    <span class="hljs-keyword">private</span> String kafkaGroupId;<font></font>
<font></font>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">consumerConfigs</span><span class="hljs-params">()</span> </span>{<font></font>
        Map&lt;String, Object&gt; props = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<font></font>
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaServer);<font></font>
        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, LongDeserializer.class);<font></font>
        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);<font></font>
        props.put(ConsumerConfig.GROUP_ID_CONFIG, kafkaGroupId);<font></font>
        <span class="hljs-keyword">return</span> props;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> KafkaListenerContainerFactory&lt;?&gt; kafkaListenerContainerFactory() {<font></font>
        ConcurrentKafkaListenerContainerFactory&lt;Long, UserDto&gt; factory =<font></font>
                <span class="hljs-keyword">new</span> ConcurrentKafkaListenerContainerFactory&lt;&gt;();<font></font>
        factory.setConsumerFactory(consumerFactory());<font></font>
        <span class="hljs-keyword">return</span> factory;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ConsumerFactory&lt;Long, UserDto&gt; <span class="hljs-title">consumerFactory</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs());<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
KafkaConsumerConfig类与我们之前创建的KafkaProducerConfig非常相似。还有一个Map，其中包含必要的配置，例如，键和值的反序列化器。创建的映射用于创建ConsumerFactory &lt;&gt;，而后者又需要用于创建KafkaListenerContainerFactory &lt;？&gt;。一个重要的细节：返回KafkaListenerContainerFactory &lt;？&gt;的方法应称为kafkaListenerContainerFactory（），否则Spring将无法找到所需的bean，并且项目将无法编译。我们开始。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6x/mb/t9/6xmbt9zj5i6uzdx95a7ck4hjjxk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们看到现在密钥已按原样显示，这意味着一切正常。</font><font style="vertical-align: inherit;">当然，Apache Kafka的功能远远超出了本文中介绍的功能，但是，我希望阅读后能对这项服务有所了解，最重要的是，您可以开始使用它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多洗手，戴口罩，不要无故外出，保持健康。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN496170/index.html">我们注定了第一名// // Udalenka陷入危机和独创性的死亡</a></li>
<li><a href="../zh-CN496174/index.html">对分析，产品团队，亚马逊，以色列，新加坡，远程工作等的需求增加-讨论了很多。</a></li>
<li><a href="../zh-CN496176/index.html">大型虚拟会议：保护现代数字公司的数据的真实经验</a></li>
<li><a href="../zh-CN496178/index.html">斯威夫特5.2。所有变更概述</a></li>
<li><a href="../zh-CN496180/index.html">照顾青春的阴影</a></li>
<li><a href="../zh-CN496184/index.html">LED显示技术：Micro-LED vs. 迷你LED</a></li>
<li><a href="../zh-CN496186/index.html">以Word2Vec为例的错误反向传播算法</a></li>
<li><a href="../zh-CN496188/index.html">如何停止狂欢看电视节目并开始生活</a></li>
<li><a href="../zh-CN496190/index.html">关于短语动词2</a></li>
<li><a href="../zh-CN496192/index.html">从Go调用Rust函数</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>