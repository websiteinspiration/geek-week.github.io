<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕑 🍅 👰🏻 ミニライトとショックセンサー| nRF52840 🧑🏽‍🤝‍🧑🏼 ➰ 💽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今日の記事では、新しい光と振動センサーについてお話ししたいと思います。センサーはモジュールE73-2G​​4M08S1C（nRF52840）で動作します。MKが開発された理由は、Sandeep Mistryライブラリに基づくArduino IDEへのサポートの追加、低コスト、優れた機能、およびMyS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ミニライトとショックセンサー| nRF52840</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478960/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今日の記事では、新しい光と振動センサーについてお話ししたいと思います。</font><font style="vertical-align: inherit;">センサーはモジュールE73-2G​​4M08S1C（nRF52840）で動作します。</font><font style="vertical-align: inherit;">MKが開発された理由は、Sandeep Mistryライブラリに基づくArduino IDEへのサポートの追加、低コスト、優れた機能、およびMySensorsからZigBeeへのシームレスな切り替えを継続できることなどです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dm/b0/dt/dmb0dtvbakfgj_pgye8k_wjlmdc.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなプロジェクトの必要性は、私の家にローラーブラインドが登場したことから生まれました。</font><font style="vertical-align: inherit;">ローラーブラインドコントローラーは、コントローラーがカーテンを制御する窓から直接、照明のレベルに関するデータを受け取る必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、BH1750FVIセンサーを使用する予定でしたが、このセンサーの特性は良好で、他のDIYプロジェクトで複数回使用されました。</font><font style="vertical-align: inherit;">しかし、ある時点で、すべての種類のセンサーについて説明するとき、誰かがMAX44009センサーを詳しく検討することを提案しました。</font><font style="vertical-align: inherit;">私はよく見て、その瞬間からBH1750FVIを思い出しませんでした。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d7/bg/a_/d7bga_4sti9_x359xlgirab0egk.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MAX44009の仕様：</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">供給電圧範囲1.7-3.6 V、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">超低動作電流-0.65μA（多くの類似製品のパワーダウンモードの電流よりも低い）、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22ビットの広いダイナミックレンジ0.045-188000、</font></font></li>
<li>  ,     ,          .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、普遍性や、拡張機能のようなものも欲しかったので、振動センサーとして機能する加速度計をプロジェクトに追加することを少し考えました。</font><font style="vertical-align: inherit;">これにより、センサーにセキュリティ機能が追加されます。</font><font style="vertical-align: inherit;">私の場合、イベントに基づいて、UDのスクリプトがセンサーからトリガーされ、家の存在をシミュレートします（部屋のライトをオンにします）。アクティブにすると、誰も家にいません。</font><font style="vertical-align: inherit;">一般に、センサーはスタンドアロンの振動および衝撃センサーとしても使用でき、光センサーのみまたは加速度計のみをはんだ付けできます。</font><font style="vertical-align: inherit;">加速度計は、タパス、ターンなどを認識するように再プログラムすることもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
加速度計としてLIS2DW12センサーが選択されましたが、これは市場で最も経済的ではないとしても、最も経済的な加速度計の1つです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ex/jc/op/exjcop6l77shvd-ietzkuksg5hq.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LIS2DW12の機能：</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">供給電圧範囲1.62-3.6 V、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタンバイモードで50 nA</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">低電力モードで1μA、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">割り込み機能の存在、センサーの連続動作の可能性、および指定されたしきい値を超えたときのMCへの割り込み信号の形成。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LIS2DW12用の既製のArduinoライブラリが完全に不足しているため、この加速度計モデルの立ち上げでArduino兄弟に起こりうる問題を予測し、同様の特性を持つLIS2DH12加速度計の別のモデルのサポートが後に追加されましたが、低電力モードでの消費量が高くなります-2μA。</font><font style="vertical-align: inherit;">LIS2DH12加速度計には、非常に優れたArduinoライブラリがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
光センサーはCR2032バッテリーで駆動します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bd/z3/lf/bdz3lfe167cepe3m-5vvg0fc5-0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MySensorsプロジェクトを使用してスマートホームを構築したことのある人の多くは、バッテリーデバイスでのMySensorsの非最適なロジックについておそらく知っています。デバイスの再起動時のプレゼンテーションの継続的な送信、ネットワーク上のデバイスの自動回復の次善のモード、スリープ機能の中断がアクティブ化された次善の消費、一般的に、夢には2つだけの中断が存在します。すべての状況は、Maysensorsプロジェクトの創設者が電池に対して悪い態度を持っているという事実を具体的に示唆しています:) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロジェクトでは、私はこれらの欠点を最小限にしようとしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が対処したかった最も基本的なことは、中断でした。</font><font style="vertical-align: inherit;">通常、スリープ機能で割り込みがアクティブになると、MK nRF52は+ 10mKAを消費し始め、MK自体を消費します（nRF52810-52811の場合は1.4μA、nRF52832-52840の場合は最大4.7μA）。</font><font style="vertical-align: inherit;">合計2つの割り込みを使用できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> interrupt1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> mode1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> interrupt2, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> mode2, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> sleepingMS = <span class="hljs-number">0</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> smartSleep = <span class="hljs-literal">false</span>)</span></span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前は、スリープ消費を最適化するためのソリューションを探して、組み込みの低消費コンパレータで割り込みを使用する可能性が実現しました。スリープ消費は+ 10μAではなく、+ 1μAの領域でしたが、割り込みに使用できるのは1つだけでした。</font><font style="vertical-align: inherit;">原則として、コードの不便さ（追加のピンからの信号の処理）とボード上の追加の要素（ダイオード）は別として、これは良い解決策でした。</font><font style="vertical-align: inherit;">しかし、私はそれをもっと良くしたかったのです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時までに、私はすでにnRF5 SDKに少し慣れ親しんでいたので、mysensors.orgフォーラム（ヒント、ヒント:)）を調べた後、nRF5 SDKで解決策を探すことに決め、それを見つけました。現在、無制限の数の割り込みが利用可能であり、実質的に余分なものを消費しません。主なことは、WInterruptsファイルのSandeepmistry nRF5ライブラリのコードに小さな変更を加えることです。GPIOTE_IRQHandler（）関数の前に属性「weak」を追加すると、このライブラリ関数をユーザーコードでオーバーライドできます-__attribute__（（weak））</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s5/sf/oy/s5sfoy5fdmvjiu16afhtkcrxkjg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルはパスにあります- C：\ Users \ USER_COMPA \ AppData \ Local \ Arduino15 \ packages \ sandeepmistry \ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
hardware \ nRF5 \ 0.6.0 \ cores \ nRF5 \</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトに追加する必要があるファイルは、GitaのEFEKTA-LIS2DW12-MAX44009-E73C / SOURCE CODE / ARDUINO /フォルダーにあります。使用例は、スケッチEFEKTA-LIS2DW12-MAX44009-E73C / SOURCE CODE / ARDUINO / vibro_ambi1_inoにあります</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次にファイナライズしたいのは、Sandeepmistry nRF5ライブラリ自体でした。そのため、新しいMK nRF52840、nRF52811、およびoldを使用するのが便利ですが、何らかの理由で、nRF52810が不当に追加されていません（結局のところ、夢の1.4μAはあなたのためではありません:)）。もちろん、Arduino IDEとnRF52832の下からnRF52840を操作できますが、もっと快適にしたかったのです。上記で、Nordic SDKで何かをすることに関心があると書きました。特に、MK nRF5を使用する場合、Segger Embedded Studioは無料です。私にとって興味深いすべてのボードのサポートはKFORから取得され、Arduinoに転送されました（これまでのところ、softdeviceがなければ、mysensorsでは必要ありません）。 MySensorsライブラリに新しいボードも追加されました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xc/hy/dy/xchydy8gbj0ld1tcvtyjiqbu70o.png"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/smartboxchannel/arduino-nRF5 </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/smartboxchannel/MySensors</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読者の1人が私の以前の記事に既に精通している場合は、以前と同じように、光センサーのケースとしてSLAで液体ポリマープリンターを使用したことに驚かないでしょう。このテクノロジーでの印刷の利点は、その高精度です。しかし、もちろん、デメリットもあります。家庭用SLAプリンターで使用できるポリマーは、FDMのプラスチックよりも強度が劣っています。ケースの3Dモデルは2つのパーツで構成され、各半分が40分間印刷されました（層の厚さ50ミクロン）。特にここで止める必要はおそらくないでしょう。3Dエディタでの開発プロセスの写真を数枚だけです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/a0/x0/qt/a0x0qtl5jiglsmcidmbjibr_5wi.png"><br>
<br>
<img src="https://habrastorage.org/webt/by/cz/rk/byczrkmuesyuzijn5yyvv71uroa.png"><br>
<br>
<img src="https://habrastorage.org/webt/i4/ct/qc/i4ctqcrbeduw2p4an1a1jpkie9s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
センサープログラムは、プレゼンテーションを送信せずにデバイスの再起動を実装しました。これは次のように機能します。デバイスが新しくネットワークに追加されていない場合、最初にネットワークに追加されたときにプレゼンテーションが登録および完了します。登録が成功すると、識別子を受信したデバイスはプレゼンテーションを再度送信しなくなりますが、センサーのボタンをクリックしてプレゼンテーションを送信できます（これはたとえば、すべてのセンサーがすぐに正常に提示されなかった場合など）。また、プログラムはネットワーク上の作業の標準的な自動回復の可能性を無効にします（センサーがネットワークを失った場合）、独自の非標準オプションが発明されました:)。これは次のように機能します。センサーが5つ以上（これはカスタマイズ可能です）のメッセージを続けて送信しようとして失敗したことを検出した場合、次に、デバイスはセンサーからのデータの送信を停止し、最初に/ 2センサーからの送信間隔と等しい間隔でネットワークの検索に関するメッセージの送信を開始し、送信のたびにこの間隔を定期的に増やします。これにより、バッテリーの電力を大幅に節約できます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストコード</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">SDK</span> <span class="hljs-selector-tag">PORT</span>
<span class="hljs-selector-tag">extern</span> "<span class="hljs-selector-tag">C</span>" {<font></font>
#include "app_gpiote.h"<font></font>
#include "nrf_gpio.h"<font></font>
}<font></font>
<span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">APP_GPIOTE_MAX_USERS</span> 1
<span class="hljs-selector-id">#include</span> &lt;<span class="hljs-selector-tag">LIS2DW12Sensor</span><span class="hljs-selector-class">.h</span>&gt;
<span class="hljs-selector-id">#include</span> &lt;<span class="hljs-selector-tag">MAX44009</span><span class="hljs-selector-class">.h</span>&gt;<font></font>
//<span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">MY_DEBUG</span>
<span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">MY_RADIO_NRF5_ESB</span>
<span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">MY_DISABLED_SERIAL</span>
<span class="hljs-selector-tag">int16_t</span> <span class="hljs-selector-tag">mtwr</span>;
<span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">MY_TRANSPORT_WAIT_READY_MS</span> (<span class="hljs-selector-tag">mtwr</span>)
<span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">MY_NRF5_ESB_PA_LEVEL</span> (<span class="hljs-selector-tag">NRF5_PA_MAX</span>)
<span class="hljs-selector-id">#include</span> &lt;<span class="hljs-selector-tag">MySensors</span><span class="hljs-selector-class">.h</span>&gt;
<span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">SN</span> "<span class="hljs-selector-tag">LUX</span> &amp; <span class="hljs-selector-tag">VIBRO</span> <span class="hljs-selector-tag">SENS</span>"
<span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">SV</span> "1<span class="hljs-selector-class">.0</span>"
<span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">V_SENS_CHILD_ID</span> 1
<span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">LUX_SENS_CHILD_ID</span> 2
<span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">WPM_SENS_CHILD_ID</span> 3
<span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">INTERVAL_R_LUX_CHILD_ID</span> 220
<span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">LEVEL_SENSIV_V_SENS_CHILD_ID</span> 230
<span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">ENABLE_WPM_SENS_CHILD_ID</span> 240
<span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">SIGNAL_Q_ID</span> 253
<span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">TEMP_CHILD_ID</span> 254 //<span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">any</span> <span class="hljs-selector-tag">tests</span>
<span class="hljs-selector-id">#include</span> &lt;<span class="hljs-selector-tag">MySensors</span><span class="hljs-selector-class">.h</span>&gt;
<span class="hljs-selector-tag">MyMessage</span> <span class="hljs-selector-tag">vibroMsg</span>(<span class="hljs-selector-tag">V_SENS_CHILD_ID</span>, <span class="hljs-selector-tag">V_TRIPPED</span>);
<span class="hljs-selector-tag">MyMessage</span> <span class="hljs-selector-tag">brightMsg</span>(<span class="hljs-selector-tag">LUX_SENS_CHILD_ID</span>, <span class="hljs-selector-tag">V_LEVEL</span>);
<span class="hljs-selector-tag">MyMessage</span> <span class="hljs-selector-tag">wpmMsg</span>(<span class="hljs-selector-tag">WPM_SENS_CHILD_ID</span>, <span class="hljs-selector-tag">V_LEVEL</span>);
<span class="hljs-selector-tag">MyMessage</span> <span class="hljs-selector-tag">conf_wpmMsg</span>(<span class="hljs-selector-tag">ENABLE_WPM_SENS_CHILD_ID</span>, <span class="hljs-selector-tag">V_VAR1</span>);
<span class="hljs-selector-tag">MyMessage</span> <span class="hljs-selector-tag">conf_vsensMsg</span>(<span class="hljs-selector-tag">LEVEL_SENSIV_V_SENS_CHILD_ID</span>, <span class="hljs-selector-tag">V_VAR1</span>);
<span class="hljs-selector-tag">MyMessage</span> <span class="hljs-selector-tag">conf_interv_rluxMsg</span>(<span class="hljs-selector-tag">INTERVAL_R_LUX_CHILD_ID</span>, <span class="hljs-selector-tag">V_VAR1</span>);
<span class="hljs-selector-tag">MyMessage</span> <span class="hljs-selector-tag">tempMsg</span>(<span class="hljs-selector-tag">TEMP_CHILD_ID</span>, <span class="hljs-selector-tag">V_VAR1</span>); //<span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">any</span> <span class="hljs-selector-tag">tests</span>
<span class="hljs-selector-tag">bool</span> <span class="hljs-selector-tag">nosleep</span> = 0;
<span class="hljs-selector-tag">bool</span> <span class="hljs-selector-tag">button_flag</span> = 0;
<span class="hljs-selector-tag">bool</span> <span class="hljs-selector-tag">configMode</span> = 0;
<span class="hljs-selector-tag">bool</span> <span class="hljs-selector-tag">wpm_enable</span> = 0;
<span class="hljs-selector-tag">bool</span> <span class="hljs-selector-tag">onoff</span> = 1;
<span class="hljs-selector-tag">bool</span> <span class="hljs-selector-tag">flag_update_transport_param</span>;
<span class="hljs-selector-tag">bool</span> <span class="hljs-selector-tag">flag_sendRoute_parent</span>;
<span class="hljs-selector-tag">bool</span> <span class="hljs-selector-tag">flag_no_present</span>;
<span class="hljs-selector-tag">bool</span> <span class="hljs-selector-tag">flag_nogateway_mode</span>;
<span class="hljs-selector-tag">bool</span> <span class="hljs-selector-tag">flag_find_parent_process</span>;
<span class="hljs-selector-tag">bool</span> <span class="hljs-selector-tag">flag_fcount</span>;
<span class="hljs-selector-tag">bool</span> <span class="hljs-selector-tag">Ack_TL</span>;
<span class="hljs-selector-tag">bool</span> <span class="hljs-selector-tag">Ack_FP</span>;
<span class="hljs-selector-tag">bool</span> <span class="hljs-selector-tag">PRESENT_ACK</span>;
<span class="hljs-selector-tag">byte</span> <span class="hljs-selector-tag">conf_vibro_set</span> = 1;
<span class="hljs-selector-tag">byte</span> <span class="hljs-selector-tag">interval_reading_lux</span> = 10;
<span class="hljs-selector-tag">byte</span> <span class="hljs-selector-tag">err_delivery_beat</span>;
<span class="hljs-selector-tag">byte</span> <span class="hljs-selector-tag">problem_mode_count</span>;
<span class="hljs-selector-tag">uint8_t</span>  <span class="hljs-selector-tag">countbatt</span> = 0;
<span class="hljs-selector-tag">uint8_t</span> <span class="hljs-selector-tag">batt_cap</span>;
<span class="hljs-selector-tag">uint8_t</span> <span class="hljs-selector-tag">old_batt_cap</span> = 100;<font></font>
//<span class="hljs-selector-tag">unsigned</span> <span class="hljs-selector-tag">long</span> <span class="hljs-selector-tag">BATT_TIME</span> = 43200000; //12 <span class="hljs-selector-tag">hours</span>
<span class="hljs-selector-tag">uint32_t</span> <span class="hljs-selector-tag">BATT_TIME</span> = 7200000; //12 <span class="hljs-selector-tag">hours</span>
<span class="hljs-selector-tag">uint32_t</span> <span class="hljs-selector-tag">SLEEP_TIME_TEMP</span> = 60000; //1 <span class="hljs-selector-tag">minute</span>
<span class="hljs-selector-tag">uint32_t</span> <span class="hljs-selector-tag">SLEEP_TIME</span>;
<span class="hljs-selector-tag">uint32_t</span> <span class="hljs-selector-tag">C_BATT_TIME</span>;
<span class="hljs-selector-tag">uint32_t</span> <span class="hljs-selector-tag">oldmillis</span>;
<span class="hljs-selector-tag">uint32_t</span> <span class="hljs-selector-tag">newmillis</span>;
<span class="hljs-selector-tag">uint32_t</span> <span class="hljs-selector-tag">previousMillis</span>;
<span class="hljs-selector-tag">uint32_t</span> <span class="hljs-selector-tag">lightMillisR</span>;
<span class="hljs-selector-tag">uint32_t</span> <span class="hljs-selector-tag">configMillis</span>;
<span class="hljs-selector-tag">uint32_t</span> <span class="hljs-selector-tag">interrupt_time</span>;
<span class="hljs-selector-tag">uint32_t</span> <span class="hljs-selector-tag">SLEEP_TIME_W</span>;
<span class="hljs-selector-tag">uint32_t</span> <span class="hljs-selector-tag">axel_time</span>;
<span class="hljs-selector-tag">int16_t</span> <span class="hljs-selector-tag">result</span>;
<span class="hljs-selector-tag">int16_t</span> <span class="hljs-selector-tag">brightness</span>;
<span class="hljs-selector-tag">int16_t</span> <span class="hljs-selector-tag">lastbrightness</span>;
<span class="hljs-selector-tag">int16_t</span> <span class="hljs-selector-tag">brightThreshold</span> = 25;
<span class="hljs-selector-tag">int16_t</span> <span class="hljs-selector-tag">myid</span>;
<span class="hljs-selector-tag">int16_t</span> <span class="hljs-selector-tag">mypar</span>;
<span class="hljs-selector-tag">int16_t</span> <span class="hljs-selector-tag">old_mypar</span> = <span class="hljs-selector-tag">-1</span>;
<span class="hljs-selector-tag">int16_t</span> <span class="hljs-selector-tag">master_id</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">Wpm</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">ODR_1Hz6_LP_ONLY</span> = 1<span class="hljs-selector-class">.6f</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">ODR_12Hz5</span> = 12<span class="hljs-selector-class">.5f</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">ODR_25Hz</span> = 25<span class="hljs-selector-class">.0f</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">ODR_50Hz</span> = 50<span class="hljs-selector-class">.0f</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">ODR_100Hz</span> = 100<span class="hljs-selector-class">.0f</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">ODR_200Hz</span> = 200<span class="hljs-selector-class">.0f</span>;
<span class="hljs-selector-tag">bool</span> <span class="hljs-selector-tag">vibro</span> = 1;
<span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">app_gpiote_user_id_t</span> <span class="hljs-selector-tag">m_gpiote_user_id</span>;
<span class="hljs-selector-tag">uint32_t</span> <span class="hljs-selector-tag">PIN_BUTTON1_MASK</span>;
<span class="hljs-selector-tag">uint32_t</span> <span class="hljs-selector-tag">AXEL_INT1_MASK</span>;
<span class="hljs-selector-tag">volatile</span> <span class="hljs-selector-tag">byte</span> <span class="hljs-selector-tag">axelInt1Status</span> = 0;
<span class="hljs-selector-tag">volatile</span> <span class="hljs-selector-tag">byte</span> <span class="hljs-selector-tag">buttInt1Status</span> = 0;
<span class="hljs-selector-tag">uint16_t</span> <span class="hljs-selector-tag">batteryVoltage</span>;
<span class="hljs-selector-tag">int16_t</span> <span class="hljs-selector-tag">linkQuality</span>;
<span class="hljs-selector-tag">int16_t</span> <span class="hljs-selector-tag">old_linkQuality</span>;
<span class="hljs-selector-tag">LIS2DW12Sensor</span> *<span class="hljs-selector-tag">lis2</span>;
<span class="hljs-selector-tag">MAX44009</span> <span class="hljs-selector-tag">light</span>;<font></font>
<font></font>
<font></font>
<font></font>
<span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">preHwInit</span>() {<font></font>
  board_Init();<font></font>
}<font></font>
<font></font>
<font></font>
<font></font>
<span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">before</span>() {<font></font>
  blinky(1, 1, GREEN_LED);<font></font>
  wait(1000);<font></font>
  nRF_Init();<font></font>
  device_Conf();<font></font>
  happy_init();<font></font>
}<font></font>
<font></font>
<font></font>
<font></font>
<span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">setup</span>() {<font></font>
  interrupt_Init();<font></font>
  sensors_Init();<font></font>
  config_Happy_node();<font></font>
}<font></font>
<font></font>
<font></font>
<font></font>
<span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">presentation</span>()<font></font>
{<font></font>
  if (!sendSketchInfo(SN, SV)) {<font></font>
    _transportSM.failedUplinkTransmissions = 0;<font></font>
    sleep(1000);<font></font>
    wait(50);<font></font>
    if (!sendSketchInfo(SN, SV)) {<font></font>
      _transportSM.failedUplinkTransmissions = 0;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-selector-tag">present</span>(<span class="hljs-selector-tag">V_SENS_CHILD_ID</span>, <span class="hljs-selector-tag">S_VIBRATION</span>, "<span class="hljs-selector-tag">STATUS</span> <span class="hljs-selector-tag">VIBRO</span>", 1);
  <span class="hljs-selector-tag">wait</span>(2500, <span class="hljs-selector-tag">C_PRESENTATION</span>, <span class="hljs-selector-tag">S_VIBRATION</span>);
  <span class="hljs-selector-tag">CORE_DEBUG</span>(<span class="hljs-selector-tag">PSTR</span>("<span class="hljs-selector-tag">MyS</span>: <span class="hljs-selector-tag">TEST</span> <span class="hljs-selector-tag">WAIT</span> <span class="hljs-selector-tag">AFTER</span> <span class="hljs-selector-tag">PRESENT</span> <span class="hljs-selector-tag">SENSOR</span>\<span class="hljs-selector-tag">n</span>"));
  <span class="hljs-selector-tag">if</span> (<span class="hljs-selector-tag">PRESENT_ACK</span> == 0) {<font></font>
    _transportSM.failedUplinkTransmissions = 0;<font></font>
    sleep(1500);<font></font>
    wait(50);<font></font>
    present(V_SENS_CHILD_ID, S_VIBRATION, "STATUS VIBRO", 1);<font></font>
    wait(2500, C_PRESENTATION, S_VIBRATION);<font></font>
    CORE_DEBUG(PSTR("<span class="hljs-attribute">MyS</span>: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string">"));
    _transportSM.failedUplinkTransmissions = 0;
  } else {
    PRESENT_ACK = 0;
  }

  present(LUX_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span>LUX<span class="hljs-string">", 1);
  wait(2500, C_PRESENTATION, S_LIGHT_LEVEL);
  CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string">"));
  if (PRESENT_ACK == 0) {
    _transportSM.failedUplinkTransmissions = 0;
    sleep(1500);
    wait(50);
    present(LUX_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span>LUX<span class="hljs-string">", 1);
    wait(2500, C_PRESENTATION, S_LIGHT_LEVEL);
    CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string">"));
    _transportSM.failedUplinkTransmissions = 0;
  } else {
    PRESENT_ACK = 0;
  }

  present(WPM_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span>W/M^<span class="hljs-number">2</span><span class="hljs-string">", 1);
  wait(2500, C_PRESENTATION, S_LIGHT_LEVEL);
  CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string">"));
  if (PRESENT_ACK == 0) {
    _transportSM.failedUplinkTransmissions = 0;
    sleep(1500);
    wait(50);
    present(WPM_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span>W/M^<span class="hljs-number">2</span><span class="hljs-string">", 1);
    wait(2500, C_PRESENTATION, S_LIGHT_LEVEL);
    CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string">"));
    _transportSM.failedUplinkTransmissions = 0;
  } else {
    PRESENT_ACK = 0;
  }

  present(SIGNAL_Q_ID, S_CUSTOM, "</span>SIGNAL QUALITY<span class="hljs-string">", 1);
  wait(2500, C_PRESENTATION, S_CUSTOM);
  CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string">"));
  if (PRESENT_ACK == 0) {
    _transportSM.failedUplinkTransmissions = 0;
    sleep(1500);
    wait(50);
    present(SIGNAL_Q_ID, S_CUSTOM, "</span>SIGNAL QUALITY<span class="hljs-string">", 1);
    wait(2500, C_PRESENTATION, S_CUSTOM);
    CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string">"));
    _transportSM.failedUplinkTransmissions = 0;
  } else {
    PRESENT_ACK = 0;
  }

  present(ENABLE_WPM_SENS_CHILD_ID, S_CUSTOM, "</span>ON|OFF WPM<span class="hljs-string">", 1);
  wait(2500, C_PRESENTATION, S_CUSTOM);
  CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string">"));
  if (PRESENT_ACK == 0) {
    _transportSM.failedUplinkTransmissions = 0;
    sleep(1500);
    wait(50);
    present(ENABLE_WPM_SENS_CHILD_ID, S_CUSTOM, "</span>ON|OFF WPM<span class="hljs-string">", 1);
    wait(2500, C_PRESENTATION, S_CUSTOM);
    CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string">"));
    _transportSM.failedUplinkTransmissions = 0;
  } else {
    PRESENT_ACK = 0;
  }

  present(LEVEL_SENSIV_V_SENS_CHILD_ID, S_CUSTOM, "</span>SENS LEVEL VIBRO<span class="hljs-string">", 1);
  wait(2500, C_PRESENTATION, S_CUSTOM);
  CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string">"));
  if (PRESENT_ACK == 0) {
    _transportSM.failedUplinkTransmissions = 0;
    sleep(1500);
    wait(50);
    present(LEVEL_SENSIV_V_SENS_CHILD_ID, S_CUSTOM, "</span>SENS LEVEL VIBRO<span class="hljs-string">", 1);
    wait(2500, C_PRESENTATION, S_CUSTOM);
    CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string">"));
    _transportSM.failedUplinkTransmissions = 0;
  } else {
    PRESENT_ACK = 0;
  }

  present(INTERVAL_R_LUX_CHILD_ID, S_CUSTOM, "</span>INTERVAL RLUX|MIN<span class="hljs-string">", 1);
  wait(2500, C_PRESENTATION, S_CUSTOM);
  CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string">"));
  if (PRESENT_ACK == 0) {
    _transportSM.failedUplinkTransmissions = 0;
    sleep(1500);
    wait(50);
    present(INTERVAL_R_LUX_CHILD_ID, S_CUSTOM, "</span>INTERVAL RLUX|MIN<span class="hljs-string">", 1);
    wait(2500, C_PRESENTATION, S_CUSTOM);
    CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string">"));
    _transportSM.failedUplinkTransmissions = 0;
  } else {
    PRESENT_ACK = 0;
  }

  send(conf_wpmMsg.set(wpm_enable), 1);
  wait(2500, C_SET, V_VAR1);
  CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string">"));
  if (Ack_TL == 0) {
    _transportSM.failedUplinkTransmissions = 0;
    sleep(1500);
    wait(50);
    send(conf_wpmMsg.set(wpm_enable), 1);
    wait(2500, C_SET, V_VAR1);
    CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string">"));
    _transportSM.failedUplinkTransmissions = 0;
  } else {
    Ack_TL = 0;
  }

  send(conf_vsensMsg.set(conf_vibro_set), 1);
  wait(2500, C_SET, V_VAR1);
  CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string">"));
  if (Ack_TL == 0) {
    _transportSM.failedUplinkTransmissions = 0;
    sleep(1500);
    wait(50);
    send(conf_vsensMsg.set(conf_vibro_set), 1);
    wait(2500, C_SET, V_VAR1);
    CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string">"));
    _transportSM.failedUplinkTransmissions = 0;
  } else {
    Ack_TL = 0;
  }

  send(conf_interv_rluxMsg.set(interval_reading_lux), 1);
  wait(2500, C_SET, V_VAR1);
  CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string">"));
  if (Ack_TL == 0) {
    _transportSM.failedUplinkTransmissions = 0;
    sleep(1500);
    wait(50);
    send(conf_interv_rluxMsg.set(interval_reading_lux), 1);
    wait(2500, C_SET, V_VAR1);
    CORE_DEBUG(PSTR("</span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string">"));
    _transportSM.failedUplinkTransmissions = 0;
  } else {
    Ack_TL = 0;
  }
}



void loop()
{
  if (flag_update_transport_param == 1) {
    update_Happy_transport();
  }
  if (flag_sendRoute_parent == 1) {
    present_only_parent();
  }

  if (isTransportReady() == true) {
    if (flag_nogateway_mode == 0) {
      if (flag_find_parent_process == 1) {
        find_parent_process();
      }
      if (configMode == 0) {
        if ((axelInt1Status == AXEL_INT1) || (buttInt1Status == PIN_BUTTON1)) {
          if (axelInt1Status == AXEL_INT1) {
            nosleep = 1;
            send_Axel();
            axelInt1Status = 0;
            newmillis = millis();
            interrupt_time = newmillis - oldmillis;
            SLEEP_TIME_W = SLEEP_TIME_W - interrupt_time;
            if (SLEEP_TIME_W &lt; 5000) {
              SLEEP_TIME_W = SLEEP_TIME;
              send_Brigh(1);
              countbatt++;
              if (countbatt == C_BATT_TIME) {
                sendBatteryStatus(1);
                countbatt = 0;
              }
            }
            nosleep = 0;
          }
          if (buttInt1Status == PIN_BUTTON1) {
            if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 0) {
              button_flag = 1;
              nosleep = 1;
              previousMillis = millis();
              ledsOff();
            }
            if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 1) {
              if ((millis() - previousMillis &gt; 0) &amp;&amp; (millis() - previousMillis &lt;= 1750)) {
                if (millis() - lightMillisR &gt; 25) {
                  lightMillisR = millis();
                  onoff = !onoff;
                  digitalWrite(GREEN_LED, onoff);
                }
              }
              if ((millis() - previousMillis &gt; 1750) &amp;&amp; (millis() - previousMillis &lt;= 2000)) {
                ledsOff();
              }
              if ((millis() - previousMillis &gt; 2000) &amp;&amp; (millis() - previousMillis &lt;= 4000)) {
                if (millis() - lightMillisR &gt; 25) {
                  lightMillisR = millis();
                  onoff = !onoff;
                  digitalWrite(BLUE_LED, onoff);
                }
              }
              if ((millis() - previousMillis &gt; 4000) &amp;&amp; (millis() - previousMillis &lt;= 4250)) {
                ledsOff();
              }
              if ((millis() - previousMillis &gt; 4250) &amp;&amp; (millis() - previousMillis &lt;= 6250)) {
                if (millis() - lightMillisR &gt; 25)    {
                  lightMillisR = millis();
                  onoff = !onoff;
                  digitalWrite(RED_LED, onoff);
                }
              }
              if ((millis() - previousMillis &gt; 6250) &amp;&amp; (millis() - previousMillis &lt;= 6500)) {
                ledsOff();
              }
              if ((millis() - previousMillis &gt; 6500) &amp;&amp; (millis() - previousMillis &lt;= 8500)) {
                if (millis() - lightMillisR &gt; 50)    {
                  lightMillisR = millis();
                  onoff = !onoff;
                  digitalWrite(RED_LED, onoff);
                }
              }
              if (millis() - previousMillis &gt; 8500) {
                ledsOff();
              }
            }
            if (digitalRead(PIN_BUTTON1) == 1 &amp;&amp; button_flag == 1) {
              if (millis() - previousMillis &lt;= 2000)
              {
                ledsOff();
                send_Brigh(0);
                nosleep = 0;
                button_flag = 0;
                buttInt1Status = 0;
              }
              if ((millis() - previousMillis &gt; 2000) &amp;&amp; (millis() - previousMillis &lt;= 4000))
              {
                ledsOff();
                configMode = 1;
                button_flag = 0;
                configMillis = millis();
              }
              if ((millis() - previousMillis &gt; 4250) &amp;&amp; (millis() - previousMillis &lt;= 6250))
              {
                ledsOff();
                blinky(2, 2, RED_LED);
                button_flag = 0;
                buttInt1Status = 0;
                presentation();
                nosleep = 0;
              }
              if ((millis() - previousMillis &gt; 6500) &amp;&amp; (millis() - previousMillis &lt;= 8500))
              {
                ledsOff();
                blinky(3, 3, RED_LED);
                new_device();
              }
              if (((millis() - previousMillis &gt; 1750) &amp;&amp; (millis() - previousMillis &lt;= 2000)) || ((millis() - previousMillis &gt; 4000) &amp;&amp; (millis() - previousMillis &lt;= 4250)) || ((millis() - previousMillis &gt; 6250) &amp;&amp; (millis() - previousMillis &lt;= 6500)) || ((millis() - previousMillis &gt; 8500)))
              {
                ledsOff();
                blinky(1, 2, GREEN_LED);
                nosleep = 0;
                button_flag = 0;
                buttInt1Status = 0;
              }
            }
          }
        } else {
          SLEEP_TIME_W = SLEEP_TIME;
          send_Brigh(1);
          countbatt++;
          if (countbatt == C_BATT_TIME) {
            sendBatteryStatus(1);
            countbatt = 0;
          }
          nosleep = 0;
        }
      } else {
        if (millis() - configMillis &gt; 30000) {
          blinky(3, 3, GREEN_LED);
          configMode = 0;
          nosleep = 0;
          button_flag = 0;
          buttInt1Status = 0;
        }
      }
    } else {
      if (buttInt1Status == PIN_BUTTON1) {

        if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 0) {
          button_flag = 1;
          nosleep = 1;
          previousMillis = millis();
          ledsOff();
        }

        if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 1) {
          if ((millis() - previousMillis &gt; 0) &amp;&amp; (millis() - previousMillis &lt;= 500))
          {
            ledsOff();
          }
          if ((millis() - previousMillis &gt; 500) &amp;&amp; (millis() - previousMillis &lt;= 2500))
          {
            lightMillisR = millis();
            onoff = !onoff;
            digitalWrite(BLUE_LED, onoff);
          }
          if ((millis() - previousMillis &gt; 2500) &amp;&amp; (millis() - previousMillis &lt;= 2750))
          {
            ledsOff();
          }
          if ((millis() - previousMillis &gt; 2750) &amp;&amp; (millis() - previousMillis &lt;= 4750)) {
            if (millis() - lightMillisR &gt; 50) {
              lightMillisR = millis();
              onoff = !onoff;
              digitalWrite(RED_LED, onoff);
            }
          }

          if (millis() - previousMillis &gt; 4750) {
            ledsOff();
            blinky(3, 1, GREEN_LED);
            button_flag = 0;
            nosleep = 0;
            buttInt1Status = 0;
          }
        }

        if (digitalRead(PIN_BUTTON1) == 1 &amp;&amp; button_flag == 1) {
          if (millis() - previousMillis &lt;= 500)
          {
            ledsOff();
            button_flag = 0;
            nosleep = 0;
            buttInt1Status = 0;
          }
          if ((millis() - previousMillis &gt; 500) &amp;&amp; (millis() - previousMillis &lt;= 2500))
          {
           ledsOff();
            blinky(1, 1, BLUE_LED);
            check_parent();
            button_flag = 0;
            nosleep = 0;
            buttInt1Status = 0; 
          }

          if ((millis() - previousMillis &gt; 2500) &amp;&amp; (millis() - previousMillis &lt;= 2750))
          {
           ledsOff();
            button_flag = 0;
            nosleep = 0;
            buttInt1Status = 0; 
          }

          if ((millis() - previousMillis &gt; 2750) &amp;&amp; (millis() - previousMillis &lt;= 4750))
          {
            ledsOff();
            blinky(3, 3, RED_LED);
            new_device();
          }

          if (millis() - previousMillis &gt; 4750)
          {
            ledsOff();
            button_flag = 0;
            nosleep = 0;
            buttInt1Status = 0;
          }
        }
      } else {
        check_parent();
      }
    }
  }

  if (_transportSM.failureCounter &gt; 0)
  {
    _transportConfig.parentNodeId = loadState(101);
    _transportConfig.nodeId = myid;
    _transportConfig.distanceGW = loadState(103);
    mypar = _transportConfig.parentNodeId;
    nosleep = 0;
    flag_fcount = 1;
    err_delivery_beat = 5;
    happy_node_mode();
    gateway_fail();
  }

  if (configMode == 0) {
    if (nosleep == 0) {
      oldmillis = millis();
      axelInt1Status = 0;
      buttInt1Status = 0;
      wait(100);
      sleep(SLEEP_TIME_W, false);
      wait(50);
      nosleep = 1;
    }
  }
}



float GetWpm()
{
  float SunLuxCoef = 0.0079;
  float Wpm_temp = 0;
  Wpm_temp = (float)brightness;
  Wpm_temp *= SunLuxCoef;
  return Wpm_temp;
}



void blinky(uint8_t pulses, uint8_t repit, uint8_t ledColor) {
  for (int x = 0; x &lt; repit; x++) {
    if (x &gt; 0) {
      sleep(300);
    }
    for (int i = 0; i &lt; pulses; i++) {
      if (i &gt; 0) {
        sleep(80);
      }
      digitalWrite(ledColor, LOW);
      sleep(20);
      digitalWrite(ledColor, HIGH);
    }
  }
}



void ledsOff() {
  digitalWrite(RED_LED, HIGH);
  digitalWrite(GREEN_LED, HIGH);
  digitalWrite(BLUE_LED, HIGH);
}



void nRF_Init() {
  NRF_POWER-&gt;DCDCEN = 1;
  NRF_NFCT-&gt;TASKS_DISABLE = 1;
  NRF_NVMC-&gt;CONFIG = 1;
  NRF_UICR-&gt;NFCPINS = 0;
  NRF_NVMC-&gt;CONFIG = 0;
  NRF_SAADC -&gt;ENABLE = 0;
  NRF_PWM0  -&gt;ENABLE = 0;
  NRF_PWM1  -&gt;ENABLE = 0;
  NRF_PWM2  -&gt;ENABLE = 0;
  NRF_TWIM1 -&gt;ENABLE = 0;
  NRF_TWIS1 -&gt;ENABLE = 0;
  NRF_RADIO-&gt;TXPOWER = 8;
}



void sensors_Init() {
  Wire.begin();
  wait(100);
  light.begin();
  wait(100);
  lis2 = new LIS2DW12Sensor (&amp;Wire);
  vibro_Init();
  if (isTransportReady() == true) {
    blinky(3, 1, BLUE_LED);
    wait(200);
    blinky(3, 1, GREEN_LED);
    wait(200);
    blinky(3, 1, RED_LED);
    SLEEP_TIME_W = SLEEP_TIME;
    send_Brigh(0);
    wait(50);
    sendBatteryStatus(0);
    axel_time = millis();
  } else {
    blinky(5, 3, RED_LED);
  }
}



void vibro_Init() {
  if (conf_vibro_set == 1) {
    lis2-&gt;ODRTEMP = ODR_1Hz6_LP_ONLY;
  }
  if (conf_vibro_set == 2) {
    lis2-&gt;ODRTEMP = ODR_12Hz5;
  }
  if (conf_vibro_set == 3) {
    lis2-&gt;ODRTEMP = ODR_25Hz;
  }
  if (conf_vibro_set == 4) {
    lis2-&gt;ODRTEMP = ODR_100Hz;
  }
  if (conf_vibro_set == 5) {
    lis2-&gt;ODRTEMP = ODR_200Hz;
  }
  lis2-&gt;Enable_X();
  wait(50);
  lis2-&gt;Enable_Wake_Up_Detection();
  wait(50);
}



void board_Init() {
  pinMode(PIN_BUTTON1, INPUT);
  pinMode(AXEL_INT1, INPUT);
  pinMode(AXEL_INT2, INPUT);
  pinMode(AMBI_INT, INPUT);
  pinMode(RED_LED, OUTPUT);
  pinMode(GREEN_LED, OUTPUT);
  pinMode(BLUE_LED, OUTPUT);
  ledsOff();
}



void send_Axel() {
  if (millis() - axel_time &gt;= 5000) {
    blinky(6, 1, RED_LED);
    lis2-&gt;Disable_Wake_Up_Detection();
    wait(100);
    if (_transportConfig.parentNodeId == 0) {
      if (send(vibroMsg.set(vibro))) {
        wait(100);
        err_delivery_beat = 0;
        if (flag_nogateway_mode == 1) {
          flag_nogateway_mode = 0;
          CORE_DEBUG(PSTR("</span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string">"));
          err_delivery_beat = 0;
        }
      } else {
        _transportSM.failedUplinkTransmissions = 0;
        if (err_delivery_beat &lt; 5) {
          err_delivery_beat++;
        }
        if (err_delivery_beat == 4) {
          if (flag_nogateway_mode == 0) {
            gateway_fail();
            CORE_DEBUG(PSTR("</span>MyS: LOST GATEWAY MODE\n<span class="hljs-string">"));
          }
        }
      }
      lis2-&gt;Enable_Wake_Up_Detection();
      wait(100);
      axel_time = millis();
      nosleep = 0;
    }
    if (_transportConfig.parentNodeId &gt; 0) {
      send(vibroMsg.set(vibro), 1);
      wait(2500, C_SET, V_TRIPPED);
      if (Ack_TL == 1) {
        Ack_TL = 0;
        err_delivery_beat = 0;
        //sleep_flag = 0;
        if (flag_nogateway_mode == 1) {
          flag_nogateway_mode = 0;
          CORE_DEBUG(PSTR("</span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string">"));
          err_delivery_beat = 0;
        }
      } else {
        _transportSM.failedUplinkTransmissions = 0;
        if (err_delivery_beat &lt; 5) {
          err_delivery_beat++;
        }
        if (err_delivery_beat == 4) {
          if (flag_nogateway_mode == 0) {
            gateway_fail();
            CORE_DEBUG(PSTR("</span>MyS: LOST GATEWAY MODE\n<span class="hljs-string">"));
          }
        }
      }
      lis2-&gt;Enable_Wake_Up_Detection();
      wait(100);
      axel_time = millis();
      nosleep = 0;
    }
  } else {
    nosleep = 0;
  }
}



void send_Brigh(bool start) {
  brightness = light.get_lux() * 2;
  wait(50);
  if (start == 1) {
    if (abs(brightness - lastbrightness) &gt;= brightThreshold) {
      if (_transportConfig.parentNodeId == 0) {
        if (send(brightMsg.set(brightness, 0))) {
          err_delivery_beat = 0;
          if (flag_nogateway_mode == 1) {
            flag_nogateway_mode = 0;
            CORE_DEBUG(PSTR("</span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string">"));
            err_delivery_beat = 0;
          }
          lastbrightness = brightness;
          if (wpm_enable == 1) {
            Wpm = GetWpm();
            wait(100);
            send(wpmMsg.set(Wpm, 0));
          }
          wait(50);
          blinky(2, 2, BLUE_LED);
        } else {
          _transportSM.failedUplinkTransmissions = 0;
          if (err_delivery_beat &lt; 5) {
            err_delivery_beat++;
          }
          if (err_delivery_beat == 4) {
            if (flag_nogateway_mode == 0) {
              gateway_fail();
              CORE_DEBUG(PSTR("</span>MyS: LOST GATEWAY MODE\n<span class="hljs-string">"));
            }
          }
        }
      }
      if (_transportConfig.parentNodeId &gt; 0) {
        send(brightMsg.set(brightness, 0), 1);
        wait(2500, C_SET, V_LEVEL);
        if (Ack_TL == 1) {
          Ack_TL = 0;
          err_delivery_beat = 0;
          if (flag_nogateway_mode == 1) {
            flag_nogateway_mode = 0;
            CORE_DEBUG(PSTR("</span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string">"));
            err_delivery_beat = 0;
          }
          lastbrightness = brightness;
          if (wpm_enable == 1) {
            Wpm = GetWpm();
            wait(100);
            send(wpmMsg.set(Wpm, 0));
          }
          wait(50);
          blinky(2, 2, BLUE_LED);
        } else {
          _transportSM.failedUplinkTransmissions = 0;
          if (err_delivery_beat &lt; 5) {
            err_delivery_beat++;
          }
          if (err_delivery_beat == 4) {
            if (flag_nogateway_mode == 0) {
              gateway_fail();
              CORE_DEBUG(PSTR("</span>MyS: LOST GATEWAY MODE\n<span class="hljs-string">"));
            }
          }
        }
      }
    }
  } else {
    send(brightMsg.set(brightness, 0));
    lastbrightness = brightness;
    if (wpm_enable == 1) {
      Wpm = GetWpm();
      wait(100);
      send(wpmMsg.set(Wpm, 0));
    }
    wait(50);
    blinky(2, 2, BLUE_LED);
  }
}



void interrupt_Init() {
  //***
  //SET
  //NRF_GPIO_PIN_NOPULL
  //NRF_GPIO_PIN_PULLUP
  //NRF_GPIO_PIN_PULLDOWN
  //***
  nrf_gpio_cfg_input(PIN_BUTTON1, NRF_GPIO_PIN_PULLUP);
  nrf_gpio_cfg_input(AXEL_INT1, NRF_GPIO_PIN_NOPULL);
  APP_GPIOTE_INIT(APP_GPIOTE_MAX_USERS);
  PIN_BUTTON1_MASK = 1 &lt;&lt; PIN_BUTTON1;
  AXEL_INT1_MASK = 1 &lt;&lt; AXEL_INT1;
  //  app_gpiote_user_register(p_user_id, pins_low_to_high_mask, pins_high_to_low_mask, event_handler)
  app_gpiote_user_register(&amp;m_gpiote_user_id, AXEL_INT1_MASK, PIN_BUTTON1_MASK, gpiote_event_handler);
  app_gpiote_user_enable(m_gpiote_user_id);
  axelInt1Status = 0;
  buttInt1Status = 0;
}



void gpiote_event_handler(uint32_t event_pins_low_to_high, uint32_t event_pins_high_to_low)
{
  MY_HW_RTC-&gt;CC[0] = (MY_HW_RTC-&gt;COUNTER + 2);

  if (PIN_BUTTON1_MASK &amp; event_pins_high_to_low) {
    if ((buttInt1Status == 0) &amp;&amp; (axelInt1Status == 0)) {
      buttInt1Status = PIN_BUTTON1;
    }
  }
  if (flag_nogateway_mode == 0) {
    if (configMode == 0) {
      if (AXEL_INT1_MASK &amp; event_pins_low_to_high) {
        if ((axelInt1Status == 0) &amp;&amp; (buttInt1Status == 0)) {
          axelInt1Status = AXEL_INT1;
        }
      }
    }
  }

  /***
    if ((PIN_BUTTON_MASK &amp; event_pins_low_to_high) || (PIN_BUTTON1_MASK &amp; event_pins_high_to_low))
  ***/
}



void device_Conf() {
  conf_vibro_set = loadState(230);
  if ((conf_vibro_set &gt; 5) || (conf_vibro_set == 0)) {
    conf_vibro_set = 1;
    saveState(230, conf_vibro_set);
  }

  wpm_enable = loadState(240);
  if (wpm_enable &gt; 1) {
    wpm_enable = 0;
    saveState(240, wpm_enable);
  }

  interval_reading_lux  = loadState(220);
  if (interval_reading_lux &gt; 60) {
    interval_reading_lux = 60;
    saveState(230, interval_reading_lux);
  } else if (interval_reading_lux &lt; 1) {
    interval_reading_lux = 1;
    saveState(230, interval_reading_lux);
  }

  SLEEP_TIME = SLEEP_TIME_TEMP * interval_reading_lux;
  C_BATT_TIME = BATT_TIME / SLEEP_TIME;
}



void sendBatteryStatus(bool start) {
  sleep(5000);
  wait(200);
  batteryVoltage = hwCPUVoltage();
  wait(10);
  batt_cap = battery_level_in_percent(batteryVoltage);
  if (start == 1) {
    if (batt_cap &lt; old_batt_cap) {
      sendBatteryLevel(battery_level_in_percent(batteryVoltage), 1);
      wait(2500, C_INTERNAL, I_BATTERY_LEVEL);
      old_batt_cap = batt_cap;
    }
  } else {
    sendBatteryLevel(battery_level_in_percent(batteryVoltage), 1);
    wait(2500, C_INTERNAL, I_BATTERY_LEVEL);
  }

  linkQuality = calculationRxQuality();
  if (linkQuality != old_linkQuality) {
    wait(10);
    sendSignalStrength(linkQuality);
    wait(50);
    old_linkQuality = linkQuality;
  }
}



bool sendSignalStrength(const int16_t level, const bool ack)
{
  return _sendRoute(build(_msgTmp, GATEWAY_ADDRESS, SIGNAL_Q_ID, C_SET, V_VAR1,
                          ack).set(level));
}
int16_t calculationRxQuality() {
  int16_t nRFRSSI_temp = transportGetReceivingRSSI();
  int16_t nRFRSSI = map(nRFRSSI_temp, -85, -40, 0, 100);
  if (nRFRSSI &lt; 0) {
    nRFRSSI = 0;
  }
  if (nRFRSSI &gt; 100) {
    nRFRSSI = 100;
  }
  return nRFRSSI;
}



void happy_init() {
  //hwWriteConfig(EEPROM_NODE_ID_ADDRESS, 255); // ******************** checking the node config reset *************************

  if (hwReadConfig(EEPROM_NODE_ID_ADDRESS) == 0) {
    hwWriteConfig(EEPROM_NODE_ID_ADDRESS, 255);
  }
  if (loadState(100) == 0) {
    saveState(100, 255);
  }
  CORE_DEBUG(PSTR("</span>EEPROM NODE ID: %d\n<span class="hljs-string">"), hwReadConfig(EEPROM_NODE_ID_ADDRESS));
  CORE_DEBUG(PSTR("</span>USER MEMORY SECTOR NODE ID: %d\n<span class="hljs-string">"), loadState(100));

  if (hwReadConfig(EEPROM_NODE_ID_ADDRESS) == 255) {
    mtwr = 0;
  } else {
    mtwr = 10000;
    no_present();
  }
  CORE_DEBUG(PSTR("</span>MY_TRANSPORT_WAIT_MS: %d\n<span class="hljs-string">"), mtwr);

}



void new_device() {
  hwWriteConfig(EEPROM_NODE_ID_ADDRESS, 255);
  saveState(100, 255);
  wdt_enable(WDTO_15MS);
}



void config_Happy_node() {
  if (mtwr == 0) {
    myid = getNodeId();
    saveState(100, myid);
    mypar = _transportConfig.parentNodeId;
    old_mypar = mypar;
    master_id = 0; // *************************** master slave mode is not initialized in this example, ..stub *******************************
    saveState(101, mypar);
    saveState(102, _transportConfig.distanceGW);
  }
  if (mtwr != 0) {
    myid = getNodeId();
    if (myid != loadState(100)) {
      saveState(100, myid);
    }
    if (isTransportReady() == true) {
      mypar = _transportConfig.parentNodeId;
      master_id = 0; // *************************** master slave mode is not initialized in this example, ..stub *******************************
      if (mypar != loadState(101)) {
        saveState(101, mypar);
      }
      if (_transportConfig.distanceGW != loadState(102)) {
        saveState(102, _transportConfig.distanceGW);
      }
      present_only_parent();
    }
    if (isTransportReady() == false)
    {
      no_present();
      flag_fcount = 1;
      err_delivery_beat = 5;
      _transportConfig.nodeId = myid;
      _transportConfig.parentNodeId = loadState(101);
      _transportConfig.distanceGW = loadState(102);
      mypar = _transportConfig.parentNodeId;
      happy_node_mode();
      gateway_fail();
    }
  }
}



void no_present() {
  _coreConfig.presentationSent = true;
  _coreConfig.nodeRegistered = true;
}



void happy_node_mode() {
  _transportSM.findingParentNode = false;
  _transportSM.transportActive = true;
  _transportSM.uplinkOk = true;
  _transportSM.pingActive = false;
  transportSwitchSM(stReady);
  _transportSM.failureCounter = 0;
}



void gateway_fail() {
  flag_nogateway_mode = 1;
  flag_update_transport_param = 0;
  SLEEP_TIME_W = SLEEP_TIME / 2;
  lis2-&gt;Disable_Wake_Up_Detection();
}



void find_parent_process() {
  flag_update_transport_param = 1;
  flag_find_parent_process = 0;
  CORE_DEBUG(PSTR("</span>MyS: STANDART TRANSPORT MODE IS RESTORED\n<span class="hljs-string">"));
  err_delivery_beat = 0;
  lis2-&gt;Enable_Wake_Up_Detection();
}



void update_Happy_transport() {
  CORE_DEBUG(PSTR("</span>MyS: UPDATE TRANSPORT CONFIGURATION\n<span class="hljs-string">"));
  mypar = _transportConfig.parentNodeId;
  master_id = 0; // *************************** master slave mode is not initialized in this example, ..stub *******************************
  if (mypar != loadState(101))
  {
    saveState(101, mypar);
  }
  if (_transportConfig.distanceGW != loadState(102))
  {
    saveState(102, _transportConfig.distanceGW);
  }
  present_only_parent();
  wait(50);
  nosleep = 0;
  flag_update_transport_param = 0;
}



void present_only_parent() {
  if (old_mypar != mypar) {
    CORE_DEBUG(PSTR("</span>MyS: SEND LITTLE PRESENT:) WITH PARENT ID\n<span class="hljs-string">"));
    if (_sendRoute(build(_msgTmp, 0, NODE_SENSOR_ID, C_INTERNAL, 6).set(mypar))) {
      flag_sendRoute_parent = 0;
      old_mypar = mypar;
    } else {
      flag_sendRoute_parent = 1;
    }
  }
}



void check_parent() {
  _transportSM.findingParentNode = true;
  CORE_DEBUG(PSTR("</span>MyS: SEND FIND PARENT REQUEST, WAIT RESPONSE\n<span class="hljs-string">"));
  _sendRoute(build(_msg, 255, NODE_SENSOR_ID, C_INTERNAL, 7).set("</span><span class="hljs-string">"));
  wait(1500, C_INTERNAL, 8);
  if (_msg.sensor == 255) {
    if (mGetCommand(_msg) == 3) {
      if (_msg.type == 8) {
        Ack_FP = 1;
        CORE_DEBUG(PSTR("</span>MyS: PARENT RESPONSE FOUND\n<span class="hljs-string">"));
      }
    }
  }
  if (Ack_FP == 1) {
    CORE_DEBUG(PSTR("</span>MyS: FIND PARENT PROCESS\n<span class="hljs-string">"));
    Ack_FP = 0;
    transportSwitchSM(stParent);
    flag_nogateway_mode = 0;
    flag_find_parent_process = 1;
    SLEEP_TIME_W = SLEEP_TIME;
    problem_mode_count = 0;
  } else {
    _transportSM.findingParentNode = false;
    CORE_DEBUG(PSTR("</span>MyS: PARENT RESPONSE NOT FOUND\n<span class="hljs-string">"));
    _transportSM.failedUplinkTransmissions = 0;
    nosleep = 0;
    if (problem_mode_count &lt; 24) {
      CORE_DEBUG(PSTR("</span>PROBLEM MODE COUNTER: %d\n<span class="hljs-string">"), problem_mode_count);
      problem_mode_count++;
      SLEEP_TIME_W = SLEEP_TIME / 100 * 120;
    } else if (problem_mode_count == 24) {
      SLEEP_TIME_W = SLEEP_TIME * 30;
      CORE_DEBUG(PSTR("</span>PROBLEM MODE COUNTER: %d\n<span class="hljs-string">"), problem_mode_count);
    }
  }
}



void receive(const MyMessage &amp; message)
{
  if (message.sensor == ENABLE_WPM_SENS_CHILD_ID) {
    if (message.type == V_VAR1) {
      if (mGetCommand(message) == C_SET) {
        if (message.isEcho()) {
          Ack_TL = 1;
        } else {
          wpm_enable = message.getBool();
          saveState(240, wpm_enable);
          wait(10);
          send(conf_wpmMsg.set(wpm_enable));
          wait(50);
          blinky(3, 3, GREEN_LED);
          configMode = 0;
          nosleep = 0;
          button_flag = 0;
          buttInt1Status = 0;
        }
      }
    }
  }

  if (message.sensor == LEVEL_SENSIV_V_SENS_CHILD_ID) {
    if (message.type == V_VAR1) {
      if (mGetCommand(message) == C_SET) {
        if (message.isEcho()) {
          Ack_TL = 1;
        } else {
          conf_vibro_set = message.getByte();
          vibro_Init();
          saveState(230, conf_vibro_set);
          wait(10);
          send(conf_vsensMsg.set(conf_vibro_set));
          wait(50);
          blinky(3, 3, GREEN_LED);
          configMode = 0;
          nosleep = 0;
          button_flag = 0;
          buttInt1Status = 0;
        }
      }
    }
  }

  if (message.sensor == INTERVAL_R_LUX_CHILD_ID) {
    if (message.type == V_VAR1) {
      if (mGetCommand(message) == C_SET) {
        if (message.isEcho()) {
          Ack_TL = 1;
        } else {
          interval_reading_lux = message.getByte();
          SLEEP_TIME = SLEEP_TIME_TEMP * interval_reading_lux;
          C_BATT_TIME = BATT_TIME / SLEEP_TIME;
          saveState(220, interval_reading_lux);
          wait(10);
          send(conf_interv_rluxMsg.set(interval_reading_lux));
          wait(50);
          blinky(3, 3, GREEN_LED);
          configMode = 0;
          nosleep = 0;
          button_flag = 0;
          buttInt1Status = 0;
        }
      }
    }
  }

  if (message.sensor == LUX_SENS_CHILD_ID) {
    if (message.type == V_LEVEL) {
      if (mGetCommand(message) == C_SET) {
        if (message.isEcho()) {
          Ack_TL = 1;
        }
      }
    }
  }

  if (message.sensor == V_SENS_CHILD_ID) {
    if (message.type == V_TRIPPED) {
      if (mGetCommand(message) == C_SET) {
        if (message.isEcho()) {
          Ack_TL = 1;
        }
      }
    }
  }

  if (mGetCommand(message) == 0) {
    PRESENT_ACK = 1;
    CORE_DEBUG(PSTR("</span>MyS: !!!ACK OF THE PRESENTATION IN THE FUNCTION RECEIVE RECEIVED!!!\n<span class="hljs-string">"));
  }
}
</span></code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトgithub（追加のライブラリ、プロジェクトソース、スキーム、ガーベラ、BOM）：</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/smartboxchannel/EFEKTA-LIS2DW12-MAX44009-E73C </font></font></a><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">センサーの特性：</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動作電圧範囲2-3 V、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スリープモードで6.7μA、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワークモードで8mA、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E73-2G​​4M08S1C nRF52840、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MAX44009周囲光センサー、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LIS2DW12 \ LIS2DH12 3軸MEMS加速度計、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB LED</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーボタン、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラミングポートSWD +シリアル。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Majordomo UDシステムでのセンサー操作の例を以下に示します。これは、MySensorsプロトコルのサポートが追加されたすべてのUDで自然に機能します。これはほとんどすべてのことがわかっています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bm/xj/zj/bmxjzjfpzn0wuvccte-w5xqtn3e.png"><br>
<br>
<img src="https://habrastorage.org/webt/5t/9k/xr/5t9kxrdt4agswilm1yukte51m4g.jpeg"><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボードの内部のビデオ、センサーの例、設定の例</font></font></b><div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/I2ywIxp-RsE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">センサー写真</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/wc/xl/hk/wcxlhkb-zb-paorsmpqx4jwkg-4.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/mh/f-/ak/mhf-akawv5xgbnuijpdv0edgcoo.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/ie/1q/ig/ie1qign_51mb0ya5ysfiurmdgkm.jpeg"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらくこれで四捨五入します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MYSENSORS（ボードのインストール、Arduino IDE環境でのnRF5マイクロコントローラーの操作、mysensorsプロトコルの使用に関するヒント、プロジェクトについての議論-テレグラムチャット</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@mysensors_rus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトでの</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸運と幸運を祈ります！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PS /シェアすぐに計画があり</font><font style="vertical-align: inherit;">、電子インクスクリーンを備えた私の温度と湿度センサーの</font><font style="vertical-align: inherit;">更新された</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドラフト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に関する記事がまもなく公開され</font><font style="vertical-align: inherit;">ます。最後に、モジュールではなく完成したデバイスになりました。リードスイッチ、加速度計、磁場センサーとエンコーダーを備えた開閉センサーに関する記事もあります。 nRF52811の写真とスポイラーのビデオ。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネタバレ</font></font></b><div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/T66y83lF-xg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<img src="https://habrastorage.org/webt/rg/dh/u2/rgdhu2htxcazyavpoh5mgf71hfo.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/uz/mx/_n/uzmx_nvuyazh3nihtfjxgb_tkpi.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/xn/7s/a2/xn7sa2lbrn3g2jvje5mr1wbcuh8.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/4y/-s/la/4y-slajjmwr_ydmqdq0v2vcify4.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/90/ub/i7/90ubi72wfku6mlf7dshkfl2nqfo.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/p9/fe/9e/p9fe9ehr29jqggmkhutdipmqygu.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/sn/gm/ou/sngmou0381zr6ias3gbtsfez3lg.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/o5/t2/j-/o5t2j-gncldts6gsxg7kxl26dce.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/jt/vl/ro/jtvlrov-l3qclnkgilhu7aqpls4.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/be/3v/je/be3vjejo_xhuxhpc_hyg9fmz4ns.jpeg"><br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja478950/index.html">今週の結果：Huaweiが制裁に適応し、プーチン大統領がセンセーショナルな法律に署名し、ロシアでShutterStockがブロックされました</a></li>
<li><a href="../ja478952/index.html">Onyx Boox Note Proで1か月</a></li>
<li><a href="../ja478954/index.html">RE：ITに対する恐れと嫌悪</a></li>
<li><a href="../ja478956/index.html">Android用Chrome VoIPクライアントとビデオアプリケーションを備えた3CX V16 Update 4ベータ版の紹介</a></li>
<li><a href="../ja478958/index.html">あらゆる規模の企業向けの完全なWindows 10アップグレードガイド</a></li>
<li><a href="../ja478962/index.html">Ilya Yakyamsev：効率が上がらない</a></li>
<li><a href="../ja478966/index.html">現代の世界で生き残り、フロントエンドの開発者になるには？</a></li>
<li><a href="../ja478968/index.html">SpaceXがNanorackを発表して宇宙デブリ軌道ステーションを作成</a></li>
<li><a href="../ja478970/index.html">DIY通話ボタンパート2. Raspberry Piのテレビ電話</a></li>
<li><a href="../ja478972/index.html">Miroプラットフォームコンテストの勝者</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>