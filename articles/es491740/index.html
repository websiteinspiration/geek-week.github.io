<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§úüèª ü§¢ ü•° Internet de las cosas en Yandex.Cloud: c√≥mo se organizan los servicios Yandex IoT Core y Yandex Cloud Functions ‚ú¥Ô∏è üë®üèΩ‚Äç‚úàÔ∏è üóÇÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En octubre del a√±o pasado, se celebr√≥ la primera conferencia en la nube Yandex Yandex Scale. Anunci√≥ el lanzamiento de muchos servicios nuevos, inclui...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Internet de las cosas en Yandex.Cloud: c√≥mo se organizan los servicios Yandex IoT Core y Yandex Cloud Functions</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/491740/"><img src="https://habrastorage.org/webt/wf/_u/zo/wf_uzobkj9vxp2ddkzxzux7lhbo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En octubre del a√±o pasado, se celebr√≥ la primera conferencia en la nube Yandex Yandex Scale. Anunci√≥ el lanzamiento de muchos servicios nuevos, incluido Yandex IoT Core, que le permite intercambiar datos con millones de dispositivos IoT. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este art√≠culo, hablar√© sobre por qu√© se necesita Yandex IoT Core y c√≥mo funciona, as√≠ como tambi√©n c√≥mo puede interactuar con otros servicios de Yandex.Cloud. Aprender√° sobre la arquitectura, las complejidades de la interacci√≥n de los componentes y las caracter√≠sticas de la implementaci√≥n de la funcionalidad; todo esto lo ayudar√° a optimizar el uso de estos servicios.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, recordemos las principales ventajas de las nubes p√∫blicas y PaaS: reducir el tiempo y los costos de desarrollo, as√≠ como los costos de soporte e infraestructura, que tambi√©n son relevantes para los proyectos de IoT. Pero hay algunas caracter√≠sticas √∫tiles menos obvias que puede obtener en la nube. Esta escala efectiva y tolerancia a fallas son aspectos importantes cuando se trabaja con dispositivos, especialmente en proyectos para infraestructura de informaci√≥n cr√≠tica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El escalado efectivo es la capacidad de aumentar o disminuir libremente el n√∫mero de dispositivos sin experimentar problemas t√©cnicos y ver un cambio predecible en el costo del sistema despu√©s de los cambios.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tolerancia a fallas es la confianza de que los servicios est√°n dise√±ados e implementados de tal manera que se garantice el mayor rendimiento posible incluso en caso de falla de algunos recursos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora entremos en los detalles.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IoT Script Architecture</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, veamos c√≥mo se ve la arquitectura general del script IoT. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z_/po/yk/z_poykwjdwprirjgwkxmkvjnq0o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En √©l se pueden distinguir dos partes grandes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El primero es la entrega de datos al almacenamiento y la entrega de comandos a los dispositivos. </font><font style="vertical-align: inherit;">Cuando crea un sistema IoT, esta tarea debe resolverse en cualquier caso, sin importar el proyecto que realice.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El segundo est√° trabajando con los datos recibidos. </font><font style="vertical-align: inherit;">Todo es similar a cualquier otro proyecto basado en el an√°lisis y visualizaci√≥n de conjuntos de datos. </font><font style="vertical-align: inherit;">Tiene un repositorio con una matriz inicial de informaci√≥n, trabajando con el cual le permitir√° realizar su tarea.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La primera parte es aproximadamente la misma en todos los sistemas IoT: se basa en principios generales y se ajusta a un escenario com√∫n adecuado para la mayor√≠a de los sistemas IoT. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La segunda parte es casi siempre √∫nica en t√©rminos de las funciones realizadas, aunque se basa en componentes est√°ndar. Al mismo tiempo, sin un sistema escalable, tolerante a fallas y de alta calidad para interactuar con el hardware, la efectividad de la parte anal√≠tica de la arquitectura se reduce a casi cero, porque simplemente no hay nada que analizar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es por eso que el equipo de Yandex.Cloud decidi√≥ en primer lugar concentrarse en la construcci√≥n de un ecosistema conveniente de servicios que entregara datos de dispositivos de manera r√°pida, eficiente y confiable y viceversa, enviar comandos a los dispositivos.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tq/k8/ug/tqk8ugcmjnp3-s3cscc4ldhmuou.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para resolver estos problemas, estamos trabajando en la funcionalidad e integraci√≥n de Yandex IoT Core, Yandex Functions y servicios de almacenamiento de datos en la nube: </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El servicio Yandex IoT Core es un br√≥ker MQTT escalable a prueba de fallos de m√∫ltiples inquilinos con un conjunto de funciones √∫tiles adicionales.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El servicio Yandex Cloud Functions es un representante de la prometedora direcci√≥n sin servidor y le permite ejecutar su c√≥digo como una funci√≥n en un entorno seguro, tolerante a fallas y escalable autom√°ticamente sin crear y mantener m√°quinas virtuales.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex Object Storage es un almacenamiento efectivo de grandes matrices de datos y es muy adecuado para registros de archivos "hist√≥ricos".</font></font></li>
<li>          ,    ,      Yandex Managed Service for ClickHouse,     ¬´¬ª  .       ¬´¬ª      ,       ,     ,             .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si los servicios de almacenamiento y an√°lisis de datos son servicios de "prop√≥sito general" que ya se han escrito sobre mucho, entonces Yandex IoT Core y su interacci√≥n con Yandex Cloud Functions generalmente generan muchas preguntas, especialmente para las personas que reci√©n comienzan a comprender Internet de las cosas y las tecnolog√≠as de la nube. </font><font style="vertical-align: inherit;">Y dado que estos servicios proporcionan tolerancia a fallas y escalado del trabajo con dispositivos, primero veremos qu√© tienen debajo del cap√≥.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥mo funciona Yandex IoT Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex IoT Core es un servicio de plataforma especializado para el intercambio de datos bidireccional entre la nube y los dispositivos que ejecutan el protocolo MQTT. De hecho, este protocolo se ha convertido en el est√°ndar para transferir datos a IoT. Utiliza el concepto de colas con nombre (temas), donde, por un lado, puede escribir datos y, por otro lado, recibirlos de forma asincr√≥nica suscribi√©ndose a eventos de esta cola. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El servicio Yandex IoT Core es multiinquilino, lo que significa una √∫nica entidad que es accesible para todos los usuarios. Es decir, todos los dispositivos y todos los usuarios interact√∫an con la misma instancia de servicio.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto permite, por un lado, garantizar la uniformidad del trabajo para todos los usuarios, por otro lado, una escala efectiva y tolerancia a fallas, para mantener una conexi√≥n con un n√∫mero ilimitado de dispositivos y procesar una cantidad ilimitada de datos tanto en volumen como en velocidad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De ello se deduce que el servicio debe tener mecanismos de redundancia y la capacidad de administrar de manera flexible los recursos utilizados, a fin de responder a los cambios de carga. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, la tenencia m√∫ltiple requiere una l√≥gica especial para compartir los derechos de acceso a los temas de MQTT. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos c√≥mo se implementa esto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al igual que muchos otros servicios de Yandex.Cloud, Yandex IoT Core se divide l√≥gicamente en dos partes: plano de control y plano de datos:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8a/u0/f3/8au0f3pzmwa1v-hhsxikvo_l_0m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Data Plane es responsable de la l√≥gica de operaci√≥n bajo el protocolo MQTT, y Control Plane es responsable de delimitar los derechos de acceso a ciertos temas y utiliza las entidades l√≥gicas Registro y Dispositivo para esto. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eu/b1/1n/eub11nm0nlmhprrhfqzohfwcyow.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada usuario de Yandex.Cloud puede tener varios registros, cada uno de los cuales puede contener su propio subconjunto de dispositivos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El acceso a los temas se proporciona de la siguiente manera: los </font></font><br>
<br>
<img src="https://habrastorage.org/webt/df/wc/hd/dfwchdy-bdwxs56mkgykrcs0ia4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dispositivos pueden enviar datos solo a su tema de eventos y tema de eventos de registro:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/events</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y suscr√≠base a mensajes solo de su tema de comandos y tema de comandos de registro:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/commands</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El registro puede enviar datos a todos los temas de los comandos del dispositivo y al tema de los comandos del registro:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device2</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/commands</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y suscr√≠base a mensajes de todos los temas de eventos de dispositivos y el tema de eventos de registro:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device2</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/events</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para trabajar con todas las entidades descritas anteriormente, Data Plane tiene un protocolo gRPC y un protocolo REST, en funci√≥n del cual se implementa el acceso a trav√©s de la consola GUI de Yandex.Cloud y la interfaz de l√≠nea de comandos CLI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cuanto al plano de datos, es compatible con el protocolo MQTT versi√≥n 3.1.1. </font><font style="vertical-align: inherit;">Sin embargo, hay varias caracter√≠sticas:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al conectarse, aseg√∫rese de usar TLS.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo se admite la conexi√≥n TCP. </font><font style="vertical-align: inherit;">WebSocket a√∫n no est√° disponible.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La autorizaci√≥n est√° disponible tanto por inicio de sesi√≥n como por contrase√±a (donde el inicio de sesi√≥n es el dispositivo o el ID de registro, y el usuario establece las contrase√±as) y mediante certificados.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El indicador Retener no es compatible, cuando se utiliza el agente MQTT guarda el mensaje marcado con el indicador y lo env√≠a la pr√≥xima vez que se suscriba al tema.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No se admite la sesi√≥n persistente, en la cual el agente MQTT guarda informaci√≥n sobre el cliente (dispositivo o registro) para facilitar la reconexi√≥n.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con suscribirse y publicar, solo se admiten los dos primeros niveles de servicio:</font></font><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoS0: como m√°ximo una vez. </font><font style="vertical-align: inherit;">No hay garant√≠a de entrega, pero no hay reenv√≠o del mismo mensaje.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoS1: al menos una vez. </font><font style="vertical-align: inherit;">La entrega est√° garantizada, pero existe la posibilidad de volver a recibir el mismo mensaje.</font></font></li>
</ol></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para simplificar la conexi√≥n a Yandex IoT Core, agregamos regularmente nuevos ejemplos para diferentes plataformas e idiomas a nuestro repositorio en GitHub, y tambi√©n describimos los scripts en la documentaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La arquitectura del servicio tiene este aspecto: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6g/ig/4o/6gig4ofj7dksmbn18wvq5swkpuo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
la l√≥gica empresarial del servicio incluye cuatro partes:</font></font><br>
<br>
<ol>
<li> Device management ‚Äî     .   Control Plane.</li>
<li> MQTT Broker ‚Äî  MQTT-.  Data Plane.</li>
<li> Triggers ‚Äî     Yandex Cloud Functions.  Data Plane.</li>
<li> Shards ‚Äî      MQTT-    .  Data Plane.</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toda interacci√≥n con el "mundo exterior" pasa por equilibradores de carga. Adem√°s, de acuerdo con la filosof√≠a de alimentaci√≥n de perros, se utiliza Yandex Load Balancer, que est√° disponible para todos los usuarios de Yandex.Cloud. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada parte de la l√≥gica de negocios consta de varios conjuntos de tres m√°quinas virtuales, una en cada zona de disponibilidad (en los Esquemas A, B y C). Las m√°quinas virtuales son exactamente iguales a todos los usuarios de Yandex.Cloud. Cuando aumenta la carga, la escala se produce con la ayuda de todo el conjunto: se agregan tres m√°quinas a la vez en el marco de una parte de la l√≥gica empresarial. Esto significa que si un conjunto de tres m√°quinas MQTT Broker no hace frente a la carga, se agrega otro conjunto de tres m√°quinas MQTT Broker, mientras que la configuraci√≥n de otras partes de la l√≥gica empresarial sigue siendo la misma.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y solo Logbroker no est√° disponible p√∫blicamente. Es un servicio para una operaci√≥n eficiente a prueba de fallas con flujos de datos. Se basa en Apache Kafka, pero tiene muchas otras funciones √∫tiles: implementa procesos de recuperaci√≥n ante desastres (incluso exactamente una sem√°ntica cuando tiene una garant√≠a de entrega de mensajes sin duplicaci√≥n) y procesos de servicio (como la replicaci√≥n entre centros, la distribuci√≥n de datos a cl√∫steres de c√°lculo), y tambi√©n tiene un mecanismo para la distribuci√≥n uniforme y no duplicada de datos entre suscriptores de flujo, un tipo de equilibrador de carga. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las funciones de administraci√≥n de dispositivos en Control Plane se describen anteriormente. Pero con Data Plane, todo es mucho m√°s interesante.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada instancia de MQTT Broker funciona de forma independiente y no sabe nada sobre otras instancias. Los corredores env√≠an todos los datos recibidos (publicaci√≥n de los clientes) a Logbroker, desde donde los recogen Shards and Triggers. Y es en fragmentos donde se produce la sincronizaci√≥n entre instancias de corredores. Los fragmentos conocen todos los clientes MQTT y la distribuci√≥n de sus suscripciones (suscribirse) entre instancias de corredores MQTT y determinan d√≥nde enviar los datos recibidos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, el cliente MQTT A est√° suscrito al tema del intermediario A, y el cliente MQTT B est√° suscrito al mismo tema del intermediario B. Si el cliente MQTT C hace publicar en el mismo tema, pero al intermediario C, el fragmento transfiere datos de intermediario C a intermediarios A y B, como resultado de lo cual los datos ser√°n recibidos tanto por el cliente MQTT A como por el cliente MQTT B.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ia/dv/dz/iadvdzgd2cs6o1r3stjkqfhsq6y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La √∫ltima parte de la l√≥gica de negocios, triggers (Triggers), tambi√©n recibe todos los datos recibidos de los clientes MQTT y, si el usuario lo configura, los pasa a los activadores del servicio Yandex Cloud Functions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, Yandex IoT Core tiene una arquitectura y una l√≥gica de trabajo bastante complicadas, que es dif√≠cil de repetir en instalaciones locales. </font><font style="vertical-align: inherit;">Esto le permite soportar la p√©rdida de incluso dos de las tres zonas de disponibilidad, y resolver un n√∫mero ilimitado de conexiones y vol√∫menes de datos ilimitados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, toda esta l√≥gica est√° oculta para el usuario "debajo del cap√≥", pero desde el exterior todo parece muy simple, como si estuviera trabajando con un solo agente MQTT.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triggers y Yandex Cloud Functions</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex Cloud Functions es un representante de los llamados servicios "sin servidor" (sin servidor) en Yandex.Cloud. La esencia principal de dichos servicios es que el usuario no pasa su tiempo configurando, implementando y escalando el entorno para ejecutar c√≥digo, sino que solo se ocupa de lo m√°s valioso para √©l: escribir el c√≥digo que realiza la tarea necesaria. En el caso de las funciones, este es el llamado c√≥digo at√≥mico sin estado que puede ser activado por alg√∫n evento. "At√≥mico" y "sin estado" significan que este c√≥digo debe realizar una tarea relativamente peque√±a pero integral, mientras que el c√≥digo no debe usar ninguna variable para almacenar valores entre llamadas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay varias formas de llamar a funciones: una llamada HTTP directa, una llamada de temporizador (cron) o una suscripci√≥n a eventos. Como √∫ltimo, el servicio ya admite la suscripci√≥n a colas de mensajes (Yandex Message Queue), eventos generados por el servicio Object Storage y (lo m√°s valioso para el escenario IoT) suscripci√≥n a mensajes en Yandex IoT Core.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pesar de que puede trabajar con Yandex IoT Core utilizando cualquier cliente compatible con MQTT, Yandex Cloud Functions es una de las formas m√°s √≥ptimas y convenientes para recibir y procesar datos. La razon para esto es muy simple. Se puede invocar una funci√≥n en cada mensaje entrante desde cualquier dispositivo, y las funciones se ejecutar√°n en paralelo entre s√≠ (debido a la atomicidad y el enfoque sin estado), y el n√∫mero de sus llamadas cambiar√° naturalmente a medida que cambie el n√∫mero de mensajes entrantes de los dispositivos. Por lo tanto, el usuario puede ignorar por completo los problemas de configuraci√≥n de la infraestructura y, adem√°s, a diferencia de las mismas m√°quinas virtuales, el pago solo se realizar√° por el trabajo realmente realizado.Esto le permitir√° ahorrar significativamente a baja carga y obtener un costo claro y predecible con el crecimiento.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mecanismo para llamar a funciones en eventos (suscribirse a eventos) se llama disparador (Trigger). Su esencia se representa en el diagrama: un </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5u/yv/bn/5uyvbnyviueygxt4ykzdh9n2nug.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
servicio que genera eventos para llamar a funciones los pone en una cola en Logbroker. En el caso de Yandex IoT Core, los activadores de Data Plane hacen esto. Adem√°s, estos eventos son tomados por el preprocesador, que est√° buscando un registro en la base de datos para este evento que indique la funci√≥n que se llamar√°. Si se encuentra dicha entrada, el preprocesador coloca la informaci√≥n sobre la llamada de funci√≥n (ID de funci√≥n y par√°metros de llamada) en la cola en el servicio Yandex Message Queue, desde donde la recoge el manejador de llamadas. El controlador, a su vez, env√≠a una solicitud HTTP para llamar a la funci√≥n al servicio Yandex Cloud Functions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al mismo tiempo, de nuevo, de acuerdo con la filosof√≠a de alimentaci√≥n de perros, se utiliza el servicio Yandex Message Queue, accesible para todos los usuarios, y las funciones se invocan exactamente de la misma manera que cualquier otro usuario puede llamar a sus funciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos algunas palabras sobre Yandex Message Queue. A pesar de que esto, como Logbroker, es un servicio de cola, existe una diferencia significativa entre ellos. Al procesar mensajes de colas, el controlador informa a la cola que ha finalizado y que el mensaje se puede eliminar. Este es un mecanismo de confiabilidad importante en dichos servicios, pero complica la l√≥gica de trabajar con mensajes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex Message Queue le permite "paralelizar" el procesamiento de cada mensaje dentro de la cola. En otras palabras, el mensaje de la cola que se est√° procesando actualmente no bloquea la posibilidad de que otro "hilo" recoja el siguiente evento de la cola para su procesamiento. Esto se llama concurrencia a nivel de mensaje. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y LogBroker opera en grupos de mensajes, y hasta que se procese todo el grupo, el siguiente grupo no puede ser recogido para su procesamiento. Este enfoque se llama concurrencia a nivel de partici√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y es precisamente el uso de Yandex Message Queue lo que le permite procesar de manera r√°pida y eficiente en paralelo muchas solicitudes para llamar a una funci√≥n para eventos de un servicio en particular.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pesar de que los disparadores son una unidad independiente separada, son parte del servicio Yandex Cloud Functions. Solo tenemos que descubrir exactamente c√≥mo se llaman las funciones.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fb/ew/ke/fbewkedbrp6eyri7zkubwiu6dzu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todas las solicitudes para llamar a funciones (tanto externas como internas) caen en el equilibrador de carga, que las distribuye a enrutadores en diferentes zonas de acceso (AZ), se implementan varias piezas en cada zona. Al recibir una solicitud, el enrutador primero va al servicio del administrador de Identidad y Acceso (IAM) para asegurarse de que la fuente de la solicitud tenga derechos para llamar a esta funci√≥n. Luego recurre al planificador y pregunta en qu√© trabajador ejecutar la funci√≥n. Worker es una m√°quina virtual con un tiempo de ejecuci√≥n personalizado de funciones aisladas. Adem√°s, el enrutador, despu√©s de haber recibido del planificador la direcci√≥n del trabajador en el que ejecutar la funci√≥n, env√≠a un comando a este trabajador para iniciar la funci√≥n con ciertos par√°metros.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øDe d√≥nde viene el trabajador? Aqu√≠ es donde sucede toda la magia sin servidor. Los programadores, analizando la carga (el n√∫mero y la duraci√≥n de las funciones), administran (inician y detienen) m√°quinas virtuales con un tiempo de ejecuci√≥n particular. NodeJS y Python ahora son compatibles. Y aqu√≠ un par√°metro es extremadamente importante: la velocidad de lanzamiento de funciones. El equipo de desarrollo de servicios ha hecho un gran trabajo, y ahora la m√°quina virtual se inicia en un m√°ximo de 250 ms, mientras utiliza el entorno m√°s seguro para aislar las funciones entre s√≠: la virtualizaci√≥n QEMU, que ejecuta todo Yandex. Cloud. Al mismo tiempo, si ya hay un trabajador que trabaja para la solicitud entrante, la funci√≥n se inicia casi instant√°neamente.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y, de acuerdo con el mismo enfoque de alimentaci√≥n de perros, Load Balancer utiliza un servicio p√∫blico accesible para todos los usuarios, y el trabajador, el planificador y el enrutador son m√°quinas virtuales comunes, lo mismo que todos los usuarios. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, la tolerancia a fallas del servicio se implementa a nivel del equilibrador de carga y la redundancia de los componentes clave del sistema (enrutador y planificador), y el escalado se produce debido a la implementaci√≥n o la reducci√≥n del n√∫mero de trabajadores. </font><font style="vertical-align: inherit;">Adem√°s, cada zona de accesibilidad funciona de forma independiente, lo que permite sobrevivir incluso a la p√©rdida de dos de las tres zonas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enlaces √∫tiles</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conclusi√≥n, quiero dar algunos enlaces que le permitir√°n estudiar los servicios con m√°s detalle:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex IoT Core: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloud.yandex.ru/services/iot-core</font></font></a> </li>
<li> Yandex Cloud Functions: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cloud.yandex.ru/services/functions</a> </li>
<li> Yandex Message Queue: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cloud.yandex.ru/services/message-queue</a> </li>
<li> Yandex Managed Service for ClickHouse: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cloud.yandex.ru/services/managed-clickhouse</a> </li>
<li> Yandex Load Balancer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cloud.yandex.ru/services/load-balancer</a> </li>
<li> Yandex Object Storage: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cloud.yandex.ru/services/storage</a> </li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es491724/index.html">El libro "Laravel. Gu√≠a completa 2da edicion</a></li>
<li><a href="../es491726/index.html">Expandir columnas anidadas: listas que utilizan el lenguaje R (paquete tidyr y funciones familiares desagradables)</a></li>
<li><a href="../es491728/index.html">Principio SECO con Laravel</a></li>
<li><a href="../es491732/index.html">¬øHay vida despu√©s de Scratch, o c√≥mo presentar a un ni√±o a Python?</a></li>
<li><a href="../es491736/index.html">TMS1000: el primer microcontrolador disponible comercialmente</a></li>
<li><a href="../es491742/index.html">Sorbete: teclado ergon√≥mico para juegos</a></li>
<li><a href="../es491744/index.html">Los piratas inform√°ticos iran√≠es explotaron vulnerabilidades en VPN</a></li>
<li><a href="../es491746/index.html">La historia de la s√≠ntesis del habla: la era de las soluciones el√©ctricas.</a></li>
<li><a href="../es491748/index.html">Tecnolog√≠as que ayudan a los ciegos a aprender ingl√©s</a></li>
<li><a href="../es491750/index.html">Escribimos la b√∫squeda de subcadenas mejor que en los libros de texto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>