<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏼 💪🏿 👢 GeminiとStorybookに基づく視覚テストの開発 ⚜️ 🖱️ 👼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！この記事では、チームでビジュアルテストを開発した経験を紹介します。
 
 偶然にも、レイアウトテストについてはすぐには考えていませんでした。まあ、いくつかのフレームは数ピクセル移動します。まあ、それを修正します。結局、テスターがいます-ハエはそれらを通過しません。しかし、ヒューマ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>GeminiとStorybookに基づく視覚テストの開発</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454464/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！この記事では、チームでビジュアルテストを開発した経験を紹介します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
偶然にも、レイアウトテストについてはすぐには考えていませんでした。まあ、いくつかのフレームは数ピクセル移動します。まあ、それを修正します。結局、テスターがいます-ハエはそれらを通過しません。しかし、ヒューマンファクターはまだだまされていません。ユーザーインターフェースの小さな変更を検出することは、テスターであっても常に物理的に可能とはほど遠いものです。レイアウトの本格的な最適化とBEMへの移行が始まったときに問題が生じました。ここでは、それは確かに無損失ではなかったでしょう、そして編集の結果として、UIの何かが意図したように、または意図した場所ではなく変化し始めた状況を検出する自動化された方法が必要でした。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者なら誰でもユニットコードのテストについて知っています。ユニットテストは、コードの変更が何も壊さなかったという確信を与えます。まあ、少なくとも彼らはテストがある部分で壊れませんでした。ユーザーインターフェースにも同じ原則を適用できます。単体テストのテストクラスと同様に、ビジュアルテストは、アプリケーションのユーザーインターフェイスを構成するビジュアルコンポーネントをテストします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビジュアルコンポーネントの場合、「クラシック」ユニットテストを記述できます。たとえば、入力パラメーターの異なる値でコンポーネントのレンダリングを開始し、assertステートメントを使用してDOMツリーの予想される状態を確認し、個々の要素またはコンポーネントのDOMツリーのスナップショットを参照と比較します。一般的に。ビジュアルテストもスナップショットに基づいていますが、既にコンポーネントのビジュアル表示のスナップショット（スクリーンショット）に基づいています。視覚テストの本質は、テスト中に撮影した写真を参照写真と比較し、違いが見つかった場合は、新しい写真を参照写真として受け入れるか、これらの違いの原因となったバグを修正することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、個々のビジュアルコンポーネントを「スクリーニング」することはあまり効果的ではありません。コンポーネントは孤立して存在せず、その表示は最上位のコンポーネントまたは隣接するコンポーネントに依存する場合があります。個々のコンポーネントをどのようにテストしても、画像全体に欠陥がある場合があります。一方、アプリケーションウィンドウ全体の写真を撮ると、多くの写真に同じコンポーネントが含まれます。つまり、1つのコンポーネントを変更すると、このコンポーネントが存在するすべての写真が強制的に更新されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
真実は、いつものように、真ん中のどこかにあります-アプリケーションのページ全体を描画できますが、テストが作成される1つの領域のみの写真を撮ります。特定の場合、この領域は特定のコンポーネントの領域と一致する場合がありますが、これはコンポーネントではありません真空ですが、非常に現実的な環境です。</font><font style="vertical-align: inherit;">そして、これはすでにユニットの視覚テストに似ていますが、「ユニット」が環境について何かを知っている場合、モジュール性についてはほとんど言えません。</font><font style="vertical-align: inherit;">まあ、大丈夫、どのカテゴリのテストにビジュアルテストが含まれるか（モジュール式または統合）は特に問題ではありません。</font><font style="vertical-align: inherit;">ことわざにあるように、「チェックするか、行くか？」</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ツールの選択</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストの実行を高速化するため</font><font style="vertical-align: inherit;">に、画面に表示されずにメモリ内のすべての作業を実行し、最大のパフォーマンスを提供する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘッドレスブラウザー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でページレンダリングを実行できます</font><font style="vertical-align: inherit;">。しかし、私たちの場合、ヘッドレスモードを備えていないInternet Explorer（IE）でアプリケーションが機能することを確認することが重要であり、プログラムによってブラウザーを管理するためのツールが必要でした。幸い、すべてはすでに私たちの前で発明されており、そのような楽器があります-それは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selenium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれてい</font><font style="vertical-align: inherit;">ます。 Seleniumプロジェクトの一部として、IEのドライバーを含むさまざまなブラウザーを管理するためのドライバーが開発されています。 Seleniumサーバーは、ブラウザーをローカルだけでなくリモートでも管理でき、セレンサーバーのクラスター、いわゆるセレングリッドを形成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セレンは強力なツールですが、それを入力するためのしきい値は非常に高いです。私たちは、Seleniumに基づく視覚テスト用の既成のツールを探すことにし、Yandexの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gemini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という素晴らしい製品に出会いました</font><font style="vertical-align: inherit;">。ジェミニは、ページの特定の領域の写真を含む写真を撮ったり、参照写真と写真を比較したり、違いを視覚化したり、アンチエイリアスやカーソルの点滅などの瞬間を考慮したりできます。さらに、Geminiは、落ちたテストの繰り返しを実行したり、テストの実行を並列化したり、その他の多くの利点があります。一般的に、私たちは試すことにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Geminiテストは簡単に作成できます。最初にインフラストラクチャを準備する必要があります</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">-Selenium-standaloneを</font></a><font style="vertical-align: inherit;">インストールします</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セレンサーバーを実行します。</font><font style="vertical-align: inherit;">次に、テスト対象のアプリケーションのアドレス（rootUrl）、セレンサーバーのアドレス（gridUrl）、ブラウザーの構成と構成、およびレポートの生成に必要なプラグインを指定して、画像圧縮を最適化し、geminiを構成します。</font><font style="vertical-align: inherit;">構成例：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//.gemini.js</span><font></font>
<font></font>
<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">rootUrl</span>: <span class="hljs-string">'http://my-app.ru'</span>,  
  <span class="hljs-attr">gridUrl</span>: <span class="hljs-string">'http://127.0.0.1:4444/wd/hub'</span>, <font></font>
<font></font>
  <span class="hljs-attr">browsers</span>: {
    <span class="hljs-attr">chrome</span>: {
      <span class="hljs-attr">windowSize</span>: <span class="hljs-string">'1920x1080'</span>,
      <span class="hljs-attr">screenshotsDir</span>:<span class="hljs-string">'gemini/screens/1920x1080'</span>
      <span class="hljs-attr">desiredCapabilities</span>: {
        <span class="hljs-attr">browserName</span>: <span class="hljs-string">'chrome'</span><font></font>
      }<font></font>
    }<font></font>
  },<font></font>
  <span class="hljs-attr">system</span>: {
    <span class="hljs-attr">projectRoot</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">plugins</span>: {
      <span class="hljs-string">'html-reporter/gemini'</span>: {
        <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">path</span>: <span class="hljs-string">'./report'</span><font></font>
      },<font></font>
      <span class="hljs-string">'gemini-optipng'</span>: <span class="hljs-literal">true</span><font></font>
    },<font></font>
    <span class="hljs-attr">exclude</span>: [ <span class="hljs-string">'**/report/*'</span> ],
    <span class="hljs-attr">diffColor</span>: <span class="hljs-string">'#EC041E'</span><font></font>
  }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テスト自体はスイートのコレクションであり、各スイートで1つ以上の写真（状態）が取得されます。</font><font style="vertical-align: inherit;">スナップショット（capture（）メソッド）を取得する前に、setCaptureElements（）メソッドを使用して、ショットするページの領域を設定し、必要に応じてアクションオブジェクトのメソッドまたは任意のJavaScriptコードを使用して、ブラウザーコンテキストでいくつかの準備アクションを実行できます。このアクションには、executeJS（）メソッドがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例：</font></font><br>
<br>
<pre><code class="javascript hljs">
gemini.suite(<span class="hljs-string">'login-dialog'</span>, suite =&gt; {<font></font>
  suite.setUrl(<span class="hljs-string">'/'</span>)<font></font>
  .setCaptureElements(<span class="hljs-string">'.login__form'</span>)<font></font>
  .capture(<span class="hljs-string">'default'</span>);<font></font>
  .capture(<span class="hljs-string">'focused'</span>, actions =&gt; actions.focus(<span class="hljs-string">'.login__editor'</span>));<font></font>
});</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストデータ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストツールが選択されましたが、それでも最終的なソリューションへの長い道のりでした。写真に表示されているデータをどう処理するかを理解する必要がありました。テストでは、ビジュアルコンポーネントを真空ではなく他のコンポーネントの実際の環境でテストするために、個々のコンポーネントではなくアプリケーションのページ全体を描画することを決定したことを思い出してください。個別のコンポーネントをレンダリングするために</font><font style="vertical-align: inherit;">必要なテストデータ</font><font style="vertical-align: inherit;">をee </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">props</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（reactコンポーネントについて話している）</font><font style="vertical-align: inherit;">に転送する</font><font style="vertical-align: inherit;">必要</font><font style="vertical-align: inherit;">がある場合</font><font style="vertical-align: inherit;">、アプリケーションのページ全体をレンダリングするにはさらに多くのものが必要であり、そのようなテストのための環境の準備は頭痛の種になる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、アプリケーション自体がデータを受信するようにして、テスト中にバックエンドへのリクエストを実行することができます。バックエンドは、参照データベースからデータを受信しますが、バージョニングについてはどうでしょうか？データベースをgitリポジトリに置くことはできません。いいえ、もちろん可能ですが、いくつかの良識があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、テストを実行するために、実際のバックエンドサーバーを偽のサーバーに置き換えることができます。これにより、Webアプリケーションに、データベースからのデータではなく、たとえばソースにjson形式で保存された静的データが提供されます。ただし、そのようなデータの準備もそれほど簡単ではありません。サーバーからデータをプルするのではなく、テストを実行する前にアプリケーションの状態を復元するだけの簡単な方法を採用することにしました（この例では、これは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Reduxストレージの</font></a><font style="vertical-align: inherit;">状態です）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、参照画像の撮影時にアプリケーションにあった。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
reduxストレージの現在の状態をシリアル化するために、snapshot（）メソッドがウィンドウオブジェクトに追加されました。</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> snapshotStore = (store: <span class="hljs-built_in">Object</span>, <span class="hljs-attr">fileName</span>: string): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> {
  <span class="hljs-keyword">let</span> state = store.getState();
  <span class="hljs-keyword">const</span> file = <span class="hljs-keyword">new</span> Blob(<font></font>
    [ <span class="hljs-built_in">JSON</span>.stringify(state, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>) ],<font></font>
    { <span class="hljs-attr">type</span>: <span class="hljs-string">'application/json'</span> }<font></font>
  );<font></font>
  <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'a'</span>);<font></font>
  a.href = URL.createObjectURL(file);<font></font>
  a.download = <span class="hljs-string">`<span class="hljs-subst">${fileName}</span>.testdata.json`</span>;<font></font>
  a.click();<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-string">`State downloaded to <span class="hljs-subst">${a.download}</span>`</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">const</span> store = createStore(reducer);<font></font>
<font></font>
<span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span>) {
  <span class="hljs-built_in">window</span>.snapshot = <span class="hljs-function"><span class="hljs-params">fileName</span> =&gt;</span> snapshotStore(store, fileName);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法を使用し、ブラウザーコンソールのコマンドラインを使用して、redux-storageの現在の状態をファイルに保存できます。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ストーリーブック</font></a></font><br>
<br>
<img src="https://habrastorage.org/webt/qf/t0/yq/qft0yqppzfe_issnjy74jon-vbs.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
は、ビジュアルテストのインフラストラクチャとして選択されました</font><font style="vertical-align: inherit;">-ビジュアルコンポーネントのライブラリをインタラクティブに開発するためのツール。</font><font style="vertical-align: inherit;">主なアイデアは、アプリケーションのさまざまな状態を修正し、ストーリーツリー内のコンポーネントのさまざまな状態の代わりにこれらの状態を使用してスクリーンショットを撮ることでした。</font><font style="vertical-align: inherit;">結局、環境の準備を除いて、単純なコンポーネントと複雑なコンポーネントの間に基本的な違いはありません。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、各視覚テストはストーリーであり、レンダリングの前に、以前にファイルに保存されたreduxストレージの状態が復元されます。</font><font style="vertical-align: inherit;">これは、react-reduxライブラリのプロバイダーコンポーネントを使用して、以前に保存されたファイルから復元された逆シリアル化状態が渡されるストアプロパティに行われます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> preloadedState <span class="hljs-keyword">from</span> <span class="hljs-string">'./incoming-letter.testdata'</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> store = createStore(rootReducer, preloadedState);<font></font>
<font></font>
storiesOf(<span class="hljs-string">'regression/Cards'</span>, <span class="hljs-built_in">module</span>)<font></font>
  .add(<span class="hljs-string">'IncomingLetter'</span>, () =&gt; {
    <span class="hljs-keyword">return</span> (
     <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">MemoryRouter</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">ContextContainer</span> {<span class="hljs-attr">...dummyProps</span>}/&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">MemoryRouter</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><font></font>
   );<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例では、ContextContainerは、アプリケーションの「スケルトン」、つまりナビゲーションツリー、ヘッダー、コンテンツ領域を含むコンポーネントです。</font><font style="vertical-align: inherit;">コンテンツ領域では、reduxストレージの現在の状態に応じて、さまざまなコンポーネント（リスト、カード、ダイアログなど）をレンダリングできます。</font><font style="vertical-align: inherit;">コンポーネントが入力のためにバックエンドに不必要な要求を行わないようにするために、対応するスタブプロパティがコンポーネントに渡されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストーリーブックのコンテキストでは、次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jx/0m/ux/jx0muxytucrqrwzpvtnskjuqs1a.png" alt="画像"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジェミニ+ストーリーブック</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、テストのデータを見つけました。次のタスクは、ジェミニとストーリーブックと友達になることです。一見すると、すべてが簡単です。Gemini構成では、テスト対象のアプリケーションのアドレスを指定します。私たちの場合、これはStorybookサーバーのアドレスです。ジェミニテストを開始する前に、ストーリーブックサーバーを上げるだけです。これは、GeminiイベントサブスクリプションSTART_RUNNERおよびEND_RUNNERを使用して、コードから直接実行できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> port = <span class="hljs-number">6006</span>;
<span class="hljs-keyword">const</span> cofiguration = {
  <span class="hljs-attr">rootUrl</span>:<span class="hljs-string">`localhost:<span class="hljs-subst">${port}</span>`</span>,
  <span class="hljs-attr">gridUrl</span>: seleniumGridHubUrl,
  <span class="hljs-attr">browsers</span>: {
    <span class="hljs-string">'chrome'</span>: {
       <span class="hljs-attr">screenshotsDir</span>:<span class="hljs-string">'gemini/screens'</span>,
       <span class="hljs-attr">desiredCapabilities</span>: chromeCapabilities<font></font>
     }<font></font>
   }<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">const</span> Gemini = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gemini'</span>);
<span class="hljs-keyword">const</span> HttpServer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http-server'</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> runner = <span class="hljs-keyword">new</span> Gemini(cofiguration);
<span class="hljs-keyword">const</span> server = HttpServer.createServer({ <span class="hljs-attr">root</span>: <span class="hljs-string">'./storybook-static'</span>});<font></font>
<font></font>
runner.on(runner.events.START_RUNNER, () =&gt; {<font></font>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`storybook server is listening on <span class="hljs-subst">${port}</span>...`</span>);<font></font>
  server.listen(port);<font></font>
});<font></font>
<font></font>
runner.on(runner.events.END_RUNNER, () =&gt; {<font></font>
  server.close();<font></font>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'storybook server is closed'</span>);<font></font>
});<font></font>
<font></font>
runner<font></font>
  .readTests(path)<font></font>
  .done(<span class="hljs-function"><span class="hljs-params">tests</span> =&gt;</span> runner.test(tests));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テスト用のサーバーとして、静的に組み立てられたストーリーブックを含むフォルダーのコンテンツを返すhttp-serverを使用しました（静的なストーリーブックを構築するには、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">build-storybookコマンドを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用します</font><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、すべてが順調に進んでいますが、問題が待っているわけではありません。実際には、ストーリーブックはフレーム内にストーリーを表示します。最初は、setCaptureElements（）を使用して画像の選択領域を設定できるようにしたかったのですが、これは、スイートのアドレスとしてフレームアドレスを指定した場合にのみ可能です。</font></font><br>
<br>
<pre><code class="javascript hljs">gemini.suite(<span class="hljs-string">'VisualRegression'</span>, suite =&gt;<font></font>
  suite.setUrl(<span class="hljs-string">'http://localhost:6006/iframe.html?selectedKind=regression%2Fcards&amp;selectedStory=IncomingLetter'</span>)<font></font>
  .setCaptureElements(<span class="hljs-string">'.some-component'</span>)<font></font>
  .capture(<span class="hljs-string">'IncomingLetter'</span>)<font></font>
);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、ショットごとに独自のスイートを作成する必要があることがわかります。 URLはスイート全体に設定できますが、スイート内の単一のスナップショットには設定できません。各スイートは個別のブラウザセッションで実行されることを理解する必要があります。これは原則として正しいです。テストは相互に依存するべきではありませんが、別のブラウザーセッションを開いてからStorybookを読み込むには、すでに開いているStorybookのフレームワーク内でストーリーを移動するだけではなく、かなりの時間がかかります。したがって、スイートの数が多いと、テストの実行時間が非常に遅くなります。問題の一部はテストの実行を並列化することで解決できますが、並列化は多くのリソース（メモリ、プロセッサ）を消費します。したがって、リソースを節約すると同時に、テストの実行中にあまり損失しないことを決定したので、別のブラウザーウィンドウでフレームを開くことを拒否しました。テストは単一のブラウザーセッション内で実行されますが、各ショットの前に、ストーリーブックを開いてストーリーツリーの個々のノードをクリックするかのように、次のストーリーがフレームに読み込まれます。画像領域-フレーム全体：</font></font><br>
<br>
<pre><code class="javascript hljs">gemini.suite(<span class="hljs-string">'VisualRegression'</span>, suite =&gt;<font></font>
  suite.setUrl(<span class="hljs-string">'/'</span>)<font></font>
  .setCaptureElements(<span class="hljs-string">'#storybook-preview-iframe'</span>)<font></font>
  .capture(<span class="hljs-string">'IncomingLetter'</span>, actions =&gt; openStory(actions, <span class="hljs-string">'IncomingLetter'</span>))<font></font>
  .capture(<span class="hljs-string">'ProjectDocument'</span>, actions =&gt; openStory(actions, <span class="hljs-string">'ProjectDocumentAccess'</span>))<font></font>
  .capture(<span class="hljs-string">'RelatedDocuments'</span>, actions =&gt; {<font></font>
     openStory(actions, <span class="hljs-string">'RelatedDocuments'</span>);<font></font>
     hover(actions, <span class="hljs-string">'.related-documents-tree-item__title'</span>, <span class="hljs-number">4</span>);<font></font>
  })<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、このオプションでは、画像領域を選択する機能に加えて、Geminiエンジンの標準アクションを使用してDOMツリーの要素（mouseDown（）、mouseMove（）、focus（）など）を操作する機能も失いました。に。 Geminiフレーム内の要素は「見えません」。しかし、ブラウザコンテキストでJavaScriptコードを実行できるexecuteJS（）関数を使用する機会はまだあります。この機能に基づいて、必要な標準アクションの類似物を実装しました。これは、Storybookフレームのコンテキストで既に機能しています。ここでは、テストコンテキストからブラウザーコンテキストにパラメーター値を転送するために、少し「活用」する必要がありました-残念ながら、executeJS（）はそのような機会を提供していません。したがって、一見すると、コードは少し奇妙に見えます-関数は文字列に変換され、コードの一部はパラメーター値に置き換えられ、ExecuteJs（）では、関数はeval（）を使用して文字列から復元されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">openStory</span>(<span class="hljs-params">actions, storyName</span>) </span>{
  <span class="hljs-keyword">const</span> storyNameLowered = storyName.toLowerCase();
  <span class="hljs-keyword">const</span> clickTo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">window</span>) </span>{
    <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">window</span>.document.querySelectorAll(<span class="hljs-string">'a'</span>)).filter(
      <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el</span>) </span>{
        <span class="hljs-keyword">return</span> el.textContent.toLowerCase() === <span class="hljs-string">'storyNameLowered'</span>;<font></font>
      })[<span class="hljs-number">0</span>].click();<font></font>
  };<font></font>
  actions.executeJS(<span class="hljs-built_in">eval</span>(<span class="hljs-string">`(<span class="hljs-subst">${clickTo.toString().replace(<span class="hljs-string">'storyNameLowered'</span>, storyNameLowered)}</span>)`</span>));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatchEvents</span>(<span class="hljs-params">actions, targets, index, events</span>) </span>{
  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">window</span>) </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">document</span> = <span class="hljs-built_in">window</span>.document.querySelector(<span class="hljs-string">'#storybook-preview-iframe'</span>).contentWindow.document;
    <span class="hljs-keyword">const</span> target = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'targets'</span>)[index || <span class="hljs-number">0</span>];<font></font>
    events.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
      <span class="hljs-keyword">const</span> clickEvent = <span class="hljs-built_in">document</span>.createEvent(<span class="hljs-string">'MouseEvents'</span>);<font></font>
      clickEvent.initEvent(event, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);<font></font>
      target.dispatchEvent(clickEvent);<font></font>
    });<font></font>
  };<font></font>
  actions.executeJS(<span class="hljs-built_in">eval</span>(<span class="hljs-string">`(<span class="hljs-subst">${dispatch.toString()
    .replace(<span class="hljs-string">'targets'</span>, targets)
    .replace(<span class="hljs-string">'index'</span>, index)
    .replace(<span class="hljs-string">'events'</span>, <span class="hljs-string">`["<span class="hljs-subst">${events.join(<span class="hljs-string">'","'</span>)}</span>"]`</span>)}</span>)`</span><font></font>
  ));<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hover</span>(<span class="hljs-params">actions, selectors, index</span>) </span>{<font></font>
  dispatchEvents(actions, selectors, index, [<font></font>
    <span class="hljs-string">'mouseenter'</span>,
    <span class="hljs-string">'mouseover'</span><font></font>
  ]);<font></font>
}<font></font>
<font></font>
<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">openStory</span>: openStory,
  <span class="hljs-attr">hover</span>: hover<font></font>
};<font></font>
</code></pre><br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビジュアルテストが作成され、機能し始めた後、一部のテストはあまり安定していないことがわかりました。アイコンが描画される時間がない場所、選択が削除されない場所、および参照画像との不一致が発生する場所。したがって、テスト実行の再テストを含めることにしました。ただし、Geminiでは、再試行はスイート全体で機能し、前述のように、各スイートに独自のスイートがある状況を回避しようとしました。これにより、テストの実行が遅くなりすぎます。一方、1つのスイートのフレームワーク内で撮影されるショット数が多いほど、スイートの繰り返し実行が前のスイートと同様に失敗する可能性が高くなります。したがって、再試行を実装する必要がありました。私たちのスキームでは、実行の繰り返しはスイート全体ではなく、前回の失敗した実行に合格しなかった写真に対してのみ行われます。これを行うには、TEST_RESULTイベントハンドラーで、スナップショットと参照を比較した結果を分析し、比較に合格しなかったショットについてのみ、新しいスイートを作成します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> SuiteCollection = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gemini/lib/suite-collection'</span>);
<span class="hljs-keyword">const</span> Suite = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gemini/lib/suite'</span>);<font></font>
<font></font>
<span class="hljs-keyword">let</span> retrySuiteCollection;
<span class="hljs-keyword">let</span> retryCount = <span class="hljs-number">2</span>;<font></font>
<font></font>
runner.on(runner.events.BEGIN, () =&gt; {<font></font>
  retrySuiteCollection = <span class="hljs-keyword">new</span> SuiteCollection();<font></font>
});<font></font>
<font></font>
runner.on(runner.events.TEST_RESULT, args =&gt; {<font></font>
  <span class="hljs-keyword">const</span> testId = <span class="hljs-string">`<span class="hljs-subst">${args.state.name}</span>/<span class="hljs-subst">${args.suite.name}</span>/<span class="hljs-subst">${args.browserId}</span>`</span>;
  <span class="hljs-keyword">if</span> (!args.equal) {
    <span class="hljs-keyword">if</span> (retryCount &gt; <span class="hljs-number">0</span>)
      <span class="hljs-built_in">console</span>.log(chalk.yellow(<span class="hljs-string">`failed <span class="hljs-subst">${testId}</span>`</span>));
    <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">console</span>.log(chalk.red(<span class="hljs-string">`failed <span class="hljs-subst">${testId}</span>`</span>));
    <span class="hljs-keyword">let</span> suite = retrySuiteCollection.topLevelSuites().find(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.name === args.suite.name);
    <span class="hljs-keyword">if</span> (!suite) {<font></font>
      suite = <span class="hljs-keyword">new</span> Suite(args.suite.name);<font></font>
      suite.url = args.suite.url;<font></font>
      suite.file = args.suite.file;<font></font>
      suite.path = args.suite.path;<font></font>
      suite.captureSelectors = [ ...args.suite.captureSelectors ];<font></font>
      suite.browsers = [ ...args.suite.browsers ];<font></font>
      suite.skipped = [ ...args.suite.skipped ];<font></font>
      suite.beforeActions = [ ...args.suite.beforeActions ];<font></font>
      retrySuiteCollection.add(suite);<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (!suite.states.find(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.name === args.state.name)) {<font></font>
      suite.addState(args.state.clone());<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">else</span>
    <span class="hljs-built_in">console</span>.log(chalk.green(<span class="hljs-string">`passed <span class="hljs-subst">${testId}</span>`</span>));<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ところで、TEST_RESULTイベントは、合格したテストの進捗状況を視覚化するのにも役立ちました。</font><font style="vertical-align: inherit;">これで、開発者はすべてのテストが完了するのを待つ必要がなくなり、問題が発生した場合は実行を中断できます。</font><font style="vertical-align: inherit;">テストの実行が中断されると、Geminiはセレンサーバーによって開かれたブラウザセッションを正しく閉じます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テスト実行の完了時に、新しいスイートが空でない場合は、繰り返しの最大数に達するまで実行します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onComplete</span>(<span class="hljs-params">result</span>) </span>{
  <span class="hljs-keyword">if</span> ((retryCount--) &gt; <span class="hljs-number">0</span> &amp;&amp; result.failed &gt; <span class="hljs-number">0</span> &amp;&amp; retrySuiteCollection.topLevelSuites().length &gt; <span class="hljs-number">0</span>) {<font></font>
    runner.test(retrySuiteCollection, {}).done(onComplete);<font></font>
  }<font></font>
}<font></font>
<font></font>
runner.readTests(path).done(<span class="hljs-function"><span class="hljs-params">tests</span> =&gt;</span> runner.test(tests).done(onComplete));</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日、アプリケーションの主要な視覚状態をカバーする約50の視覚テストがあります。もちろん、UIテストの全範囲について話す必要はありませんが、まだそのような目標を設定していません。テストは、開発者のワークステーションとビルドエージェントの両方で正常に機能します。テストはChromeとInternet Explorerのコンテキストでのみ実行されますが、将来的には他のブラウザーを接続することも可能です。このエコノミーはすべて、仮想マシンに2つのノードがデプロイされたSelemiumグリッドに対応します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chromeの新バージョンのリリース後、一部の要素（スクローラーなど）が少し異なって表示されるようになったため、参照画像を更新する必要があるという事実に直面することがありますが、それについては何もする必要がありません。</font><font style="vertical-align: inherit;">まれですが、redux-storeの構造を変更すると、テスト用に保存された状態を再度取得する必要がある場合があります。</font><font style="vertical-align: inherit;">もちろん、作成時のテストとまったく同じ状態に戻すのは簡単ではありません。</font><font style="vertical-align: inherit;">原則として、これらの写真が撮られたデータベースを誰も覚えていないため、他のデータで新しい写真を撮る必要があります。</font><font style="vertical-align: inherit;">これは問題ですが、それほど大きな問題ではありません。</font><font style="vertical-align: inherit;">それを解決するには、デモ用のスクリプトがあり、最新の状態に保たれているため、デモベースで写真を撮ることができます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja454452/index.html">特定のルールに従って、認識された画像にコンテンツを表示します</a></li>
<li><a href="../ja454456/index.html">Cisco 200-125 CCNA v3.0のトレーニング。7日目。FAQ</a></li>
<li><a href="../ja454458/index.html">変成テスト：この有望な手法について誰も知らない理由</a></li>
<li><a href="../ja454460/index.html">モバイル＃300開発者向けの興味深い資料のダイジェスト（5月27日-6月2日）</a></li>
<li><a href="../ja454462/index.html">フォト用紙なしのフォトグラム</a></li>
<li><a href="../ja454470/index.html">実行前の生活。Yandexレポート</a></li>
<li><a href="../ja454472/index.html">シスコの最新のルーターパッチについて知っておくべきこと</a></li>
<li><a href="../ja454474/index.html">6月3日から9日までのモスクワでのデジタルイベント</a></li>
<li><a href="../ja454476/index.html">ベストプラクティスNode.js-プロジェクト構造のヒント</a></li>
<li><a href="../ja454478/index.html">Azure IoT Edge Tools（Preview）拡張機能が発表されました</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>