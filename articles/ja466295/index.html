<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏏️ 🤜🏿 🏪 Scala上の痛みのないフォールバックキャッシュ 💞 💫 🌡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大規模またはマイクロサービスアーキテクチャでは、最も重要なサービスが常に最も生産的であるとは限らず、高負荷を対象としない場合もあります。バックエンドについて話している。それはゆっくりと動作します-データ処理とそれとDBMSの間の応答を待つ時間を失い、スケーリングしません。アプリケーション自体のスケー...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Scala上の痛みのないフォールバックキャッシュ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/466295/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大規模またはマイクロサービスアーキテクチャでは、最も重要なサービスが常に最も生産的であるとは限らず、高負荷を対象としない場合もあります。</font><font style="vertical-align: inherit;">バックエンドについて話している。</font><font style="vertical-align: inherit;">それはゆっくりと動作します-データ処理とそれとDBMSの間の応答を待つ時間を失い、スケーリングしません。</font><font style="vertical-align: inherit;">アプリケーション自体のスケーリングが容易であっても、このボトルネックはまったくスケーリングしません。</font><font style="vertical-align: inherit;">この問題を解決して高性能を確保するにはどうすればよいですか？</font><font style="vertical-align: inherit;">重要な情報源が沈黙しているときにシステム応答を提供する方法は？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tw/3o/ti/tw3otiqpnki3jcwa8ittvdrpzoc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アーキテクチャがReactiveマニフェストと完全に一致している場合、アプリケーションのコンポーネントは、互いに独立して負荷が増加するにつれて無制限にスケーリングし、ノードの落下に耐えます-答えはわかっています。</font><font style="vertical-align: inherit;">しかし、そうでない場合は、&nbsp; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleg Nizhnikov</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オドモントワ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は、アプリケーションを書き直すことなく、Scala上に痛みのないフォールバックキャッシュを構築することにより、Tinkoffでスケーラビリティの問題がどのように解決されたかを示します。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意。</font><font style="vertical-align: inherit;">この記事には、最小限のScalaコードと最大限の一般的な原則とアイデアが含まれます。</font></font></i><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/p9j6_nOP4Kk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不安定または遅いバックエンド</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックエンドとやり取りする場合、平均的なアプリケーションは高速です。</font><font style="vertical-align: inherit;">しかし、バックエンドは作業の大部分を実行し、ほとんどのデータを内部で粉砕します-それにより多くの時間が費やされます。</font><font style="vertical-align: inherit;">バックエンドとDBMSの応答を待つために余分な時間が無駄になります。</font><font style="vertical-align: inherit;">アプリケーション自体のスケーリングが容易であっても、このボトルネックはまったくスケーリングしません。</font><font style="vertical-align: inherit;">バックエンドの負荷を軽減して問題を解決する方法は？</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたのサービス</font></font></b><br>
</td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックエンド</font></font></b><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各回答の正味作業時間：（de）シリアル化、チェック、ロジック、非同期コスト</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">53ミリ秒</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">785ms</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックエンドとDBMSを待機しています</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3015ミリ秒</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1932ミリ秒</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノード数</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まとめ回答</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3070ミリ秒</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2702ミリ秒</font></font><br>
</td>
</tr>
</tbody></table></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">埋め込みキャッシュ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のアイデアは、読み取るデータ、データを受信するリクエストを取得し、各メモリ内ノードのレベルでキャッシュを構成することです。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e98/e7d/18f/e98e7d18f9f43d97f36941011d82b3b4.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャッシュは、ノードが再起動して最後のデータのみが格納されるまで存続します。</font><font style="vertical-align: inherit;">アプリケーションがクラッシュし、過去1時間、1日、または1週間前にいない新しいユーザーが入った場合、アプリケーションはそれについて何もできません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代理</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のオプションはプロキシで、リクエストの一部を引き継ぐか、アプリケーションを変更します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7ff/817/a49/7ff817a49b919c269c55e9995eaca4f0.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、プロキシでは、アプリケーション自体のすべての作業を行うことはできません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュデータベース</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目のオプションは、バックエンドが返すデータの一部を長期間ストレージに置くことができる場合に注意が必要です。</font><font style="vertical-align: inherit;">それらが必要であるとき、たとえそれらがもはや関係がないとしても、私たちはクライアントを示します。</font><font style="vertical-align: inherit;">これは何もないよりはましです。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/024/8a3/72f/0248a372f78828298f116a711321a55f.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この決定について説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォールバックキャッシュ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが私たちのライブラリです。</font><font style="vertical-align: inherit;">これはアプリケーションに組み込まれ、バックエンドと通信します。</font><font style="vertical-align: inherit;">最小限の改良で、データ構造を分析し、シリアル化フォーマットを生成し、サーキットブレーカーアルゴリズムの助けを借りて、フォールトトレランスを向上させます。</font><font style="vertical-align: inherit;">効果的なシリアライゼーションは、型が十分に厳密に定義されていれば事前に分析できる任意の言語で実装できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部品</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのライブラリはこのようなものです。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/906/57c/ce0/90657cce0e43cbaf09ba1a38b3e8eaff.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左側は、このリポジトリとのやり取りに専念しています。このリポジトリには、2つの重要なコンポーネントが含まれています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化プロセスを担当するコンポーネント-フォールバックキャッシュを使用する前のDBMSでの事前アクション。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動シリアル化生成モジュール。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
右側は、フォールバックに関連する一般的な機能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのように機能しますか？</font><font style="vertical-align: inherit;">アプリケーションの途中にクエリがあり、状態を保存するための中間タイプがあります。</font><font style="vertical-align: inherit;">このフォームは、1つ以上のリクエストに対してバックエンドから受け取ったデータを表します。</font><font style="vertical-align: inherit;">パラメータをメソッドに送信し、そこからデータを取得します。</font><font style="vertical-align: inherit;">このデータは、ストレージに配置するために何らかの方法でシリアル化する必要があるため、コードでラップします。</font><font style="vertical-align: inherit;">別のモジュールがこれを担当します。</font><font style="vertical-align: inherit;">回路ブレーカーパターンを使用しました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストレージ要件</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長い貯蔵寿命-30-500日</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。一部のアクションには時間がかかる可能性があり、この間もデータの保存が必要です。したがって、データを長期間保存できるストレージが必要です。インメモリはこれには適していません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大容量のデータ-100 GB〜20 TB</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。私たちは数十テラバイトのデータをキャッシュに保存したいと考えています。これらすべてをメモリに保持することは非効率的です。ほとんどのデータが常に要求されるわけではありません。彼らは長い間嘘をつき、入って来て尋ねるユーザーを待っています。インメモリはこれらの要件に該当しません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高いデータ可用性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。サービスに何かが発生する可能性がありますが、DBMSを常に使用可能な状態にしておく必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">低い保管コスト</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">追加データをキャッシュに送信します。</font><font style="vertical-align: inherit;">その結果、オーバーヘッドが発生します。</font><font style="vertical-align: inherit;">ソリューションを実装するときは、それを最小限に抑えたいと考えています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">間隔を置い</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た</font><b><font style="vertical-align: inherit;">クエリのサポート</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私たちのデータベースは、全体のデータだけでなく、一定の間隔でデータの一部を引き出すことができたはずです：アクションのリスト、特定の期間のユーザーの履歴。</font><font style="vertical-align: inherit;">したがって、純粋なキー値は適切ではありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮定</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要件によって候補者のリストが絞り込まれます。</font><font style="vertical-align: inherit;">他のすべてを実装したと想定し、以下の仮定を行い、なぜフォールバックキャッシュが必要なのかを正確に理解します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つの異なるGET要求間のデータ整合性は必要ありません</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、それらが互いに整合しない2つの異なる状態を表示する場合、これに我慢します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データの関連性と無効化は必要ありません</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">リクエストの時点では、表示されている最新バージョンを使用していると想定されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックエンドとの間でデータを送受信します。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このデータの構造は事前にわかってい</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストレージの選択</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代替案として、3つの主要なオプションを検討しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カサンドラ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。利点：高可用性、容易なスケーラビリティ、およびUDTコレクションによる組み込みのシリアル化メカニズム。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザー定義タイプは</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、何らかの</font><b><font style="vertical-align: inherit;">タイプ</font></b><font style="vertical-align: inherit;">を意味します。構造化タイプを効率的にスタックすることができます。タイプフィールドは事前にわかっています。これらのシリアル化フィールドは、プロトコルバッファーと同様に、個別のタグでマークされます。この構造を読んだ後、タグに基づいて、どのようなフィールドがあるかを理解できます。名前とタイプを見つけるのに十分なメタデータ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cassandraのもう1つの利点は、パーティションキーの他に、追加の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスタリングキーがあることです。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、データが1つのノードに配置される特別なキーです。これにより、間隔クエリなどのオプションを実装できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cassandraは比較的長い間使用されており、そのための</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの監視ソリューションがあり</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、&nbsp; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つはJVM</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。これは、DBMSを作成できるプラットフォームで最も生産的なオプションではありません。 JVMには、ガベージコレクションとオーバーヘッドに関する問題があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のオプションは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CouchBase</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。利点：データのアクセス可能性、スケーラビリティ、スキーマレス。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CouchBaseを使用すると、シリアル化について考える必要が少なくなります。これはプラスにもマイナスにもなります。データスキームを制御する必要はありません。クラスター全体でインターバルクエリをグローバルに実行できるグローバルインデックスがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CouchBaseは、通常のDBMSの</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高速キャッシュ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><b><font style="vertical-align: inherit;">Memcacheが</font></b><font style="vertical-align: inherit;">追加されたハイブリッド</font><font style="vertical-align: inherit;">です。これにより、ノード上のすべてのデータを自動的にキャッシュできます。これは、非常に高い可用性を備えた最もホットなものです。キャッシュのおかげで、同じデータが非常に頻繁に要求される場合、CouchBaseは高速になります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スキーマレス</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と&nbsp; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSON</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もマイナスになります。データは、アプリケーションを変更する時間があるほど長期間保存できます。この場合、CouchBaseが保存および読み取るデータ構造も変更されます。以前のバージョンは互換性がない場合があります。これについては、データが本番環境のどこかにある場合、データを読み取るときではなく、データを開発するときだけ学習します。適切な移行について考える必要があり、これはまさに私たちがしたくないことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目のオプションは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タランツール</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">超高速で有名です。</font><font style="vertical-align: inherit;">LuaJit上のサーバー上で実行される一連のロジックを記述できる素晴らしいLUAエンジンを備えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、これは変更されたキー値です。</font><font style="vertical-align: inherit;">データはタプルに格納されます。</font><font style="vertical-align: inherit;">正しいシリアル化について自分で考える必要がありますが、これは必ずしも明白な作業ではありません。</font><font style="vertical-align: inherit;">Tarantoolには、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スケーラビリティ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に対する特定のアプローチもあり&nbsp; </font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">彼の何が悪いのか、私たちはさらに議論します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シャーディング/レプリケーション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプリケーションでは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シャーディング/レプリケーション</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が必要になる場合があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">3つのリポジトリは、それらを異なる方法で実装します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cassandraは、通常「リング」と呼ばれる構造を提案しています。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/387/b22/828/387b228289ece281dd70ecea2ded8890.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くのノードが利用可能です。</font><font style="vertical-align: inherit;">それらのそれぞれは、そのデータと最も近いノードからのデータをレプリカとして保存します。</font><font style="vertical-align: inherit;">ドロップアウトが発生した場合、その隣のノードは、ドロップアウトが上昇するまでデータの一部を提供できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シャーディング\レプリケーションは同じ構造を担当します。</font><font style="vertical-align: inherit;">10個とレプリケーションファクター3に展開するには、10ノードで十分です。</font><font style="vertical-align: inherit;">各ノードは、隣接するノードからの2つのレプリカを格納します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CouchBaseでは、ノード間の相互作用構造は同様に構成されています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノード自体が責任を負うアクティブとしてマークされているデータがあります。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CouchBaseが保存する隣接ノードのレプリカがあります。</font></font><br>
</li>
</ul><br>
<img src="https://habrastorage.org/getpro/habr/post_images/296/09a/1c8/29609a1c8391653566cb36ab9434da21.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つのノードが脱落すると、隣接するノードが共有され、キーのこの部分の保守を担当します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tarantoolでは、アーキテクチャはMongoDBに似ています。</font><font style="vertical-align: inherit;">しかし、微妙な違いがあります。互いに複製されるシャーディンググループがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e81/5f8/5a5/e815f85a59d330b8250071def6cc0d25.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前の2つのアーキテクチャでは、4つのシャードとレプリケーションファクター3を作成する場合、4つのノードが必要です。</font><font style="vertical-align: inherit;">Tarantoolの場合-12！</font><font style="vertical-align: inherit;">しかし、欠点はTarantoolが保証する速度によって相殺されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カサンドラ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tarantoolのシャーディング用のオプションモジュールが登場したのは、ごく最近のことです。</font><font style="vertical-align: inherit;">そのため、Cassandra DBMSを主要な候補として選択しました。</font><font style="vertical-align: inherit;">特定のシリアル化について話したことを思い出してください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動シリアル化</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLプロトコルは、データスキーマを自由に定義できることを前提としています。 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは利点として使用できます。</font><font style="vertical-align: inherit;">たとえば、葉状構造の長いフィールド名が毎回値に格納されないようにデータをシリアル化します。</font><font style="vertical-align: inherit;">この場合、データデバイスを説明するメタデータがいくつかあります。</font><font style="vertical-align: inherit;">UDT自体も、ラベルとタグが対応するフィールドを通知します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、自動生成されたシリアル化は、ほぼ同じ方法で行われます。</font><font style="vertical-align: inherit;">データベースのタイプと1対1で一致する基本タイプの1つがある場合は、それを行います。</font><font style="vertical-align: inherit;">Ins、Long、String、Double型のセットもCassandraにあります。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションデータタイプ</font></font></b><br>
</td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cassandraのデータ型</font></font></b><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリミティブ型</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（Int、Long、String、Double、BigDecimal）</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリミティブ型</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（int、biging、text、double、decimal）</font></font><br>
</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オプションのフィールドが何らかの構造で検出された場合、追加の処理は行われません。</font><font style="vertical-align: inherit;">このフィールドがどのタイプになるかを彼に示します。</font><font style="vertical-align: inherit;">構造体はnullを格納します。</font><font style="vertical-align: inherit;">逆シリアル化レベルで構造体にnullが見つかった場合、これは値ではないと見なされます。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションデータタイプ</font></font></b><br>
</td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cassandraのデータ型</font></font></b><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプション[A]</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font><br>
</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Scalaのコレクションのすべてのコレクション型は、リスト型に変換されます。</font><font style="vertical-align: inherit;">これらは、インデックスマッチング要素を持つ順序付けられたコレクションです。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションデータタイプ</font></font></b><br>
</td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cassandraのデータ型</font></font></b><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーケンス[A]、リスト[A]、ストリーム[A]、ベクトル[A]</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凍結された&lt;リスト "a"&gt;</font></font><br>
</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
順序付けられていないSetコレクションは、各値を持つ要素を1つだけ保証します。</font><font style="vertical-align: inherit;">それらのために、Cassandraには特別なセットタイプもあります。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションデータタイプ</font></font></b><br>
</td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cassandraのデータ型</font></font></b><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セット[A]</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凍結された&lt;set "a"&gt;</font></font><br>
</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も可能性が高いのは、特に文字列キーの場合、多くのマッピング（）があることです。</font><font style="vertical-align: inherit;">Cassandraには、特別なマップタイプがあります。</font><font style="vertical-align: inherit;">これも型付きで、2つの型パラメーターがあります。</font><font style="vertical-align: inherit;">どのキーにも適切なタイプを作成できるように</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションデータタイプ</font></font></b><br>
</td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cassandraのデータ型</font></font></b><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マップ[K、V]</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凍結した&lt;map "k、v"&gt;</font></font><br>
</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションで独自に定義するデータ型があります。</font><font style="vertical-align: inherit;">多くの言語では、それらは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代数的データ型</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれてい</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらは、タイプの名前付き製品、つまり構造を定義することによって定義されます。</font><font style="vertical-align: inherit;">この構造をユーザー定義タイプに割り当てます。</font><font style="vertical-align: inherit;">構造の各フィールドは、UDTの1つのフィールドに対応します。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションデータタイプ</font></font></b><br>
</td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cassandraのデータ型</font></font></b><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプ製品：ケースクラス</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDT</font></font><br>
</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のタイプは、タイプの</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代数和です</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この場合、タイプは以前に知られているいくつかのサブタイプまたはサブ種に対応します。</font><font style="vertical-align: inherit;">また、ある方法で、それに構造を割り当てます。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションデータタイプ</font></font></b><br>
</td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cassandraのデータ型</font></font></b><br>
</td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプ合計：封印された特性\クラス</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDT</font></font><br>
</td>
</tr>
</tbody></table></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDTに変換する抽象データ型</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造があり、1対1で表示します。フィールドごとに、Cassandraで作成されたUDTでフィールドを定義します。</font></font><br>
<br>
<pre><code class="plaintext hljs">case class Account (<font></font>
id: Long,<font></font>
tags: List[String],<font></font>
user: User,<font></font>
finData: Option[FinData]<font></font>
)<font></font>
<font></font>
create type account (<font></font>
id&nbsp;bigint,<font></font>
tags: frozen&lt;list&lt;text&gt;&gt;,<font></font>
user frozen&lt;user&gt;,<font></font>
fin_data frozen&lt;fin_data&gt;<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プリミティブ型はプリミティブ型に変わります。それが凍結される前に以前に定義されたタイプへの参照。これはCassandraの特別なラッパーです。つまり、このフィールドから少しずつ読み取ることはできません。ラッパーはこの状態に「凍結」されます。タグの場合と同様に、ユーザーまたはリストの読み取りまたは保存のみが可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オプションのフィールドを満たした場合、この特性は破棄されます。使用するフィールドのタイプに対応するデータタイプのみを取得します。ここで出会った場合-値がない-対応するフィールドにnullを書き込みます。読む際はヌル以外の対応も取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
既知の選択肢がいくつかある型に出会った場合は、Cassandraで新しいデータ型も定義します。選択肢ごとに、UDTのデータ型のフィールド。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、この構造では、常に1つのフィールドのみがnullになりません。</font><font style="vertical-align: inherit;">あるタイプのユーザーに出会い、実行時にモデレーターのインスタンスであることが判明した場合-モデレーターフィールドには値が含まれ、残りはnullになります。</font><font style="vertical-align: inherit;">管理者-管理者、残り-nullの場合。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、次のように構造をエンコードできます。4つのオプションフィールドがあります。これらのフィールドから1つだけが書き込まれることを保証します。</font><font style="vertical-align: inherit;">Cassandraは1つのタグのみを使用して、構造内の特定のフィールドの存在を識別します。</font><font style="vertical-align: inherit;">これにより、オーバーヘッドのないストレージ構造が実現しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、ユーザータイプを保存するために、それがモデレーターである場合、モデレーターを格納するには同じバイト数が必要です。</font><font style="vertical-align: inherit;">プラス1バイトで、ここにどの選択肢があるかを示します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化</font></font></h3><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化は予備の手順であり、フォールバックを使用する前に完了する必要があります。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロセスはどのように機能しますか？</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各ノードで、提示されたタイプに基づいて、テーブル、タイプ、およびクエリテキストの定義を生成します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DBMSから現在のスキーマを読み取ります。</font><font style="vertical-align: inherit;">Cassandraでは、これに接続するだけで簡単に実行できます。</font><font style="vertical-align: inherit;">接続すると、ほとんどすべてのドライバーで、「セッション」オブジェクト自体が、接続先のキースペースメタデータを送り出します。</font><font style="vertical-align: inherit;">次に、彼らが持っているものを見ることができます。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メタデータを調べ、比較して、作成するすべてのものが許可されており、段階的な移行が可能であることを確認します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてが正常で初期化が可能な場合は、移行を実行します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リクエストを準備中です。</font></font><br>
</li>
</ul><br>
<pre><code class="plaintext hljs">sealed trait User<font></font>
<font></font>
case class Anonymous extends User<font></font>
case class Registered extends User<font></font>
case class Moderator extends User<font></font>
case class Admin extends User<font></font>
<font></font>
create type user (<font></font>
anonymous frozen&lt;anonymous&gt;,<font></font>
registered frozen&lt;registered&gt;,<font></font>
moderator frozen&lt;moderator&gt;,<font></font>
admin frozen&lt;admin&gt;<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはこのように起こります。</font><font style="vertical-align: inherit;">我々は持っている</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テーブル、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および&nbsp; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クエリを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">タイプは他のタイプに依存し、他のタイプに依存します。</font><font style="vertical-align: inherit;">テーブルはこれらのタイプに依存します。</font><font style="vertical-align: inherit;">クエリはすでに、データを読み取るテーブルに依存しています。</font><font style="vertical-align: inherit;">初期化では、これらの依存関係をすべてチェックし、特定のルールに従って、DBMSで作成できるすべてのものを作成します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプの移行</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプを段階的に移行できることを確認するにはどうすればよいですか？</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/105/eeb/554/105eeb554bcc5eadaf10753f8c150531.jpg"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このタイプがDBMSでどのように定義されているかを読みます。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そのようなタイプがない場合、つまり、新しいタイプを考え出しました-それを作成します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そのようなタイプがすでに存在する場合、既存の定義とこのタイプに与えたい定義をフィールドごとに比較しようとしています。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存在しないフィールドをいくつか追加したい場合は、それを行います。</font><font style="vertical-align: inherit;">変更するALTER TYPE操作のリストを作成し、それらを開始します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なるタイプのフィールドがあることが判明した場合、エラーが生成されます。</font><font style="vertical-align: inherit;">たとえば、リストがありました-それはマップになりました、または1つのユーザー定義タイプへのリンクがありました、そして私たちはそれを違うものにしようとしています。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者は、プロダクションで機能を開始する前でも、このエラーを確認できます。</font><font style="vertical-align: inherit;">まったく同じデータスキームが彼の開発環境にあると思います。</font><font style="vertical-align: inherit;">彼は何らかの方法で移行不可能なデータスキーマを作成し、これらのエラーを回避するために、自動生成されたシリアル化をオーバーライドし、オプションを追加し、フィールドまたはすべてのタイプとテーブル全体の名前を変更できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化：タイプ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかのタイプの定義があると想像してください：</font></font><br>
<br>
<pre><code class="plaintext hljs">case class Product (id: Long, name: ctring, price: BigDecimal)<font></font>
case class UserOffers (valiDate: LocalDate, offers: Seq[Products])<font></font>
case class UserProducts (user User, products: Map[Date, Product])<font></font>
case class UserInfo: UserOffers, products: UserProducts)</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caseクラス</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;-一連のフィールドを含むクラス。これは、Rustのstructに類似しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4つのタイプのそれぞれについて、おおよそこのようなデータ定義を生成します。</font></font><br>
<br>
<pre><code class="plaintext hljs">CREATE TYPE product (id&nbsp;bigint, name text, price decimal);<font></font>
CREATE TYPE user_offers (valid_date date, offers frozen&lt;list&lt;frozen&lt;offer&gt;&gt;&gt;);<font></font>
CREATE TYPE user_products (user frozen&lt;user&gt;, products frozen&lt;map&lt;date, frozen&lt;product&gt;&gt;);<font></font>
CREATE TYPE user_jnfo (offers: frozen&lt;user_offers&gt;, products: frozen&lt;user_products&gt;);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
user_offersのタイプはオファーのタイプに依存し、user_productsは製品のタイプに依存し、user_infoは2番目と3番目のタイプに依存します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5bb/e3b/e9d/5bbe3be9d2694677b42b59613305752b.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプ間にこのような依存関係があり、それを正しく初期化する必要があります。この図は、user_offersとuser_productsを並行して初期化することを示しています。これは、2つの並列操作を起動することを意味するものではありません。いいえ、2つの並列スレッドで誤って同じ型を作成しないように、すべてのステートメント、すべての分析を順次開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、エラー訂正のレベルではある程度の並列性があります。タイプでエラーが発生した場合、そのタイプに依存するすべてのものが元のエラーを引き出します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/122/93f/0ba/12293f0bab8bd0a8b7e12d092380a5c5.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並列分岐のいずれかによってエラーが生成された場合、正常に移行されたデータに依存するすべてがエラーなしで生成されます。テーブルの定義、テーブルからの準備済みステートメントがある場合は、フォールバックキャッシュのこの部分を安全に初期化できます。通信は、バックエンドの一部または一部の機能でのみ失われます。残りは初期化されます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a8d/5ec/3a2/a8d5ec3a2483d899c7db16ac56974fe9.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に初期化される2つのタイプが異なるエラーを生成する場合があります。</font><font style="vertical-align: inherit;">この場合、両方のタイプに依存する機能により、合計タイプのエラーが発生します。</font><font style="vertical-align: inherit;">開発環境でフォールバックを初期化する開発者は、エラーのあるデータの完全なリストを受け取ります。</font><font style="vertical-align: inherit;">当然、彼はここでそれを修正し、さらにエラーを取得できます。</font><font style="vertical-align: inherit;">ただし、このブランチに関係なく、1つの完全に独立したブランチが、発生する可能性のあるエラーを閉じるわけではありません。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d08/e94/4ba/d08e944ba9b210d16f6f6c0b57048051.jpg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化：テーブル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、テーブルを作成します。</font></font><br>
<br>
<pre><code class="plaintext hljs">def getOffer (user: User, number: Long): Future[OfferData]<font></font>
<font></font>
create table get_offer(<font></font>
key frozen&lt;tuple&lt;frozen&lt;user&gt;, bigint&gt;&gt;PRIMARY KEY,<font></font>
value frozen&lt;friend_data&gt;<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような要求は、RESTまたはSOAP要求を直接起動したり、内部に追加の操作を作成したり、複数の要求を実行したりすることもできます。</font><font style="vertical-align: inherit;">それはすべてあなたのコードに依存します-あなたがコードをどのように編成したかはそうです。</font><font style="vertical-align: inherit;">フォールバックは、そのようなスタブをハングさせたメソッドの内部で何が発生するかを絶対に分析しません。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォールバックは同じなので、メソッドは非同期でなければなりません。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Scalaでは、これは特別なタイプのFutureでタグ付けされています。</font><font style="vertical-align: inherit;">これは、結果がいつか返されることを意味します。</font><font style="vertical-align: inherit;">正確には-それは不明です：多分すぐに、または多分そうではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドのテーブルを作成します。</font><font style="vertical-align: inherit;">表のキーは、このメソッドのパラメーターに対応するすべてのタイプのタプルです。</font><font style="vertical-align: inherit;">非キー値は結果であり、非同期で返されます。</font><font style="vertical-align: inherit;">そのようなテーブルごとに、2つのパラメトリッククエリを事前に準備します。データの挿入とデータの読み取りです。</font></font><br>
<br>
<pre><code class="plaintext hljs">insert into get_offer(key, value) values (?key, ?value);<font></font>
<font></font>
select value from get_offer where key = ?key;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてがDBMSと対話する準備ができています。</font><font style="vertical-align: inherit;">フォールバックからデータを読み取る方法を見つけることはまだ残っています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遮断器</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、責任は有名なサーキットブレーカーパターンのゾーンに移ります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5c0/de1/91c/5c0de191c5c1699cc8f324f38d62b6ee.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的なサーキットブレーカーには3つの状態があります。</font><font style="vertical-align: inherit;">Closed-バックエンドを閉じる</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトの閉じた状態</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。原則は、最初にバックエンドからデータを読み取り、取得できなかった場合にのみ、フォールバックに進むことです。なんとかデータを取得できた場合は、フォールバックを調べずにデータを保存しますが、何も起こりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題が次々に発生する場合は、バックエンドが嘘であると想定します。膨大な量の新しいリクエストでスパムを送信しないよう</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、引き裂かれた状態でOpen-に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">切り替え&nbsp; </font><font style="vertical-align: inherit;">ます。その中で、フォールバックからのみデータを読み取ろうとしています。うまくいかない場合は、すぐにエラーが返され、メインのバックエンドには触れません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しばらくして、バックエンドが起動したかどうかを確認して、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハーフオープン状態（短命な状態）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をリセットしようとし</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">彼の寿命は一つの要求です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短期間の状態では、再び閉じるか、さらに長い時間開くかを選択します。</font><font style="vertical-align: inherit;">ハーフオープン状態でフォールバックに成功し、次のリクエストを受け取った場合、クローズ状態に切り替えます。</font><font style="vertical-align: inherit;">うまくいかなかった場合は、Openに戻りますが、長い間です。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/9ad/92e/4a4/9ad92e4a417201c8655ed4785ae21dfc.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回路ブレーカー回路に明らかに関連しない2つの状態を追加しました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">強制-強制的に閉じた状態。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逆-開いた状態と閉じた状態の優先順位が逆になります。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らが何をするか見てみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">国家の運営の原則</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クローズド</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">スキームは大きいですが、それから一般的な原理を理解するには十分です。</font><font style="vertical-align: inherit;">すべてがうまくいき、Fallbackから読み取った場合、Fallbackをバックエンドから結果を返す方法と並行して維持します。</font><font style="vertical-align: inherit;">どこでも問題がある場合は、エラーの優先度を返します。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つのエラーのうち、バックエンドエラーを選択します。</font></font></blockquote><br>
<img src="https://habrastorage.org/getpro/habr/post_images/5b7/541/f99/5b7541f99197cc1730c6a934cebe6516.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラーがない場合は、これと並行してカウンターをインクリメントし、リクエストが多すぎる場合はオープン状態に切り替えます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/182/18f/25d/18218f25de112cf7f6a88291fccbe72f.jpg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ザオープン</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Openのオープン状態の方が簡単です。何が起こっても、常にフォールバックから読み取り、しばらくしてからハーフオープン状態に切り替えようとします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハーフオープン</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。構造の状態はClosedに似ています。違いは、回答が成功した場合、クローズ状態になることです。失敗した場合-長い間隔でオープンに戻ります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b82/a1e/7c8/b82a1e7c89774bbe327613b51f50f5c0.jpg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">強制は、キャッシュをウォームアップするための追加の状態です</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。データを入力すると、フォールバックからの読み取りは行われず、レコードが追加されるだけです。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bdc/8e3/b33/bdc8e3b335750b826fdd21db6c0f0ac7.jpg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反転-2番目に遠いフェッチ状態</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">永続的なキャッシュのように機能します。</font><font style="vertical-align: inherit;">データが無関係である場合でも、バックエンドから負荷を完全に削除する場合は、状態をオンにします。</font><font style="vertical-align: inherit;">フォールバックでは最初に逆検索が行われ、検索が失敗した場合はバックエンドに移動して処理されます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/618/0da/8ed/6180da8edf69398780bd37fae9bc8ba7.jpg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この全体的なスキームでは、いくつかの問題がありました。最も深刻なのは</font><font style="vertical-align: inherit;">、Cassandraで</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準備されたステートメント</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がどのように機能するかを理解することです</font><font style="vertical-align: inherit;">。この問題は、まだリリースされていないバージョン4.0で修正されているので、お知らせします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cassandraは、何百万ものクライアントを同時に接続するように設計されており、誰もが準備済みのステートメントを準備しようとしています。当然、Cassandraは準備されたすべてのステートメントを準備するわけではありません。準備しないと、メモリが不足します。テキスト、キースペース、クエリオプションに基づいてMD5パラメータを計算します。まったく同じMD5でまったく同じリクエストを受け取った場合、彼女はすでに準備されたリクエストを受け取ります。メタデータとその処理方法に関する情報はすでにあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、バージョンの問題があります。私たちは新しいリリースをリリースしています。それは、移行をうまく展開し、タイプにフィールドを追加し、準備されたステートメントを実行します。以前のバージョンの状態とメタデータが返されます-フィールドのない型が含まれます。データの読み取り時に、私たちはそれらの新しい必須列を書き込もうとしていますが、それらは単に存在しないという事実に直面しています！カサンドラは、これは一般的に彼女が知らない別のタイプであると言います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題には次のように対処し</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><b><font style="vertical-align: inherit;">準備した各リクエストに一意のテキスト</font></b><font style="vertical-align: inherit;">を</font><b><font style="vertical-align: inherit;">追加しました</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">create table get_offer(<font></font>
key frozen&lt;tuple&lt;frozen&lt;user&gt;, bigint&gt;&gt; PRIMARY KEY,<font></font>
value frozen&lt;friend_data&gt;,<font></font>
query_tag text<font></font>
)<font></font>
<font></font>
insert into get_offer (key, value, query_tag)<font></font>
values (?key, ?value, ‘tag_123’);<font></font>
<font></font>
select value as&nbsp;tag_123 from get_offer where key = ?key;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数百万の接続されたクライアントはありませんが、複数の接続を保持するノードごとに1つのセッションのみが存在します。準備文ごとに1回。アプリケーションの各バージョンまたはノードの開始ごとに、リクエストのテキストに含まれる一意のテキストが生成されても問題ないと想定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは彼をだますために特別なフィールドを追加しました。挿入するとき、このフィールドに定数を書き込みます。これは、起動またはアプリケーションのバージョンごとに固有です-これはライブラリで構成されます。読み取るとき、取得した値のエイリアスとしてこの名前を使用します。リクエストはまったく同じです。値を選択していますが、テキストが異なります。 Cassandraは、これが同じリクエストであることを認識せず、別のMD5を計算し、新しいメタデータを使用してリクエストを再度準備します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の問題は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移行レース</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">たとえば、いくつかの並行移行を行います。</font><font style="vertical-align: inherit;">いくつかのノードを開始し、同時に計算を開始して、テーブルの作成、タイプの作成を実行します。</font><font style="vertical-align: inherit;">これは、各ノードまたは各並列スレッドですべてが成功し、2つのテーブルが正常に作成されているように見えるという事実につながる可能性があります。</font><font style="vertical-align: inherit;">しかし、Cassandra内では混乱し、書き込みと読み取りのタイムアウトが発生します。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数のスレッドまたは複数のノードからプロセスを並列化しようとすると、Cassandraを中断できます。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォールバック移行が必要であることがわかっている場合は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リリース前に1つの特別なノードから移行します</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。その後、リリース中にすべてのノードを起動します。この問題を解決しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目の問題は、&nbsp; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォールバックキャッシュにデータがないことです</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。メソッドを「フルバック」した可能性があります。1年前の履歴データを保存する必要がありますが、実際には昨日立ち上げました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この問題はウォームアップによって解決されました</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。強制状態を使用し、実際のユーザーと通信しない特別なノードを起動しました。それらは、私たちが想定するすべての可能なキーを取得し、キャッシュを円状にウォームアップします。ウォーミングアップは非常に速く進んでいるので、読んでいるバックエンドを殺さないようになっています。</font></font><br>
<br>
<blockquote> , ,   &nbsp;&nbsp;—     Scala.&nbsp;26&nbsp; &nbsp;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  Scala-</a>. , ,      &nbsp;&nbsp; ,    &nbsp; ,   ,    &nbsp;—      . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a> &nbsp;,      &nbsp;Scala &nbsp;26&nbsp;,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja466281/index.html">バーチャルリアリティ、オープンソースゲーム、電気自動車：ジョンカーマックがポッドキャストジョーローガンで言ったこと</a></li>
<li><a href="../ja466283/index.html">Opencartforumと友達</a></li>
<li><a href="../ja466285/index.html">ちょっとした景品：ラッフルコンボDVRとレーダー探知機</a></li>
<li><a href="../ja466289/index.html">立法イニシアチブ。奇妙ですが、州下院に紹介されました</a></li>
<li><a href="../ja466291/index.html">2019年の全国インターネットセグメントの持続可能性調査</a></li>
<li><a href="../ja466299/index.html">ロシアの社会学者が世界初のチャットボット調査を実施</a></li>
<li><a href="../ja466301/index.html">その他：Haikuアプリパッケージ？</a></li>
<li><a href="../ja466305/index.html">国分隆史：Rubyアプリケーションの実行速度を上げる方法</a></li>
<li><a href="../ja466307/index.html">SCSの設計方法</a></li>
<li><a href="../ja466311/index.html">SLSワークショップ9月6日</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>