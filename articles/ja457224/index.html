<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂 👩🏾‍✈️ 👩🏾‍💻 Androidでの競争に対する最新のアプローチ：Kotlinコルーチン 🙇🏾 🙏🏾 👨🏾‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！有名なBig Nerd Ranch Guidesシリーズから、待望のKotlin言語の本の予約注文
 
 がすでに行われていることを思い出します。本日、KotlinコルーチンとAndroidでのストリームの正しい処理について説明する記事の翻訳を注目することにしました。このトピック...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Androidでの競争に対する最新のアプローチ：Kotlinコルーチン</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/457224/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！</font><font style="vertical-align: inherit;">有名なBig Nerd Ranch Guidesシリーズから、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">待望</font></a><font style="vertical-align: inherit;">のKotlin言語の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">本の予約注文</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
がすでに行われていることを思い出します</font><font style="vertical-align: inherit;">。本日、KotlinコルーチンとAndroidでのストリームの正しい処理について説明する記事の翻訳を注目することにしました。このトピックは非常に活発に議論されているため、完全</font><font style="vertical-align: inherit;">を期すために、Habrの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">この記事</font></a><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">Axmor Softwareブログの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">この詳細な投稿を</font></a><font style="vertical-align: inherit;">ご覧になる</font><font style="vertical-align: inherit;">ことをお勧めします</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java / Androidの最新の競合するフレームワークはコールバックに地獄を与え、ブロッキング状態につながります。これは、Androidにはスレッドの安全性を保証するためのかなり単純な方法がないためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kotlinコルーチンは非常に効果的で完全なツールキットであり、競争の管理をはるかに簡単かつ生産的にします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一時停止とブロック：</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コルーチンはスレッドを置き換えるのではなく、スレッドを管理するためのフレームワークを提供するという</font><b><font style="vertical-align: inherit;">違いは何</font></b><font style="vertical-align: inherit;">ですか。 corutinの哲学は</font><font style="vertical-align: inherit;">、メインスレッドをブロックせずにバックグラウンド操作が完了</font><font style="vertical-align: inherit;">するのを</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待つ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことができるコンテキストを定義することです</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合のコルティンの目標は、コールバックを省略して競争を簡素化することです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も単純な例</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、最も簡単な例を見てみましょう</font></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">コンテキスト</font><font style="vertical-align: inherit;">（メインスレッド）で</font><font style="vertical-align: inherit;">コルーチンを実行します</font><font style="vertical-align: inherit;">。その中で、ストリームから画像を抽出し、</font></font><code>IO</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この画像を処理のためにに送り返し</font></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="kotlin hljs">launch(Dispatchers.Main) {
    <span class="hljs-keyword">val</span> image = withContext(Dispatchers.IO) { getImage() } <span class="hljs-comment">//    IO</span>
    imageView.setImageBitmap(image) <span class="hljs-comment">//    </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードはシングルスレッド関数のように単純です。さらに、</font></font><code>getImage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">専用スレッドプール</font></font><code>IO</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">実行されている間</font><font style="vertical-align: inherit;">、メインスレッドは解放され、他のタスクを実行できます。 withContext関数は、アクション（</font></font><code>getImage()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">実行中に現在のコルーチンを一時停止し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">メインスレッドから</font></font><code>getImage()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">戻って</font></font><code>looper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アクセスできる</font><font style="vertical-align: inherit;">よう</font><font style="vertical-align: inherit;">になると</font><font style="vertical-align: inherit;">すぐに</font><font style="vertical-align: inherit;">、コルーチンはメインスレッドで作業を再開し、を呼び出します</font></font><code>imageView.setImageBitmap(image)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の例：2つのバックグラウンドタスクを使用できるように完了する必要があります。これらの2つのタスクが並行して実行されるようにasync / awaitデュエットを使用し、両方のタスクの準備ができたらすぐにメインスレッドでその結果を使用します。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> job = launch(Dispatchers.Main) {
    <span class="hljs-keyword">val</span> deferred1 = async(Dispatchers.Default) { getFirstValue() }
    <span class="hljs-keyword">val</span> deferred2 = async(Dispatchers.IO) { getSecondValue() }<font></font>
    useValues(deferred1.await(), deferred2.await())<font></font>
}<font></font>
job.join() <span class="hljs-comment">//    ,     </span></code></pre><br>
<code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同様</font></font><code> launch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですが、</font></font><code>deferred</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Kotlinエンティティと同等</font></font><code>Future</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">返す</font><font style="vertical-align: inherit;">ため、その結果はを使用して取得できます</font></font><code>await()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。パラメータなしで呼び出されると、現在のスコープのデフォルトのコンテキストで機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでも、2つの値を待つ間、メインスレッドは解放されたままです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、関数</font></font><code>launch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が返されます</font></font><code>Job</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、操作が完了するまで待機するために使用できます</font></font><code>join()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは関数を使用して行われます</font><font style="vertical-align: inherit;">。これは他の言語と同じように機能しますが</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コルーチンを一時停止する</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">だけで</font><b><font style="vertical-align: inherit;">、フローをブロックしない</font></b><font style="vertical-align: inherit;">ことに注意して</font><font style="vertical-align: inherit;">ください。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">派遣</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コルーチンを使用する場合、ディスパッチは重要な概念です。</font><font style="vertical-align: inherit;">このアクションにより、あるスレッドから別のスレッドに「ジャンプ」できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
javaがでのディスパッチと同等のように見えることを考えてください</font></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。つまり、</font></font><br>
<br>
<pre><code class="kotlin hljs">runOnUiThread:
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> void runOnUiThread(Runnable action) {
    <span class="hljs-keyword">if</span> (Thread.currentThread() != mUiThread) {<font></font>
        mHandler.post(action); <span class="hljs-comment">// </span>
    } <span class="hljs-keyword">else</span> {<font></font>
        action.run(); <span class="hljs-comment">//  </span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android </font><font style="vertical-align: inherit;">
のコンテキスト実装</font><font style="vertical-align: inherit;">はディスパッチャベース</font></font><code>Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">したがって、これは確かに非常に適切な実装です。</font></font><br>
<br>
<pre><code class="kotlin hljs">launch(Dispatchers.Main) { ... }<font></font>
        vs<font></font>
launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED) { ... }<font></font>
<font></font>
<font></font>
<span class="hljs-comment">//   kotlinx 0.26:</span>
launch(Dispatchers.Main.immediate) { ... }</code></pre><br>
<code>launch(Dispatchers.Main)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で送信</font></font><code>Runnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font></font><code>Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、そのコードはすぐには実行されません。</font></font><br>
<br>
<code>launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のスレッドでラムダ式をすぐに実行します。</font></font><br>
<br>
<code>Dispatchers.Main</code> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチンが作業を再開すると、メインスレッドに送られることを保証します</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">さらに、ハンドラーは、アプリケーションイベントループに送信するAndroidのネイティブ実装としてここで使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正確な実装は次のようになります。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> Main: HandlerDispatcher = HandlerContext(mainHandler, <span class="hljs-string">"Main"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、Androidでのディスパッチの複雑さを理解するのに役立つ優れた記事です</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。Androidコアの理解：Looper、Handler、およびHandlerThread</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチン</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コンテキスト</font><b><font style="vertical-align: inherit;">コルーチン</font></b><font style="vertical-align: inherit;">コンテキスト（別名コルーチンマネージャー）は、コードが実行されるスレッド、例外がスローされた場合の処理​​を決定し、親コンテキストを参照してキャンセルを伝達します。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> job = Job()
<span class="hljs-keyword">val</span> exceptionHandler = CoroutineExceptionHandler {<font></font>
    coroutineContext, throwable -&gt; whatever(throwable)<font></font>
}<font></font>
<font></font>
launch(Disaptchers.Default+exceptionHandler+job) { ... }</code></pre><br>
<code>job.cancel()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">親がであるすべてのコルーチンをキャンセルします</font></font><code>job</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 exceptionHandlerは、これらのコルーチンでスローされたすべての例外を受け取ります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スコープ</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
インターフェイスは</font></font><code>coroutineScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラー処理を簡素化します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その子コルーチンのいずれかが失敗すると、スコープ全体とすべての子コルーチンも失敗します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例</font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、値を抽出することができなかった場合、別のタスクが引き続き機能している間に、破損した状態が発生しているため、それに対して何らかの処置を行う必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
で作業する場合</font></font><code>coroutineScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の機能、それは</font></font><code>useValues</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">両方の値の抽出が成功した場合にのみ呼び出されます。また、</font></font><code>deferred2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拒否</font></font><code>deferred1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">された</font><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">キャンセルとなります。</font></font><br>
<br>
<pre><code class="kotlin hljs">coroutineScope { 
    <span class="hljs-keyword">val</span> deferred1 = async(Dispatchers.Default) { getFirstValue() }
    <span class="hljs-keyword">val</span> deferred2 = async(Dispatchers.IO) { getSecondValue() }<font></font>
    useValues(deferred1.await(), deferred2.await())<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、クラス全体に「スコープを設定」して、</font></font><code>CoroutineContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトの</font><font style="vertical-align: inherit;">コンテキストを設定し、</font><font style="vertical-align: inherit;">使用する</font><font style="vertical-align: inherit;">こと</font><font style="vertical-align: inherit;">もできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターフェースを実装するクラスの例</font></font><code>CoroutineScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScopedViewModel</span> : <span class="hljs-type">ViewModel</span></span>(), CoroutineScope {
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> job = Job()
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext = Dispatchers.Main+job<font></font>
<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCleared</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.onCleared()<font></font>
        job.cancel()<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
でのCorutinの起動</font></font><code>CoroutineScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスパッチャー</font></font><code>launch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはが</font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、デフォルトで現在のスコープのディスパッチャーになります。</font></font><br>
<br>
<pre><code class="kotlin hljs">launch {
    <span class="hljs-keyword">val</span> foo = withContext(Dispatchers.IO) { … }
    <span class="hljs-comment">// -    CoroutineContext   </span><font></font>
    …<font></font>
}<font></font>
<font></font>
launch(Dispatchers.Default) {<font></font>
    <span class="hljs-comment">// -       </span><font></font>
    …<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コルーチンの自律的な起動（CoroutineScopeの外部）：</font></font><br>
<br>
<pre><code class="kotlin hljs">GlobalScope.launch(Dispatchers.Main) {
    <span class="hljs-comment">// -    .</span><font></font>
    …<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトの</font><font style="vertical-align: inherit;">
ディスパッチャーを設定して、アプリケーションのスコープを定義することもでき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">object</span> AppScope : CoroutineScope <span class="hljs-keyword">by</span> GlobalScope {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext = Dispatchers.Main.immediate<font></font>
}<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">備考</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチンはJavaとの相互運用性を制限する </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可変性を制限してロックを回避する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチンはスレッドを整理するのではなく、待機するように設計されています</font></font></li>
<li><font style="vertical-align: inherit;"></font><code>Dispatchers.Default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（および</font></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...）</font><font style="vertical-align: inherit;">でI / Oを回避する</font><font style="vertical-align: inherit;">-これがDispatchers.IOの目的です</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームはリソースを消費するため、シングルスレッドのコンテキストが使用されます </font></font></li>
<li><code>Dispatchers.Default</code><font style="vertical-align: inherit;"></font><code>ForkJoinPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android 5以降に登場したものに</font><font style="vertical-align: inherit;">基づく</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチンはチャネルを通じて使用できます</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チャネルを使用してロックとコールバックを取り除きます</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
。JetBrainsのドキュメントの</font><b><font style="vertical-align: inherit;">チャネル</font></b><font style="vertical-align: inherit;">定義：</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チャネルは</font></font><code>Channel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概念的に</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">に非常に似てい</font></font><code>BlockingQueue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">主な違いは、書き込み操作をブロックせず、一時停止</font></font><code>send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（または非</font></font><code> offer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロック）を提供し、取得操作をブロックする代わりに、一時停止を提供すること</font></font><code>receive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font></blockquote><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アクター</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
チャンネルを操作するための簡単なツールを考えてみましょう</font></font><code>Actor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<code>Actor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、これも非常に似て</font></font><code>Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">います。コルーチンのコンテキスト（つまり、アクションを実行するスレッド）を定義し、それを順番に操作します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、違いは、コルチンがここで使用されていることです。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パワー、および実行されるコード-一時停止を指定できます</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則として、</font></font><code>actor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンドはコルーチンチャネルにリダイレクトされます。</font><font style="vertical-align: inherit;">これは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そのコンテキストでコマンドと制限し操作の実行を保証します</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このアプローチは、呼び出し</font></font><code>synchronize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">取り除き、</font><font style="vertical-align: inherit;">すべてのスレッドをフリーに保つの</font><font style="vertical-align: inherit;">に完全に役立ちます</font><font style="vertical-align: inherit;">！</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> updateActor <span class="hljs-keyword">by</span> lazy {<font></font>
    actor&lt;Update&gt;(capacity = Channel.UNLIMITED) {<font></font>
        <span class="hljs-keyword">for</span> (update <span class="hljs-keyword">in</span> channel) <span class="hljs-keyword">when</span> (update) {<font></font>
            Refresh -&gt; updateList()<font></font>
            <span class="hljs-keyword">is</span> Filter -&gt; filter.filter(update.query)
            <span class="hljs-keyword">is</span> MediaUpdate -&gt; updateItems(update.mediaList <span class="hljs-keyword">as</span> List&lt;T&gt;)
            <span class="hljs-keyword">is</span> MediaAddition -&gt; addMedia(update.media <span class="hljs-keyword">as</span> T)
            <span class="hljs-keyword">is</span> MediaListAddition -&gt; addMedia(update.mediaList <span class="hljs-keyword">as</span> List&lt;T&gt;)
            <span class="hljs-keyword">is</span> MediaRemoval -&gt; removeMedia(update.media <span class="hljs-keyword">as</span> T)<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<span class="hljs-comment">// </span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">filter</span><span class="hljs-params">(query: <span class="hljs-type">String</span>?)</span></span> = updateActor.offer(Filter(query))
<span class="hljs-comment">// </span>
<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">filter</span><span class="hljs-params">(query: <span class="hljs-type">String</span>?)</span></span> = updateActor.send(Filter(query))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、シールされたKotlinクラスを使用して、実行するアクションを選択します。 </font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Update</span></span>
<span class="hljs-keyword">object</span> Refresh : Update()
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Filter</span></span>(<span class="hljs-keyword">val</span> query: String?) : Update()
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediaAddition</span></span>(<span class="hljs-keyword">val</span> media: Media) : Update()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、これらのアクションはすべてキューに入れられ、並列に実行されることはありません。これは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変動限界</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を達成するための便利な方法</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Androidライフサイクル+コルーチン</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
アクターは、Androidユーザーインターフェイスの管理、タスクのキャンセルの簡素化、メインスレッドの過負荷の防止にも非常に役立ちます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを実装して</font></font><code>job.cancel()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、アクティビティが破棄されたときに</font><font style="vertical-align: inherit;">呼び出しましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>(), CoroutineScope {
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> job = SupervisorJob() <span class="hljs-comment">//  Job   </span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> coroutineContext = Dispatchers.Main.immediate+job<font></font>
<font></font>
<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.onDestroy()<font></font>
        job.cancel() <span class="hljs-comment">//     </span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクラス</font></font><code> SupervisorJob</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は通常</font><font style="vertical-align: inherit;">のクラス</font><font style="vertical-align: inherit;">と似てい</font></font><code>Job</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ますが、キャンセルは下流方向にのみ適用されるという点が異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、コルーチンの</font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つが失敗</font><font style="vertical-align: inherit;">しても</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">すべてのコルーチンをキャンセルすることはありませ</font><font style="vertical-align: inherit;">ん。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
物事は少し良いとされている</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拡張機能</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それへのオープンアクセスにあなたを可能にする、</font></font><code>CoroutineContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あらゆるから</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の中で</font></font><code>CoroutineScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> View.coroutineContext: CoroutineContext?
    <span class="hljs-keyword">get</span>() = (context <span class="hljs-keyword">as</span>? CoroutineScope)?.coroutineContext</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これでこれらすべてを組み合わせることができます。関数</font></font><code>setOnClick</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、そのアクションを制御する統合アクターを作成します</font></font><code>onClick</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">複数のタップの場合、中間アクションは無視されるため、ANRエラー（アプリケーションは応答しません）が排除され、これらのアクションはスコープ内で実行されます</font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、アクティビティが破棄されると、これらすべてがキャンセルされます。</font></font><br>
 <br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">setOnClick</span><span class="hljs-params">(action: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    <span class="hljs-comment">//        </span>
    <span class="hljs-keyword">val</span> scope = (context <span class="hljs-keyword">as</span>? CoroutineScope)?: AppScope
    <span class="hljs-keyword">val</span> eventActor = scope.actor&lt;<span class="hljs-built_in">Unit</span>&gt;(capacity = Channel.CONFLATED) {
        <span class="hljs-keyword">for</span> (event <span class="hljs-keyword">in</span> channel) action()<font></font>
    }<font></font>
    <span class="hljs-comment">//      </span>
    setOnClickListener { eventActor.offer(<span class="hljs-built_in">Unit</span>) }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、</font><font style="vertical-align: inherit;">イベントが多すぎる場合に一部のイベントを無視するように</font></font><code>Channel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">を設定し</font><font style="vertical-align: inherit;">ます</font></font><code>Conflated</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>Channel.UNLIMITED</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントを失うことなくイベントをキューに入れたいが、それでもANRエラーからアプリケーションを保護したい場合</font><font style="vertical-align: inherit;">は、これを置き換えることが</font><font style="vertical-align: inherit;">できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コルーチンとライフサイクルフレームワークを組み合わせて、ユーザーインターフェイスに関連するタスクのキャンセルを自動化することもできます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> LifecycleOwner.untilDestroy: Job <span class="hljs-keyword">get</span>() {
    <span class="hljs-keyword">val</span> job = Job()<font></font>
<font></font>
    lifecycle.addObserver(<span class="hljs-keyword">object</span>: LifecycleObserver {
        <span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span>
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> { job.cancel() }<font></font>
    })<font></font>
<font></font>
    <span class="hljs-keyword">return</span> job<font></font>
}<font></font>
<span class="hljs-comment">// </span><font></font>
GlobalScope.launch(Dispatchers.Main, parent = untilDestroy) {<font></font>
    <span class="hljs-comment">/*    ! */</span>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバックによる状況の簡略化（パート1）</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コールバックベースのAPIの使用を変換する方法を以下に示します</font></font><code>Channel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
APIは次のように機能します。</font></font><br>
<br>
<ol>
<li><code>requestBrowsing(url, listener)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にあるフォルダの解析を開始します</font></font><code>url</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスナー</font></font><code>listener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>onMediaAdded(media: Media)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、このフォルダーで見つかったメディアファイル</font><font style="vertical-align: inherit;">を受け取り</font><font style="vertical-align: inherit;">ます。</font></font></li>
<li><code>listener.onBrowseEnd()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> フォルダを解析した後に呼び出されます</font></font></li>
</ol><br><font style="vertical-align: inherit;"></font><code>refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VLCブラウザーのコンテンツプロバイダーの</font><font style="vertical-align: inherit;">
古い機能</font><font style="vertical-align: inherit;">を次に示します。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> refreshList = mutableListOf&lt;Media&gt;()<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span></span> = requestBrowsing(url, refreshListener)<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> refreshListener = <span class="hljs-keyword">object</span> : EventListener{
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMediaAdded</span><span class="hljs-params">(media: <span class="hljs-type">Media</span>)</span></span> {<font></font>
        refreshList.add(media))<font></font>
    }<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBrowseEnd</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">val</span> list = refreshList.toMutableList()<font></font>
        refreshList.clear()<font></font>
        launch {<font></font>
            dataset.value = list<font></font>
            parseSubDirectories()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それを改善するには？</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
で実行するチャネルを作成します</font></font><code>refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これで、ブラウザのコールバックは、メディアをこのチャネルに転送して閉じるだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで機能</font></font><code>refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が明確になりました。</font><font style="vertical-align: inherit;">彼女はチャンネルを作成し、VLCブラウザーを呼び出し、メディアファイルのリストを作成して処理します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数の代わりに、</font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font><font style="vertical-align: inherit;">メディアを待機するために</font></font><code>consumeEach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用でき</font><font style="vertical-align: inherit;">ます。</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このサイクルは、チャネル</font></font><code>browserChannel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が閉じる</font><font style="vertical-align: inherit;">とすぐに中断し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> browserChannel : Channel&lt;Media&gt;<font></font>
<font></font>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMediaAdded</span><span class="hljs-params">(media: <span class="hljs-type">Media</span>)</span></span> {<font></font>
    browserChannel.offer(media)<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBrowseEnd</span><span class="hljs-params">()</span></span> {<font></font>
    browserChannel.close()<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span></span> {<font></font>
    browserChannel = Channel(Channel.UNLIMITED)<font></font>
    <span class="hljs-keyword">val</span> refreshList = mutableListOf&lt;Media&gt;()<font></font>
    requestBrowsing(url)<font></font>
    <span class="hljs-comment">//       </span>
    <span class="hljs-keyword">for</span> (media <span class="hljs-keyword">in</span> browserChannel) refreshList.add(media)
    <span class="hljs-comment">//  </span><font></font>
    dataset.value = refreshList<font></font>
    parseSubDirectories()<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバックを使用して状況を簡略化します（パート2）：改造</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
2番目のアプローチ：Kotlinxコルーチンはまったく使用しませんが、コルーチンコアフレームワークを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コルーチンが実際にどのように機能するかを見てください！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数は</font></font><code>retrofitSuspendCall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、呼び出し要求</font></font><code>Retrofit Call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">ラップ</font><font style="vertical-align: inherit;">して、関数を作成します</font></font><code>suspend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
助けを借りて</font></font><code>suspendCoroutine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、私たちメソッドを呼び出す</font></font><code>Call.enqueue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とコルーチンを中断。この方法で提供されるコールバックは</font></font><code>continuation.resume(response)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、サーバーからの応答が受信されるとすぐにコルーチンを再開する</font><font style="vertical-align: inherit;">ようにアピールし</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、</font></font><code>retrofitSuspendCall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クエリの結果を返すために</font><font style="vertical-align: inherit;">、Retrofit関数を組み合わせるだけです</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">suspend</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span>  <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">retrofitSuspendCall</span><span class="hljs-params">(request: () -&gt; <span class="hljs-type">Call</span> &lt;<span class="hljs-type">T</span>&gt;
)</span></span> : Response &lt;T&gt; = suspendCoroutine { continuation -&gt;<font></font>
    request.invoke().enqueue(<span class="hljs-keyword">object</span> : Callback&lt;T&gt; {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, response: <span class="hljs-type">Response</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> {<font></font>
            continuation.resume(response)<font></font>
        }<font></font>
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> {<font></font>
            continuation.resumeWithException(t)<font></font>
        }<font></font>
    })<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">browse</span><span class="hljs-params">(path: <span class="hljs-type">String</span>?)</span></span> = retrofitSuspendCall {<font></font>
    ApiClient.browse(path)<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//  (   Main)</span>
livedata.value = Repo.browse(path)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ネットワークをブロックする呼び出しは専用のレトロフィットストリームで行われ、コルーチンはここにあり、サーバーからの応答を待っており、アプリケーションでそれを使用する場所がありません！</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この実装は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gildor / kotlin-coroutines-retrofitライブラリに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">触発されてい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JakeWharton / retrofit2-kotlin-コルーチン・アダプタは、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同様の結果を与える別の実装と。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エピローグ</font></font></b><br>
<br>
<code>Channel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は他の多くの方法で使用できます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BroadcastChannelを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調べて</font><font style="vertical-align: inherit;">、役立つと思わ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">れる</font></a><font style="vertical-align: inherit;">より強力な実装を</font><font style="vertical-align: inherit;">確認してください</font><font style="vertical-align: inherit;">。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">プロデュース</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
機能を使用してチャネルを作成することもできます</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、チャネルを使用すると、UIのコンポーネント間の通信を整理するのに便利です。アダプタは</font></font><code>Channel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、たとえばを介して、</font><font style="vertical-align: inherit;">フラグメント/アクティビティにクリックイベントを送信できます</font></font><code>Actor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja457198/index.html">ニューラルネットワークは、テキスト記述から複雑なシーンを描くことを学びました</a></li>
<li><a href="../ja457202/index.html">製品開発のアイデアをどのように選択するか：ベンダーは聞くことができなければなりません...</a></li>
<li><a href="../ja457204/index.html">Windows PowerShellとロングパス</a></li>
<li><a href="../ja457210/index.html">静的リソースをホスティングに保存する</a></li>
<li><a href="../ja457212/index.html">Java（または他のJava言語）の学習を開始するのに遅すぎることがないのはなぜですか</a></li>
<li><a href="../ja457232/index.html">ロボット蜂「バンブル」-ISS内での最初のテスト飛行</a></li>
<li><a href="../ja457234/index.html">製品認知バイアス</a></li>
<li><a href="../ja457236/index.html">IT企業が音楽の販売に苦労した方法</a></li>
<li><a href="../ja457240/index.html">今週のニュース：ニューラルネットワークと写真の画像、Yandexの株式の成長、Huaweiは特許に10億ドルが必要</a></li>
<li><a href="../ja457246/index.html">C ++ 17、タプル、そして少しのファンタジーを使用してCortexMで4つのLEDを点滅させる方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>