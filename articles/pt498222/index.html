<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÜ üì´ ‚ôªÔ∏è ZX Spectrum de coronav√≠rus e paus (na verdade, n√£o realmente) ü§≥üèø üîÜ üòª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O auto-isolamento √© o flagelo da humanidade moderna. Aqui, por exemplo, na cidade vizinha, √†s sextas e s√°bados, depois das tradicionais palmas √†s 20h,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ZX Spectrum de coronav√≠rus e paus (na verdade, n√£o realmente)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498222/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O auto-isolamento √© o flagelo da humanidade moderna. Aqui, por exemplo, na cidade vizinha, √†s sextas e s√°bados, depois das tradicionais palmas √†s 20h, eles organizam concertos na varanda. Eles se sentem bem, suas casas s√£o altas e seus vizinhos s√£o jovens. Nossos vizinhos s√£o idosos, n√£o querem shows. E as casas s√£o baixas, o que tamb√©m n√£o contribui para a ociosidade. Portanto, somos salvos como podemos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä tarde, em um site remoto, n√£o √© t√£o ruim. Como √† noite, at√© as crian√ßas adormecerem. Como nos primeiros dias, at√© os livros acabarem e a s√©rie ficar entediada. Mas um m√™s passa, seguido por outro. A alma requer ferro velho. Mas n√£o apenas, mas com pervers√£o. E eu vasculhei as lixeiras e encontrei o processador Zilog Z80 l√°:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7f1/fe7/7c9/7f1fe77c9972b2270ad8478702521555.jpg" alt="imagem"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Devo dizer, eu realmente amo este processador. Provavelmente, a √∫nica coisa que eu gosto nele √© o 486¬∫ chip, mas minhas m√£os n√£o o alcan√ßar√£o em breve, porque √© dif√≠cil e in√∫til inseri-lo na t√°bua de p√£o. Tem que soldar. Mas eu n√£o quero soldar ainda. E ainda mais do que o pr√≥prio Z80, eu amo o computador ZX Spectrum constru√≠do em sua base. Mas o Spectrum nativo sofre um desastre na forma de um chip l√≥gico personalizado do ULA, e seus clones do lado frouxo, embora n√£o sejam particularmente dif√≠ceis de construir e refinar, ainda n√£o s√£o para o modelo da placa de ensaio e, de fato, por que tantas preocupa√ß√µes quando existe arduino?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um leitor inteligente, equilibrado e adequado aqui interrompe a leitura ou lan√ßa algo como "1 microcircuito FPGA acomodar√° a classe de computadores Spectrum" antes de parar. N√£o sou inteligente, n√£o sou adequado, apesar de equilibrado, mas s√≥ sei sobre o FPGA que √© legal. Eu s√≥ posso fazer arduino. Mas realmente quer cutucar os fios no Z80. Altamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos come√ßar </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Claro, vamos come√ßar. Mas primeiro, Isen√ß√£o de responsabilidade.</font></font><b>,   ,   ,    .  ‚Äî       .      ,    , .      ,    (,   ?), ,   ,   ,     ,  .       ,    ,  ,   ,   ,    .</b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para come√ßar, o que √© um computador de 8 bits adequado. Este √©, de fato, um processador conectado √† ROM e √† RAM e, ao lado, h√° alguns contadores para exibir na tela composta. √Äs vezes, um cron√¥metro para chiar. O ZX Spectrum n√£o √© diferente do esquema tradicional, exceto um mas. Existe um ULA. Este, de fato, √© o "chipset" do Spectrum. O ULA gerencia perif√©ricos, como um gravador, tweeter, teclado (parcialmente), sa√≠da para a tela (sim, sim, a placa de v√≠deo integrada apareceu no chipset Spectrum antes de se tornar mainstream). Havia tamb√©m um memorial compartilhado, os primeiros 16 KiB de RAM (endere√ßos de 0x4000 a 0x5B00). A partir dele, o ULA desenhou um composto na tela e, para que o Z80 n√£o ficasse l√° quando n√£o era necess√°rio, o ULA poderia parar o processador, se necess√°rio, porque o sinal do rel√≥gio no Z80 vinha dele. Ou seja, se o ULA trabalhou com mem√≥ria e detectou,que o processador tamb√©m entra nessa mem√≥ria (para isso, monitora constantemente as linhas MREQ e A15 e A14), simplesmente interrompe o clock do processador at√© terminar de fazer o que √© necess√°rio. A prop√≥sito, para evitar corrup√ß√£o de dados no barramento, partes do barramento no lado do processador e no ULA foram delimitadas por ... resistores ... Al√©m disso, a mem√≥ria estava no barramento do lado do ULA e, portanto, no caso de uma colis√£o, ignorava completamente os dados e o endere√ßo do lado do processador.ignorou completamente os dados e o endere√ßo do processador.ignorou completamente os dados e o endere√ßo do processador.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, o Spectrum possu√≠a ROMs (endere√ßos 0x0000 - 0x3FFF) e mem√≥ria pr√≥pria do processador (0x8000 - 0xFFFF), √†s quais o ULA n√£o tinha acesso e que funcionava mais r√°pido que 16 KiB de mem√≥ria compartilhada, pois o processador n√£o interferia no ULA nessa √°rea. . Mas isso foi apenas na vers√£o 48K do computador. Na vers√£o b√°sica, havia apenas ROMs e 16 KiB compat√≠veis com o ULA. Vamos come√ßar com ela.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â conveniente que o processador Z80 possa regenerar a DRAM, mas de alguma forma n√£o quero me preocupar com isso, porque a SRAM √© mais f√°cil de encontrar e n√£o tenho um multiplexador (ou n√£o consigo encontr√°-lo). Ent√£o, usaremos SRAM. Para come√ßar, montaremos o esqueleto principal, no qual todo o resto pode ser pendurado. O esqueleto ser√° um processador, ROM com firmware, mapeado para o endere√ßo da ROM do Spectrum, RAM, mapeado para os primeiros 16 KiB ap√≥s a ROM e alguns chips para embrulhar tudo ... Devo dizer que, durante muito tempo, n√£o quis rodar, porque tenho layouts chineses US $ 1 por 2 pe√ßas no ibee. Mas, para mim, o barulho vale a pena. Se voc√™ n√£o quiser mexer por muito tempo, fa√ßa bons layouts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, instale o Z80. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como voc√™ pode ver na </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">folha de dados</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ee/n6/i0/een6i0aw3zjgv2b4gah5oo9t2ja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O processador possui 40 pinos, divididos em grupos: barramento de endere√ßos, barramento de dados, controle do sistema, controle do processador, controle do barramento do processador, po√ßo, pot√™ncia e rel√≥gio. Nem todas essas conclus√µes s√£o usadas em sistemas reais, como o ZX Spectrum, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como pode ser visto no diagrama.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Do grupo "controle do processador" no Spectrum, apenas os sinais INT e RESET s√£o usados. O sinal M1 n√£o √© utilizado no grupo "controle do sistema", o grupo "controle do barramento" n√£o √© utilizado. H√° uma raz√£o para isto. Os antigos sistemas de 8 bits eram muito simples, e o Spectrum foi criado com a id√©ia de ser o mais simples poss√≠vel e tudo o que podia ser ignorado era ignorado. Obviamente, os fabricantes de perif√©ricos podiam usar interrup√ß√µes (sinais INT e NMI), eles eram roteados para o slot de expans√£o, mas a NMI n√£o era usada no pr√≥prio espectro. Como pode ser visto no diagrama acima, os sinais NMI, WAIT, BUSREQ s√£o puxados pelos resistores de pot√™ncia, pois s√£o entradas ativadas de baixo n√≠vel (isso √© indicado pela barra acima do nome do sinal) e deve haver uma unidade l√≥gica (ou seja, + 5V) para que Deus n√£o permita que o sinal desnecess√°rio n√£o funcione. E aqui est√£o as conclus√µes, BUSACK, HALT, M1,e fique no ar, n√£o conectado a nada. A prop√≥sito, observe que n√£o h√° bot√£o de reinicializa√ß√£o no Spectrum. O pino de reset est√° conectado via</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corrente RC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para energia (RESET tamb√©m √© ativado por um n√≠vel baixo), pois, de acordo com a folha de dados, ap√≥s ativar o RESET, pelo menos 3 ciclos de clock devem estar ativos para que o processador entre no modo de opera√ß√£o. Esse circuito RC mant√©m um n√≠vel baixo at√© que o capacitor seja carregado em um n√≠vel alto atrav√©s de um resistor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos examinar brevemente o resto dos sinais: </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M1.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√≥s n√£o precisamos. Ele relata que o processador come√ßou a executar a pr√≥xima instru√ß√£o. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MREQ.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eu preciso disso. Ele relata que o processador est√° acessando a mem√≥ria. Se esse sinal ficar baixo (ou seja, conectado ao aterramento), precisaremos ativar a mem√≥ria conectada ao processador. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOREQ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Eu preciso disso. Ele relata que o processador est√° acessando um dispositivo perif√©rico. Por exemplo, para o teclado.</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Eu preciso disso. Informa que o processador ir√° ler dados da mem√≥ria (se MREQ estiver ativo) ou perif√©ricos (IOREQ). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Eu preciso disso. Relata que o processador gravar√° dados na mem√≥ria / perif√©ricos. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFSH</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Necess√°rio. Em geral, esse sinal √© necess√°rio para a mem√≥ria din√¢mica (DRAM). N√£o pretendo us√°-lo, pois seu endere√ßamento √© mais dif√≠cil (matriz, n√£o linear, ou seja, ser√° necess√°rio instalar um multiplexador) e, em geral, em nosso tempo, os microcircuitos SRAM de baixa capacidade s√£o mais f√°ceis de obter. Por√©m, como o pr√≥prio processador regenera a DRAM classificando os endere√ßos no barramento de mem√≥ria, esse sinal nos permitir√° ignorar os ciclos de regenera√ß√£o e n√£o ativar a mem√≥ria com o RFSH ativo. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MEIO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . N√£o √© necess√°rio. Indica que o processador est√° parado. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESPERAR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. N√£o √© necess√°rio. Este sinal √© necess√°rio para solicitar que o processador pare e espere um pouco. Geralmente usado por perif√©ricos lentos ou mem√≥ria. Mas n√£o no Spectrum. Quando nos perif√©ricos Spectrum (ULA) decide parar o processador, ele simplesmente deixa de enviar um sinal de rel√≥gio para ele. Isso √© mais confi√°vel, porque depois de receber WAIT, o processador n√£o para imediatamente. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Interromper. Ainda n√£o est√° claro. Assumimos que ainda n√£o √© necess√°rio. Ent√£o vamos descobrir. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A MNI</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Interrup√ß√£o desmascar√°vel. Super interrup√ß√£o. N√£o √© necess√°rio. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RESET</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sem ele, n√£o voar√°. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUSREQ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . N√£o √© necess√°rio. Solicita que o processador desconecte os barramentos de dados / endere√ßo, bem como os sinais de controle. √â necess√°rio se algum dispositivo quiser obter controle sobre o barramento. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUSACK</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. N√£o √© necess√°rio. Serve para informar ao dispositivo que executou o BUSREQ que o barramento est√° livre. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O REL√ìGIO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sinal de rel√≥gio. Claramente, ele √© necess√°rio. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As refei√ß√µes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tamb√©m </font><b><font style="vertical-align: inherit;">s√£o</font></b><font style="vertical-align: inherit;"> necess√°rias. Gl√≥ria aos desenvolvedores, apenas + 5V / GND. N√£o h√° 3 estresses para voc√™. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A0-A15</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© o barramento de endere√ßos. Nele, o processador exibe um endere√ßo de mem√≥ria (MREQ est√° ativo) ou um endere√ßo de porta de E / S (IOREQ est√° ativo) com as chamadas apropriadas. Como voc√™ pode ver, o barramento tem 16 bits de largura, o que permite endere√ßar diretamente 64 KiB de mem√≥ria. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D0-D7</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - barramento de dados. O processador envia a ele (WR ativo) ou l√™ (RD ativo) os dados solicitados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, colocaremos o processador na placa de ensaio. Portanto, suas conclus√µes est√£o fisicamente localizadas:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/dcb/b3f/2c4/dcbb3f2c401007d7aa3e1083e403f301.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conecte a energia (pinos 11 e 29). S√≥ para garantir, eu tamb√©m coloquei um capacitor de 10 pF entre essas pernas. Mas ele n√£o me ajudou no final. Os pinos 27, 23, 18 podem permanecer desconectados de qualquer coisa. Os pinos 26, 25, 24, 17, 16 s√£o conectados via resistores (usei 10 kOhm) √† fonte de alimenta√ß√£o. Levei o barramento de endere√ßos (pinos 1-5 e 30-40) para o lado oposto da placa de ensaio e o barramento de dados (pinos 7-10 e 12-15) para um barramento de dados separado, feito a partir de prot√≥tipos de barramento de for√ßa. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os pinos 6 (sinal de rel√≥gio) e 26 (RESET) s√£o conectados (posteriormente) ao Arduin para que voc√™ possa controlar o processador a partir dele. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aconteceu assim:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jm/in/rx/jminrxjfjixmm4pod6jhxw3kzfy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At√© que voc√™ preste aten√ß√£o nos fios de cima, eles partem da ROM, passaremos a ele um pouco mais tarde. Al√©m disso, na foto ao lado do processador, mais um chip √© vis√≠vel. Precisamos decodificar os bits superiores do endere√ßo. Como eu disse acima, existem 3 tipos de mem√≥ria no Spectrum. Os 16 KiB mais baixos do espa√ßo de endere√ßo s√£o ROM. Portanto, se os terminais A14 e A15 estiverem em um estado baixo (0 Volts), precisamos desconectar tudo, exceto o chip ROM do barramento. Em seguida, s√£o 16 KiB de mem√≥ria compartilhada. Portanto, precisamos conectar essa mem√≥ria ao barramento (e desconectar o restante) se a sa√≠da A15 for baixa e A14 for alta (+5 Volts). Bem, ent√£o vem 32 KiB de mem√≥ria r√°pida. Anexaremos essa mem√≥ria posteriormente e a ativaremos se a sa√≠da A15 estiver em um estado alto. Al√©m disso, n√£o esque√ßa que somente ativamos a mem√≥ria quando ativos (aqui, ativo - baixo,0 Volt) MREQ e inativo (aqui, inativo - alto, + 5V) RFSH. Tudo isso √© muito simples de implementar na l√≥gica padr√£o, nas mesmas NANDs, como 74HC00 ou K155LA3 ortodoxa, e eu entendo que esta tarefa √© para o grupo preparat√≥rio do jardim de inf√¢ncia, no entanto, s√≥ consigo pensar nas tabelas da verdade em liberdade e em cativeiro</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu tenho um diagrama Harlequin completo l√°</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , do qual voc√™ pode simplesmente assumir a parte em que o U4 √© desenhado (74HC138, felizmente eu tenho cerca de cem deles). </font><font style="vertical-align: inherit;">Iremos ignorar o U11 por quest√µes de clareza, pois os 32KiB superiores n√£o nos interessam at√© agora. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A conex√£o √© muito simples. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2h/my/p2/2hmyp2xuiiuejpixie4e1mnoo1w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como pode ser visto na </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">breve descri√ß√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O microcircuito √© um decodificador que recebe n√∫meros bin√°rios de 000 a 111 nos terminais 1 a 3 e ativa uma das 8 sa√≠das (pernas 7 e 9 a 15) correspondentes a esse n√∫mero. </font><font style="vertical-align: inherit;">Como apenas 8 n√∫meros diferentes podem ser armazenados em 3 bits, existem apenas oito sa√≠das. </font><font style="vertical-align: inherit;">Como voc√™ pode ver, as conclus√µes s√£o invertidas, ou seja, a que estar√° ativa ter√° um n√≠vel de 0V, e todas as outras + 5V. </font><font style="vertical-align: inherit;">Al√©m disso, uma chave na forma de uma porta de 3 entradas do tipo ‚ÄúI‚Äù est√° embutida no chip e duas de suas tr√™s entradas tamb√©m s√£o invertidas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No nosso caso, conectamos o decodificador em si da seguinte forma: o bit mais significativo (terceira perna) ao ch√£o, sempre haver√° 0. O bit do meio √© a linha A15. Haver√° 1 apenas se o processador acessar os 32KiB superiores de mem√≥ria (endere√ßos 0x8000 - 0xFFFF ou 1000000000000000 - 1111111111111111 em bin√°rio, quando o bit mais significativo √© sempre definido como 1). Conectamos o bit menos significativo √† linha A14, onde o n√≠vel alto ser√° no caso de acessar a mem√≥ria ap√≥s os primeiros 16 KiB, mas at√© os 32 KiB superiores (endere√ßos 0x4000 - 0x7FFF ou 0100000000000000 - 0111111111111111 em formato bin√°rio) ou os 16 KiB mais recentes do endere√ßo espa√ßos (endere√ßos 0xB000 - 0xFFFF ou 1100000000000000 - 1111111111111111 em formato bin√°rio). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver qual ser√° a sa√≠da em cada um dos casos:</font></font><br>
<br>
<ul>
<li>  14  15    ,       16  ,    ,     000,  0    (    ),     Y0 (15 ).      ,      .</li>
<li>  14   ,   15 ‚Äî  ,         16 ,   32 ,    001,  1   ,     Y1 (14 ).      ,  16 ,       .</li>
<li>  14   ,   15 ‚Äî  ,     -  32   48 ,    010,     Y2 (13 ).      ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se as duas linhas (A14 e A15) estiverem ativas, o processador acessa os 16 KiB de mem√≥ria principais, de 48 a 64 KiB, n√£o temos, portanto o pino Y3 (12¬∫ pino) tamb√©m est√° no ar.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, gra√ßas a outro elemento, o microcircuito ativar√° suas descobertas apenas se as entradas 4 e 5 forem baixas e 6 forem altas. </font><font style="vertical-align: inherit;">A quarta entrada est√° sempre no estado baixo (est√° conectada diretamente ao terra), a quinta somente ser√° baixa quando o processador estiver acessando a mem√≥ria (lembre-se, o MREQ no estado baixo significa acessar a mem√≥ria) e a sexta estar√° alta quando o processador n√£o executar um ciclo de atualiza√ß√£o DRAM (temos SRAM, portanto, os ciclos de atualiza√ß√£o de DRAM s√£o a maneira mais segura de ignorar). </font><font style="vertical-align: inherit;">Acontece √≥timo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, coloque a ROM.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peguei o W27C512 porque √© barato, alegre, tudo vai ficar bem e voc√™ tamb√©m pode pagar. 64KiB! 4 firmware podem ser carregados. Bem, eu tenho cerca de um milh√£o desses microcircuitos. Eu decidi que s√≥ costuraria a metade superior, j√° que no Harlequin a perna A15 est√° ligada a + 5V, e a A14 √© ajust√°vel com um jumper. Assim, posso testar o firmware no Harlequin para n√£o mexer por um longo tempo. Folha de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dados</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Smorim </font><font style="vertical-align: inherit;">. Colocamos o chip na t√°bua de p√£o. Mais uma vez, coloquei no canto direito para colocar o barramento de endere√ßos √† esquerda. Puxamos a perna A15 para o poder, a fia√ß√£o A14 para o ch√£o. Fia√ß√£o - isto √© para que voc√™ possa alterar os bancos de mem√≥ria. Como o A15 sempre estar√° em um n√≠vel alto, apenas as 32 principais unidades flash KiB estar√£o dispon√≠veis para n√≥s. Destes, a linha A14 selecionar√° os 16 KiB superior (+ 5V) ou inferior (terra). Neles, preenchi a </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">imagem de teste com o</font></a><font style="vertical-align: inherit;"> programador</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e firmware </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b√°sico de 48K</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As 14 linhas de endere√ßo restantes (A0 - A13) est√£o conectadas ao barramento de endere√ßos √† esquerda. Conectamos o barramento de dados (Q0 - Q7) ao barramento improvisado na forma de barramentos de for√ßa dos modelos de placa de ensaio. N√£o se esque√ßa de comida!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora os sinais de controle. </font><font style="vertical-align: inherit;">OE √© uma habilita√ß√£o de sa√≠da. </font><font style="vertical-align: inherit;">Precisamos que a ROM envie dados ao barramento de dados quando o processador l√™. </font><font style="vertical-align: inherit;">Portanto, nos conectamos diretamente √† sa√≠da do processador RD. </font><font style="vertical-align: inherit;">Convenientemente, os dois pinos, OE na ROM e RD no processador, est√£o ativos em um estado baixo. </font><font style="vertical-align: inherit;">Isso √© importante, voc√™ n√£o precisa inverter nada. </font><font style="vertical-align: inherit;">Al√©m disso, a ROM possui uma entrada CS, tamb√©m ativa em um estado baixo. </font><font style="vertical-align: inherit;">Se esta entrada n√£o estiver ativa, a ROM ignorar√° todos os outros sinais e n√£o emitir√° nada para o barramento de dados. </font><font style="vertical-align: inherit;">Vamos conectar essa entrada ao pino Y0 (15 pinos) do chip 74HC138, que tamb√©m est√° ativo no estado baixo. </font><font style="vertical-align: inherit;">No circuito </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harlequin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">esse sinal, por algum motivo, √© conectado atrav√©s de um resistor. </font><font style="vertical-align: inherit;">N√≥s vamos fazer o mesmo. </font><font style="vertical-align: inherit;">Porque eu n√£o sei. </font><font style="vertical-align: inherit;">Talvez pessoas inteligentes me digam nos coment√°rios ... </font><i><font style="vertical-align: inherit;">Eles</font></i><font style="vertical-align: inherit;"> me </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disseram. </font><font style="vertical-align: inherit;">Obrigado,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sterr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><blockquote>  .       ,    ¬´¬ª .            .</blockquote></i><br>
<br>
<img src="https://habrastorage.org/webt/1k/n7/h3/1kn7h3nfgruh121jefz2qfhucts.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora RAM. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â mais dif√≠cil, pois n√£o apenas o processador, mas tamb√©m o ULA, ou, no nosso caso, o Arduino, trabalham com RAM (com nossos 16 KiB). Uma vez que √© necess√°rio ler algo que √© exibido na tela. Portanto, precisamos desconectar os sinais de controle e o barramento de endere√ßo RAM do processador. N√£o desconectaremos o barramento de dados, atuaremos como no espectro original (e no Harlequin): dividiremos o barramento com resistores (470-500 Ohms). Por um lado, os resistores ser√£o o processador e a ROM, por outro, RAM e Arduino. Portanto, no caso de um conflito no barramento de dados, ele funcionar√° como 2 barramentos separados. Mas, de resto, usamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">74HC245</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , como no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harlequin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (U43, U44 no diagrama), embora no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presente Speccy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamb√©m havia resistores (entre IC1, por um lado, isto √© ULA, e IC3, IC4, por outro). </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O 74HC245</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© um buffer de barramento de 8 bits. Mas temos 2 sinais de controle (RD - no caso de leitura da mem√≥ria e CE para ativar a pr√≥pria RAM. Lidaremos com o WR no caso de gravar na mem√≥ria posteriormente) e 14 bits do endere√ßo: lembre-se, acima, j√° geramos um sinal para a mem√≥ria usando apenas 74HC138 no caso em que o processador ativou o A14 com o A15 inativo, portanto n√£o precisamos decodificar o endere√ßo, a mem√≥ria funcionar√° apenas ao acessar os primeiros 16 KiB ap√≥s a ROM. Bem, √© claro, para endere√ßar 16 KiB, voc√™ precisa de apenas 14 linhas de endere√ßo (A0-A13). No total, s√£o obtidos 16 sinais, por isso precisamos de 2 microcircuitos 74HC245. N√≥s os conectamos √† placa de ensaio √† esquerda, no lugar do barramento de endere√ßos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A partir da folha de dados do 74HC245, fica claro que, em geral, n√£o importa de que lado conectar os microcircuitos, mas desde que comecei a criar os layouts de baixo para cima, e todos os outros microcircuitos s√£o instalados com o primeiro pino √† esquerda, o barramento de endere√ßos se conectar√° ao lado A (pinos 2 -9 chips, na folha de dados s√£o designados como A0-A7). A dire√ß√£o da transfer√™ncia √© sempre do processador para a RAM, pois a RAM nunca define o endere√ßo, mas apenas o recebe. No 74HC245, o pino 1 (DIR) √© respons√°vel pela dire√ß√£o da transmiss√£o. De acordo com a </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">folha</font></a><font style="vertical-align: inherit;"> de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dados</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que no lado B exista uma sa√≠da igual √† entrada no lado A, o DIR deve estar definido como HIGH. Portanto, conecte o primeiro pino de ambos os circuitos a + 5V. OE (20 pinos, ativado por um n√≠vel baixo) √© conectado usando a fia√ß√£o ao terra, para que possa ser rapidamente mudado para + 5V e desconectado do processador. Mais simples. Conecte a energia para os dois chips. Os pinos mais √† direita do microcircuito direito (8¬∫ e 9¬∫ pinos, entradas A6 e A7) ser√£o sinais de controle. Conectei o A7 ao terminal RD do processador e o A6 ao pino Y1 do chip 74HC138, pois haver√° um n√≠vel baixo apenas quando o processador acessar nossa RAM. As conclus√µes restantes do lado A de ambos os microcircuitos (pernas 2‚Äì9 para a esquerda e pernas 2‚Äì7 para a direita) conectei ao barramento de endere√ßo, terminais A13-A0. N√£o precisamos dos 2 bits superiores do endere√ßo, porque eles j√° est√£o decodificados no sinal do 74HC138.Agora sobre a pr√≥pria RAM. Naturalmente, usei o que j√° tinha: um chip de cache da antiga placa-m√£e. Me deparei</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IS61C256</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em 20 ns, mas qualquer um far√°. Speccy trabalhava a uma frequ√™ncia de 3,5 MHz, mas, por enquanto, geralmente trataremos o Arduinki. Se 100 kHz sair, haver√° felicidade! Ent√£o, n√≥s nos conectamos. Claro, n√£o se esque√ßa de comida. Conclus√µes I / O0 - I / O7 s√£o conectadas √† placa de ensaio do barramento de dados AP√ìS os resistores. Tive sorte (de fato, n√£o). Nas minhas maquetes chinesas, os √¥nibus el√©tricos est√£o divididos exatamente no meio. Eu usei esse recurso para separar o barramento com resistores. Se seus layouts est√£o errados, voc√™ deve ser </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pervertido</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fa√ßa um segundo barramento de dados e conecte-o com resistores ao primeiro. As conclus√µes de A0-A13 s√£o apresentadas nas conclus√µes B correspondentes dos chips 74HC245, n√£o esquecendo que os mais √† direita est√£o conectados n√£o ao barramento de dados, mas aos sinais de controle. A14 - por op√ß√£o, seja no ch√£o ou em + 5V. Como um chip de 32 KiB, essa conclus√£o determinar√° qual metade usaremos. Se voc√™ encontrar uma SRAM de 16 KiB, n√£o haver√° linha A14 nela. As sa√≠das s√£o WE (ativa√ß√£o por grava√ß√£o), CE (ativa√ß√£o por chip) e OE (ativa√ß√£o por sa√≠da). Todos s√£o ativados baixo. O OE deve estar conectado ao RD do processador, mas, √© claro, n√£o diretamente, mas atrav√©s do 74HC245 direito, onde o RD chega ao meu p√© A7 e, consequentemente, sai do p√© B7 (11¬∫ pino). L√° e conectar. O CE deve estar conectado ao Y1 a partir do 74HC138, que decodifica o endere√ßo. Seu sinal chega a mim no A6 do chip certo 74HC245, respectivamente,sai do p√© B6 (12 pinos). WE eu diretamente conectado √† sa√≠da do processador WR. Tamb√©m instalei um fio de ponte do sinal OE e o prendi apenas na parte n√£o utilizada da placa de ensaio. Ao conectar esse fio ao terra de energia, posso for√ßar a RAM a ser ativada quando o li em Arduinka. Ainda assim, puxei todos os sinais de controle da RAM para + 5V usando resistores de 10 kOhm. Apenas no caso de. Aconteceu assim:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9y/0k/3h/9y0k3ht6ehvrsvzoehp70h428mo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, aqui, e se houver, desde o in√≠cio, deve haver um programa educacional sobre o tempo dos sinais nos pneus. N√£o farei isso, pois isso j√° foi feito muitas vezes na rede por pessoas muito mais inteligentes que eu. Para os interessados, posso recomendar este v√≠deo:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/i_wrxBdXTgM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, se voc√™ n√£o se inscreveu neste canal e est√° interessado em eletr√¥nicos como amador, e n√£o como profissional, eu o recomendo. Este √© um conte√∫do de alta qualidade. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, isso √© quase tudo. Agora voc√™ s√≥ precisa entender como ler dados da RAM no Arduino. Para come√ßar, vamos calcular quantas conclus√µes de Arduinki precisamos. Precisamos dar um sinal de rel√≥gio e controlar o RESET, estes s√£o 2 pinos. 8 bits de barramento de dados - outros 8 pinos. Mais 13 bits de endere√ßo, total de 23 pinos. Al√©m disso, precisamos nos comunicar com Arduinka, faremos isso atrav√©s de sua interface serial, este √© mais 2 pinos. Infelizmente, existem apenas 20 conclus√µes no meu DNA.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, isso n√£o importa. N√£o conhe√ßo uma √∫nica pessoa que tenha Arduino e n√£o tenha 74HC595. Parece-me que eles s√£o vendidos apenas no kit. Pelo menos eu tenho apenas chips 74HC00 mais que 595x. Ent√£o n√≥s os usamos. Al√©m disso, vou economizar espa√ßo no artigo, porque o trabalho do 595x com o arduino est√° perfeitamente descrito </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. 595mi iremos gerar o endere√ßo. O chip precisar√° de 2 pe√ßas (j√° que temos 13 bits do endere√ßo e o 595¬∫ possui 8 pinos). Como conectar v√°rios 595x para expans√£o de barramento √© descrito em detalhes no link acima. Notei apenas que nos exemplos desse link OE (pino 13) 595x √© puxado para o ch√£o. N√≥s categoricamente n√£o faremos isso, enviaremos um sinal de Arduinki l√°, pois os pinos 595x ser√£o conectados diretamente ao barramento de endere√ßos RAM, e n√£o precisamos de nenhum sinal falso l√°. Ap√≥s conectar os pinos 595x ao barramento de endere√ßo RAM, nada mais precisa ser feito nos modelos. Hora de conectar o arduinka. Mas primeiro, escreva um esbo√ßo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// CPU defines</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CPU_CLOCK_PIN 2</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CPU_RESET_PIN 3</span><font></font>
<font></font>
<span class="hljs-comment">// RAM defines</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_OUTPUT_ENABLE_PIN 4</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_WRITE_ENABLE_PIN 5</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_CHIP_ENABLE_PIN 6</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_BUFFER_PIN 7</span><font></font>
<font></font>
<span class="hljs-comment">// Shift Register defines</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_DATA_PIN 8</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_OUTPUT_ENABLE_PIN 9</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_LATCH_PIN 10</span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_CLOCK_PIN 11</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{<font></font>
  <span class="hljs-comment">// All CPU and RAM control signals need to be configured as inputs by default</span><font></font>
  <span class="hljs-comment">// and only changed to outputs when used.</span><font></font>
  <span class="hljs-comment">// Shift register control signals may be preconfigured</span><font></font>
<font></font>
  <span class="hljs-comment">// CPU controls seetup</span><font></font>
  DDRC = B00000000;<font></font>
  pinMode(CPU_CLOCK_PIN, INPUT);<font></font>
  pinMode(CPU_RESET_PIN, INPUT);<font></font>
<font></font>
  <span class="hljs-comment">// RAM setup</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_BUFFER_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_BUFFER_PIN, LOW);<font></font>
<font></font>
  <span class="hljs-comment">// SR setup</span><font></font>
  pinMode(SR_LATCH_PIN, OUTPUT);<font></font>
  pinMode(SR_CLOCK_PIN, OUTPUT);<font></font>
  pinMode(SR_DATA_PIN, OUTPUT);<font></font>
  pinMode(SR_OUTPUT_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
<font></font>
  <span class="hljs-comment">// common setup</span><font></font>
  Serial.begin(<span class="hljs-number">9600</span>);<font></font>
  Serial.println(<span class="hljs-string">"Hello"</span>);<font></font>
}<span class="hljs-comment">// setup</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shiftReadValueFromAddress</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> address, <span class="hljs-keyword">uint8_t</span> *value)</span> </span>{<font></font>
  <span class="hljs-comment">// disable RAM output</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_WRITE_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  <span class="hljs-comment">// set address</span><font></font>
  digitalWrite(SR_LATCH_PIN, LOW);<font></font>
  shiftOut(SR_DATA_PIN, SR_CLOCK_PIN, MSBFIRST, address&gt;&gt;<span class="hljs-number">8</span>); <font></font>
  shiftOut(SR_DATA_PIN, SR_CLOCK_PIN, MSBFIRST, address);  <font></font>
  digitalWrite(SR_LATCH_PIN, HIGH);<font></font>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, LOW); <span class="hljs-comment">// active low</span><font></font>
  <span class="hljs-comment">// write value to RAM</span><font></font>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, LOW); <span class="hljs-comment">// active low</span><font></font>
  delay(<span class="hljs-number">1</span>);<font></font>
  DDRC = B00000000;<font></font>
  *value = PINC;<font></font>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  <span class="hljs-comment">// disable SR</span><font></font>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
}<span class="hljs-comment">// shiftWriteValueToAddress</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">runClock</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> cycles)</span> </span>{<font></font>
  <span class="hljs-keyword">uint32_t</span> currCycle = <span class="hljs-number">0</span>;<font></font>
  pinMode(CPU_CLOCK_PIN, OUTPUT);<font></font>
  <span class="hljs-keyword">while</span>(currCycle &lt; cycles) {<font></font>
    digitalWrite(CPU_CLOCK_PIN, HIGH);<font></font>
    digitalWrite(CPU_CLOCK_PIN, LOW);<font></font>
    currCycle++;<font></font>
  }<font></font>
  pinMode(CPU_CLOCK_PIN, INPUT);<font></font>
}<span class="hljs-comment">// runClock</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trySpectrum</span><span class="hljs-params">()</span> </span>{<font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
  pinMode(CPU_RESET_PIN, OUTPUT);<font></font>
  digitalWrite(CPU_RESET_PIN, LOW);<font></font>
  runClock(<span class="hljs-number">30</span>);<font></font>
  digitalWrite(CPU_RESET_PIN, HIGH);<font></font>
  runClock(<span class="hljs-number">12500000</span>);<font></font>
}<span class="hljs-comment">// trySpectrum</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">readDisplayLines</span><span class="hljs-params">()</span> </span>{<font></font>
  <span class="hljs-keyword">uint8_t</span> value;<font></font>
  digitalWrite(RAM_BUFFER_PIN, HIGH);<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_CHIP_ENABLE_PIN, LOW);<font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">uint16_t</span> i=<span class="hljs-number">16384</span>; i&lt;<span class="hljs-number">16384</span>+<span class="hljs-number">6144</span>;i++) {<font></font>
    shiftReadValueFromAddress(i, &amp;value);<font></font>
    Serial.println(value);<font></font>
  }<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, INPUT);<font></font>
}<span class="hljs-comment">// readDisplayLines</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{<font></font>
  trySpectrum();<font></font>
  Serial.println(<span class="hljs-string">"Hope we are ok now. Please set up memory for reading"</span>);<font></font>
  delay(<span class="hljs-number">40000</span>);<font></font>
  Serial.println(<span class="hljs-string">"Reading memory"</span>);<font></font>
  readDisplayLines();<font></font>
  Serial.println(<span class="hljs-string">"Done"</span>);<font></font>
  delay(<span class="hljs-number">100000</span>);<font></font>
}<span class="hljs-comment">// loop</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como voc√™ pode ver no esbo√ßo (bem, de repente, algu√©m leu), li o barramento de dados para a porta C. Como Arduischik pode se lembrar, no CID, a porta C tem 6 pinos. Ou seja, eu li apenas 6 bits. Sim, pela simplicidade do processo, ignoro os 2 bits altos em cada byte do buffer de tela. Isso resultar√° no fato de que a cada 2 pixels ap√≥s 6 sempre haver√° cores de fundo. Durante um passeio, conserte-o. Este √© o esqueleto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, a conex√£o em si. Em princ√≠pio, tudo √© pintado no topo do esbo√ßo:</font></font><br>
<br>
<pre><code class="plaintext hljs">// CPU defines<font></font>
#define CPU_CLOCK_PIN 2 -  2     6  ( )<font></font>
#define CPU_RESET_PIN 3 -  3     26  (RESET)<font></font>
<font></font>
// RAM defines<font></font>
#define RAM_OUTPUT_ENABLE_PIN 4 -  4     22  (OE)<font></font>
#define RAM_WRITE_ENABLE_PIN 5 -  5    .     .<font></font>
#define RAM_CHIP_ENABLE_PIN 6 -  6     .        ,        .   - ,   -  .   ,   .<font></font>
#define RAM_BUFFER_PIN 7 -  ,    6,    .<font></font>
<font></font>
// Shift Register defines<font></font>
#define SR_DATA_PIN 8   -  8     14 "" 595.        9 ,     .<font></font>
#define SR_OUTPUT_ENABLE_PIN 9 -   13  595<font></font>
#define SR_LATCH_PIN 10 -   12  595<font></font>
#define SR_CLOCK_PIN 11 -   11  595.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo √© simples. Aqui est√° como parece que estou todo montado (o arduino foi cortado na imagem, mas n√£o h√° nada de especial para assistir): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pj/q5/si/pjq5siebaxafimb_nqnjxyry6_u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na inicializa√ß√£o, o Arduino alegremente diz Ol√° para a porta serial do computador (embora virtual) e come√ßa a atormentar o processador. Depois de tortur√°-lo completamente (alguns minutos), o programa ir√° parar o pobre rapaz e oferecer√° a voc√™ para reorganizar os jumpers com as canetas na placa de ensaio, desconectando a mem√≥ria dos sinais de controle do processador e do barramento de endere√ßos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora precisamos usar as al√ßas para reorganizar a fia√ß√£o conectada aos pinos 19 de ambos 74HC245 do ch√£o para + 5V. Assim, desconectamos o processador da RAM. O pino 22 do chip de RAM em si deve estar conectado ao terra (escrevi acima sobre a fia√ß√£o, que acabei de prender na placa de ensaio at√© agora, em um local n√£o utilizado). Assim, ativamos √† for√ßa a RAM.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois disso, depois de esperar um pouco, o Arduinka come√ßar√° a ler o conte√∫do da mem√≥ria e envi√°-lo em uma coluna para a porta serial. Haver√° muitos, muitos n√∫meros. Agora voc√™ pode copiar esses dados de l√° e col√°-los, digamos, em um arquivo de texto, sem esquecer de limpar todo o texto desnecess√°rio (algumas linhas na parte superior e "Conclu√≠do" na parte inferior), precisamos apenas de n√∫meros. Isso √© o que nosso Speccy gravou na mem√≥ria de v√≠deo. Resta apenas ver o que havia na mem√≥ria de v√≠deo. E a mem√≥ria de v√≠deo do Spectrum </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">f√°cil</font></a><font style="vertical-align: inherit;"> ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como voc√™ pode ver, os pr√≥prios pixels s√£o armazenados separadamente da cor. Vamos ignorar a cor por enquanto, vamos ler apenas os pixels em si. Mas eles n√£o s√£o t√£o f√°ceis de decodificar. Ap√≥s muita dor no Visual Studio, cheguei a esta solu√ß√£o elegante:</font></font><br>
<br>
<pre><code class="cpp hljs"><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND, UINT, WPARAM, LPARAM)</span></span>;<font></font>
<span class="hljs-keyword">uint8_t</span> *scrData;<font></font>
<font></font>
<span class="hljs-function">VOID <span class="hljs-title">OnPaint</span><span class="hljs-params">(HDC hdc)</span> </span>{<font></font>
	<span class="hljs-keyword">size_t</span> arrSize = <span class="hljs-number">6144</span>;<span class="hljs-comment">//sizeof(scrData) / sizeof(scrData[0]);</span><font></font>
	<span class="hljs-comment">//int currRow = 0, currX = 0, currBlock = 0, currY = 0, currBase = 0;</span><font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> arrPos = <span class="hljs-number">0</span>; arrPos &lt; arrSize; arrPos++) {<font></font>
		<span class="hljs-keyword">int</span> blockPos = arrPos % <span class="hljs-number">2048</span>;<font></font>
		<span class="hljs-keyword">int</span> currBase = (blockPos % <span class="hljs-number">256</span>) / <span class="hljs-number">32</span>;<font></font>
		<span class="hljs-keyword">int</span> currX = blockPos % <span class="hljs-number">32</span>;<font></font>
		<span class="hljs-keyword">int</span> currBlock = arrPos / <span class="hljs-number">2048</span>;<font></font>
		<span class="hljs-keyword">int</span> currRow = blockPos / <span class="hljs-number">256</span>;<font></font>
		<span class="hljs-keyword">int</span> currY = currBlock * <span class="hljs-number">64</span> + currBase * <span class="hljs-number">8</span> + currRow;<font></font>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> trueX = <span class="hljs-number">0</span>; trueX &lt; <span class="hljs-number">8</span>; trueX++) {<font></font>
			<span class="hljs-keyword">char</span> r = ((scrData[arrPos] &gt;&gt; trueX) &amp; <span class="hljs-number">1</span>)*<span class="hljs-number">255</span>;<font></font>
			SetPixel(hdc, currX * <span class="hljs-number">8</span> + (<span class="hljs-number">8</span>-trueX), currY, RGB(r, r, r));<font></font>
		}<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadData</span><span class="hljs-params">()</span> </span>{<font></font>
	FILE *file;<font></font>
	<span class="hljs-keyword">errno_t</span> err;<font></font>
	<span class="hljs-keyword">if</span> ((err = fopen_s(&amp;file, <span class="hljs-string">"data.txt"</span>, <span class="hljs-string">"r"</span>))) {<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, <span class="hljs-string">L"Unable to oopen the file"</span>, <span class="hljs-string">L"Error"</span>, <span class="hljs-number">1</span>);<font></font>
	}<font></font>
	scrData = (<span class="hljs-keyword">uint8_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">6144</span>);<font></font>
	<span class="hljs-keyword">int</span> currDataPos = <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">char</span> buffer[<span class="hljs-number">256</span>];<font></font>
	<span class="hljs-keyword">char</span> currChar = <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">int</span> currLinePos = <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">while</span> (currChar != EOF) {<font></font>
		currChar = getc(file);<font></font>
		buffer[currLinePos++] = currChar;<font></font>
		<span class="hljs-keyword">if</span> (currChar == <span class="hljs-string">'\n'</span>) {<font></font>
			buffer[currLinePos] = <span class="hljs-number">0</span>;<font></font>
			scrData[currDataPos++] = (<span class="hljs-keyword">uint8_t</span>)atoi(buffer);<font></font>
			currLinePos = <span class="hljs-number">0</span>;<font></font>
		}<font></font>
	}<font></font>
	fclose(file);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">INT WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE, PSTR, INT iCmdShow)</span> </span>{<font></font>
	HWND                hWnd;<font></font>
	MSG                 msg;<font></font>
	WNDCLASS            wndClass;<font></font>
	wndClass.style = CS_HREDRAW | CS_VREDRAW;<font></font>
	wndClass.lpfnWndProc = WndProc;<font></font>
	wndClass.cbClsExtra = <span class="hljs-number">0</span>;<font></font>
	wndClass.cbWndExtra = <span class="hljs-number">0</span>;<font></font>
	wndClass.hInstance = hInstance;<font></font>
	wndClass.hIcon = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
	wndClass.hCursor = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);<font></font>
	wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<font></font>
	wndClass.lpszMenuName = <span class="hljs-literal">NULL</span>;<font></font>
	wndClass.lpszClassName = TEXT(<span class="hljs-string">"GettingStarted"</span>);<font></font>
	RegisterClass(&amp;wndClass);<font></font>
	hWnd = CreateWindow(<font></font>
		TEXT(<span class="hljs-string">"GettingStarted"</span>),   <span class="hljs-comment">// window class name</span><font></font>
		TEXT(<span class="hljs-string">"Getting Started"</span>),  <span class="hljs-comment">// window caption</span><font></font>
		WS_OVERLAPPEDWINDOW,      <span class="hljs-comment">// window style</span><font></font>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial x position</span><font></font>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial y position</span><font></font>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial x size</span><font></font>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial y size</span><font></font>
		<span class="hljs-literal">NULL</span>,                     <span class="hljs-comment">// parent window handle</span><font></font>
		<span class="hljs-literal">NULL</span>,                     <span class="hljs-comment">// window menu handle</span><font></font>
		hInstance,                <span class="hljs-comment">// program instance handle</span><font></font>
		<span class="hljs-literal">NULL</span>);                    <span class="hljs-comment">// creation parameters</span><font></font>
	loadData();<font></font>
	ShowWindow(hWnd, iCmdShow);<font></font>
	UpdateWindow(hWnd);<font></font>
	<span class="hljs-keyword">while</span> (GetMessage(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) {<font></font>
		TranslateMessage(&amp;msg);<font></font>
		DispatchMessage(&amp;msg);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> msg.wParam;<font></font>
}  <span class="hljs-comment">// WinMain</span><font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>{<font></font>
	HDC          hdc;<font></font>
	PAINTSTRUCT  ps;<font></font>
	<span class="hljs-keyword">switch</span> (message) {<font></font>
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		hdc = BeginPaint(hWnd, &amp;ps);<font></font>
		OnPaint(hdc);<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		PostQuitMessage(<span class="hljs-number">0</span>);<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	<span class="hljs-keyword">default</span>:<font></font>
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);<font></font>
	}<font></font>
} <span class="hljs-comment">// WndProc</span><font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O programa abre o arquivo data.txt a partir do diret√≥rio </font><font style="vertical-align: inherit;">Neste arquivo, a sa√≠da de texto do arduino (ap√≥s excluir todas as linhas extras, como mencionado acima.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√≥s o alimentamos com o arquivo resultante e como resultado: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tv/ai/3f/tvai3fcvvg-y53dlrcxogjo9o-c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sim, enquanto o resultado est√° muito longe do ideal, mas √© definitivamente a sa√≠da para a tela. </font><font style="vertical-align: inherit;">Al√©m disso, o que √© necess√°rio. </font><font style="vertical-align: inherit;">Da ROM com firmware de diagn√≥stico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, o esqueleto do computador est√° pronto. </font><font style="vertical-align: inherit;">Sim, ainda n√£o √© poss√≠vel us√°-lo, mas voc√™ pode ver como os computadores antigos de 8 bits foram extremamente simples. </font><font style="vertical-align: inherit;">Ainda bati um pouco demais, mas a conclus√£o s√≥ piorou. </font><font style="vertical-align: inherit;">Parece que o pr√≥ximo passo √© soldar em uma t√°bua de p√£o normal, n√£o soldada, com energia normal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas isso √© necess√°rio?</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt498208/index.html">Semana 17 de Seguran√ßa: Implica√ß√µes do ataque ao servidor Linux</a></li>
<li><a href="../pt498214/index.html">Maria Popova: ‚ÄúAlguns aprenderam sobre o OpenStreetMap pelo fato de terem marcado hogweed no mapa‚Äù</a></li>
<li><a href="../pt498216/index.html">Colorir textos em html e React</a></li>
<li><a href="../pt498218/index.html">Enquanto escrevia m√∫sica a partir de raios c√≥smicos</a></li>
<li><a href="../pt498220/index.html">–ö–∞–∫ –∫–æ—Ä–æ–Ω–∞–≤–∏—Ä—É—Å (COVID-XX) –º–æ–∂–µ—Ç –ø–æ–º–æ—á—å 1–° –∑–∞—Ö–≤–∞—Ç–∏—Ç—å –º–∏—Ä?</a></li>
<li><a href="../pt498224/index.html">Crie uma exposi√ß√£o interativa com o .NET, Azure Functions e a magia dos servi√ßos cognitivos</a></li>
<li><a href="../pt498226/index.html">Decomposi√ß√£o. Como desmontar um grande projeto em segmentos compreens√≠veis para uma avalia√ß√£o preliminar</a></li>
<li><a href="../pt498234/index.html">Mitos reais sobre gerenciamento de DevOps</a></li>
<li><a href="../pt498238/index.html">Pol√≠mero eletricamente condutor: como os cientistas fizeram pl√°stico de metal</a></li>
<li><a href="../pt498242/index.html">Usando armazenamento no conte√∫do da m√≠dia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>