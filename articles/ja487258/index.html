<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙉 🏜️ 🎙️ 非同期PHP 🔋 👳 👩🏽‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="10年前、私たちは古典的なLAMPスタックを持っていました：Linux、Apache、MySQL、PHPであり、これらはmod_phpの低速モードで動作しました。世界は変化し、それに伴いスピードの重要性が変わりました。 PHPのソリューションのパフォーマンスを大幅に向上させることができるPHP-FP...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>非同期PHP</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/487258/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10年前、私たちは古典的なLAMPスタックを持っていました：Linux、Apache、MySQL、PHPであり、これらはmod_phpの低速モードで動作しました。世界は変化し、それに伴いスピードの重要性が変わりました。 PHPのソリューションのパフォーマンスを大幅に向上させることができるPHP-FPMが登場しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並行して、ReactPHPライブラリは、OSからの信号を処理し、非同期操作の結果を表示するためのイベントループの概念を使用して開発されていました。 ReactPHP-AMPHPのアイデアの発展。このライブラリは同じイベントループを使用しますが、ReactPHPとは異なり、コルーチンをサポートします。同期のように見える非同期コードを書くことができます。おそらくこれは、PHPで非同期アプリケーションを開発するための最新のフレームワークです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tf/03/e6/tf03e6u08mt8gake9o4lbbfbdca.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、速度がますます必要になり、ツールだけでは十分ではないため、PHPでの非同期プログラミングのアイデアは、クエリ処理を高速化し、リソースをより有効に活用する方法の1つです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アントンシャボッタが</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">話します</font><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zloyusr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）Onlinerの開発者です。</font><font style="vertical-align: inherit;">10年以上の経験：C / C ++のデスクトップアプリケーションから始めて、PHPでのWeb開発に切り替えました。</font><font style="vertical-align: inherit;">彼はC＃とPython 3で「ホーム」プロジェクトを書いており、PHPではDDD、CQRS、イベントソーシング、非同期マルチタスクを実験しています。</font></font><br>
<a name="habracut"></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHPロシア2019</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に関するアントンのレポートの筆記録に基づいてい</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">その中で、PHPのブロッキングおよび非ブロッキング操作を理解し、イベントループの構造と、Promiseやコルーチンなどの非同期プリミティブを内部から研究します。</font><font style="vertical-align: inherit;">最後に、ext-async、AMPHP 3、およびPHP 8で何が待ち受けているかを確認します。</font></font></i><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/w75P9RrVgKg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの定義を紹介します。</font><font style="vertical-align: inherit;">長い間、私は非同期操作と非同期操作の正確な定義を見つけようとしましたが、私は見つけて書きませんでした。</font></font><br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、実行のメインスレッドをブロックしないソフトウェアシステムの機能です。</font></font><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期操作</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、完了するまでプログラムの実行フローをブロックしない操作です。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シンプルなようですが、最初にどの操作が実行フローをブロックするかを理解する必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロッキング操作</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHPはインタープリター言語です。</font><font style="vertical-align: inherit;">彼はコードを1行ずつ読み取り、指示に変換して実行します。</font><font style="vertical-align: inherit;">以下の例のどの行でコードがブロックされますか？</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">User $user</span>)</span><font></font><span class="hljs-function">
</span>{<font></font>
    <span class="hljs-keyword">try</span> {<font></font>
        $sql = <span class="hljs-string">'UPDATE users SET ...'</span>;<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;connection-&gt;execute($sql, $user-&gt;data());<font></font>
    } <span class="hljs-keyword">catch</span> (\PDOException $error) {<font></font>
        log($error-&gt;getMessage());<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PDO経由でデータベースに接続すると、SQL-server：へのクエリ文字列で実行スレッドがブロックされます</font></font><code>return $this-&gt;connection-&gt;execute($sql, $user-&gt;data());</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、PHPがSQLサーバーがこのクエリを処理する時間とクエリがまったく実行されるかどうかを認識していないためです。</font><font style="vertical-align: inherit;">サーバーからの応答を待ち、プログラムはこの間ずっと実行されていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHPは、すべてのI / O操作の実行フローもブロックします。</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイルシステム</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><code>fwrite</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>file_get_contents</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベース</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><code>PDOConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>RedisClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">データベースに接続するためのほとんどすべての拡張機能は、デフォルトでブロッキングモードで動作します。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセス</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><code>exec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>system</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>proc_open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">プロセスを使用するすべての作業はシステムコールを通じて構築されるため、これらはブロック操作です。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準入力/標準出力を使用した作業</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><code>readline</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>echo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>print</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、実行は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイマー</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でブロックされ</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">：</font></font><code>sleep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>usleep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらは、しばらくの間スリープ状態になるようにスレッドに明示的に指示する操作です。</font><font style="vertical-align: inherit;">PHPは常にアイドル状態です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期SQLクライアント</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、現代のPHPは汎用言語であり、1997年のPHP / FIのようなWeb用だけではありません。</font><font style="vertical-align: inherit;">したがって、非同期SQLクライアントを最初から作成できます。</font><font style="vertical-align: inherit;">タスクは最も簡単なものではありませんが、解決可能です。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execAsync</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> $query, <span class="hljs-keyword">array</span> $params = []</span>)</span><font></font><span class="hljs-function">
</span>{<font></font>
    $socket = stream_socket_client(<span class="hljs-string">'127.0.0.1:3306'</span>, ...);<font></font>
<font></font>
    stream_set_blocking($socket, <span class="hljs-literal">false</span>);<font></font>
<font></font>
    $data = <span class="hljs-keyword">$this</span>-&gt;packBinarySQL($query, $params);<font></font>
    <font></font>
    socket_write($socket, $data, strlen($data));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなクライアントは何をしますか？</font><font style="vertical-align: inherit;">SQLサーバーに接続し、ソケットを非ブロッキングモードにし、SQLサーバーが理解できるバイナリ形式でリクエストをパックし、ソケットにデータを書き込みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソケットは非ブロッキングモードであるため、PHPからの書き込み操作は高速です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、そのような操作の結果として何が返されますか？</font><font style="vertical-align: inherit;">SQLサーバーがどのように応答するかはわかりません。</font><font style="vertical-align: inherit;">リクエストが完了するまでに時間がかかる場合や、完了しない場合があります。</font><font style="vertical-align: inherit;">しかし、何かを返す必要がありますか？</font><font style="vertical-align: inherit;">PDOを使用</font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">してSQLサーバーでクエリ</font><font style="vertical-align: inherit;">を呼び出すと、</font></font><code>affected rows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このクエリによって変更された行数</font><font style="vertical-align: inherit;">が返さ</font><font style="vertical-align: inherit;">れます。</font><font style="vertical-align: inherit;">まだ返品はできませんので</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返品の</font><strong><font style="vertical-align: inherit;">約束</font></strong><font style="vertical-align: inherit;">のみさせていただきます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">約束する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは非同期プログラミングの世界からの概念です。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promiseは、非同期操作の結果に対するラッパーオブジェクトです。</font><font style="vertical-align: inherit;">さらに、操作の結果はまだ不明です。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">残念ながら、単一のPromise標準はありません。また、JavaScriptの世界からPHPに標準を直接転送することはできません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promiseの仕組み</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まだ結果がないので、一部しか確立できません</font></font><code>callbacks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ia/n1/qq/ian1qqvr_xs0faonifptkfrd2jc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データが利用可能な場合は、コールバックを実行する必要があります</font></font><code>onResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8v/bk/sf/8vbksfxvsfxskeozp3jckft5rmg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラーが発生した場合、エラー</font></font><code>onReject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を処理するために</font><font style="vertical-align: inherit;">コールバックが実行さ</font><font style="vertical-align: inherit;">れます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8x/hw/0v/8xhw0vsdhfryxyxalvsydiydfsc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Promiseインターフェースは次のようになります。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Promise</span></span><font></font><span class="hljs-class">
</span>{<font></font>
    <span class="hljs-keyword">const</span><font></font>
        STATUS_PENDING = <span class="hljs-number">0</span>,<font></font>
        STATUS_RESOLVED = <span class="hljs-number">1</span>,<font></font>
        STATUS_REJECTED = <span class="hljs-number">2</span><font></font>
    ;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onResolve</span>(<span class="hljs-params"><span class="hljs-keyword">callable</span> $callback</span>)</span>;<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onReject</span>(<span class="hljs-params"><span class="hljs-keyword">callable</span> $callback</span>)</span>;<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">$data</span>)</span>;<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">\<span class="hljs-built_in">Throwable</span> $error</span>)</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Promiseには、コールバックを設定し、</font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promiseにデータまたはエラー（</font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を入力</font><font style="vertical-align: inherit;">するためのステータスとメソッドがあります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、違いやバリエーションがあります。</font><font style="vertical-align: inherit;">メソッドは別の方法</font><font style="vertical-align: inherit;">で呼び出すことも</font><font style="vertical-align: inherit;">、コールバックを確立するための個別のメソッドの代わりに呼び出すこともできます</font><font style="vertical-align: inherit;">。たとえば、AMPHPのように</font><font style="vertical-align: inherit;">、メソッド</font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が存在</font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する場合</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">あります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合、技術の約束を埋めるために</font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して</font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別のオブジェクトに取る</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">繰延</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -記憶状態の非同期機能を。</font><font style="vertical-align: inherit;">プロミスの一種の工場と言えます。</font><font style="vertical-align: inherit;">1回限りです。1つのDeferredが1つのPromiseを作成します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bq/on/aq/bqonaqi04ql4kdhakfezn9nu25g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自分で書くことにした場合、SQLクライアントでこれをどのように適用しますか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期SQLクライアント</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、Deferredを作成し、ソケットを使用してすべての作業を行い、データを書き留め、Promiseを返しました-すべてが簡単です。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execAsync</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> $query, <span class="hljs-keyword">array</span> $params = []</span>)</span><font></font><span class="hljs-function">
</span>{<font></font>
    $deferred = <span class="hljs-keyword">new</span> Deferred;<font></font>
<font></font>
    $socket = stream_socket_client(<span class="hljs-string">'127.0.0.1:3306'</span>, ...);<font></font>
    stream_set_blocking($socket, <span class="hljs-literal">false</span>);<font></font>
<font></font>
    $data = <span class="hljs-keyword">$this</span>-&gt;packBinarySQL($query, $params);<font></font>
    socket_write($socket, $data, strlen($data));<font></font>
<font></font>
    <span class="hljs-keyword">return</span> $deferred-&gt;promise();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Promiseがある場合、たとえば次のことができます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバックを設定し、</font></font><code>affected rows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返される</font><font style="vertical-align: inherit;">コールバックを取得</font><font style="vertical-align: inherit;">します</font></font><code>PDOConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラーを処理し、ログに追加します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLサーバーがエラーで応答した場合は、クエリを再試行します。</font></font></li>
</ul><br>
<pre><code class="php hljs">$promise = <span class="hljs-keyword">$this</span>-&gt;execAsync($sql, $user-&gt;data());<font></font>
<font></font>
$promise-&gt;onResolve(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-keyword">int</span> $rows</span>) </span>{<font></font>
    <span class="hljs-keyword">echo</span> <span class="hljs-string">"Affected rows: {$rows}"</span>;<font></font>
});<font></font>
<font></font>
$promise-&gt;onReject(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">\<span class="hljs-built_in">Throwable</span> $error</span>) </span>{<font></font>
    log($error-&gt;getMessage());<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は残ります：私たちはコールバックを設定し、誰が電話</font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をかけ</font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ますか？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントループ</font></font></h2><br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントループ-イベントループ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の概念があり</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">彼は非同期環境でメッセージを処理することができます。</font><font style="vertical-align: inherit;">非同期I / Oの場合、これらは、ソケットが読み取りまたは書き込みの準備ができているというOSからのメッセージになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使い方。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントは、何らかの種類のソケットに関心があることをイベントループに通知します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントループ</font></font><code>stream_select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font><font style="vertical-align: inherit;">システムコールを介してOSをポーリングします</font><font style="vertical-align: inherit;">。ソケットの準備ができているか、すべてのデータが書き込まれているか、反対側からのデータかです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OSがソケットの準備ができていない、ブロックされていると報告した場合、イベントループはループを繰り返します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OSがソケットの準備ができたことを通知すると、イベントループは制御をクライアントに返し、</font><font style="vertical-align: inherit;">Promise </font><font style="vertical-align: inherit;">を有効（</font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>reject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）にします。</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/ln/ey/bb/lneybbz-tylmfanfoizqm2hscik.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この概念をコードで表現します。最も単純なケースを取り、エラー処理と他のニュアンスを削除して、無限ループが1つ残るようにします。</font><font style="vertical-align: inherit;">各反復で、読み取りまたは書き込みの準備ができているソケットについてOSをポーリングし、特定のソケットのコールバックを呼び出します。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span><font></font><span class="hljs-function">
</span>{<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {<font></font>
        stream_select($readSockets, $writeSockets, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>);<font></font>
        <font></font>
        <span class="hljs-keyword">foreach</span> ($readSockets <span class="hljs-keyword">as</span> $i =&gt; $socket) {<font></font>
            call_user_func(<span class="hljs-built_in">self</span>::readCallbacks[$i], $socket);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">// Do same for write sockets</span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQLクライアントを補完します。</font><font style="vertical-align: inherit;">SQLサーバーからのデータが処理中のソケットに到達するとすぐに、Deferredを「完了」状態にして、ソケットからPromiseにデータを転送する必要があることをイベントループに通知します。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execAsync</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> $query, <span class="hljs-keyword">array</span> $params = []</span>)</span><font></font><span class="hljs-function">
</span>{<font></font>
    $deferred = <span class="hljs-keyword">new</span> Deferred;<font></font>
    ...<font></font>
    Loop::onReadable($socket, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$socket</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$deferred</span>) </span>{<font></font>
        $deferred-&gt;resolve(socket_read($socket));<font></font>
    });<font></font>
<font></font>
    <span class="hljs-keyword">return</span> $deferred-&gt;promise();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントループ</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はI / O</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><strong><font style="vertical-align: inherit;">処理でき</font></strong></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ソケット</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><strong><font style="vertical-align: inherit;">動作し</font></strong><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">彼は他に何ができますか？</font></font><br>
<br>
<ul>
<li> JavaScript   <code>setTimeout</code>  <code>setInterval</code> — .             N . <strong>Event Loop      </strong>.</li>
<li>Event Loop  <strong>   </strong>.    <code>process control</code>,       .</li>
</ul><br>
<h3> Event Loop</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントループの記述は可能であるだけでなく、必要でもあります。非同期PHPを使用する場合は、独自の単純な実装を作成して、これがどのように機能するかを理解することが重要です。ただし、本番環境ではもちろん使用しませんが、既成の実装を採用します。安定していて、エラーがなく、動作が実証されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つの主要な実装があります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReactPHP</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 PHP 5.3で始まった最も古いプロジェクト。現在、PHPの最低限必要なバージョンは5.3.8です。プロジェクト</font><font style="vertical-align: inherit;">はJavaScriptの世界からの</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promises / A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準を実装</font><font style="vertical-align: inherit;">しています。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMPHP</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。私が使用したいのはこの実装です。最小要件はPHP 7.0です。次のバージョン以降はすでに7.3です。 Promiseの上でコルーチンを使用します。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スウール</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは興味深い中国のフレームワークで、開発者はいくつかの概念をGoの世界からPHPに移植しようとします。</font><font style="vertical-align: inherit;">英語のドキュメントは不完全であり、そのほとんどは中国語のGitHubにあります。</font><font style="vertical-align: inherit;">あなたが言語を知っているなら-進んでください、しかし今のところ私は働くのが怖いです</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zo/n3/cq/zon3cqtbmsf-vnd0uliqqupphoo.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReactPHP</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ReactPHP for MySQLを使用してクライアントがどのように見えるかを見てみましょう。</font></font><br>
<br>
<pre><code class="php hljs">$connection = (<span class="hljs-keyword">new</span> ConnectionFactory)-&gt;createLazyConnection();<font></font>
<font></font>
$promise = $connection-&gt;query(<span class="hljs-string">'UPDATE users SET ...'</span>);<font></font>
$promise-&gt;then(<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">QueryResult $command</span>) </span>{<font></font>
        <span class="hljs-keyword">echo</span> count($command-&gt;resultRows) . <span class="hljs-string">' row(s) in set.'</span>;<font></font>
    },<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">Exception</span> $error</span>) </span>{<font></font>
        <span class="hljs-keyword">echo</span> <span class="hljs-string">'Error: '</span> . $error-&gt;getMessage();<font></font>
    });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべては、私たちが書いたものとほとんど同じ</font></font><code>onnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。要求</font><font style="vertical-align: inherit;">を作成</font><font style="vertical-align: inherit;">して実行します。</font><font style="vertical-align: inherit;">結果を処理するためのコールバックを設定できます（return </font></font><code>affected rows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><br>
<br>
<pre><code class="php hljs">    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">QueryResult $command</span>) </span>{<font></font>
        <span class="hljs-keyword">echo</span> count($command-&gt;resultRows) . <span class="hljs-string">' row(s) in set.'</span>;<font></font>
    },</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラー処理のためのコールバック：</font></font><br>
<br>
<pre><code class="php hljs">    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">Exception</span> $error</span>) </span>{<font></font>
        <span class="hljs-keyword">echo</span> <span class="hljs-string">'Error: '</span> . $error-&gt;getMessage();<font></font>
    });</code></pre><br><font style="vertical-align: inherit;"></font><code>then</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReactPHPの</font><font style="vertical-align: inherit;">
各結果</font><font style="vertical-align: inherit;">もPromiseを返す</font><font style="vertical-align: inherit;">ため、これらのコールバックから長い長いチェーンを構築でき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="php hljs">$promise<font></font>
    -&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$data</span>) </span>{<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(...);<font></font>
    })<font></font>
    -&gt;then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$data</span>) </span>{<font></font>
        ...<font></font>
    }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$error</span>) </span>{<font></font>
        log($error);<font></font>
    })<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、コールバック地獄と呼ばれる問題の解決策です。</font><font style="vertical-align: inherit;">残念ながら、ReactPHP実装では、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RabbitMQに正しく接続するため</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10〜11のコールバックが</font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">必要な</font></strong><font style="vertical-align: inherit;">場合、これは「Promise hell」問題に</font><strong><font style="vertical-align: inherit;">つながり</font></strong><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">このようなコードを操作して修正することは困難です。</font><font style="vertical-align: inherit;">これは私のものではないことにすぐに気づき、AMPHPに切り替えました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Amphp</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロジェクトはReactPHPよりも新しいものであり、異なる概念- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチン</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を促進し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">AMPHPでMySQLを操作する場合、これは</font></font><code>PDOConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHPでの操作</font><font style="vertical-align: inherit;">とほとんど同じであることがわかり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="php hljs">$pool = Mysql\pool(<span class="hljs-string">"host=127.0.0.1 port=3306 db=test"</span>);<font></font>
<font></font>
<span class="hljs-keyword">try</span> {<font></font>
    $result = <span class="hljs-keyword">yield</span> $pool-&gt;query(<span class="hljs-string">"UPDATE users SET ..."</span>);<font></font>
<font></font>
    <span class="hljs-keyword">echo</span> $result-&gt;affectedRows . <span class="hljs-string">' row(s) in set.'</span>;<font></font>
} <span class="hljs-keyword">catch</span> (\<span class="hljs-built_in">Throwable</span> $error) {<font></font>
    <span class="hljs-keyword">echo</span> <span class="hljs-string">'Error: '</span> . $error-&gt;getMessage();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、プールを作成し、接続してリクエストを実行します。</font><font style="vertical-align: inherit;">エラーは通常の方法で処理でき</font></font><code>try...catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。コールバックは必要ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、非同期呼び出しの前に、キーワード-がここに表示されます</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発電機</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーワード</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、関数をジェネレーターに変えます。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generator</span>(<span class="hljs-params">$counter = <span class="hljs-number">1</span></span>)</span><font></font><span class="hljs-function">
</span>{<font></font>
    <span class="hljs-keyword">yield</span> $counter++;<font></font>
<font></font>
    <span class="hljs-keyword">echo</span> <span class="hljs-string">"A"</span>;<font></font>
<font></font>
    <span class="hljs-keyword">yield</span> $counter;<font></font>
<font></font>
    <span class="hljs-keyword">echo</span> <span class="hljs-string">"B"</span>;<font></font>
<font></font>
    <span class="hljs-keyword">yield</span> ++$counter;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHPインタープリター</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、本体内の関数に</font><font style="vertical-align: inherit;">遭遇</font><font style="vertical-align: inherit;">すると</font><font style="vertical-align: inherit;">すぐに、</font><font style="vertical-align: inherit;">それがジェネレーター関数であることを認識します。</font><font style="vertical-align: inherit;">実行される代わりに、が呼び出されたときにクラスオブジェクトが作成され</font></font><code>Generator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネレーターはイテレーターインターフェースを継承します。</font></font><br>
<br>
<pre><code class="php hljs">$generator = <span class="hljs-built_in">generator</span>(<span class="hljs-number">1</span>);<font></font>
<font></font>
<span class="hljs-keyword">foreach</span> ($generator <span class="hljs-keyword">as</span> $value) {<font></font>
    <span class="hljs-keyword">echo</span> $value;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">while</span> ($generator-&gt;valid()) {<font></font>
    <span class="hljs-keyword">echo</span> $generator-&gt;current();<font></font>
<font></font>
    $generator-&gt;next();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、サイクル</font></font><code>foreach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">など</font><font style="vertical-align: inherit;">を実行することが可能</font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">しかし、さらに興味深いことに、イテレータにはメソッド</font></font><code>current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とがあり</font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">それらを段階的に見ていきましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数を実行します</font></font><code>generator($counter = 1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ジェネレータメソッドを呼び出します</font></font><code>current()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">変数の値が返され</font></font><code>$counter++</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネレータを実行するとすぐ</font></font><code>next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、コードはジェネレータ内の次の呼び出しに移動し</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">2つの間のコード全体</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が実行されます。これはすばらしいことです。</font><font style="vertical-align: inherit;">ジェネレーターを回転し続けると、結果が得られます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、ジェネレータにはもっと興味深い機能があります。外部からジェネレータにデータを送信できます。</font><font style="vertical-align: inherit;">この場合、これは完全なジェネレーターではなく、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチン</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはコルーチンです。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printer</span>(<span class="hljs-params"></span>) </span>{  <font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {     <font></font>
        <span class="hljs-keyword">echo</span> <span class="hljs-keyword">yield</span>;       <font></font>
    }                             <font></font>
}                                <font></font>
<font></font>
$print = printer();<font></font>
$print-&gt;send(<span class="hljs-string">'Hello'</span>);<font></font>
$print-&gt;send(<span class="hljs-string">' PHPRussia'</span>);<font></font>
$print-&gt;send(<span class="hljs-string">' 2019'</span>);<font></font>
$print-&gt;send(<span class="hljs-string">'!'</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードのこのセクションでは</font></font><code>while (true)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、実行のフローをブロックせず、1回だけ実行される</font><font style="vertical-align: inherit;">ことが興味深いです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">データをCorutinに送信して受信しました</font></font><code>'Hello'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">もっと受け取った</font></font><code>'PHPRussia'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">原理は明確です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネレーターにデータを送信するだけでなく、エラーを送信して内部からエラーを処理できるため、便利です。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printer</span>(<span class="hljs-params"></span>) </span>{<font></font>
    <span class="hljs-keyword">try</span> {<font></font>
        <span class="hljs-keyword">echo</span> <span class="hljs-keyword">yield</span>;<font></font>
    } <span class="hljs-keyword">catch</span> (\<span class="hljs-built_in">Throwable</span> $e) {<font></font>
        <span class="hljs-keyword">echo</span> $e-&gt;getMessage();<font></font>
    }<font></font>
}<font></font>
<font></font>
printer()-&gt;throw(<span class="hljs-keyword">new</span> \<span class="hljs-built_in">Exception</span>(<span class="hljs-string">'Ooops...'</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要約する。</font><font style="vertical-align: inherit;">Corutinは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、現在の状態を維持しながら実行の停止と続行</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><strong><font style="vertical-align: inherit;">サポートする</font></strong><font style="vertical-align: inherit;">プログラムのコンポーネントです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Corutinは自分のコールスタックと内部のデータを記憶しており、将来的に使用することができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発電機と約束</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネレーターとプロミスのインターフェースを見てみましょう。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span></span><font></font><span class="hljs-class">
</span>{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">send</span>(<span class="hljs-params">$data</span>)</span>;<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throw</span>(<span class="hljs-params">\<span class="hljs-built_in">Throwable</span> $error</span>)</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Promise</span></span><font></font><span class="hljs-class">
</span>{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">$data</span>)</span>;<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">\<span class="hljs-built_in">Throwable</span> $error</span>)</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッド名が異なるだけで、外観は同じです。</font><font style="vertical-align: inherit;">データを送信し、ジェネレータとPromiseの両方にエラーをスローできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはどのように使用できますか？</font><font style="vertical-align: inherit;">関数を書いてみましょう。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recoil</span>(<span class="hljs-params">\<span class="hljs-built_in">Generator</span> $generator</span>)</span><font></font><span class="hljs-function">
</span>{<font></font>
    $promise = $generator-&gt;current();<font></font>
<font></font>
    $promise-&gt;onResolve(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$data</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$generator</span>) </span>{<font></font>
        $generator-&gt;send($data);<font></font>
        recoil($generator);<font></font>
    };<font></font>
<font></font>
    $promise-&gt;onReject(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$error</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$generator</span>) </span>{<font></font>
        $generator-&gt;throw($error);<font></font>
        recoil($generator);<font></font>
    });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数は、ジェネレーターの現在の値を取得します</font></font><code> $promise = $generator-&gt;current();</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少し誇張しました。</font><font style="vertical-align: inherit;">はい、返される現在の値がなんらかの</font></font><code>instanceof</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">約束</font><font style="vertical-align: inherit;">であることを確認する必要があり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">もしそうなら、私たちは彼にコールバックを求めることができます。</font><font style="vertical-align: inherit;">Promiseが成功し、関数を再帰的に開始すると、内部的にデータをジェネレータに送り返します</font></font><code>recoil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="php hljs">    $promise-&gt;onResolve(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$data</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$generator</span>) </span>{<font></font>
        $generator-&gt;send($data);<font></font>
        recoil($generator);<font></font>
    };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラーが発生しても同じことができます。</font><font style="vertical-align: inherit;">たとえば、Promiseが失敗した場合、SQLサーバーは「Too many connections」と言ったので、ジェネレーター内でエラーをスローし、次のステップに進むことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべてが、協調的マルチタスクという重要な概念につながります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">協調マルチタスク</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは一種のマルチタスクであり、現在のタスクが他のタスクにプロセッサ時間を与える準備ができていることを明示的に宣言した後にのみ、次のタスクが実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースを1つだけ処理するなど、単純なものに出くわすことはめったにありません。ほとんどの場合、ユーザーを更新するプロセスでは、データベース、検索インデックスのデータを更新してから、キャッシュを消去または更新してから、さらに15個のメッセージをRabbitMQに送信する必要があります。 PHPでは、すべてこのようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m6/w7/5n/m6w75nkbjrduxzynamn9qiinfwm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オペレーションを1つずつ実行します。データベース、インデックス、そしてキャッシュを更新しました。しかし、デフォルトでは、PHPはこのような操作（I / O）をブロックするため、よく見ると、すべてがそうです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wk/3d/wc/wk3dwckb_gjjfnoprw63gxnoxlm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暗い部分ではブロックしました。彼らは最も時間がかかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期モードで作業する場合、これらの部分は存在せず、実行タイムラインは断続的です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qj/mx/xv/qjmxxv9oiwkix-_oebyl48qbio4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたはそれをすべて一緒に接着して、1つずつ作品を作ることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t0/o0/x5/t0o0x5ddiw6pij4rlmvzst2oyaq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは何のためですか？</font><font style="vertical-align: inherit;">タイムラインのサイズを見ると、最初は時間がかかりますが、一緒に接着するとすぐにアプリケーションが高速化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントループと協調マルチタスクの概念そのものが、さまざまなアプリケーション（Nginx、Node.js、Memcached、Redis）で長い間使用されてきました。</font><font style="vertical-align: inherit;">それらはすべてイベントループ内で使用され、同じ原理に基づいて構築されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NginxおよびNode.js Webサーバーについて話し始めたので、PHPでのリクエストの処理がどのように行われるかを思い出してみましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHPでのリクエスト処理</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブラウザはリクエストを送信し、FPMストリームのプールがあるHTTPサーバーに到達します。</font><font style="vertical-align: inherit;">スレッドの1つがこの要求を処理し、コードを接続して実行を開始します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/s1/p_/bgs1p_g8r9ytthxrst0mszi7_bw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のリクエストが到着すると、別のFPMスレッドがそれを取得してコードを接続し、実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この作業計画には</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">利点</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純なエラー処理</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">何かがうまくいかず、リクエストの1つが落ちた場合、私たちは何もする必要はありません-次のリクエストが来るので、これはその作業に影響を与えません。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記憶については考えていません</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">メモリをクリーンアップしたり監視したりする必要はありません。</font><font style="vertical-align: inherit;">次のリクエストで、すべてのメモリがクリアされます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、PHPで最初から機能していて、引き続き正常に機能するクールなスキームです。</font><font style="vertical-align: inherit;">しかし、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不利な点</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も</font><strong><font style="vertical-align: inherit;">あり</font></strong><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセス数を制限します</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">サーバーに50個のFPMスレッドがある場合、51番目のリクエストが到着するとすぐに、いずれかのスレッドが解放されるまで待機します。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテキストスイッチのコスト</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">OSは、FPMストリーム間で要求を切り替えます。</font><font style="vertical-align: inherit;">このプロセッサレベルの操作は、コンテキストスイッチと呼ばれます。</font><font style="vertical-align: inherit;">それは高価であり、膨大な数の対策を実行します。</font><font style="vertical-align: inherit;">すべてのレジスタ、コールスタック、プロセッサ内のすべてを保存してから、別のプロセスに切り替え、そのレジスタとそのコールスタックをロードし、そこで何かを実行し、もう一度切り替えて、もう一度保存する必要があります...長い間。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の方法で質問に取り組みましょう。PHP自体でHTTPサーバーを作成します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期HTTPサーバー</font></font></h2><br>
<img src="https://habrastorage.org/webt/nd/dy/yt/nddyyt6dhjy0dxnkmpokppvvcr4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
できます。</font><font style="vertical-align: inherit;">ノンブロッキングモードでソケットを操作する方法はすでに学びました。HTTP接続は同じソケットです。</font><font style="vertical-align: inherit;">それはどのように見え、機能しますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはAMPHPフレームワークでHTTPサーバーを起動する例です。</font></font><br>
<br>
<pre><code class="php hljs">Loop::run(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{<font></font>
    $app = <span class="hljs-keyword">new</span> Application();<font></font>
    $app-&gt;bootstrap();<font></font>
<font></font>
    $sockets = [Socket\listen(<span class="hljs-string">'0.0.0.0:80'</span>)];<font></font>
<font></font>
    $server = <span class="hljs-keyword">new</span> Server($sockets, <span class="hljs-keyword">new</span> CallableRequestHandler(<font></font>
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Request $request</span>) <span class="hljs-title">use</span> (<span class="hljs-params">$app</span>) </span>{<font></font>
            $response = <span class="hljs-keyword">yield</span> $app-&gt;dispatch($request);<font></font>
<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Response(Status::OK, [], $response);<font></font>
        })<font></font>
    );<font></font>
<font></font>
    <span class="hljs-keyword">yield</span> $server-&gt;start();<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが非常に単純です。</font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソケットプールを</font><font style="vertical-align: inherit;">ロード</font><font style="vertical-align: inherit;">して作成します（1つ以上）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、サーバーを起動し、サーバーを設定します</font></font><code>Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、各要求で実行され</font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、応答を取得するために</font><font style="vertical-align: inherit;">要求を送信します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、サーバーを起動します</font></font><code>yield $server-&gt;start();</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ReactPHPでもほぼ同じように見えますが、さまざまなオプションに対して150のコールバックしか存在しないため、あまり便利ではありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHPの非同期にはいくつかの問題があります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準の欠如</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。各フレームワーク：Swoole、ReactPHP、またはAMPHPは独自のPromiseインターフェイスを実装しており、互換性がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AMPHPは理論的にはReactPHPのPromiseと相互作用することができますが、注意が必要です。 ReactPHPのコードが十分に記述されておらず、どこかで暗黙的にイベントループが呼び出されるか作成される場合、2つのイベントループが内部でスピンすることがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptには、Guzzleを実装する比較的良いPromises / A +標準があります。フレームワークがそれに従うといいですね。しかし、これまでのところそうではありません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリリーク</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。通常のFPMモードでPHPを使用する場合、メモリについては考慮しない場合があります。一部の拡張機能の開発者が適切なコードの記述を忘れ、Valgrindの実行を忘れ、メモリ内のどこかに流れていても、問題ありません。次のリクエストはクリアされ、再び開始されます。しかし、非同期モードでは、遅かれ早かれ私たちは単に落ちるので、これを買う余裕はありません</font></font><code>OutOfMemoryException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
修理は可能ですが、困難で苦痛です。 Xdebugは、場合によっては、straceが原因で発生したエラーを解析するのに役立ちます</font></font><code>OutOfMemoryException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブロッキングオペレーション</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。非同期コードを記述するときは、イベントループをブロックしないことが重要です。実行フローをブロックするとすぐにアプリケーションの速度が低下し、各コルーチンの実行が遅くなります。</font></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kelunik / loop-block</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
パッケージは、AMPHPのそのような操作を見つけるのに役立ちます</font><font style="vertical-align: inherit;">。タイマーを非常に短い間隔に設定します。タイマーが機能しない場合は、どこかでブロックされています。このパッケージは、ブロックする場所を見つけるのに役立ちますが、常にそうであるとは限りません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリサポート：Cassandra、Influx、ClickHouse</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。すべての非同期PHPの主な問題は、ライブラリのサポートです。すべての人に通常の</font></font><code>PDOConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>RedisClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他のドライバーを</font><font style="vertical-align: inherit;">使用することはできません</font><font style="vertical-align: inherit;">-非ブロッキング実装が必要です。また、Cドライバーが非同期コードに統合できるインターフェースを提供することはほとんどないため、非ブロッキングモードのPHPで記述する必要もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cassandraデータベースのドライバーで私が得た奇妙な体験。彼らは操作を提供します</font></font><code>ExecuteAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>GetAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">およびその他のものですが、同時に</font><font style="vertical-align: inherit;">、ブロック</font></font><code>Future</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する単一のメソッド</font></font><code>get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">オブジェクト</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">返し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">非同期で何かを取得する機会がありますが、結果を待つために、ループ全体をブロックします。</font><font style="vertical-align: inherit;">コールバックなど、何らかの方法でそれを行うには機能しません。</font><font style="vertical-align: inherit;">私は、Cassandraのクライアントを作成しました。これは、仕事で使用するためです。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプ表示</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これはAMPHPとcorutinの問題です。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span></span><font></font><span class="hljs-class">
</span>{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> $id</span>): \<span class="hljs-title">Generator</span></span><font></font><span class="hljs-function">
    </span>{<font></font>
        $data = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">$this</span>-&gt;db-&gt;query(<span class="hljs-string">'SELECT ...'</span>, $id);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> User::fill($data);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数内で発生</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すると、ジェネレータになります。</font><font style="vertical-align: inherit;">この時点では、正しい戻りデータ型を指定できなくなりました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP 8</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PHP 8では何が待ち受けていますか？</font><font style="vertical-align: inherit;">私の仮定や、むしろ私の欲望についてお話しします（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">編集者注：Dmitry Stogov </font><font style="vertical-align: inherit;">は、実際にPHP 8で何が表示されるかを</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">知って</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">います</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントループ </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントループを何らかの形でカーネルに取り込む作業が進行中であるため、表示される可能性があります。</font><font style="vertical-align: inherit;">これが発生した場合</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、JavaScriptまたはC＃のような</font><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">があり、特定の場所で非同期操作の結果を待つことができます。</font><font style="vertical-align: inherit;">この場合、拡張機能は必要ありません。すべてがカーネルレベルで非同期に機能します。</font></font><br>
<br>
<pre><code class="php hljs"><font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span></span><font></font><span class="hljs-class">
</span>{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> $id</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">User</span>&gt;</span><font></font><span class="hljs-function">
    </span>{<font></font>
        $data = await <span class="hljs-keyword">$this</span>-&gt;db-&gt;query(<span class="hljs-string">'SELECT ...'</span>, $id);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> User::fill($data);<font></font>
    }<font></font>
}</code></pre><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジェネリック </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Goはジェネリックスを待っています。私たちはジェネリックスを待っています。誰もがジェネリックスを待っています。</font></font><br>
<br>
<pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span></span><font></font><span class="hljs-class">
</span>{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> $id</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">User</span>&gt;</span><font></font><span class="hljs-function">
    </span>{<font></font>
        $data = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">$this</span>-&gt;db-&gt;query(<span class="hljs-string">'SELECT ...'</span>, $id);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> User::fill($data);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、コレクションのジェネリックスを待つのではなく、Promiseの結果が正確にUserオブジェクトになることを示します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜこれなのか？</font></font></h2><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スピードとパフォーマンスのために。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHPは、ほとんどの操作がI / Oバウンドである言語です。</font><font style="vertical-align: inherit;">プロセッサでの計算に大幅に関連するコードを記述することはほとんどありません。</font><font style="vertical-align: inherit;">ほとんどの場合、ソケットを使用します。データベースに要求を出し、何かを読み取り、応答を返し、ファイルを送信する必要があります。</font><font style="vertical-align: inherit;">非同期により、このようなコードを高速化できます。</font><font style="vertical-align: inherit;">1000リクエストの平均応答時間を見ると、約8倍、10,000リクエストで約6倍高速化できます。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2020年5月13日、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHPロシア</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">2度目の集まり</font><font style="vertical-align: inherit;">、言語、ライブラリ、フレームワーク、生産性を向上させる方法、誇大広告ソリューションの落とし穴について話し合います。</font><font style="vertical-align: inherit;">最初の4 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">件のレポート</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を受け入れました</font><font style="vertical-align: inherit;">が、ペーパーの募集はまだ続いています。</font><font style="vertical-align: inherit;">コミュニティで体験を共有したい場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">申請し</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">てください。</font></font></blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja487246/index.html">Tensor証明機関が顧客の秘密キーを侵害する可能性があります</a></li>
<li><a href="../ja487248/index.html">不適切なテストについてもう少し</a></li>
<li><a href="../ja487250/index.html">遅延アルファブレンディング</a></li>
<li><a href="../ja487254/index.html">侵入者を監視するだけでなくCCTVカメラを使用する方法</a></li>
<li><a href="../ja487256/index.html">灰やフェニックスの人々から燃えて帰る</a></li>
<li><a href="../ja487260/index.html">NoVerify：高速に動作するPHPリンター</a></li>
<li><a href="../ja487262/index.html">オープンカンファレンスPHPロシアオンライン</a></li>
<li><a href="../ja487266/index.html">GitLab 12.7が親子パイプラインとWindows用の一般的なジョブハンドラーのベータ版とともにリリースされました</a></li>
<li><a href="../ja487270/index.html">ペロブスカイトはガジェット画面の寿命を延ばすことができます</a></li>
<li><a href="../ja487272/index.html">ブックマーク-カウントが終了しました</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>