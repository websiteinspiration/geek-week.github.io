<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚 🎖️ 👟 スタートアップASP.NETコアの非同期コード：GetAwaiter（）を回避する4つの方法GetResult（） ▪️ ♋️ 📙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="async / awaitメカニズムはC＃5.0で導入されて以来、非同期コードを同期で使用することは非常に悪いことであるということを、すべての記事とドキュメントで常に教えてきました。そして、彼らはGetAwaiter（）のような恐怖を要求します。ただし、Microsoftプログラマー自身がこの設計を...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>スタートアップASP.NETコアの非同期コード：GetAwaiter（）を回避する4つの方法GetResult（）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/496300/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / awaitメカニズムはC＃5.0で導入されて以来、非同期コードを同期で使用することは非常に悪いことであるということを、すべての記事とドキュメントで常に教えてきました。</font><font style="vertical-align: inherit;">そして、彼らはGetAwaiter（）のような恐怖を要求します。</font><font style="vertical-align: inherit;">ただし、Microsoftプログラマー自身がこの設計を軽視しないケースが1つあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yl/m9/nb/ylm9nbu--2sz9pzjxu-tgx8k5t4.png"><br>
 <a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕事の背景</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、レガシー認証から業界の標準となっているOAuth 2.0への移行を進めています。</font><font style="vertical-align: inherit;">私が現在取り組んでいるサービスは、新しいシステムとの統合とJWT認証への移行のパイロットになりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
統合プロセスでは、さまざまなオプションを検討しながら、トークンプロバイダー（この場合はIdentityServer）の負荷を減らし、システム全体の信頼性を高める方法を実験しました。</font><font style="vertical-align: inherit;">JWTベースの検証をASP.NET Coreに接続することは非常に簡単で、トークンプロバイダーの特定の実装に結び付けられていません。</font></font><br>
<br>
<pre><code class="cs hljs">services<font></font>
      .AddAuthentication()<font></font>
      .AddJwtBearer(); <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これら2つの線の背後に隠されているものは何でしょうか。</font><font style="vertical-align: inherit;">それらの内部では、JWTBearerHandlerが作成され、APIクライアントからのJWTをすでに処理しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fs/sx/ce/fssxce2duwjnem0_zgekkezhglm.jpeg" width="550"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要求</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
時</font><i><font style="vertical-align: inherit;">のクライアント、API、およびトークンプロバイダーの相互作用</font></i><font style="vertical-align: inherit;"> JWTBearerHandlerは、クライアントからトークンを受信すると、検証のためにプロバイダーにトークンを送信しませんが、逆に、署名鍵プロバイダー（トークンに署名する鍵の公開部分）を要求します。このキーに基づいて、トークンが正しいプロバイダーによって署名されていることが確認されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JWTBearerHandlerの内部にはHttpClientがあり、ネットワークを介してプロバイダーと対話します。ただし、プロバイダーの署名キーが頻繁に変更される予定がない場合は、アプリケーションの起動時に一度取得して、自分自身をキャッシュし、一定のネットワーク要求を取り除くことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
署名キーの次のコードを取得しました：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AuthenticationBuilder <span class="hljs-title">AddJwtAuthentication</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> AuthenticationBuilder builder, AuthJwtOptions options</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> signingKeys = <span class="hljs-keyword">new</span> List&lt;SecurityKey&gt;();<font></font>
<font></font>
    <span class="hljs-keyword">var</span> jwtBearerOptions = <span class="hljs-keyword">new</span> JwtBearerOptions {Authority = options?.Authority};<font></font>
    <font></font>
    <span class="hljs-keyword">new</span> JwtBearerPostConfigureOptions().PostConfigure(<span class="hljs-keyword">string</span>.Empty, jwtBearerOptions);
    <span class="hljs-keyword">try</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> config = jwtBearerOptions.ConfigurationManager<font></font>
            .GetConfigurationAsync(<span class="hljs-keyword">new</span> CancellationTokenSource(options?.AuthorityTimeoutInMs ?? <span class="hljs-number">5000</span>).Token)<font></font>
            .GetAwaiter().GetResult();<font></font>
        <span class="hljs-keyword">var</span> providerSigningKeys = config.SigningKeys;<font></font>
        signingKeys.AddRange(providerSigningKeys);<font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span> (Exception)<font></font>
    {<font></font>
        <span class="hljs-comment">// ignored</span><font></font>
    }<font></font>
<font></font>
    builder<font></font>
        .AddJwtBearer(options =&gt;<font></font>
        {<font></font>
            options.TokenValidationParameters = <span class="hljs-keyword">new</span> TokenValidationParameters<font></font>
            {<font></font>
                <span class="hljs-comment">// ...</span><font></font>
                IssuerSigningKeys = signingKeys,<font></font>
                <span class="hljs-comment">// ...</span><font></font>
            };<font></font>
        });<font></font>
    <span class="hljs-keyword">return</span> builder;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
12行目で、.GetAwaiter（）と出会います。</font><font style="vertical-align: inherit;">これは、Startupクラスのpublic void ConfigureServices（IServiceCollection services）{...}内でAuthenticationBuilderが構成されており、このメソッドに非同期バージョンがないためです。</font><font style="vertical-align: inherit;">トラブル。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C＃7.1以降、非同期のMain（）があります。</font><font style="vertical-align: inherit;">ただし、Asp.NET Coreの非同期スタートアップ構成メソッドはまだ提供されていません。</font><font style="vertical-align: inherit;">GetAwaiter（）を作成することに美的に悩まされました（）GetResult（）（私はこれをしないように教えられました！）そこで、私はオンラインで他の人がこの問題に対処する方法を探しました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetAwaiter（）に悩まされています。GetResult（）ですが、Microsoftはそうではありません。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の1つは、Microsoftプログラマー</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がAzure KeyVaultからシークレット</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">取得</font></a><font style="vertical-align: inherit;">する</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ために</font></a><font style="vertical-align: inherit;">同様のタスクで使用するオプションを見つけました</font><font style="vertical-align: inherit;">。抽象化のいくつかの層を下に進むと、次のようになります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Load</span>(<span class="hljs-params"></span>)</span> =&gt; LoadAsync().ConfigureAwait(<span class="hljs-literal">false</span>).GetAwaiter().GetResult();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
こんにちは、GetAwaiter（）。GetResult（）！</font><font style="vertical-align: inherit;">他の解決策はありますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短いグーグルの後、私</font><font style="vertical-align: inherit;">は1年前に私と同じ問題について考えていたAndrew Lock </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">による一連の素晴らしい記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を見つけました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">同じ理由でさえ-彼は審美的に非同期コードを同期的に呼び出すのが好きではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、このトピックに興味があるすべての人に、Andrewによる5つの記事のシリーズ全体を読むことをお勧めします。</font><font style="vertical-align: inherit;">そこで彼は、どの作業タスクがこの問題につながるのかを詳細に分析し、次にいくつかの誤ったアプローチを検討し、その後で解決策を説明します。</font><font style="vertical-align: inherit;">私の記事では、解決策にさらに集中して、彼の研究について簡単に説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Webサービスの開始における非同期タスクの役割</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一歩戻って全体像を確認します。</font><font style="vertical-align: inherit;">フレームワークに関係なく、私が解決しようとした概念的な問題は何ですか？</font></font><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントのリクエストを処理するようにWebサービスを開始する必要がありますが、いくつかの（比較的）長い操作のセットがあり、それがないとサービスはクライアントに応答できないか、その応答が正しくありません。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そのような操作の例：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">強く型付けされた構成の検証。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュを満たします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースまたは他のサービスへの予備接続。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JITおよびアセンブリのロード（サービスのウォーミングアップ）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースの移行。</font><font style="vertical-align: inherit;">これはAndrew Lockの例の1つですが、彼自身、結局のところ、この操作は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスの開始時に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">望ましくない</font></a><font style="vertical-align: inherit;">ことを認めて</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">います</font></a><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GetAwaiter（）。GetResult（）なしで、アプリケーションの起動時に任意の非同期タスクを自然な方法で実行できるソリューションを見つけたいと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのタスクは、アプリケーションが要求の受け入れを開始する前に完了する必要がありますが、その作業には、アプリケーションの構成および登録されたサービスが必要になる場合があります。</font><font style="vertical-align: inherit;">したがって、これらのタスクはDI構成の後に実行する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアイデアは、図の形で表すことができます。</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nc/eh/ym/ncehymvjo0cm3yz5p3uq-uycvpq.jpeg"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解決策1：相続人を混乱させる可能性のある実用的な解決策</font></font></h2><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lockが提供する</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最初の実用的なソリューション</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><font></font>
{<font></font>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span><font></font>
   {<font></font>
       IWebHost webHost = CreateWebHostBuilder(args).Build();<font></font>
<font></font>
       <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> scope = webHost.Services.CreateScope())<font></font>
       {<font></font>
           <span class="hljs-comment">//   </span>
           <span class="hljs-keyword">var</span> myService = scope.ServiceProvider.GetRequiredService&lt;MyService&gt;();<font></font>
<font></font>
           <span class="hljs-keyword">await</span> myService.DoAsyncJob();<font></font>
       }<font></font>
<font></font>
       <span class="hljs-keyword">await</span> webHost.RunAsync();<font></font>
   }<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IWebHostBuilder <span class="hljs-title">CreateWebHostBuilder</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span> =&gt;<font></font>
       WebHost.CreateDefaultBuilder(args)<font></font>
           .UseStartup&lt;Startup&gt;();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは、C＃7.1からの非同期Main（）の登場により可能になりました。</font><font style="vertical-align: inherit;">その唯一の欠点は、構成部分をStartup.csからProgram.csに転送したことです。</font><font style="vertical-align: inherit;">ASP.NETフレームワークのこのような非標準のソリューションは、コードを継承する人を混乱させる可能性があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解決策2：非同期操作をDIに埋め込む</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、Andrewはソリューションの改良版を提案しました。</font><font style="vertical-align: inherit;">非同期タスクのインターフェースが宣言されています：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IStartupTask</span><font></font>
{<font></font>
    <span class="hljs-function">Task <span class="hljs-title">ExecuteAsync</span>(<span class="hljs-params">CancellationToken cancellationToken = <span class="hljs-keyword">default</span></span>)</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、これらのタスクをDIに登録する拡張メソッド：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ServiceCollectionExtensions</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IServiceCollection AddStartupTask&lt;T&gt;(<span class="hljs-keyword">this</span> IServiceCollection services)
        <span class="hljs-keyword">where</span> T : <span class="hljs-keyword">class</span>, <span class="hljs-title">IStartupTask</span><font></font>
        =&gt; services.AddTransient&lt;IStartupTask, T&gt;();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、すでにIWebHost用に別の拡張メソッドが宣言されています。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StartupTaskWebHostExtensions</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">RunWithTasksAsync</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> IWebHost webHost, CancellationToken cancellationToken = <span class="hljs-keyword">default</span></span>)</span><font></font>
    {<font></font>
        <span class="hljs-comment">//      DI</span>
        <span class="hljs-keyword">var</span> startupTasks = webHost.Services.GetServices&lt;IStartupTask&gt;();<font></font>
<font></font>
        <span class="hljs-comment">//   </span>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> startupTask <span class="hljs-keyword">in</span> startupTasks)<font></font>
        {<font></font>
            <span class="hljs-keyword">await</span> startupTask.ExecuteAsync(cancellationToken);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">//    </span>
        <span class="hljs-keyword">await</span> webHost.RunAsync(cancellationToken);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてProgram.csでは、1行だけを変更します。</font><font style="vertical-align: inherit;">代わりに：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">await</span> CreateWebHostBuilder(args).Build().Run();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは次のように呼びます：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">await</span> CreateWebHostBuilder(args).Build().RunWithTasksAsync();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では、アプリケーションを起動するときに、長時間の操作をできるだけ透過的に行う優れたアプローチです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解決策3：ASP.NET Core 3.xに切り替えた人向け</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ASP.NET Core 3.xを使用している場合は、別のオプションがあります。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andrew Lockの記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を再び参照し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ASP.NET Core 2.xからのWebHost起動コードは次のとおりです。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WebHost</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">StartAsync</span>(<span class="hljs-params">CancellationToken cancellationToken = <span class="hljs-keyword">default</span></span>)</span><font></font>
    {<font></font>
        <span class="hljs-comment">// ... initial setup</span>
        <span class="hljs-keyword">await</span> Server.StartAsync(hostingApp, cancellationToken).ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Fire IApplicationLifetime.Started</span><font></font>
        _applicationLifetime?.NotifyStarted();<font></font>
<font></font>
        <span class="hljs-comment">// Fire IHostedService.Start</span>
        <span class="hljs-keyword">await</span> _hostedServiceExecutor.StartAsync(cancellationToken).ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
<font></font>
        <span class="hljs-comment">// ...remaining setup</span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして</font><font style="vertical-align: inherit;">、これはASP.NET Core 3.0の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じメソッド</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WebHost</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">StartAsync</span>(<span class="hljs-params">CancellationToken cancellationToken = <span class="hljs-keyword">default</span></span>)</span><font></font>
    {<font></font>
        <span class="hljs-comment">// ... initial setup</span><font></font>
<font></font>
        <span class="hljs-comment">// Fire IHostedService.Start</span>
        <span class="hljs-keyword">await</span> _hostedServiceExecutor.StartAsync(cancellationToken).ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
<font></font>
        <span class="hljs-comment">// ... more setup</span>
        <span class="hljs-keyword">await</span> Server.StartAsync(hostingApp, cancellationToken).ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Fire IApplicationLifetime.Started</span><font></font>
        _applicationLifetime?.NotifyStarted();<font></font>
<font></font>
        <span class="hljs-comment">// ...remaining setup</span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ASP.NET Core 3.xでは、HostedServicesが最初に起動され、次にメインのWebHostが起動されます。以前はまったく逆でした。</font><font style="vertical-align: inherit;">これは私たちに何を与えますか？</font><font style="vertical-align: inherit;">これで、すべての非同期操作をIHostedServiceインターフェイスのStartAsync（CancellationToken）メソッド内で呼び出すことができ、個別のインターフェイスや拡張メソッドを作成せずに同じ効果を得ることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解決策4：ヘルスチェックとKubernetesのストーリー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで落ち着くかもしれませんが、別のアプローチがあり、それが突然、現在の現実で重要であることが判明しました。これはヘルスチェックの使用です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的な考え方は、サービスがリクエストを受け入れる準備ができていることをロードバランサーに通知するために、Kestrelサーバーをできるだけ早く起動することです。ただし、同時に、ヘルスチェック以外のすべてのリクエストは503（Service Unavailable）を返します。</font><font style="vertical-align: inherit;">ASP.NET Coreでヘルスチェックを使用する方法について</font><font style="vertical-align: inherit;">は、Microsoftのサイトにかなり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">広範な記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります</font><font style="vertical-align: inherit;">。タスクに適用される特別な詳細なしでこのアプローチを検討したかったのです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Andrew Lockは、</font><font style="vertical-align: inherit;">このアプローチについて</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別の記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">持ってい</font><font style="vertical-align: inherit;">ます。その主な利点は、ネットワークのタイムアウトを回避できることです。</font></font><br>
<blockquote> ,          ,    ,     .  Kestrel   ,       ,       «   ».</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、ヘルスチェックアプローチのための完全なAndrew Lockソリューションは提供しません。かなりボリュームがありますが、複雑なものはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単に説明すると、非同期操作の完了を待たずにWebサービスを開始する必要があります。この場合、ヘルスチェックエンドポイントはこれらの操作のステータスを認識し、実行中に503を発行し、すでに完了しているときに200を発行する必要があります。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正直なところ、私がこのオプションを研究したとき、私は特定の懐疑論を持っていました。以前のアプローチと比較して、ソリューション全体が扱いにくいように見えました。そして、類推をすると、これは</font><font style="vertical-align: inherit;">、すでにおなじみの非同期/待機の代わりに、イベントサブスクリプションで</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EAPアプローチ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を再び使用する方法</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、その後Kubernetesが登場しました。</font><font style="vertical-align: inherit;">彼は準備プローブという独自の概念を持っています。</font><font style="vertical-align: inherit;">私は無料のプレゼンテーションで「Kubernetes in Action」という本から引用します。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常に準備プローブを決定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
準備プローブがない場合、ポッドはほぼ瞬時にサービスのエンドポイントになります。</font><font style="vertical-align: inherit;">アプリケーションが着信リクエストを受け入れる準備に時間がかかりすぎる場合、サービスに対する顧客のリクエストも、着信接続を受け入れる準備ができていないポッドを開始することになります。</font><font style="vertical-align: inherit;">その結果、クライアントは「接続拒否」エラーを受け取ります。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は簡単な実験を行いました。HostedServiceで長い非同期タスクを使用してASP.NET Core 3サービスを作成しました。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LongTaskHostedService</span> : <span class="hljs-title">IHostedService</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">StartAsync</span>(<span class="hljs-params">CancellationToken cancellationToken</span>)</span><font></font>
    {<font></font>
            Console.WriteLine(<span class="hljs-string">"Long task started..."</span>);
            <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">5000</span>, cancellationToken);<font></font>
            Console.WriteLine(<span class="hljs-string">"Long task finished."</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">StopAsync</span>(<span class="hljs-params">CancellationToken cancellationToken</span>)</span><font></font>
    {...}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
minikubeを使用してこのサービスを開始した後、遅延を5秒以内に2に減らしたところ、1秒ごとに私のリクエストから有用な情報が得られませんでしたが、「接続が拒否されました」。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes 1.16 UPD</font></font></b><div class="spoiler_text">    , ,   Kubernetes 1.16  startup probe (   ).     ,     readiness probe.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>.      .<br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべての研究からどのような結論を導き出すことができますか？</font><font style="vertical-align: inherit;">おそらく、誰もが自分のプロジェクトに最適なソリューションを決定する必要があります。</font><font style="vertical-align: inherit;">非同期操作にそれほど時間がかからず、クライアントに何らかの再試行ポリシーがあると想定される場合は、GetAwaiter（）から始まり、ASP.NET Core 3.xのIHostedServiceで終わるすべてのアプローチを使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、Kubernetesを使用して非同期操作をかなり長時間実行できる場合は、ヘルスチェック（準備/起動プローブ）なしでは実行できません。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja496284/index.html">ロシアで石油を検索する方法</a></li>
<li><a href="../ja496286/index.html">新しいFederation / Eagle宇宙船の計算方法。TESISへのインタビュー</a></li>
<li><a href="../ja496288/index.html">ターゲット言語の1つとしてKotlinを選択した理由。パート1：回顧</a></li>
<li><a href="../ja496290/index.html">args4jライブラリを使用するKotlin / Javaコンソールユーティリティ</a></li>
<li><a href="../ja496292/index.html">脊髄の神経刺激は、脊髄損傷後に麻痺した人々が歩くことを可能にします</a></li>
<li><a href="../ja496302/index.html">ハッカーが不在の間にハッカーに会社を渡さない方法。SOCスペシャリストのためのヒント</a></li>
<li><a href="../ja496304/index.html">ゲームの作成中にUE4を学習し続ける方法</a></li>
<li><a href="../ja496308/index.html">シームレスなノイズマップを作成する</a></li>
<li><a href="../ja496310/index.html">Spark SQLを使用して練習する、またはレーキを踏まない方法</a></li>
<li><a href="../ja496312/index.html">CentOS 8にAIDE（Advanced Intrusion Detection Environment）をインストールして使用する方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>