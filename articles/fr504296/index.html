<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🎨 🏮 👩🏻‍🤝‍👨🏽 Génération de branches aléatoires en Python ✌🏽 👶🏿 🤙🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rappelant Dawkins, l'idée principale peut être exprimée comme suit: si vous gardez la tornade sur la poubelle pendant longtemps , alors un Boeing 747 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Génération de branches aléatoires en Python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504296/"><img src="https://habrastorage.org/webt/fy/vd/nr/fyvdnr83rzvq1tow9chyg7e0kry.gif" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rappelant Dawkins, l'idée principale peut être exprimée comme suit: si vous </font><font style="vertical-align: inherit;">gardez la tornade sur la poubelle pendant </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">longtemps</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , alors un Boeing 747 peut s'assembler. L'émergence d'une structure du chaos par un durik: triant et recombinant tout d'affilée, de tous les processus dénués de sens et désordonnés, on peut en voir des assez significatifs et ordonnés. Si de tels processus sont fixes et répétés d'une manière ou d'une autre, alors le système, qui était hier un mouvement brownien, commence aujourd'hui à ressembler à un comportement mis en place par une main invisible et à effectuer des actions significatives de notre point de vue. En même temps, il n'y a aucune main. Elle s'est installée.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour m'en assurer à nouveau, je m'efforce d'écrire une sorte de vie numérique qui, hors du chaos et sans instructions inutiles d'une personne, pourra générer de façon aléatoire une logique pour elle-même et exister sur elle dans son habitat naturel - le système d'exploitation. Oui, en cela, il y a probablement une différence avec de nombreux programmes de la direction de la «vie artificielle», qui «vivent» dans les corrals, produisent des «prédateurs» et des «herbivores» et coexistent dans des domaines artificiels avec la «nourriture» et entre eux. Aucun de ces programmes n'interagit avec les objets système (processus, fichiers, etc.), ce qui signifie que le code ne vit pas vraiment. De plus, ce code, d'une manière ou d'une autre, effectue toujours une sorte de tâche dont une personne a besoin et dont la portée est très limitée à cause de cela.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour implémenter du code avec une grande liberté d'action dans le système d'exploitation, qui en même temps ne serait pas simplement un ensemble chaotique d'instructions exécutables, un modèle est apparu qui se compose de 3 modules. </font></font><br>
<a name="habracut"></a><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le module de génération aléatoire du code exécutable principal</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Module d'éducation aléatoire</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le module "vision par ordinateur" des objets OS</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, nous parlerons du premier module, qui jusqu'à présent n'est que la génération de branchements aléatoires, c'est-à-dire constructions comme "if-elif-else". Pourquoi se ramifier? Parce que, dans l'ensemble, la vie de tout organisme vivant se compose de réactions conditionnées: tout ce que nous faisons est une réponse à une information perçue. Les cellules se divisent si certaines conditions se produisent, la victime tente de s'échapper s'il voit un prédateur plus fort, et s'il est plus faible, il peut essayer de l'attaquer, les cafards se dispersent si la lumière s'allume, une personne va manger, s'il a faim, etc. etc. - cette rangée est sans fin. Il n'y a pas d'actions indépendantes et séparées qui ne soient conditionnées par rien. Par conséquent, le comportement des organismes vivants en particulier est décrit comme une réaction à la condition: SI [quelque chose] ALORS [quelque chose]. Nous essayons de générer ce comportement.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi au hasard? Afin de laisser le code l'opportunité maximale d'agir indépendamment et d'éloigner autant que possible la personne (programmeur) de ce processus (idéalement complètement exclue). Ce dernier est le plus difficile pour le programmeur, car la programmation standard, à laquelle tout le monde est habitué, ressemble à un dur entraînement des animaux, qui doit effectuer exactement ce que le programmeur indique, exactement comme il l'indique quand il l'indique. Ici, la situation est inverse: le code généré final doit agir de manière à être aussi imprévisible pour le créateur de son générateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de passer aux diagrammes et au code du générateur, il est nécessaire de s'attarder sur la fonction de prise de décision, qui sert de conducteur, permettant d'exécuter l'une ou l'autre partie du code. J'ai écrit à son sujet plus tôt</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . J'ai ensuite été invité à décrire l'idée de l'apprentissage par renforcement et le jeu de John Conway, intitulé «Life». Il se pourrait bien que je n'ai rien contre l'utilisation de ce qui a déjà été développé ou ouvertement. Au final, tout ce qui est nouveau est une synthèse du déjà connu, et j'ai moi-même admis avoir adopté l'idée de prioriser les flux, qui est utilisée dans Windows. Ici, elle est très appropriée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Actuellement, la fonction mentionnée a été légèrement transformée:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_solution</span>(<span class="hljs-params">p_random, p_deter</span>):</span>                       
    deter_flag = <span class="hljs-number">0</span>
    random_flag = <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> p_random &gt;= random.random():<font></font>
            p_random-=<span class="hljs-number">0.01</span>                                  <span class="hljs-comment">#  </span>
            p_deter+=<span class="hljs-number">0.01</span>
            random_flag = <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> p_deter &gt;= random.random():<font></font>
            p_deter-=<span class="hljs-number">0.01</span>                                   <span class="hljs-comment">#  </span>
            p_random+=<span class="hljs-number">0.01</span>
            deter_flag = <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> random_flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> deter_flag == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span>(p_random, p_deter, <span class="hljs-number">1</span>)
    <span class="hljs-keyword">elif</span> deter_flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> random_flag == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span>(p_random, p_deter, <span class="hljs-number">-1</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> (p_random, p_deter,<span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En entrée, il prend 2 probabilités (par défaut au départ elles sont toutes deux égales à 0,5), après quoi il vérifie leur fonctionnement un par un. La probabilité déclenchée diminue d'elle-même de 1% et en même temps augmente l'autre de 1%. Par conséquent, chaque fois que la probabilité fonctionne, elle diminue et l'autre augmente. En conséquence, aucune probabilité n'obtient trop d'avantage sur une autre, et ils s'auto-équilibrent, formant une distribution normale centrée sur 0,5 et avec un quartier de travail ne dépassant pas + -10%, ce qui distingue cette fonction du hasard standard, où la probabilité dans notre cas Il serait toujours égal à 0,5 et ne dépendrait pas des calculs précédents.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au sens figuré, il s'agit d'un pendule de probabilité de faible amplitude. Si la première probabilité a fonctionné et la seconde n'a pas fonctionné, elle renvoie 1, sinon -1 est renvoyée, et si les deux ont fonctionné ou n'ont pas fonctionné, 0. Ainsi, la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour 2 probabilités entrantes renvoie l'une des 3 actions possibles, donnant un équilibre solution fourchue avec 3 options de continuation possibles. À l'avenir, cette fonction est susceptible d'être universelle et pourra prendre un nombre indéfini de probabilités, car la variation au niveau des fourches peut être supérieure à 3, mais dans le cas du générateur if-elif-else, trois options de poursuite suffisent largement.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient également de noter ici que dans le code, il existe différentes, pour ainsi dire, des fourches typiques. Par exemple, comme on le verra ci-dessous, dans la fonction principale du générateur, il y a une fourchette dans laquelle il y a un choix de schéma pour construire une branche, dont il n'y en a que 3, mais d'autres cas sont également présents dans le code: insérer un bloc d'action ou démarrer une récursivité, combien de lignes d'action doivent être générées, combien compliqué cela devrait être ligne avec la condition, mettre ou ou et, elif ou autre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je crois que le pendule probabiliste, dont nous avons parlé ci-dessus, devrait être défini pour chaque type d'action: alors la fourche n'est équilibrée que sur la base de ce qui s'est passé plus tôt sur cette fourchette, et pas dans d'autres parties du code. Ceux. lors du choix de la structure générale de branchement, nous avons notre propre paire de probabilités, et à l'intérieur, lorsque ses éléments sont construits, une autre.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr, vous pouvez équilibrer toutes les actions avec une seule paire, mais la probabilité à chaque fourche sera alors très difficile et dépendra de toutes les actions précédentes à d'autres jonctions. Le caractère aléatoire d'un tel design sera encore plus élevé, mais pour l'instant je suis personnellement enclin au premier schéma, car j'aime le design où d'autres petits se balancent dans le cadre d'un grand pendule oscillant, c'est-à-dire des soldes plus petits naissent dans un seul grand équilibre. De plus, dans le deuxième schéma, le caractère aléatoire est également plus que suffisant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de l'écriture du générateur de branche, il était nécessaire de créer non seulement un code exploitable qui produit des générations sans erreur, mais aussi un code qui </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pourrait</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">générer le maximum de constructions possibles de if-elif-else, mais il n'y a pas 2 ou 3 de ces options possibles. Considérons, par exemple, les schémas possibles suivants. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qu/oj/i3/quoji3ppc2arksk-xwafu3lfiqm.jpeg" width="350" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par l'icône </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[..]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans les schémas, j'entends un ensemble d'expressions pour une condition ou un bloc d'actions aléatoires. Le schéma le plus élémentaire est 1, où la condition va simplement, et ensuite le bloc d'action. 2a et 2b sont si des variations avec un elif ou un autre. Dans l'option 2c, si vient déjà en combinaison avec plusieurs elif sans autre. Et enfin, dans l'option 2d, le schéma le plus général est présenté, où if contient plusieurs elif et 1 else.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout serait simple sans la nécessité de construire des succursales illimitées. Après chaque if, elif ou else, la récursivité peut être appelée, qui à son tour peut également récurser davantage et produire de nouveaux blocs elif-else vers la «droite». Regardons le schéma des options possibles. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y0/0z/vr/y00zvr1zkcwxuceu28olrpfabpo.jpeg" width="400" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les modes de réalisation 2e et 2f montrent des cas spéciaux simples d'une telle ramification récursive lorsque la récursivité est appelée soit après un seul elif, soit après un seul autre. L'option 2g décrit le cas le plus complexe et le plus général d'une telle récursivité, quand après chaque elif il peut y avoir un bloc d'action + récursion (ou immédiatement récursivité), et la même chose peut se produire après autre chose. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe encore des variations lorsque la récursivité se produit immédiatement après if ou après if et un bloc d'action.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/dv/ye/hxdvyem6hl667rv0v-e-mjhpiv8.jpeg" width="400" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela se voit dans les options 3a et 3b. L'option 3c présente un tel schéma sous sa forme la plus générale. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela ne veut pas dire que les schémas ci-dessus couvrent toutes les options possibles pour la construction de branches, mais même sous cette forme, le code final donne facilement naissance à des branches de 150 lignes, allant «à droite» en 10 à 15 étapes. Dans tous les cas, compliquer le schéma si nécessaire n'est pas difficile. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez regarder un exemple d' </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> telle génération pour vous assurer que les branches peuvent être très diverses.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zs/8j/gd/zs8jgd-5efc6vzg0thgjztgfyq0.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous n'avez pas besoin de prêter attention à la composition des expressions conditionnelles et des blocs d'action - pour la simplicité visuelle, ils sont générés à partir uniquement de combinaisons de deux variables, 3 expressions et un petit nombre de signes arithmétiques et logiques. Une discussion sur la véritable «viande» pour la recombinaison est au-delà de la portée de cet article (cela sera discuté dans la discussion de 3 modules). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de procéder à un examen direct du code du générateur, il est nécessaire de se rappeler que les blocs générés doivent être décalés horizontalement vers la droite, s'il est elif, sinon, si des blocs de récursivité ou d'action, et aussi "revenir" vers la gauche après la fin de la branche. De plus, étant donné que Python est très pointilleux sur les retraits horizontaux, il est souhaitable de rendre l'étape identique (dans notre cas, l'étape est 3).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le diagramme suivant illustre comment les déplacements sont décalés. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mu/p8/ue/mup8uegwtzj-fydzcdcsswbsutw.jpeg" width="500" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La chose la plus importante ici est que les déplacements avec l'approfondissement des branches se déplacent toujours vers la droite. Cependant, si nous avons, par exemple, un bloc elif-else dans lequel il y a plusieurs elif ou une seule paire elif-else, alors il est nécessaire de "retourner" le chariot qui flottait vers la droite, de sorte que le prochain elif (ou bien) commence par mêmes décalages que le précédent du bloc. Pour ce faire, vous devez enregistrer le décalage d'origine ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wall_offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) et après la fin de la génération de branche (par exemple, ramification complète d'un elif), restaurez-la. Cela garantit que les éléments elif, else dans le bloc sont «les uns sur les autres» uniformément. De plus, chaque nouveau bloc a son propre déplacement. La même astuce fournit l'harmonie dans la construction globale if-elif-else (y compris les récursions). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons maintenant au code. Le code avec un volume total d'environ 200 lignes se compose de 8 fonctions, dont une que nous avons examinée ci-dessus. En raison de la récursivité et d'un grand nombre de paramètres transmis aux fonctions, il peut être mal lisible par endroits. Pour commencer, je citerai la «viande» très utilisée pour générer des expressions conditionnelles et des blocs d'action.</font></font><br>
<br>
<pre><code class="python hljs">var_list = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>]<font></font>
exp_list = [<span class="hljs-string">'a+b'</span>,<span class="hljs-string">'b-a'</span>, <span class="hljs-string">'b//a'</span>]<font></font>
sign = [<span class="hljs-string">'+'</span>,<span class="hljs-string">'-'</span>,<span class="hljs-string">'/'</span>,<span class="hljs-string">'*'</span>,<span class="hljs-string">'//'</span>]<font></font>
sign2 = [<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'=='</span>,<span class="hljs-string">'&gt;='</span>,<span class="hljs-string">'&lt;='</span>,<span class="hljs-string">'!='</span>]<font></font>
a = <span class="hljs-number">3</span>
b = <span class="hljs-number">2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, deux variables sont utilisées: a et b ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), qui sont initialisées, 3 expressions arithmétiques ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exp_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), et également deux feuilles avec des signes ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sign, sign2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Comme mentionné précédemment, la composition des expressions résultantes n'a plus d'importance maintenant et n'est pas considérée dans cet article - elles sont principalement nécessaires pour illustrer le code. Une particularité supplémentaire doit être notée: lors de la génération du bloc elif-else, vous devez suivre l'apparence de else et arrêter la génération, sinon d'autres peuvent apparaître avant elif, ce qui naturellement provoquera une erreur. Le drapeau </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin_else_flag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est utilisé à cet effet </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous commençons notre examen par la fonction de génération principale.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">if_gen</span>(<span class="hljs-params">exp_list, var_list, if_str, offset_koeff, fin_else_flag, prob_list</span>):</span>             <font></font>
    choice_list = [exp_list, var_list]<font></font>
    base_offset = <span class="hljs-string">' '</span>
    <span class="hljs-comment">#   </span>
    prob_list[<span class="hljs-number">0</span>],prob_list[<span class="hljs-number">1</span>],sol = make_solution(prob_list[<span class="hljs-number">0</span>],prob_list[<span class="hljs-number">1</span>])       
    <span class="hljs-comment"># if +   (1   )        </span>
    <span class="hljs-keyword">if</span> sol == <span class="hljs-number">0</span>: 
        <span class="hljs-comment">#     +3                                                                   </span>
        action_str = action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list)                 
        <span class="hljs-keyword">return</span>(base_offset*offset_koeff+<span class="hljs-string">'if '</span>+ if_sub(exp_list,var_list, sign, prob_list) +<span class="hljs-string">':\n'</span> + action_str, offset_koeff, fin_else_flag, prob_list) 
    <span class="hljs-comment"># if + elif/else (2   )           </span>
    <span class="hljs-keyword">elif</span> sol == <span class="hljs-number">-1</span>:                                                                         <font></font>
        if_str= base_offset*offset_koeff+<span class="hljs-string">'if '</span>+ if_sub(exp_list,var_list, sign, prob_list) +<span class="hljs-string">':\n'</span> + action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list) <span class="hljs-comment"># if [..]:</span>
        <span class="hljs-comment">#  elif/else</span>
        prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol2=make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])             
        <span class="hljs-keyword">if</span> sol2!=<span class="hljs-number">0</span>:<font></font>
            ee_string=<span class="hljs-string">'elif'</span>
        <span class="hljs-keyword">else</span>:<font></font>
             ee_string=<span class="hljs-string">'else'</span>
        <span class="hljs-comment">#   elif/else</span><font></font>
        if_str, offset_koeff, fin_else_flag, prob_list = elif_else_block(ee_string, offset_koeff, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
        <span class="hljs-keyword">return</span>(if_str, offset_koeff, fin_else_flag, prob_list)
    <span class="hljs-comment"># if + if() (3   )</span>
    <span class="hljs-keyword">else</span>:                                                                                   <font></font>
            if_str= base_offset*offset_koeff+<span class="hljs-string">'if '</span>+ if_sub(exp_list,var_list, sign, prob_list) +<span class="hljs-string">':\n'</span> <span class="hljs-comment"># if [..]:</span>
            <span class="hljs-comment">#  if/if+ </span>
            prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>],sol = make_solution(prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>])        
            <span class="hljs-keyword">if</span> sol==<span class="hljs-number">0</span>:
                <span class="hljs-comment">#     +3</span>
                if_str+=action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list)      
            <span class="hljs-comment">#          </span><font></font>
            wall_offset = offset_koeff                                                      <font></font>
            if_rek, offset_koeff, fin_else_flag, prob_list = if_gen(exp_list, var_list, if_str, offset_koeff+<span class="hljs-number">3</span>, fin_else_flag, prob_list) <span class="hljs-comment">#  if+if</span>
            <span class="hljs-comment">#    </span><font></font>
            if_str+=if_rek   <font></font>
            <span class="hljs-comment">#   elif-else/                                                                </span>
            prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>],sol2=make_solution(prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>])         
            <span class="hljs-keyword">if</span> sol2!=<span class="hljs-number">0</span>:<font></font>
                prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol3=make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])
                <span class="hljs-keyword">if</span> sol3!=<span class="hljs-number">0</span>:<font></font>
                    ee_string=<span class="hljs-string">'elif'</span>
                <span class="hljs-keyword">else</span>:<font></font>
                    ee_string=<span class="hljs-string">'else'</span><font></font>
                if_str, offset_koeff, fin_else_flag, prob_list = elif_else_block(ee_string, wall_offset, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)  <font></font>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-comment">#     +3</span>
                if_str+=action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list)              
            <span class="hljs-keyword">return</span>(if_str, offset_koeff,fin_else_flag, prob_list)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus des listes avec «viande» pour la génération (exp_list, var_list), la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accepte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> également </font><b><font style="vertical-align: inherit;">if_str</font></b><font style="vertical-align: inherit;"> - c'est la ligne où le code généré est collecté à son tour. Elle est acceptée ici parce que la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen elle-même</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peut être appelée récursivement, et il serait conseillé de ne pas perdre le morceau de code généré précédemment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le paramètre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offset_koeff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le coefficient de décalage, qui est un facteur pour une ligne avec un espace ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base_offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et, par conséquent, il est responsable des déplacements horizontaux des blocs de code. </font><font style="vertical-align: inherit;">Nous avons parlé </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin_else_flag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ci-dessus, ici il est simplement passé à une fonction qui est responsable de générer if + elif / else (voir ci-dessous). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, il y a un autre paramètre -</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est une feuille avec 10 probabilités (5 paires de probabilités)</font></font><pre><code class="python hljs">prob_list = [<span class="hljs-number">0.5</span> <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)] </code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et est utilisé par la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme nous l'avons vu plus haut: telle ou telle paire de probabilités correspondant au type de fork lui est passée (par exemple, la fork structurelle principale utilise les 2 premières probabilités de la feuille: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list [0]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list [1]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Les résultats des changements de probabilité dans cette feuille, à titre d'exemple, peuvent être vus dans la figure suivante. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tw/_o/qc/tw_oqckdotydpm1m5djcmdc3rgw.jpeg" width="550" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les probabilités de cette liste changent de génération en génération si, au cours de la génération suivante, le morceau de code correspondant est exécuté. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la fonction elle-même, la liste imbriquée choice_list est initialisée au début - elle est nécessaire pour la génération aléatoire pratique d'expressions à partir de "meat", et la base offset </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base_offset = ''</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans un espace.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après cela vient le fork principal, qui, via la fonction make_solution, obtient la solution dans la variable sol. Sol prend l'une des trois valeurs (0, -1,1) et détermine, par conséquent, selon le schéma de construction de la structure. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première option implémente l'option la plus simple si + [..]. La réponse est formée comme une chaîne avec le décalage actuel (il n'est pas nécessairement égal à 0!), Une chaîne «if», une condition aléatoire qui est générée par la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_sub</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (qui sera discutée plus tard), le retour chariot et la génération d'un bloc d'action à l'aide de la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">action_str</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (voir ci-dessous) . En conséquence, nous obtenons quelque chose comme:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a+b)==(b)):<font></font>
   b=b<font></font>
   a=b-a<font></font>
   a=a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La deuxième option est responsable de la génération de ce type: if [..] + elif / else-block (option 2 dans les schémas). </font><font style="vertical-align: inherit;">Tout d'abord, une ligne if + [..] y est formée, puis un fork elif / else se produit, qui décide si le bloc elif-else sera généré, juste si-elif ou if-else (fonction e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lif_else_block</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - voir ci-dessous). </font><font style="vertical-align: inherit;">Les résultats peuvent varier. </font><font style="vertical-align: inherit;">Par exemple:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a+b)==(a)):<font></font>
   b=a+b<font></font>
<span class="hljs-keyword">elif</span> ((b//a)==(a)):
   <span class="hljs-literal">None</span>
<span class="hljs-keyword">elif</span> ((a+b)&lt;=(a)):<font></font>
   a=b//a<font></font>
<span class="hljs-keyword">else</span>:
   <span class="hljs-keyword">if</span> ((b)&lt;=(a)):<font></font>
      a=b-a<font></font>
      b=a</code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a)==(b-a)):<font></font>
   b=b-a<font></font>
   b=b<font></font>
   a=b<font></font>
   a=b-a<font></font>
<span class="hljs-keyword">elif</span> ((b)&gt;(b-a))<span class="hljs-keyword">and</span>((a)&lt;(b-a)):
   <span class="hljs-keyword">if</span> ((b//a)&lt;(a)):<font></font>
      b=b-a<font></font>
   <span class="hljs-keyword">elif</span> ((a+b)&lt;(b-a))<span class="hljs-keyword">and</span>((b)&lt;(a+b))<span class="hljs-keyword">or</span>((a+b)==(a+b)):<font></font>
      b=b<font></font>
      a=b-a<font></font>
   <span class="hljs-keyword">elif</span> ((a)&gt;(b-a)):
      <span class="hljs-literal">None</span></code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b)&lt;=(b-a))<span class="hljs-keyword">or</span>((a+b)&gt;=(b)):<font></font>
   a=a<font></font>
   b=b<font></font>
<span class="hljs-keyword">elif</span> ((b)&lt;=(b)):
   <span class="hljs-keyword">if</span> ((a)&gt;=(b)):<font></font>
      a=a+b<font></font>
      a=b<font></font>
<span class="hljs-keyword">elif</span> ((b)&gt;=(a)):<font></font>
   a=b-a<font></font>
   a=a<font></font>
   <span class="hljs-keyword">if</span> ((a)&gt;=(b))<span class="hljs-keyword">and</span>((b//a)==(a))<span class="hljs-keyword">and</span>((b//a)!=(b)):<font></font>
      b=b-a<font></font>
<span class="hljs-keyword">else</span>:<font></font>
   a=b//a<font></font>
   <span class="hljs-keyword">if</span> ((b//a)&lt;(b-a)):<font></font>
      a=b<font></font>
      a=b-a<font></font>
   <span class="hljs-keyword">else</span>:
      <span class="hljs-keyword">if</span> ((a)==(b)):<font></font>
         a=a<font></font>
         a=b//a<font></font>
         b=b<font></font>
         b=a+b<font></font>
         b=a<font></font>
      <span class="hljs-keyword">else</span>:
         <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La troisième option implémente la récursion depuis le tout début (option 3 dans les schémas), c'est-à-dire </font><font style="vertical-align: inherit;">donne naissance à une branche de la forme:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a)==(a)):
   <span class="hljs-keyword">if</span> ((a+b)&lt;(b)):</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ou </font></font><pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b-a)&lt;=(a)):<font></font>
   a=a<font></font>
   <span class="hljs-keyword">if</span> ((b-a)==(b)):<font></font>
      a=a<font></font>
      a=a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, la ligne if est formée (de manière similaire), puis une fourchette apparaît, qui décide d'insérer ou non le bloc d'action, après quoi le décalage est enregistré et la récursivité est appelée. L'offset doit être sauvegardé pour qu'après la récursivité et le retour du morceau de code, il soit possible d'ajouter un autre bloc elif-else au même offset que la ligne d'origine avec if. Ici, vous pouvez voir comment elif et autre dans la branche se trouvent au même décalage avec leur "natif" if.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b-a)==(b)):<font></font>
<font></font>
   <span class="hljs-keyword">if</span> ((a)&gt;(a+b)):
      <span class="hljs-keyword">if</span> ((b)==(b-a)):<font></font>
         b=b<font></font>
         a=a<font></font>
      <span class="hljs-keyword">elif</span> ((b)&gt;(b)):
         <span class="hljs-literal">None</span>
      <span class="hljs-keyword">else</span>:
         <span class="hljs-literal">None</span><font></font>
         b=a<font></font>
         b=b</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vient ensuite une fourchette dans le bloc elif-else-block / action, qui décide s'il faut ajouter un bloc d'action ou un bloc elif-else après récursivité. Si vous décidez d'ajouter un bloc elif-else, alors là, comme dans le cas décrit ci-dessus, dans le schéma 2, elif ou else est sélectionné. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, il est nécessaire de faire attention au fait que la récursivité est appelée avec un décalage de + 3 pour décaler le code généré vers la droite d'un pas, et le bloc elif-else est appelé avec un décalage de wall_offset afin que ce bloc n'aille pas à droite après la récursivité, mais reste avec le "natif" le décalage de l'original si. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les résultats peuvent être très différents: du simple au complexe, mais l'apparition de la récursivité produit immédiatement les branches les plus ornées.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b-a)&gt;(a+b))<span class="hljs-keyword">and</span>((b)&lt;(a+b)):
   <span class="hljs-keyword">if</span> ((b-a)&lt;=(a+b)):<font></font>
      b=b//a<font></font>
   <span class="hljs-keyword">elif</span> ((b)!=(a)):<font></font>
      a=b-a<font></font>
<span class="hljs-keyword">else</span>:
   <span class="hljs-keyword">if</span> ((a+b)!=(b-a)):<font></font>
      a=a</code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b)&lt;(b-a)):
   <span class="hljs-keyword">if</span> ((a+b)==(b-a))<span class="hljs-keyword">and</span>((b-a)&lt;(a+b))<span class="hljs-keyword">and</span>((b-a)==(a))<span class="hljs-keyword">and</span>((a)&gt;(b//a))<span class="hljs-keyword">or</span>((a+b)&gt;(b//a)):
      <span class="hljs-keyword">if</span> ((b)&gt;=(b-a)):<font></font>
         a=b<font></font>
         b=b<font></font>
         <span class="hljs-keyword">if</span> ((b)&gt;(b)):<font></font>
            a=a+b<font></font>
            b=a+b<font></font>
            a=a<font></font>
            b=a+b<font></font>
            b=b//a<font></font>
            b=a<font></font>
      <span class="hljs-keyword">else</span>:<font></font>
         b=a+b<font></font>
         a=b<font></font>
         a=b<font></font>
   <span class="hljs-keyword">elif</span> ((a)&lt;(b-a)):<font></font>
      a=b//a<font></font>
      a=b-a</code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a)&gt;=(b-a))<span class="hljs-keyword">or</span>((a)&gt;=(a))<span class="hljs-keyword">or</span>((b)&lt;=(b)):<font></font>
   a=a<font></font>
   a=a<font></font>
<span class="hljs-keyword">elif</span> ((a)==(a))<span class="hljs-keyword">and</span>((b)&gt;(b-a)):<font></font>
   a=b//a<font></font>
   <span class="hljs-keyword">if</span> ((a)&lt;(b)):
      <span class="hljs-keyword">if</span> ((a+b)==(b-a)):<font></font>
         a=a<font></font>
         <span class="hljs-keyword">if</span> ((a)!=(b//a)):
            <span class="hljs-keyword">if</span> ((b//a)!=(a))<span class="hljs-keyword">and</span>((b-a)&gt;=(b)):<font></font>
               a=b<font></font>
            <span class="hljs-keyword">else</span>:
               <span class="hljs-literal">None</span><font></font>
               a=b//a<font></font>
      <span class="hljs-keyword">else</span>:<font></font>
         b=b<font></font>
         b=a+b<font></font>
         <span class="hljs-keyword">if</span> ((b-a)&lt;=(b//a)):<font></font>
            a=b<font></font>
            a=b<font></font>
            a=a+b<font></font>
<span class="hljs-keyword">else</span>:<font></font>
   a=a+b<font></font>
   <span class="hljs-keyword">if</span> ((b-a)&gt;=(a)):<font></font>
      a=b<font></font>
      <span class="hljs-keyword">if</span> ((b-a)==(a))<span class="hljs-keyword">or</span>((b)!=(b//a)):<font></font>
         a=b-a<font></font>
         a=a<font></font>
         a=a<font></font>
         a=b//a<font></font>
         a=a+b<font></font>
         b=a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinons maintenant la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else_block</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est responsable de la formation du bloc elif-else et est appelée à partir de la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> principale </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">elif_else_block</span>(<span class="hljs-params">ee_string, offset_koeff, exp_list, var_list, sign, if_str, choice_list,  fin_else_flag, prob_list</span>):</span>
    <span class="hljs-keyword">if</span> ee_string==<span class="hljs-string">'elif'</span>:<font></font>
        sol3 = <span class="hljs-number">9</span>
        <span class="hljs-comment">#  </span><font></font>
        wall_offset = offset_koeff<font></font>
        <span class="hljs-comment">#  elif  </span>
        <span class="hljs-keyword">while</span> sol3!=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> fin_else_flag!=<span class="hljs-number">1</span>:<font></font>
            temp_str, offset_koeff, fin_else_flag, prob_list=elif_else(<span class="hljs-string">'elif'</span>, wall_offset, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
            if_str+=temp_str<font></font>
            prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol3 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-comment">#  -   else   elif?</span>
        prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol = make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])
        <span class="hljs-keyword">if</span> sol!=<span class="hljs-number">0</span>:
            <span class="hljs-comment">#  else,   </span>
            fin_else_flag=<span class="hljs-number">1</span>
            temp_str,offset_koeff, fin_else_flag, prob_list=elif_else(<span class="hljs-string">'else'</span>, wall_offset, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
            if_str+=temp_str<font></font>
        <span class="hljs-keyword">return</span>(if_str,offset_koeff, fin_else_flag, prob_list)
    <span class="hljs-comment">#  else</span>
    <span class="hljs-keyword">else</span>: <font></font>
          temp_str,offset_koeff, fin_else_flag, prob_list=elif_else(<span class="hljs-string">'else'</span>, offset_koeff, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
          if_str+=temp_str<font></font>
          <span class="hljs-keyword">return</span>(if_str, offset_koeff, fin_else_flag, prob_list)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette fonction décide d'ajouter un bloc elif ou elif / else au code. Elle ne décide pas s'il faut simplement mettre autre chose, mais dépend de la valeur d'entrée e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e_string</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qu'elle reçoit de la fonction principale </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tout d'abord, le bloc elif est généré dans la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boucle while</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , où 2 conditions sont vérifiées: probabiliste - le nombre d'elif dans le bloc et le drapeau </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin_else_flag en dépendent</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et s'il s'allume soudainement, cela signifie que d'autre était connecté avant cela, et donc vous devez quitter la boucle . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La décision d'attacher else et else au bloc elif est décidée par un fork utilisant la même fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et si else est attaché, le drapeau </font><b><font style="vertical-align: inherit;">fin_else_flag</font></b><font style="vertical-align: inherit;"> est </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">activé immédiatement</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce qui arrête la génération de blocs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La jonction directe d'elif et d'autre est effectuée par la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (voir ci-dessous). Ici, il est nécessaire de faire attention à ce que lors de la génération du bloc elif (et également lors de l'attachement à un autre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">élément</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), l'offset </font><b><font style="vertical-align: inherit;">wall_offset</font></b><font style="vertical-align: inherit;"> soit utilisé pour construire en douceur le bloc dans son ensemble. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérons maintenant la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="python hljs">&lt;b&gt;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">elif_else</span>(<span class="hljs-params">ee_string, offset_koeff, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list</span>):</span>
    ee_str = <span class="hljs-string">''</span>
    <span class="hljs-comment">#   else:  elif [..]:</span>
    <span class="hljs-keyword">if</span> ee_string==<span class="hljs-string">'else'</span>:<font></font>
        ee_str += <span class="hljs-string">' '</span>*offset_koeff+ee_string + <span class="hljs-string">':\n'</span>
    <span class="hljs-keyword">elif</span> ee_string==<span class="hljs-string">'elif'</span>:<font></font>
        ee_str += <span class="hljs-string">' '</span>*offset_koeff+ee_string+<span class="hljs-string">' '</span>+if_sub(exp_list, var_list, sign, prob_list) + <span class="hljs-string">':\n'</span>
    <span class="hljs-comment">#   -None /  +</span>
    prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol = make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])
    <span class="hljs-keyword">if</span> sol!=<span class="hljs-number">0</span>:<font></font>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol2 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-keyword">if</span> sol2!=<span class="hljs-number">0</span>:
            <span class="hljs-comment">#  </span>
            ee_str+=action_str_gen(choice_list,offset_koeff+<span class="hljs-number">3</span>, prob_list)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># None</span>
            ee_str+=<span class="hljs-string">' '</span>*(offset_koeff+<span class="hljs-number">3</span>)+<span class="hljs-string">'None\n'</span>
        <span class="hljs-keyword">return</span>(ee_str, offset_koeff, fin_else_flag, prob_list)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-comment">#   </span>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol2 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-keyword">if</span> sol2==<span class="hljs-number">0</span>:
            <span class="hljs-comment">#  </span>
            ee_str+=action_str_gen(choice_list,offset_koeff+<span class="hljs-number">3</span>, prob_list)
        <span class="hljs-comment">#  if_gen</span>
        if_str, offset_koeff,  fin_else_flag, prob_list = if_gen(exp_list, var_list, if_str, offset_koeff+<span class="hljs-number">3</span>, fin_else_flag, prob_list)                 <font></font>
        ee_str+=if_str<font></font>
        <span class="hljs-keyword">return</span>(ee_str, offset_koeff, fin_else_flag, prob_list)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction est responsable de la formation de la ligne elif ou bien elle-même, ainsi que de la génération ultérieure de blocs d'action ou de récursivité après ces lignes. Il prend également une variable </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ee_string</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui contient soit elif, soit else, et forme la chaîne correspondante. Ensuite, il y a un fork, où il est déterminé ce qui se passera ensuite: (bloc d'action ou Aucun), ou (bloc d'action ou bloc d'action + récursivité). À l'intérieur de cette fourchette, il y a une division, respectivement, en deux sous-fourches, et dans chaque cas, la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><b><font style="vertical-align: inherit;">appelée</font></b><font style="vertical-align: inherit;"> avec les paramètres appropriés pour prendre une décision. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient de noter que lorsqu'il se produit dans le code</font></font><code>if sol!=0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cela signifie que nous donnons intentionnellement un avantage à une partie du code par rapport à une autre, car si sol! = 0, alors il est égal à -1 ou 1, et donc un autre morceau de code sera exécuté moins souvent (uniquement lorsque sol == 0). Ceci est utilisé, en particulier, dans la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else_block</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , où il est plus rentable pour nous de laisser plus d' </font><b><font style="vertical-align: inherit;">elifs se</font></b><font style="vertical-align: inherit;"> former dans le bloc, plutôt que de donner une probabilité égale à elif et autre. Ou, par exemple, dans la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous donnons un avantage à l'option quand un bloc d'action ou None est formé plutôt que ce que la récursion vise - sinon les branches peuvent atteindre des tailles complètement indécentes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il suffit de considérer les fonctions responsables de la génération aléatoire d'expressions dans des conditions et des blocs d'actions. Comme je l'ai dit ci-dessus, à ce stade, ils ne jouent pas un rôle décisif et sont présentés ici pour montrer généralement à quoi ressemblera le code généré final. Mais puisqu'ils sont utilisés dans le générateur, nous les examinerons brièvement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction responsable de la génération du </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloc d'</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> action </font><b><font style="vertical-align: inherit;">action_str</font></b><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action_str_gen</span>(<span class="hljs-params">choice_list, offset_koeff, prob_list</span>):</span>
    sol = <span class="hljs-number">9</span>
    curr_offset = <span class="hljs-string">' '</span>*offset_koeff<font></font>
    act_str = <span class="hljs-string">''</span>
    <span class="hljs-keyword">while</span> sol!=<span class="hljs-number">0</span>:<font></font>
        act_str+= curr_offset+rand(rand(choice_list[<span class="hljs-number">1</span>]))+<span class="hljs-string">'='</span>+rand(rand(choice_list))+<span class="hljs-string">'\n'</span>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
    <span class="hljs-keyword">return</span>(act_str)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout est assez simple ici: à partir de la liste imbriquée choise_list, qui, rappelons-le, se compose de v </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ar_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (liste de variables) et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exp_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (liste d'expressions), cette fonction se compose d'une ou plusieurs lignes de cette forme: a = a + b ou b = b . </font><font style="vertical-align: inherit;">Ceux. </font><font style="vertical-align: inherit;">soit une expression est affectée à la variable, soit une autre variable (y compris elle-même). </font><font style="vertical-align: inherit;">La fonction rand sélectionne au hasard un élément de la liste et n'est nécessaire ici que pour ne pas produire de chaînes monstrueuses.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rand</span>(<span class="hljs-params">t_list</span>):</span>
    <span class="hljs-keyword">return</span>(t_list[random.randint(<span class="hljs-number">0</span>,len(t_list)<span class="hljs-number">-1</span>)])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction de génération d'expression </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_sub</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour les conditions semble plus grande.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">if_sub</span>(<span class="hljs-params">exp_list, var_list, sign, prob_list</span>):</span>
    sub_str = <span class="hljs-string">''</span>
    sol = <span class="hljs-number">9</span><font></font>
    choice_list = [exp_list, var_list]<font></font>
    flag = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> sol!=<span class="hljs-number">0</span>:<font></font>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])<font></font>
        sub_str+=<span class="hljs-string">'(('</span>+rand(rand(choice_list))+<span class="hljs-string">')'</span>+rand(sign2)+<span class="hljs-string">'('</span>+rand(rand(choice_list))+<span class="hljs-string">'))'</span>
        <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> sol==<span class="hljs-number">1</span>:<font></font>
            sub_str+=<span class="hljs-string">')'</span>
            flag=<span class="hljs-number">0</span><font></font>
        or_and_exp = or_and(prob_list)<font></font>
        <span class="hljs-keyword">if</span> len(or_and_exp):<font></font>
            sub_str+=or_and_exp<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol2 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-keyword">if</span> sol2 == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'D'</span> <span class="hljs-keyword">or</span> sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'R'</span>) <span class="hljs-keyword">and</span> flag == <span class="hljs-number">0</span>:<font></font>
            sub_str+=<span class="hljs-string">'('</span>
            flag = <span class="hljs-number">1</span><font></font>
    <font></font>
    <span class="hljs-keyword">if</span> sub_str[<span class="hljs-number">-1</span>] == <span class="hljs-string">'('</span>:
        <span class="hljs-keyword">if</span> sub_str[<span class="hljs-number">-2</span>]==<span class="hljs-string">'d'</span>:<font></font>
           sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-4</span>]
        <span class="hljs-keyword">elif</span> sub_str[<span class="hljs-number">-2</span>]==<span class="hljs-string">'r'</span>:<font></font>
             sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-3</span>]
        <span class="hljs-keyword">else</span>:<font></font>
            sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-1</span>]
    <span class="hljs-keyword">elif</span> sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'d'</span>:<font></font>
         sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-3</span>]
    <span class="hljs-keyword">elif</span> sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'r'</span>:<font></font>
         sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-2</span>]
    <span class="hljs-keyword">else</span>:
         <span class="hljs-literal">None</span>
    <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span>:<font></font>
        sub_str+=<span class="hljs-string">')'</span>
        <span class="hljs-keyword">return</span>(sub_str)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span>(sub_str)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il génère des expressions par type: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">((a)&gt; = (ba)) ou ((a)&gt; = (a)) ou ((b) &lt;= (b))</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dans le même temps, les côtés gauche et droit peuvent avoir différentes options et se présenter comme des variables distinctes, ainsi que des expressions ou leurs groupes. </font><font style="vertical-align: inherit;">Les opérateurs logiques </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont également utilisés ici </font><font style="vertical-align: inherit;">, qui sont sélectionnés par commodité à l'aide de la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or_and_exp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">or_and</span>(<span class="hljs-params">prob_list</span>):</span>
    prob_list[<span class="hljs-number">8</span>],prob_list[<span class="hljs-number">9</span>],sol = make_solution(prob_list[<span class="hljs-number">8</span>],prob_list[<span class="hljs-number">9</span>])
    <span class="hljs-keyword">if</span> sol==<span class="hljs-number">-1</span>:
        <span class="hljs-keyword">return</span>(<span class="hljs-string">'and'</span>)
    <span class="hljs-keyword">elif</span> sol==<span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span>(<span class="hljs-string">'or'</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span>(<span class="hljs-string">''</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le reste de la fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_sub</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coupe les queues supplémentaires des expressions et ajoute, si nécessaire, des crochets de fermeture - pour considérer ces danses avec des tambourins ici, je pense, est inopportun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien voilà tout. </font><font style="vertical-align: inherit;">Vous pouvez démarrer le générateur, par exemple, comme ceci:</font></font><br>
<br>
<pre><code class="python hljs">var_list = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>]<font></font>
exp_list = [<span class="hljs-string">'a+b'</span>,<span class="hljs-string">'b-a'</span>, <span class="hljs-string">'b//a'</span>]<font></font>
sign = [<span class="hljs-string">'+'</span>,<span class="hljs-string">'-'</span>,<span class="hljs-string">'/'</span>,<span class="hljs-string">'*'</span>,<span class="hljs-string">'//'</span>]<font></font>
sign2 = [<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'=='</span>,<span class="hljs-string">'&gt;='</span>,<span class="hljs-string">'&lt;='</span>,<span class="hljs-string">'!='</span>]<font></font>
a = <span class="hljs-number">3</span>
b = <span class="hljs-number">2</span>       
prob_list = [<span class="hljs-number">0.5</span> <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)]      
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
     if_str = <span class="hljs-string">''</span>
     if_str, offset_koeff, fin_else_flag, prob_list = if_gen(exp_list, var_list, if_str, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>, prob_list)
     <span class="hljs-keyword">try</span>:<font></font>
         exec(compile(if_str,<span class="hljs-string">'gen'</span>,<span class="hljs-string">'exec'</span>))<font></font>
         print(if_str)<font></font>
         input()<font></font>
         <font></font>
     <span class="hljs-keyword">except</span> ZeroDivisionError:
         <span class="hljs-literal">None</span>
     <span class="hljs-keyword">except</span>:<font></font>
         print(<span class="hljs-string">'error'</span>)<font></font>
         print(if_str)<font></font>
         input()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'abord, l'entrée, y compris une </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec probabilités </font><font style="vertical-align: inherit;">, puis dans une boucle infinie, appelant la fonction principale </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et démarrant la chaîne générée générée pour exécution. Il vaut la peine de traiter séparément ZeroDivisionError, car la division par zéro avec une telle construction aléatoire des expressions est très courante. Après le lancement, appuyez simplement sur Entrée pour voir une autre génération. Le plus souvent, ils seront assez simples, mais souvent ramifiés et même très ramifiés. Eh bien, l' </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">import aléatoire</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au début serait également bien à insérer;) Pour ceux qui ne veulent pas tout voir à la main, vous pouvez télécharger le fichier depuis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (fichier if_gen.py).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conclusion, je tiens à dire que le code que j'ai présenté a été testé sur des centaines de milliers de générations sans erreur, alors qu'il démontrait toute la palette des schémas if-elif-else que je voulais enfin voir. Une fois, par erreur, j'ai donné dans une partie du code une probabilité de récursivité trop élevée et j'ai obtenu 52 000 (!) Lignes de génération et en même temps ça fonctionnait (bien que la maquette ait été suspendue pendant 30 secondes). Cela indique également la fiabilité de l'algorithme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probablement, il était possible d'écrire de manière plus concise quelque part, d'optimiser quelque part, d'organiser la fonction principale d'une autre manière, mais l'essentiel est que ce code fonctionne et génère environ 250 générations par seconde, ce qui, à mon avis, est tout à fait acceptable.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'ai jamais considéré ce code comme autosuffisant - ce n'est qu'un module du futur organisme numérique et a été écrit à des fins de recherche, il n'a donc pratiquement aucune application pratique. </font><font style="vertical-align: inherit;">En même temps, je ne suis pas responsable des conséquences pour quiconque utilise le code ci-dessus, et j'exhorte tout le monde à couper du pain avec un couteau pour couper le pain, et pas autre chose. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le prochain article, nous considérerons le deuxième module, qui sera responsable de la formation aléatoire de l'expérience. </font><font style="vertical-align: inherit;">Ce sujet promet d'être beaucoup plus intéressant que le générateur if, et je posterai certainement les résultats dès que je les aurai.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr504270/index.html">Svelte est-il un bon choix pour la mise en œuvre de widgets?</a></li>
<li><a href="../fr504276/index.html">Top 10 des livres pour développeurs</a></li>
<li><a href="../fr504282/index.html">Création d'architecture d'entreprise dans NSPK</a></li>
<li><a href="../fr504284/index.html">Le livre «Pure Agile. Les bases de la flexibilité</a></li>
<li><a href="../fr504290/index.html">Test de charge en tant que service CI pour les développeurs</a></li>
<li><a href="../fr504306/index.html">Comment le matériel russe est-il conçu pour le stockage Aerodisk Vostok sur Elbrus</a></li>
<li><a href="../fr504310/index.html">Dichotomie des données: repenser la relation avec les données et les services</a></li>
<li><a href="../fr504312/index.html">Registre unifié des programmes russes et de la GPL. Mes cinq cents</a></li>
<li><a href="../fr504314/index.html">Implémentation des commandes Docker Pull et Docker Push sans client Docker via des requêtes HTTP</a></li>
<li><a href="../fr504320/index.html">Code de ligne unique ou validation Nethermind à l'aide de PVS-Studio C # pour Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>