<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟 👩🏿‍🚒 💪🏽 Backend-gesteuerte Benutzeroberfläche mit Widgets ⛹🏽 🖋️ 🙇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Berücksichtigen Sie die Funktionen dieses Ansatzes und unsere Implementierung mithilfe von Widgets, deren Konzept, Vorteile und Unterschiede zu andere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Backend-gesteuerte Benutzeroberfläche mit Widgets</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/498664/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berücksichtigen Sie die Funktionen dieses Ansatzes und unsere Implementierung mithilfe von Widgets, deren Konzept, Vorteile und Unterschiede zu anderen Ansichten in Android.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0z/p9/hd/0zp9hdtjfkdd28_s70pm46rqvw0.png"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Backend-gesteuerte Benutzeroberfläche - Ein Ansatz, mit dem Sie Benutzeroberflächenkomponenten basierend auf der Serverantwort erstellen können. Die API-Beschreibung sollte die Komponententypen und ihre Eigenschaften enthalten, und die Anwendung sollte abhängig von den Typen und Eigenschaften die erforderlichen Komponenten anzeigen. Im Allgemeinen kann die Logik der Komponenten festgelegt werden, und für eine mobile Anwendung sind sie eine Black Box, da jede Komponente eine vom Rest der Anwendung unabhängige Logik haben kann und vom Server abhängig von der erforderlichen Geschäftslogik beliebig konfiguriert werden kann. Aus diesem Grund wird dieser Ansatz häufig in Bankanwendungen verwendet: Zum Beispiel, wenn Sie ein Übersetzungsformular mit einer großen Anzahl dynamisch definierter Felder anzeigen müssen. Die Anwendung kennt die Zusammensetzung des Formulars und die Reihenfolge der darin enthaltenen Felder nicht im Voraus.Dieser Ansatz ist die einzige Möglichkeit, Code ohne Krücken zu schreiben. Darüber hinaus bietet es zusätzliche Flexibilität: Auf der Serverseite können Sie das Formular jederzeit ändern, und die mobile Anwendung ist dafür bereit.</font></font><br>
<cut></cut><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anwendungsfall</font></font></h3><br>
<img src="https://habrastorage.org/webt/kd/ao/vw/kdaovw36bkxi3ec-y5ajmidakke.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgenden Arten von Komponenten sind oben dargestellt:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liste der zur Übertragung verfügbaren Konten;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Name der Art der Übersetzung;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feld zur Eingabe einer Telefonnummer (es hat eine Maske zur Eingabe und ein Symbol zur Auswahl von Kontakten vom Gerät);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feld zur Eingabe des Überweisungsbetrags.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auch auf dem Formular ist eine beliebige Anzahl anderer Komponenten möglich, die in die Geschäftslogik eingebettet und in der Entwurfsphase festgelegt sind. Informationen zu jeder Komponente, die in der Antwort vom Server eingehen, müssen den Anforderungen entsprechen, und von jeder Komponente muss erwartet werden, dass sie von der mobilen Anwendung korrekt verarbeitet wird. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/j9/3g/hu/j93ghualguxt2lxhch93sraomys.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unterschiedliche Eingabefelder haben unterschiedliche Masken und Validierungsregeln. Die Schaltfläche kann beim Booten eine schimmernde Animation aufweisen. Ein Widget zum Auswählen eines Abbuchungskontos kann beim Scrollen Animationen enthalten und so weiter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle UI-Komponenten sind unabhängig voneinander, und die Logik kann in separate Ansichten mit unterschiedlichen Verantwortungsbereichen aufgenommen werden - nennen wir sie Widgets. Jedes Widget erhält seine Konfiguration in der Serverantwort und kapselt die Logik der Anzeige und Datenverarbeitung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Implementierung des Bildschirms ist RecyclerView am besten geeignet, dessen Elemente Widgets enthalten. </font><font style="vertical-align: inherit;">Der ViewHolder jedes eindeutigen Listenelements initialisiert das Widget und gibt ihm die Daten, die angezeigt werden sollen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget-Konzept</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns Widgets genauer betrachten. </font><font style="vertical-align: inherit;">Ein Widget ist im Kern eine benutzerdefinierte Ansicht "mit maximaler Geschwindigkeit". </font><font style="vertical-align: inherit;">Eine gewöhnliche benutzerdefinierte Ansicht kann auch Daten und die Logik ihrer Anzeige enthalten, aber das Widget impliziert etwas mehr - es hat einen Präsentator, ein Bildschirmmodell und einen eigenen DI-Bereich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir uns mit den Details der Implementierung von Widgets befassen, diskutieren wir deren Vorteile:</font></font><br>
<br>
<ul>
<li>     ,   ,   «» ,       —     UI-  ,             .</li>
<li>        ,         ,         .</li>
<li>,     —        :  ,      ,    .</li>
</ul><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um skalierbare Widgets zu implementieren, verwenden wir die Basisklassen für die am häufigsten verwendeten ViewGroups, die über eigene DI-Bereiche verfügen. Alle Basisklassen werden wiederum von der gemeinsamen Schnittstelle geerbt, die alles enthält, was zum Initialisieren von Widgets erforderlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der einfachste Fall für die Verwendung von Widgets sind statische Ansichten, die direkt im Layout angegeben werden. Nach der Implementierung der Widget-Klassen können Sie sie sicher zum XML-Layout hinzufügen, ohne die ID im Layout anzugeben (basierend auf der ID wird der DI-Bereich eines Widgets gebildet). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel werden dynamische Widgets ausführlicher betrachtet, da der oben beschriebene Fall des Übersetzungsformulars mit einem beliebigen Satz von Feldern mit ihrer Hilfe bequem gelöst werden kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes statische und dynamische Widget in unserer Implementierung unterscheidet sich in Bezug auf MVP kaum von der normalen Sichtweise. </font><font style="vertical-align: inherit;">Normalerweise werden 4 Klassen benötigt, um ein Widget zu implementieren:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ansichtsklasse, in der das Layoutlayout und die Inhaltsanzeige erfolgen;</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldWidget</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
        context: Context,<font></font>
        attrs: AttributeSet? = <span class="hljs-literal">null</span><font></font>
) : CoreFrameLayoutView(context, attrs) {<font></font>
<span class="hljs-meta">@Inject</span>
<span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> presenter: TextInputFieldPresenter<font></font>
…<font></font>
<span class="hljs-keyword">init</span> {<font></font>
     inflate(context, R.layout.view_field_text_input, <span class="hljs-keyword">this</span>)<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Klasse für den Präsentator, in der die Grundlogik des Widgets beschrieben wird, zum Beispiel:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Laden und Übertragen von Daten für ein Rendering;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abonnieren verschiedener Ereignisse und Ausgeben von Ereignissen bei Änderungen der Widget-Eingabe;</font></font></li>
</ol><br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@PerScreen</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldPresenter</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
        basePresenterDependency: BasePresenterDependency,<font></font>
        rxBus: RxBus<font></font>
) : BaseInputFieldPresenter&lt;TextInputFieldWidget&gt;(<font></font>
       basePresenterDependency, rxBus<font></font>
) {<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sm = TextInputFieldScreenModel()<font></font>
...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserer Implementierung ist die RxBus-Klasse ein PublishSubject-basierter Bus zum Senden und Abonnieren von Ereignissen.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Klasse für das Bildschirmmodell, mit deren Hilfe der Präsentator Daten empfängt und zum Rendern in einer Ansicht überträgt (in Bezug auf das Präsentationsmodellmuster);</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldScreenModel</span> : <span class="hljs-type">ScreenModel</span></span>() {
	<span class="hljs-keyword">val</span> value = String = “”
	<span class="hljs-keyword">val</span> hint = String = “”
	<span class="hljs-keyword">val</span> errorText = String = “”<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Konfiguratorklasse zum Implementieren von DI, mit deren Hilfe Abhängigkeiten für das Widget bereitgestellt werden, die den gewünschten Bereich haben, und der Präsentator in seine Ansicht eingefügt wird.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldWidgetConfigurator</span> : <span class="hljs-type">WidgetScreenConfigurator</span></span>() {
	<span class="hljs-comment">// logic for components injection</span><font></font>
}<font></font>
</code></pre><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der einzige Unterschied zwischen Widgets und unserer Implementierung vollwertiger Bildschirme (Aktivität, Fragment) besteht darin, dass das Widget nicht über viele Lebenszyklusmethoden verfügt (onStart, onResume, onPause). </font><font style="vertical-align: inherit;">Es gibt nur die onCreate-Methode, die anzeigt, dass das Widget derzeit seinen Bereich erstellt hat, und der Scoop wird in der onDetachedFromWindow-Methode zerstört. </font><font style="vertical-align: inherit;">Aus Gründen der Benutzerfreundlichkeit und Konsistenz erhält der Präsentator des Widgets jedoch dieselben Lebenszyklusmethoden wie die übrigen Bildschirme. </font><font style="vertical-align: inherit;">Diese Ereignisse werden ihm automatisch vom Elternteil übermittelt. </font><font style="vertical-align: inherit;">Es ist zu beachten, dass die Basisklasse des Widget-Präsentators dieselbe Basisklasse von Präsentatoren anderer Bildschirme ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamische Widgets verwenden</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fahren wir mit der Implementierung des am Anfang des Artikels beschriebenen Falls fort.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Bildschirmdarstellung werden die Daten für das Übersetzungsformular geladen, die Daten werden zum Rendern an die Ansicht übertragen. </font><font style="vertical-align: inherit;">In diesem Stadium spielt es für uns keine Rolle, ob die Ansicht des Aktivitätsbildschirms ein Fragment oder ein Widget ist. </font><font style="vertical-align: inherit;">Wir sind nur daran interessiert, RecyclerView zu haben und damit ein dynamisches Formular zu rendern.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TransferFormPresenter</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sm = TransferFormScreenModel()<font></font>
…<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadData</span><span class="hljs-params">()</span></span> {<font></font>
	loadDataDisposable.dispose()<font></font>
  	loadDataDisposable = subscribe(<font></font>
              observerDataForTransfer().io(), <font></font>
              { <span class="hljs-keyword">data</span> -&gt; <font></font>
                      sm.<span class="hljs-keyword">data</span> = <span class="hljs-keyword">data</span><font></font>
                      view.render(sm)<font></font>
              },<font></font>
              { error -&gt; <span class="hljs-comment">/* error handling */</span> }<font></font>
  	)<font></font>
 }<font></font>
</code></pre><br>
 </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formulardaten werden an den Listenadapter übertragen und mithilfe von Widgets gerendert, die sich im ViewHolder für jedes eindeutige Formularelement befinden. </font><font style="vertical-align: inherit;">Der gewünschte ViewHolder zum Rendern der Komponente wird basierend auf vordefinierten Typen von Formularkomponenten bestimmt.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TransferFormView</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">render</span><span class="hljs-params">(sm: <span class="hljs-type">TransferFormScreenModel</span>)</span></span> {
    <span class="hljs-comment">//      </span>
    <span class="hljs-comment">//   EasyAdapter [3]</span>
    <span class="hljs-keyword">val</span> list = ItemList.create()
    <span class="hljs-comment">//       Controller,</span>
    <span class="hljs-comment">//       </span><font></font>
<font></font>
    sm.<span class="hljs-keyword">data</span><font></font>
        .filter { transferField -&gt; transferField.visible }<font></font>
        .forEach { transferField -&gt;<font></font>
            <span class="hljs-keyword">when</span> (transferField.type) {<font></font>
                TransferFieldType.PHONE_INPUT -&gt; {<font></font>
                    list.add(<font></font>
                        PhoneInputFieldData(transferField),<font></font>
                        phoneInputController<font></font>
                    )<font></font>
                }<font></font>
                TransferFieldType.MONEY -&gt; {<font></font>
                    list.add(<font></font>
                        MoneyInputFieldData(transferField),<font></font>
                        moneyInputController<font></font>
                    )<font></font>
                }<font></font>
                TransferFieldType.BUTTON -&gt; {<font></font>
                    list.add(<font></font>
                        ButtonInputFieldData(transferField),<font></font>
                        buttonController<font></font>
                    )<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> -&gt; {<font></font>
                    list.add(<font></font>
                        TextInputFieldData(transferField),<font></font>
                        textInputController<font></font>
                    )<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-comment">//     RecyclerView</span><font></font>
        adapter.setItems(list)<font></font>
}  <font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Widget wird in der Bindemethode von ViewHolder initialisiert. </font><font style="vertical-align: inherit;">Neben der Übertragung von Daten für das Rendern ist es auch wichtig, eine eindeutige ID für das Widget festzulegen, auf deren Grundlage der DI-Bereich gebildet wird. </font><font style="vertical-align: inherit;">In unserem Fall hatte jedes Element des Formulars eine eindeutige ID, die für die Ernennung der Eingabe verantwortlich war und zusätzlich zum Elementtyp als Antwort kam (Typen können im Formular wiederholt werden).</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// ViewHolder</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">data</span>: <span class="hljs-type">TransferFieldUi</span>)</span></span> {
	<span class="hljs-comment">// get initialize params from given data</span><font></font>
	itemView.findViewById(R.id.field_tif).initialize(...)<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Initialisierungsmethode initialisiert die Widget-Ansichtsdaten, die dann mithilfe der onCreate-Lebenszyklusmethode an den Präsentator übertragen werden, wobei die Feldwerte auf das Widget-Modell und dessen Rendering festgelegt werden.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initialize</span><span class="hljs-params">(
       id: <span class="hljs-type">String</span> = this.id,
       value: <span class="hljs-type">String</span> = this.value,
       hint: <span class="hljs-type">String</span> = this.hint,
       errorText: <span class="hljs-type">String</span> = this.errorText
)</span></span> {
       <span class="hljs-keyword">this</span>.id = id
       <span class="hljs-keyword">this</span>.value = value
       <span class="hljs-keyword">this</span>.hint = hint
       <span class="hljs-keyword">this</span>.errorText = errorText<font></font>
}<font></font>
    <font></font>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
       presenter.onCreate(value, hint, errorText)<font></font>
       <span class="hljs-comment">// other logic...</span><font></font>
}<font></font>
<span class="hljs-comment">// TextInputFieldPresenter</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(value: <span class="hljs-type">String</span>, hint: <span class="hljs-type">String</span>, errorText: <span class="hljs-type">String</span>)</span></span> {<font></font>
       sm.value = value<font></font>
       sm.hint = hint<font></font>
       sm.errorText = errorText<font></font>
       view.render(sm)<font></font>
}<font></font>
</code></pre><br>
</li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterwasserfelsen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie aus der Beschreibung hervorgeht, ist die Implementierung sehr einfach und intuitiv. </font><font style="vertical-align: inherit;">Es gibt jedoch Nuancen, die berücksichtigt werden müssen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrachten Sie den Lebenszyklus von Widgets</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die Basisklassen von Widgets Erben der häufig verwendeten ViewGroups sind, kennen wir auch den Lebenszyklus von Widgets. </font><font style="vertical-align: inherit;">In der Regel werden Widgets im ViewHolder durch Aufrufen einer speziellen Methode initialisiert, bei der die Daten übertragen werden, wie im vorherigen Absatz gezeigt. </font><font style="vertical-align: inherit;">Eine andere Initialisierung findet in onCreate statt (z. B. Festlegen von Klick-Listenern). Diese Methode wird nach onAttachedToWindow mit einem speziellen Delegaten aufgerufen, der die Schlüsselentitäten der Widget-Logik steuert.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// CoreFrameLayoutView (      ViewGroup)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoreFrameLayoutView</span></span><font></font>
          extends FrameLayout implements CoreWidgetViewInterface {<font></font>
…<font></font>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">protected</span> void onAttachedToWindow() {
   <span class="hljs-keyword">super</span>.onAttachedToWindow();
   <span class="hljs-keyword">if</span> (!isManualInitEnabled) {<font></font>
        widgetViewDelegate = createWidgetViewDelegate();<font></font>
        widgetViewDelegate.onCreate();<font></font>
   }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> void onCreate() {
    <span class="hljs-comment">//empty. define in descendant class if needed</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// WidgetViewDelegate</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetViewDelegate</span> </span>{<font></font>
…<font></font>
<span class="hljs-keyword">public</span> void onCreate() {
   <span class="hljs-comment">// other logic of widget initialization</span><font></font>
   coreWidgetView.onCreate();<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reinigen Sie immer die Zuhörer</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Formular abhängige Felder enthält, benötigen wir möglicherweise onDetachedFromWindow. </font><font style="vertical-align: inherit;">Stellen Sie sich den folgenden Fall vor: Das Übersetzungsformular enthält viele Felder, unter denen sich eine Dropdown-Liste befindet. </font><font style="vertical-align: inherit;">Abhängig von dem in der Liste ausgewählten Wert wird möglicherweise ein zusätzliches Formulareingabefeld angezeigt oder ein vorhandenes verschwindet.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dropdown-Wert zur Auswahl der Art der Übersetzung</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sichtbarkeit des Eingabefelds für den Zahlungszeitraum</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sichtbarkeit des Eingabefelds der Telefonnummer</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übertragung per Telefonnummer</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsch</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wahr</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zahlung</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wahr</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsch</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dem oben beschriebenen Fall ist es sehr wichtig, alle Widget-Listener in der onDetachedFromWindow-Methode zu löschen, da alle Listener neu initialisiert werden, wenn Sie das Widget erneut zur Liste hinzufügen.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
     initListeners()<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDetachedFromWindow</span><span class="hljs-params">()</span></span> {
      <span class="hljs-keyword">super</span>.onDetachedFromWindow()<font></font>
      clearListeners()<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Behandeln Sie Widget-Ereignisabonnements korrekt</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Darstellung des Bildschirms mit den Widgets sollte über die Änderungen in der Eingabe jedes Widgets informiert werden. Die naheliegendste Implementierung jedes Widgets mithilfe von Ausgabeereignissen und Abonnieren aller Ereignisse mit einem Bildschirmpräsentator. Das Ereignis muss die Widget-ID und ihre Daten enthalten. Es ist am besten, diese Logik so zu implementieren, dass die aktuellen Eingabewerte im Bildschirmmodell gespeichert werden. Wenn Sie auf die Schaltfläche klicken, werden die fertigen Daten in der Anforderung gesendet. Mit diesem Ansatz ist es einfacher, die Formularvalidierung zu implementieren: Sie tritt auf, wenn auf eine Schaltfläche geklickt wird, und wenn keine Fehler aufgetreten sind, wird die Anforderung mit den zuvor gespeicherten Formulardaten gesendet.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> defaultTextChangedListener = <span class="hljs-keyword">object</span> : OnMaskedValueChangedListener {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onValueChanged</span><span class="hljs-params">(value: <span class="hljs-type">String</span>)</span></span> {<font></font>
            presenter.onTextChange(value, id)<font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Events.kt</span>
<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputValueType</span></span>(<span class="hljs-keyword">val</span> id: String)<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextValue</span></span>(id: String, <span class="hljs-keyword">val</span> value: String) : InputValueType(id)<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataEvent</span></span>(<span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span>: InputValueType)<font></font>
<font></font>
<span class="hljs-comment">// TextInputFieldPresenter -  </span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTextChange</span><span class="hljs-params">(value: <span class="hljs-type">String</span>, id: <span class="hljs-type">String</span>)</span></span> {<font></font>
	rxBus.emitEvent(DataEvent(<span class="hljs-keyword">data</span> = TextValue(id = id, value = value)))<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// TransferFormPresenter -  </span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeToEvents</span><span class="hljs-params">()</span></span> {<font></font>
	subscribe(rxBus.observeEvents(DataEvent::<span class="hljs-keyword">class</span>.java))<font></font>
        {<font></font>
            handleValue(it.<span class="hljs-keyword">data</span>) // handle <span class="hljs-keyword">data</span><font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> handleValue(value: InputValueType) {
	 <span class="hljs-keyword">val</span> id = value.id
	 <span class="hljs-keyword">when</span> (value) {<font></font>
		 // handle event using its type, saving event value using its id<font></font>
	 	 <span class="hljs-keyword">is</span> TextValue -&gt; {<font></font>
       		 	 sm.fieldValuesMap[id] = value.value<font></font>
       	 	 }<font></font>
		 <span class="hljs-keyword">else</span> -&gt; {<font></font>
			// handle other events<font></font>
		 }<font></font>
 	 }<font></font>
}<font></font>
// TransferScreenModel<font></font>
<span class="hljs-keyword">class</span> TransferScreenModel : ScreenModel() {<font></font>
 	 // map <span class="hljs-keyword">for</span> form values: key = input id
	 <span class="hljs-keyword">val</span> fieldValuesMap: MutableMap&lt;String, String&gt; = mutableMapOf()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt eine zweite Implementierungsoption, bei der Ereignisse von Widgets mit ihren Daten erst nach dem Klicken auf die Schaltfläche auftreten und nicht während der Eingabe, dh wir erfassen alle Daten unmittelbar vor dem Senden der Anforderung. </font><font style="vertical-align: inherit;">Mit dieser Option wird es viel weniger Ereignisse geben, aber es ist erwähnenswert, dass sich diese Implementierung in der Praxis als nicht trivial herausstellen kann und zusätzliche Logik erforderlich ist, um zu überprüfen, ob alle Ereignisse empfangen wurden.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vereinheitlichen Sie alle Anforderungen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte noch einmal darauf hinweisen, dass der beschriebene Fall erst nach Abstimmung der Anforderungen mit dem Backend möglich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Welche Anforderungen müssen vereinheitlicht werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feldtypen. </font><font style="vertical-align: inherit;">Jedes Feld sollte von der mobilen Anwendung für seine korrekte Anzeige und Verarbeitung erwartet werden.</font></font></li>
<li>  —     ,   ,     ,        .</li>
<li>   ,         .</li>
<li> .    ,          : ,    ,     —              ,        -,     .</li>
</ul><br>
<img src="https://habrastorage.org/webt/vy/h-/v4/vyh-v4r81dk91ehe3t3j8fgurkq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist erforderlich, damit die in der Antwort empfangene Komponente der mobilen Anwendung für die korrekte Anzeige und Verarbeitung der Logik bekannt ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite Nuance besteht darin, dass die Komponenten des Formulars selbst im Allgemeinen unabhängig voneinander sind. Einige Szenarien sind jedoch möglich, wenn beispielsweise die Sichtbarkeit eines Elements vom Zustand eines anderen Elements abhängt, wie oben beschrieben. </font><font style="vertical-align: inherit;">Um diese Logik zu implementieren, müssen die abhängigen Elemente immer zusammenkommen, und die Antwort muss eine Beschreibung der Logik enthalten, welche Komponenten wie voneinander abhängen. </font><font style="vertical-align: inherit;">Und all dies sollte natürlich vor Beginn der Entwicklung mit dem Serverteam vereinbart werden.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie also selbst einen Standardfall wie das Ausfüllen einer dynamischen Liste implementieren, können Sie nicht immer bei bereits vorhandenen Lösungen Halt machen. </font><font style="vertical-align: inherit;">Für uns war dies ein neues Konzept, mit dem wir atomare Logik- und Darstellungselemente aus riesigen Bildschirmen auswählen konnten, und es gelang uns, eine funktionierende erweiterbare Lösung zu erhalten, die aufgrund der Ähnlichkeit von Widgets mit anderen Ansichten einfach zu warten ist. </font><font style="vertical-align: inherit;">In unserer Implementierung wurden Widgets im Hinblick auf das RxPM-Muster entwickelt. Nach dem Hinzufügen von Bindemitteln wurde die Verwendung von Widgets noch bequemer, aber dies ist eine ganz andere Geschichte.</font></font><br>
<br>
<h4><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nützliche Links</font></font></b></h4><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android-Anwendungsentwicklungs- </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Framework Surf</font></a></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget-Modul</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsere </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung des</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einfachen Renderns komplexer Listen</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PresentationModel-Muster</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de498654/index.html">Was ist VPS / VDS und wie kaufe ich es? Die verständlichste Anweisung</a></li>
<li><a href="../de498656/index.html">Crohn-Batterietest</a></li>
<li><a href="../de498658/index.html">Aktualisiertes Web Security-Testhandbuch des OWASP-Konsortiums</a></li>
<li><a href="../de498660/index.html">Wie unsere unbemannte Straßenbahn die reale Stadt sieht</a></li>
<li><a href="../de498662/index.html">Wie kann COVID-19 die Suchergebnisse von Google für immer ändern?</a></li>
<li><a href="../de498672/index.html">Knöpfe und ihre Vielfalt</a></li>
<li><a href="../de498674/index.html">Produktsicherheitstrends 2020 Online-Konferenz Videoaufzeichnungen</a></li>
<li><a href="../de498678/index.html">Kartierung auf den Gipfel des Berges und eines Phonendoskops in der Nähe der Christusstatue - wie Projektoren es Ihnen ermöglichen, in schwierigen Zeiten unterstützende Worte auszudrücken</a></li>
<li><a href="../de498688/index.html">Toller A / B Test Guide</a></li>
<li><a href="../de498692/index.html">SIP-Anschluss Telegramm + Voximplant = Anrufe an Mobiltelefone und Softphones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>