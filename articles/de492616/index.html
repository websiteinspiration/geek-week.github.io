<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👩‍👧‍👧 🍴 👷 Packer, Terraform und Ansible: Kubernetes-Clusterbereitstellung in einer Stunde 🛕 🐻 🚶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, mein Name ist Andrey Schukin. Ich helfe großen Unternehmen bei der Migration von Diensten und Systemen in die CROC Cloud. Zusammen mit Kollegen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Packer, Terraform und Ansible: Kubernetes-Clusterbereitstellung in einer Stunde</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/croccloudteam/blog/492616/"><img src="https://habrastorage.org/webt/0m/2c/zt/0m2cztx1saqv1v7e8a3mrliht_k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hallo, mein Name ist Andrey Schukin. Ich helfe großen Unternehmen bei der Migration von Diensten und Systemen in die CROC Cloud. Zusammen mit Kollegen aus Southbridge, die Kubernetes-Kurse im Slerm-Schulungszentrum durchführen, haben wir kürzlich ein Webinar für unsere Kunden durchgeführt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe mich entschlossen, Materialien aus einem ausgezeichneten Vortrag von Pavel Selivanov zu nehmen und einen Beitrag für diejenigen zu schreiben, die gerade erst mit Cloud-Provisioning-Tools arbeiten und nicht wissen, wo sie anfangen sollen. Daher werde ich über den Stapel von Technologien sprechen, die in unserer Schulung und Produktion von CROC Cloud verwendet werden. Lassen Sie uns über moderne Ansätze für das Infrastrukturmanagement sprechen, über eine Reihe von Packer-, Terraform- und Ansible-Komponenten sowie über das Kubeadm-Tool, mit dem wir installieren werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter dem Schnitt wird viel Text und Konfigurationen sein. </font><font style="vertical-align: inherit;">Da es viel Material gibt, habe ich die Post-Navigation hinzugefügt. </font><font style="vertical-align: inherit;">Wir haben auch ein kleines Repository vorbereitet, in dem wir alles aufbewahren, was wir für unsere Schulungsbereitstellung benötigen. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geben Sie keine Hühnernamen. </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gebackene Kuchen sind gesünder als gebratene. </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir starten den Ofen. </font><font style="vertical-align: inherit;">Packer </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terraform - Infrastruktur als Code </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starten Sie die Terraform- </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clusterstruktur Kubernetes </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubeadm </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository mit allen Dateien</font></font></a><br>
 <a name="habracut"></a><br>
<a name="1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geben Sie Hühnern keine Namen</font></font></h2><br>
<img src="https://habrastorage.org/webt/j0/0w/v1/j00wv1h7pcevviakk2iocfleqjk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt viele verschiedene Konzepte des Infrastrukturmanagements. Einer von ihnen heißt Haustiere vs. Rinder, das heißt "Haustiere gegen Vieh". Dieses Konzept beschreibt zwei gegensätzliche Ansätze für die Infrastruktur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich vor, wir haben einen Lieblingshund. Wir kümmern uns um sie, bringen ihn zum Tierarzt, kämmen das Fell aus und im Allgemeinen ist es unter vielen anderen Hunden einzigartig für uns.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einem anderen Fall haben wir einen Hühnerstall. Wir kümmern uns auch um Hühner, füttern, erhitzen und versuchen, die angenehmsten Bedingungen zu schaffen. Trotzdem sind Hühner für uns eine eher gesichtslose Ressource, die ihre Funktion der Eiablage erfüllt, und wir bezeichnen sie bestenfalls als "das schwarze Pulver, das immer Zement pickt". Wenn das Huhn aufhört, Eier zu legen oder seine Pfote bricht, wird es uns höchstwahrscheinlich einfach eine köstliche Brühe zum Mittagessen liefern. Tatsächlich kümmern wir uns nicht um das Schicksal eines einzelnen Huhns, sondern um den Hühnerstall als Ganzes als Produktionslinie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der IT wurde ein ähnlicher Ansatz angewendet, sobald Tools erschienen, die die Einstiegsschwelle für Ingenieure senkten und die Bereitstellung und Wartung komplexer Cluster in einem vollautomatischen Modus ermöglichten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuvor hatten wir eine kleine Anzahl von Servern, die überwacht, manuell optimiert und auf jede mögliche Weise gepflegt wurden. Bei der Überwachung wurden Protokolle von den Servern Cthulhu, Aylith und Dagon geflasht. Traditionen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann drang die Virtualisierung fest in unser Leben ein und die Namen aus den Werken von Lovecraft und Star Trek machten dem nützlicheren „vlg-vlt-vault01.company.ru“ Platz. Es gibt viele Server, aber wir haben die Dienste immer noch mehr oder weniger manuell erhöht, um die Probleme auf jedem Computer bei Bedarf zu beseitigen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt stimmt der Ansatz zur Wartung der Infrastruktur vollständig mit der Programmierung überein. </font><font style="vertical-align: inherit;">Wir fügen eine weitere Abstraktionsebene hinzu und kümmern uns nicht mehr um einzelne Knoten. </font><font style="vertical-align: inherit;">Jeder hat einen gesichtslosen Index anstelle eines Namens, und im Falle eines Problems wird die virtuelle Maschine einfach beendet und steigt aus dem Arbeitsschnappschuss auf. </font><font style="vertical-align: inherit;">Es gibt Tools, mit denen Sie diesen Ansatz implementieren können. </font><font style="vertical-align: inherit;">In unserem Fall ist das erste Tool die CROC Cloud, das zweite Terraform.</font></font><br>
<br>
<a name="2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gebackene Kuchen sind gesünder als gebraten</font></font></h2><br>
<img src="https://habrastorage.org/webt/hs/pp/oa/hsppoaujv0lhrk0u3dt6ust0rry.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Infrastrukturmanagement gibt es einen Kontrast zwischen den beiden Ansätzen Fried vs. Gebacken, das heißt "gebraten gegen gebacken". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Fried-Ansatz impliziert, dass Sie über ein Vanilla-Betriebssystem-Image verfügen, z. B. CentOS 7. Nach der Bereitstellung des Betriebssystems verwenden wir das Konfigurationsverwaltungssystem, um das System in den Zielstatus zu versetzen. Zum Beispiel mit Ansible, Chef, Puppet oder SaltStack.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles funktioniert gut, besonders wenn es nicht sehr viele Server gibt. Wenn eine massive Bereitstellung erforderlich ist, sind wir mit Leistungsproblemen konfrontiert. Hunderte von Servern verschlingen synchron Netzwerkressourcen, CPU, RAM und IOPS, während viele neue Pakete gerollt werden. Darüber hinaus kann sich dieser Vorgang ziemlich lange verzögern. Kurz gesagt, die Schaltung ist absolut betriebsbereit, aber unter dem Gesichtspunkt der Minimierung von Ausfallzeiten bei Unfällen nicht so interessant.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Baked-Ansatz impliziert, dass Sie vorgefertigte "gebackene" Betriebssystem-Images haben, auf denen Sie bereits alle erforderlichen Pakete installiert, die Konfiguration und alles andere konfiguriert haben. </font><font style="vertical-align: inherit;">Bei der Ausgabe haben wir eine abstrakte Snapshot-Vorlage, die für die Ausführung einiger Funktionen geschärft wurde. </font><font style="vertical-align: inherit;">Das Bereitstellen der Infrastruktur aus solchen gebackenen Images nimmt erheblich weniger Zeit in Anspruch und reduziert Ausfallzeiten auf ein Minimum. </font><font style="vertical-align: inherit;">Eine sehr ähnliche Ideologie wird in mehrschichtigen Docker-Bildern verwendet, in denen niemand unnötig in die Hände stößt. </font><font style="vertical-align: inherit;">Den Container genagelt - einen neuen aufgehoben.</font></font><br>
<br>
<a name="3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir starten den Ofen. </font><font style="vertical-align: inherit;">Packer</font></font></h2><br>
<img src="https://habrastorage.org/webt/xw/mr/im/xwmrimtkl-6qvfcrae3xo4zdf7q.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserer Infrastruktur verwenden wir mehrere Hashicorp-Produkte, von denen sich einige als äußerst erfolgreich erwiesen haben. Beginnen wir unsere Magie mit dem Vorbereiten und Backen eines Bildes mit dem Packer-Tool. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Packer verwendet eine JSON-Vorlage, dh Vorlagendateien, die eine Beschreibung dessen enthalten, was als "gebackene" virtuelle Maschine (VM) abgerufen werden muss. Nach dem Erstellen der Vorlage wird die Datei an Packer übertragen und die erforderlichen Berechtigungen zum Erstellen des Servers in der Cloud werden konfiguriert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Packer können Sie VMs lokal in KVM, VirtualBox, Vagrant, AWS, GCP, Alibaba Cloud, OpenStack usw. anheben. Es ist praktisch, mit Packer in der CROC Cloud zu arbeiten, da AWS-Schnittstellen implementiert werden, dh alle Tools, für die geschrieben wurde AWS, arbeiten Sie mit der CROC Cloud.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Festlegen der erforderlichen Vorlagen löst Packer VM CROC in der Cloud aus, wartet auf den Start und der „Provider“ betritt den Work-Provisioner: ein Dienstprogramm, das die Image-Vorbereitung abschließen muss. </font><font style="vertical-align: inherit;">In unserem Fall ist dies Ansible, obwohl Packer mit anderen Optionen arbeiten kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die VM bereit ist, erstellt Packer ihr Image und platziert es in der CROC Cloud, sodass andere VMs von demselben Image aus gestartet werden können.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Base.json-Struktur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Anfang der Datei befindet sich ein Abschnitt, in dem Variablen deklariert werden:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"variables" : {<font></font>
 "source_ami_name": "{{env SOURCE_AMI_NAME}}",<font></font>
 "ami_name": "{{env AMI_NAME}}",<font></font>
 "instance_type": "{{env INSTANCE_TYPE}}",<font></font>
 "kubernetes_version": "{{env KUBERNETES_VERSION}}",<font></font>
 "docker_version": "{{env DOCKER_VERSION}}",<font></font>
 "subnet_id": "",<font></font>
 "availability_zone": "",<font></font>
},</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Hauptsatz dieser Variablen wird aus der Datei settings.json festgelegt. </font><font style="vertical-align: inherit;">Und diese Variablen, die sich häufig ändern, können bequemer über die Konsole festgelegt werden, wenn Sie Packer starten und ein neues Image erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Folgende ist der Abschnitt Builder:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"builders" : [<font></font>
 {<font></font>
  "type": "amazon-ebs",<font></font>
  "region": "croc",<font></font>
  "skip_region_validation": true,<font></font>
  "custom_endpoint_ec2": "https://api.cloud.croc.ru",<font></font>
  "source_ami": "",<font></font>
  "source_ami_filter": {<font></font>
   "filters": {<font></font>
    "name": "{{user `source_ami_name`}}"<font></font>
    "state": "available",<font></font>
    "virtualization-type": "kvm-virtio"<font></font>
     },<font></font>
...</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zielwolken und die VM-Startmethode werden hier beschrieben. Bitte beachten Sie, dass in diesem Fall der Typ amazon-ebs deklariert ist, für den Betrieb von Packer mit der CROC Cloud jedoch die entsprechende Adresse in custom_endpoint_ec2 festgelegt ist. Unsere Infrastruktur verfügt über eine API, die fast vollständig mit Amazon Web Services kompatibel ist. Wenn Sie also vorgefertigte Entwicklungen für diese Plattform haben, müssen Sie zum größten Teil nur einen benutzerdefinierten API-Einstiegspunkt angeben - </font><font style="vertical-align: inherit;">in unserem Beispiel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">api.cloud.croc.ru</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist erwähnenswert, den Abschnitt source_ami_filter separat zu erwähnen. </font><font style="vertical-align: inherit;">Hier wird das Ausgangsimage der VM eingestellt, in dem die notwendigen Änderungen vorgenommen werden. </font><font style="vertical-align: inherit;">Packer benötigt jedoch eine AMI für dieses Bild, d. H. Seine zufällige Kennung. </font><font style="vertical-align: inherit;">Da diese Kennung selten im Voraus bekannt ist und sich mit jedem Update ändert, wird die Quell-AMI nicht als spezifischer Wert, sondern als Variable source_ami_filter festgelegt. </font><font style="vertical-align: inherit;">In diesem Fall ist der bestimmende Parameter des Filters der Name des Bildes. </font><font style="vertical-align: inherit;">Dieser Name wird in den Variablen über die Datei settings.json festgelegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes werden die VM-Einstellungen definiert: Der Instanztyp, der Prozessor, die Speichergröße, der zugewiesene Speicherplatz usw. werden angegeben:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"instance_type": "{{user `instance_type`}}",<font></font>
"launch_block_device_mappings": [<font></font>
 {<font></font>
  "device_name": "disk1",<font></font>
  "volume_type": "io1",<font></font>
  "volume_size": "8",<font></font>
  "iops": "1000",<font></font>
  "delete_on_termination": "true"<font></font>
 }<font></font>
],</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In base.json sind die Parameter für die Verbindung zu dieser VM aufgeführt:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"availability_zone": "{{user `availability_zone`}}",<font></font>
"subnet_id": "{{user `subnet_id`}}",<font></font>
"associate_public_ip_address": true,<font></font>
"ssh_username": "ec2-user",<font></font>
"ami_name": "{{user `ami_name`}}"<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist wichtig, den Parameter subnet_id hier zu beachten. </font><font style="vertical-align: inherit;">Es muss manuell festgelegt werden, da ohne Angabe des VM-Subnetzes in der CROC Cloud keine Erstellung möglich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer Parameter, der einer vorherigen Vorbereitung bedarf, ist Associate_public_ip_address. </font><font style="vertical-align: inherit;">Sie müssen eine weiße IP-Adresse auswählen, da nach dem Erstellen des VM Packer die erforderlichen Einstellungen über Ansible vorgenommen werden. </font><font style="vertical-align: inherit;">In diesem Fall stellt Ansible über SSH eine Verbindung zur VM her, für die eine weiße IP-Adresse oder ein VPN erforderlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der letzte Abschnitt sind die Provisioner:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">"provisioners": [<font></font>
 {<font></font>
  "type": "ansible",<font></font>
  "playbook_file": "playbook.yml",<font></font>
  "extra_arguments": [<font></font>
   "--extra-vars",<font></font>
   "kubernetes_version={{user `kubernetes_version`}}",<font></font>
   "--extra-vars",<font></font>
   "docker_version={{user `docker_version`}}"<font></font>
   ]<font></font>
  }<font></font>
]</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies sind die Anbieter, dh die Dienstprogramme, mit denen Packer den Server konfiguriert. </font><font style="vertical-align: inherit;">In diesem Fall wird ein Ansible-Typ-Provider verwendet. </font><font style="vertical-align: inherit;">Der folgende Parameter ist playbook_file, der die Ansible-Rollen und die Hosts definiert, auf die die angegebenen Rollen angewendet werden. </font><font style="vertical-align: inherit;">Im Folgenden werden zusätzliche Optionen extra_arguments vorgestellt, mit denen beim Starten von Ansible Versionen von Kubernetes und Docker übertragen werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CROC Cloud-Vorbereitung</font></font></h3><br>
 <img src="https://habrastorage.org/webt/23/_s/uo/23_suoef0us5ia6kjgn8xteomba.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zu unseren Konfigurationsdateien müssen wir einige Dinge von der Seite des Cloud-Kontrollfelds aus tun, damit die ganze Magie funktioniert. </font><font style="vertical-align: inherit;">Wir müssen eine weiße IP auswählen und ein funktionierendes Subnetz erstellen, das wir bei der Bereitstellung verwenden werden.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klicken Sie auf Adresse markieren. </font><font style="vertical-align: inherit;">Der Packer findet die gewünschte weiße IP-Adresse selbstständig.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klicken Sie auf Subnetz erstellen und geben Sie ein Subnetz und eine Maske an. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kopieren Sie die Subnetz-ID. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie diesen Wert in den Parameter subnet_id des Packer-Startbefehls ein. </font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/24/0w/gp/240wgpvzi8oyy6ixwzdj8cougqk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Führen Sie dann Packer aus. </font><font style="vertical-align: inherit;">Er findet das ursprüngliche VM-Image, stellt es in der CROC-Cloud bereit und führt die Ansible-Rolle darauf aus. </font><font style="vertical-align: inherit;">Die neue VM ist in der CROC Cloud im Abschnitt "Instanzen" zu sehen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ol/aj/ui/olajuiprqljv50bi2opn4xlqcvs.png"> <br>
 <br>
<img src="https://habrastorage.org/webt/rq/0d/ri/rq0drint5cwvddjxbd7czcyfp9a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach Abschluss der Arbeiten entfernt Packer die VM aus der Cloud und hinterlässt an ihrer Stelle ein fertiges Image, das im Abschnitt "Vorlagen" zu finden ist. </font><font style="vertical-align: inherit;">Aus diesem Image wird die gesamte Kubernetes-Infrastruktur erstellt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ansible</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erwähnt, wird der Playbook-Parameter in den Parametern des Ansible-Anbieters übergeben. </font><font style="vertical-align: inherit;">Die Datei playbook.yml selbst sieht folgendermaßen aus:</font></font><br>
<br>
<pre><code class="plaintext hljs">- hosts: all<font></font>
  become: true<font></font>
<font></font>
  roles:<font></font>
  | - base</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Datei überträgt an Ansible, dass auf allen Hosts die Rolle der Basis erfüllt werden muss. </font><font style="vertical-align: inherit;">Wenn andere Rollen vorhanden sind, können Sie sie derselben Datei wie eine Liste hinzufügen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der Basiserolle können Sie mit einem einzigen Befehl einen vorgefertigten Cluster abrufen. </font><font style="vertical-align: inherit;">Die Datei main.yml zeigt, was genau diese Rolle bewirkt:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügt der Systemvorlage ein Docker-Repository hinzu. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügt das Kubernetes-Repository zur Systemvorlage hinzu. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installiert die erforderlichen Pakete. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellt ein Verzeichnis zum Konfigurieren des Docker-Dämons. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfiguriert den Computer gemäß der Konfigurationsdatei daemon.json.j2. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lädt den Kernel br_netfilter.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enthält die erforderlichen Optionen für br_netfilter.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enthält Docker- und Kubelet-Komponenten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Führt Docker in VM aus.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Führt einen Befehl aus, der die Docker-Images herunterlädt, die für die Funktion von Kubernetes erforderlich sind.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall werden die installierten Pakete in der Datei main.yml aus dem Verzeichnis vars festgelegt. </font><font style="vertical-align: inherit;">In unserem Fall installieren wir das Docker-CE-Paket sowie die drei Pakete, die für die Funktion von Kubernetes erforderlich sind: kubelet, kubeadm und kubectl.</font></font><br>
<br>
<a name="4"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terraform - Infrastruktur als Code</font></font></h2><br>
<img src="https://habrastorage.org/webt/o4/um/wi/o4umwitq-qh_zpwr0thmcmejis0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terraform ist ein sehr funktionales Tool von HashiCorp für die Cloud-Orchestrierung. Es verfügt über eine eigene spezifische HCL-Sprache, die häufig in anderen Produkten des Unternehmens verwendet wird, z. B. in HashiCorp Vault und Consul. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Grundprinzip ähnelt allen Konfigurationsmanagementsystemen. Sie geben einfach den Zielzustand im gewünschten Format an und das System berechnet den Algorithmus, wie dies erreicht werden kann. Eine andere Sache ist, dass Terraform im Gegensatz zu demselben Ansible, das in komplexen Playbooks als Black Box fungiert, einen Plan für zukünftige Aktionen in einer für die Analyse geeigneten Form erstellen kann. Dies ist wichtig bei der Planung komplexer Infrastrukturänderungen. Führen Sie nach dem Planen der erforderlichen Aktionen den Befehl </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terraform apply aus,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Terraform stellt die in den Dateien beschriebene Infrastruktur bereit.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Packer unterstützt dieses Tool AWS, GCP, Alibaba Cloud, Azure, OpenStack, VMware usw.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir beschreiben das Projekt</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Terraform-Verzeichnis enthält eine Reihe von Dateien mit der Erweiterung .tf. </font><font style="vertical-align: inherit;">Diese Dateien beschreiben die Komponenten der Infrastruktur, mit der wir arbeiten werden. </font><font style="vertical-align: inherit;">Teilen Sie das Projekt in Funktionsmodule auf. </font><font style="vertical-align: inherit;">Eine solche Struktur erleichtert die Steuerung der Versionierung und das Zusammensetzen jedes Projekts aus vorgefertigten praktischen Blöcken. </font><font style="vertical-align: inherit;">Für unsere Option ist folgende Struktur geeignet:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.tf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">network.tf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">security_groups.tf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">master.tf</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">master.tpl</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Main.tf-Dateistruktur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit der Datei main.tf, in der der Zugriff auf die Cloud konfiguriert ist. </font><font style="vertical-align: inherit;">Insbesondere werden mehrere Parameter angekündigt, die Terraform für die Verwendung mit der CROC Cloud konfigurieren:</font></font><br>
<br>
<pre><code class="plaintext hljs">provider "aws" {<font></font>
 endpoints {<font></font>
  ec2 = "https://api.cloud.croc.ru"<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus beschreibt die Datei, dass Terraform unabhängig einen privaten Schlüssel erstellen und seinen öffentlichen Teil auf alle Server hochladen muss. </font><font style="vertical-align: inherit;">Der private Schlüssel selbst wird am Ende von Terraform ausgegeben:</font></font><br>
<br>
<pre><code class="plaintext hljs">resource "tls_private_key" "ssh" {<font></font>
 algorithm = "RSA"<font></font>
}<font></font>
resource "aws_key_pair" "kube" {<font></font>
 key_name = "terraform"<font></font>
 public_key = "${tls_private_key.ssh.public_key_openssh}"<font></font>
}<font></font>
output "ssh" {<font></font>
value = "${tls_private_key.ssh.private_key_pem}"<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Struktur der Datei network.tf</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Datei beschreibt die Netzwerkkomponenten, die zum Starten der VM erforderlich sind:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">data "aws_availability_zones" "az" {<font></font>
 state = "available"<font></font>
}<font></font>
resource "aws_vpc" "kube" {<font></font>
 cidr_block = "${var.vpc_cidr}"<font></font>
}<font></font>
resource "aws_eip" "master" {<font></font>
 count = "1"<font></font>
 vpc = true<font></font>
}<font></font>
resource "aws_subnet" "private" {<font></font>
 vpc_id = "${aws_vpc.kube.id}"<font></font>
 count = "${length(data.aws_availability_zones.az.names)}"<font></font>
 cidr_block = "${var.private_subnet_cidr_list[count.index]}"<font></font>
 availability_zone = "${data.aws_availability_zones.az.names[count.index]}"<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terraform verwendet zwei Arten von Komponenten:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ressource - was muss geschaffen werden;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daten - was Sie brauchen, um zu bekommen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall gibt der Datenparameter an, dass Terraform die Verfügbarkeitszonen der angegebenen Cloud erhalten soll, die sich im verfügbaren Zustand befinden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste Parameterressource beschreibt die Erstellung einer virtuellen privaten Cloud, und der nächste Parameter beschreibt die Erstellung einer elastischen IP-Adresse. Für den Kubernetes-Cluster bestellen wir diese IP-Adresse über Terraform. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus wird in jeder der Barrierefreiheitszonen und im Moment, in dem CROC über zwei Cloud-Dienste verfügt, ein eigenes Subnetz erstellt. Eine Ressource vom Typ aws_subnet wird deklariert und die ID des erstellten aws_vpc wird als Teil dieses Parameters übergeben. Da die ID dieser Ressource jedoch noch unbekannt ist, geben wir den Parameter aws_vpc.kube.id an, der auf die erstellte Ressource verweist und den Wert aus dem ID-Feld ersetzt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die Anzahl der erstellten Subnetze durch die Anzahl der Cloud-Verfügbarkeitszonen bestimmt wird und sich diese Anzahl im Laufe der Zeit ändern kann, wird dieser Parameter über die Längenvariable (data.aws_availability_zones.az.names) festgelegt, d. H. Die Länge der Liste der über den Datenparameter empfangenen Zugriffszonen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die letzten beiden Parameter sind cidr_block (das zugewiesene Subnetz) und die Verfügbarkeitszone, in der dieses Subnetz erstellt wird. </font><font style="vertical-align: inherit;">Der letzte Parameter wird auch über eine Variable festgelegt, die einen Wert aus der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenliste</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gemäß dem Index der von </font><b><font style="vertical-align: inherit;">[count.index]</font></b><font style="vertical-align: inherit;"> deklarierten Schleife </font><b><font style="vertical-align: inherit;">übernimmt</font></b><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Security_groups.tf Dateistruktur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sicherheitsgruppen sind eine Art Firewall für Clouds, die nicht in der VM selbst, sondern in der Cloud erstellt werden kann. </font><font style="vertical-align: inherit;">In diesem Fall beschreibt die Firewall zwei Regeln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste Regel erstellt eine Sicherheitsgruppe namens kube. </font><font style="vertical-align: inherit;">Diese Sicherheitsgruppe wird benötigt, um den gesamten ausgehenden Datenverkehr von Kubernetes-Knoten zuzulassen und den Knoten den freien Zugriff auf das Internet zu ermöglichen. </font><font style="vertical-align: inherit;">Eingehender Verkehr zu Kubernetes-Knoten aus den Subnetzen der Knoten selbst ist ebenfalls zulässig. </font><font style="vertical-align: inherit;">Somit können Kubernetes-Knoten ohne Einschränkungen untereinander arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite Regel erstellt die Sicherheitsgruppe ssh. </font><font style="vertical-align: inherit;">Es ermöglicht eine SSH-Verbindung von einer beliebigen IP-Adresse zu Port 22 der Kubernetes-Cluster-VM:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">resource "aws_security_group" "kube" {<font></font>
 vpc_id = "${aws_vpc.kube.id}"<font></font>
 name   = "kubernetes"<font></font>
 # Allow all outbound<font></font>
 egress {<font></font>
  from_port = 0<font></font>
  to_port = 0<font></font>
  protocol = "-1"<font></font>
  cidr_blocks = ["0.0.0.0/0"]<font></font>
 }<font></font>
 # Allow all internal<font></font>
 ingress {<font></font>
  from_port = 0<font></font>
  to_port = 0<font></font>
  protocol = "-1"<font></font>
  cidr_blocks = ["${var.vpc_cidr}"]<font></font>
 }<font></font>
}<font></font>
resource "aws_security_group" "ssh" {<font></font>
 vpc_id = "${aws_vpc.kube.id}"<font></font>
 name   = "ssh"<font></font>
<font></font>
 # Allow all inbound<font></font>
 ingress {<font></font>
  from_port = 22<font></font>
  to_port = 22<font></font>
  protocol = "tcp"<font></font>
  cidr_blocks = ["0.0.0.0/0"]<font></font>
 }<font></font>
}</code></pre><br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauptknoten. </font><font style="vertical-align: inherit;">Master.tf-Dateistruktur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Datei master.tf beschreibt die Erstellung mehrerer Vorlagen und Instanzen. </font><font style="vertical-align: inherit;">Insbesondere wird eine Kubernetes-Masterinstanz erstellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Variable ami legt den AMI des Quellabbilds für die VM fest. </font><font style="vertical-align: inherit;">Im Folgenden werden der VM-Typ und das Subnetz beschrieben, in dem sie erstellt wird. </font><font style="vertical-align: inherit;">Beim Definieren eines Subnetzes wird erneut ein Zyklus verwendet, um VMs in jeder Verfügbarkeitszone zu erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Nächstes werden die verwendeten Sicherheitsgruppen und der in der Datei main.tf angegebene Schlüssel deklariert. </font><font style="vertical-align: inherit;">Das Feld user_data enthält die Ausführung einer Reihe von Cloud-Init-Skripten, deren Ergebnisse in der VM implementiert werden:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spoiler</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">resource "aws_instance" "master" {<font></font>
 count = "1"<font></font>
 ami = "${var.kubernetes_ami}"<font></font>
 instance_type = "c3.large"<font></font>
 disable_api_termination = false<font></font>
 instance_initiated_shutdown_behavior = "terminate"<font></font>
 source_dest_check = false<font></font>
 subnet_id = "${aws_subnet.private.*.id[count.index % length(data.aws_availability_zones.az.names)]}"<font></font>
 associate_public_ip_address = true<font></font>
 vpc_security_group_ids = [<font></font>
  "${aws_security_group.ssh.id}",<font></font>
  "${aws_security_group.kube.id}",<font></font>
 ]<font></font>
 key_name = "${aws_key_pair.kube.key_name}"<font></font>
 user_data = "${data.template_cloudinit_config.master.rendered}"<font></font>
 monitoring = "true"<font></font>
}</code></pre><br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauptknoten. </font><font style="vertical-align: inherit;">Cloud init</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud-init</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein Tool, das Canonical entwickelt. </font><font style="vertical-align: inherit;">Sie können bestimmte Befehle in einer Cloud-Infrastruktur automatisch ausführen, nachdem Sie eine VM gestartet haben. </font><font style="vertical-align: inherit;">Terraform verfügt über Mechanismen zur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integration mithilfe von Vorlagen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da es unmöglich ist, alles Notwendige in der VM zu "backen", muss sie nach dem Start je nach Typ entweder dem Kubernetes-Cluster beitreten oder den Kubernetes-Cluster initialisieren. </font><font style="vertical-align: inherit;">In der Cloud-Init-Dateivorlage mit dem Namen master.tpl werden mehrere Aktionen ausgeführt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Konfigurationsdateien für Kubeadm werden aufgezeichnet:</font></font><br>
<br>
<pre><code class="plaintext hljs">#cloud-config<font></font>
<font></font>
    write_files:<font></font>
    - path: etc/kubernetes/kubeadm.conf<font></font>
      owner: root:root<font></font>
      content:<font></font>
    ...</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Eine Reihe von Befehlen wird ausgeführt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die IP-Adresse des Assistenten wird in die generierte Konfigurationsdatei geschrieben.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Master im Kubernetes-Cluster wird mit dem Befehl kubeadm init initialisiert.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Kubernetes-Cluster wird das Calico-Overlay-Netzwerk mit dem Befehl kubectl apply installiert.</font></font></li>
</ul><br>
 <pre><code class="plaintext hljs">runcmd:<font></font>
         - sed -i "s/CONTROL_PLANE_IP/$(curl http://169.254.169.254/latest/meta-data-local-ipv4)/g" /etc/kubernetes/kubeadm.conf<font></font>
         - kubeadm init --config /etc/kubernetes/kubeadm.conf<font></font>
         - mkdir -p $HOME/.kube<font></font>
         - sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<font></font>
         - sudo chown $(id -u):$(id -g) $HOME/.kube/config<font></font>
         - kubectl apply -f https://docs.projectcalico.org/v3.8/manifests/calico.yaml</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Ausführen der Befehle beim Starten der VM wird ein funktionierender Kubernetes-Cluster von einem Masterknoten abgerufen. </font><font style="vertical-align: inherit;">Die verbleibenden Knoten werden diesem Masterknoten beitreten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gewöhnliche Knoten. </font><font style="vertical-align: inherit;">node.tf</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Datei node.tf ähnelt der Datei master.tf. </font><font style="vertical-align: inherit;">Hier werden auch Ressourcen erstellt, die in diesem Fall als Knoten bezeichnet werden. </font><font style="vertical-align: inherit;">Der einzige Unterschied besteht darin, dass der Masterknoten in einer einzelnen Instanz erstellt wird und die Anzahl der erstellten Arbeitsknoten über die Variable node_count festgelegt wird:</font></font><br>
<br>
<pre><code class="plaintext hljs">resource "aws_instance" "node" {<font></font>
 count = "${var.nodes_count}"<font></font>
 ami = "${var.kubernetes_ami}"<font></font>
 instance_type = "c3.large"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Cloud-Init-Datei für Arbeitsknoten führt nur einen Befehl aus - kubeadm join. </font><font style="vertical-align: inherit;">Dieser Befehl hängt den fertigen Computer mithilfe des von uns gesendeten Autorisierungstokens an den Kubernetes-Cluster an.</font></font><br>
<br>
<a name="5"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starten Sie Terraform</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Start verwendet Terraform mehrere Module:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AWS-Modul</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorlagenmodul;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLS-Modul, das für die Schlüsselgenerierung verantwortlich ist. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Module müssen auf dem lokalen Computer installiert sein:</font></font><br>
<br>
<pre><code class="plaintext hljs">terraform init terraform/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusammen mit diesem Befehl wird das Verzeichnis angezeigt, in dem sich alle erforderlichen Dateien befinden. </font><font style="vertical-align: inherit;">Bei der Initialisierung lädt Terraform alle angegebenen Module herunter. Anschließend müssen Sie den Befehl terraform plan ausführen:</font></font><br>
<br>
<pre><code class="plaintext hljs">terraform plan -var-file terraform/vars/dev.tfvars terraform/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass zusätzlich zu dem Verzeichnis mit den Terraform-Dateien die var-Datei angezeigt wird, die die Werte der in den Terraform-Dateien verwendeten Variablen enthält. </font><font style="vertical-align: inherit;">Das vars-Verzeichnis kann mehrere .tfvars-Dateien enthalten, mit denen Sie verschiedene Arten von Infrastrukturen mit einem Satz Terraform-Dateien verwalten können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Datei dev.tfvars selbst enthält die folgenden wichtigen Variablen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes_version (installierbare Version von Kubernetes);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes_ami (AMI-Image, das Packer erstellt hat). </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Führen Sie nach dem Festlegen der erforderlichen Werte für die Variablen den Befehl terraform plan aus. Anschließend zeigt Terraform eine Liste der Aktionen an, die erforderlich sind, um den in den Terraform-Dateien beschriebenen Status zu erreichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenden Sie nach dem Überprüfen dieser Liste die vorgeschlagenen Änderungen an: </font></font><br>
<br>
<code>terraform apply -auto-approve -var-file terraform/vars/dev.tfvars terraform/</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Befehl terraform plan unterscheidet sich durch das Vorhandensein eines Schlüssels - Auto-Approve -, sodass die vorgenommenen Änderungen nicht mehr bestätigt werden müssen. </font><font style="vertical-align: inherit;">Sie können diesen Schlüssel weglassen, aber dann muss jede Aktion manuell bestätigt werden.</font></font><br>
<br>
<a name="6"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes-Clusterstruktur</font></font></h2><br>
<img src="https://habrastorage.org/webt/zs/i-/c3/zsi-c326-ips2acfurg_trunzhm.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Kubernetes-Cluster besteht aus einem Masterknoten, der Verwaltungsfunktionen ausführt, und Arbeitsknoten, auf denen im Cluster installierte Anwendungen ausgeführt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf dem Masterknoten sind vier Komponenten installiert, die den Betrieb dieses Systems sicherstellen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ETCD, d. H. Kubernetes-Datenbank</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API-Server, über den wir Informationen in Kubernetes speichern und Informationen daraus abrufen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Controller Manager</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planer </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf den Arbeitsknoten sind zwei zusätzliche Komponenten installiert:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kube-Proxy (verantwortlich für die Generierung von Netzwerkregeln im Kubernetes-Cluster);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubelet (verantwortlich für das Senden des Befehls an den Docker-Dämon zum Ausführen von Anwendungen im Kubernetes-Cluster). </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zwischen den Knoten funktioniert das Calico-Netzwerk-Plug-In.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cluster-Workflow-Diagramm</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/oz/ew/f3/ozewf310dnhdmnx2gg4ozhzb1rc.png"><br>
,      Kubernetes    replicaset.<br>
<br>
<ol>
<li>     API-,     ETCD.        .</li>
<li>API-      .</li>
<li>Controller-manager   API-   ,    «»,    .</li>
<li>Scheduler       .       ETCD  API-.</li>
<li>Kubelet  API-  Docker    .</li>
<li>Docker   .</li>
<li>Kubelet   API-   ,     .</li>
</ol><br>
 ,    Kubernetes  ,      .       ,           ,     YAML-.  ,   ,    API-.       .<br>
</div></div><br>
<a name="7"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubeadm</font></font></h2><br>
<img src="https://habrastorage.org/webt/wd/sw/cu/wdswcujzvnx4ynnrbi_ec9c1gr8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das letzte erwähnenswerte Element ist Kubeadm. </font><font style="vertical-align: inherit;">Das Bereitstellen eines neuen Kubernetes-Clusters ist immer ein mühsamer Prozess. </font><font style="vertical-align: inherit;">In jeder Phase besteht das Risiko von Fehlern aufgrund des menschlichen Faktors, und viele Aufgaben sind einfach sehr routinemäßig und langwierig. </font><font style="vertical-align: inherit;">Beispiel: Gießen von Zertifikaten für die TLS-Verschlüsselung zwischen Knoten und Aktualisieren dieser Zertifikate. </font><font style="vertical-align: inherit;">Hier helfen Dienstprogramme für die grundlegende Vorlagenautomatisierung. </font><font style="vertical-align: inherit;">Der Trick von Kubeadm ist, dass es offiziell für die Arbeit mit Kubernetes zertifiziert ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ermöglicht Ihnen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installieren, konfigurieren und führen Sie alle wichtigen Clusterkomponenten aus</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zertifikate verwalten, einschließlich drehen und neue ausschreiben;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwalten von Clusterkomponentenversionen (Upgrade und Downgrade). </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gleichzeitig ist Kubeadm kein vollständiges Kubernetes-Clusterverwaltungssystem, sondern eine Art Baustein, mit dem Sie Kubernetes auf dem Knoten konfigurieren können, auf dem das Kubeadm-Dienstprogramm ausgeführt wird. </font><font style="vertical-align: inherit;">Dies bedeutet, dass ein Orchestrierungssystem benötigt wird, das alle erforderlichen VMs ausführt, konfiguriert und Kubeadm auf allen Knoten ausführt. </font><font style="vertical-align: inherit;">Für diese Zwecke wird Terraform verwendet.</font></font><br>
<br>
<a name="8"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository mit allen Dateien</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier platzieren </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir alle Dateien und Konfigurationen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an einem Ort, damit es für Sie bequemer ist. </font><font style="vertical-align: inherit;">Wenn Sie keine private Cloud zur Hand haben, aber alle diese Schritte selbst ausführen und die Bereitstellung in der Praxis testen möchten, schreiben Sie uns an cloud@croc.ru. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir geben Ihnen eine Demoversion für Tests und beraten Sie in allen Fragen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und bald wird es einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neuen Slurm geben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in dem Sie Ihren eigenen Cluster erstellen können. </font><font style="vertical-align: inherit;">Der CROC-Gutscheincode bietet 10% Rabatt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für diejenigen, die bereits mit Kubernetes arbeiten, gibt es einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortgeschrittenenkurs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Der Rabatt ist der gleiche. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kollegen, Habraparser bricht das Markup des Codes. </font><font style="vertical-align: inherit;">Bitte nehmen Sie die Quelle von GitHub über den obigen Link.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de492600/index.html">Semi-wissenschaftlicher Leitfaden zum Hosten eines WLAN-Routers</a></li>
<li><a href="../de492604/index.html">Asynchrones Arbeiten mit View mithilfe von Coroutine</a></li>
<li><a href="../de492606/index.html">Toolkit-Probleme in großen Projekten</a></li>
<li><a href="../de492608/index.html">Funktionen Lieferfunktionen in großen Projekten</a></li>
<li><a href="../de492612/index.html">Dekorative Deckenleuchte Lauch Berühmtheit</a></li>
<li><a href="../de492628/index.html">Konfidenzintervall für die Anzahl der Patienten mit Coronavirus (Mortalitätsberechnung)</a></li>
<li><a href="../de492632/index.html">Kleinunternehmen in Quarantäne: Panik ist der Feind der Vernunft</a></li>
<li><a href="../de492636/index.html">Was bedeutet es, effektiv zu sein?</a></li>
<li><a href="../de492638/index.html">Skalieren einer Redux-App mit Enten</a></li>
<li><a href="../de492642/index.html">Erstellen Sie eine skalierbare und ausfallsichere Architektur mit dynamischen Mikrodiensten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>