<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò® üéì ü•ô Postgres: ballonnement, pg_repack et contraintes diff√©r√©es üë©üèº‚Äçüåæ ü§® ü§∑üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'effet des tables et des index de ballonnement (ballonnement) est largement connu et n'est pas seulement pr√©sent dans Postgres. Il existe des moyens ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Postgres: ballonnement, pg_repack et contraintes diff√©r√©es</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/miro/blog/499444/"><img src="https://habrastorage.org/webt/vf/eu/y5/vfeuy53s9e1md_jhdwxbkkmr-8e.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'effet des tables et des index de ballonnement (ballonnement) est largement connu et n'est pas seulement pr√©sent dans Postgres. </font><font style="vertical-align: inherit;">Il existe des moyens de le traiter ¬´pr√™t √† l'emploi¬ª comme VACUUM FULL ou CLUSTER, mais ils verrouillent les tables pendant le fonctionnement et ne peuvent donc pas toujours √™tre utilis√©s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'article contiendra un peu de th√©orie sur la fa√ßon dont le ballonnement se produit, comment y faire face, sur les contraintes diff√©r√©es et les probl√®mes qu'ils posent √† l'utilisation de l'extension pg_repack.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet article est bas√© sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ma pr√©sentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† PgConf.Russia 2020.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/8vaVeCKuz6M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi le ballonnement se produit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postgres est bas√© sur le mod√®le multi-version ( </font></font><abbr title="Contr√¥le d'acc√®s simultan√© multi-versions"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MVCC</font></font></a></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Son essence est que chaque ligne du tableau peut avoir plusieurs versions, tandis que les transactions ne voient pas plus d'une de ces versions, mais pas n√©cessairement la m√™me. Cela permet √† plusieurs transactions de fonctionner simultan√©ment et de n'avoir pratiquement aucun effet les unes sur les autres. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√âvidemment, toutes ces versions doivent √™tre stock√©es. Postgres fonctionne avec la m√©moire page par page et la page est la quantit√© minimale de donn√©es pouvant √™tre lues ou √©crites sur le disque. Regardons un petit exemple pour comprendre comment cela se produit.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que nous ayons une table dans laquelle nous avons ajout√© plusieurs enregistrements. Dans la premi√®re page du fichier o√π la table est stock√©e, de nouvelles donn√©es sont apparues. Ce sont des versions en direct de cha√Ænes qui sont disponibles pour d'autres transactions apr√®s une validation (pour plus de simplicit√©, nous supposerons que le niveau d'isolement de lecture valid√©e). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pb/ep/av/pbepavyhm5_alpqup33j8vfcocm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous avons mis √† jour l'une des entr√©es et marqu√© ainsi l'ancienne version comme non pertinente. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/na/tr/tg/natrtgitck2f7ymtdalnr_coecu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√âtape par √©tape, en mettant √† jour et en supprimant la version des lignes, nous avons obtenu une page dans laquelle environ la moiti√© des donn√©es sont des ¬´ordures¬ª. Ces donn√©es ne sont visibles par aucune transaction. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_j/8d/ji/_j8djifah3idpuohxwseop01xcw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Postgres dispose d'un m√©canisme √† </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIDE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui nettoie les versions non pertinentes et lib√®re de l'espace pour les nouvelles donn√©es. Mais s'il n'est pas configur√© de mani√®re suffisamment agressive ou s'il est occup√© √† travailler dans d'autres tables, alors les ¬´donn√©es ind√©sirables¬ª restent et nous devons utiliser des pages suppl√©mentaires pour les nouvelles donn√©es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, dans notre exemple, √† un moment donn√©, le tableau comprendra quatre pages, mais il ne contiendra que la moiti√© des donn√©es en direct. Par cons√©quent, lors de l'acc√®s √† la table, nous lirons beaucoup plus de donn√©es que n√©cessaire. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nz/ni/rn/nznirnw2kenpvkn7kv7hqwi1k08.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√™me si VACUUM supprime d√©sormais toutes les versions non pertinentes des cha√Ænes, la situation ne s'am√©liorera pas de fa√ßon spectaculaire. Nous aurons de l'espace libre dans les pages ou m√™me des pages enti√®res pour les nouvelles lignes, mais nous continuerons √† lire plus de donn√©es que n√©cessaire.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, si une page compl√®tement vierge (la seconde dans notre exemple) se trouvait √† la fin du fichier, alors VACUUM pourrait la couper. </font><font style="vertical-align: inherit;">Mais maintenant, elle est au milieu, donc rien ne peut √™tre fait avec elle. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fy/ix/rq/fyixrqdxzpivbooplfjoqpeyc-q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque le nombre de ces pages vierges ou tr√®s plates devient important, ce qui est appel√© ballonnement, il commence √† affecter les performances. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout ce qui est d√©crit ci-dessus est la m√©canique de l'occurrence de ballonnement dans les tableaux. </font><font style="vertical-align: inherit;">Dans les index, cela se produit de la m√™me mani√®re.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dois-je un ballonnement?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe plusieurs fa√ßons de d√©terminer si vous avez un ballonnement. L'id√©e de la premi√®re est d'utiliser des statistiques Postgres internes, qui contiennent des informations approximatives sur le nombre de lignes dans les tableaux, le nombre de lignes ¬´live¬ª, etc. Sur Internet, vous pouvez trouver de nombreuses variantes de scripts pr√™ts √† l'emploi. Nous avons pris comme base un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">script</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des experts PostgreSQL, qui peut √©valuer les tables de gonflement ainsi que les index de toast et de btree de ballonnement. D'apr√®s notre exp√©rience, son erreur est de 10-20%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre fa√ßon est d'utiliser l'extension </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pgstattuple</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui vous permet de regarder √† l'int√©rieur des pages et d'obtenir des valeurs de ballonnement estim√©es et pr√©cises. Mais dans le deuxi√®me cas, vous devez scanner la table enti√®re.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une petite valeur de ballonnement, jusqu'√† 20%, nous consid√©rons acceptable. </font><font style="vertical-align: inherit;">Il peut √™tre consid√©r√© comme un analogue de fillfactor pour les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tableaux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">index</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">√Ä 50% et plus, des probl√®mes de performances peuvent commencer.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fa√ßons de faire face au ballonnement</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe plusieurs fa√ßons de traiter les ballonnements hors de la bo√Æte √† Postgres, mais ils sont loin d'√™tre toujours adapt√©s √† tout le monde. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©glez AUTOVACUUM pour √©viter les ballonnements</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Et plus pr√©cis√©ment, pour le maintenir √† un niveau acceptable pour vous. Cela semble √™tre le conseil du ¬´capitaine¬ª, mais en r√©alit√© ce n'est pas toujours facile √† r√©aliser. Par exemple, vous d√©veloppez activement des modifications r√©guli√®res du sch√©ma de donn√©es ou une sorte de migration de donn√©es se produit. Par cons√©quent, votre profil de charge peut changer fr√©quemment et, en r√®gle g√©n√©rale, il peut √™tre diff√©rent pour diff√©rentes tables. Cela signifie que vous devez constamment travailler un peu en avant de la courbe et ajuster AUTOVACUUM au profil changeant de chaque table. Mais il est √©vident que ce n'est pas facile.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre raison courante pour laquelle AUTOVACUUM n'a pas le temps de traiter les tables est la pr√©sence de longues transactions qui l'emp√™chent d'effacer les donn√©es car elles sont disponibles pour ces transactions. La recommandation ici est √©galement √©vidente - se d√©barrasser des transactions suspendues et minimiser le temps des transactions actives. Mais si la charge de votre application est un hybride OLAP et OLTP, vous pouvez en m√™me temps avoir de nombreuses mises √† jour fr√©quentes et de courtes demandes, ainsi que de longues op√©rations - par exemple, la cr√©ation d'un rapport. Dans une telle situation, il convient de penser √† r√©partir la charge sur diff√©rentes bases, ce qui permettra un r√©glage plus fin de chacune d'entre elles.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre exemple - m√™me si le profil est uniforme, mais la base de donn√©es est sous une charge tr√®s √©lev√©e, m√™me l'AUTOVACUUM le plus agressif peut ne pas faire face, et un ballonnement se produira. La mise √† l'√©chelle (verticale ou horizontale) est la seule solution. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais qu'en est-il de la situation lorsque vous avez configur√© AUTOVACUUM, mais le ballonnement continue de cro√Ætre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commande </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VACUUM FULL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reconstruit le contenu des tables et des index et n'y laisse que des donn√©es pertinentes. Pour √©liminer les ballonnements, cela fonctionne parfaitement, mais lors de son ex√©cution, un verrou exclusif sur la table (AccessExclusiveLock) est captur√©, ce qui ne permettra pas les requ√™tes sur cette table, m√™me les s√©lections. Si vous pouvez vous permettre d'arr√™ter votre service ou une partie de celui-ci pendant un certain temps (de plusieurs dizaines de minutes √† plusieurs heures, selon la taille de la base de donn√©es et de votre mat√©riel), cette option est la meilleure. Malheureusement, nous n'avons pas le temps d'ex√©cuter VACUUM FULL pendant la maintenance planifi√©e, donc cette m√©thode ne nous convient pas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commande </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CLUSTER</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il reconstruit √©galement le contenu des tables, comme le fait VACUUM FULL, en m√™me temps il vous permet de sp√©cifier l'index selon lequel les donn√©es seront physiquement ordonn√©es sur le disque (mais √† l'avenir, l'ordre n'est pas garanti). Dans certaines situations, il s'agit d'une bonne optimisation pour un certain nombre de requ√™tes - avec la lecture de plusieurs enregistrements par index. L'inconv√©nient de la commande est le m√™me que celui de VACUUM FULL - elle verrouille la table pendant le fonctionnement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La commande </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">REINDEX est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> similaire aux deux pr√©c√©dentes, mais reconstruit un index sp√©cifique ou tous les index de la table. Les verrous sont l√©g√®rement plus faibles: ShareLock sur la table (emp√™che les modifications, mais vous permet de s√©lectionner) et AccessExclusiveLock sur l'index reconstructible (bloque les requ√™tes utilisant cet index). Cependant, dans la version 12 de Postgres, le param√®tre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CONCURRENTLY</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui vous permet de reconstruire l'index sans bloquer l'ajout, la modification ou la suppression parall√®les d'enregistrements. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les versions ant√©rieures de Postgres, vous pouvez obtenir un r√©sultat similaire √† REINDEX CONCURRENTLY avec </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CREATE INDEX CONCURRENTLY</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il vous permet de cr√©er un index sans blocage strict (ShareUpdateExclusiveLock, qui n'interf√®re pas avec les requ√™tes parall√®les), puis de remplacer l'ancien index par un nouveau et de supprimer l'ancien index. Cela √©limine les index de ballonnement sans interf√©rer avec votre application. Il est important de consid√©rer que lors de la reconstruction des index, il y aura une charge suppl√©mentaire sur le sous-syst√®me de disque. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, s'il existe des moyens pour les index d'√©liminer le gonflement ¬´√† chaud¬ª, alors pour les tables il n'y en a pas. Ici, diverses extensions externes entrent en </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">jeu</font></a><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pg_repack</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(anciennement pg_reorg), </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pgcompact</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pgcompacttable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et autres. </font><font style="vertical-align: inherit;">Dans le cadre de cet article, je ne les comparerai pas et ne parlerai que de pg_repack, que, apr√®s quelques raffinements, nous utilisons chez nous.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonctionnement de pg_repack</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/5j/bp/ng/5jbpng5ietzdlekjqc32gdf_5cs.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que nous ayons une table tr√®s normale pour nous - avec des index, des restrictions et, malheureusement, avec des ballonnements. La premi√®re √©tape est que pg_repack cr√©e une table de journal pour stocker les donn√©es sur toutes les modifications pendant le fonctionnement. Le d√©clencheur r√©pliquera ces modifications √† chaque insertion, mise √† jour et suppression. Ensuite, une table est cr√©√©e qui est similaire √† la structure d'origine, mais sans index et restrictions, afin de ne pas ralentir le processus d'insertion des donn√©es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, pg_repack transf√®re les donn√©es de l'ancienne √† la nouvelle table, filtrant automatiquement toutes les lignes non pertinentes, puis cr√©e des index pour la nouvelle table. Pendant l'ex√©cution de toutes ces op√©rations, les modifications sont accumul√©es dans la table des journaux.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'√©tape suivante consiste √† transf√©rer les modifications dans la nouvelle table. </font><font style="vertical-align: inherit;">La migration est effectu√©e en plusieurs it√©rations, et lorsqu'il reste moins de 20 entr√©es dans la table des journaux, pg_repack capture un verrou strict, transf√®re les derni√®res donn√©es et remplace l'ancienne table par la nouvelle dans les tables syst√®me Postgres. </font><font style="vertical-align: inherit;">Il s'agit du seul et tr√®s court moment o√π vous ne pouvez pas travailler avec la table. </font><font style="vertical-align: inherit;">Apr√®s cela, l'ancienne table et la table avec les journaux sont supprim√©es et l'espace est lib√©r√© dans le syst√®me de fichiers. </font><font style="vertical-align: inherit;">Le processus est termin√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En th√©orie, tout a l'air bien, qu'en pratique? </font><font style="vertical-align: inherit;">Nous avons test√© pg_repack sans charge et sous charge, nous avons v√©rifi√© son fonctionnement en cas d'arr√™t pr√©matur√© (en d'autres termes, Ctrl + C). </font><font style="vertical-align: inherit;">Tous les tests √©taient positifs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous sommes all√©s au prod - et puis tout s'est mal pass√© comme pr√©vu.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La premi√®re cr√™pe sur prod</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur le premier cluster, nous avons re√ßu une erreur concernant la violation d'une restriction unique:</font></font><br>
<br>
<pre><code class="bash hljs">$ ./pg_repack -t tablename -o id<font></font>
INFO: repacking table <span class="hljs-string">"tablename"</span><font></font>
ERROR: query failed: <font></font>
    ERROR: duplicate key value violates unique constraint <span class="hljs-string">"index_16508"</span><font></font>
DETAIL:  Key (id, index)=(100500, 42) already exists.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette restriction avait le nom g√©n√©r√© automatiquement index_16508 - il a √©t√© cr√©√© par pg_repack. </font><font style="vertical-align: inherit;">Par les attributs inclus dans sa composition, nous avons d√©termin√© ¬´notre¬ª restriction, qui lui correspond. </font><font style="vertical-align: inherit;">Le probl√®me s'est av√©r√© que ce n'est pas une restriction tout √† fait ordinaire, mais une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contrainte diff√©r√©e</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , c'est-√†-dire </font><font style="vertical-align: inherit;">sa v√©rification est effectu√©e plus tard que la commande sql, ce qui entra√Æne des cons√©quences inattendues.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contraintes diff√©r√©es: pourquoi sont-elles n√©cessaires et comment fonctionnent-elles?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un peu de th√©orie sur les contraintes diff√©r√©es. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenons un exemple simple: nous avons une table de r√©f√©rence de voiture avec deux attributs - le nom et l'ordre de la voiture dans le r√©pertoire.</font></font><br>
<img src="https://habrastorage.org/webt/n8/1s/td/n81stdw9kie5wll03ylnel18aie.png" align="right"><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> cars<font></font>
(<font></font>
  <span class="hljs-type">name</span> <span class="hljs-type">text</span> <span class="hljs-keyword">constraint</span> pk_cars <span class="hljs-keyword">primary key</span>,<font></font>
  ord <span class="hljs-type">integer</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">constraint</span> uk_cars <span class="hljs-keyword">unique</span><font></font>
);<font></font>
</code></pre><br>
<br clear="all"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Disons que nous devions √©changer les premi√®re et deuxi√®me voitures. </font><font style="vertical-align: inherit;">La solution "au front" est de mettre √† jour la premi√®re valeur √† la seconde, et la seconde √† la premi√®re:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">begin</span>;
  <span class="hljs-keyword">update</span> cars <span class="hljs-keyword">set</span> ord = <span class="hljs-number">2</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">'audi'</span>;
  <span class="hljs-keyword">update</span> cars <span class="hljs-keyword">set</span> ord = <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> = <span class="hljs-string">'bmw'</span>;
<span class="hljs-keyword">commit</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais lors de l'ex√©cution de ce code, nous attendons probablement une violation de la contrainte, car l'ordre des valeurs dans la table est unique:</font></font><br>
<br>
<pre><code class="bash hljs">[23305] ERROR: duplicate key value violates unique constraint ‚Äúuk_cars‚Äù<font></font>
Detail: Key (ord)=(2) already exists.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment faire autrement? Premi√®re option: ajoutez un remplacement suppl√©mentaire de la valeur par une commande dont il est garanti qu'elle n'existe pas dans le tableau, par exemple, ¬´-1¬ª. En programmation, cela s'appelle ¬´√©changer les valeurs de deux variables √† travers la troisi√®me¬ª. Le seul inconv√©nient de cette m√©thode est la mise √† jour suppl√©mentaire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deuxi√®me option: reconcevoir la table pour utiliser un type de donn√©es √† virgule flottante pour la valeur de commande au lieu d'entiers Ensuite, lors de la mise √† jour de la valeur de 1, par exemple, √† 2,5, le premier enregistrement ¬´se l√®vera¬ª automatiquement entre le deuxi√®me et le troisi√®me. Cette solution fonctionne, mais il existe deux limitations. Premi√®rement, cela ne fonctionnera pas pour vous si la valeur est utilis√©e quelque part dans l'interface. Deuxi√®mement, selon la pr√©cision du type de donn√©es, vous aurez un nombre limit√© d'insertions possibles avant de recalculer les valeurs de tous les enregistrements.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Troisi√®me option: reporter la restriction afin qu'elle ne soit v√©rifi√©e qu'au moment de la validation:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> cars<font></font>
(<font></font>
  <span class="hljs-type">name</span> <span class="hljs-type">text</span> <span class="hljs-keyword">constraint</span> pk_cars <span class="hljs-keyword">primary key</span>,<font></font>
  ord <span class="hljs-type">integer</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">constraint</span> uk_cars <span class="hljs-keyword">unique</span> <span class="hljs-keyword">deferrable</span> <span class="hljs-keyword">initially</span> <span class="hljs-keyword">deferred</span>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√âtant donn√© que la logique de notre demande initiale garantit que toutes les valeurs sont uniques au moment de la validation, elle r√©ussira. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'exemple ci-dessus est, bien s√ªr, tr√®s synth√©tique, mais il r√©v√®le l'id√©e. </font><font style="vertical-align: inherit;">Dans notre application, nous utilisons des contraintes diff√©r√©es pour impl√©menter une logique responsable de la r√©solution des conflits tout en travaillant simultan√©ment avec des objets widgets communs sur la carte. </font><font style="vertical-align: inherit;">L'utilisation de telles restrictions nous permet de rendre le code d'application un peu plus facile. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En g√©n√©ral, selon le type de contrainte dans Postgres, il existe trois niveaux de granularit√© pour les v√©rifier: niveau de ligne, transaction et expression. </font></font><br>
<img src="https://habrastorage.org/webt/vn/bw/qq/vnbwqqmhgjpnd7kb8dtxpixb8xi.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Source: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">begriffs</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CHECK et NOT NULL sont toujours v√©rifi√©s au niveau de la ligne, pour d'autres restrictions, comme le montre le tableau, il existe diff√©rentes options. </font><font style="vertical-align: inherit;">En savoir plus </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour r√©sumer bri√®vement, les restrictions en attente dans certaines situations donnent un code plus lisible et moins de commandes. </font><font style="vertical-align: inherit;">Cependant, vous devez payer pour cela en compliquant le processus de d√©bogage, car le moment o√π l'erreur s'est produite et le moment o√π vous l'avez d√©couvert sont s√©par√©s dans le temps. </font><font style="vertical-align: inherit;">Un autre probl√®me possible est que le planificateur ne peut pas toujours construire le plan optimal si une contrainte retard√©e est impliqu√©e dans la demande.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raffinement pg_repack</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons compris quelles sont les restrictions en attente, mais comment sont-elles li√©es √† notre probl√®me? </font><font style="vertical-align: inherit;">Rappelez-vous l'erreur que nous avons pr√©c√©demment re√ßue:</font></font><br>
<br>
<pre><code class="bash hljs">$ ./pg_repack -t tablename -o id<font></font>
INFO: repacking table <span class="hljs-string">"tablename"</span><font></font>
ERROR: query failed: <font></font>
    ERROR: duplicate key value violates unique constraint <span class="hljs-string">"index_16508"</span>
DETAIL:  Key (id, index)=(100500, 42) already exists.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il se produit au moment de la copie des donn√©es de la table des journaux vers la nouvelle table. √áa a l'air bizarre parce que les donn√©es de la table de journal sont valid√©es avec les donn√©es de la table d'origine. S'ils satisfont aux contraintes de la table d'origine, comment peuvent-ils violer les m√™mes contraintes dans la nouvelle? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'est av√©r√© que la racine du probl√®me r√©side dans l'√©tape pr√©c√©dente de pg_repack, qui ne cr√©e que des index, mais pas de restrictions: l'ancienne table avait une contrainte unique et la nouvelle cr√©ait un index unique √† la place.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_y/da/fc/_ydafcxizllawi1jo3o5ai-x-kg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est important de noter ici que si la restriction est normale et non diff√©r√©e, alors l'index unique cr√©√© √† sa place est √©quivalent √† cette restriction, car </font><font style="vertical-align: inherit;">Les contraintes uniques Postgres sont impl√©ment√©es en cr√©ant un index unique. </font><font style="vertical-align: inherit;">Mais dans le cas d'une contrainte diff√©r√©e, le comportement n'est pas le m√™me, car l'index ne peut pas √™tre diff√©r√© et est toujours v√©rifi√© au moment de l'ex√©cution de la commande sql. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, l'essence du probl√®me r√©side dans le ¬´report¬ª de la v√©rification: dans la table d'origine, il se produit au moment de la validation, et dans la nouvelle - au moment de l'ex√©cution de la commande sql. </font><font style="vertical-align: inherit;">Nous devons donc nous assurer que les contr√¥les sont effectu√©s de la m√™me mani√®re dans les deux cas: soit toujours diff√©r√©s, soit toujours imm√©diatement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors, quelles id√©es avions-nous?</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©er un index similaire √† diff√©r√©</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La premi√®re id√©e est d'effectuer les deux contr√¥les en mode imm√©diat. Cela peut donner lieu √† plusieurs faux d√©clencheurs positifs de la restriction, mais s'il y en a peu, cela ne devrait pas affecter le travail des utilisateurs, car pour eux, de tels conflits sont une situation normale. Ils se produisent, par exemple, lorsque deux utilisateurs commencent √† modifier simultan√©ment le m√™me widget et que le client du deuxi√®me utilisateur n'a pas le temps d'obtenir des informations indiquant que le widget est d√©j√† verrouill√© pour modification par le premier utilisateur. Dans cette situation, le serveur refuse le deuxi√®me utilisateur et son client annule les modifications et bloque le widget. Un peu plus tard, lorsque le premier utilisateur a termin√© la modification, le second recevra des informations indiquant que le widget n'est plus verrouill√© et pourra r√©p√©ter son action.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/dw/oq/jw/dwoqjwhuqva3veavihajfcd5t4c.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour garantir que les v√©rifications sont toujours en mode d'urgence, nous avons cr√©√© un nouvel index similaire √† la contrainte diff√©r√©e d'origine:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">CONCURRENTLY</span> uk_tablename__immediate <span class="hljs-keyword">ON</span> tablename (id, <span class="hljs-keyword">index</span>);
<span class="hljs-comment">-- run pg_repack</span>
<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">CONCURRENTLY</span> uk_tablename__immediate;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur l'environnement de test, nous n'avons re√ßu que quelques erreurs attendues. Succ√®s! Nous avons de nouveau lanc√© pg_repack sur le prod et obtenu 5 erreurs sur le premier cluster en une heure de travail. C'est un r√©sultat acceptable. Cependant, d√©j√† sur le deuxi√®me cluster, le nombre d'erreurs a augment√© plusieurs fois et nous avons d√ª arr√™ter pg_repack. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi est-ce arriv√©? La probabilit√© d'une erreur d√©pend du nombre d'utilisateurs travaillant simultan√©ment avec les m√™mes widgets. Apparemment, √† ce moment-l√†, avec les donn√©es stock√©es sur le premier cluster, il y avait beaucoup moins de changements de concurrence que sur les autres, c'est-√†-dire nous √©tions juste ¬´chanceux¬ª. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'id√©e n'a pas fonctionn√©. √Ä ce moment, nous avons vu deux autres options de solution: r√©√©crire notre code d'application pour abandonner les restrictions en attente, ou ¬´apprendre¬ª √† pg_repack √† travailler avec elles. Nous avons choisi le second.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remplacer les index dans une nouvelle table par des contraintes diff√©r√©es de la table source</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le but de la r√©vision √©tait √©vident - si la table d'origine a une contrainte diff√©r√©e, alors pour la nouvelle, vous devez cr√©er une telle contrainte, pas un index. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour tester nos modifications, nous avons √©crit un test simple:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">table avec restriction diff√©r√©e et un enregistrement;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ins√©rer des donn√©es dans la boucle qui entrent en conflit avec l'enregistrement existant;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faire une mise √† jour - les donn√©es ne sont plus en conflit;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">engager le changement.</font></font></li>
</ul><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test_table<font></font>
(<font></font>
  id <span class="hljs-type">serial</span>,<font></font>
  val <span class="hljs-type">int</span>,
  <span class="hljs-keyword">constraint</span> uk_test_table__val <span class="hljs-keyword">unique</span> (val) <span class="hljs-keyword">deferrable</span> <span class="hljs-keyword">initially</span> <span class="hljs-keyword">deferred</span> <font></font>
);<font></font>
</code></pre><br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test_table (val) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">0</span>);
<span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">1.</span><span class="hljs-number">.10000</span> <span class="hljs-keyword">LOOP</span>
  <span class="hljs-keyword">BEGIN</span>
    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test_table <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">0</span>) <span class="hljs-keyword">RETURNING</span> id <span class="hljs-keyword">INTO</span> v_id;
    <span class="hljs-keyword">UPDATE</span> test_table <span class="hljs-keyword">set</span> val = i <span class="hljs-keyword">where</span> id = v_id;
    <span class="hljs-keyword">COMMIT</span>;
  <span class="hljs-keyword">END</span>;
<span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La version originale de pg_repack s'est toujours √©cras√©e lors de la premi√®re insertion, la version r√©vis√©e a fonctionn√© sans erreur. </font><font style="vertical-align: inherit;">Bien. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons au prod et encore une fois nous obtenons une erreur dans la m√™me phase de copie des donn√©es de la table de log dans la nouvelle:</font></font><br>
<br>
<pre><code class="bash hljs">$ ./pg_repack -t tablename -o id<font></font>
INFO: repacking table <span class="hljs-string">"tablename"</span><font></font>
ERROR: query failed: <font></font>
    ERROR: duplicate key value violates unique constraint <span class="hljs-string">"index_16508"</span>
DETAIL:  Key (id, index)=(100500, 42) already exists.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Situation classique: tout fonctionne sur des environnements de test, mais pas sur prod?!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APPLY_COUNT et la jonction de deux lots</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons commenc√© √† analyser le code litt√©ralement ligne par ligne et avons trouv√© un point important: les donn√©es sont transf√©r√©es de la table journal vers la nouvelle avec des lots, la constante APPLY_COUNT indiquait la taille des lots:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">for</span> (;;)<font></font>
{<font></font>
num = apply_log(connection, table, APPLY_COUNT);<font></font>
<font></font>
<span class="hljs-keyword">if</span> (num &gt; MIN_TUPLES_BEFORE_SWITCH)
     <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">/* there might be still some tuples, repeat. */</span><font></font>
...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le probl√®me est que les donn√©es de la transaction d'origine, dans lesquelles plusieurs op√©rations peuvent potentiellement violer la restriction, peuvent √™tre transf√©r√©es √† la jonction de deux lots pendant le transfert - la moiti√© des √©quipes seront engag√©es dans le premier match et l'autre dans le second. Et voici notre chance: si les √©quipes du premier lot ne violent rien, alors tout va bien, mais si elles violent - une erreur se produit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
APPLY_COUNT est √©gal √† 1000 entr√©es, ce qui explique pourquoi nos tests ont r√©ussi - ils ne couvraient pas le cas de ¬´jonction de lots¬ª. Nous avons utilis√© deux commandes - ins√©rer et mettre √† jour, donc exactement 500 transactions de deux √©quipes ont toujours √©t√© plac√©es dans le lot et nous n'avons rencontr√© aucun probl√®me. Apr√®s avoir ajout√© la deuxi√®me mise √† jour, notre modification a cess√© de fonctionner:</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">FOR</span> i <span class="hljs-keyword">IN</span> <span class="hljs-number">1.</span><span class="hljs-number">.10000</span> <span class="hljs-keyword">LOOP</span>
  <span class="hljs-keyword">BEGIN</span>
    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test_table <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>) <span class="hljs-keyword">RETURNING</span> id <span class="hljs-keyword">INTO</span> v_id;
    <span class="hljs-keyword">UPDATE</span> test_table <span class="hljs-keyword">set</span> val = i <span class="hljs-keyword">where</span> id = v_id;
    <span class="hljs-keyword">UPDATE</span> test_table <span class="hljs-keyword">set</span> val = i <span class="hljs-keyword">where</span> id = v_id; <span class="hljs-comment">-- one more update</span>
    <span class="hljs-keyword">COMMIT</span>;
  <span class="hljs-keyword">END</span>;
<span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, la t√¢che suivante consiste √† s'assurer que les donn√©es de la table source qui ont chang√© dans une transaction tombent dans la nouvelle table √©galement dans la m√™me transaction.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refus de boucher</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et encore une fois, nous avions deux solutions. </font><font style="vertical-align: inherit;">Tout d'abord: abandonnons compl√®tement le traitement par lots et effectuons le transfert de donn√©es en une seule transaction. </font><font style="vertical-align: inherit;">En faveur de cette solution √©tait sa simplicit√© - les changements de code requis √©taient minimes (au fait, dans les anciennes versions alors pg_reorg fonctionnait exactement de cette fa√ßon). </font><font style="vertical-align: inherit;">Mais il y a un probl√®me - nous cr√©ons une transaction longue, et cela, comme cela a √©t√© dit plus haut, constitue une menace pour l'√©mergence d'un nouveau ballonnement.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La deuxi√®me solution est plus compliqu√©e, mais probablement plus correcte: cr√©ez une colonne dans la table des journaux avec l'identifiant de la transaction qui a ajout√© les donn√©es √† la table. Ensuite, lors de la copie des donn√©es, nous pourrons les regrouper par cet attribut et nous assurer que les modifications associ√©es seront transf√©r√©es ensemble. Un lot sera form√© de plusieurs transactions (ou d'une grande) et sa taille variera en fonction de la quantit√© de donn√©es modifi√©es dans ces transactions. Il est important de noter que puisque les donn√©es des diff√©rentes transactions tombent dans la table des journaux dans un ordre al√©atoire, il ne sera pas possible de les lire s√©quentiellement, comme c'√©tait le cas auparavant. seqscan pour chaque demande filtr√©e par tx_id est trop cher, vous avez besoin d'un index, mais cela ralentira la m√©thode en raison de la surcharge de sa mise √† jour. En g√©n√©ral, comme toujours, vous devez sacrifier quelque chose.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons donc d√©cid√© de commencer par la premi√®re option, plus simple. Premi√®rement, il fallait comprendre si une transaction longue serait un vrai probl√®me. √âtant donn√© que le principal transfert de donn√©es de l'ancienne table vers la nouvelle se produit √©galement dans une longue transaction, la question s'est transform√©e en ¬´combien allons-nous augmenter cette transaction?¬ª La dur√©e de la premi√®re transaction d√©pend principalement de la taille de la table. La dur√©e du nouveau d√©pend du nombre de modifications accumul√©es dans la table pendant le transfert de donn√©es, c'est-√†-dire de l'intensit√© de la charge. L'ex√©cution de pg_repack s'est produite pendant la charge minimale sur le service et la quantit√© de changement √©tait incomparablement petite par rapport √† la taille de table d'origine. Nous avons d√©cid√© de ne pas tenir compte de l'heure de la nouvelle transaction (√† titre de comparaison, c'est en moyenne 1 heure et 2-3 minutes).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les exp√©riences ont √©t√© positives. Fonctionnant √©galement sur prod. Pour plus de clart√©, une image de la taille de l'une des bases apr√®s l'ex√©cution: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z4/ps/gu/z4psgu_s8jsbhwnxst2pogfcsfa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisque cette solution nous convenait parfaitement, nous n'avons pas essay√© d'impl√©menter la seconde, mais nous envisageons d'en discuter avec les d√©veloppeurs d'extensions. Malheureusement, notre r√©vision actuelle n'est pas encore pr√™te √† √™tre publi√©e, car nous n'avons r√©solu le probl√®me qu'avec des restrictions uniques en attente, et pour un correctif complet, il est n√©cessaire de prendre en charge d'autres types. Nous esp√©rons pouvoir le faire √† l'avenir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peut-√™tre avez-vous une question, pourquoi nous sommes-nous impliqu√©s dans cette histoire avec l'ach√®vement de pg_repack, et n'avons-nous pas, par exemple, utilis√© ses analogues? </font><font style="vertical-align: inherit;">√Ä un moment donn√©, nous y avons √©galement pens√©, mais l'exp√©rience positive de l'utiliser plus t√¥t, sur des tables sans restrictions en attente, nous a motiv√©s √† essayer de comprendre l'essence du probl√®me et de le r√©soudre. </font><font style="vertical-align: inherit;">De plus, pour utiliser d'autres solutions, il faut √©galement du temps pour effectuer des tests, nous avons donc d√©cid√© que nous essaierions d'abord de r√©soudre le probl√®me, et si nous r√©alisions que nous ne pouvions pas le faire dans un d√©lai raisonnable, nous commencerions alors √† envisager des analogues.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©sultats</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce que nous pouvons recommander sur la base de notre propre exp√©rience:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surveillez votre ballonnement. </font><font style="vertical-align: inherit;">Sur la base des donn√©es de surveillance, vous pouvez comprendre dans quelle mesure l'autovacuum est configur√©.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©glez AUTOVACUUM pour maintenir le ballonnement √† un niveau raisonnable.</font></font></li>
<li>   bloat           ‚Äú ‚Äù,     .  ‚Äì   .</li>
<li>        ‚Äì        ,     .</li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr499434/index.html">Comment mettre en ≈ìuvre la gestion des connaissances: b√©n√©ficiez de ¬´poches¬ª, de ¬´fines perroquets¬ª et de la r√©flexion sur les clips</a></li>
<li><a href="../fr499436/index.html">Une enzyme t√©l√©command√©e acc√©l√©rera le traitement des accidents vasculaires c√©r√©braux et des blessures √† la colonne vert√©brale</a></li>
<li><a href="../fr499438/index.html">Stream pour les testeurs et pas seulement</a></li>
<li><a href="../fr499440/index.html">Alors que nous √©crivions le pilote automatique le plus cool du monde pour une locomotive de man≈ìuvre</a></li>
<li><a href="../fr499442/index.html">Cr√©ation d'un jeu de course pseudo-3D: mise en ≈ìuvre des collines et finition du jeu</a></li>
<li><a href="../fr499446/index.html">Test des chargeurs de d√©marrage au format STEP pour VR</a></li>
<li><a href="../fr499448/index.html">Impl√©mentation d'une architecture SOLIDE et en couches dans Node.js avec TypeScript et InversifyJS</a></li>
<li><a href="../fr499450/index.html">Choisir l'√©quipement pour un jeu persan utilisant la g√©n√©tique / √©volution en Python</a></li>
<li><a href="../fr499452/index.html">La vie quotidienne d'un ophtalmologiste √† la clinique: quand les m√©decins ne suffisent pas</a></li>
<li><a href="../fr499454/index.html">Vid√©o en direct! Meetup Badoo Localization 21 avril</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>