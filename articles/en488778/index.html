<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíü ‚è±Ô∏è üö± Data structures: a list that can do everything * üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø ü¶Ä üïã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* By everything, I mean the relatively quick execution of operations on a single element of an array. 
 
 The data structures that implement the list ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Data structures: a list that can do everything *</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488778/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* By everything, I mean the relatively quick execution of operations on a single element of an array. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The data structures that implement the list are complete. </font><font style="vertical-align: inherit;">Everyone has their own advantages and disadvantages. </font><font style="vertical-align: inherit;">For example, in the Java world - depending on the necessary operations - you can use:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add (obj), get (obj), set (index, obj): a basic set of almost all lists, e.g. ArrayList. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add (index, obj): tree-like structures, e.g. TreeList from apache common-collections. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remove (index): same as above. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains (obj), indexOf (obj): you can use a bunch of ArrayList and HashMap. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remove (obj): ... I find it difficult to answer. </font><font style="vertical-align: inherit;">In some cases, you can get by with a LinkedHashSet. </font><font style="vertical-align: inherit;">It is solved trivially in the presence of the previous two points, but which structures can both quickly?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When I needed a structure with quick add (obj), get (index), remove (index) and indexOf (obj), google did not give an answer. I did not find any code examples or descriptions of such structures. Maybe I was not looking there, I had to invent it myself. But if someone drops the link in the comments, I will greatly appreciate it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhaps someone realized that you can take a TreeList, which can quickly insert / remove items in the middle of the list and add a HashMap from the object to the index in the TreeList for quick execution of indexOf (obj). And it will be a simple, elegant, but incorrect decision. After all, when adding to the middle or removing from the middle, it will be necessary to recalculate the indices, on average, for half the elements. This will degrade performance to O (n).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next I will talk about a data structure that can do all of the above. Which performs any operation on one element in O (log (n)) time. Well, almost - for the logarithm is performed in the case when all the objects in the list are different. If the list contains the same objects, then it is possible to sag performance up to O (log (n) ^ 2).</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will warn you right away that I will not paint the code here. </font><font style="vertical-align: inherit;">It can be quite complicated for the article. </font><font style="vertical-align: inherit;">But it is, written in Java. </font><font style="vertical-align: inherit;">Based on the TreeList class from apache common-collections. </font><font style="vertical-align: inherit;">Pull request already exists, but at the time of writing, the article is not yet poured. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also, I will not describe well-known algorithms. </font><font style="vertical-align: inherit;">For example, tree balancing algorithms. </font><font style="vertical-align: inherit;">For most, it may be sufficient to take for granted the fact that the tree can be kept balanced. </font><font style="vertical-align: inherit;">This does not affect the understanding of the general idea. </font><font style="vertical-align: inherit;">Those who want to know more can easily find information. </font><font style="vertical-align: inherit;">But I will tell you very briefly about some basic things, because without the knowledge of the basics, many key elements cannot be understood. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Links will be at the end.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why is it necessary</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, it‚Äôs not so easy to come up with situations where everything is needed directly from the list. </font><font style="vertical-align: inherit;">It is unlikely that this is some kind of super necessary structure, otherwise everyone would know about it. </font><font style="vertical-align: inherit;">However, a few examples where such a list could be useful can be given. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I recognize that many of the examples are far-fetched. </font><font style="vertical-align: inherit;">All or almost everything can be solved in another way.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caching and compression</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My initial task, because of which I began to research the issue. </font><font style="vertical-align: inherit;">Played with compression of specific data and needed a list for the object cache. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The idea is this: when processing another object, we look for it in the list. </font><font style="vertical-align: inherit;">If not found, save the object and add it to the top of the list. </font><font style="vertical-align: inherit;">If found, then we take its index in the list and instead of the object we save only its index, after which we move the object to the top of the list. </font><font style="vertical-align: inherit;">Thus, objects that occur will often receive small indexes, and objects that occur only once will eventually move to the end of the list and be deleted.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turn</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If instead of the usual FIFO queue, for some tasks, a similar structure is used, then the following operations can be done:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Answer the question: how many tasks are in the queue before this task. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remove tasks from the queue. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It‚Äôs like in a supermarket. </font><font style="vertical-align: inherit;">If you came for a chocolate bar, but you see that the line is moving slowly, then maybe the chocolate bar is not so much needed? </font><font style="vertical-align: inherit;">:)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">High score table</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose we want to store the time during which players complete a level in a game. </font><font style="vertical-align: inherit;">There are many players and they all compete, trying to show the minimum time. </font><font style="vertical-align: inherit;">Player data can be put into an array and sorted by time. </font><font style="vertical-align: inherit;">Using this structure, you can:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Move players higher in the list if they show better results than before. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remove players from the list, for example, in the case of a ban for cheating. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Show each player where he is. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Show the table of records page by page. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Show a sparse table in places, for example, time 1, 2, 3, 5, 10, 20, 50, 100, 1000, 10000 places. </font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data structure</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The structure is based on a tree with an implicit key. </font><font style="vertical-align: inherit;">It is on this approach, for example, that TreeList in apache common-collections is based. </font><font style="vertical-align: inherit;">In order to move on, you need to understand how this structure works.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implicit Key Tree</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A tree consists of nodes (Nodes). </font><font style="vertical-align: inherit;">Each node contains a link to an object that is stored in the node and 2 links to other nodes: left and right. </font><font style="vertical-align: inherit;">The topmost node is called the root node. </font><font style="vertical-align: inherit;">In the simplest case, the node looks something like this:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  obj: T<font></font>
  left: Node&lt;T&gt;<font></font>
  right: Node&lt;T&gt;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the classical binary tree for each node in the left subtree, all objects are smaller than in the current node, and in the right - large. </font><font style="vertical-align: inherit;">For instance:</font></font><br>
<br>
<pre><code class="plaintext hljs">                             [ element: 25 ]<font></font>
                           /                 \<font></font>
                          /                   \<font></font>
          [ element: 14 ]                       [ element: 45 ]<font></font>
           /          \                           /          \<font></font>
          /            \                         /            \<font></font>
[ element: 10 ]    [ element: 22 ]     [ element: 27 ]    [ element: 90 ]<font></font>
                    /          \                            /<font></font>
                   /            \                          /<font></font>
            [ element: 17 ] [ element: 23 ]         [ element: 80 ] </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But for our purpose, such a tree is not suitable. We do not need to store objects sorted, but we need to have access to them by index, as in an array. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How can I put an array in a tree? Let's select an element with index i from the middle of the array. Place the ith element from the array in the root node. 2 subtrees exit the root node. In the left subtree we put half the array with index &lt;i, and in the right one with index&gt; i. How to do it? In the same way: we select an element from the middle in a subarray, put this element in a node, we get 2 more smaller subarrays. And so until we put all the elements of the array in the nodes of the tree. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, an array with the elements [‚Äúq‚Äù, ‚Äúw‚Äù, ‚Äúe‚Äù, ‚Äúr‚Äù, ‚Äút‚Äù, ‚Äúy‚Äù, ‚Äúu‚Äù] might look like this:</font></font><br>
<br>
<pre><code class="plaintext hljs">                            [el: r,  size: 7]<font></font>
                           /        :        \<font></font>
                          /         :         \<font></font>
         [el: w, size: 3]           :           [el: y, size: 3]<font></font>
           /     :    \             :             /    :     \<font></font>
          /      :     \            :            /     :      \<font></font>
[el: q, size: 1] : [el: e, size: 1] : [el: t, size: 1] : [el: u, size: 1]<font></font>
        :        :         :        :         :        :         :<font></font>
        :        :         :        :         :        :         :<font></font>
       [q]      [w]       [e]      [r]       [t]      [y]       [u]<font></font>
<font></font>
Index:  0        1         2        3         4        5         6</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The middle element in the ‚Äúr‚Äù array, we put it in the root node. Two subarrays [‚Äúq‚Äù, ‚Äúw‚Äù, ‚Äúe‚Äù] and [‚Äút‚Äù, ‚Äúy‚Äù, ‚Äúu‚Äù] are placed in the left and right subtrees. For this, the central elements are selected from the subarrays, in our case these are ‚Äúw‚Äù and ‚Äúy‚Äù, and they fall into the nodes of the next level. And so on. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our case, the tree is balanced, the depth of all subtrees is the same. But this does not have to be so. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the picture above, each node, in addition to the element and links to the left and right nodes, contains the number of elements of the entire subtree. This information must be updated correctly when the tree changes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's see how to find, for example, an element with index = 4 in such a tree.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We start the crawl from the root node (root, in our case with the ‚Äúr‚Äù element). We have 3 options: we are already on the right node, the right node on the left, the right node on the right. In order to understand where to look for the desired element, you need to compare the size of the left subtree (in our case left.size = 3) and the current index (in our case 4). If these 2 numbers are equal, then we found the necessary node and the desired element in it. If the size of the left subtree is larger, then the required node in the left subtree. If it‚Äôs less, then you need to look in the right subtree, but you need to reduce the desired index: index = index - left.size - 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since in our case left.size &lt;index, we are looking in the right subtree for the element with the new index 4 - 3 - 1 = 0. Move to the node with the element ‚Äúy‚Äù.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then we do the same thing that we did in the root node. Compare left.size and index. Since 1&gt; 0, we look in the left subtree, move to the node with the element ‚Äút‚Äù. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is no left subtree in this node, and its size is 0. index = left.size, which means we found a node with index 4 and can get the required element ‚Äút‚Äù from it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In pseudo code, it looks something like this:</font></font><br>
<br>
<pre><code class="kotlin hljs">function <span class="hljs-keyword">get</span>(node: Node&lt;T&gt;, index: int): T {
  <span class="hljs-keyword">val</span> leftSize: int = (node.left == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : node.left.size;
  <span class="hljs-keyword">if</span> (leftSize == index) {
    <span class="hljs-keyword">return</span> node.obj;<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leftSize &gt; index) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(node.left, index);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(node.right, index ‚Äî leftSize ‚Äî <span class="hljs-number">1</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I tried to describe the key principle of how to put an array in a tree. </font><font style="vertical-align: inherit;">Such a structure works, of course, slower than the classical array, for O (log (n)) versus O (1). </font><font style="vertical-align: inherit;">But it has an important advantage: adding an element to the middle or removing from the middle also works for O (log (n)) versus O (n) for the array. </font><font style="vertical-align: inherit;">Of course, provided that the tree is more or less balanced. </font><font style="vertical-align: inherit;">There are many algorithms for maintaining a tree in an almost balanced way. </font><font style="vertical-align: inherit;">For example, red-black tree, AVL tree, Cartesian tree. </font><font style="vertical-align: inherit;">I will not write down the details of balancing the tree, any algorithm is suitable for us. </font><font style="vertical-align: inherit;">Let's just assume that the tree is balanced on average and its maximum depth is not much different from the minimum.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slight optimization</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The approach described above, with checking the size of the tree on the left is convenient for perception, but can be done a little more efficiently. In order not to look into the left subtree each time, instead of the size of the tree, one can store in the node its position relative to the position of its parent node. The root node stores an absolute position that matches the size of the left subtree.</font></font><br>
<br>
<pre><code class="plaintext hljs">                             [el: r, pos: 3]<font></font>
                           /        :        \<font></font>
                          /         :         \<font></font>
         [el: w, pos: -2]           :           [el: y, pos: +2]<font></font>
           /     :    \             :             /    :     \<font></font>
          /      :     \            :            /     :      \<font></font>
[el: q, pos: -1] : [el: e, pos: +1] : [el: t, pos: -1] : [el: u, pos: +1]<font></font>
        :        :         :        :         :        :         :<font></font>
        :        :         :        :         :        :         :<font></font>
       [q]      [w]       [e]      [r]       [t]      [y]       [u]<font></font>
<font></font>
Index:  0        1         2        3         4        5         6</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, the root node ‚Äúr‚Äù has position 3. The node ‚Äúw‚Äù has position -2 relative to the parent node or the absolute position 3 + (-2) = 1. Similarly, you can go down one more level, for example, the node ‚Äúe‚Äù has position 3 + (-2) + (+1) = 2. That is, </font><font style="vertical-align: inherit;">node index is the sum of the positions from the root of the tree to this node. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This optimization, in addition to a faster search for an item in the list, will provide a faster and easier search for the index on the node. </font><font style="vertical-align: inherit;">But, of course, correctly updating the position when changing the tree has become a little more difficult.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add Indexing</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, in the tree we can take an element by index, change its value, add elements to the middle and delete. Essentially, we just need to add a quick index search by value, indexOf (obj). Then contains (obj) and remove (obj) will be trivially solved. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But first, let's simplify the task a bit. Let's make a structure that stores only unique elements. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to quickly search for something, they usually use a table. In the Java world, tables are called Map; it has 2 main implementations: HashMap and TreeMap. The key to the table will be a link to the object, and the value will be a link to its node:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexedTreeListSet</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  root: Node&lt;T&gt;<font></font>
  indexMap: Map&lt;T, Node&lt;T&gt;&gt;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Those. the structure consists of two parts: the list tree itself and the table with links to objects and nodes of this tree. When updating the tree, the table must also be updated. I will not describe the process in detail. Intuitively, it should be understandable: add a node - put it in the table, delete the node - delete it from the table. In practice, there are nuances with balancing the tree: the algorithm should change links between nodes, and not move objects between nodes. Otherwise, you will have to do a lot of updates in the table and performance will drop. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ok, we will assume that we can quickly find the node by the element that it contains. So what? We need to find its index, but this cannot be done yet. But we can complicate the node class so that it contains not only links to the left and right nodes, but also to its parent:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  obj: T<font></font>
  left: Node&lt;T&gt;<font></font>
  right: Node&lt;T&gt;<font></font>
  parent: Node&lt;T&gt;<font></font>
  pos: int<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, updating the tree is a little more complicated, because now we need to carefully update the link to the parent. But now, knowing the node, we can go up the tree and calculate the index of any node. If we used the optimization from the previous chapter, then we just need to calculate the sum of the positions from the current node to the root. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a list containing unique elements, the problem can be considered solved.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
True, we have a small problem. </font><font style="vertical-align: inherit;">Suppose we call set (index, obj). </font><font style="vertical-align: inherit;">We can easily replace one element in a node with another, but only if there is no new element in the list yet. </font><font style="vertical-align: inherit;">And if so, what should I do? </font><font style="vertical-align: inherit;">Remove excess item from old position and put in new? </font><font style="vertical-align: inherit;">Or vice versa, first add and then delete? </font><font style="vertical-align: inherit;">The result may be different. </font><font style="vertical-align: inherit;">And you can do nothing at all or throw an exception. </font><font style="vertical-align: inherit;">There is no perfect solution. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sorting by standard methods such a list, most likely, will not work either. </font><font style="vertical-align: inherit;">After all, the sorting algorithm will not know about the need for uniqueness of objects and will create duplicates when moving items in the list.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We remove uniqueness</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ok, complicating things further, let us keep the same objects. Obviously, you need to do something with the table. The first idea to store a list of nodes in it does not seem very good: with an increase in the length of the list, performance will deteriorate. Up to O (n) if all list items are the same. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then let's try to store a sorted tree of nodes in a table instead of a list. Sorted by position in the list.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexedTreeList</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  root: Node&lt;T&gt;<font></font>
  indexMap: Map&lt;T, TreeSet&lt;Node&lt;T&gt;&gt;&gt;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then insertion / deletion to / from the TreeSet &lt;Node&gt; of size m will occur during log (m) comparisons of the positions of the nodes, and each comparison will occur over log (n) time. The final complexity of inserting or deleting into a similar structure will occur in O (log (n) * (1 + log (m))), where n is the total number of elements in the list and m is the number of elements in the list equal to the inserted / deleted. In the worst case, when all the elements are equal to each other, we obtain the complexity O (log (n) ^ 2).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An attentive reader will probably object: but what about immutability? </font><font style="vertical-align: inherit;">After all, we cannot change objects if they are table keys? </font><font style="vertical-align: inherit;">In general, it is. </font><font style="vertical-align: inherit;">However, for a tree that stores sorted objects in keys, in addition to the standard rules for comparisons, it is sufficient to preserve the invariant: if a &lt;b, then this property should not change over time. </font><font style="vertical-align: inherit;">This is just our case: if the position of one node is less than the position of another node, then this property will be preserved regardless of how many nodes were added or deleted between them.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is it possible to make the structure persistent?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Short answer: no, it is impossible. </font><font style="vertical-align: inherit;">Due to the biconnectedness of the tree, from the root to the leaves and back, we have every tree node connected to each. </font><font style="vertical-align: inherit;">Persistence cannot be done in this way; you have to recreate the entire structure with any change. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But I have an understanding of how to implement a persistent structure for cases where we do not need to insert elements in the middle of the list. </font><font style="vertical-align: inherit;">You can add elements to the beginning or end, and you can delete from the middle. </font><font style="vertical-align: inherit;">The remaining properties are the same. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you are interested, then I will try to write an article about this structure. </font><font style="vertical-align: inherit;">Perhaps I even implement it in Java, Kotlin or Scala. </font><font style="vertical-align: inherit;">But, most likely, it will not be soon.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A few implementation features</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here I want to describe some features that I had to face. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
About one of the optimizations about storing the node position in the list, I wrote above. Here the strength of Open Source is manifested: I took the ready-made TreeList code and did not delve into the details of the AVL tree, node rotations, position updates, etc.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another feature inherited from TreeList is the links to subtrees in tree leaves. Each node stores boolean leftIsPrevious and rightIsNext. These variables indicate the presence or absence of a left / right subtree. If there is no subtree, then in left / right, instead of a link to the subtree, a link to the node that corresponds to the previous or next element is stored. In our example, [‚Äúq‚Äù, ‚Äúw‚Äù, ‚Äúe‚Äù, ‚Äúr‚Äù, ‚Äút‚Äù, ‚Äúy‚Äù, ‚Äúu‚Äù] the node ‚Äúe‚Äù is leafy, it has no subtrees. Accordingly, leftIsPrevious and rightIsNext are true, and left and right point to the nodes ‚Äúw‚Äù and ‚Äúr‚Äù, respectively. This approach helps iterate through the list faster. And it interferes with the programming of new features :)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A little bit about working with the table object ‚Üí node. Ideally, you need to put an element into the table once when adding it to the structure and delete it once from the structure. In practice, I could not achieve this. When you add an item, it is added to the table, everything is as it should. However, when you delete an item, the balancing algorithm sometimes moves items between nodes. The result is two deletions and one record in the table instead of one deletion. This can be fixed if you remove the optimization from leftIsPrevious and rightIsNext. And even get a small performance gain, and not only during removal. In some tests, the increase was 10-20%. But the iteration speed drops significantly, 1.5-2.5 times in my tests. I decided to leave the optimization for now.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Java, the main types of tables are HashMap and TreeMap. For a table, an object ‚Üí a node uses HashMap by default. However, you can use TreeMap with a task-specific Comparator. In this case, indexOf (obj) and remove (obj) will search / delete the object that is equal to the specified object according to the Comparator code. For example, we store a list of users, and the comparator compares users only by name. Then we can answer the question ‚ÄúWhat positions of the list are users with the name 'Napoleon?'‚Äù. Or remove all Napoleons from the list :). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The structure does not support null. You can fix it, but there is no feeling that it is necessary.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regarding the fact that the structure ‚Äúknows everything‚Äù, I, of course, was a little misleading. </font><font style="vertical-align: inherit;">Of course, when working with single elements, everything is fine and under certain conditions even for the logarithm. </font><font style="vertical-align: inherit;">However, she does not know some things that other structures can. </font><font style="vertical-align: inherit;">For example, a Cartesian tree with an implicit key, there were articles about it on the hub </font><font style="vertical-align: inherit;">It does not know how to quickly do indexOf, but it knows how to make a sublist and concatenate two lists into one for the logarithm (on average, not guaranteed), plus it can be made persistent.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Java, performance is usually measured using the jmh framework. </font><font style="vertical-align: inherit;">Tests were conducted on the 2017 MacBook Pro under Java11. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I compared the performance of the standard ArrayList, TreeList from apache common-collections, and my two classes IndexedTreeList and IndexedTreeListSet in several scenarios. </font><font style="vertical-align: inherit;">In each scenario, 1000 operations of the same type were performed, so the result should be multiplied by 1000.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code under the spoiler</font></font></b><div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-meta">@Fork(1)</span>
<span class="hljs-meta">@Warmup(iterations = 3)</span>
<span class="hljs-meta">@Measurement(iterations = 5)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PerformanceCompare</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Class&gt; CLASSES = Stream.of(TreeList.class, IndexedTreeListSet.class, IndexedTreeList.class,<font></font>
            ArrayList.class)<font></font>
            .collect(Collectors.toMap(c -&gt; c.getSimpleName(), c -&gt; c));<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ITERATIONS = <span class="hljs-number">1000</span>;<font></font>
<font></font>
    <span class="hljs-meta">@State(Scope.Benchmark)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plan</span> </span>{<font></font>
<font></font>
        <span class="hljs-meta">@Param({"10", "100", "1000", "10000", "100000", "1000000"/*, "10000000"*/})</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> size;<font></font>
<font></font>
        <span class="hljs-meta">@Param({"ArrayList", "TreeList", "IndexedTreeList", "IndexedTreeListSet"})</span>
        <span class="hljs-keyword">public</span> String className;<font></font>
<font></font>
        <span class="hljs-keyword">private</span> Random random;
        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<font></font>
<font></font>
        <span class="hljs-meta">@Setup</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException </span>{<font></font>
            random = <span class="hljs-keyword">new</span> Random();<font></font>
            list = (List&lt;Integer&gt;) CLASSES.get(className).newInstance();<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<font></font>
                list.add(i);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">indexOfKnown</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value = list.indexOf(random.nextInt(plan.size));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">indexOfUnknown</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value += list.indexOf(random.nextInt());<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addRemoveRandom</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            list.add(random.nextInt(list.size() + <span class="hljs-number">1</span>), random.nextInt());<font></font>
            value += list.remove(random.nextInt(list.size()));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value += list.get(random.nextInt(list.size()));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Timeout(time = 1, timeUnit = TimeUnit.MILLISECONDS)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException </span>{<font></font>
        Options opt = <span class="hljs-keyword">new</span> OptionsBuilder()<font></font>
                .include(PerformanceCompare.class.getSimpleName())<font></font>
                .forks(<span class="hljs-number">1</span>)
<span class="hljs-comment">//                .jvmArgs("-Xms2048m", "-Xmx2048m", "-XX:MaxDirectMemorySize=512M")</span><font></font>
                .build();<font></font>
<font></font>
        <span class="hljs-keyword">new</span> Runner(opt).run();<font></font>
    }<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To begin with, I compared the speed of getting a random item from a list. </font><font style="vertical-align: inherit;">I‚Äôll warn you right away that in this test the overhead is very significant. </font><font style="vertical-align: inherit;">Results approaching 100,000 * 1,000 operations per second are severely distorted.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get test result</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.get                       ArrayList       10  thrpt    5  79865.412 ¬± 10145.202  ops/s<font></font>
PerformanceCompare.get                       ArrayList      100  thrpt    5  81862.243 ¬±   983.727  ops/s<font></font>
PerformanceCompare.get                       ArrayList     1000  thrpt    5  81033.507 ¬±  4540.206  ops/s<font></font>
PerformanceCompare.get                       ArrayList    10000  thrpt    5  64096.123 ¬±  1430.361  ops/s<font></font>
PerformanceCompare.get                       ArrayList   100000  thrpt    5  41289.491 ¬± 11286.114  ops/s<font></font>
PerformanceCompare.get                       ArrayList  1000000  thrpt    5   8598.944 ¬±  2048.461  ops/s<font></font>
PerformanceCompare.get                        TreeList       10  thrpt    5  33912.275 ¬±  3754.284  ops/s<font></font>
PerformanceCompare.get                        TreeList      100  thrpt    5  21346.854 ¬±   863.588  ops/s<font></font>
PerformanceCompare.get                        TreeList     1000  thrpt    5  14808.414 ¬±   508.098  ops/s<font></font>
PerformanceCompare.get                        TreeList    10000  thrpt    5   8679.384 ¬±   109.250  ops/s<font></font>
PerformanceCompare.get                        TreeList   100000  thrpt    5   4605.998 ¬±  1028.945  ops/s<font></font>
PerformanceCompare.get                        TreeList  1000000  thrpt    5   2241.381 ¬±   768.147  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList       10  thrpt    5  34054.357 ¬±  3682.829  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList      100  thrpt    5  21934.002 ¬±  2339.947  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList     1000  thrpt    5  14626.691 ¬±   369.893  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList    10000  thrpt    5   7386.863 ¬±   342.150  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList   100000  thrpt    5   4562.126 ¬±   352.772  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList  1000000  thrpt    5   2105.718 ¬±   702.064  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet       10  thrpt    5  33317.503 ¬±  2307.829  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet      100  thrpt    5  21247.440 ¬±  1253.386  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet     1000  thrpt    5  14665.557 ¬±   487.833  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet    10000  thrpt    5   7667.214 ¬±    80.093  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet   100000  thrpt    5   3454.023 ¬±    82.994  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet  1000000  thrpt    5   1768.701 ¬±    35.878  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here, oddly enough, the greatest interest is the standard ArrayList. Theoretically, the speed of getting out of it should be constant and not depend on the number of elements. In practice, the performance first holds around 90,000 * 1000 operations per second (remember the overhead), but with a list length of several thousand items it starts to sag. This is due to the increasingly frequent cache miss: the processor cache does not have the necessary data and more and more often you need to go for data in RAM. With a million elements, the speed of the test is 10 times lower, but in practice, the performance drawdown is even greater.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TreeList, IndexedTreeList and IndexedTreeListSet expectedly show similar results. </font><font style="vertical-align: inherit;">Expected much slower than ArrayList. </font><font style="vertical-align: inherit;">Even with a small number of elements, TreeList is several times slower than ArrayList, although the test shows the difference only 2 times. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The next test is addRemoveRandom. </font><font style="vertical-align: inherit;">Here, in each test, I insert an element into a random position and remove an element from a random position.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AddRemoveRandom test result</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.addRemoveRandom           ArrayList       10  thrpt    5  12440.764 ¬±   485.642  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList      100  thrpt    5   9880.123 ¬±   464.014  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList     1000  thrpt    5   5288.905 ¬±  1219.055  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList    10000  thrpt    5   1024.942 ¬±   179.366  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList   100000  thrpt    5     91.219 ¬±    25.380  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList  1000000  thrpt    5      5.499 ¬±     0.400  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList       10  thrpt    5   6242.607 ¬±   350.290  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList      100  thrpt    5   3117.945 ¬±   116.066  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList     1000  thrpt    5   1829.778 ¬±    80.516  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList    10000  thrpt    5   1230.077 ¬±    53.381  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList   100000  thrpt    5    443.571 ¬±    69.207  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList  1000000  thrpt    5    308.963 ¬±    84.077  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList       10  thrpt    5   3556.511 ¬±   144.596  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList      100  thrpt    5   2120.777 ¬±    83.848  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList     1000  thrpt    5   1211.112 ¬±    92.288  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList    10000  thrpt    5    789.458 ¬±    19.450  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList   100000  thrpt    5    302.989 ¬±    40.030  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList  1000000  thrpt    5    178.822 ¬±    92.853  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet       10  thrpt    5   4138.007 ¬±   119.943  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet      100  thrpt    5   2435.803 ¬±    20.276  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet     1000  thrpt    5   1445.054 ¬±   276.909  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet    10000  thrpt    5    972.256 ¬±    19.987  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet   100000  thrpt    5    366.608 ¬±    94.487  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet  1000000  thrpt    5    227.677 ¬±    48.276  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It could be assumed that ArrayList is faster on small lists. </font><font style="vertical-align: inherit;">However, the fact that he wins in this test on lists of up to 10,000 elements looks interesting. </font><font style="vertical-align: inherit;">Apparently, System.arrayCopy is very well optimized and uses all the features of modern processors. </font><font style="vertical-align: inherit;">Starting at 10,000 items, specialized data structures are starting to win. </font><font style="vertical-align: inherit;">With 1,000,000 elements, the speed difference is 30-50 times. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IndexedTreeList and IndexedTreeListSet are expected to be slower than TreeList. </font><font style="vertical-align: inherit;">About 1.5 - 2 times. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The remaining 2 tests indexOfKnown and indexOfUnknown should just demonstrate the main feature of this structure. </font><font style="vertical-align: inherit;">The difference between the tests is that in one case we are looking for an element that is in the list, and in the other case we are looking for an element that is not in the list.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test result indexOfKnown and indexOfUnknown</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.indexOfKnown              ArrayList       10  thrpt    5  41424.356 ¬±   549.047  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList      100  thrpt    5  17216.477 ¬±  1444.744  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList     1000  thrpt    5   2296.306 ¬±    76.372  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList    10000  thrpt    5    233.863 ¬±    26.926  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList   100000  thrpt    5     23.208 ¬±     2.776  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList  1000000  thrpt    5      0.919 ¬±     0.455  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList       10  thrpt    5  26740.708 ¬±  1323.125  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList      100  thrpt    5   5670.923 ¬±    99.638  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList     1000  thrpt    5    745.408 ¬±    26.827  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList    10000  thrpt    5     52.288 ¬±     1.362  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList   100000  thrpt    5      4.224 ¬±     0.855  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList  1000000  thrpt    5      0.193 ¬±     0.052  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList       10  thrpt    5  34485.128 ¬±  1582.703  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList      100  thrpt    5  29209.412 ¬±  1544.268  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList     1000  thrpt    5  21139.584 ¬±  1442.867  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList    10000  thrpt    5  12544.306 ¬±   312.097  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList   100000  thrpt    5   3538.201 ¬±   272.537  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList  1000000  thrpt    5   1420.119 ¬±   538.476  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet       10  thrpt    5  39201.995 ¬±  1887.065  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet      100  thrpt    5  34204.112 ¬±  1122.517  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet     1000  thrpt    5  25374.557 ¬±  1596.746  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet    10000  thrpt    5  14291.317 ¬±   391.180  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet   100000  thrpt    5   4215.898 ¬±   283.680  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet  1000000  thrpt    5   1729.100 ¬±  1260.815  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList       10  thrpt    5  59053.313 ¬±  1845.665  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList      100  thrpt    5  10867.572 ¬±   142.823  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList     1000  thrpt    5   1186.583 ¬±    28.003  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList    10000  thrpt    5    120.953 ¬±     4.146  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList   100000  thrpt    5     11.936 ¬±     0.320  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList  1000000  thrpt    5      0.566 ¬±     0.335  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList       10  thrpt    5  28134.237 ¬±  2291.670  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList      100  thrpt    5   3153.930 ¬±   158.734  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList     1000  thrpt    5    322.383 ¬±    44.245  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList    10000  thrpt    5     25.674 ¬±     1.787  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList   100000  thrpt    5      1.867 ¬±     0.291  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList  1000000  thrpt    5      0.093 ¬±     0.008  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList       10  thrpt    5  66625.126 ¬±  5232.668  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList      100  thrpt    5  70038.055 ¬±  5803.848  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList     1000  thrpt    5  63240.467 ¬±   885.956  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList    10000  thrpt    5  54731.988 ¬±  3950.150  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList   100000  thrpt    5  22049.476 ¬±   821.924  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList  1000000  thrpt    5   9459.862 ¬±   804.738  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet       10  thrpt    5  70274.968 ¬± 15830.355  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet      100  thrpt    5  71017.685 ¬±  6920.447  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet     1000  thrpt    5  66405.960 ¬±  1127.231  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet    10000  thrpt    5  57983.963 ¬±  3276.142  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet   100000  thrpt    5  41277.110 ¬±  9919.893  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet  1000000  thrpt    5   9840.185 ¬±  2159.352  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here, ArrayList and TreeList have almost no surprises. With increasing size, the speed decreases almost linearly. The search for an item from a non-list is expected to be 2 times slower than the search for an item from the list, because you need to go through the entire array instead of half on average. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But IndexedTreeList and IndexedTreeListSet here show the expected good result. These data structures show an indexOf execution speed comparable to ArrayList even with 10 elements. With 1000 elements, these structures are 10 times faster, with 1,000,000 faster 1000 times. When searching for an item that is not in the list, they are expected to give better speed than when searching for an item from the list.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What else is interesting to pay attention to is the performance subsidence of IndexedTreeList and IndexedTreeListSet in the indexOfUnknown test. </font><font style="vertical-align: inherit;">Here the situation is similar to that in the test with ArrayList.get. </font><font style="vertical-align: inherit;">Theoretically, we should not have gotten a drop in performance, but in practice, because of cache miss, we got it, moreover, significantly.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of a conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I still don‚Äôt know if the proposed structure has a novelty or not. On the one hand, the idea is not complicated if you know how the tree works by an implicit key. On the other hand, I have not seen a description of a structure with such properties. And if so, then it makes sense to make the structure more famous, it might be useful to someone. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But even if this is another bike, I tried to make it useful. A pull request in common-collections has been created, but at the time of writing this article is not yet poured. Knowing how slowly everything can happen in open source, I won‚Äôt be surprised if the process drags on for months.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somewhat surprised by the result of comparing the performance of ArrayList and TreeList. </font><font style="vertical-align: inherit;">Tests showed that TreeList does not make sense to use up to 10,000 elements on the list size. </font><font style="vertical-align: inherit;">It would be interesting to try b-tree instead of a binary tree. </font><font style="vertical-align: inherit;">This structure should use memory more carefully and, most likely, work faster. </font><font style="vertical-align: inherit;">And for it you can adapt the idea with indexing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In any case, it‚Äôs fun to have an instrument in the arsenal that can (almost) do everything with predictable complexity.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">References</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Original </font></font><br>
</a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pull request </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">project </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">in apache common-collections </font></a></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ticket in Jira</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en488762/index.html">Elegant asynchronous programming with promises</a></li>
<li><a href="../en488766/index.html">Art and Technology: University of Massachusetts Lowell</a></li>
<li><a href="../en488768/index.html">Bloody hell, or How to swear in English to be mistaken for a cultured person</a></li>
<li><a href="../en488770/index.html">Work with the KOMPAS-3D API ‚Üí Lesson 17 ‚Üí Text document</a></li>
<li><a href="../en488776/index.html">Accessibility Enhancements in Visual Studio 2019 for Mac</a></li>
<li><a href="../en488780/index.html">Mozilla lost in the browser war, but still believes it could save the Internet</a></li>
<li><a href="../en488782/index.html">How do you like this dependency management option in Python?</a></li>
<li><a href="../en488784/index.html">Commercialization of free software improvements under Copyleft licenses</a></li>
<li><a href="../en488786/index.html">How detailed should a user story be?</a></li>
<li><a href="../en488792/index.html">Monitoring site availability in Russia on the knee</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>