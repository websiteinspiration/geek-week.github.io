<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐙 😻 🧟 SHISHUA: the world's fastest pseudo random number generator 👨🏽‍🚒 👓 ♐️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Six months ago, I wanted to create the best pseudorandom number generator (PRNG) with some unusual architecture. I thought that the beginning would be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SHISHUA: the world's fastest pseudo random number generator</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/498352/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/ex/bl/5pexblhd_seedlgm8iidkfktef4.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Six months ago, I wanted to create the best pseudorandom number generator (PRNG) with some unusual architecture. I thought that the beginning would be easy, and as you work, the task will slowly become more complex. And I thought if I could learn everything fast enough to cope with the most difficult. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To my surprise, complexity did not increase linearly. Chi-square byte testing proved to be very difficult! Later it was just as difficult to pass diehard tests. I </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">published the current results</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to understand what other difficulties await me. However </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the PractRand test failed at that time</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then it was very difficult to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pass the BigCrush test</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then it was very difficult to transfer 32 terabytes of data when passing PractRand. </font><font style="vertical-align: inherit;">Speed ​​has become a problem. </font><font style="vertical-align: inherit;">It was not enough to create a design that generated ten megabytes per second, because passing PractRand would take a month. </font><font style="vertical-align: inherit;">But I must admit that it </font><font style="vertical-align: inherit;">was very difficult to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pass this test at a speed of gigabytes per second</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When you rise to such a height ... you want to know if you can get to the Pareto border. </font><font style="vertical-align: inherit;">You want to create the world's fastest PRNG, which will pass the most complex statistical tests. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I have succeeded. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">previous article,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I talked about what I learned to achieve my goal. </font><font style="vertical-align: inherit;">And here I will tell you how the final architecture works.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">purpose</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start with the obvious: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speed depends on the platform</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">I focused on optimizing for the modern x86-64 architecture (Intel and AMD processors). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To compare performance, the classic </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> metric is used </font><font style="vertical-align: inherit;">: this is the number of processor cycles spent on generating one byte. </font><font style="vertical-align: inherit;">This metric is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calculated and compared</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in all cryptographic works. </font><font style="vertical-align: inherit;">A slightly lower cpb in the world of software or hardware can ensure victory in the competition or use on websites around the world. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To improve cpb, you can:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generate more bytes with the same amount of work,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Or do less work to generate the same number of bytes,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Or parallelize the work.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will do all of the above. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
According to the first point, we need to produce more bits at each iteration. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I was afraid that they would tell me: “If it does not give out 32-bit numbers, then this is not the PRSP”, or the same with 64-bit numbers. Or: “The PRNG should only be for x86-64 architecture,” as if instructions like POPCNT or registers like% xmm7 are forbidden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, the PRNG is engineering: generators have been trying for several decades to squeeze everything possible out of processors! When ROL appeared, they began to rely on him. With the advent of 64-bit processors, they began to rely on% rax. Of course, such algorithms can work slower on ARM (although this remains to be seen), however, 64-bit PRNs were actively used even before Android started demanding 64-bit support in 2019! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, this area is developing along with the hardware. And today, Intel and AMD processors due to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> already support 256-bit operations. RC4 produced 1 byte, drand48 could produce 4 bytes at a time, pcg64 - 8 bytes, and now we can immediately generate 32 bytes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8 bytes can be a 64-bit number, and most programming languages ​​have built-in types for this. </font><font style="vertical-align: inherit;">But few languages ​​provide types for 16 bytes (a notable exception is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__uint128_t</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in C). </font><font style="vertical-align: inherit;">Even fewer languages ​​have type for 32 bytes (except internal). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So we can say goodbye to the usual prototype of the PRNG function (example from the Vigny </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HWD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> benchmark </font><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="plaintext hljs">static uint64_t next(void);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Instead, you can make a generator that fills the buffer (example from </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my benchmark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="plaintext hljs">void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What are the disadvantages of this solution? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If your generator produces 32 bytes at a time, then you need the consumer to provide an array that is a multiple of 32 (ideally, aligned by 32 bytes). </font><font style="vertical-align: inherit;">Although you can do without it, we’ll just fill the buffer. </font><font style="vertical-align: inherit;">We will remove unused data from it and fill it again as necessary. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The delay</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> becomes unpredictable: some calls will just read the buffer. </font><font style="vertical-align: inherit;">But on average everything will be the same. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we generate more bytes, doing the same amount of work. </font><font style="vertical-align: inherit;">How do we parallelize it?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallelism</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Processors offer an incredible set of parallelization tools at all levels. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Firstly, these are SIMD instructions (Single-Instruction, Multiple Data). For example, AVX2 simultaneously performs four 64-bit additions, or eight 32-bit additions, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It has been used in cryptography for about fifteen years. Concurrency provided the incredible performance of the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaCha20</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It is used by most important primitives that do not use AESNI. For example, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NORX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gimli are</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> designed with parallelism in mind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recently, interest in this topic has also increased in the non-cryptographic PRNG community. In particular, existing primitives that were not designed for SIMD can be the basis for creating very fast PRNs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When Sebastiano Vigna promoted his </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> architecture </font><font style="vertical-align: inherit;">in the Julia standard library, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">he found out</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that the results of eight competitive, differently initialized PRNG instances can be concatenated very quickly if each operation is performed simultaneously in all PRNRs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMD is just one of the levels of parallelization in the processor. I recommend reading the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">previous article on this topic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in order to have a better idea, but I will give some explanations. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Processor pipelines</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> allow several instructions to be processed at different stages. If the order of their execution is well organized in order to reduce the dependencies between the stages, then you can speed up the processing of instructions.</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Superscalar execution</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> allows you to simultaneously process the computing parts of the instructions. </font><font style="vertical-align: inherit;">But for this they should not have read-write dependencies. </font><font style="vertical-align: inherit;">You can adapt the architecture to reduce the risk of downtime by recording long before reading. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extraordinary execution</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> allows the processor to execute instructions not in the order of sequence, but as they are ready, even if the previous instructions are not yet ready. </font><font style="vertical-align: inherit;">But for this there should be no read-write dependency. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And now we pass to implementation!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Architecture</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider a scheme called semi-SHISHUA. </font><font style="vertical-align: inherit;">Where such a name comes from will become gradually apparent as you read. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The scheme looks like this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd8/df1/b8f/bd8df1b8fcfae4897eb4b74f2c6e856f.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider its line by line.</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct prng_state {<font></font>
  __m256i state[2];<font></font>
  __m256i output;<font></font>
  __m256i counter;<font></font>
} prng_state;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The state is divided into two parts, which are placed in the AVX2 register (256 bits). To increase the speed, we keep the result close to the state itself, but it is not part of the state. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We also have a 64-bit counter. To simplify the calculation, it is also an AVX2 register. The fact is that AVX2 has a small feature: ordinary registers (% rax and the like) cannot be transferred directly to SIMD via MOV, they must pass through RAM (most often through the stack), which increases the delay and costs two processor instructions (MOV on the stack, VMOV from the stack). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's look at the generation. Let's start by loading, then go through the buffer and fill it with 32 bytes at each iteration.</font></font><br>
<br>
<pre><code class="plaintext hljs">inline void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size) {<font></font>
  __m256i s0 = s-&gt;state[0], counter = s-&gt;counter,<font></font>
          s1 = s-&gt;state[1],       o = s-&gt;output;<font></font>
  for (__uint64_t i = 0; i &lt; size; i += 4) {<font></font>
    _mm256_storeu_si256((__m256i*)&amp;buf[i], o);<font></font>
    // …<font></font>
  }<font></font>
  s-&gt;state[0] = s0; s-&gt;counter = counter;<font></font>
  s-&gt;state[1] = s1; s-&gt;output  = o;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the function is inline, immediately filling the buffer at startup allows the processor to immediately execute the instructions depending on this through an extraordinary execution mechanism. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inside the loop, we quickly perform three state operations:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ft</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ffle</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dd</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hence the name SHISHUA!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, shift</font></font></h3><br>
<pre><code class="plaintext hljs">u0 = _mm256_srli_epi64(s0, 1);              u1 = _mm256_srli_epi64(s1, 3);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unfortunately, the AVX2 does not support revs. </font><font style="vertical-align: inherit;">But I want to mix the bits of one position in a 64-bit number with the bits of another position! </font><font style="vertical-align: inherit;">And shift is the best way to realize this. </font><font style="vertical-align: inherit;">We will shift by an odd number, so that each bit will visit all 64-bit positions, and not half of them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
During the shift, bits are lost, which leads to the removal of information from our state. </font><font style="vertical-align: inherit;">This is bad, you need to minimize losses. </font><font style="vertical-align: inherit;">The smallest odd numbers are 1 and 3, we will use different shift values ​​to increase the discrepancy between the two parts. </font><font style="vertical-align: inherit;">This will help reduce the similarity of their self-correlation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will shift to the right, because the rightmost bits have the lowest diffusion during addition: for example, the least significant bit in A + B is just the XOR of the least significant bits A and B.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stirring</font></font></h3><br>
<pre><code class="plaintext hljs">t0 = _mm256_permutevar8x32_epi32(s0, shu0); t1 = _mm256_permutevar8x32_epi32(s1, shu1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will use 32-bit mixing, because it gives a different granularity compared to the 64-bit operations that we use everywhere (64-bit alignment is violated). Moreover, it can be a cross-lane operation: other shuffles can move bits within the left 128 bits if they start from the left, or within the right 128 bits if they start from the right. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mixing Constants:</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i shu0 = _mm256_set_epi32(4, 3, 2, 1, 0, 7, 6, 5),<font></font>
        shu1 = _mm256_set_epi32(2, 1, 0, 7, 6, 5, 4, 3);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So that mixing really improves the result, we will move the weak (low dispersion) 32-bit parts of 64-bit additions to strong positions, so that the next additions enrich them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The low-end 32-bit part of the 64-bit chunk never moves to the same 64-bit chunk as the high-order part. </font><font style="vertical-align: inherit;">Thus, both parts do not remain within the same chunk, which improves mixing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the end, each 32-bit part goes through all positions in a circle: from A to B, from B to C, ... from H to A. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You may have noticed that the simplest mixing that takes into account all these requirements is two 256-bit turnover (revolutions of 96 bits and 160 bits to the right, respectively).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addition</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's add 64-bit chunks from two temporary variables - shift and mixing.</font></font><br>
<br>
<pre><code class="plaintext hljs">s0 = _mm256_add_epi64(t0, u0);              s1 = _mm256_add_epi64(t1, u1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Addition is the main source of dispersion: in this operation, bits are combined into irreducible combinations of XOR and AND expressions distributed over 64-bit positions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Storing the result of addition within a state permanently preserves this dispersion.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Output function</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Where do we get the output from? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It's simple: the structure we created allows us to generate two independent parts of the state s0 and s1, which do not affect each other in any way. </font><font style="vertical-align: inherit;">Apply XOR to them and get a completely random result. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To strengthen the independence between the data to which we apply XOR, we take a partial result: the shifted part of one state and the mixed part of another.</font></font><br>
<br>
<pre><code class="plaintext hljs">o = _mm256_xor_si256(u0, t1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is similar to reducing the read-write dependencies between instructions in a superscalar processor, as if u0 and t1 were ready to read to s0 and s1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now discuss the counter. We process it at the beginning of the cycle. First, change the state, and then increase the counter value:</font></font><br>
<br>
<pre><code class="plaintext hljs">s1 = _mm256_add_epi64(s1, counter);<font></font>
counter = _mm256_add_epi64(counter, increment);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why do we first change the state, and then update the counter? s1 becomes available earlier, this reduces the likelihood that subsequent instructions that read it will stop in the processor pipeline. Also, this sequence helps to avoid the direct dependence of the read-write counter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We apply the counter to s1, and not to s0, because they both affect the output anyway, however, s1 loses more bits due to the shift, so that it helps it to “get on its feet” after the shift. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The counter may not record the PractRand test. Its sole purpose is to set a lower limit of 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bytes = 512 exbibytes for the PRNG period: we begin to repeat the cycle only after one millennium of work at a speed of 10 gibytes per second. It is unlikely that it will be too slow for practical use in the coming centuries. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Increment:</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i increment = _mm256_set_epi64x(1, 3, 5, 7);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The odd numbers are chosen as increments, because only the basic coprime numbers cover the entire cycle of the finite field GF (2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), and all the odd numbers are coprime for 2. In other words, if you increment by an even integer in the range from 0 to 4, returning to 0 after 4, it turns out the sequence 0-2-0-2- ..., which will never lead to 1 or 3. And the odd increment passes through all integers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For all 64-bit numbers in state, we will use different odd numbers, which will further separate them and slightly increase mixing. </font><font style="vertical-align: inherit;">I chose the smallest odd numbers so they don't look magical. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is how state transition and output function work. </font><font style="vertical-align: inherit;">How to initialize them?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialization</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We initialize the state using the hexadecimal digits Φ, the irrational number that is least approximated by the fraction.</font></font><br>
<br>
<pre><code class="plaintext hljs">static __uint64_t phi[8] = {<font></font>
  0x9E3779B97F4A7C15, 0xF39CC0605CEDC834, 0x1082276BF3A27251, 0xF86C6A11D0C18E95,<font></font>
  0x2767F0B153D27B7F, 0x0347045B5BF1827F, 0x01886F0928403002, 0xC1D64BA40F335E36,<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Take a 256-bit seed. </font><font style="vertical-align: inherit;">This is often done in cryptography and does not harm the work of non-cryptographic PRNGs:</font></font><br>
<br>
<pre><code class="plaintext hljs">prng_state prng_init(SEEDTYPE seed[4]) {<font></font>
  prng_state s;<font></font>
  // …<font></font>
  return s;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We do not want to redefine the entire part of the state (s0 or s1) with this initial number, we only need to affect half. </font><font style="vertical-align: inherit;">This way we will avoid the use of attenuating initial numbers, which accidentally or intentionally give rise to a known weak initial state. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since we do not change half of each state, we retain control over 128 status bits. </font><font style="vertical-align: inherit;">Such entropy is enough to start and maintain a strong position.</font></font><br>
<br>
<pre><code class="plaintext hljs">s.state[0] = _mm256_set_epi64x(phi[3], phi[2] ^ seed[1], phi[1], phi[0] ^ seed[0]);<font></font>
s.state[1] = _mm256_set_epi64x(phi[7], phi[6] ^ seed[3], phi[5], phi[4] ^ seed[2]);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then we repeat ( </font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">several times the </font><font style="vertical-align: inherit;">following sequence:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Run the steps ( </font></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) of the SHISHUA iterations.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We assign one part of the state to another state, and the other part to the output.</font></font></li>
</ol><br>
<pre><code class="plaintext hljs">for (char i = 0; i &lt; ROUNDS; i++) {<font></font>
  prng_gen(&amp;s, buf, 4 * STEPS);<font></font>
  s.state[0] = s.state[1];<font></font>
  s.state[1] = s.output;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assigning an output result increases state dispersion. </font><font style="vertical-align: inherit;">During initialization, the additional work and correlation of states does not matter, because this series of operations is performed once. </font><font style="vertical-align: inherit;">We are only interested in dispersion during initialization. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After evaluating the effect on the correlation of the initial values, I chose </font></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 for and for </font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. I calculated the correlation by calculating the “unusual” and “suspicious” anomalies that arise due to the PRNG quality control tools in PractRand.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is difficult to measure speed for several reasons:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clock measurement</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> may not be accurate enough.</font></font></li>
<li>    <strong></strong>,      , -  ,  -,       .</li>
<li>,        .        <strong></strong>   .</li>
<li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><strong>  </strong></a>:        ,       .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I use the RDTSC processor instruction, which calculates the number of cycles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So that anyone can reproduce my results, I use a cloud-based virtual machine. This does not change the level of benchmark results compared to local testing. In addition, you do not have to buy the same computer as mine. Finally, there are many situations where the PRNG is launched in the clouds. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I chose Google Cloud Platform N2 (Intel processor) and N2D (AMD processor). The advantage of GCP is that they offer servers with processors from both manufacturers. In this article, we will focus on Intel, but for AMD the results will be in the same order. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To delve deeper into the topic, let's first get rid of the old RC4 cryptographic generator. Unable to parallelize the work, I got</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.5 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (cycles per generated byte). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's run a very popular and fast MCG: the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplest Lehmer128 PRNG</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which passes the BigCrush test, showed </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.5 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wow, great! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then we will run the latest development, which is used for fast hash tables - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wyrand</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.41 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a little better! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Some PRSPs do not pass the 32-terabyte PractRand test, but they work very quickly. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xoshiro256 +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reached only 512 mebibytes, but showed a very high speed: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.34 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another recent development of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RomuTrio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . She claims to be the fastest PRNG in the world - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.31 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Okay, that’s enough. </font><font style="vertical-align: inherit;">What did semi-SHISHUA show? </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.14 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Twice as fast as RomuTrio.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c84/f7a/c9f/c84f7ac9fcbc4d4a7b2400ae552522a4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cool. </font><font style="vertical-align: inherit;">Now test the cryptographic generator ChaCha8. </font><font style="vertical-align: inherit;">He reached ... </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.12 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMD is real magic! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the cryptographic community, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this was not a special surprise</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">ChaCha8 is extremely easy to parallelize. </font><font style="vertical-align: inherit;">This is just a well-hashed counter in a diffuse state. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And remember how the Julia language team tried to combine several instances of Vigny’s architecture to create a fast SIMD-based PRNG? </font><font style="vertical-align: inherit;">Let's look at their result using this technique ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 pieces of Xoshiro256 +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.09 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Technically, my laptop could affect the results. I'm not sure why Julia team development is faster than ChaCha8 in GCP, but slower when tested locally. On my machine, semi-SHISHUA runs faster than the Julia team development, but slower than ChaCha8. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is necessary to defeat all competitors. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You are probably already asking why we called the previous version of the semi-SHISHUA generator? Because it turned out to be easy to double the speed if you run two copies of semi-SHISHUA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Similar to the idea of ​​the Julia command, we separately initialize two PRNGs (four blocks of a 256-bit state), alternately supplying the output of their work. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But if we make more states, then we can produce even more data, combining four states in pairs:</font></font><br>
<br>
<pre><code class="plaintext hljs">o0 = _mm256_xor_si256(u0, t1);<font></font>
o1 = _mm256_xor_si256(u2, t3);<font></font>
o2 = _mm256_xor_si256(s0, s3);<font></font>
o3 = _mm256_xor_si256(s2, s1);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So we got SHISHUA, which showed a speed of </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.06 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is twice as fast as the previous fastest competitor in the world, which passed the 32-terabyte PractRand test. </font><font style="vertical-align: inherit;">The result is on the graph. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I believe that the development turned out to be competitive. </font><font style="vertical-align: inherit;">It works even faster on my laptop - 0.03 cpb, but I will adhere to my principles regarding the benchmark. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hopefully for a few more weeks my generator will stay on the podium of the fastest in the world (please do so).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quality</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The generator honestly passes BigCrush and the 32-terabyte PractRand test. And all thanks to four output streams. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The disadvantages of architecture include its </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">irreversibility</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This can be seen by reducing to a 4-bit state with </font></font><code>s0 = [a, b]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>s1 = [c, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. With a shift, we get </font></font><code>[0, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>[0, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and with stirring, </font></font><code>[b, c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>[d, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. New </font></font><code>s0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equals </font></font><code>[b, c] + [0, a] = [b⊕(a∧c), a⊕c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but </font></font><code>s1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equals </font></font><code>[d, a] + [0, c] = [d⊕(a∧c), a⊕c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If </font></font><code>a = ¬c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then, </font></font><code>a⊕c = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>a∧c = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">therefore, </font></font><code>s0 = [b, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>s1 = [d, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. That is, we get two combinations of </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which give us the same final state. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our case, this is not a problem, because the 64-bit counter is also part of the state. It turns out the minimum cycle of 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">71</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bytes (128 bytes per state transition), which is at a speed of 10 gibytes / sec. </font><font style="vertical-align: inherit;">will last seven thousand years. </font><font style="vertical-align: inherit;">This balances the lost states. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, even despite irreversibility, the average transition period between states is 2 ^ ((256 + 1) ÷ 2). </font><font style="vertical-align: inherit;">This gives an average cycle of </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,135</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bytes (at a speed of 10 gibytes / sec. It will last more than a trillion times longer than the universe exists). </font><font style="vertical-align: inherit;">Although I believe that middle cycles are overestimated, because they do not tell us anything about the quality of the generator. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here are the benchmark results:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generator</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quality</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seed correlation</font></font></strong></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHISHUA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.06</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 256 GiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 + x8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.09</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaCha8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB?</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB?</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RomuTrio</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.31</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 +</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.34</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">512 MiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wyrand</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.41</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lehmer128</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.44</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RC4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.48</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
</tbody></table></div><br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : The number of processor cycles spent on one generated byte. </font><font style="vertical-align: inherit;">Received on cloud machines N2 GCP and N2D (AMD), the order is the same.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quality</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : The level at which the generator fails to pass the PractRand test. </font><font style="vertical-align: inherit;">If it does not fail, there is a&gt; sign. </font><font style="vertical-align: inherit;">If the result is not proven, there is a question mark.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correlation of seed numbers</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : PractRand traversal with alternating bytes of eight streams with seed numbers 0, 1, 2, 4, 8, 16, 32, 64. We use PractRand with double convolution and advanced tests.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/3f6/f1d/ea73f6f1db25664622785ba127764dbc.png"></div><br>
</li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although in our case there are no problems with irreversibility, we can still improve SHISHUA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In my opinion, the ideal PRNG has the following properties:</font></font><br>
<br>
<ol>
<li><strong>      </strong>,     2<sup>1024</sup>.      10 /.    10<sup>282</sup>  ,   .    «» (  ).              ,       .  ,      128-  NEON   ARM?  ,      ,     .</li>
<li><strong>    </strong>.      ,   SHISHUA  XOR    .     ,     .</li>
<li><strong>  ,</strong>      2<sup>128</sup>    (     ).        SHISHUA,  ,  .  ,      ( )    (, , .  2).</li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">State initialization has perfect dispersion</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : all bits of the initial number affect all bits of the state with the same probability. </font><font style="vertical-align: inherit;">I want to find out in relation to SHISHUA.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the problems holding back the development of PRNGs and cryptography as a whole is the lack of better general-purpose tools. </font><font style="vertical-align: inherit;">I need a tool that can immediately give me the exact measurement result so that I can compare different architectures on the fly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PractRand is great compared to what it was before, however:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It does not allow evaluating high-quality generators, making it impossible to compare them with each other. </font><font style="vertical-align: inherit;">We have to say: “well, after 32 terabytes they have no anomalies ...”</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It takes weeks to run it ...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I hope that the situation will improve greatly soon.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en498332/index.html">Zero-Trusted Security Architecture Implementation: Second Edition</a></li>
<li><a href="../en498334/index.html">How to organize the planning process in the SAP Analytics Cloud</a></li>
<li><a href="../en498340/index.html">About the new IDA Home (review)</a></li>
<li><a href="../en498346/index.html">GoLand 2020.1 - Enhanced support for Go Modules, a lot of auto-completion and much more</a></li>
<li><a href="../en498350/index.html">The best materials for job interviews and job searches</a></li>
<li><a href="../en498354/index.html">How to translate “Wishlist” into “hardware”, or semi-ideal semi-mobile semi-desktop</a></li>
<li><a href="../en498358/index.html">Learn French or how to get a universal adapter from a PSA diagnostic scanner</a></li>
<li><a href="../en498360/index.html">Integrated Server Load Metrics Evaluation</a></li>
<li><a href="../en498362/index.html">Kingston maintains leadership in SSD shipments: how do we do it?</a></li>
<li><a href="../en498366/index.html">What algorithms do Yandex developers implement every day</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>