<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐋 🎍 😙 So übertragen Sie einen Shader von einer Spiel-Engine auf Substance Painter 🏴󠁧󠁢󠁥󠁮󠁧󠁿 🗽 🦎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mein Name ist Taras Uleisky, ich bin technischer Künstler im Plarium Kharkiv. Um die Grafik unseres Survival-Rollenspiels auf Mobilgeräten zu optimier...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>So übertragen Sie einen Shader von einer Spiel-Engine auf Substance Painter</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/501982/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mein Name ist Taras Uleisky, ich bin technischer Künstler im Plarium Kharkiv. </font><font style="vertical-align: inherit;">Um die Grafik unseres Survival-Rollenspiels auf Mobilgeräten zu optimieren, haben wir unsere benutzerdefinierten Shader verwendet. </font><font style="vertical-align: inherit;">Sie beinhalten die Verwendung eindeutiger Texturen und Karten, die Texturen und Karten in anderen gängigen Schattierungsmethoden nicht ähnlich sind. </font><font style="vertical-align: inherit;">Infolgedessen ist 3D-Künstlern nicht ganz klar, wie diese Texturen für Assets im Spiel erstellt werden sollen. </font><font style="vertical-align: inherit;">Um sofort zu sehen, wie das 3D-Modell in der Spiel-Engine in der Texturierungsphase aussehen wird, habe ich den Shader auf Substance Painter verschoben. </font><font style="vertical-align: inherit;">Momentan gibt es in Substance Painter praktisch keine API-Materialien. Ich habe dieses Thema selbst studiert und mich daher entschlossen, meine eigenen Ideen zu teilen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tt/hi/z2/tthiz2dpzs2v-tdmzga9nskoeao.png"><a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity Shader</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Spiel verwendet Matcap Shading. Neben der üblichen Diff-Textur werden auch zwei vorgefertigte Matcap-Texturen auf den Shader übertragen. Sie werden mit jeweils zwei Masken interpoliert und verwischt. Infolgedessen wird die Matcap-Textur mit diffuser und gefälschter Blendung multipliziert, und auf dem Material sind Reflexionen zu sehen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wd/mt/fr/wdmtfrjwwe6gach03sv2-u31cya.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das folgende Beispiel zeigt, wie Matcap in einem Shader-Diagramm implementiert ist. In diesem Fall werden zwei Matcap-Texturen in eine gepackt und in Kanäle unterteilt. Das heißt, Metall und Nichtmetall in den Kanälen R bzw. G. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gt/tn/x1/gttnx1bhczfa3fuqiwmgrqegdvk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zwei Matcaps werden für ein Beispiel per Checker interpoliert. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/oj/go/ro/ojgorowglvxcnfsbqns551jwz3e.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis ist eine gewisse Analogie zu Metall und Nichtmetall wie bei der PBR-Schattierung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wollten den Materialien Rauheit und Schmutz hinzufügen, um eine Art Rauheitsanalogon bei der PBR-Schattierung zu erzeugen. Dazu haben wir die Texturierungsmethode verwendet.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mip-Mapping</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Eine Folge von Texturen erzeugt die sogenannte MIP-Pyramide mit einer Auflösung von maximal 1x1. </font><font style="vertical-align: inherit;">Zum Beispiel: 1 × 1, 2 × 2, 4 × 4, 8 × 8, 16 × 16, 32 × 32, 64 × 64, 128 × 128. </font><font style="vertical-align: inherit;">Jede dieser Texturen wird als MIP-Level bezeichnet. </font><font style="vertical-align: inherit;">Um Pixel für Pixel Abnutzungserscheinungen im Shader basierend auf der Maske zu implementieren, müssen Sie den erforderlichen MIP-Pegel auswählen. </font><font style="vertical-align: inherit;">Dies stellt sich folgendermaßen heraus: Wenn das Pixel auf der Maske schwarz ist, der maximale MIP-Pegel in Matcap ausgewählt ist und wenn die Pixelfarbe weiß ist, ist der MIP-Pegel 0. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/r9/33/bw/r933bw4z7ja0uwi4o8uwoomrthe.gif"><br>
<br>
<img src="https://habrastorage.org/webt/7o/k7/n9/7ok7n9zj0oxq3ouidw_kwt9ezww.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Shader ermöglicht es daher, Reflexionen und Glanzlichter zu simulieren, leichte Rauheit und Abnutzungserscheinungen hinzuzufügen. </font><font style="vertical-align: inherit;">Und das alles ohne die Verwendung von Cubemap, ohne komplexe Beleuchtungsberechnungen und andere Techniken, die die Leistung mobiler Geräte erheblich reduzieren.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ga/yr/ur/gayrur5ty9hr3xdfl56duhlcgqi.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einrichten von Substance Painter zum Erstellen eines Shaders</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle verfügbaren Shader in Substance Painter sind in GLSL geschrieben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um einen Shader für Substance Painter zu schreiben, verwende ich den kostenlosen VS-Code. Für die Hervorhebung der Syntax ist es besser, die Shader-Sprachunterstützung für die VS-Code-Erweiterung zu verwenden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fz/xo/iw/fzxoiwxrllvqgwvfammn5uuq7b8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt nur sehr wenig Material über die API in Substance Painter, daher ist die Standarddokumentation in der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hilfe- / Dokumentations- / Shader-API von</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unschätzbarem Wert. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2t/rw/yx/2trwyxswqga9eozdwbk4mmc1ztk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite, was beim Schreiben des Shaders hilft, sind die Standard-Shader in Substance Painter. Um sie zu finden, gehen Sie zu ... </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ Allegorithmic / SubstancePainter / resources / Shelf / Allegorithmic / Shader.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir, den einfachsten unbeleuchteten Shader zu schreiben, der die Grundfarbe anzeigt. Erstellen Sie zunächst eine Textdatei mit der Erweiterung .glsl und schreiben Sie einen so einfachen Shader. Vielleicht, obwohl nichts klar ist, werde ich die Struktur des Shaders in Substance Painter näher erläutern. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mk/ck/rv/mkckrvh6j8r7fz7zh72sjfhylgg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie ein neues Projekt und ziehen Sie den Shader auf Ihre Shell. Im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Import Ihre Ressourcen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dropdown-Liste, </font><font style="vertical-align: inherit;">wählen Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projekt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚project_name‘</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/a0/us/24/a0us24ykiapgfc-ioeuxt7mpckc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist notwendig, damit alle Änderungen aktualisiert werden können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gehen Sie nun zu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fenster / Ansichten / Shader-Einstellungen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und wählen Sie Ihren neuen Shader im angezeigten Fenster aus. Sie können die Suche verwenden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9u/bt/6p/9ubt6padacui5ccb77bgpbywfcg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sehen, dass das gesamte Modell weiß ist und Sie die Grundfarbe darauf zeichnen können, haben Sie alles richtig gemacht. </font><font style="vertical-align: inherit;">Jetzt können Sie das Projekt speichern und mit dem nächsten Abschnitt fortfahren. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jz/ig/wt/jzigwtwpb73uz6s8paesepkcqao.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Modell rosa ist, liegt höchstwahrscheinlich ein Fehler im Shader vor - eine Benachrichtigung darüber wird in der Konsole angezeigt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen eines Shaders in Substance Painter</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie die Struktur eines Shaders am Beispiel des zuvor beschriebenen unbeleuchteten Shaders. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mk/ck/rv/mkckrvh6j8r7fz7zh72sjfhylgg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Schattenmethode ist der grundlegende Teil des Shaders, ohne sie funktioniert sie nicht. Alles, was im Inneren beschrieben wird, kann auf einem 3D-Modell angezeigt werden. Alle endgültigen Berechnungen werden über die Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diffuseShadingOutput ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausgegeben </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Zeilen 3 und 4 erstellen einen Parameter bzw. eine Variable. Der Parameter ordnet den Basisfarbkanal der Variablen zu, in der die gemalte Textur gespeichert wird. Alle Parameter sind in der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hilfe angegeben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , bei der Grundfarbe sollte alles wie im Beispiel angegeben werden. Zeile 8 legt die Textur in den UV-Koordinaten des 3D-Modells fest. Ich stelle fest, dass für die Textur mit Basisfarbe das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sparse Virtual Textures-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> System verwendet wird </font><font style="vertical-align: inherit;">, da die Bibliothek mit der ersten Zeile verbunden ist</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lib-sparce.glsl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können viele Implementierungen von Matcap finden, aber der Hauptpunkt ist, dass die Normalen des Modells auf die Kamera gerichtet sind und die Textur entlang der x- und y-Achse gedreht wird. Um die Normale in Richtung Kamera zu drehen, benötigen wir eine Ansichtsmatrix oder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Matrixtyp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sie finden eine in dem </font><font style="vertical-align: inherit;">oben genannten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zertifikat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/b5/94/ox/b594oxz6c9doiz0sdm2jbzxt6ow.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies sind also die gleichen deklarierten Namen wie im Fall der Grundfarbe. Jetzt müssen wir die Normalen des 3D-Modells erhalten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wg/os/4b/wgos4bygzxftd_sbadht0lqznhy.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Null als viertes Element des Vektors ist erforderlich.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Durch Multiplizieren einer Ansichtsmatrix mit einem Normalenvektor wird die Normalen zur Kamera erweitert. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/bt/c0/tybtc0ibyb9ybigfr5x-tse61ne.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergessen Sie nicht, dass beim Multiplizieren von Matrizen die Reihenfolge der Faktoren wichtig ist. Wenn Sie die Multiplikationsreihenfolge ändern, sind die Ergebnisse unterschiedlich.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können Sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UV-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinaten </font><font style="vertical-align: inherit;">aus </font><i><font style="vertical-align: inherit;">viewNormal erstellen</font></i><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/94/ef/jn/94efjnpw9ingufg9ocbgfdxxnwq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist Zeit, die Matcap-Textur anzuschließen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ed/k3/k8/edk3k848a9wdmfa06dunpn8zrni.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall erstellt der Parameter ein Texturfeld in der Shader-Oberfläche. Wenn das Projekt eine Textur mit dem Namen "Matcap_mip" hat, wird diese von Substance Painter automatisch verschärft. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yl/q5/e0/ylq5e0hbag9jh4bpgj2ro2vot4e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns überprüfen, was passiert ist. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/re/zb/iy/rezbiydl_fat8ornozz67bwjbs0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier wird die Textur von Matcap in neuen Koordinaten erweitert und am Ausgang mit der Grundfarbe multipliziert. Ich möchte darauf achten , </font><font style="vertical-align: inherit;">dass die Matcap Textur durch die erweitert wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textur ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">und Grundfarbe - durch die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">textureSparse ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">. Dies liegt daran, dass die über die Shader-Oberfläche angegebenen Texturen nicht vom Typ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SamplerSparse sein können</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis sollte ungefähr so ​​aussehen:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/l7/v1/rq/l7v1rqhspgrp92iuffebw2-jmua.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen Sie nun eine Maske hinzu, die zwei Matcaps mischt. Fügen Sie der Einfachheit halber zwei Matcap'a in einer Textur hinzu und teilen Sie sie in Kanäle auf. Infolgedessen befinden sich zwei Matcap-Texturen in den Kanälen R bzw. G. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird sich ungefähr so ​​herausstellen: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/a-/nr/ih/a-nrih00ttqwnk6ewdv-pbhq9yo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir damit, dem Shader eine Maske hinzuzufügen. Das Prinzip ähnelt dem Hinzufügen der Grundfarbe. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tt/lv/jf/ttlvjfnodtzhu_qp_mpq-oqfpga.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es reicht aus, den Basisfarbenwert im Parameter durch user0 zu ersetzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Holen Sie sich nun den Maskenwert in den Pixel-Shader und mischen Sie die Matcap-Texturen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/42/sr/pa42srwn-29afh50di07sepap_w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier wird nur der R-Kanal in der Maske verwendet, da dieser schwarzweiß ist. Die beiden Matcap-Kanäle werden mit der Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mix ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gemischt </font><font style="vertical-align: inherit;">, einem Analogon von lerp in Unity. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns den Shader aktualisieren und benutzerdefinierte Kanäle in die Benutzeroberfläche einfügen. Gehen Sie dazu zu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fenster / Ansichten / Textur-Set-Einstellungen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klicken Sie im Fenster neben der Überschrift Kanäle auf das Pluszeichen und wählen Sie Benutzer0 aus der großen Liste aus. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/0t/v0/mo/0tv0mo6ovcvfztcawlrhbzrhzbs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Kanal kann beliebig aufgerufen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie nun auf diesem Kanal zeichnen, können Sie sehen, wie die beiden Matcap-Texturen gemischt werden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ri/jq/nu/rijqnu1-0utez7t0babbdv11--s.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Shader für Unity verwendete auch normale Karten für Matcap, die aus einem High-Poly-Modell gebacken wurden. Versuchen wir, dasselbe in Substance Painter zu tun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um alle Operationen für Normalen zu verwenden, müssen Sie die entsprechende </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliothek verbinden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6f/zz/z3/6fzzz36x9epa7a34gew0hcq-fro.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt verbinden wir die normalen Karten. In Substance Painter gibt es zwei davon: Eine wird durch Backen erhalten, und die zweite kann gezeichnet werden. </font><i><font style="vertical-align: inherit;">Anhand</font></i></font><br>
<br>
<img src="https://habrastorage.org/webt/hw/7q/86/hw7q86rpk52sdkyygjo32vufv5s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
der Parameter können Sie erraten, dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">channel_normal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine normale Karte ist, nach der Sie zeichnen können, und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">textur_normal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- gebackene normale Karte. Ich </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stelle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auch fest, dass der Variablenname </font><i><font style="vertical-align: inherit;">textur_normal</font></i><font style="vertical-align: inherit;"> in die API eingebettet </font><i><font style="vertical-align: inherit;">ist</font></i><font style="vertical-align: inherit;"> und Sie ihn nicht nach eigenem Ermessen benennen können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes entpacken Sie die Karten im Pixel-Shader: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yq/wx/sv/yqwxsvn2ohvouv-rwzui9blzp6q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann mischen wir die normalen Karten und Normalen, die sich auf den Scheitelpunkten des Modells befinden. Zu diesem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweck</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gibt es in der oben verbundenen Bibliothek eine </font><i><font style="vertical-align: inherit;">normalBlend ()</font></i><font style="vertical-align: inherit;"> -Funktion </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2y/r0/zs/2yr0zsobknqtlz7ooj_6xd4onsg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst mischen wir die beiden normalen Karten und dann die normalen Normalen. Obwohl es nicht wirklich wichtig ist, in welcher Reihenfolge sie gemischt werden sollen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Drehung der Normalen in Blickrichtung der Kamera sieht folgendermaßen aus: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yc/bl/mt/ycblmti7x5nhbfhdlx6yyrqyl4o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann können Sie nichts ändern, alles bleibt gleich. Es sollte ungefähr so ​​sein:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gm/ny/za/gmnyza2j-simray-86frype0usa.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie oben erwähnt, ist in diesem Fall eine Mip-Zuordnung erforderlich, um Abnutzungserscheinungen zu simulieren, ähnlich einer Rauheitskarte bei der PBR-Schattierung. Das Hauptproblem ist jedoch, dass die Pyramide aus Mip-Karten nicht für die Textur generiert wird, die von der Shader-Schnittstelle übertragen wird, und dementsprechend </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktioniert die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode </font><i><font style="vertical-align: inherit;">textureLod ()</font></i><font style="vertical-align: inherit;"> von glsl nicht. Man könnte in die andere Richtung gehen und die Matcap-Textur über den Benutzerkanal laden, wie dies beim Mischen von Matcaps der Fall war. Aber dann nimmt die Qualität der Textur stark ab und es erscheinen seltsame Artefakte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine alternative Lösung besteht darin, eine </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Pyramide von MIP-Karten</font></a><font style="vertical-align: inherit;"> zu erstellen</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manuell in Adobe Photoshop oder einem anderen ähnlichen Editor und wählen Sie dann die MIP-Stufe aus. Die Pyramide ist ganz einfach gebaut. Es ist notwendig, von der Größe der ursprünglichen Textur auszugehen - in meinem Fall ist es 256x256. Wir erstellen eine Datei mit einer Größe von 384 x 256 (384, weil 256 + 256/2) und reduzieren jetzt die ursprüngliche Textur um die Hälfte, bis sie ein Pixel groß ist. Alle Versionen reduzierter Texturen werden in aufsteigender Reihenfolge rechts von der ursprünglichen Textur platziert. Es sollte folgendermaßen aussehen: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sg/h-/qw/sgh-qwq1kmwq_gh7hgkg1l8fnxq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können Sie eine Funktion schreiben, die die Koordinaten jeder Textur in der Pyramide in Abhängigkeit von der Farbe jedes Pixels auf der Maske ermittelt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am einfachsten ist es, die UV-Koordinaten, die für jede Textur berechnet werden, in einem Array zu speichern. Die Größe des Arrays wird als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">log2 (Höhe) bestimmt.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir brauchen die ursprüngliche </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , also fügen wir sie dem Funktionsargument hinzu. Fügen Sie </font><font style="vertical-align: inherit;">dem Funktionsargument </font><font style="vertical-align: inherit;">eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ebene</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hinzu, um zu bestimmen, welches Array-Element für ein bestimmtes Pixel verwendet werden soll </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hq/ox/um/hqoxumpnar903hkoghv3hgtfzr4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berechnen Sie nun UV für die ursprüngliche Textur, dh schneiden Sie diese zusätzlichen 128 Pixel in der Breite zu. Multiplizieren Sie dazu die x-Koordinate mit ⅔. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ho/or/nh/hoornhxxr9w2yj_bgr8ckt9rdw8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Rest der Textur aus der Pyramide zu verwenden, müssen Sie Muster finden. Als wir die Pyramide aus den Texturen erstellten, konnten wir feststellen, dass die Textur jedes Mal um die Hälfte gegenüber der vorherigen Größe reduziert wurde. Das heißt, wie oft die Texturgröße abnimmt, können Sie bestimmen, indem Sie 2 auf die Leistung des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MIP-Pegels</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erhöhen </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9i/yk/6k/9iyk6k9udtbo2gyundt8erj8a0q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich heraus, dass die Textur um das 16-fache abnimmt, wenn Sie Stufe 4 auswählen. Als</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UV-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinaten werden von 0 bis 1 bestimmt, dann muss die Größe normalisiert werden, dh 1 geteilt durch die Häufigkeit, mit der die Textur abgenommen hat, z. B. 1 geteilt durch 16. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dem erhaltenen Wert der Größenvariablen können Sie die Koordinaten für einen bestimmten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MIP-Pegel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berechnen </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/we/cv/kh/wecvkhragapkffyxyussvrbgkes.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Größe von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UV wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf die gleiche Weise reduziert wie die Größe der Textur. An der x-Koordinate verschiebt sich die Textur immer um ⅔. Die y - </font><font style="vertical-align: inherit;">Koordinatenverschiebung kann als die Summe aller Werte der definiert wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Größe</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> variabel </font><font style="vertical-align: inherit;">für jeden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Level</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Wert </font><font style="vertical-align: inherit;">. Das heißt, wenn der Wert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">level = 1 ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , verschiebt sich uv in der y-Koordinate um 0 Pixel, und wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">level = 2 ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ist die Verschiebung halb so hoch wie die Textur - 128 Pixel. Wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Level = 3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann stellt sich heraus, dass die Verschiebung 128 + 64 Pixel beträgt und so weiter. Die Summe aller Verschiebungen kann unter Verwendung des Zyklus erhalten werden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/fl/wi/njflwi83bfg42lecjugixw2xrr8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei jeder Iteration </font><font style="vertical-align: inherit;">addiert sich </font><font style="vertical-align: inherit;">die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versatzvariable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und verschiebt die Textur entlang der y-Achse um die gewünschte Anzahl von Pixeln. Der Schritt-für-Schritt-Algorithmus sieht ungefähr so ​​aus: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jc/cd/ll/jccdllnuvqh288742jsx21jtbme.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der letzte Schritt besteht darin, einen Kanal anzuzeigen, der </font><font style="vertical-align: inherit;">bei jedem Pixel </font><font style="vertical-align: inherit;">den gewünschten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pegel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auswählt </font><font style="vertical-align: inherit;">. Wir haben das schon gemacht, nichts Neues. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/no/sh/4d/nosh4drvum-rq3fif1mh2qdif_0.png"><br>
<br>
<img src="https://habrastorage.org/webt/vg/-5/w0/vg-5w0rym_gpaygfgzhtkubfxly.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MIP-Ebene</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als Textur </font><font style="vertical-align: inherit;">auszuwählen </font><font style="vertical-align: inherit;">, multiplizieren Sie einfach die Länge des Arrays mit der Textur. Jetzt können Sie neue UV-Koordinaten über die gerade geschriebene Methode verbinden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/af/-h/1a/af-h1agpkidgfd7153wgsfgltaa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergessen Sie nicht, die Textur in den Typ int zu übersetzen, da dies jetzt ein Index für das Array ist.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Nächstes müssen Sie wie zuvor einen benutzerdefinierten Kanal in Substance Painter hinzufügen. Es sollte so aussehen: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qc/4p/h4/qc4ph4jzivfdrtqd5w4dqtn0ojw.gif"><br>
<br>
<img src="https://habrastorage.org/webt/mp/s4/1c/mps41cvu0dlu_kqkkv7qkrtmb5m.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das einzige, was dem Shader fehlt, ist die Lichtquelle und die Fähigkeit, sie durch Drücken der Umschalttaste zu drehen. Dazu benötigen wir zunächst einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der den Drehwinkel durch Drücken von Shift und die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rotationsmatrix erzeugt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xy/g_/y1/xyg_y1vvg_rhtoxwuepokzrp9x0.png"><br>
<br>
<img src="https://habrastorage.org/webt/ny/17/df/ny17dfcnyibmvgvfx8pbphsxkom.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir platzieren die Lichtquelle zufällig und multiplizieren die Position mit der Rotationsmatrix. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bo/gi/fp/bogifpq90um2ygho-bgv0zdvy7a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt dreht sich die Lichtquelle durch Drücken der Umschalttaste um die y-Achse. Bisher ist dies jedoch nur ein Vektor, in dem die Position der Lichtquelle gespeichert ist. Es gibt </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gute Sachen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie man gerichtetes Licht in einen Shader implementiert. </font><font style="vertical-align: inherit;">Wir werden uns auf ihn konzentrieren. </font><font style="vertical-align: inherit;">Es bleibt uns überlassen, die Lichtrichtung und die Beleuchtung unseres Modells zu bestimmen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ok/a4/df/oka4dfn33tv1t2meohooiu9fz2k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Farbe des Schattens und die Farbe der Lichtquelle werden durch die Parameter eingestellt: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mr/zs/km/mrzskmiirmqmddlhwwg59ab_mpm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Farbparameter werden gemäß der oben berechneten Beleuchtung interpoliert. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c4/ci/8h/c4ci8hm54ul19f-lg92oox2t7li.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird folgendermaßen aussehen: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dp/rx/s9/dprxs9gy7_jaw4p3lu_ux7a9xbi.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit diesen Parametern können Sie die Farbe des Schattens und die Farbe der Lichtquelle über die Substance Painter-Oberfläche anpassen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ws/o8/e3/wso8e3nnmdky15efibtajhj0rya.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen und konfigurieren Sie eine Voreinstellung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Shader fertig ist, müssen Sie die Matcap-Textur und den Shader mit der Regaleinstellung importieren. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hg/w2/wh/hgw2wh4tdzd6i1l4hgcpi8iebpk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir entfernen alle nicht verwendeten Kanäle und fügen Benutzerkanäle hinzu: Die </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hl/qs/xe/hlqsxepohrs1j0hbrlkeghgch5g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voreinstellung für den Export von Texturen sieht wie jede andere aus, außer dass unsere benutzerdefinierten Kanäle verwendet werden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zp/xf/7o/zpxf7oje5map2cl0gurvpustk7u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erstellen eine Vorlage für alle Einstellungen, sodass beim Erstellen des Projekts sofort der gewünschte Shader zugewiesen und alle Texturkanäle konfiguriert werden. </font><font style="vertical-align: inherit;">Gehen Sie dazu zu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datei / SaveAsTemplate</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und speichern Sie die Vorlage. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pb/xn/aq/pbxnaqjvwraborjnospf8rglc10.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie jetzt ein neues Projekt erstellen, müssen Sie nichts konfigurieren - wählen Sie einfach die gewünschte Vorlage aus.</font></font></b><br>
<br>
<img src="https://habrastorage.org/webt/hh/xw/by/hhxwbyfzcemnynsqglcabzbgzto.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was hast du bekommen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein technischer Künstler kann Spezialeffekte erstellen, Szenen anpassen und Renderprozesse optimieren. </font><font style="vertical-align: inherit;">Ich wollte auch, dass die Rüstungs- und Waffenmodelle in Stormfall: Saga of Survival genau das sind, was 3D-Künstler beabsichtigten. </font><font style="vertical-align: inherit;">Infolgedessen sieht das 3D-Modell in Substance Painter genauso aus wie in der Spiel-Engine. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/x_/ic/qr/x_icqrlq2s3_osfrps5c-0qttwo.gif"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3D-Modell in Substance Painter mit benutzerdefinierter Schattierung. </font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/7e/79/sg/7e79sgwszeyazecwzi18j2fhv4s.gif"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3D-Modell in Unity mit benutzerdefinierter Schattierung. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, der Artikel war nützlich und hat Sie zu neuen Errungenschaften inspiriert!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de501968/index.html">MVI-Architekturvorlage in Kotlin Multiplattform, Teil 1</a></li>
<li><a href="../de501970/index.html">Was brauchst du, um einen guten Dungeon in RPG zu erstellen?</a></li>
<li><a href="../de501976/index.html">So lernen Sie, Software zu testen</a></li>
<li><a href="../de501978/index.html">Wie funktioniert das Prometheus-Histogramm?</a></li>
<li><a href="../de501980/index.html">Die Geschichte eines Projekts oder wie ich 7 Jahre PBX basierend auf Asterisk und Php erstellt habe</a></li>
<li><a href="../de501984/index.html">Was gibt es in Quarantäne zu sehen? Eine Auswahl von Materialien aus Technostream (Teil 4)</a></li>
<li><a href="../de501986/index.html">Geheimnisse des unglaublichen Erfolgs von Apple AirPods</a></li>
<li><a href="../de501988/index.html">Wie wird der VK-Nachrichtenbildschirm gerendert?</a></li>
<li><a href="../de501990/index.html">Nützlicher Beitrag: 4 Ereignisse, um die Probleme des zweiten Tages in OpenShift zu lösen und Operatoren zu erstellen</a></li>
<li><a href="../de501992/index.html">So organisieren Sie Tests, um Produktfreigaben zu beschleunigen und zu stabilisieren. Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>