<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♎️ 📓 🙎🏿 Qtでの適切なスレッド 💾 🌘 🤽🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="QtはC ++の非常に強力で便利なフレームワークです。しかし、この利便性には欠点があります。Qtの多くのことはユーザーから隠されています。ほとんどの場合、Qtの対応する機能は「魔法のように」機能し、ユーザーにこの魔法を当然のことと見なすように教えます。しかし、それでも魔法が解けると、一見平らなところ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Qtでの適切なスレッド</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467261/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QtはC ++の非常に強力で便利なフレームワークです。</font><font style="vertical-align: inherit;">しかし、この利便性には欠点があります。Qtの多くのことはユーザーから隠されています。</font><font style="vertical-align: inherit;">ほとんどの場合、Qtの対応する機能は「魔法のように」機能し、ユーザーにこの魔法を当然のことと見なすように教えます。</font><font style="vertical-align: inherit;">しかし、それでも魔法が解けると、一見平らなところに突然現れた問題を認識して解決するのが非常に難しくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、Qtの「内部」実装がフローでどのように機能するかを体系化する試みであり、このモデルの制限に関連する明らかでない落とし穴の数についてです。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">スレッドアフィニティの</font></a></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、初期化、およびそれらの制限</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メインスレッド、QCoreApplication、およびGUI </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリングスレッド</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></a><br>
<br>
<a name="habracut"></a><a name="part1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基礎</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本から始めましょう。 Qtでは、シグナルとスロットを処理できるオブジェクトはすべてQObjectクラスの子孫です。これらのオブジェクトは設計上コピー不可であり、互いに「対話」するいくつかの個別のエンティティを論理的に表します。特定のイベントに反応し、それ自体がイベントを生成できます。言い換えると、QtのQObjectは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actorsパターンを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。適切に実装されていれば、Qtプログラムは基本的に、すべてのプログラムロジックが「存続」する、相互に作用し合うQObjectのネットワークにすぎません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
QObjectsのセットに加えて、Qtプログラムにはデータオブジェクトを含めることができます。これらのオブジェクトは信号を生成および受信できませんが、コピーすることはできます。たとえば、QStringListとQStringListModelを比較できます。それらの1つはQObjectであり、コピーできませんが、UIオブジェクトと直接対話できます。もう1つは、通常のコピー可能なデータコンテナーです。次に、データを持つオブジェクトは、「Qtメタタイプ」とその他すべてに分割されます。たとえば、QStringListはQtメタタイプですが、std :: list &lt;std :: string&gt;（追加のジェスチャーなし）はそうではありません。前者は任意のQt-shnomコンテキスト（信号を介して送信される、QVariantにあるなど）で使用できますが、特別な登録手順が必要であり、クラスにはパブリックデストラクタ、コピーコンストラクタ、およびデフォルトコンストラクタが必要です。 2番目は任意のC ++型です。</font></font><br>
<br>
<a name="part2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際のスレッドにシームレスに進みます</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、条件付きの「データ」があり、それらと連携する条件付きの「コード」があります。</font><font style="vertical-align: inherit;">しかし、実際にこのコードを実行するのは誰ですか？</font><font style="vertical-align: inherit;">Qtモデルでは、この質問に対する答えが明示的に設定されています。各QObjectは、実際にはこのオブジェクトのスロットや他のイベントのサービスに従事しているQThreadスレッドに厳密に関連付けられています。</font><font style="vertical-align: inherit;">1つのスレッドが一度に多数のQObjectを処理することも、まったく処理しないこともありますが、QObjectには常に親スレッドがあり、常に1つです。</font><font style="vertical-align: inherit;">実際、各QThreadはQObjectのセットを「所有」していると想定できます。</font><font style="vertical-align: inherit;">Qtの用語では、これはスレッドアフィニティと呼ばれます。</font><font style="vertical-align: inherit;">わかりやすくするために視覚化してみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zs/py/t2/zspyt2yti1t8-mr6k708rer0rao.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各QThreadの内部には、このQThreadが「所有する」オブジェクトにアドレス指定されたメッセージのキューがあります。 Qtモデルでは、QObjectに何らかのアクションを実行させる場合、QEventメッセージをこのQObjectに「送信」すると想定しています。</font></font><br>
<br>
<pre><code class="cpp hljs">QCoreApplication::postEvent(QObject *receiver, QEvent *event, <span class="hljs-keyword">int</span> priority);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このスレッドセーフな呼び出しで、Qtはレシーバーオブジェクトが属するQThreadを見つけ、QEventをこのスレッドのメッセージキューに書き込み、必要に応じてこのスレッドを起動します。その後のある時点でこのQThreadで実行されているコードがキューからメッセージを読み取り、対応するアクションを実行することが期待されています。これを実際に行うには、QThreadのコードが適切なオブジェクトを作成し、exec（）メソッドまたはprocessEvents（）メソッドのいずれかを呼び出すことにより、QEventLoopイベントループに入らなければなりません。最初のオプションは（QEventLoopがquit（）イベントを受け取る前に）無限のメッセージ処理ループに入り、2番目のオプションは以前にキューに蓄積されたメッセージの処理に制限されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8x/ia/6o/8xia6o7i8wf0q5hoxkvzdjsl9xq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つのスレッドに属するすべてのオブジェクトのイベントが順次処理されることは簡単にわかります。</font><font style="vertical-align: inherit;">スレッドによるイベントの処理に時間がかかる場合、他のすべてのオブジェクトは「凍結」されます。それらのイベントはストリームキューに蓄積されますが、処理されません。</font><font style="vertical-align: inherit;">これが起こらないようにするために、Qtは協調的なマルチタスクの可能性を提供します-新しいQEventLoopを作成して制御を渡すことにより、どこでもイベントハンドラーが「一時的に中断」できます。</font><font style="vertical-align: inherit;">イベントハンドラーもストリームのQEventLoopから以前に呼び出されていたため、このアプローチでは、互いに「ネストされた」イベントループのチェーンが形成されます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントディスパッチャーについて一言</font></font></b><div class="spoiler_text"> , QEventLoop —           -    Event Dispatcher    QAbstractEventDispatcher.        .       QAbstractEventDispatcher     .      Qt5      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">    </a>   1             QEventLoop. </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなサイクルで処理される「イベント」の概念には何が含まれていますか？</font><font style="vertical-align: inherit;">すべてのQt従業員によく知られている「シグナル」は、QEvent :: MetaCallの1つの特定の例にすぎません。</font><font style="vertical-align: inherit;">このようなQEventは、呼び出す必要のある関数（スロット）とその引数を識別するために必要な情報へのポインターを格納します。</font><font style="vertical-align: inherit;">ただし、Qtのシグナルに加えて、約100の（！）他のイベントもあり、そのうちの12は特別なQtイベント（ChildAdded、DeferredDelete、ParentChange）のために予約されており、残りはオペレーティングシステムからのさまざまなメッセージに対応しています。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜそんなにたくさんあるのか、そして単に信号だけではうまくいかないのですか？</font></font></b><div class="spoiler_text">    :                  ?          -.      compressible —           ( QEvent::Paint),      .      (filtered out).        QEvent    .    QEvent              .</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで明らかでない落とし穴の1つは、Qtでは、一般的に言えば、ストリームにDispatcherがなく、EventLoopがないことです。このストリームに属するオブジェクトは、送信されたイベントに応答しません。 QThread :: run（）はデフォルトでQThread :: exec（）を呼び出すため、内部に標準のEventLoopが実装されているだけなので、QThreadから継承する独自のrun（）のバージョンを決定しようとする人は、しばしばこの問題に直面します。 QThreadの同様の使用例は、原則として非常に有効であり、ドキュメントでも推奨されていますが、上記のQtでコードを編成するという一般的な考えに反し、</font><i><font style="vertical-align: inherit;">期待どおりに</font></i><font style="vertical-align: inherit;">機能しないことがよくあります</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Facebookユーザー。この場合の典型的な間違いは、QThread :: exit（）またはquit（）を呼び出して、そのようなカスタムQThreadを停止しようとしたことです。これらの関数はどちらもQEventLoopにメッセージを送信しますが、ストリームに単にQEventLoopがない場合は、当然、それらを処理する人がいません。その結果、「壊れたクラスを修正」しようとする経験の浅いユーザーは、「機能する」QThread :: terminateを使用しようとし始めますが、これは絶対に不可能です。覚えておいてください-run（）を再定義し、標準のイベントループを使用しない場合は、ストリームに自分で終了するメカニズムを提供する必要があります。たとえば、特別に追加されたQThread :: requestInterruption（）関数を使用します。しかし、より正確です特別な新しい種類のスレッドを実際に実装する予定がなく、そのようなスクリプト用に特別に作成されたQtConcurrentを使用するか、QObjectから継承された特別なWorkerオブジェクトにロジックを配置し、後者を標準のQThreadに配置してWorkerを管理する場合は、QThreadから継承しないでください。信号を使用します。</font></font><br>
<br>
<a name="part3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドアフィニティ、初期化、およびそれらの制限</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、すでに理解しているように、Qtの各オブジェクトはいくつかのストリームに「属しています」。</font><font style="vertical-align: inherit;">同時に、論理的な問題が発生します。実際、どちらに正確なのでしょうか。</font><font style="vertical-align: inherit;">Qtでは次の規則が受け入れられ</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.「親」のすべての「子」は常に親と同じストリームに住んでいます</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはおそらくQtストリームモデルの最も強力な制限であり、それを壊そうとすると、ユーザーに非常に奇妙な結果をもたらすことがよくあります。たとえば、Qtの別のスレッドにあるオブジェクトでsetParentを作成しようとすると、単に警告なしに失敗します（コンソールに警告が表示されます）。どうやら、別のスレッドに住んでいる親が死亡した場合にスレッドセーフな「子供」を削除することは非常に重要であり、バグを捕らえにくい傾向があるため、妥協点に達したようです。異なるストリームに存在する相互作用するオブジェクトの階層を実装する場合は、自分で削除を整理する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.作成時に親が指定されていないオブジェクトは、それを作成したストリームに存在します</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここにあるすべてが同時に、単純かつ同時に明らかであるとは限りません。たとえば、このルールのおかげで、（オブジェクトとしての）QThreadは、それ自体が制御するスレッドとは別のスレッドに住んでいます（ルール1のおかげで、このスレッドで作成されたオブジェクトを所有できません）。または、QThread ::を再定義し、内部でQObjectの子孫を作成して作成した場合、（前の章で説明したように）特別な対策を講じないと、作成されたオブジェクトはシグナルに応答しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドアフィニティは、必要に応じてQObject :: moveToThreadを呼び出して変更できます。</font><font style="vertical-align: inherit;">ルール1により、移動できるのは最上位の「親」（親== nullの場合のみ）であり、「子」を移動しようとしても黙って無視されます。</font><font style="vertical-align: inherit;">上位レベルの「親」を移動すると、彼のすべての「子供」も新しいストリームに移動します。</font><font style="vertical-align: inherit;">不思議なことに、moveToThread（nullptr）の呼び出しも有効であり、「null」のスレッドアフィニティを持つオブジェクトを作成する方法です。</font><font style="vertical-align: inherit;">このようなオブジェクトはメッセージを受信できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトが関連付けられているスレッドであるQThread :: currentThread（）関数を呼び出して、「現在の」実行スレッドを取得できます-QObject :: thread（）を呼び出します</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意力に関する興味深い質問</font></font></b><div class="spoiler_text">          QEvent-, ,    -   .    Qt           QThread.      QObject  - std::thread       QThread::currentThread()?      Qt   « »    - QAdoptedThread.                   ,      . <br>
</div></div><br>
<a name="part4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メインスレッド、QCoreApplicationおよびGUI</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのスレッドの中で、Qtは必ず1つの「メイン」スレッドを選び出します。これは、UIアプリケーションの場合はGUIスレッドにもなります。 QApplicationオブジェクト（QCoreApplication / QGuiApplication）はこのスレッドにあり、オペレーティングシステムからのメッセージを処理するためのメインイベントループを提供します。前のセクションのルール2のおかげで、「メイン」スレッドは実際にQApplicationオブジェクトを作成したスレッドになります。多くのオペレーティングシステムでは「メインスレッド」に特別な意味があるため、ドキュメントでは、全体の最初のオブジェクトでQApplicationを作成することを強くお勧めしますQtプログラムを実行し、アプリケーションを起動した直後に実行します（==プロセスの最初のスレッド内）。アプリケーションのメインスレッドへのポインターを取得するには、QCoreApplication ::形式のデザインを適宜使用できます。インスタンス（）-&gt;スレッド（）。ただし、純粋に技術的にはQApplication</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">メイン（）以外のスレッド</font></a><font style="vertical-align: inherit;">で</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ハングアップすることもできます。</font></a><font style="vertical-align: inherit;">たとえば、Qtインターフェースがある種のプラグイン内に作成されていれば、多くの場合これで問題あり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ません</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「作成されたオブジェクトは現在のスレッドを継承する」というルールにより、1つのスレッドの制限を超えずにいつでも安全に作業できます。作成されたすべてのオブジェクトは、自動的にサービスの「メイン」スレッドに移動します。そこでは常にイベントループがあり、（他のスレッドが存在しないため）同期に問題はありません。マルチスレッドを必要とするより複雑なシステムを使用している場合でも、他の場所に明示的に配置される少数のオブジェクトを除いて、ほとんどのオブジェクトはメインストリームに分類される可能性があります。おそらくこれは、オブジェクトが何の努力もせずに独立して機能しているように見える（見た目は協調的マルチタスクがフロー内に実装されているため）同時に、同期やブロックなどを必要としない（すべてが1つのスレッドで発生するため） ）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「メイン」スレッドが「最初の」スレッドであり、メインのQCoreApplicationイベント処理ループが含まれているという事実に加えて、Qtのもう1つの制限は、GUIに接続されたすべてのオブジェクトがこのスレッドで「ライブ」でなければならないことです。これは一部レガシーの結果です。一部のオペレーティングシステムでは、GUIを使用した操作はメインスレッドでのみ実行できるため、Qtはすべてのオブジェクトを「ウィジェット」と「非ウィジェット」に分割します。ウィジェットタイプのオブジェクトはメインスレッドにのみ存在できます。他のオブジェクトでそのようなオブジェクトを「上回る」試みは自動的にフレアします。このため、特別なQObject :: isWidgetType（）メソッドでさえ、そのようなオブジェクトを操作するメカニズムのかなり深い内部の違いを反映しています。しかし興味深いのは、はるかに新しいQtQuickでは、isWidgetTypeを持つ松葉杖が同じ問題を回避しようとしたところ、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何か問題でもありますか？ Qt5では、QMLオブジェクトはウィジェットではなくなり、別のスレッドでレンダリングできます。しかし、これは別の問題につながりました-同期の難しさ。 UIオブジェクトのレンダリングは、それらの状態の「読み取り」であり、一貫している必要があります。レンダリングと同時にオブジェクトの状態を変更しようとすると、結果の「競合」の結果が気に入らない場合があります。さらに、「新しい」グラフィックQtが構築されているOpenGLは、描画コマンドの形成がいくつかのグローバルな状態（一連の順次操作としてのみ変更できる「グラフィックコンテキスト」）で動作する1つのスレッドによって実行されるという事実に対して、非常に「シャープ」です。画面上に2つの異なるグラフィックオブジェクトを同時に描画することはできません。常に、次々に順番に描画されます。その結果、同じソリューションに戻ります-UIのレンダリングが1つのスレッドに割り当てられます。ただし、注意深い読者は、このスレッドがメインスレッドである必要がないことに気づくでしょう。Qt5では、フレームワークはこのために別のレンダリングスレッドを使用しようとします。</font></font><br>
<br>
<a name="part5"></a><h3>Rendering thread</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいQt5モデルのフレームワークでは、オブジェクトのすべてのレンダリングは、このレンダリングスレッドに特別に割り当てられたスレッドで行われます。同時に、これが意味をなし、「メイン」ストリームから別のストリームへの単純な移行に限定されないように、オブジェクトは暗黙的にプログラマーが見る「フロントエンド」と通常は実際に実際のレンダリングを実行する「バックエンド」に分割されます。バックエンドはレンダリングスレッドに存在しますが、フロントエンドは理論的には他の任意のスレッドに存在できます。フロントエンドがイベント処理の形で有用な作業（ある場合）を実行することが想定されていますが、バックエンド機能はレンダリングによってのみ制限されます。理論的には、双方にメリットがあることがわかります。バックアップは定期的にオブジェクトの現在の状態を「ポーリング」し、画面に描画します。同時に、この遅い処理は別のスレッドで行われるため、イベントの処理中にオブジェクトの一部が「考えすぎ」たという事実によって「停止」することはできません。次に、オブジェクトのストリームは、レンダリングの完了を確認するグラフィックスドライバーからの「応答」を待つ必要がなく、さまざまなオブジェクトがさまざまなストリームで動作できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、前の章ですでに述べたように、データを作成するストリーム（フロント）とそれを読み取るストリーム（バック）があるため、何らかの形でそれらを同期する必要があります。 Qtでのこの同期はロックによって行われます。フロントが存在するストリームは一時的に中断され、その後に特別な関数呼び出し（QQuickItem :: updatePaintNode（）、QQuickFramebufferObject :: Renderer :: synchronize（））が続きます。その唯一のタスクは、視覚化に関連するオブジェクトをフロントからバックにコピーすることです。 」同時に、そのような関数の呼び出しは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリングスレッド内で</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発生</font><font style="vertical-align: inherit;">しますが、この時点でオブジェクトが存在するスレッドが停止しているため、ユーザーはオブジェクトが属するストリーム内で、「通常どおり」発生したかのように、オブジェクトのデータを自由に操作できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべて大丈夫ですか、すべて大丈夫ですか？残念ながら、いいえ、そしてまったく自明でない瞬間がここから始まります。オブジェクトごとに個別にロックをかけると、レンダリングスレッドはこれらのオブジェクトがイベントの処理を完了するまで強制的に待機するため、かなり遅くなります。ストリームは、オブジェクトが存在する場所で「ハング」し、「ハング」してレンダリングされます。さらに、2つのオブジェクトが同時に変更されたときに、一方がフレームNに描画され、もう一方がフレームN + 1にのみ描画される場合、「非同期」が可能になります。すべてのオブジェクトに対して一度に、このロックが成功することが確実な場合にのみ、ロックを一度だけ取得することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qtでこの問題を解決するために何が実装されましたか？まず、1つのウィンドウのすべての「グラフィック」オブジェクトが1つのストリームに存在することが決定されました。したがって、ウィンドウを描画し、ウィンドウに含まれるすべてのオブジェクトをロックするには、このストリームを単独で停止するだけで十分です。次に、UIオブジェクトを含むスレッドは、バックエンドを更新するためのロックを開始し、同期する必要があることを示すメッセージをレンダリングスレッドに送信し、それ自体を停止します（誰かが興味を持っている場合はQSGThreadedRenderLoop :: polishAndSync）。これにより、レンダリングスレッドがフロントエンドストリームを「待機」することがなくなります。突然「ハング」した場合-レンダリングスレッドは、更新の必要性に関するメッセージを受信せずに、オブジェクトの「古い」状態を描画し続けるだけです。これは、「なんらかの理由でレンダリングがすぐにウィンドウを描画できない場合、メインスレッドがフリーズする」という形の非常に面白いバグを本当に引き起こしますが、一般的にはそれは妥当な妥協です。 QtQuick 2.0以降</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メインスレッドが「考えている」場合でもアニメーションが機能し続けることができるように、レンダースレッド</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">で「アニメーション化された」オブジェクトの数を「設定」する</font></a><font style="vertical-align: inherit;">こともできます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bc0/250/3da/bc02503da9d76ff4b66ae038ce3cf81f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、このソリューションの実際的な結果は、すべてのUIオブジェクトがとにかく同じスレッドに存在する必要があることです。古いウィジェットの場合、「メイン」スレッド、新しいQt Quickオブジェクトの場合、それらを所有するQQuickWindowオブジェクトスレッド。最後のルールはかなり洗練されています。QQuickItemを描画するには、対応するQQuickWindowにsetParentを作成する必要があります。これにより、すでに説明したように、オブジェクトが対応するストリームに移動するか、setParent呼び出しが失敗します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今、悲しいことに、軟膏のハエ：異なるQQuickWindowは理論的には異なるストリームに住んでいる可能性がありますが、実際には、これにはオペレーティングシステムからそれらへのメッセージの正確な送信が必要であり、現在のQtでは実装されていません。たとえば、Qt 5.13では、QCoreApplicationはsendEventを介してQQuickWindowと通信しようとしますが、受信者と送信者が同じスレッドにある必要があります（スレッドを異なるようにするpostEventではなく）。したがって、実際には、QQuickWindowはGUIスレッドでのみ正しく機能し、その結果、すべてのQtQuickオブジェクトは同じ場所に存在します。その結果、レンダリングスレッドが存在するにもかかわらず、ユーザーが使用できるほぼすべてのGUI関連オブジェクトは、同じGUIスレッドに残っています。おそらくこれはQt 6で変更されるでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記に加えて、Qtは多くの異なるプラットフォーム（マルチスレッドをサポートしていないプラットフォームを含む）で動作するため、フレームワークは適切な数のフォールバックを提供し、場合によってはレンダリングスレッド機能が実際には同じGUIスレッドによって実行されることも覚えておく価値があります。</font><font style="vertical-align: inherit;">この場合、レンダリングを含むUI全体が1つのスレッドに存在し、同期の問題は自動的に解消されます。</font><font style="vertical-align: inherit;">状況は、以前のQt4スタイルのウィジェットベースのUIと似ています。</font><font style="vertical-align: inherit;">必要に応じて、環境変数QSG_RENDER_LOOPを適切なオプションに設定することにより、Qtをこの「シングルスレッド」モードで動作させることができます。</font></font><br>
<br>
<a name="part6"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qtは巨大で複雑なフレームワークであり、その中でスレッドを操作することは、この複雑さの一部を反映しています。</font><font style="vertical-align: inherit;">しかし、それは非常に注意深く、論理的かつ適切に設計されたため、Qtのフローを使用していくつかの重要なアイデアを理解すると、間違いなく作業するのは非常に簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要点をもう一度思い出させてください。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各オブジェクトには、それを所有するスレッドがあり、キュー信号の処理を含む、オブジェクトで発生するすべてのイベントのハンドラーを実行します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトを「所有している」スレッドがQtイベントループを実行しない場合、それに属しているオブジェクトはメッセージを受信せず、スレッド自体が終了を通知する試みに応答しません（）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">親と子孫は常に同じストリームに住んでいます。</font><font style="vertical-align: inherit;">ストリーム間で転送できるのは最上位の親のみです。</font><font style="vertical-align: inherit;">このルールに違反すると、setParentまたはmoveToThread操作のサイレント障害が発生する可能性があります</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">親が指定されていないオブジェクトは、このオブジェクトが作成したスレッドのプロパティになります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリングバックエンドを除くすべてのGUIオブジェクトは、GUIストリームに存在する必要があります</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GUIスレッドは、QApplicationオブジェクトが作成されたスレッドです。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、Qtをより効率的に使用し、マルチスレッドモデルに関連する間違いを犯さないようにしてください。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja467251/index.html">COBOL人質と数学。パート1</a></li>
<li><a href="../ja467253/index.html">COBOL人質と数学。パート2</a></li>
<li><a href="../ja467255/index.html">すべてのReact開発者が知っておくべき3つの一般的なセキュリティミス</a></li>
<li><a href="../ja467257/index.html">一度にすべての卵を1つのバスケットに保管しないでください</a></li>
<li><a href="../ja467259/index.html">DPI（SSLインスペクション）は暗号化の意味に矛盾しますが、企業はそれを実装しています</a></li>
<li><a href="../ja467263/index.html">私たちは、年間25％の太陽エネルギーまたは受動的収入で実務経験を積んでいます。パート2</a></li>
<li><a href="../ja467269/index.html">情報セキュリティのモデル</a></li>
<li><a href="../ja467271/index.html">職業プログラマー、職業別化学者</a></li>
<li><a href="../ja467275/index.html">プログラマの日へ。2019年のプログラマー</a></li>
<li><a href="../ja467277/index.html">pg_stat_statements + pg_stat_activity + loq_query = pg_ash？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>