<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëåüèº üÜï üòã Planning in Go: Part II - The Go Scheduler üõÅ üèá üè∑Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! This is the second post in a three-part series, which will give an idea of ‚Äã‚Äãthe mechanics and semantics of the work of the scheduler in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Planning in Go: Part II - The Go Scheduler</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489862/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, Habr! </font><font style="vertical-align: inherit;">This is the second post in a three-part series, which will give an idea of ‚Äã‚Äãthe mechanics and semantics of the work of the scheduler in Go. </font><font style="vertical-align: inherit;">This post is about the Go planner. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first part of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> this series, I explained aspects of the operating system scheduler that, in my opinion, are important for understanding and evaluating the Go scheduler's semantics. </font><font style="vertical-align: inherit;">In this post, I will explain at a semantic level how the Go scheduler works. </font><font style="vertical-align: inherit;">The Go Scheduler is a complex system and small mechanical details are not important. </font><font style="vertical-align: inherit;">It is important to have a good model of how everything works and behaves. </font><font style="vertical-align: inherit;">This will allow you to make the best engineering decisions.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Your program is starting</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When your Go program starts, it is assigned a logical processor (P) for each virtual core defined on the host machine. If you have a processor with several hardware threads per physical core (Hyper-Threading), each hardware thread will be presented to your program as a virtual core. To better understand this, take a look at the system report for my MacBook Pro. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b6e/2de/4a8/b6e2de4a805c6a87c95aa0afcef436ac.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can see that I have one processor with 4 physical cores. This report does not disclose the number of hardware threads per physical core. The Intel Core i7 processor has Hyper-Threading technology, which means that the physical core has 2 hardware threads. This tells Go that 8 virtual cores are available for running OS threads in parallel. To verify this, consider the following program:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> main<font></font>
<font></font>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"runtime"</span><font></font>
)<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
<font></font>
    <span class="hljs-comment">// NumCPU returns the number of logical</span>
    <span class="hljs-comment">// CPUs usable by the current process.</span><font></font>
    fmt.Println(runtime.NumCPU())<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When I run this program on my computer, the result of calling the NumCPU () function will be 8. Any Go program that I run on my computer will get 8 (P). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is assigned an OS stream ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). This thread is still managed by the OS, and the OS is still responsible for placing the thread in the kernel for execution. This means that when I run Go on my computer, I have 8 threads available to do my work, each individually linked to P. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each Go program is also given an initial Goroutine ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Goroutine is essentially Coroutine, but it is Go, so we replace the letter C with G and get the word Goroutine. You can think of Goroutines as application-level threads, and they are a lot like OS threads. Just as OS threads are turned on and off by the kernel, context programs are turned on and off by the context.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The last puzzle is the execution queues. </font><font style="vertical-align: inherit;">There are two different execution queues in the Go scheduler: the global execution queue (GRQ) and the local execution queue (LRQ). </font><font style="vertical-align: inherit;">Each P is assigned an LRQ that controls the goroutins assigned to execute in the context of P. These goroutines turn on and off from the context M assigned to this P. GRQ is for goroutines that have not been assigned to P. There is a process to move the goroutines from GRQ to LRQ, which we will discuss later. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The image shows all of these components together.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/114/13e/494/11413e494428c2540e349637f34bbec3.png" alt="image"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cooperative planner</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As we said in the first post, the OS scheduler is a preemptive scheduler. Essentially, this means that you cannot predict what the planner is going to do at any given time. The kernel makes decisions and everything is non-deterministic. Applications running on top of the operating system do not control what happens inside the kernel with scheduling unless they use synchronization primitives such as atomic instructions and mutex calls.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Go Scheduler is part of the Go Runtime, and the Go Runtime is built into your application. This means that the Go scheduler works in user space on the kernel. The current Go scheduler implementation is not a preemptive, but an interactive scheduler. Being a cooperative planner means that the planner needs clearly defined events in the user space that occur at safe points in the code to make planning decisions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is good about Go's collaborative planner is that it looks and feels proactive. </font><font style="vertical-align: inherit;">You cannot predict what the Go scheduler is going to do. </font><font style="vertical-align: inherit;">This is due to the fact that decision-making for this scheduler does not depend on the developers, but on the execution time of Go. </font><font style="vertical-align: inherit;">It is important to think of the Go scheduler as a proactive scheduler, and since the scheduler is non-deterministic, it is not too difficult.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gorutin States</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Just like streams, goroutines have the same three high-level states. They determine the role that the Go planner plays with any goroutine. Goroutin can be in one of three states: Waiting, Ready, or Fulfilling. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Waiting</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : This means that goroutine is stopped and waiting for something to continue. This can happen for reasons such as waiting for the operating system (system calls) or synchronization of calls (atomic and mutex operations). These types of delays are the main cause of poor performance. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Readiness</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: this means that goroutine wants time to follow the assigned instructions. </font><font style="vertical-align: inherit;">If you have a lot of goroutines who need time, then goroutines will have to wait longer to get time. </font><font style="vertical-align: inherit;">In addition, the individual amount of time that any goroutine receives is reduced as more goroutines compete for time. </font><font style="vertical-align: inherit;">This type of scheduling delay can also cause poor performance. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fulfillment</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : this means that goroutine has been placed in M ‚Äã‚Äãand is following its instructions. </font><font style="vertical-align: inherit;">The work associated with the application has been completed. </font><font style="vertical-align: inherit;">This is what everyone wants.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Context switch</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Go Scheduler requires well-defined user-space events that occur at secure points in the code to switch context. </font><font style="vertical-align: inherit;">These events and safe points appear in function calls. </font><font style="vertical-align: inherit;">Function calls are critical to the performance of the Go Scheduler. </font><font style="vertical-align: inherit;">If you execute any narrow loops that do not make function calls, you will cause delays in the scheduler and garbage collection. </font><font style="vertical-align: inherit;">It is imperative that function calls occur within a reasonable amount of time. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are four classes of events that occur in your Go programs that allow the planner to make planning decisions. </font><font style="vertical-align: inherit;">This does not mean that this will always happen at one of these events. </font><font style="vertical-align: inherit;">This means that the scheduler gets the opportunity.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using the go keyword</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garbage collector</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System calls</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronization</font></font></li>
</ul><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using the go</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
keyword The </font><i><font style="vertical-align: inherit;">go</font></i><font style="vertical-align: inherit;"> keyword is how you create goroutine. </font><font style="vertical-align: inherit;">As soon as a new goroutine is created, it gives the planner the opportunity to make a planning decision. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garbage Collector (GC)</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Since the GC works with its own set of goroutines, these gorutins need time on M to run. </font><font style="vertical-align: inherit;">This forces the GC to create a lot of chaos in planning. </font><font style="vertical-align: inherit;">However, the planner is very smart at what goroutine does, and he will use it to make decisions. </font><font style="vertical-align: inherit;">One reasonable solution is to switch the context to goroutine, which wants to access the system resource, and no one else but it during garbage collection. </font><font style="vertical-align: inherit;">When the GC works, many planning decisions are made. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System calls</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If goroutine makes a system call that will make it block M, the scheduler can switch the context to another goroutine, to the same M. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronization</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
If a call to an atomic operation, a mutex or a channel causes goroutine to be blocked, the scheduler can switch the context to start a new goroutine. </font><font style="vertical-align: inherit;">Once goroutine can work again, it can be queued and eventually switch back to M.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous system calls</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When the operating system you are working on has the ability to process a system call asynchronously, what is called a network poller can be used to process the system call more efficiently. </font><font style="vertical-align: inherit;">This is achieved using kqueue (MacOS), epoll (Linux) or iocp (Windows) in these respective OSs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Network system calls can be handled asynchronously by many of the operating systems we use today. This is where the network poller shows itself, since its main purpose is to process network operations. Using the network poller for network system calls, the scheduler can prevent goroutines from blocking M during these system calls. This helps keep M available to execute other goroutines in LRQ P without the need to create new M. This helps reduce the planning burden in the OS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The best way to see how this works is to look at an example. The figure shows our basic planning scheme. Gorutin-1 is executed on M, and 3 more Gorutins are waiting in LRQ to get their time on M. Network poller is idle, and he has nothing to do.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d76/7cd/b0f/d767cdb0fd640db3a84e3c87d14f38e3.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the following figure, Gorutin-1 (G1) wants to make a network system call, so G1 moves to the Network poller and is treated as an asynchronous network system call. </font><font style="vertical-align: inherit;">Once G1 has been moved to Network poller, M is now available to execute another goroutine from LRQ. </font><font style="vertical-align: inherit;">In this case, Gorutin-2 switches to M. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/764/93f/af0/76493faf0f599eefae69938878e4ceb1.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the following figure, the system network call ends with an asynchronous network call, and G1 moves back to LRQ for P. After G1 can be switched back to M, the code associated with Go, for which he answers can execute again. </font><font style="vertical-align: inherit;">The big win is that no additional Ms. is required to make network system calls. </font><font style="vertical-align: inherit;">Network poller has an OS thread, and it processes through an event loop.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronous system calls</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What happens when goroutine wants to make a system call that cannot be executed asynchronously? </font><font style="vertical-align: inherit;">In this case, the Network poller cannot be used, and the goroutine making the system call will block M. This is bad, but there is no way to prevent this. </font><font style="vertical-align: inherit;">One example of a system call that cannot be made asynchronously is file-based system calls. </font><font style="vertical-align: inherit;">If you use CGO, there may be other situations where calling C functions also blocks M.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Windows operating system can make file-based asynchronous system calls. </font><font style="vertical-align: inherit;">Technically, when working on Windows, you can use Network poller.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's see what happens with a synchronous system call (for example, file I / O) that will block M. The figure shows our basic planning diagram, but this time G1 is going to make a synchronous system call that will block M1. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/747/549/a28/747549a28a7a627a3cbd98fffe728fad.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the following figure, the scheduler can determine that G1 caused an M lock. At this point, the scheduler disconnects M1 from P with a blocking G1 still attached. The scheduler then introduces a new M2 to serve P. At this point, G2 can be selected from LRQ and included in the M2 context. If M already exists due to a previous exchange, this transition is faster than the need to create a new M.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/966/30c/3dd/96630c3dd34a06fbc5ed5f8b4c8bdfbc.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The next step completes the lock system call made by G1. </font><font style="vertical-align: inherit;">At this point, G1 can return to LRQ and be served again by P. M1 then goes aside for future use if this scenario should be repeated.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/553/0ed/f8c/5530edf8c481aee13a40ff0b55e8e1ed.png" alt="image"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Work stealing</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another aspect of the scheduler is that it is a goroutine theft planner. This helps in several areas to support effective planning. Firstly, the last thing you need is for M to go to the standby state, because as soon as this happens, the OS will switch M from the kernel using context. This means that P cannot do any work, even if there is a Goroutine in a healthy state, until M switches back to the kernel. Gorutin Theft also helps to balance time intervals between all Ps so that work is better distributed and performed more efficiently. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the figure, we have a multi-threaded Go program with two Ps serving four Gs each and one G in GRQ. What happens if one of P quickly serves all of its G?</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e1a/745/eaa/e1a745eaaeab4e91bf35e80d8f16ae34.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Further, P1 no longer has goroutines to execute. But there are goroutines in working condition, both in LRQ for P2, and in GRQ. This is the moment when P1 needs to steal goroutine. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6f6/190/ccc/6f6190cccec8213c27cadfbb03b67767.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The rules for stealing goroutines are as follows. All code can be viewed in the runtime sources.</font></font><br>
<br>
<pre><code class="go hljs">runtime.schedule() {
    <span class="hljs-comment">// only 1/61 of the time, check the global runnable queue for a G.</span>
    <span class="hljs-comment">// if not found, check the local queue.</span>
    <span class="hljs-comment">// if not found,</span>
    <span class="hljs-comment">//     try to steal from other Ps.</span>
    <span class="hljs-comment">//     if not, check the global runnable queue.</span>
    <span class="hljs-comment">//     if not found, poll network.</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, based on these rules, P1 should check P2 for the presence of goroutines in its LRQ and take half of what it finds. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/af2/b9b/ec2/af2b9bec21571656e051799fb3213020.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What happens if P2 finishes serving all its programs and P1 has nothing left in LRQ? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2 has completed all his work and now must steal the goroutines. </font><font style="vertical-align: inherit;">First, he will look at the LRQ P1, but will not find any Goroutines. </font><font style="vertical-align: inherit;">Next he will look at GRQ. </font><font style="vertical-align: inherit;">There he will find the G9. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4f8/2db/b86/4f82dbb86b9005e458097587792dd462.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
P2 steals G9 from GRQ and starts to do the job. </font><font style="vertical-align: inherit;">What is good about all this theft is that it allows M to stay busy and not be inactive.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e12/221/a4a/e12221a4ad60695c5c5c97837e30cfbb.png" alt="image"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Practical example</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With mechanics and semantics, I want to show you how this all comes together so that the Go scheduler can do more work over time. Imagine a multi-threaded application written in C, in which the program manages two OS threads that send messages to each other. There are 2 threads in the picture that send the message back and forth. Thread 1 receives context-switched core 1 and is now running, which allows thread 1 to send its message to thread 2.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bb3/6fb/00d/bb36fb00db345441ca295dd01d153b2b.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Further, when thread 1 finishes sending the message, now it needs to wait for a response. This will cause thread 1 to be disconnected from the context of kernel 1 and put into a wait state. As soon as thread 2 receives a message notification, it goes into a healthy state. Now the OS can perform a context switch and run thread 2 on the kernel, which turns out to be kernel 2. Then thread 2 processes the message and sends a new message back to thread 1.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4af/66e/0fe/4af66e0fe8440f757063603b6bc161a2.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, the stream switches back to context when the message from stream 2 is received by stream 1. Now, stream 2 switches from the run state to the standby state, and stream 1 switches from the standby state to the ready state and finally returns to the run state, which allows it to process and send a new message back. All of these context switches and state changes take time to complete, which limits the speed of the work. Since each context switch entails a delay of ~ 1000 nanoseconds, and we hope that the hardware executes 12 instructions per nanosecond, you look at 12,000 instructions that are more or less not executed during these context switches. Since these flows also intersect between different nuclei,The likelihood of an additional cache-line misses delay is also high.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a45/b47/127/a45b47127d054f2b56b6c2534c9150bf.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the figure there are two gorutins who are in harmony with each other, passing the message back and forth. G1 gets the context switch M1, which runs on Core 1, which allows G1 to do its job. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/977/b59/78c/977b5978ca8daa9bfc186c77c901565a.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Further, when G1 finishes sending the message, now he needs to wait for a response. This will cause G1 to be disconnected from the M1 context and put into the idle state. As soon as G2 is notified of the message, it goes into a healthy state. Now the Go scheduler can perform context switching and run G2 on M1, which still runs on Core 1. Then G2 processes the message and sends a new message back to G1.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3e8/86c/003/3e886c003a64536731234abde2746ca2.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the next step, everything switches again when the message sent by G2 is received by G1. Now, the context G2 switches from the execution state to the waiting state, and the context G1 switches from the waiting state to the execution state and, finally, back to the execution state, which allows it to process and send a new message back. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4db/97b/a31/4db97ba314fa8b14bf6497dcaf15135a.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Things on the surface do not seem to be different. All the same context changes and state changes occur regardless of whether you use Streams or Goroutines. However, there is a big difference between the use of Streams and Gorutin, which may not be obvious at first glance.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If goroutine is used, the same OS threads and kernel are used for all processing. This means that from an OS point of view, OS Flow never goes into a wait state; never. As a result, all those instructions that we lost when switching contexts when using streams are not lost when using goroutin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essentially, Go turned IO / Blocking work into a processor-bound job at the OS level. Since all context switching occurs at the application level, we do not lose the same ~ 12 thousand instructions (on average) on context switching that we lost when using streams. In Go, the same context switches cost you ~ 200 nanoseconds or ~ 2.4 thousand commands. The scheduler also helps improve the performance of caching strings and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUMA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">That's why we don‚Äôt need more threads than we have virtual cores. </font><font style="vertical-align: inherit;">Go can do more work over time, because the Go scheduler tries to use fewer threads and do more on each thread, which helps reduce the load on the OS and hardware.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Go Scheduler is truly amazing in how it takes into account the intricacies of the operating system and hardware. The ability to turn I / O / lock operation into a processor-bound operation at the operating system level is where we get big gains in using more processor power over time. This is why you don‚Äôt need more OS threads than you have virtual kernels. You can reasonably expect that all of your work will be done (with CPU binding and I / O / locks) with one OS thread per virtual kernel. This is possible for network applications and other applications that do not need system calls that block OS threads.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a developer, you should still understand what your application does in terms of type of work. </font><font style="vertical-align: inherit;">You cannot create an unlimited amount of goroutines and expect amazing performance. </font><font style="vertical-align: inherit;">Less is always more, but with an understanding of this semantics of the Go scheduler, you can make better engineering decisions.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en489852/index.html">Transparent authentication in ASP.Net Core on Linux</a></li>
<li><a href="../en489854/index.html">Redux vs MobX without confusion</a></li>
<li><a href="../en489856/index.html">Banach-Tarski reverse paradox or how to reduce the stored data volume by five times</a></li>
<li><a href="../en489858/index.html">Internationalization: Making the Web Accessible to Everyone</a></li>
<li><a href="../en489860/index.html">The history of Telefunken: the phoenix of German electronics from Wilhelm II and Goebbels to the Beatles and today</a></li>
<li><a href="../en489868/index.html">Freezing Mozilla WebThings</a></li>
<li><a href="../en489870/index.html">Free offline intensive by Node.js in Nizhny Novgorod</a></li>
<li><a href="../en489872/index.html">How the DLP system and the OCR module prevented employees from falsifying passport scans</a></li>
<li><a href="../en489874/index.html">Cross compiling Rust for Windows executables from Linux</a></li>
<li><a href="../en489876/index.html">How we solved the problem of three monoliths</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>