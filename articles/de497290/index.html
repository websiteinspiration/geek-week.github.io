<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😼 👩🏾‍💻 🥈 Verbessern der Leistung mithilfe des UOP-Cache auf Sandy Bridge + 🤙 👩🏿‍⚕️ 👨🏿‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In modernen x86 Intel-Prozessoren kann die Pipeline in zwei Teile unterteilt werden: Front-End und Back-End. 
 
 Das Front-End ist dafür verantwortlic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Verbessern der Leistung mithilfe des UOP-Cache auf Sandy Bridge +</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/497290/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In modernen x86 Intel-Prozessoren kann die Pipeline in zwei Teile unterteilt werden: Front-End und Back-End. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Front-End ist dafür verantwortlich, Code aus dem Speicher zu laden und in Mikrooperationen zu dekodieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Back-End ist für die Durchführung von Mikrooperationen vom Front-End aus verantwortlich. </font><font style="vertical-align: inherit;">Da diese Mikrooperationen vom Kernel außerhalb der Reihenfolge ausgeführt werden können, stellt das Back-End auch sicher, dass das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dieser Mikrooperationen genau der Reihenfolge entspricht, in der sie im Code enthalten sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den meisten Fällen wirkt sich eine ineffiziente Verwendung von Front End'a nicht spürbar auf die Leistung aus. </font><font style="vertical-align: inherit;">Die maximale Bandbreite auf den meisten Intel-Prozessoren beträgt 4 Mikrooperationen pro Zyklus. Daher kann die CPU beispielsweise einen speicher- / L3-gebundenen Code nicht vollständig nutzen.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pro relativ neuer Ice Lake</font></font></b><div class="spoiler_text">   ,      Ice Lake    4  5   .  ,        ,         . <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einigen Fällen kann der Leistungsunterschied jedoch erheblich sein. </font><font style="vertical-align: inherit;">Unter dem Schnitt befindet sich eine Analyse der Auswirkungen des Mikrooperations-Cache auf die Leistung.</font></font><br>
<a name="habracut"></a><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Inhalt des Artikels</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Umgebung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übersicht über Front End'a Intel-Prozessoren</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spitzenbandbreitenanalyse µop-Cache -&gt; IDQ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Umgebung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für alle Messungen in diesem Artikel wird </font></font><code>i7-8550U Kaby Lake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HT aktiviert / verwendet </font></font><code>Ubuntu 18.04/Linux Kernel 5.3.0-45-generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In diesem Fall kann eine solche Umgebung von Bedeutung sein, weil </font><font style="vertical-align: inherit;">Jedes CPU-Modell hat ein eigenes Leistungsereignis. </font><font style="vertical-align: inherit;">Insbesondere für Mikroarchitekturen, die älter als Sandy Bridge sind, sind einige der in Zukunft verwendeten Ereignisse einfach nicht sinnvoll.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übersicht über Front End'a Intel-Prozessoren</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die übergeordnete Fließbandorganisation ist öffentlich verfügbar und wird in der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offiziellen Dokumentation von Intel zur Softwareoptimierung veröffentlicht</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Eine detailliertere Beschreibung einiger Funktionen, die in der offiziellen Dokumentation nicht aufgeführt sind, finden Sie in anderen seriösen Quellen wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agner Fog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travis Downs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">So sieht beispielsweise das Assembly-Pipeline-Schema für Skylake in der Intel-Dokumentation folgendermaßen aus: Schauen </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qe/jr/xa/qejrxaieyvky3yjl5yps8toljme.png" alt="Skylake-Pipeline"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
wir uns </font><font style="vertical-align: inherit;">den </font><font style="vertical-align: inherit;">Anfang dieses Schemas genauer </font><font style="vertical-align: inherit;">an </font><font style="vertical-align: inherit;">- das Front-End. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dp/ya/yw/dpyaywk2lq0qub5zh4dvjlqwjn4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Legacy Decode Pipeline ist für die Dekodierung des Codes in Mikrooperationen verantwortlich. </font><font style="vertical-align: inherit;">Es besteht aus folgenden Komponenten:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instruction Fetch Unit - IFU</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First Level Instructions Cache - L1i</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adresscache für die Übersetzung von Anweisungsprotokollen - ITLB</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instructor Prefector</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pre-Decoder-Anweisungen</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warteschlange vordecodierter Anweisungen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vordecodierte Befehlsdecoder für die Mikrooperation</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie jeden Teil der Legacy Decode-Pipeline einzeln. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instruction Fetch Unit. </font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Er ist verantwortlich für das Laden des Codes, das Vorcodieren (Bestimmen der Länge des Befehls und der Eigenschaften, z. B. "ob der Befehl ein Zweig ist") und das Bereitstellen vordecodierter Befehle an die Warteschlange. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First Level Instructions Cache - L1i</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Herunterladen des Codes verwendet die IFU L1i, den Anweisungscache der ersten Ebene, und L2 / LLC, den Cache der zweiten Ebene und den Offcore-Cache der obersten Ebene, die Code und Daten gemeinsam haben. Der Download erfolgt in Teilen von 16 Bytes, die ebenfalls auf 16 Bytes ausgerichtet sind. Wenn der nächste 16-Byte-Code der Reihe nach geladen wird, wird L1i aufgerufen, und wenn die entsprechende Zeile nicht gefunden wird, wird eine Suche in L2 und im Fehlerfall in LLC und Speicher durchgeführt. Vor Skylake LLC war der Cache inklusive - jede Zeile in L1 (i / d) und L2 sollte in der LLC enthalten sein. Somit "wusste" LLC über alle Leitungen in allen Kernen Bescheid und im Fall von LLC-Fehlern war bekannt, ob die Caches in anderen Kernen die erforderliche Zeile im modifizierten Zustand enthielten, was bedeutet, dass diese Leitung von einem anderen Kern geladen werden konnte. Skylake LLC wurde zu einem nicht inklusive L2-Opfer-Cache, aber die L2-Größe wurde viermal erhöht. Ich weiß es nichtob L2 in Bezug auf L1i inklusive ist. L2</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inklusive in Bezug auf L1d. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übersetzung logischer Adressadressen - ITLB</font></font></b> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Bevor Sie Daten aus dem Cache herunterladen, müssen Sie nach der entsprechenden Zeile suchen. Bei </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assoziativen Zwischencaches</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann sich jede Zeile an </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verschiedenen Stellen im Cache selbst befinden. Um die möglichen Positionen im Cache zu bestimmen, wird ein Index verwendet (normalerweise einige niedrigere Bits der Adresse). Um festzustellen, ob die Zeile mit der von uns benötigten Adresse übereinstimmt, wird ein Tag verwendet (der Rest der Adresse). Welche Adressen verwendet werden sollen: physisch oder logisch - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hängt von der Cache-Implementierung ab</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Verwendung physischer Adressen erfordert eine Adressübersetzung. Für die Adressumsetzung wird ein TLB-Puffer verwendet, der die Ergebnisse von Seitenläufen zwischenspeichert, wodurch die Verzögerung beim Empfang einer physischen Adresse von einer logischen Adresse bei nachfolgenden Aufrufen verringert wird. Für Anweisungen gibt es einen eigenen Anweisungs-TLB-Puffer, der sich getrennt vom Daten-TLB befindet. Der CPU-Kern verfügt außerdem über einen TLB der zweiten Ebene, der Code und Daten gemeinsam ist - STLB. Ob STLB inklusive ist, ist mir unbekannt (es wird gemunkelt, dass es sich nicht um einen inklusive Opfer-Cache im Vergleich zu D / I TLB handelt). Verwenden von Software-Prefetch-Anweisungen</font></font><code>prefetcht1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können die Zeile mit dem Code in L2 aufrufen, der entsprechende TLB-Datensatz wird jedoch nur in DTLB aufgerufen. </font><font style="vertical-align: inherit;">Wenn STLB nicht inklusive ist, erhalten Sie bei der Suche nach dieser Zeile mit dem Code in den Caches ITLB-Fehler -&gt; STLB-Fehler -&gt; Seitenlauf (tatsächlich ist dies nicht so einfach, da der Kernel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen spekulativen Seitenlauf initiieren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">,</font></a><font style="vertical-align: inherit;"> bevor dies geschieht TLB Miss). </font><font style="vertical-align: inherit;">Die Intel-Dokumentation rät auch von der Verwendung von SW-Prefetches für Code ab. Intel Software Optimization Manual / 2.5.5.4:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der softwaregesteuerte Prefetch dient zum Prefetching von Daten, nicht jedoch zum Prefetching von Code.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Travis D. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erwähnte jedoch,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dass ein solcher Prefetch sehr effektiv sein kann (und höchstwahrscheinlich auch), aber dies ist mir bisher nicht klar, und um davon überzeugt zu sein, muss ich dieses Problem separat untersuchen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instructor Prefector</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Laden von Daten in den Cache (L1d / i, L2 usw.) erfolgt beim Zugriff auf einen nicht zwischengespeicherten Speicherort. </font><font style="vertical-align: inherit;">Wenn dies jedoch nur unter solchen Bedingungen geschehen würde, würden wir als Ergebnis eine ineffiziente Nutzung der Cache-Bandbreite erhalten. </font><font style="vertical-align: inherit;">Zum Beispiel auf Sandy Bridge für L1d - 2 Leseoperationen, 1 Schreibvorgang 16 Bytes pro Zyklus; </font><font style="vertical-align: inherit;">Für den L1i-1-Lesevorgang mit 16 Bytes ist der Schreibdurchsatz in der Dokumentation nicht angegeben. Agner Fog wurde ebenfalls nicht gefunden. </font><font style="vertical-align: inherit;">Um dieses Problem zu lösen, gibt es Hardware-Prefetchers, die das Muster des Zugriffs auf den Speicher bestimmen und die erforderlichen Zeilen in den Cache ziehen können, bevor der Code sie tatsächlich adressiert. </font><font style="vertical-align: inherit;">Die Intel-Dokumentation definiert 4 Prefetchers: 2 für L1d, 2 für L2:</font></font><br>
<br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 DCU</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Serielle Cache-Zeilen mit Präfix. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schreibgeschützt weiterleiten</font></font></b></li>
<li><b>L1 IP</b> —              (. 0x5555555545a0, 0x5555555545b0, 0x5555555545c0, ...),    ,   ,  </li>
<li><b>L2 Spatial</b> —       L2    -,        128-.       LLC</li>
<li><b>L2 Streamer</b> —    .    L1 DCU      «».       LLC</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Intel-Dokumentation beschreibt nicht das Prinzip des L1i-Präfektors. </font><font style="vertical-align: inherit;">Es ist lediglich bekannt, dass die Branch Prediction Unit (BPU) an diesem Prozess beteiligt ist. Intel Software Optimization Manual / 2.6.2: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/js/y3/sdjsy3jrgseyeuukletr84i2gyu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agner Fog sieht ebenfalls keine Details. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Code-Prefetching in L2 / LLC ist explizit nur für Streamer definiert. </font><font style="vertical-align: inherit;">Optimierungshandbuch / 2.5.5.4 Datenpräfektion:</font></font><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streamer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dieser Prefetcher überwacht Leseanforderungen aus dem L1-Cache auf aufsteigende und absteigende Folgen von Adressen. </font><font style="vertical-align: inherit;">Zu den überwachten Leseanforderungen gehören L1-DCache-Anforderungen, die durch Lade- und Speicheroperationen sowie durch die Hardware-Prefetchers initiiert wurden, sowie L1-ICache-Anforderungen für das Abrufen von Code.</font></font></blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für den Spatial Prefetcher ist dies eindeutig nicht klargestellt:</font></font><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spatial Prefetcher:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dieser Prefetcher versucht, jede in den L2-Cache abgerufene Cache-Zeile mit der Paarzeile zu vervollständigen, die ihn zu einem 128-Byte-ausgerichteten Block vervollständigt.</font></font></blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies kann jedoch überprüft werden. </font><font style="vertical-align: inherit;">Jeder dieser Prefetchers kann mithilfe von deaktiviert werden </font></font><code>MSR 0x1A4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wie im Handbuch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modellspezifische Register beschrieben.</font></font></a><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Über MSR 0x1A4</font></font></b><div class="spoiler_text">  MSR     L2 Spatial    L1i.     .              ,    LLC.     L2 Streamer       2.5 . <br>
<br>
 Linux  msr ,   msr     .  <code>$ sudo wrmsr -p 1 0x1a4 1</code>  L2 Streamer   1.<br>
</div></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pre-Decoder-Anweisungen</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nachdem der nächste 16-Byte-Code geladen wurde, fallen sie in die Pre-Decoder-Anweisungen. </font><font style="vertical-align: inherit;">Seine Aufgabe ist es, die Länge der Anweisung zu bestimmen, die Präfixe zu dekodieren und zu markieren, ob die entsprechende Anweisung eine Verzweigung ist (höchstwahrscheinlich gibt es noch viele verschiedene Eigenschaften, aber die Dokumentation darüber enthält keine Informationen). </font><font style="vertical-align: inherit;">Intel Software Optimization Manual / 2.6.2.2:</font></font><br>
<blockquote>The predecode unit accepts the sixteen bytes from the instruction cache or prefetch buffers and carries out the following tasks:<br>
<br>
<ul>
<li>Determine the length of the instructions</li>
<li>Decode all prefixes associated with instructions</li>
<li>Mark various properties of instructions for the decoders (for example, “is branch.”)</li>
</ul></blockquote><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Reihe vordecodierter Anweisungen. </font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von der IFU werden Anweisungen zur vorcodierten Anweisungswarteschlange hinzugefügt. </font><font style="vertical-align: inherit;">Diese Warteschlange ist seit Nehalem aufgetaucht. Gemäß der Intel-Dokumentation hat sie eine Größe von 18 Anweisungen. </font><font style="vertical-align: inherit;">Agner Fog erwähnt auch, dass diese Warteschlange nicht mehr als 64 Bytes enthält. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auch in Core2 wurde diese Warteschlange als Schleifencache verwendet. </font><font style="vertical-align: inherit;">Wenn sich alle Mikrooperationen aus dem Zyklus in der Warteschlange befinden, können in einigen Fällen die Kosten für das Laden und die Vorcodierung vermieden werden. </font><font style="vertical-align: inherit;">Der Loop Stream Detector (LSD) kann Anweisungen liefern, die sich bereits in der Warteschlange befinden, bis die BPU signalisiert, dass der Zyklus beendet wurde. </font><font style="vertical-align: inherit;">Agner Fog hat eine Reihe interessanter Hinweise zu LSD auf Core2:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besteht aus 4 Zeilen mit 16 Bytes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spitzendurchsatz bis zu 32 Byte Code pro Zyklus</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnend mit Sandy Bridge wurde dieser Schleifencache von der vordecodierten Anweisungswarteschlange zurück zu IDQ verschoben. </font></font><br>
 <br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decoder von vordecodierten Anweisungen in der Mikrooperation</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Aus der Warteschlange von </font><b><font style="vertical-align: inherit;">vordecodierten</font></b><font style="vertical-align: inherit;"> Anweisungen wird der Code zur Decodierung in der Mikrooperation gesendet. Decoder sind für die Decodierung verantwortlich - insgesamt gibt es 4. Laut Intel-Dokumentation kann einer der Decoder Anweisungen dekodieren, die aus 4 Mikrooperationen oder weniger bestehen. Der Rest decodiert Anweisungen, die aus einer Mikrooperation (Mikro- / Makro-Fusion) bestehen, Intel Software Optimization Manual / 2.5.2.1:</font></font><br>
<blockquote>There are four decoding units that decode instruction into micro-ops. The first can decode all IA-32 and Intel 64 instructions up to four micro-ops in size. The remaining three decoding units handle single-micro-op instructions. All four decoding units support the common cases of single micro-op flows including micro-fusion and macro-fusion.</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anweisungen, die in einer großen Anzahl von Mikrooperationen decodiert wurden (z. B. rep movsb, die bei der Implementierung von memcpy in libc auf bestimmten Größen des kopierten Speichers verwendet werden), stammen vom Microcode Sequencer (MS ROM). Die Spitzenbandbreite des Sequenzers beträgt 4 Mikrooperationen pro Zyklus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie im Fließbanddiagramm sehen können, kann die Legacy Decode Pipeline auf Skylake bis zu 5 Mikrooperationen pro Zyklus decodieren. Bei Broadwell und älteren Versionen betrug der Spitzendurchsatz der Legacy Decode Pipeline 4 Mikrooperationen pro Zyklus. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mikrooperations-Cache</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem die Anweisungen in Mikrooperationen decodiert wurden, fallen sie aus der Legacy Decode Pipeline in die spezielle Mikrooperationswarteschlange - Instruction Decode Queue (IDQ) - sowie in den sogenannten Mikrooperationscache (Decoded ICache, µop Cache). Der Mikrooperations-Cache wurde ursprünglich in Sandy Bridge eingeführt und wird verwendet, um das Abrufen und Dekodieren von Anweisungen bei Mikrooperationen zu vermeiden, wodurch der Durchsatz für die Bereitstellung von Mikrooperationen in IDQ erhöht wird - bis zu 6 pro Zyklus. Nach dem Einstieg in IDQ werden Mikrooperationen zur Ausführung mit einem Spitzendurchsatz von 4 Mikrooperationen pro Zyklus an das Back-End gesendet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Laut Intel-Dokumentation besteht der Mikrooperations-Cache aus 32 Sätzen, jeder Satz enthält 8 Zeilen, jede Zeile kann bis zu 6 Mikrooperationen (Mikro- / Makro-Fusion) zwischenspeichern, was einen Gesamt-Cache von bis zu 32 * 8 * 6 = 1536 Mikrooperationen ermöglicht . </font><font style="vertical-align: inherit;">Das Zwischenspeichern von Mikrooperationen erfolgt mit einer Granularität von 32 Bytes, d.h. </font><font style="vertical-align: inherit;">Mikrooperationen, die Anweisungen aus verschiedenen 32-Byte-Regionen folgen, können nicht in eine Zeile fallen. </font><font style="vertical-align: inherit;">Bis zu 3 verschiedene Cache-Zeilen können jedoch einer 32-Byte-Region entsprechen. </font><font style="vertical-align: inherit;">Somit können bis zu 18 Mikrooperationen im µop-Cache jeder 32-Byte-Region entsprechen.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intel Software Optimization Manual / 2.5.5.2</font></font></b><div class="spoiler_text"><blockquote>The Decoded ICache consists of 32 sets. Each set contains eight Ways. Each Way can hold up to six micro-ops. The Decoded ICache can ideally hold up to 1536 micro-ops. The following are some of the rules how the Decoded ICache is filled with micro-ops:<br>
<br>
<ul>
<li>ll micro-ops in a Way represent instructions which are statically contiguous in the code and have their EIPs within the same aligned 32-byte region.</li>
<li>Up to three Ways may be dedicated to the same 32-byte aligned chunk, allowing a total of 18 micro-ops to be cached per 32-byte region of the original IA program.</li>
<li>A multi micro-op instruction cannot be split across Ways.</li>
<li>Up to two branches are allowed per Way. </li>
<li>An instruction which turns on the MSROM consumes an entire Way.</li>
<li>A non-conditional branch is the last micro-op in a Way. </li>
<li>Micro-fused micro-ops (load+op and stores) are kept as one micro-op.</li>
<li>A pair of macro-fused instructions is kept as one micro-op.</li>
<li>Instructions with 64-bit immediate require two slots to hold the immediate.</li>
</ul></blockquote><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agner Fog erwähnt auch, dass nur einzeilige Mikrooperationen pro Zyklus heruntergeladen werden können (in der Intel-Dokumentation nicht explizit angegeben, obwohl dies leicht manuell überprüft werden kann).</font></font><br>
<br>
<h4>    µop cache --&gt; IDQ</h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einigen Fällen ist es sehr praktisch, </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Längen </font><font style="vertical-align: inherit;">von </font><font style="vertical-align: inherit;">1 Byte </font><font style="vertical-align: inherit;">zu verwenden, um das Verhalten des Frontends zu untersuchen </font><font style="vertical-align: inherit;">. Gleichzeitig können wir sicher sein, dass wir aus irgendeinem Grund das Front-End und nicht den Resource Stall am Back-End untersuchen. Tatsache ist, dass sie </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neben anderen Anweisungen in der Legacy Decode Pipeline decodiert, im µop-Cache gemischt und an IDQ gesendet werden. Weiter </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sowie andere Anweisungen, nimmt Back-End. Der wesentliche Unterschied besteht darin, dass bei den Ressourcen im Back-End </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachbestellungspuffer verwendet wird</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und kein Steckplatz in der Reservierungsstation (auch als Scheduler bezeichnet) erforderlich ist. Somit ist es unmittelbar nach Eingabe </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des Bestellpuffers für den Ruhestand bereit, der gemäß der Reihenfolge im Programmcode ausgeführt wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deklarieren Sie eine Funktion, um den Durchsatz zu testen </font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_decoded_icache</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> iteration_count)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mit Umsetzung am </font></font><code>nasm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">align 32<font></font>
test_decoded_icache:<font></font>
    ;nop',  0  23 <font></font>
    dec rdi<font></font>
    ja test_decoded_icache<font></font>
    ret</code></pre><br>
<code>ja</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wurde nicht zufällig ausgewählt. </font></font><code>ja</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwenden Sie verschiedene Flags - </font></font><code>ja</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liest von </font></font><code>CF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>ZF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nimmt </font></font><code>dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht in der CF auf, sodass Macro Fusion nicht angewendet wird. </font><font style="vertical-align: inherit;">Dies geschieht lediglich, um Mikrooperationen in einem Zyklus bequem zählen zu können - jeder Befehl entspricht einer Mikrooperation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für Messungen benötigen wir die folgenden Perf-Ereignisse: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. </font></font><code>uops_issued.any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Wird verwendet, um die Mikrooperationen zu zählen, die Renamer von IDQ übernimmt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Intel System Programming Guide dokumentiert dieses Ereignis als die Anzahl der Mikrooperationen, die Renamer in die Reservierungsstation einfügt:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zählt die Anzahl der Uops, die die Resource Allocation Table (RAT) an die Reservation Station (RS) ausgibt.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Beschreibung korreliert nicht vollständig mit den Werten, die aus Experimenten erhalten werden können. Insbesondere </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fallen sie in diesen Schalter, obwohl es nur eine Tatsache ist, dass sie an der Reservierungsstation überhaupt nicht benötigt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. </font></font><code>uops_retired.retire_slots</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- die Gesamtzahl der Mikrooperationen im Ruhestand unter Berücksichtigung der Mikro- / Makrofusion </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. </font></font><code>uops_retired.stall_cycles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- die Anzahl der Zecken, für die es keine einzige Mikrooperation im Ruhestand gab </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. </font></font><code>resource_stalls.any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- die Anzahl der Zecken im Leerlaufförderer aufgrund der Unzugänglichkeit einer der Ressourcen Back-End </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
im Intel Software Optimization Manual / B. .4.1 Es gibt ein Inhaltsdiagramm, das die oben beschriebenen Ereignisse charakterisiert: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wq/j9/y3/wqj9y3jj7aeisnmdjxxxjwsl_jk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5. </font></font><code>idq.all_dsb_cycles_4_uops</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Die Anzahl der Taktzyklen, für die 4 (oder mehr) Anweisungen aus dem µop-Cache geliefert wurden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Tatsache, dass diese Metrik die Bereitstellung von mehr als 4 Mikrooperationen pro Zyklus berücksichtigt, wird in der Intel-Dokumentation nicht beschrieben, stimmt jedoch sehr gut mit den Experimenten überein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6. </font></font><code>idq.all_dsb_cycles_any_uops</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- die Anzahl der Maßnahmen, für die mindestens eine Mikrooperation durchgeführt wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7. </font></font><code>idq.dsb_cycles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Die Gesamtzahl der Ticks, bei denen die Lieferung aus dem µop-Cache erfolgte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8. </font></font><code>idq_uops_not_delivered.cycles_le_N_uop_deliv.core</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Die Anzahl </font><font style="vertical-align: inherit;">der Ticks, </font><font style="vertical-align: inherit;">für die Renamer eine </font></font><code>N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder weniger </font><font style="vertical-align: inherit;">Mikrooperationen durchgeführt hat </font><font style="vertical-align: inherit;">und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf der Back-End-Seite keine Ausfallzeiten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufgetreten </font><font style="vertical-align: inherit;">sind. </font></font><code>N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 1, 2, 3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir nehmen Nachforschungen an </font></font><code>iteration_count = 1 &lt;&lt; 31</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir beginnen die Analyse dessen, was in der CPU geschieht, indem wir die Anzahl der Mikrooperationen untersuchen und zunächst die durchschnittliche Ausfallbandbreite messen, d. H. </font></font><code>uops_retired.retire_slots/uops_retired.total_cycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">::</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xi/b2/0s/xib20shepbr334i1xmhka10rjeg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was sofort auffällt, ist das Absinken des Ruhestandsdurchsatzes bei einer Zyklusgröße von 7 Mikrooperationen. Um zu verstehen, worum es geht, schauen wir uns an, wie sich die durchschnittliche Übermittlungsgeschwindigkeit aus dem µop-Cache ändert </font></font><code>idq.all_dsb_cycles_any_uops / idq.dsb_cycles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xm/5s/su/xm5ssuzamxr4th-xs7e0ixrisfm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und wie die Gesamtzahl der Kennzahlen und Kennzahlen, für die der µop-Cache an IDQ geliefert wird, zusammenhängt: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/it/w5/va/itw5vasl9ogpslneyoclxzasu4k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So können wir sehen, dass wir mit einem Zyklus von 6 </font><font style="vertical-align: inherit;">Mikrooperationen </font><font style="vertical-align: inherit;">eine effektive </font><font style="vertical-align: inherit;">erzielen </font><font style="vertical-align: inherit;">µop-Cache-Bandbreitennutzung - 6 Mikrooperationen pro Zyklus. Aufgrund der Tatsache, dass Renamer nicht so viel aufnehmen kann, wie der µop-Cache liefert, liefert ein Teil der µop-Cache-Zyklen nichts, was im vorherigen Diagramm deutlich sichtbar ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei einem Zyklus von 7 Mikrooperationen sinkt der Durchsatz des µop-Cache stark - 3,5 Mikrooperationen pro Zyklus. Gleichzeitig ist der µop-Cache, wie aus dem vorherigen Diagramm ersichtlich, ständig in Betrieb. Mit einem Zyklus von 7 Mikrooperationen erhalten wir somit eine ineffiziente Auslastung des Bandbreiten-µop-Cache. Tatsache ist, dass, wie bereits erwähnt, der µop-Cache pro Zyklus Mikrooperationen von nur einer Zeile liefern kann. Bei Mikrooperationen 7 fallen die ersten 6 in eine Zeile und die restlichen 7 in eine andere. Auf diese Weise erhalten wir 7 Mikrooperationen pro 2 Zyklen oder 3,5 Mikrooperationen pro Zyklus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns nun an, wie Renamer Mikrooperationen von IDQ übernimmt. Dafür brauchen wir </font></font><code>idq_uops_not_delivered.core</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>idq_uops_not_delivered.cycles_le_N_uop_deliv.core</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kv/mg/qv/kvmgqvwgra-j4qgpxia46mwlsh4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Möglicherweise stellen Sie fest, dass bei 7 Mikrooperationen jeweils nur 3 Mikrooperationen die Hälfte der Renamer-Zyklen benötigen. Von hier aus erhalten wir einen Ruhestandsdurchsatz von durchschnittlich 3,5 Mikrooperationen pro Zyklus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer interessanter Punkt in Bezug auf dieses Beispiel ist zu sehen, wenn wir den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effektiven</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durchsatz der Pensionierung </font><font style="vertical-align: inherit;">berücksichtigen </font><font style="vertical-align: inherit;">. Jene. ohne Berücksichtigung </font></font><code>uops_retired.stall_cycles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uo/hy/gt/uohygtod0xknhsvolqjnig7tfos.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es kann angemerkt werden, dass bei 7 Mikrooperationen alle 7 Maßnahmen die Stilllegung von 4 Mikrooperationen durchgeführt wird und jede 8. Maßnahme ohne Mikrooperationen im Ruhestand im Leerlauf ist (Stillstandsstand). </font><font style="vertical-align: inherit;">Nach einer Reihe von Experimenten konnte festgestellt werden, dass ein solches Verhalten immer während 7 Mikrooperationen beobachtet wurde, unabhängig von deren Anordnung 1-6, 6-1, 2-5, 5-2, 3-4, 4-3. </font><font style="vertical-align: inherit;">Ich weiß nicht, warum dies genau der Fall ist, und nicht zum Beispiel wird die Stilllegung von 3 Mikrooperationen in einem Taktzyklus und von 4 im nächsten durchgeführt. </font><font style="vertical-align: inherit;">Agner Fog erwähnte, dass Zweigübergänge nur einen Teil der Slots der Ruhestandsstation nutzen können. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielleicht ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diese Einschränkung der Grund für dieses Ruhestandsverhalten.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu verstehen, ob dies alles in der Praxis Auswirkungen hat, betrachten Sie das folgende etwas praktischere Beispiel als bei </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es werden zwei Arrays angegeben </font></font><code>unsigned</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es ist notwendig, die Summe der arithmetischen Mittelwerte für jeden Index zu akkumulieren und in das dritte Array zu schreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Beispielimplementierung könnte folgendermaßen aussehen:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> arr1[] = { ... };<font></font>
<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> arr2[] = { ... };<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arithmetic_mean</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> *arr1, <span class="hljs-keyword">unsigned</span> *arr2, <span class="hljs-keyword">unsigned</span> *out, <span class="hljs-keyword">size_t</span> sz)</span></span>{
    <span class="hljs-keyword">unsigned</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">size_t</span> idx = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(idx &lt; sz){<font></font>
        sum += (arr1[idx] + arr2[idx]) &gt;&gt; <span class="hljs-number">1</span>;<font></font>
        out[idx] = sum;<font></font>
        idx++;<font></font>
    }<font></font>
    __asm__ __volatile__(<span class="hljs-string">""</span> ::: <span class="hljs-string">"memory"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    <span class="hljs-keyword">unsigned</span> out[<span class="hljs-keyword">sizeof</span> arr1 / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span>)];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4096</span> * <span class="hljs-number">4096</span>; i++){<font></font>
        arithmetic_mean(arr1, arr2, out, <span class="hljs-keyword">sizeof</span> arr1 / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span>));<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompilieren Sie mit gcc-Flags </font></font><br>
<br>
<pre><code class="plaintext hljs">-Werror<font></font>
-Wextra<font></font>
-Wall<font></font>
-pedantic<font></font>
-Wno-stack-protector<font></font>
-g3<font></font>
-O3<font></font>
-Wno-unused-result<font></font>
-Wno-unused-parameter</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist ziemlich offensichtlich, dass die Funktion </font></font><code>arithmetic_mean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht im Code vorhanden ist und direkt in Folgendes eingefügt wird </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">(gdb) disas main<font></font>
Dump of assembler code for function main:<font></font>
   #...<font></font>
   0x00000000000005dc &lt;+60&gt;:    nop    DWORD PTR [rax+0x0]<font></font>
   0x00000000000005e0 &lt;+64&gt;:    mov    edx,DWORD PTR [rdi+rax*4]<font></font>
   0x00000000000005e3 &lt;+67&gt;:    add    edx,DWORD PTR [r8+rax*4]<font></font>
   0x00000000000005e7 &lt;+71&gt;:    shr    edx,1<font></font>
   0x00000000000005e9 &lt;+73&gt;:    add    ecx,edx<font></font>
   0x00000000000005eb &lt;+75&gt;:    mov    DWORD PTR [rsi+rax*4],ecx<font></font>
   0x00000000000005ee &lt;+78&gt;:    add    rax,0x1<font></font>
   0x00000000000005f2 &lt;+82&gt;:    cmp    rax,0x80<font></font>
   0x00000000000005f8 &lt;+88&gt;:    jne    0x5e0 &lt;main+64&gt;<font></font>
   0x00000000000005fa &lt;+90&gt;:    sub    r9,0x1<font></font>
   0x00000000000005fe &lt;+94&gt;:    jne    0x5d8 &lt;main+56&gt;<font></font>
   #...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass der Compiler den Schleifencode auf 32 Bytes ( </font></font><code>nop DWORD PTR [rax+0x0]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) ausgerichtet hat, was genau das ist, was wir brauchen. </font><font style="vertical-align: inherit;">Nachdem sichergestellt wurde, dass kein </font></font><code>resource_stalls.any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Back-End vorhanden ist (alle Messungen werden unter Berücksichtigung des beheizten L1d-Cache durchgeführt), können wir beginnen, die mit der Lieferung an IDQ verbundenen Zähler zu berücksichtigen:</font></font><br>
<br>
<pre><code class="plaintext hljs"> Performance counter stats for './test_decoded_icache':<font></font>
<font></font>
     2 273 343 251      idq.all_dsb_cycles_4_uops                                     (15,94%)<font></font>
     4 458 322 025      idq.all_dsb_cycles_any_uops                                     (16,26%)<font></font>
    15 473 065 238      idq.dsb_uops                                                  (16,59%)<font></font>
     4 358 690 532      idq.dsb_cycles                                                (16,91%)<font></font>
     2 528 373 243      idq_uops_not_delivered.core                                     (16,93%)<font></font>
        73 728 040      idq_uops_not_delivered.cycles_0_uops_deliv.core                                     (16,93%)<font></font>
       107 262 304      idq_uops_not_delivered.cycles_le_1_uop_deliv.core                                     (16,93%)<font></font>
       108 454 043      idq_uops_not_delivered.cycles_le_2_uop_deliv.core                                     (16,65%)<font></font>
     2 248 557 762      idq_uops_not_delivered.cycles_le_3_uop_deliv.core                                     (16,32%)<font></font>
     2 385 493 805      idq_uops_not_delivered.cycles_fe_was_ok                                     (16,00%)<font></font>
    15 147 004 678     uops_retired.retire_slots<font></font>
    4 724 790 623      uops_retired.total_cycles<font></font>
       <font></font>
     1,228684264 seconds time elapsed<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass in diesem Fall die Ausfallbreite für den Ruhestand = 15147004678/4724790623 = 3.20585733562 ist und dass nur 3 Mikrooperationen die Hälfte der Uhren von Renamer benötigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen Sie nun die Implementierung der manuellen Schleife zur Implementierung hinzu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arithmetic_mean</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> *arr1, <span class="hljs-keyword">unsigned</span> *arr2, <span class="hljs-keyword">unsigned</span> *out, <span class="hljs-keyword">size_t</span> sz)</span></span>{
    <span class="hljs-keyword">unsigned</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">size_t</span> idx = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(sz &amp; <span class="hljs-number">2</span>){<font></font>
        sum += (arr1[idx] + arr2[idx]) &gt;&gt; <span class="hljs-number">1</span>;<font></font>
        out[idx] = sum;<font></font>
        idx++;<font></font>
    }<font></font>
    <span class="hljs-keyword">while</span>(idx &lt; sz){<font></font>
        sum += (arr1[idx] + arr2[idx]) &gt;&gt; <span class="hljs-number">1</span>;<font></font>
        out[idx] = sum;<font></font>
        idx++;<font></font>
        sum += (arr1[idx] + arr2[idx]) &gt;&gt; <span class="hljs-number">1</span>;<font></font>
        out[idx] = sum;<font></font>
        idx++;  <span class="hljs-comment">//   idx++     idx+=2</span><font></font>
    }<font></font>
    __asm__ __volatile__(<span class="hljs-string">""</span> ::: <span class="hljs-string">"memory"</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die resultierenden Leistungsindikatoren sehen aus wie:</font></font><br>
<br>
<pre><code class="plaintext hljs">Performance counter stats for './test_decoded_icache':<font></font>
<font></font>
     2 152 818 549      idq.all_dsb_cycles_4_uops                                     (14,79%)<font></font>
     3 207 203 856      idq.all_dsb_cycles_any_uops                                     (15,25%)<font></font>
    12 855 932 240      idq.dsb_uops                                                  (15,70%)<font></font>
     3 184 814 613      idq.dsb_cycles                                                (16,15%)<font></font>
        24 946 367      idq_uops_not_delivered.core                                     (16,24%)<font></font>
         3 011 119      idq_uops_not_delivered.cycles_0_uops_deliv.core                                     (16,24%)<font></font>
         5 239 222      idq_uops_not_delivered.cycles_le_1_uop_deliv.core                                     (16,24%)<font></font>
         7 373 563      idq_uops_not_delivered.cycles_le_2_uop_deliv.core                                     (16,24%)<font></font>
         7 837 764      idq_uops_not_delivered.cycles_le_3_uop_deliv.core                                     (16,24%)<font></font>
     3 418 529 799      idq_uops_not_delivered.cycles_fe_was_ok                                     (16,24%)<font></font>
     3 444 833 440      uops_retired.total_cycles                                     (18,18%)<font></font>
    13 037 919 196      uops_retired.retire_slots                                     (18,17%)<font></font>
<font></font>
    0,871040207 seconds time elapsed</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall haben wir eine Ruhestandsbandbreite = 13037919196/3444833440 = 3.78477491672 sowie eine effiziente Nutzung der Renamer-Bandbreite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise haben wir nicht nur eine Verzweigungs- und eine Inkrementierungsoperation in einem Zyklus beseitigt, sondern auch die Ausfallbandbreite erhöht, indem der Durchsatz des Mikrooperationscaches effizient genutzt wurde, was zu einer Leistungssteigerung von insgesamt 28% führte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass nur eine Reduzierung einer Verzweigungs- und Inkrementierungsoperation eine durchschnittliche Leistungssteigerung von 9% ergibt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kleine Bemerkung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der CPU, die zur Durchführung dieser Experimente verwendet wurde, ist LSD ausgeschaltet. </font><font style="vertical-align: inherit;">Es scheint, dass LSD mit einer solchen Situation umgehen könnte. </font><font style="vertical-align: inherit;">Bei CPUs mit aktiviertem LSD müssen solche Fälle separat untersucht werden.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de497278/index.html">Flattern. Asynchronität und Parallelität</a></li>
<li><a href="../de497280/index.html">Wie ich aufhörte, Angst zu haben und mich in Cholesterin verliebte</a></li>
<li><a href="../de497282/index.html">Bereinigen Sie den Code in Angular. Kochen ESLint, Codelyzer, Stylelint, Husky, Fussel inszeniert und hübscher</a></li>
<li><a href="../de497286/index.html">Ludum Dare: Checkliste eine Woche vor dem Start</a></li>
<li><a href="../de497288/index.html">Dekorative Deckenleuchte Feron AL5000</a></li>
<li><a href="../de497292/index.html">Technologie-Stapel-Shiro-Spiele</a></li>
<li><a href="../de497296/index.html">Beliebte Fehler in Englisch bei IT-Fachleuten. Teil 2: Aussprache</a></li>
<li><a href="../de497302/index.html">Autonome Navigation eines mobilen Roboters</a></li>
<li><a href="../de497304/index.html">Intercepter-NG 2.5 für Android veröffentlicht</a></li>
<li><a href="../de497306/index.html">DLL-Spoofing (DLL-Hijacking)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>