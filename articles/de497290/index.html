<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòº üë©üèæ‚Äçüíª ü•à Verbessern der Leistung mithilfe des UOP-Cache auf Sandy Bridge + ü§ô üë©üèø‚Äç‚öïÔ∏è üë®üèø‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In modernen x86 Intel-Prozessoren kann die Pipeline in zwei Teile unterteilt werden: Front-End und Back-End. 
 
 Das Front-End ist daf√ºr verantwortlic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Verbessern der Leistung mithilfe des UOP-Cache auf Sandy Bridge +</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/497290/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In modernen x86 Intel-Prozessoren kann die Pipeline in zwei Teile unterteilt werden: Front-End und Back-End. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Front-End ist daf√ºr verantwortlich, Code aus dem Speicher zu laden und in Mikrooperationen zu dekodieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Back-End ist f√ºr die Durchf√ºhrung von Mikrooperationen vom Front-End aus verantwortlich. </font><font style="vertical-align: inherit;">Da diese Mikrooperationen vom Kernel au√üerhalb der Reihenfolge ausgef√ºhrt werden k√∂nnen, stellt das Back-End auch sicher, dass das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dieser Mikrooperationen genau der Reihenfolge entspricht, in der sie im Code enthalten sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den meisten F√§llen wirkt sich eine ineffiziente Verwendung von Front End'a nicht sp√ºrbar auf die Leistung aus. </font><font style="vertical-align: inherit;">Die maximale Bandbreite auf den meisten Intel-Prozessoren betr√§gt 4 Mikrooperationen pro Zyklus. Daher kann die CPU beispielsweise einen speicher- / L3-gebundenen Code nicht vollst√§ndig nutzen.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pro relativ neuer Ice Lake</font></font></b><div class="spoiler_text">   ,      Ice Lake    4  5   .  ,        ,         . <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einigen F√§llen kann der Leistungsunterschied jedoch erheblich sein. </font><font style="vertical-align: inherit;">Unter dem Schnitt befindet sich eine Analyse der Auswirkungen des Mikrooperations-Cache auf die Leistung.</font></font><br>
<a name="habracut"></a><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Inhalt des Artikels</font></font></h4><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Umgebung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úbersicht √ºber Front End'a Intel-Prozessoren</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spitzenbandbreitenanalyse ¬µop-Cache -&gt; IDQ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Umgebung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr alle Messungen in diesem Artikel wird </font></font><code>i7-8550U Kaby Lake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HT aktiviert / verwendet </font></font><code>Ubuntu 18.04/Linux Kernel 5.3.0-45-generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In diesem Fall kann eine solche Umgebung von Bedeutung sein, weil </font><font style="vertical-align: inherit;">Jedes CPU-Modell hat ein eigenes Leistungsereignis. </font><font style="vertical-align: inherit;">Insbesondere f√ºr Mikroarchitekturen, die √§lter als Sandy Bridge sind, sind einige der in Zukunft verwendeten Ereignisse einfach nicht sinnvoll.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úbersicht √ºber Front End'a Intel-Prozessoren</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die √ºbergeordnete Flie√übandorganisation ist √∂ffentlich verf√ºgbar und wird in der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offiziellen Dokumentation von Intel zur Softwareoptimierung ver√∂ffentlicht</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Eine detailliertere Beschreibung einiger Funktionen, die in der offiziellen Dokumentation nicht aufgef√ºhrt sind, finden Sie in anderen seri√∂sen Quellen wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agner Fog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travis Downs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">So sieht beispielsweise das Assembly-Pipeline-Schema f√ºr Skylake in der Intel-Dokumentation folgenderma√üen aus: Schauen </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qe/jr/xa/qejrxaieyvky3yjl5yps8toljme.png" alt="Skylake-Pipeline"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
wir uns </font><font style="vertical-align: inherit;">den </font><font style="vertical-align: inherit;">Anfang dieses Schemas genauer </font><font style="vertical-align: inherit;">an </font><font style="vertical-align: inherit;">- das Front-End. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dp/ya/yw/dpyaywk2lq0qub5zh4dvjlqwjn4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Legacy Decode Pipeline ist f√ºr die Dekodierung des Codes in Mikrooperationen verantwortlich. </font><font style="vertical-align: inherit;">Es besteht aus folgenden Komponenten:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instruction Fetch Unit - IFU</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First Level Instructions Cache - L1i</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adresscache f√ºr die √úbersetzung von Anweisungsprotokollen - ITLB</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instructor Prefector</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pre-Decoder-Anweisungen</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warteschlange vordecodierter Anweisungen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vordecodierte Befehlsdecoder f√ºr die Mikrooperation</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie jeden Teil der Legacy Decode-Pipeline einzeln. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instruction Fetch Unit. </font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Er ist verantwortlich f√ºr das Laden des Codes, das Vorcodieren (Bestimmen der L√§nge des Befehls und der Eigenschaften, z. B. "ob der Befehl ein Zweig ist") und das Bereitstellen vordecodierter Befehle an die Warteschlange. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First Level Instructions Cache - L1i</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Herunterladen des Codes verwendet die IFU L1i, den Anweisungscache der ersten Ebene, und L2 / LLC, den Cache der zweiten Ebene und den Offcore-Cache der obersten Ebene, die Code und Daten gemeinsam haben. Der Download erfolgt in Teilen von 16 Bytes, die ebenfalls auf 16 Bytes ausgerichtet sind. Wenn der n√§chste 16-Byte-Code der Reihe nach geladen wird, wird L1i aufgerufen, und wenn die entsprechende Zeile nicht gefunden wird, wird eine Suche in L2 und im Fehlerfall in LLC und Speicher durchgef√ºhrt. Vor Skylake LLC war der Cache inklusive - jede Zeile in L1 (i / d) und L2 sollte in der LLC enthalten sein. Somit "wusste" LLC √ºber alle Leitungen in allen Kernen Bescheid und im Fall von LLC-Fehlern war bekannt, ob die Caches in anderen Kernen die erforderliche Zeile im modifizierten Zustand enthielten, was bedeutet, dass diese Leitung von einem anderen Kern geladen werden konnte. Skylake LLC wurde zu einem nicht inklusive L2-Opfer-Cache, aber die L2-Gr√∂√üe wurde viermal erh√∂ht. Ich wei√ü es nichtob L2 in Bezug auf L1i inklusive ist. L2</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inklusive in Bezug auf L1d. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úbersetzung logischer Adressadressen - ITLB</font></font></b> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Bevor Sie Daten aus dem Cache herunterladen, m√ºssen Sie nach der entsprechenden Zeile suchen. Bei </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assoziativen Zwischencaches</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann sich jede Zeile an </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verschiedenen Stellen im Cache selbst befinden. Um die m√∂glichen Positionen im Cache zu bestimmen, wird ein Index verwendet (normalerweise einige niedrigere Bits der Adresse). Um festzustellen, ob die Zeile mit der von uns ben√∂tigten Adresse √ºbereinstimmt, wird ein Tag verwendet (der Rest der Adresse). Welche Adressen verwendet werden sollen: physisch oder logisch - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h√§ngt von der Cache-Implementierung ab</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Verwendung physischer Adressen erfordert eine Adress√ºbersetzung. F√ºr die Adressumsetzung wird ein TLB-Puffer verwendet, der die Ergebnisse von Seitenl√§ufen zwischenspeichert, wodurch die Verz√∂gerung beim Empfang einer physischen Adresse von einer logischen Adresse bei nachfolgenden Aufrufen verringert wird. F√ºr Anweisungen gibt es einen eigenen Anweisungs-TLB-Puffer, der sich getrennt vom Daten-TLB befindet. Der CPU-Kern verf√ºgt au√üerdem √ºber einen TLB der zweiten Ebene, der Code und Daten gemeinsam ist - STLB. Ob STLB inklusive ist, ist mir unbekannt (es wird gemunkelt, dass es sich nicht um einen inklusive Opfer-Cache im Vergleich zu D / I TLB handelt). Verwenden von Software-Prefetch-Anweisungen</font></font><code>prefetcht1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen die Zeile mit dem Code in L2 aufrufen, der entsprechende TLB-Datensatz wird jedoch nur in DTLB aufgerufen. </font><font style="vertical-align: inherit;">Wenn STLB nicht inklusive ist, erhalten Sie bei der Suche nach dieser Zeile mit dem Code in den Caches ITLB-Fehler -&gt; STLB-Fehler -&gt; Seitenlauf (tats√§chlich ist dies nicht so einfach, da der Kernel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen spekulativen Seitenlauf initiieren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">,</font></a><font style="vertical-align: inherit;"> bevor dies geschieht TLB Miss). </font><font style="vertical-align: inherit;">Die Intel-Dokumentation r√§t auch von der Verwendung von SW-Prefetches f√ºr Code ab. Intel Software Optimization Manual / 2.5.5.4:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der softwaregesteuerte Prefetch dient zum Prefetching von Daten, nicht jedoch zum Prefetching von Code.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Travis D. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erw√§hnte jedoch,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dass ein solcher Prefetch sehr effektiv sein kann (und h√∂chstwahrscheinlich auch), aber dies ist mir bisher nicht klar, und um davon √ºberzeugt zu sein, muss ich dieses Problem separat untersuchen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instructor Prefector</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Laden von Daten in den Cache (L1d / i, L2 usw.) erfolgt beim Zugriff auf einen nicht zwischengespeicherten Speicherort. </font><font style="vertical-align: inherit;">Wenn dies jedoch nur unter solchen Bedingungen geschehen w√ºrde, w√ºrden wir als Ergebnis eine ineffiziente Nutzung der Cache-Bandbreite erhalten. </font><font style="vertical-align: inherit;">Zum Beispiel auf Sandy Bridge f√ºr L1d - 2 Leseoperationen, 1 Schreibvorgang 16 Bytes pro Zyklus; </font><font style="vertical-align: inherit;">F√ºr den L1i-1-Lesevorgang mit 16 Bytes ist der Schreibdurchsatz in der Dokumentation nicht angegeben. Agner Fog wurde ebenfalls nicht gefunden. </font><font style="vertical-align: inherit;">Um dieses Problem zu l√∂sen, gibt es Hardware-Prefetchers, die das Muster des Zugriffs auf den Speicher bestimmen und die erforderlichen Zeilen in den Cache ziehen k√∂nnen, bevor der Code sie tats√§chlich adressiert. </font><font style="vertical-align: inherit;">Die Intel-Dokumentation definiert 4 Prefetchers: 2 f√ºr L1d, 2 f√ºr L2:</font></font><br>
<br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 DCU</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Serielle Cache-Zeilen mit Pr√§fix. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schreibgesch√ºtzt weiterleiten</font></font></b></li>
<li><b>L1 IP</b> ‚Äî              (. 0x5555555545a0, 0x5555555545b0, 0x5555555545c0, ...),    ,   ,  </li>
<li><b>L2 Spatial</b> ‚Äî       L2    -,        128-.       LLC</li>
<li><b>L2 Streamer</b> ‚Äî    .    L1 DCU      ¬´¬ª.       LLC</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Intel-Dokumentation beschreibt nicht das Prinzip des L1i-Pr√§fektors. </font><font style="vertical-align: inherit;">Es ist lediglich bekannt, dass die Branch Prediction Unit (BPU) an diesem Prozess beteiligt ist. Intel Software Optimization Manual / 2.6.2: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/js/y3/sdjsy3jrgseyeuukletr84i2gyu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agner Fog sieht ebenfalls keine Details. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Code-Prefetching in L2 / LLC ist explizit nur f√ºr Streamer definiert. </font><font style="vertical-align: inherit;">Optimierungshandbuch / 2.5.5.4 Datenpr√§fektion:</font></font><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streamer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dieser Prefetcher √ºberwacht Leseanforderungen aus dem L1-Cache auf aufsteigende und absteigende Folgen von Adressen. </font><font style="vertical-align: inherit;">Zu den √ºberwachten Leseanforderungen geh√∂ren L1-DCache-Anforderungen, die durch Lade- und Speicheroperationen sowie durch die Hardware-Prefetchers initiiert wurden, sowie L1-ICache-Anforderungen f√ºr das Abrufen von Code.</font></font></blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr den Spatial Prefetcher ist dies eindeutig nicht klargestellt:</font></font><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spatial Prefetcher:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dieser Prefetcher versucht, jede in den L2-Cache abgerufene Cache-Zeile mit der Paarzeile zu vervollst√§ndigen, die ihn zu einem 128-Byte-ausgerichteten Block vervollst√§ndigt.</font></font></blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies kann jedoch √ºberpr√ºft werden. </font><font style="vertical-align: inherit;">Jeder dieser Prefetchers kann mithilfe von deaktiviert werden </font></font><code>MSR 0x1A4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wie im Handbuch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modellspezifische Register beschrieben.</font></font></a><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úber MSR 0x1A4</font></font></b><div class="spoiler_text">  MSR     L2 Spatial    L1i.     .              ,    LLC.     L2 Streamer       2.5 . <br>
<br>
 Linux  msr ,   msr     .  <code>$ sudo wrmsr -p 1 0x1a4 1</code>  L2 Streamer   1.<br>
</div></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pre-Decoder-Anweisungen</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nachdem der n√§chste 16-Byte-Code geladen wurde, fallen sie in die Pre-Decoder-Anweisungen. </font><font style="vertical-align: inherit;">Seine Aufgabe ist es, die L√§nge der Anweisung zu bestimmen, die Pr√§fixe zu dekodieren und zu markieren, ob die entsprechende Anweisung eine Verzweigung ist (h√∂chstwahrscheinlich gibt es noch viele verschiedene Eigenschaften, aber die Dokumentation dar√ºber enth√§lt keine Informationen). </font><font style="vertical-align: inherit;">Intel Software Optimization Manual / 2.6.2.2:</font></font><br>
<blockquote>The predecode unit accepts the sixteen bytes from the instruction cache or prefetch buffers and carries out the following tasks:<br>
<br>
<ul>
<li>Determine the length of the instructions</li>
<li>Decode all prefixes associated with instructions</li>
<li>Mark various properties of instructions for the decoders (for example, ‚Äúis branch.‚Äù)</li>
</ul></blockquote><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Reihe vordecodierter Anweisungen. </font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von der IFU werden Anweisungen zur vorcodierten Anweisungswarteschlange hinzugef√ºgt. </font><font style="vertical-align: inherit;">Diese Warteschlange ist seit Nehalem aufgetaucht. Gem√§√ü der Intel-Dokumentation hat sie eine Gr√∂√üe von 18 Anweisungen. </font><font style="vertical-align: inherit;">Agner Fog erw√§hnt auch, dass diese Warteschlange nicht mehr als 64 Bytes enth√§lt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auch in Core2 wurde diese Warteschlange als Schleifencache verwendet. </font><font style="vertical-align: inherit;">Wenn sich alle Mikrooperationen aus dem Zyklus in der Warteschlange befinden, k√∂nnen in einigen F√§llen die Kosten f√ºr das Laden und die Vorcodierung vermieden werden. </font><font style="vertical-align: inherit;">Der Loop Stream Detector (LSD) kann Anweisungen liefern, die sich bereits in der Warteschlange befinden, bis die BPU signalisiert, dass der Zyklus beendet wurde. </font><font style="vertical-align: inherit;">Agner Fog hat eine Reihe interessanter Hinweise zu LSD auf Core2:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besteht aus 4 Zeilen mit 16 Bytes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spitzendurchsatz bis zu 32 Byte Code pro Zyklus</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnend mit Sandy Bridge wurde dieser Schleifencache von der vordecodierten Anweisungswarteschlange zur√ºck zu IDQ verschoben. </font></font><br>
 <br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decoder von vordecodierten Anweisungen in der Mikrooperation</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Aus der Warteschlange von </font><b><font style="vertical-align: inherit;">vordecodierten</font></b><font style="vertical-align: inherit;"> Anweisungen wird der Code zur Decodierung in der Mikrooperation gesendet. Decoder sind f√ºr die Decodierung verantwortlich - insgesamt gibt es 4. Laut Intel-Dokumentation kann einer der Decoder Anweisungen dekodieren, die aus 4 Mikrooperationen oder weniger bestehen. Der Rest decodiert Anweisungen, die aus einer Mikrooperation (Mikro- / Makro-Fusion) bestehen, Intel Software Optimization Manual / 2.5.2.1:</font></font><br>
<blockquote>There are four decoding units that decode instruction into micro-ops. The first can decode all IA-32 and Intel 64 instructions up to four micro-ops in size. The remaining three decoding units handle single-micro-op instructions. All four decoding units support the common cases of single micro-op flows including micro-fusion and macro-fusion.</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anweisungen, die in einer gro√üen Anzahl von Mikrooperationen decodiert wurden (z. B. rep movsb, die bei der Implementierung von memcpy in libc auf bestimmten Gr√∂√üen des kopierten Speichers verwendet werden), stammen vom Microcode Sequencer (MS ROM). Die Spitzenbandbreite des Sequenzers betr√§gt 4 Mikrooperationen pro Zyklus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie im Flie√übanddiagramm sehen k√∂nnen, kann die Legacy Decode Pipeline auf Skylake bis zu 5 Mikrooperationen pro Zyklus decodieren. Bei Broadwell und √§lteren Versionen betrug der Spitzendurchsatz der Legacy Decode Pipeline 4 Mikrooperationen pro Zyklus. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mikrooperations-Cache</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem die Anweisungen in Mikrooperationen decodiert wurden, fallen sie aus der Legacy Decode Pipeline in die spezielle Mikrooperationswarteschlange - Instruction Decode Queue (IDQ) - sowie in den sogenannten Mikrooperationscache (Decoded ICache, ¬µop Cache). Der Mikrooperations-Cache wurde urspr√ºnglich in Sandy Bridge eingef√ºhrt und wird verwendet, um das Abrufen und Dekodieren von Anweisungen bei Mikrooperationen zu vermeiden, wodurch der Durchsatz f√ºr die Bereitstellung von Mikrooperationen in IDQ erh√∂ht wird - bis zu 6 pro Zyklus. Nach dem Einstieg in IDQ werden Mikrooperationen zur Ausf√ºhrung mit einem Spitzendurchsatz von 4 Mikrooperationen pro Zyklus an das Back-End gesendet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Laut Intel-Dokumentation besteht der Mikrooperations-Cache aus 32 S√§tzen, jeder Satz enth√§lt 8 Zeilen, jede Zeile kann bis zu 6 Mikrooperationen (Mikro- / Makro-Fusion) zwischenspeichern, was einen Gesamt-Cache von bis zu 32 * 8 * 6 = 1536 Mikrooperationen erm√∂glicht . </font><font style="vertical-align: inherit;">Das Zwischenspeichern von Mikrooperationen erfolgt mit einer Granularit√§t von 32 Bytes, d.h. </font><font style="vertical-align: inherit;">Mikrooperationen, die Anweisungen aus verschiedenen 32-Byte-Regionen folgen, k√∂nnen nicht in eine Zeile fallen. </font><font style="vertical-align: inherit;">Bis zu 3 verschiedene Cache-Zeilen k√∂nnen jedoch einer 32-Byte-Region entsprechen. </font><font style="vertical-align: inherit;">Somit k√∂nnen bis zu 18 Mikrooperationen im ¬µop-Cache jeder 32-Byte-Region entsprechen.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intel Software Optimization Manual / 2.5.5.2</font></font></b><div class="spoiler_text"><blockquote>The Decoded ICache consists of 32 sets. Each set contains eight Ways. Each Way can hold up to six micro-ops. The Decoded ICache can ideally hold up to 1536 micro-ops. The following are some of the rules how the Decoded ICache is filled with micro-ops:<br>
<br>
<ul>
<li>ll micro-ops in a Way represent instructions which are statically contiguous in the code and have their EIPs within the same aligned 32-byte region.</li>
<li>Up to three Ways may be dedicated to the same 32-byte aligned chunk, allowing a total of 18 micro-ops to be cached per 32-byte region of the original IA program.</li>
<li>A multi micro-op instruction cannot be split across Ways.</li>
<li>Up to two branches are allowed per Way. </li>
<li>An instruction which turns on the MSROM consumes an entire Way.</li>
<li>A non-conditional branch is the last micro-op in a Way. </li>
<li>Micro-fused micro-ops (load+op and stores) are kept as one micro-op.</li>
<li>A pair of macro-fused instructions is kept as one micro-op.</li>
<li>Instructions with 64-bit immediate require two slots to hold the immediate.</li>
</ul></blockquote><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agner Fog erw√§hnt auch, dass nur einzeilige Mikrooperationen pro Zyklus heruntergeladen werden k√∂nnen (in der Intel-Dokumentation nicht explizit angegeben, obwohl dies leicht manuell √ºberpr√ºft werden kann).</font></font><br>
<br>
<h4>    ¬µop cache --&gt; IDQ</h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einigen F√§llen ist es sehr praktisch, </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√§ngen </font><font style="vertical-align: inherit;">von </font><font style="vertical-align: inherit;">1 Byte </font><font style="vertical-align: inherit;">zu verwenden, um das Verhalten des Frontends zu untersuchen </font><font style="vertical-align: inherit;">. Gleichzeitig k√∂nnen wir sicher sein, dass wir aus irgendeinem Grund das Front-End und nicht den Resource Stall am Back-End untersuchen. Tatsache ist, dass sie </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neben anderen Anweisungen in der Legacy Decode Pipeline decodiert, im ¬µop-Cache gemischt und an IDQ gesendet werden. Weiter </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sowie andere Anweisungen, nimmt Back-End. Der wesentliche Unterschied besteht darin, dass bei den Ressourcen im Back-End </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachbestellungspuffer verwendet wird</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und kein Steckplatz in der Reservierungsstation (auch als Scheduler bezeichnet) erforderlich ist. Somit ist es unmittelbar nach Eingabe </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des Bestellpuffers f√ºr den Ruhestand bereit, der gem√§√ü der Reihenfolge im Programmcode ausgef√ºhrt wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deklarieren Sie eine Funktion, um den Durchsatz zu testen </font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_decoded_icache</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> iteration_count)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mit Umsetzung am </font></font><code>nasm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">align 32<font></font>
test_decoded_icache:<font></font>
    ;nop',  0  23 <font></font>
    dec rdi<font></font>
    ja test_decoded_icache<font></font>
    ret</code></pre><br>
<code>ja</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wurde nicht zuf√§llig ausgew√§hlt. </font></font><code>ja</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwenden Sie verschiedene Flags - </font></font><code>ja</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liest von </font></font><code>CF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>ZF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nimmt </font></font><code>dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht in der CF auf, sodass Macro Fusion nicht angewendet wird. </font><font style="vertical-align: inherit;">Dies geschieht lediglich, um Mikrooperationen in einem Zyklus bequem z√§hlen zu k√∂nnen - jeder Befehl entspricht einer Mikrooperation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr Messungen ben√∂tigen wir die folgenden Perf-Ereignisse: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. </font></font><code>uops_issued.any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Wird verwendet, um die Mikrooperationen zu z√§hlen, die Renamer von IDQ √ºbernimmt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Intel System Programming Guide dokumentiert dieses Ereignis als die Anzahl der Mikrooperationen, die Renamer in die Reservierungsstation einf√ºgt:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z√§hlt die Anzahl der Uops, die die Resource Allocation Table (RAT) an die Reservation Station (RS) ausgibt.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Beschreibung korreliert nicht vollst√§ndig mit den Werten, die aus Experimenten erhalten werden k√∂nnen. Insbesondere </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fallen sie in diesen Schalter, obwohl es nur eine Tatsache ist, dass sie an der Reservierungsstation √ºberhaupt nicht ben√∂tigt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. </font></font><code>uops_retired.retire_slots</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- die Gesamtzahl der Mikrooperationen im Ruhestand unter Ber√ºcksichtigung der Mikro- / Makrofusion </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. </font></font><code>uops_retired.stall_cycles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- die Anzahl der Zecken, f√ºr die es keine einzige Mikrooperation im Ruhestand gab </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. </font></font><code>resource_stalls.any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- die Anzahl der Zecken im Leerlauff√∂rderer aufgrund der Unzug√§nglichkeit einer der Ressourcen Back-End </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
im Intel Software Optimization Manual / B. .4.1 Es gibt ein Inhaltsdiagramm, das die oben beschriebenen Ereignisse charakterisiert: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wq/j9/y3/wqj9y3jj7aeisnmdjxxxjwsl_jk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5. </font></font><code>idq.all_dsb_cycles_4_uops</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Die Anzahl der Taktzyklen, f√ºr die 4 (oder mehr) Anweisungen aus dem ¬µop-Cache geliefert wurden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Tatsache, dass diese Metrik die Bereitstellung von mehr als 4 Mikrooperationen pro Zyklus ber√ºcksichtigt, wird in der Intel-Dokumentation nicht beschrieben, stimmt jedoch sehr gut mit den Experimenten √ºberein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6. </font></font><code>idq.all_dsb_cycles_any_uops</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- die Anzahl der Ma√ünahmen, f√ºr die mindestens eine Mikrooperation durchgef√ºhrt wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7. </font></font><code>idq.dsb_cycles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Die Gesamtzahl der Ticks, bei denen die Lieferung aus dem ¬µop-Cache erfolgte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8. </font></font><code>idq_uops_not_delivered.cycles_le_N_uop_deliv.core</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Die Anzahl </font><font style="vertical-align: inherit;">der Ticks, </font><font style="vertical-align: inherit;">f√ºr die Renamer eine </font></font><code>N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder weniger </font><font style="vertical-align: inherit;">Mikrooperationen durchgef√ºhrt hat </font><font style="vertical-align: inherit;">und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf der Back-End-Seite keine Ausfallzeiten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufgetreten </font><font style="vertical-align: inherit;">sind. </font></font><code>N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 1, 2, 3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir nehmen Nachforschungen an </font></font><code>iteration_count = 1 &lt;&lt; 31</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wir beginnen die Analyse dessen, was in der CPU geschieht, indem wir die Anzahl der Mikrooperationen untersuchen und zun√§chst die durchschnittliche Ausfallbandbreite messen, d. H. </font></font><code>uops_retired.retire_slots/uops_retired.total_cycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">::</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xi/b2/0s/xib20shepbr334i1xmhka10rjeg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was sofort auff√§llt, ist das Absinken des Ruhestandsdurchsatzes bei einer Zyklusgr√∂√üe von 7 Mikrooperationen. Um zu verstehen, worum es geht, schauen wir uns an, wie sich die durchschnittliche √úbermittlungsgeschwindigkeit aus dem ¬µop-Cache √§ndert </font></font><code>idq.all_dsb_cycles_any_uops / idq.dsb_cycles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xm/5s/su/xm5ssuzamxr4th-xs7e0ixrisfm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und wie die Gesamtzahl der Kennzahlen und Kennzahlen, f√ºr die der ¬µop-Cache an IDQ geliefert wird, zusammenh√§ngt: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/it/w5/va/itw5vasl9ogpslneyoclxzasu4k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So k√∂nnen wir sehen, dass wir mit einem Zyklus von 6 </font><font style="vertical-align: inherit;">Mikrooperationen </font><font style="vertical-align: inherit;">eine effektive </font><font style="vertical-align: inherit;">erzielen </font><font style="vertical-align: inherit;">¬µop-Cache-Bandbreitennutzung - 6 Mikrooperationen pro Zyklus. Aufgrund der Tatsache, dass Renamer nicht so viel aufnehmen kann, wie der ¬µop-Cache liefert, liefert ein Teil der ¬µop-Cache-Zyklen nichts, was im vorherigen Diagramm deutlich sichtbar ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei einem Zyklus von 7 Mikrooperationen sinkt der Durchsatz des ¬µop-Cache stark - 3,5 Mikrooperationen pro Zyklus. Gleichzeitig ist der ¬µop-Cache, wie aus dem vorherigen Diagramm ersichtlich, st√§ndig in Betrieb. Mit einem Zyklus von 7 Mikrooperationen erhalten wir somit eine ineffiziente Auslastung des Bandbreiten-¬µop-Cache. Tatsache ist, dass, wie bereits erw√§hnt, der ¬µop-Cache pro Zyklus Mikrooperationen von nur einer Zeile liefern kann. Bei Mikrooperationen 7 fallen die ersten 6 in eine Zeile und die restlichen 7 in eine andere. Auf diese Weise erhalten wir 7 Mikrooperationen pro 2 Zyklen oder 3,5 Mikrooperationen pro Zyklus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns nun an, wie Renamer Mikrooperationen von IDQ √ºbernimmt. Daf√ºr brauchen wir </font></font><code>idq_uops_not_delivered.core</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>idq_uops_not_delivered.cycles_le_N_uop_deliv.core</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kv/mg/qv/kvmgqvwgra-j4qgpxia46mwlsh4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√∂glicherweise stellen Sie fest, dass bei 7 Mikrooperationen jeweils nur 3 Mikrooperationen die H√§lfte der Renamer-Zyklen ben√∂tigen. Von hier aus erhalten wir einen Ruhestandsdurchsatz von durchschnittlich 3,5 Mikrooperationen pro Zyklus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer interessanter Punkt in Bezug auf dieses Beispiel ist zu sehen, wenn wir den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effektiven</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durchsatz der Pensionierung </font><font style="vertical-align: inherit;">ber√ºcksichtigen </font><font style="vertical-align: inherit;">. Jene. ohne Ber√ºcksichtigung </font></font><code>uops_retired.stall_cycles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uo/hy/gt/uohygtod0xknhsvolqjnig7tfos.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es kann angemerkt werden, dass bei 7 Mikrooperationen alle 7 Ma√ünahmen die Stilllegung von 4 Mikrooperationen durchgef√ºhrt wird und jede 8. Ma√ünahme ohne Mikrooperationen im Ruhestand im Leerlauf ist (Stillstandsstand). </font><font style="vertical-align: inherit;">Nach einer Reihe von Experimenten konnte festgestellt werden, dass ein solches Verhalten immer w√§hrend 7 Mikrooperationen beobachtet wurde, unabh√§ngig von deren Anordnung 1-6, 6-1, 2-5, 5-2, 3-4, 4-3. </font><font style="vertical-align: inherit;">Ich wei√ü nicht, warum dies genau der Fall ist, und nicht zum Beispiel wird die Stilllegung von 3 Mikrooperationen in einem Taktzyklus und von 4 im n√§chsten durchgef√ºhrt. </font><font style="vertical-align: inherit;">Agner Fog erw√§hnte, dass Zweig√ºberg√§nge nur einen Teil der Slots der Ruhestandsstation nutzen k√∂nnen. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielleicht ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diese Einschr√§nkung der Grund f√ºr dieses Ruhestandsverhalten.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu verstehen, ob dies alles in der Praxis Auswirkungen hat, betrachten Sie das folgende etwas praktischere Beispiel als bei </font></font><code>nop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es werden zwei Arrays angegeben </font></font><code>unsigned</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es ist notwendig, die Summe der arithmetischen Mittelwerte f√ºr jeden Index zu akkumulieren und in das dritte Array zu schreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Beispielimplementierung k√∂nnte folgenderma√üen aussehen:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> arr1[] = { ... };<font></font>
<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> arr2[] = { ... };<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arithmetic_mean</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> *arr1, <span class="hljs-keyword">unsigned</span> *arr2, <span class="hljs-keyword">unsigned</span> *out, <span class="hljs-keyword">size_t</span> sz)</span></span>{
    <span class="hljs-keyword">unsigned</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">size_t</span> idx = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(idx &lt; sz){<font></font>
        sum += (arr1[idx] + arr2[idx]) &gt;&gt; <span class="hljs-number">1</span>;<font></font>
        out[idx] = sum;<font></font>
        idx++;<font></font>
    }<font></font>
    __asm__ __volatile__(<span class="hljs-string">""</span> ::: <span class="hljs-string">"memory"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    <span class="hljs-keyword">unsigned</span> out[<span class="hljs-keyword">sizeof</span> arr1 / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span>)];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4096</span> * <span class="hljs-number">4096</span>; i++){<font></font>
        arithmetic_mean(arr1, arr2, out, <span class="hljs-keyword">sizeof</span> arr1 / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span>));<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompilieren Sie mit gcc-Flags </font></font><br>
<br>
<pre><code class="plaintext hljs">-Werror<font></font>
-Wextra<font></font>
-Wall<font></font>
-pedantic<font></font>
-Wno-stack-protector<font></font>
-g3<font></font>
-O3<font></font>
-Wno-unused-result<font></font>
-Wno-unused-parameter</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist ziemlich offensichtlich, dass die Funktion </font></font><code>arithmetic_mean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht im Code vorhanden ist und direkt in Folgendes eingef√ºgt wird </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">(gdb) disas main<font></font>
Dump of assembler code for function main:<font></font>
   #...<font></font>
   0x00000000000005dc &lt;+60&gt;:    nop    DWORD PTR [rax+0x0]<font></font>
   0x00000000000005e0 &lt;+64&gt;:    mov    edx,DWORD PTR [rdi+rax*4]<font></font>
   0x00000000000005e3 &lt;+67&gt;:    add    edx,DWORD PTR [r8+rax*4]<font></font>
   0x00000000000005e7 &lt;+71&gt;:    shr    edx,1<font></font>
   0x00000000000005e9 &lt;+73&gt;:    add    ecx,edx<font></font>
   0x00000000000005eb &lt;+75&gt;:    mov    DWORD PTR [rsi+rax*4],ecx<font></font>
   0x00000000000005ee &lt;+78&gt;:    add    rax,0x1<font></font>
   0x00000000000005f2 &lt;+82&gt;:    cmp    rax,0x80<font></font>
   0x00000000000005f8 &lt;+88&gt;:    jne    0x5e0 &lt;main+64&gt;<font></font>
   0x00000000000005fa &lt;+90&gt;:    sub    r9,0x1<font></font>
   0x00000000000005fe &lt;+94&gt;:    jne    0x5d8 &lt;main+56&gt;<font></font>
   #...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass der Compiler den Schleifencode auf 32 Bytes ( </font></font><code>nop DWORD PTR [rax+0x0]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) ausgerichtet hat, was genau das ist, was wir brauchen. </font><font style="vertical-align: inherit;">Nachdem sichergestellt wurde, dass kein </font></font><code>resource_stalls.any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Back-End vorhanden ist (alle Messungen werden unter Ber√ºcksichtigung des beheizten L1d-Cache durchgef√ºhrt), k√∂nnen wir beginnen, die mit der Lieferung an IDQ verbundenen Z√§hler zu ber√ºcksichtigen:</font></font><br>
<br>
<pre><code class="plaintext hljs"> Performance counter stats for './test_decoded_icache':<font></font>
<font></font>
     2‚ÄØ273‚ÄØ343‚ÄØ251      idq.all_dsb_cycles_4_uops                                     (15,94%)<font></font>
     4‚ÄØ458‚ÄØ322‚ÄØ025      idq.all_dsb_cycles_any_uops                                     (16,26%)<font></font>
    15‚ÄØ473‚ÄØ065‚ÄØ238      idq.dsb_uops                                                  (16,59%)<font></font>
     4‚ÄØ358‚ÄØ690‚ÄØ532      idq.dsb_cycles                                                (16,91%)<font></font>
     2‚ÄØ528‚ÄØ373‚ÄØ243      idq_uops_not_delivered.core                                     (16,93%)<font></font>
        73‚ÄØ728‚ÄØ040      idq_uops_not_delivered.cycles_0_uops_deliv.core                                     (16,93%)<font></font>
       107‚ÄØ262‚ÄØ304      idq_uops_not_delivered.cycles_le_1_uop_deliv.core                                     (16,93%)<font></font>
       108‚ÄØ454‚ÄØ043      idq_uops_not_delivered.cycles_le_2_uop_deliv.core                                     (16,65%)<font></font>
     2‚ÄØ248‚ÄØ557‚ÄØ762      idq_uops_not_delivered.cycles_le_3_uop_deliv.core                                     (16,32%)<font></font>
     2‚ÄØ385‚ÄØ493‚ÄØ805      idq_uops_not_delivered.cycles_fe_was_ok                                     (16,00%)<font></font>
    15‚ÄØ147‚ÄØ004‚ÄØ678     uops_retired.retire_slots<font></font>
    4‚ÄØ724‚ÄØ790‚ÄØ623      uops_retired.total_cycles<font></font>
       <font></font>
     1,228684264 seconds time elapsed<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass in diesem Fall die Ausfallbreite f√ºr den Ruhestand = 15147004678/4724790623 = 3.20585733562 ist und dass nur 3 Mikrooperationen die H√§lfte der Uhren von Renamer ben√∂tigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºgen Sie nun die Implementierung der manuellen Schleife zur Implementierung hinzu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">arithmetic_mean</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> *arr1, <span class="hljs-keyword">unsigned</span> *arr2, <span class="hljs-keyword">unsigned</span> *out, <span class="hljs-keyword">size_t</span> sz)</span></span>{
    <span class="hljs-keyword">unsigned</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">size_t</span> idx = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(sz &amp; <span class="hljs-number">2</span>){<font></font>
        sum += (arr1[idx] + arr2[idx]) &gt;&gt; <span class="hljs-number">1</span>;<font></font>
        out[idx] = sum;<font></font>
        idx++;<font></font>
    }<font></font>
    <span class="hljs-keyword">while</span>(idx &lt; sz){<font></font>
        sum += (arr1[idx] + arr2[idx]) &gt;&gt; <span class="hljs-number">1</span>;<font></font>
        out[idx] = sum;<font></font>
        idx++;<font></font>
        sum += (arr1[idx] + arr2[idx]) &gt;&gt; <span class="hljs-number">1</span>;<font></font>
        out[idx] = sum;<font></font>
        idx++;  <span class="hljs-comment">//   idx++     idx+=2</span><font></font>
    }<font></font>
    __asm__ __volatile__(<span class="hljs-string">""</span> ::: <span class="hljs-string">"memory"</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die resultierenden Leistungsindikatoren sehen aus wie:</font></font><br>
<br>
<pre><code class="plaintext hljs">Performance counter stats for './test_decoded_icache':<font></font>
<font></font>
     2‚ÄØ152‚ÄØ818‚ÄØ549      idq.all_dsb_cycles_4_uops                                     (14,79%)<font></font>
     3‚ÄØ207‚ÄØ203‚ÄØ856      idq.all_dsb_cycles_any_uops                                     (15,25%)<font></font>
    12‚ÄØ855‚ÄØ932‚ÄØ240      idq.dsb_uops                                                  (15,70%)<font></font>
     3‚ÄØ184‚ÄØ814‚ÄØ613      idq.dsb_cycles                                                (16,15%)<font></font>
        24‚ÄØ946‚ÄØ367      idq_uops_not_delivered.core                                     (16,24%)<font></font>
         3‚ÄØ011‚ÄØ119      idq_uops_not_delivered.cycles_0_uops_deliv.core                                     (16,24%)<font></font>
         5‚ÄØ239‚ÄØ222      idq_uops_not_delivered.cycles_le_1_uop_deliv.core                                     (16,24%)<font></font>
         7‚ÄØ373‚ÄØ563      idq_uops_not_delivered.cycles_le_2_uop_deliv.core                                     (16,24%)<font></font>
         7‚ÄØ837‚ÄØ764      idq_uops_not_delivered.cycles_le_3_uop_deliv.core                                     (16,24%)<font></font>
     3‚ÄØ418‚ÄØ529‚ÄØ799      idq_uops_not_delivered.cycles_fe_was_ok                                     (16,24%)<font></font>
     3‚ÄØ444‚ÄØ833‚ÄØ440      uops_retired.total_cycles                                     (18,18%)<font></font>
    13‚ÄØ037‚ÄØ919‚ÄØ196      uops_retired.retire_slots                                     (18,17%)<font></font>
<font></font>
    0,871040207 seconds time elapsed</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall haben wir eine Ruhestandsbandbreite = 13037919196/3444833440 = 3.78477491672 sowie eine effiziente Nutzung der Renamer-Bandbreite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise haben wir nicht nur eine Verzweigungs- und eine Inkrementierungsoperation in einem Zyklus beseitigt, sondern auch die Ausfallbandbreite erh√∂ht, indem der Durchsatz des Mikrooperationscaches effizient genutzt wurde, was zu einer Leistungssteigerung von insgesamt 28% f√ºhrte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass nur eine Reduzierung einer Verzweigungs- und Inkrementierungsoperation eine durchschnittliche Leistungssteigerung von 9% ergibt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kleine Bemerkung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der CPU, die zur Durchf√ºhrung dieser Experimente verwendet wurde, ist LSD ausgeschaltet. </font><font style="vertical-align: inherit;">Es scheint, dass LSD mit einer solchen Situation umgehen k√∂nnte. </font><font style="vertical-align: inherit;">Bei CPUs mit aktiviertem LSD m√ºssen solche F√§lle separat untersucht werden.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de497278/index.html">Flattern. Asynchronit√§t und Parallelit√§t</a></li>
<li><a href="../de497280/index.html">Wie ich aufh√∂rte, Angst zu haben und mich in Cholesterin verliebte</a></li>
<li><a href="../de497282/index.html">Bereinigen Sie den Code in Angular. Kochen ESLint, Codelyzer, Stylelint, Husky, Fussel inszeniert und h√ºbscher</a></li>
<li><a href="../de497286/index.html">Ludum Dare: Checkliste eine Woche vor dem Start</a></li>
<li><a href="../de497288/index.html">Dekorative Deckenleuchte Feron AL5000</a></li>
<li><a href="../de497292/index.html">Technologie-Stapel-Shiro-Spiele</a></li>
<li><a href="../de497296/index.html">Beliebte Fehler in Englisch bei IT-Fachleuten. Teil 2: Aussprache</a></li>
<li><a href="../de497302/index.html">Autonome Navigation eines mobilen Roboters</a></li>
<li><a href="../de497304/index.html">Intercepter-NG 2.5 f√ºr Android ver√∂ffentlicht</a></li>
<li><a href="../de497306/index.html">DLL-Spoofing (DLL-Hijacking)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>