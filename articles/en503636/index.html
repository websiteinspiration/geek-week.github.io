<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò¢Ô∏è üí£ üëÜüèº What kind of load on the servers create network mechanisms? üëÉ üî£ üî´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When analyzing the operation of the network subsystem of servers, attention is usually paid to such indicators as latency, throughput of the system, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>What kind of load on the servers create network mechanisms?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/503636/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When analyzing the operation of the network subsystem of servers, attention is usually paid to such indicators as latency, throughput of the system, and the number of packets that can be processed per second (PPS, Packets Per Second). These indicators are used in order to understand under what maximum load the computer under study can work. And although these metrics are important and often able to say a lot about the system, they do not provide information on what impact processing of network packets has on programs running on the server. </font><font style="vertical-align: inherit;">
This material is aimed at studying the load created by network mechanisms on servers. In particular, we will talk about how much processor time the solution to network problems can ‚Äústeal‚Äù from various processes running on Linux systems.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/webt/q_/0y/ya/q_0yyareydlakrio4dbunpbt8fu.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Network packet processing on Linux</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linux processes a significant number of packets in the context of any process executed by the processor at the time of processing the corresponding IRQ. </font><font style="vertical-align: inherit;">The System Accounting engine will assign the processor cycles used for this to any process that is currently executing. </font><font style="vertical-align: inherit;">This will be done even if this process has nothing to do with network packet processing. </font><font style="vertical-align: inherit;">For example, a team </font></font><code>top</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">may indicate that a process appears to be using more than 99% of the processor‚Äôs resources, but in fact 60% of the processor time will be spent on processing the packets. </font><font style="vertical-align: inherit;">And this means that the process itself, solving its own problems, uses only 40% of the CPU resources. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inbound Handler</font></font><code>net_rx_action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usually performed very, very fast. For example, in less than 25 Œºs. (This data was obtained from measurements using eBPF. If you are interested in the details, look </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a> <code>net_rx_action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) The processor can process up to 64 packets per NAPI instance (NIC or RPS) before postponing the task to another SoftIRQ cycle. One after another, without a break, up to 10 SoftIRQ cycles can follow, which takes about 2 ms (you can find out more about this by reading about </font></font><code>__do_softirq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). If the SoftIRQ vector, after the maximum number of cycles has passed, or the time has passed, still has unsolved problems, then the solution of these problems is delayed for execution in the thread</font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">specific CPU. </font><font style="vertical-align: inherit;">When this happens, the system turns out to be a little more transparent in the sense of obtaining information about the processor load created by network operations (although such an analysis is performed on the assumption that it is SoftIRQ that is studied, which are related to packet processing, and not to something else) . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One way to obtain the above indicators is to use </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">sudo perf record -a \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:irq_handler_entry,irq:irq_handler_exit<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:softirq_entry --filter="vec == 3" \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:softirq_exit --filter="vec == 3"&nbsp; \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e napi:napi_poll \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- sleep 1<font></font>
<font></font>
sudo perf script<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is the result:</font></font><br>
<br>
<pre><code class="plaintext hljs">swapper &nbsp; &nbsp; 0 [005] 176146.491879: irq:irq_handler_entry: irq=152 name=mlx5_comp2@pci:0000:d8:00.0<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491880:&nbsp; irq:irq_handler_exit: irq=152 ret=handled<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491880: &nbsp; &nbsp; irq:softirq_entry: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491942:&nbsp; &nbsp; &nbsp; &nbsp; napi:napi_poll: napi poll on napi struct 0xffff9d3d53863e88 for device eth0 work 64 budget 64<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491943:&nbsp; &nbsp; &nbsp; irq:softirq_exit: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491943: &nbsp; &nbsp; irq:softirq_entry: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491971:&nbsp; &nbsp; &nbsp; &nbsp; napi:napi_poll: napi poll on napi struct 0xffff9d3d53863e88 for device eth0 work 27 budget 64<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491971:&nbsp; &nbsp; &nbsp; irq:softirq_exit: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.492200: irq:irq_handler_entry: irq=152 name=mlx5_comp2@pci:0000:d8:00.0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, the processor is idle (hence the appearance of entries </font></font><code>swapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for the process), IRQ is called for the Rx queue on CPU 5, SoftIRQ processing is called twice, 64 packets are processed first, then 27. The next IRQ is called after 229 Œºs and starts the cycle again.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This data was obtained on an idle system. But on the processor, any task can be performed. In this case, the above sequence of events occurs, interrupting this task and performing IRQ / SoftIRQ tasks. At the same time, System Accounting ascribes to the interrupted process the load created by the processor. As a result, network packet processing tasks are usually hidden from conventional processor load monitoring tools. They are executed in the context of some randomly selected process, in the context of the ‚Äúvictim process‚Äù. This leads us to some questions. How to estimate the time for which the process is interrupted for the processing of packets? How to compare 2 different network solutions in order to understand which of them has a lesser effect on various tasks solved on a computer?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When using RSS, RPS, RFS mechanisms, packet processing is usually distributed between the processor cores. </font><font style="vertical-align: inherit;">Therefore, the above packet processing sequence is related to each specific CPU. </font><font style="vertical-align: inherit;">As the packet arrival rate increases (I think we can talk about speeds of 100,000 packets per second and higher), each CPU has to process thousands or tens of thousands of packets per second. </font><font style="vertical-align: inherit;">Processing so many packets will inevitably affect other tasks performed on the server. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider one way to evaluate this effect.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disabling Distributed Packet Processing</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To begin, let's stop the distributed processing of packets by disabling RPS and setting up flow control rules aimed at organizing the processing of all packets related to a specific MAC address on the only CPU known to us. </font><font style="vertical-align: inherit;">My system has 2 NICs aggregated in an 802.3ad configuration. </font><font style="vertical-align: inherit;">Network tasks are assigned to a single virtual machine running on a computer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RPS on network adapters is disabled as follows:</font></font><br>
<br>
<pre><code class="plaintext hljs">for d in eth0 eth1; do<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;find /sys/class/net/${d}/queues -name rps_cpus |<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;while read f; do<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 0 | sudo tee ${f}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;done<font></font>
done<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, we set up the flow control rules to ensure that packets get into the test virtual machine using a single CPU:</font></font><br>
<br>
<pre><code class="plaintext hljs">DMAC=12:34:de:ad:ca:fe<font></font>
sudo ethtool -N eth0 flow-type ether dst ${DMAC} action 2<font></font>
sudo ethtool -N eth1 flow-type ether dst ${DMAC} action 2<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Disabling RPS and using flow control rules allows us to ensure that all packets destined for our virtual machine are processed on the same CPU. </font><font style="vertical-align: inherit;">In order to make sure that packets are sent to the queue to which they should be sent, you can use a command like </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ethq</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Then you can find out which CPU this queue belongs to using </font></font><code>/proc/interrupts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In my case, turn 2 is processed by means of CPU 5.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Openssl speed command</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I could use utilities </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font><font style="vertical-align: inherit;">to analyze SoftIRQ runtimes responsible for processing incoming traffic </font></font><code>bpf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but this approach is quite complicated. In addition, the observation process itself definitely affects the results. A much simpler and more understandable solution is to identify the load created by the network operations on the system using some task, one that creates a known load on the system. For example, this is a command </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used to test OpenSSL performance. This will allow you to find out how much processor resources the program gets in reality, and compare it with the amount of resources that it is supposed to receive (this will help to find out how much resources are spent on network tasks).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The team is </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">almost 100% a user space team. If you tie it to a certain CPU, then it, during the execution of tests, uses all its available resources. The team works by setting the timer to the specified interval (here, for example, to make calculations easier, it takes 10 seconds), running the test, and then, when the timer is triggered, using </font></font><code>times</code><code>()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it to find out how much processor time the program actually got. From the point of view </font></font><code>syscall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it looks like this:</font></font><br>
<br>
<pre><code class="plaintext hljs">alarm(10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0<font></font>
times({tms_utime=0, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726601344<font></font>
--- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL} ---<font></font>
rt_sigaction(SIGALRM, ...) = 0<font></font>
rt_sigreturn({mask=[]}) = 2782545353<font></font>
times({tms_utime=1000, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726602344<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, it turns out that </font></font><code>alarm()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">very few system calls were made </font><font style="vertical-align: inherit;">between calling </font><font style="vertical-align: inherit;">and checking the results. If the program was not interrupted, or interrupted very rarely, the time </font></font><code>tms_utime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will coincide with the test time (in this case, 10 seconds). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since this is a test performed exclusively in user space, any system time that appears in </font></font><code>times()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will mean some additional load on the system. It turns out that although </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this is a process that runs on the CPU, the CPU itself may be busy with something else. For example, processing network packets:</font></font><br>
<br>
<pre><code class="plaintext hljs">alarm(10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0<font></font>
times({tms_utime=0, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726617896<font></font>
--- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL} ---<font></font>
rt_sigaction(SIGALRM, ...) = 0<font></font>
rt_sigreturn({mask=[]}) = 4079301579<font></font>
times({tms_utime=178, tms_stime=571, tms_cutime=0, tms_cstime=0}) = 1726618896<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here you can see that it was </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">possible to work on the processor for 7.49 seconds (178 + 571 in units of measurement corresponding to 0.01 s.). </font><font style="vertical-align: inherit;">But at the same time 5.71 s. </font><font style="vertical-align: inherit;">this interval is represented by the system time. </font><font style="vertical-align: inherit;">Since he is </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not busy with any business in the kernel space, this means that 5.71 s. </font><font style="vertical-align: inherit;">- This is the result of some additional load on the system. </font><font style="vertical-align: inherit;">That is, this is the time that the process was "stolen" in order to meet the needs of the system.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using the openssl speed command to detect system load caused by network mechanisms</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now that we‚Äôve figured out how the team works </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we‚Äôll look at the results that it produces on a practically inactive server:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ taskset -c 5 openssl speed -seconds 10 aes-256-cbc &gt;/dev/null<font></font>
Doing aes-256 cbc for 10s on 16 size blocks: 66675623 aes-256 cbc's in 9.99s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 18096647 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 4607752 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 1162429 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 145251 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 72831 aes-256 cbc's in 10.00s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, we are informed that the program spends from 9.99 to 10 seconds to process blocks of different sizes. This confirms that system mechanisms do not take processor time from the program. Now, using </font></font><code>netperf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we will load the server by processing packets coming from two sources. Run the test again:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ taskset -c 5 openssl speed -seconds 10 aes-256-cbc &gt;/dev/null<font></font>
Doing aes-256 cbc for 10s on 16 size blocks: 12061658 aes-256 cbc's in 1.96s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 3457491 aes-256 cbc's in 2.10s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 893939 aes-256 cbc's in 2.01s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 201756 aes-256 cbc's in 1.86s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 25117 aes-256 cbc's in 1.78s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 13859 aes-256 cbc's in 1.89s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The results are very different from those obtained on an idle server. It is expected that each of the tests will be executed within 10 seconds, but </font></font><code>times()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reports that the real execution time is from 1.78 to 2.1 seconds. This means that the remaining time, varying from 7.9 to 8.22 seconds, was spent on processing the packets, either in the context of the process </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or in </font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let‚Äôs take a look at what the team will give out </font></font><code>top</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when analyzing the launch just completed </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="plaintext hljs">PID USER&nbsp; &nbsp; &nbsp; PR&nbsp; NI&nbsp; &nbsp; VIRT&nbsp; &nbsp; RES&nbsp; &nbsp; SHR S&nbsp; %CPU %MEM &nbsp; &nbsp; TIME+ COMMAND&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P&nbsp;<font></font>
&nbsp;8180 libvirt+&nbsp; 20 &nbsp; 0 33.269g 1.649g 1.565g S 279.9&nbsp; 0.9&nbsp; 18:57.81 qemu-system-x86 &nbsp; &nbsp; 75<font></font>
&nbsp;8374 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 99.4&nbsp; 0.0 &nbsp; 2:57.97 vhost-8180&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 89<font></font>
&nbsp;1684 dahern&nbsp; &nbsp; 20 &nbsp; 0 &nbsp; 17112 &nbsp; 4400 &nbsp; 3892 R&nbsp; 73.6&nbsp; 0.0 &nbsp; 0:09.91 openssl&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;38 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 26.2&nbsp; 0.0 &nbsp; 0:31.86 ksoftirqd/5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here you might think that it </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uses approximately 73% of the resources of CPU 5, and the </font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remaining resources are obtained. </font><font style="vertical-align: inherit;">But in reality, in the context </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, processing of such a large number of packages is performed that the program itself takes only 18-21% of the processor time to solve its problems. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you reduce the network load to 1 stream, you </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get the </font><font style="vertical-align: inherit;">feeling that </font><font style="vertical-align: inherit;">99% of system resources are being consumed.</font></font><br>
<br>
<pre><code class="plaintext hljs">&nbsp;&nbsp;PID USER&nbsp; &nbsp; &nbsp; PR&nbsp; NI&nbsp; &nbsp; VIRT&nbsp; &nbsp; RES&nbsp; &nbsp; SHR S&nbsp; %CPU %MEM &nbsp; &nbsp; TIME+ COMMAND&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P<font></font>
&nbsp;8180 libvirt+&nbsp; 20 &nbsp; 0 33.269g 1.722g 1.637g S 325.1&nbsp; 0.9 166:38.12 qemu-system-x86 &nbsp; &nbsp; 29<font></font>
44218 dahern&nbsp; &nbsp; 20 &nbsp; 0 &nbsp; 17112 &nbsp; 4488 &nbsp; 3996 R&nbsp; 99.2&nbsp; 0.0 &nbsp; 0:28.55 openssl&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
&nbsp;8374 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 64.7&nbsp; 0.0&nbsp; 60:40.50 vhost-8180&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 55<font></font>
&nbsp;&nbsp;&nbsp;38 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 S &nbsp; 1.0&nbsp; 0.0 &nbsp; 4:51.98 ksoftirqd/5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But in reality it turns out that the program running in the user space gets, out of the expected 10 seconds, only about 4 seconds:</font></font><br>
<br>
<pre><code class="plaintext hljs">Doing aes-256 cbc for 10s on 16 size blocks: 26596388 aes-256 cbc's in 4.01s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 7137481 aes-256 cbc's in 4.14s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 1844565 aes-256 cbc's in 4.31s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 472687 aes-256 cbc's in 4.28s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 59001 aes-256 cbc's in 4.46s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 28569 aes-256 cbc's in 4.16s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conventional process monitoring tools indicate that the program uses almost all the processor resources, but in reality it turns out that 55-80% of the CPU resources are spent on processing network packets. </font><font style="vertical-align: inherit;">The throughput of the system at the same time looks great (more than 22 Gb / s per 25 Gb / s line), but this has a tremendous impact on the processes running in this system.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summary</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we examined an example of how packet processing mechanisms ‚Äústeal‚Äù processor clocks from a simple and not very important benchmark. </font><font style="vertical-align: inherit;">But on a real server, processes that are affected similarly can be anything. </font><font style="vertical-align: inherit;">These can be virtual processors, emulator threads, vhost threads of virtual machines. </font><font style="vertical-align: inherit;">These can be different system processes, the impact on which can have a different impact on the performance of these processes and the entire system. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do you consider, analyzing your servers, the impact on their actual performance of the load associated with network operations?</font></font></b><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/webt/a_/bs/aa/a_bsaactpbr8fltzymtkhqbw1d4.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en503624/index.html">The digest of fresh materials from the world of the front-end for the last week No. 416 (May 18-24, 2020)</a></li>
<li><a href="../en503626/index.html">Testing. ISTQB certification errors or solve a million examples</a></li>
<li><a href="../en503630/index.html">Augmented reality glasses: where are we now?</a></li>
<li><a href="../en503632/index.html">1000 and 1 post: happy birthday, Habr ‚ù§</a></li>
<li><a href="../en503634/index.html">5 interesting JavaScript finds made in Vue source code</a></li>
<li><a href="../en503638/index.html">6 useful habits that, surprisingly, only a few programmers have</a></li>
<li><a href="../en503642/index.html">How to get on LinkedIn, Facebook, Google in Silicon Valley</a></li>
<li><a href="../en503648/index.html">What does the output of "ss -s" mean</a></li>
<li><a href="../en503650/index.html">VKCup 2020 Stage I. A Long Way</a></li>
<li><a href="../en503652/index.html">Digital events in Moscow from May 25 to May 31</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>