<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔦 🏮 🚴 关于掩码寄存器 🎣 👨🏽‍⚖️ 👨🏽‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="AVX-512指令集包括八个所谓的掩码寄存器[1]-从k0 [2]到k7。它们适合与大多数ALU操作一起使用，并允许您对矢量元素执行掩码操作，以对目标寄存器中的数据进行归零或合并[3]，从而加快了代码的执行速度，这将需要在AVX2指令集和早期版本中进行其他合并操作。
 
 如果以上内容不足以使您成为...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>关于掩码寄存器</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/488670/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX-512指令集包括八个所谓的掩码寄存器[1]-从</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [2]到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k7</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它们适合与大多数ALU操作一起使用，并允许您对矢量元素执行掩码操作，以对目标寄存器中的数据进行归零或合并[3]，从而加快了代码的执行速度，这将需要在AVX2指令集和早期版本中进行其他合并操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果以上内容不足以使您成为掩码寄存器狂热者的追随者，我将引用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">维基百科的文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘录</font><font style="vertical-align: inherit;">，希望</font><font style="vertical-align: inherit;">该</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">文章</font></a><font style="vertical-align: inherit;">最终可以帮助您解决：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大多数AVX-512命令可以使用与8个掩码寄存器（k0 – k7）之一相对应的操作数掩码。如果将掩码寄存器用作操作掩码，则k0寄存器的行为与其余掩码寄存器不同：在这种情况下，它充当硬编码常量，指示此操作未应用掩码。但是，在算术和逻辑运算中以及将值写入掩码寄存器时，k0的行为类似于正常的工作寄存器。在大多数命令中，掩码寄存器用作确定应该将哪些项目写入输出寄存器的掩码。操作数掩码的行为取决于标志：如果设置了该标志，则所有未选择的元素都将被重置（“归零”模式，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">零</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），如果没有，则所有未选择的元素都保持其先前状态（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合并</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式，</font><i><font style="vertical-align: inherit;">merge</font></i><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">合并模式与</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">混合指令</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有相同的效果</font><font style="vertical-align: inherit;">。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，掩码寄存器[4]是一项重要的创新，但是与通用寄存器（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eax</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rsi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等）或SIMD寄存器（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xmm0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ymm5</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等）</font><font style="vertical-align: inherit;">相比，它们很少被记住</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在英特尔演示文稿中显示了微体系结构资源的大小，未提及掩码寄存器：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xa/ty/eq/xatyeq9cozm0-7xfqmlxg4caffo.png" alt="图片"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
据我所知，关于</font><font style="vertical-align: inherit;">掩码寄存器</font><font style="vertical-align: inherit;">的物理寄存器文件（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物理寄存器文件，PRF</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">的大小的信息</font><font style="vertical-align: inherit;">也从未发布过。现在我们将修复它。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工具</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的修改版</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">来测量</font></a><font style="vertical-align: inherit;">命令重排序缓冲区（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ROB</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">的</font></a><font style="vertical-align: inherit;">大小，</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">该</font></a><font style="vertical-align: inherit;">大小</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由Henry Wong</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [5]（以下简称为Henry）</font><font style="vertical-align: inherit;">创建和</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">描述</font></a><font style="vertical-align: inherit;">。他使用此工具计算了</font><font style="vertical-align: inherit;">先前体系</font><font style="vertical-align: inherit;">结构</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中非常规执行</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的已记录和未记录结构的大小</font><font style="vertical-align: inherit;">。如果您还没有阅读亨利的笔记，请停下来再返回。我的文章将等待。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，读？出于危害，这是亨利（Henry）文章的摘要：</font></font><br>
<br>
<h2>     ROB</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
许多</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">镇流器指令</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">被</font><font style="vertical-align: inherit;">插入到两个读取指令之间，并发生高速缓存未命中[6] </font><font style="vertical-align: inherit;">-它们的确切数量将取决于我们要测量的处理器资源。如果没有太多镇流器命令，则将并行处理两个缓存未命中，因此它们的延迟将重叠，总执行时间将约为一个缓存未命中所需的[7]倍。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如果镇流器命令的数量超过某个临界阈值，则相应的资源将被完全耗尽，并且在发出具有缓存未命中的第二条命令之前，将停止在ROB中放置团队。在这种情况下，它们的并行处理将是不可能的，并且总时间将几乎是一次此类操作的时间的两倍，这将在图表中反映为急剧跳跃。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，编写测试，以便团队仅使用要测试的资源的一个单位-在这种情况下，图上的峰峰值将指示其总体积。</font><font style="vertical-align: inherit;">因此，通常，标准通用命令使用通用PRF寄存器中的一个物理寄存器，因此非常适合测量给定资源的数量。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">掩码寄存器的物理寄存器文件的大小</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此测试中，我们将执行将值写入掩码寄存器的命令，以找出这些寄存器的PRF大小。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从一系列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd k1，k2，k3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">团队开始（显示16个镇流器团队）：</font></font><br>
<br>
<pre><code class="cpp hljs">mov    rcx,QWORD PTR [rcx]  ;    -<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
kaddd  k1,k2,k3<font></font>
mov    rdx,QWORD PTR [rdx]  ;    -<font></font>
lfence                      ;      ,    <font></font>
                            ;   <font></font>
;     <span class="hljs-number">16</span> </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">消耗一个物理掩码寄存器。如果镇流器命令的数量小于或等于掩码寄存器的数量，则将在并行模式下处理高速缓存未中，否则在顺序模式下进行。因此，当从并行模式切换到串行模式时，我们应该在图形上看到一个急剧的跳跃，这表明执行时间增加了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这正是我们正在观察的结果：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gu/0u/0s/gu0u0s6phxsglrya170shjhls30.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们仔细看一下上升情况：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ix/ve/yl/ixveylwsz7jjcbdwnoxcfqynjbu.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正如我们现在所看到的，跳跃</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并不那么剧烈</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：随着镇流器命令的数量从130增加到134，执行速度在最小和最大级别之间取中间值。亨利称这种行为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不完美</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">;我在许多测试中都观察到了它，尽管不是全部。事实是，硬件的实现并不能总是在资源接近极限时完全耗尽它[8]-在某些情况下可以成功，而在另一些情况下只有很少的团队达到理论上的最大值。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这方面，我们对倒数第二个上升点感兴趣，在该倒数第二个上升点，速度仍然高于慢速模式。这一点表明我们可用的资源单元数，这意味着至少有尽可能多的物理寄存器。如您所见，在这种情况下约为134. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，SKX </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有134个物理寄存器，能够存储掩码寄存器的推测性（通过预期执行获得）值</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">亨利（Henry）建议再使用8个来存储八个掩码寄存器的当前体系结构状态，因此它们的PRF总量可以估计为142。这比通用寄存器（180）和SIMD寄存器（168）的文件大小略小，但仍然很多（请参见</font><font style="vertical-align: inherit;">其他平台</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的非常规执行资源的大小表</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设此文件足够大，以至于在实践中我们没有时间完全占用它：很难想象真实的代码中几乎60％的命令[9]会写[10]来屏蔽寄存器-即，因此将需要许多资源来耗尽此资源。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些注册表文件是否不同？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您必须已经注意到，到目前为止，我</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下假设</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">掩码寄存器PRF是一个单独的文件，不会与其他类型的寄存器文件相交。基于掩码寄存器的工作原理以及它们是寄存器重命名的单独域的一部分，我相信这很有可能[11]。支持我的假设的另一个论据是，观察到的PRF掩码寄存器的大小与通用寄存器文件或SIMD寄存器文件的大小不匹配。实际上，我们可以通过测试来进行测试！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此测试与之前的测试类似，但现在为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd命令</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将与使用通用寄存器或SIMD寄存器的命令交替显示。如果将掩码寄存器与同一寄存器文件中的第一个或第二个寄存器组合在一起，则图中的跳转应指示相应的PRF的大小。如果未合并寄存器文件，我们将遇到其他限制，该限制将不等于两个寄存器文件中的任何一个的大小，但将等于例如ROB的大小。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试29中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd命令</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和标量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">交替出现</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">mov    rcx,QWORD PTR [rcx]<font></font>
add    ebx,ebx<font></font>
kaddd  k1,k2,k3<font></font>
add    esi,esi<font></font>
kaddd  k1,k2,k3<font></font>
add    ebx,ebx<font></font>
kaddd  k1,k2,k3<font></font>
add    esi,esi<font></font>
kaddd  k1,k2,k3<font></font>
add    ebx,ebx<font></font>
kaddd  k1,k2,k3<font></font>
add    esi,esi<font></font>
kaddd  k1,k2,k3<font></font>
add    ebx,ebx<font></font>
kaddd  k1,k2,k3<font></font>
mov    rdx,QWORD PTR [rdx]<font></font>
lfence</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们看一下图表：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vh/ew/hc/vhewhcthcquksk66f8wircsk6n4.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，占峰值的镇流器数量大于PRF通用寄存器和掩码寄存器的大小。</font><font style="vertical-align: inherit;">由此得出的结论是，掩码寄存器不包含在通用寄存器文件中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那么也许它们包含在SIMD寄存器文件中？</font><font style="vertical-align: inherit;">毕竟，与通用命令相比，掩码寄存器与SIMD命令的关联更大。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要了解，我们将使用测试35，这与这里的差相同试验29 </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd命令</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交替与</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vxorps</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">mov    rcx,QWORD PTR [rcx]<font></font>
vxorps ymm0,ymm0,ymm1<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm2,ymm2,ymm3<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm4,ymm4,ymm5<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm6,ymm6,ymm7<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm0,ymm0,ymm1<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm2,ymm2,ymm3<font></font>
kaddd  k1,k2,k3<font></font>
vxorps ymm4,ymm4,ymm5<font></font>
kaddd  k1,k2,k3<font></font>
mov    rdx,QWORD PTR [rdx]<font></font>
lfence</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
图：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/66/r4/zj/66r4zjzixtvauqfascucqdqk5tq.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此测试中，观察到的行为与上一个行为相同，因此我们得出结论，掩码寄存器和SIMD寄存器的寄存器文件也分开了。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未解之谜</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，在这两个测试中，峰值的末尾都落在大约212个命令上，而该微体系结构的ROB大小为224。也许这只是</font><font style="vertical-align: inherit;">我们之前已经观察到</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不完美行为</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？好吧，让我们检查一下：将这两个测试的结果与测试4的结果进行比较，在测试4中，只有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nop</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令用作镇流器命令</font><font style="vertical-align: inherit;">：除了ROB之外，它们不应消耗任何其他资源。比较测试4（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nop</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和测试29（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和标量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加法</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交替</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">的图形</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ch/1y/re/ch1yream9tyqh6opy8t2343ai0q.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试4中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">慢速模式的开始恰好落在224标志（矢量图像，因此您可以增加它们并自己查看）。结果是212（从这一点开始，慢速模式在将掩码寄存器与通用寄存器或SIMD寄存器交替使用时开始）–这是某些其他资源的限制。实际上，即使交替使用通用寄存器和SIMD寄存器，我们也遇到相同的限制-比较测试4和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试21</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（它结合了通用寄存器和SIMD </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vxorps命令的添加</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fg/ha/2r/fgha2rlaljpa5z1qrazmq3eb8am.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在您的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文章中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，标题相同（“未解之谜”）的亨利描述了相同的效果，但更为明显：</font></font><br>
<blockquote>  ,     AVS  SSE  Sandy Bridge      147 ,       ROB.    (,     ,   AVX-   ,  NOP-),    ,    SSE/AVX,     ,   -   ,        147,        –  ,       .</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关详细信息，请参考Henry的文章。</font><font style="vertical-align: inherit;">我们观察到了类似的效果，但效果并不明显：我们至少设法占据了ROB体积的95％，但我们仍然没有完全耗尽它。</font><font style="vertical-align: inherit;">也许那个神秘的通用寄存器池与它们的释放机制相关联，例如PRRT表[12]，该表跟踪命令完成后可用于释放的寄存器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，让我们讨论屏蔽寄存器的更多功能，并检查通用寄存器和SIMD寄存器可用的优化机制是否适用于它们。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复制副本</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于通用或SIMD命令，可以应用所谓的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消除移动</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。通过这种优化，寄存器重命名机制不允许执行将值从一个寄存器复制到另一个寄存器的命令，例如</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mov eax</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">edx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vmovdqu ymm1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ymm2-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而是</font><font style="vertical-align: inherit;">将</font><i><font style="vertical-align: inherit;">目标</font></i><font style="vertical-align: inherit;">寄存器“简单地” [13]重新分配给RAT中的源寄存器，这使您无需参与ALU就可以做到。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
检查副本替换是否适用于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kmov k1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">。首先，看一下</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试28</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的图形</font><font style="vertical-align: inherit;">，其中</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kmovd k1是</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">镇流器组</font><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<img src="https://habrastorage.org/webt/wc/s3/jc/wcs3jcnzmjp4pffpopov47ybtg4.png" alt="图片"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该图看起来与之前使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kaddd</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令讨论的测试27 </font><i><font style="vertical-align: inherit;">完全相同</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，可以合理地假设填充的是物理寄存器，除非我们在替换副本时不小心耗尽了一些其他资源，它们的行为相同且大小相同[14]。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们在uops.info网站上找到了更多确认信息：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它说</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">掩码寄存器之间</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kmov</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> copy </font><i><font style="vertical-align: inherit;">命令的</font></i><font style="vertical-align: inherit;">所有变体都</font><font style="vertical-align: inherit;">占用一个在端口</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上执行的微操作</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果有替换副本，我们将不会在端口上观察到活动。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由此得出的结论是，不替换使用掩码寄存器[15]的复制命令。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成瘾成语</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使x86体系结构中的通用寄存器无效的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">最佳方法</font></a><font style="vertical-align: inherit;">是使用异或逻辑（xor）：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xor reg</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reg</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">其作用基于以下事实：使用此操作将任何值与其自身进行比较都会得出零。</font><font style="vertical-align: inherit;">该命令比更明显的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mov eax</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">短（占用更少的字节）</font><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和更快，因为处理器知道这是一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重置习惯，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并执行了必要的寄存器重命名[16]，从而消除了对ALU和端口加载的需求。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而且，这种惯用法消除了数据依赖性：通常是命令</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xor reg1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reg2的结果</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取决于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reg1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reg2寄存器中</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的值</font><font style="vertical-align: inherit;">，但是在特殊情况下reg1和reg2包含相同的值时，就没有依赖性，因为对于任何输入值，输出将为零。所有现代x86处理器都认可这种[17]特例。这同样适用于异或成语的那些版本的事实，使用SIMD寄存器，即</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vpxor</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作</font><font style="vertical-align: inherit;">上整数和</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vxorps</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vxorpd操作</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上实数。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，好奇的读者可能会问：是否有类似这个成语的工作</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor命令</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？例如，将</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxorb k1，k1，k1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [18] </font><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">视为重设习惯吗？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，这是两个不同的问题，因为使用重置习语的效果由两个部分组成：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">零延迟执行绕过执行模块（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行消除</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消除依赖</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将分别处理每个问题。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更换执行</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，可以将具有xor的命令（例如</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxorb k1，k1，k1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）替换为重新分配的寄存器而不放置在执行模块中吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没有。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我什至无需自己做任何事情来证明这一点：所有信息都在uops.info网站上，因为他们进行了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样的测试，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并表明该命令的执行延迟了1个时钟周期，并且对端口</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行了一次微操作</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">随之而来的是，掩码寄存器的“异或”重置惯用语不起作用。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消除依赖</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如果使用kxor的重置习惯用法仍然消除了数据依赖性，即使它们需要放置在执行模块中怎么办？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此处uops.info将无济于事。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">具有1个时钟周期的延迟，并且在单个端口（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）上执行，因此存在一种有趣的情况（？），其中</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><i><font style="vertical-align: inherit;">链</font></i><font style="vertical-align: inherit;">以相同的速度执行，而不管它们之间是否存在依赖关系：带宽能力1命令/周期的性能下降与延迟1命令/周期的下降相同！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没什么，我们还有一些技巧。以下测试将帮助我们回答这个问题。嵌入</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在命令链中，每个后续命令都取决于前一个命令，并且该链的总执行时间应足够大以形成瓶颈。如果</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">没有消除依赖性，则链的总执行时间将等于其组成命令的延迟之和。如果依赖性消失，则链会分解成较短的序列，其延迟重叠，然后它们的执行速度将受到吞吐量的某个极限值的限制（例如，与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">端口竞争</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相关</font><font style="vertical-align: inherit;">）。使用该方案可以清楚地表明这一点，但是我对此并不坚强。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有这些测试可以在基准中找到</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uarch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">板凳</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但我将在下面给出重点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，从通用寄存器测量标准复制时间，反之亦然：</font></font><br>
<br>
<pre><code class="cpp hljs">kmovb k0, eax<font></font>
kmovb eax, k0<font></font>
;   <span class="hljs-number">127</span> </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些命令中的一对以4种方式执行[19]。尚不确切知道每个时间花了多少时间：2个小节或一个小节，另外3个小节[20]？但是，对于我们的任务来说这无关紧要，因为我们对来回复制的总时间感兴趣。值得注意的是，此序列的带宽为1个时钟周期，比延迟快4倍，因为每个命令都在其自己的端口（</font><font style="vertical-align: inherit;">分别为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p5</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）上执行。这意味着我们可以将延迟的影响与带宽的影响分开。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，在我们的链中，包括</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">，可以确保不会导致大小写重置：</font></font><br>
<br>
<pre><code class="cpp hljs">kmovb k0, eax<font></font>
kxorb k0, k0, k1<font></font>
kmovb eax, k0<font></font>
;   <span class="hljs-number">127</span> </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们知道</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxorb</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有1个时钟周期的延迟，总的执行时间应增加至5个循环-这就是测试显示了（前两个测试的结果被示出）：</font></font><br>
<br>
<pre><code class="cpp hljs">**   avx512 :  AVX512 **<font></font>
                                       <font></font>
mov  GP  kreg                    <span class="hljs-number">4.00</span>         <span class="hljs-number">1.25</span><font></font>
mov  GP  kreg   + <font></font>
kxorb                              <span class="hljs-number">5.00</span>         <span class="hljs-number">1.57</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，主要测试：</font></font><br>
<pre><code class="cpp hljs">kmovb k0, eax<font></font>
kxorb k0, k0, k0<font></font>
kmovb eax, k0<font></font>
;   <span class="hljs-number">127</span> </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这次我们使用</font><font style="vertical-align: inherit;">带有大小写重置</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxorb</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxorb k0，k0，k0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果对寄存器k0中值的依赖性消失，则意味着</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kmovb eax，k0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">不再取决于先前的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kmovb k0，eax</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">，并且链已断开，总执行时间应减少。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
鼓声... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们得到了所有相同的5.0小节-与前面的示例相同：</font></font><br>
<br>
<pre><code class="cpp hljs">**   avx512 :  AVX512 **<font></font>
                                     <font></font>
mov  GP  kreg                   <span class="hljs-number">4.00</span>         <span class="hljs-number">1.25</span><font></font>
mov  GP  kreg   + <font></font>
kxorb                             <span class="hljs-number">5.00</span>         <span class="hljs-number">1.57</span><font></font>
mov  GP  kreg   + <font></font>
kxorb                             <span class="hljs-number">5.00</span>         <span class="hljs-number">1.57</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初步结论是：如果将复位惯用语应用于屏蔽寄存器，则处理器不会识别它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总之，我们将进行另一次测试，以确保我们的推理是正确的：我们更换</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kxor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用命令</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KMOV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">，正如你知道的，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总是</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除依赖关系：</font></font><br>
<br>
<pre><code class="cpp hljs">kmovb k0, eax<font></font>
kmovb k0, ecx<font></font>
kmovb eax, k0<font></font>
;   <span class="hljs-number">127</span> </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最终答案如下。</font><font style="vertical-align: inherit;">上一次测试要快得多-仅2个时钟周期，而瓶颈是端口</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p5</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kmov k，r32命令</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都仅在此端口上执行）：</font></font><br>
<br>
<pre><code class="cpp hljs">**   avx512 :  AVX512 **<font></font>
                                       <font></font>
mov  GP  kreg                   <span class="hljs-number">4.00</span>            <span class="hljs-number">1.25</span><font></font>
mov  GP  kreg   + <font></font>
kxorb                             <span class="hljs-number">5.00</span>            <span class="hljs-number">1.57</span><font></font>
mov  GP  kreg   + <font></font>
kxorb                             <span class="hljs-number">5.00</span>            <span class="hljs-number">1.57</span><font></font>
mov  GP  kreg   + <font></font>
mov  GP                                  <span class="hljs-number">2.00</span>            <span class="hljs-number">0.63</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事实证明，我们的假设是正确的。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">播放结果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过</font><font style="vertical-align: inherit;">在Linux或Windows（在WSL下）</font><font style="vertical-align: inherit;">运行</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">robsize</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可执行文件</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">您可以自己重现本文介绍的所有结果</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它们</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也可以在资源库中找到</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以及</font><font style="vertical-align: inherit;">用于收集和绘制它们的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">脚本</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发现</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SKX体系结构掩码寄存器位于单独的物理寄存器文件中。</font><font style="vertical-align: inherit;">其中134个用于存储推测值，掩码寄存器的总数为142</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此数字可与其他类型的寄存器文件以及ROB缓冲区的大小相比，并且足够大，不会在使用掩码寄存器时出现性能下降</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有掩码寄存器的复制命令不会被替换</font></font></li>
<li>  [21]               </li>
</ul><br>
<ol>
<li>   <i>k-</i>   <i>kregs</i> –  -. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a>,  <i>k</i>     –           «» (<i>m</i>)   «» (<i>f</i>). </li>
<li>   (             AVX-512  ),  <i>k0</i> –     ,      , ,    .    : <i>k0</i> –   ,     ,     ,     <i>k</i>,   SIMD-,     (,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>   AVX-512).    SIMD-  <i>k0</i>    ,                . </li>
<li>        ,        -,        0,  ,          .  , ,    ,  ,  -   -      . </li>
<li>       « »,     <i>kreg</i> –        (  <i>k0</i>, <i>k1</i>  ..), –    «kreg»  « » ( ). </li>
<li>H. Wong, <i>Measuring Reorder Buffer Capacity</i>, May, 2013. [Online]. (. , «    »,  2013. -.) : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">blog.stuffedcow.net/2013/05/measuring-rob-capacity</a></li>
<li>        100  300 .     ,              -    2     50  100 ,     –   2,5 (,  2   5 ).     TLB-/               .</li>
<li> «»     .   ,       ,  .            . ,   29       104,    ,    –  ,     200.      ,   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a>)    –   ,   -           (         ),        . </li>
<li> , , ,                 (<i>register alias table, RAT</i>),      .  RAT  ,     ,        ,        ,       .     RAT      ,                ,    . </li>
<li> 60%   134  224, ..    PRF     ROB.   ,      ROB   224  ,        ,   ,      [10]   60% ,   ROB. ,       -  ,   60%   ,       ROB,    <i></i>.</li>
<li> ,        ,    . ,      (, SIMD-   ),     . [2]</li>
<li>    ,          .  ,   2      2  SIMD- (    ),  4   . </li>
<li>    <i>Physical Register Reclaim Table</i> (   )  <i>Post Retirement Reclaim Table</i> (     ).</li>
<li>        –   ,    «  », ..   ,        ,        .        ,    .     :       ,       . </li>
<li> ,        ( 7)   ,      PRF         ROB. </li>
<li> ,           ,     ,     .  ,             ( ,  ,      ,       –      ). </li>
<li>        RAT  ,           RAT  , ,     . </li>
<li>      <i>xor</i>,              ,  <i>sub reg,reg</i>   <i>sbb reg, reg</i>.     ,      <i>reg</i>  0  -1 (  )     .    ,     <i>reg</i>, –     ,            .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>           . </li>
<li> ,      :   <i>kxorb k1, k1, k1</i>   ,        <i>kxorb k1, k2, k2</i>. </li>
<li> ,    ,      <br>
<br>
<pre><code class="cpp hljs">./uarch-bench.sh --test-name=avx512<span class="hljs-comment">/*. </span></code></pre><br>
</li>
<li>  uops.info   <i>kmov r32, k,</i>   <i>kmov k, 32</i>    <i>&lt;= 3</i>.  ,       4 .          1 , ,         3 . </li>
<li>,      xor,      , , -, ,         .  ,    :     ,            . </li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN488660/index.html">现在该忘记React并升级到Svelte吗？</a></li>
<li><a href="../zh-CN488662/index.html">每个Web开发人员都需要的浏览器扩展</a></li>
<li><a href="../zh-CN488664/index.html">寻找完美的工具包：分析流行的Python项目模板</a></li>
<li><a href="../zh-CN488666/index.html">适用于所有场合的10种React组件</a></li>
<li><a href="../zh-CN488668/index.html">CI / CD链和Docker自动化</a></li>
<li><a href="../zh-CN488672/index.html">通过UART调试ARM Cortex-M微控制器</a></li>
<li><a href="../zh-CN488674/index.html">图表与Excel和PowerPoint</a></li>
<li><a href="../zh-CN488678/index.html">Node.js对小缓冲区的需求很大</a></li>
<li><a href="../zh-CN488682/index.html">如何测试Python编程技能？Yandex的任务</a></li>
<li><a href="../zh-CN488686/index.html">使用Flowmon网络来监视分布式应用程序和数据库的性能</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>