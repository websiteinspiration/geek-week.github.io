<!doctype html>
<html class="no-js" lang="ar">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏿 🔑 🏴󠁧󠁢󠁷󠁬󠁳󠁿 قليلا عن الترحيل في نواة لينكس 📹 🔡 💓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="سنقوم بحل مشكلة بسيطة - حدد كتلة ذاكرة في مساحة نواة لينكس ، ووضع بعض التعليمات البرمجية الثنائية فيها وتنفيذها. للقيام بذلك ، نكتب وحدة kernel ، حيث ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>قليلا عن الترحيل في نواة لينكس</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504442/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سنقوم بحل مشكلة بسيطة - حدد كتلة ذاكرة في مساحة نواة لينكس ، ووضع بعض التعليمات البرمجية الثنائية فيها وتنفيذها. </font><font style="vertical-align: inherit;">للقيام بذلك ، نكتب وحدة kernel ، حيث نحدد الوظيفة foo ، والتي ستلعب دور الشفرة الثنائية التي نحتاجها ، ثم باستخدام وظيفة module_alloc ، حدد كتلة الذاكرة ، انسخ هذه الوظيفة بأكملها إليها من خلال memcpy ونمنحها التحكم. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
إليك ما يبدو عليه:</font></font><br>
<a name="habracut"></a><br>
<pre><code class="plaintext hljs">static noinline int foo(int ret)<font></font>
{<font></font>
	return (ret + 2);<font></font>
}<font></font>
<font></font>
static int exe_init(void)<font></font>
{<font></font>
	int ret = 0;<font></font>
	int (*new_foo)(int);<font></font>
<font></font>
	ret = foo(0);<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
<font></font>
	new_foo = module_alloc(PAGE_SIZE);<font></font>
	set_memory_x((unsigned long)new_foo, 1);<font></font>
<font></font>
	printk(KERN_INFO "foo=%lx new_foo=%lx\n",<font></font>
		(unsigned long)foo, (unsigned long)new_foo);<font></font>
<font></font>
	memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
<font></font>
	ret = new_foo(1);<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
<font></font>
	vfree(new_foo);<font></font>
	return 0;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يتم استدعاء الدالة exe_init عند تحميل الوحدة. </font><font style="vertical-align: inherit;">ننظر إلى نتيجة العمل في سجل النواة:</font></font><br>
<br>
<pre><code class="plaintext hljs">[ 6972.522422] ret=2<font></font>
[ 6972.522443] foo=ffffffffc0000000 new_foo=ffffffffc0007000<font></font>
[ 6972.522457] ret=3<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
كل شيء يعمل بشكل صحيح. </font><font style="vertical-align: inherit;">والآن نضيف دالة printk إلى foo لعرض الوسيطة:</font></font><br>
<br>
<pre><code class="plaintext hljs">static noinline int foo(int ret)<font></font>
{<font></font>
	printk(KERN_INFO "ret=%d\n", ret);<font></font>
	return (ret + 2);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
وتفريغ 25 بايت من محتويات الدالة new_foo () قبل تمرير التحكم إليها:</font></font><br>
<br>
<pre><code class="plaintext hljs">	memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
	dump((unsigned long)new_foo);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يعرف التفريغ على أنه</font></font><br>
<br>
<pre><code class="plaintext hljs">static inline void dump(unsigned long x)<font></font>
{<font></font>
	int i;<font></font>
	for (i = 0; i &lt; 25; i++) \<font></font>
		pr_cont("%.2x ", *((unsigned char *)(x) + i) &amp; 0xFF); \<font></font>
	pr_cont("\n");<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
نحمل الوحدة ونحصل على عطل بالرسالة التالية في السجل:</font></font><br>
<br>
<pre><code class="plaintext hljs">[ 8482.806092] ret=0<font></font>
[ 8482.806092] ret=2<font></font>
[ 8482.806111] foo=ffffffffc0000000 new_foo=ffffffffc0007000<font></font>
[ 8482.806113] 53 89 fe 89 fb 48 c7 c7 24 10 00 c0 e8 e8 3d 0b c1 8d 43 02 5b c3 66 2e 0f <font></font>
[ 8482.806135] invalid opcode: 0000 [#1] SMP NOPTI<font></font>
[ 8482.806639] CPU: 0 PID: 5081 Comm: insmod Tainted: G           O      5.4.27 #12<font></font>
[ 8482.807669] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006<font></font>
[ 8482.808560] RIP: 0010:irq_create_direct_mapping+0x79/0x90<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بطريقة ما ، انتهى بنا الأمر في وظيفة irq_create_direct_mapping ، على الرغم من أنه كان علينا استدعاء printk. </font><font style="vertical-align: inherit;">دعونا نكتشف ما حدث. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
أولاً ، ألق نظرة على قائمة وظيفة foo المفككة. </font><font style="vertical-align: inherit;">احصل عليه باستخدام الأمر objdump -d:</font></font><br>
<br>
<pre><code class="plaintext hljs">Disassembly of section .text:<font></font>
<font></font>
0000000000000000 &lt;foo&gt;:<font></font>
   0:	53                   	push   %rbx<font></font>
   1:	89 fe                	mov    %edi,%esi<font></font>
   3:	89 fb                	mov    %edi,%ebx<font></font>
   5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi<font></font>
   c:	e8 00 00 00 00       	callq  11 &lt;foo+0x11&gt;<font></font>
  11:	8d 43 02             	lea    0x2(%rbx),%eax<font></font>
  14:	5b                   	pop    %rbx<font></font>
  15:	c3                   	retq   <font></font>
  16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)<font></font>
  1d:	00 00 00 <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
توجد وظيفة foo في بداية قسم النص. عند الإزاحة 0xC ، يوجد كود تشغيل الأمر call call e8 - قريب ، لأنه يتم تنفيذه في مقطع الرمز الحالي ، لا تتغير قيمة المحدد. البايتات الأربعة التالية هي الإزاحة بالنسبة للقيمة في سجل RIP التي سيتم نقل عنصر التحكم إليها ، أي RIP = RIP + الإزاحة ، وفقًا لوثائق Intel (دليل مطوري برامج Intel 64 و IA-32 ، مرجع مجموعة التعليمات AZ):</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم تحديد الإزاحة النسبية (rel16 أو rel32) بشكل عام كتسمية في رمز التجميع. </font><font style="vertical-align: inherit;">ولكن على مستوى رمز الجهاز ، يتم ترميزه كقيمة فورية موقعة ، 16 أو 32 بت. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
تتم إضافة هذه القيمة إلى القيمة الموجودة في سجل EIP (RIP). </font><font style="vertical-align: inherit;">في وضع 64 بت ، يكون الإزاحة النسبية دائمًا قيمة فورية 32 بت والتي يتم تسجيلها لتوسيعها إلى 64 بت قبل إضافتها إلى القيمة في سجل RIP لحساب الهدف.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
نحن نعرف عنوان الدالة foo ، وهو 0xffffffffc0000000 ، لذلك في RIP = 0xffffffffc0000000 + 0xc + 0x5 = 0xffffffffc00000011 (0xc هو الإزاحة إلى تعليمات e8 و 1 بايت من التعليمات و 4 بايت من الإزاحة). </font><font style="vertical-align: inherit;">نحن نعرف الإزاحة ، لأن </font><font style="vertical-align: inherit;">وظائف الجسم الملقاة. </font><font style="vertical-align: inherit;">دعنا نحسب المكان الذي سترسل فيه المكالمة لإرسالنا إلى الوظيفة foo:</font></font><br>
<br>
<pre><code class="plaintext hljs">0xffffffffc00000011 + 0xffffffffc10b3de8 = 0xffffffff810b3df9
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هذا هو عنوان وظيفة printk:</font></font><br>
<pre><code class="plaintext hljs"># cat /proc/kallsyms | grep ffffffff810b3df9  <font></font>
ffffffff810b3df9 T printk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
والآن نفس الشيء ينطبق على new_foo ، وعنوانه 0xffffffffc0007000</font></font><br>
<br>
<pre><code class="plaintext hljs">0xffffffffc0007011 + 0xffffffffc10b3de8 = 0xffffffff810badf9
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لا يوجد مثل هذا العنوان في kallsyms ، ولكن هناك 0xffffffff810badf9 - 0x79 = 0xffffffff810bad80</font></font><br>
<pre><code class="plaintext hljs"># cat /proc/kallsyms | grep ffffffff810bad80<font></font>
ffffffff810bad80 T irq_create_direct_mapping<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هذه هي الوظيفة التي حدث فيها الحادث. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لمنع حدوث عطل ، ما عليك سوى إعادة حساب الإزاحة ، مع العلم بعنوان وظيفة new_foo:</font></font><br>
<br>
<pre><code class="plaintext hljs">memcpy((void *)new_foo, (const void *)foo, PAGE_SIZE);<font></font>
unsigned int delta = (unsigned long)printk - (unsigned long)new_foo - 0x11;<font></font>
*(unsigned int *)((void *)new_foo + 0xD) = delta;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بعد هذا التصحيح ، لن يكون هناك أي تعطل ، سيتم تنفيذ وظيفة new_foo والتحكم في الإرجاع بنجاح. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
حلت المشكلة. </font><font style="vertical-align: inherit;">يبقى فقط أن نفهم سبب إدراج الإزاحة في رمز أداة فك الإزاحة بعد رمز تشغيل e8 صفرًا ، ولكن لا توجد وظيفة في التفريغ. </font><font style="vertical-align: inherit;">للقيام بذلك ، ضع في اعتبارك ما هي عمليات الترحيل وكيف تعمل النواة معهم. </font><font style="vertical-align: inherit;">لكن أولاً ، القليل عن تنسيق ELF.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ELF لتقف على تنسيق قابل للتنفيذ وقابل للربط - تنسيق الملفات القابلة للتنفيذ والملح. ملف ELF عبارة عن مجموعة من الأقسام. يقوم القسم بتخزين مجموعة من العناصر اللازمة للرابط لتشكيل صورة قابلة للتنفيذ - التعليمات والبيانات وجداول الرموز وسجلات الانتقال ، وما إلى ذلك. يتم وصف كل قسم بعنوان. يتم جمع جميع الرؤوس في جدول من الرؤوس وهي في الأساس صفيف حيث يحتوي كل عنصر على فهرس. يحتوي رأس القسم على إزاحة إلى بداية القسم ومعلومات عامة أخرى ، مثل الروابط إلى أقسام أخرى عن طريق تحديد فهرس في جدول الرأس.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
عند تجميع حالة الاختبار الخاصة بنا ، لا يعرف المترجم عنوان وظيفة printk ، وبالتالي فإنه يملأ موقع المكالمة بقيمة صفرية ، وباستخدام سجل النقل ، يخبر النواة أنه يجب ملء هذا الموضع بقيمة صالحة. يحتوي سجل النقل على إزاحة للموضع حيث تريد إجراء تغييرات (موضع إعادة التوطين) ، ونوع النقل وفهرس الرمز في جدول الرموز ، ويجب استبدال عنوانه بالإزاحة المحددة. ما هو نوع النقل؟ نعتبر أدناه. يشير عنوان قسم سجلات النقل من خلال الفهارس إلى عناوين القسم مع جدول الأحرف والأقسام ، بالنسبة إلى البداية التي يتم تحديد إزاحة لموضع النقل. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يمكنك الاطلاع على محتويات سجلات النقل باستخدام الأداة objdump مع رمز التبديل -r.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
من القائمة المفككة ، نعلم أنه عند الإزاحة 0xD ، من الضروري كتابة عنوان وظيفة printk ، لذلك نبحث عن إخراج objdump بالموضع التالي:</font></font><br>
<br>
<pre><code class="plaintext hljs">000000000000000d R_X86_64_PC32     printk-0x0000000000000004
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
لذا ، لدينا سجل النقل الضروري الذي يشير إلى الموضع عند الإزاحة 0xD ، واسم الرمز الذي يجب كتابة عنوانه في هذا الموضع. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
القيمة (-4). </font><font style="vertical-align: inherit;">الذي يضاف إلى عنوان وظيفة printk يسمى الملحق ، ويؤخذ في الاعتبار عند حساب النتيجة النهائية للانتقال. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
انظر الآن إلى رمز printk:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ objdump -t exe.ko | grep printk<font></font>
0000000000000000         *UND*	0000000000000000 printk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يوجد رمز ، غير معرف داخل الوحدة (غير محدد) ، لذلك سنبحث عنه في النواة. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
سيكون من المفيد جدًا الاطلاع على سجلات النقل والرموز في شكل ثنائي. </font><font style="vertical-align: inherit;">يمكن القيام بذلك باستخدام wireshark ، ويمكنه تحليل تنسيق ELF. </font><font style="vertical-align: inherit;">هذا هو إدخال النقل الخاص بنا (لصق النسخ من writeshark ، LSB على اليسار):</font></font><br>
<br>
<pre><code class="plaintext hljs">  0d 00 00 00 00 00 00 00  02 00 00 00 22 00 00 00  fc ff ff ff ff ff ff ff<font></font>
  |                     |  |          ||         |  |                     |<font></font>
  +----  -------+  +--  ---++---+  +---- addendum  ------+<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
قارن هذا الإدخال بتعريف البنية المقابلة من &lt;linux / elf.h&gt;:</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct elf64_rela {<font></font>
  Elf64_Addr r_offset;	/* Location at which to apply the action */<font></font>
  Elf64_Xword r_info;	/* index and type of relocation */<font></font>
  Elf64_Sxword r_addend;	/* Constant addend used to compute value */<font></font>
} Elf64_Rela;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هنا لدينا 8 بايت إزاحة 0x00000000d ، نوع 4 بايت 0x00000002 ، فهرس 4 بايت في جدول الأحرف 0x00000022 (أو 34 في العلامة العشرية) وملحق 8 بايت -4. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
وهنا الإدخال من جدول الرموز في رقم 34:</font></font><br>
<br>
<pre><code class="plaintext hljs">  01 01 00 00 10 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
والهيكل ذات الصلة</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct elf64_sym {<font></font>
  Elf64_Word st_name;		/* Symbol name, index in string tbl */<font></font>
  unsigned char	st_info;	/* Type and binding attributes */<font></font>
  unsigned char	st_other;	/* No defined meaning, 0 */<font></font>
  Elf64_Half st_shndx;		/* Associated section index */<font></font>
  Elf64_Addr st_value;		/* Value of the symbol */<font></font>
  Elf64_Xword st_size;		/* Associated symbol size */<font></font>
} Elf64_Sym;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
أول 4 بايت 0x00000101 هو الفهرس في جدول السلاسل. strtab لاسم هذا الحرف ، أي برينتك. يحدد حقل st_info نوع الرمز ، ويمكن أن يكون دالة ، أو كائن بيانات ، وما إلى ذلك ، راجع مواصفات ELF لمزيد من التفاصيل. سوف نتخطى الحقل st_other ، الآن لا يهمنا ، ونلقي نظرة على الحقول الثلاثة الأخيرة st_shndx و st_value و st_size. st_shndx - فهرس رأس القسم الذي يتم تعريف الحرف فيه. نرى هنا قيمة صفرية ، لأن لم يتم تعريف الرمز داخل الوحدة النمطية ؛ فهو ليس في الأقسام المتاحة. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
وبناء على ذلك ، فإن قيمة st_value وحجم st_size هي أيضًا صفر. ستملأ النواة هذه الحقول عند تحميل الوحدة. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
للمقارنة ، انظر إلى الرمز foo ، الموجود بوضوح:</font></font><br>
<br>
<pre><code class="plaintext hljs">  08 00 00 00 02 00 02 00  00 00 00 00 00 00 00 00  16 00 00 00 00 00 00 00
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يحدد الرمز دالة موجودة في قسم .text في العنوان المتعلق ببداية قسم 0x00000000 ، أي </font><font style="vertical-align: inherit;">في بداية القسم ، كما رأينا في القائمة المفككة ، حجم الوظيفة هو 22 بايت. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
سيعرض لنا Objdump نفس المعلومات حول هذا:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ objdump -t exe.ko | grep foo<font></font>
0000000000000000 l     F .text	0000000000000016 foo<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
عندما يقوم kernel بتحميل الوحدة ، فإنه يجد كل الأحرف غير المعرفة ويملأ حقلي st_value و st_size بقيم صالحة. </font><font style="vertical-align: inherit;">يتم ذلك في دالة simpleify_symbols ، ملف kernel / module.c:</font></font><br>
<br>
<pre><code class="plaintext hljs">/* Change all symbols so that st_value encodes the pointer directly. */<font></font>
static int simplify_symbols(struct module *mod, const struct load_info *info)<font></font>
{<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في معلمات الدالة ، يتم تمرير بنية load_info للنموذج التالي</font></font><br>
<br>
<pre><code class="plaintext hljs">struct load_info {<font></font>
	const char *name;<font></font>
	/* pointer to module in temporary copy, freed at end of load_module() */<font></font>
	struct module *mod;<font></font>
	Elf_Ehdr *hdr;<font></font>
	unsigned long len;<font></font>
	Elf_Shdr *sechdrs;<font></font>
	char *secstrings, *strtab;<font></font>
	unsigned long symoffs, stroffs, init_typeoffs, core_typeoffs;<font></font>
	struct _ddebug *debug;<font></font>
	unsigned int num_debug;<font></font>
	bool sig_ok;<font></font>
#ifdef CONFIG_KALLSYMS<font></font>
	unsigned long mod_kallsyms_init_off;<font></font>
#endif<font></font>
	struct {<font></font>
		unsigned int sym, str, mod, vers, info, pcpu;<font></font>
	} index;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
الحقول التالية تهمنا: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - hdr - رأس ملف ELF </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - sechdrs - المؤشر إلى جدول رأس القسم </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - strtab - جدول اسم الرمز - مجموعة من السلاسل مفصولة </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 بالأصفار - index.sym - فهرس رأس القسم الذي يحتوي على جدول الرموز </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
أولاً وقبل كل شيء ، ستحصل الوظيفة على الوصول إلى القسم مع جدول الرموز. </font><font style="vertical-align: inherit;">جدول الرموز عبارة عن مجموعة من العناصر من النوع Elf64_Sym:</font></font><br>
<br>
<pre><code class="plaintext hljs">Elf64_Shdr *symsec = &amp;info-&gt;sechdrs[info-&gt;index.sym];<font></font>
Elf64_Sym *sym = (void *)symsec-&gt;sh_addr;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
بعد ذلك ، في الحلقة ، نراجع جميع الأحرف في الجدول ، ونحدد لكل اسم:</font></font><br>
<pre><code class="plaintext hljs">for (i = 1; i &lt; symsec-&gt;sh_size / sizeof(Elf_Sym); i++) {<font></font>
	const char *name = info-&gt;strtab + sym[i].st_name;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يحتوي الحقل st_shndx على فهرس رأس القسم الذي يتم تعريف هذا الحرف فيه. </font><font style="vertical-align: inherit;">إذا كانت هناك قيمة صفرية (حالتنا) ، فإن هذا الرمز ليس داخل الوحدة ، فأنت بحاجة إلى البحث عنه في النواة:</font></font><br>
<br>
<pre><code class="plaintext hljs">	switch (sym[i].st_shndx) {<font></font>
	.....<font></font>
	 case SHN_UNDEF: //  0<font></font>
	ksym = resolve_symbol_wait(mod, info, name);<font></font>
 	/* Ok if resolved.  */<font></font>
	if (ksym &amp;&amp; !IS_ERR(ksym)) {<font></font>
		sym[i].st_value = kernel_symbol_value(ksym);<font></font>
		break;<font></font>
	}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ثم تأتي قائمة انتظار النقل في وظيفة application_relocations:</font></font><br>
<br>
<pre><code class="plaintext hljs">static int apply_relocations(struct module *mod, const struct load_info *info)<font></font>
{<font></font>
	unsigned int i;<font></font>
	int err = 0;<font></font>
<font></font>
	/* Now do relocations. */<font></font>
	for (i = 1; i &lt; info-&gt;hdr-&gt;e_shnum; i++) {<font></font>
	.....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في الحلقة ، نبحث عن أقسام النقل ونعالج سجلات كل قسم موجود في دالة application_relocate_add:</font></font><br>
<br>
<pre><code class="plaintext hljs">if (info-&gt;sechdrs[i].sh_type == SHT_RELA) //   <font></font>
	err = apply_relocate_add(info-&gt;sechdrs, info-&gt;strtab,<font></font>
				info-&gt;index.sym, i, mod);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يتم تمرير مؤشر إلى جدول رأس القسم ، ومؤشر إلى جدول اسم الرمز ، وفهرس رأس قسم مع جدول رمز وفهرس رأس قسم نقل لتطبيق_relocate_add:</font></font><br>
<br>
<pre><code class="plaintext hljs">int apply_relocate_add(Elf64_Shdr *sechdrs,<font></font>
	   const char *strtab,<font></font>
	   unsigned int symindex,<font></font>
	   unsigned int relsec,<font></font>
	   struct module *me)<font></font>
{<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
نتناول أولاً قسم النقل:</font></font><br>
<br>
<pre><code class="plaintext hljs">Elf64_Rela *rel = (void *)sechdrs[relsec].sh_addr;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ثم ، في حلقة ، نقوم بفرز مجموعة من إدخالاتها:</font></font><br>
<br>
<pre><code class="plaintext hljs">for (i = 0; i &lt; sechdrs[relsec].sh_size / sizeof(*rel); i++) {
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
نجد قسم النقل والموضع فيه ، أي </font><font style="vertical-align: inherit;">حيث نحتاج إلى إجراء تغييرات. </font><font style="vertical-align: inherit;">حقل sh_info لرأس قسم النقل هو فهرس رأس قسم النقل ، وحقل r_offset من سجل النقل هو الإزاحة إلى الموضع داخل قسم النقل:</font></font><br>
<br>
<pre><code class="plaintext hljs">/* This is where to make the change */<font></font>
loc = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
عنوان الشخصية التي سيتم استبدالها في هذا الموقف ، مع مراعاة الإضافة. </font><font style="vertical-align: inherit;">يحتوي حقل r_info الخاص بإدخال إعادة التوطين على فهرس هذا الرمز في جدول الرموز:</font></font><br>
<br>
<pre><code class="plaintext hljs">	/* This is the symbol it is referring to.  Note that all<font></font>
	   undefined symbols have been resolved.  */<font></font>
	sym = (Elf64_Sym *)sechdrs[symindex].sh_addr<font></font>
		+ ELF64_R_SYM(rel[i].r_info);<font></font>
<font></font>
	val = sym-&gt;st_value + rel[i].r_addend;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
يحدد نوع النقل النتيجة النهائية للحسابات ، في مثالنا هو R_X86_64_PLT32:</font></font><br>
<br>
<pre><code class="plaintext hljs">	switch (ELF64_R_TYPE(rel[i].r_info)) {<font></font>
	......<font></font>
	case R_X86_64_PLT32:	<font></font>
		if (*(u32 *)loc != 0)<font></font>
			goto invalid_relocation;<font></font>
		val -= (u64)loc;	//   <font></font>
		*(u32 *)loc = val;  //    <font></font>
		break;<font></font>
	.....<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
الآن يمكننا حساب القيمة النهائية بأنفسنا ، مع العلم أن sym-&gt; st_value هو عنوان دالة printk 0xffffffff810b3df9 ، r_addend هو (-4) ، الإزاحة إلى موضع النقل هي 0xd من بداية قسم نص الوحدة ، أو من بداية وظيفة foo ، أي </font><font style="vertical-align: inherit;">سيكون ffffffffc000000d. </font><font style="vertical-align: inherit;">استبدل كل هذه القيم واحصل على:</font></font><br>
<br>
<pre><code class="plaintext hljs">val = (u32)(0xffffffff810b3df9 - 0x4 - 0xffffffffc000000d) = 0xc10b3de8
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
دعونا نلقي نظرة على تفريغ وظيفة foo ، التي حصلنا عليها في البداية:</font></font><br>
<br>
<pre><code class="plaintext hljs">53 89 fe 89 fb 48 c7 c7 24 10 00 c0 e8 e8 3d 0b c1 8d 43 02 5b c3 66 2e 0f
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
عند الإزاحة 0xD ، تم العثور على القيمة 0xc10b3de8 ، وهي مطابقة للقيمة التي حسبناها. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
هذه هي الطريقة التي تعالج بها kernel عمليات الترحيل وتحصل على الإزاحة اللازمة لأمر الإغلاق. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
في إعداد المقال ، تم استخدام إصدار نواة لينكس 5.4.27.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar504414/index.html">كيف قتل مايكروسوفت AppGet</a></li>
<li><a href="../ar504420/index.html">كتابة ساحة PvP مبنية على أساس مع حركات متزامنة</a></li>
<li><a href="../ar504430/index.html">Everyday Life Tinkoff Security Operations Center: Single Bootloader Analysis</a></li>
<li><a href="../ar504434/index.html">برنامج تعليمي للآباء: كيفية حماية الأطفال من الخطر على الإنترنت</a></li>
<li><a href="../ar504438/index.html">30 نقرة في الأسبوع. نفتح موسم الصيف 2020</a></li>
<li><a href="../ar504444/index.html">استخدام عامل إرساء متعدد المراحل لبناء صور النوافذ</a></li>
<li><a href="../ar504448/index.html">الجيل الثاني من اللاعبين</a></li>
<li><a href="../ar504450/index.html">جافا سكريبت الحديثة: عرض جانبي</a></li>
<li><a href="../ar504452/index.html">Ontology تطلق الطبقة 2 ، المساهمة في منصة سلسلة عامة أكثر تكاملاً</a></li>
<li><a href="../ar504454/index.html">أفضل مستودعات GitHub لمطوري الويب</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>