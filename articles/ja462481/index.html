<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏻‍🤝‍🧑🏻 ✋🏾 👁️ タイプシステムFAQ 🤡 ⚽️ 🙇🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本日の翻訳を公開している記事の著者は、この投稿とそれに対するコメントが執筆のきっかけとなったと述べています。彼によると、ITスペシャリストはタイプについて誤解を抱いており、誤った用語を使用し、タイプに関連する問題を議論すると、誤った結論に至ります。彼は静的型システムの擁護者ではないと指摘している。彼...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>タイプシステムFAQ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/462481/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本日の翻訳を公開している記事の著者は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投稿とそれに対するコメントが</font><font style="vertical-align: inherit;">執筆のきっかけ</font><font style="vertical-align: inherit;">となっ</font><font style="vertical-align: inherit;">た</font><font style="vertical-align: inherit;">と述べています。彼によると、ITスペシャリストはタイプについて誤解を抱いており、誤った用語を使用し、タイプに関連する問題を議論すると、誤った結論に至ります。彼は静的型システムの擁護者ではないと指摘している。彼を悩ませているのは、用語の正しい使い方だけです。これは建設的な議論を可能にします。著者はこの資料を自発的に作成したと述べていますが、誤りがないことを願っています。彼が何かを混乱させたら、彼は</font><font style="vertical-align: inherit;">それについて</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">知らせる</font><font style="vertical-align: inherit;">ように頼み</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">
型システムについて話すときに混乱の原因となるものを一度に理解しましょう。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/5h/v0/_9/5hv0_9iyqwfr7itow5ihgjdpdio.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的型付けと型付けの欠如</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部の人々は、動的型システムは型なし型システムと同じであると考えています。</font><font style="vertical-align: inherit;">型付けの欠如は、特定の型システムでは型を区別しても意味がないことを意味します。</font><font style="vertical-align: inherit;">型システムに型が1つしかない場合でも、型を区別しても意味がありません。</font><font style="vertical-align: inherit;">例えば：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブラーでは、唯一のタイプはビットのストリングです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラムダ計算では、唯一のタイプは関数です。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰かがこの機会にこれを言うかもしれません：「しかし、それはどのような違いを生むのですか-動的なタイピングまたはタイピングの欠如-私にとっても質問です。」しかし、実際には、これは大きくて重要な問題です。事実、動的型付けと型付けの欠如を同一視すると、動的型システムが静的型システムの反対であるという事実が自動的に採用されることになります。その結果、プログラマーの2つの対立する陣営が形成されます-動的タイピングキャンプと静的タイピングキャンプです（これは、対応するセクションで説明するように、間違っています）。</font></font><br>
<br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数の値の範囲を制限しない言語は、型なし言語と呼ばれます。型がない、または同じことですが、すべての値を含むユニバーサル型が1つだけあります。</font></font></font></i><br>
<sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型システム、Luca Cardelli</font></font></a></sub><br>
<br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラミング言語には、その世界を大まかに2つのグループに分割できる興味深い機能が1つあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型なし言語-プログラムは単に実行されます。</font><font style="vertical-align: inherit;">これは、「フォームの均一性」をチェックすることなく、迅速に行われます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型指定された言語-コンパイル中またはプログラムの実行中に、「形式の均一性」をチェックする試みが行われます。</font></font></li>
</ul></font></i><br>
<sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「プログラミング言語の型システム」、ベンジャミンピアース</font></font></sub><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的および静的型付け</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
動的型システムは、型が動的に（プログラムの実行中に）チェックされるシステムです。</font><font style="vertical-align: inherit;">静的型システムは、型が静的にチェックされるシステムです（コンパイル時またはコード変換時）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのシステムの1つは他のシステムの反対ですか？いいえ、ちがいます。どちらのタイプのシステムも同じ言語で使用できます。実際、ほとんどの静的型システムには動的型チェックもあります。例として、入出力操作（入出力、IO）の検証を検討してください。数字を入力する必要があるユーザーから提供されたデータを読み取る必要があると想像してください。実行時に、数値が対応する行の解析の結果であるかどうかを確認します（解析の結果として、例外がスローされるか、returnなどが返される場合があります</font></font><code>NaN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。ユーザーが入力したデータをチェックして、それらを数値と見なすことができるかどうかを判断するとき、動的な型チェックを実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、静的型と動的型の間に対立がないことがわかります。</font><font style="vertical-align: inherit;">あなたは同じ言語で、それらと他の両方を使用することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、静的型チェックは複雑なプロセスであることに注意してください。</font><font style="vertical-align: inherit;">プログラムの一部を静的にチェックすることが非常に難しい場合があります。</font><font style="vertical-align: inherit;">その結果、静的型チェックを適用する代わりに、動的チェックに頼ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静的型システムは、静的にチェックされる型と見なすことをお勧めします。</font><font style="vertical-align: inherit;">動的型システムは、動的にチェックされる型のようなものです。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的型を使用すると、コンパイル時に型を知ることになりますか？</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションのタイトルで提起された質問は否定的に答えることができます。</font><font style="vertical-align: inherit;">パーサー（JavaScriptパーサーを含む）のソースコードを開くと、パーサーが解析中に値のタイプを知っていることがわかります（これはコンパイルプロセスの一部です）。</font></font><br>
<br>
<pre><code class="plaintext hljs">let x = "test";</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーサーはそれ</font></font><code>"test"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が文字列で</font><font style="vertical-align: inherit;">あることを知っていること</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">わかり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これはJavaScriptを静的型付き言語にしますか？</font><font style="vertical-align: inherit;">いいえ、ありません。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">段階的タイピング</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
段階的型システムは、プログラムの一部の型チェックをスキップできる静的な型システムです。</font><font style="vertical-align: inherit;">たとえば、TypeScriptでは、これは</font></font><code>any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font><font style="vertical-align: inherit;">を使用して実装され</font></font><code>@ts-ignore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方で、これにより型システムの安全性が低下します。</font><font style="vertical-align: inherit;">一方、段階的なタイピングを備えたタイプシステムでは、動的なタイピングを使用して言語にタイプの説明を徐々に追加できます。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信頼できるタイプのシステムと信頼できないタイプのシステム</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
信頼できる型システム（サウンド型システム）を使用する場合、このプログラムに型に関連するエラーがあるかどうか、プログラムは型チェック中に「承認」されません。不健全な型システムを使用すると、プログラムに型に関連するエラーが含まれる可能性があります。確かに、それについて知った後、慌てる必要はありません。実際には、これは問題にはなりません。信頼性または健全性は、証明を必要とする型チェックアルゴリズムの数学的特性です。多くの既存のコンパイラ（内部では、型チェックシステム）は信頼できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
信頼性の高い型システムで作業したい場合は、Hindley-Milner型システムを使用するMLファミリーのプログラミング言語をご覧ください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、信頼性の高い型システムは間違ったプログラムをスキップしない（間違ったプログラムが正しいと見なして誤検知テスト結果を出さない）ことは理解する必要がありますが、正しいプログラムを見逃すことはありません（誤った負のテスト結果を出す可能性があります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正しいプログラムを決して拒否しない型システムは完全と呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
型システムが信頼性と完全性の両方を備えていることはありますか？</font><font style="vertical-align: inherit;">私の知る限り、そのような型システムは存在しません。</font><font style="vertical-align: inherit;">最後まではわかりませんが、ゲーデルの不完全性定理に基づくと、そのような型システムの存在は根本的に不可能であるように思えます（私は間違っているかもしれません）。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱くて強いタイピング</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「弱いタイピング」と「強いタイピング」という用語を使うのは不適切だと思います。これらの用語はあいまいであり、それらを使用すると、明確さよりも混乱が生じやすくなります。いくつか引用をさせてください。</font></font><br>
<br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらの言語は、比喩的に言えば、型チェックが弱い言語（または通常、さまざまな出版物で呼ばれている、型付けの弱い言語）と呼ぶことができます。言語で弱い型チェックを使用すると、安全でない操作が静的に検出される場合とそうでない場合があります。このクラスの言語での型チェックの「弱さ」は大きく異なります。</font></font></font></i><br>
<sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型システム、Luca Cardelli</font></font></a></sub><br>
<br>
<i><font color="#999999">,             «»  «» .     ,           . ,   ,   ,     ,     ,    ,  ,  .     « »  « »    .<br>
<sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">«       »,  </a></sub><br>
<br>
 « »  « »  .     :<br>
<br>
<ul>
<li>  « »  « ».  «»  ,  ,    ,    «».   ,        .</li>
<li>,  « »,    «   ». ,  JavaScript     <code>"a" - 1</code>.     « ».            , ,              <code>1 - 1.1</code>.    ,     « »,  «»  «»  .         . «»  «»  —   ,     .</li>
<li>   « »   ,           .</li>
<li> « »    ,      .  C —    ,     . ,  <code>xs</code> —      — C    ,      <code>xs[5]</code>  <code>xs[1000]</code>.     ,    ,      <code>xs</code>.</li>
</ul></font></i><br>
<sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">«»,  </a></sub><br>
<br>
<h2><font color="#3AC1EF">        ?</font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静的に型付けされた言語では、必ずしも型宣言が必要なわけではありません。</font><font style="vertical-align: inherit;">型システムが型を推測できる場合があります（コード構造に基づいて仮定を行うことにより）。</font><font style="vertical-align: inherit;">次に例を示します（TypeScript）。</font></font><br>
<br>
<pre><code class="plaintext hljs">const x = "test";</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
型システムはそれ</font></font><code>"test"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が文字列で</font><font style="vertical-align: inherit;">あることを知ってい</font><font style="vertical-align: inherit;">ます（この知識はコード解析の規則に基づいています）。</font><font style="vertical-align: inherit;">型システム</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、これが定数であること、つまり、値</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を再割り当てできないこと</font><font style="vertical-align: inherit;">も知って</font><font style="vertical-align: inherit;">います。</font><font style="vertical-align: inherit;">その結果、</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文字列型</font><font style="vertical-align: inherit;">であると結論付けることができます</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下に別の例（フロー）を示します。</font></font><br>
<br>
<pre><code class="plaintext hljs">const add = (x, y) =&gt; x / y<font></font>
//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^        [1]   .<font></font>
add(1, "2")</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
型チェックシステムは、関数を呼び出し</font></font><code>add</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て、数値と文字列を渡すこと</font><font style="vertical-align: inherit;">を認識し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これは、関数の宣言を分析します。</font><font style="vertical-align: inherit;">型チェックシステムは、除算演算を実行するために、対応する演算子の右側と左側に数字がなければならないことを認識しています。</font><font style="vertical-align: inherit;">除算演算に関係するオペランドの1つが数値ではありません。</font><font style="vertical-align: inherit;">その結果、エラーが通知されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここには型宣言はありませんが、これは上記のプログラムの静的型チェックに干渉しません。</font><font style="vertical-align: inherit;">現実の世界で同様の状況に遭遇した場合は、遅かれ早かれ、いくつかの型を宣言する必要があります。</font><font style="vertical-align: inherit;">型システムは、すべての型を完全に推測できるわけではありません。</font><font style="vertical-align: inherit;">ただし、言語は型宣言を使用するためではなく、プログラムの開始前に型がチェックされるため、「静的」と呼ぶことができることを理解する必要があります。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScriptで記述されたコードはJavaScriptコードにコンパイルされるため、TypeScriptは安全ではありませんか？</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScriptは不健全な言語です。</font><font style="vertical-align: inherit;">したがって、その上に書かれたコードは、安全でないアプリケーションに変わる可能性があります。</font><font style="vertical-align: inherit;">しかし、これはコンパイルする対象とは関係ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどのデスクトップコンパイラは、プログラムをアセンブリ言語のようなものに変換します。</font><font style="vertical-align: inherit;">そして、アセンブラーはJSよりも安全性の低い言語です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、JSでのコンパイルが原因でTSが安全ではないという考えに戻ると、次のように思われるかもしれません。</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」思慮は賢明です。しかし、これもTSを安全でない言語と呼ぶ理由にはなりません。 TSがアプリケーション内のセキュリティを保証するためには、TSコードが外界と相互作用する場所に「防御メカニズム」を配置する必要があります。つまり、たとえば、入出力メカニズムを介してプログラムに入力されるデータの正確性をチェックする必要があります。これは、ユーザーが入力した内容の確認、サーバーの応答の確認、ブラウザーのストレージから読み取ったデータの確認などであるとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、エルムにおけるこのような「防御メカニズム」の役割は、「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポート</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」</font><font style="vertical-align: inherit;">が担ってい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。 TSでは、io-tsのようなものを使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
対応する「保護メカニズム」は、静的型システムと動的型システムの間のブリッジを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは簡単な例です：</font></font><br>
<br>
<pre><code class="plaintext hljs">const makeSureIsNumber = (x: any) =&gt; {<font></font>
&nbsp;&nbsp;const result = parseFloat(x);<font></font>
&nbsp;&nbsp;if (isNaN(result)) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;throw Error("Not a number");<font></font>
&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;return result;<font></font>
}<font></font>
const read = (input: any) =&gt; {<font></font>
&nbsp;&nbsp;try {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;const n = makeSureIsNumber(input);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;//     n, ,  <font></font>
&nbsp;&nbsp;&nbsp;&nbsp;//          <font></font>
&nbsp;&nbsp;&nbsp;&nbsp;// makeSureIsNumber "" , n  <font></font>
&nbsp;&nbsp;} catch (e) { }<font></font>
}</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型がコンパイラにのみ必要であることは本当ですか？</font></font></font></h2><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型は、コンパイラにヒントを与えるために必要なハックにすぎません。</font></font></font></i><br>
<sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Waut Mertens</font></font></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
型はコンパイラーのみが必要ですか？</font><font style="vertical-align: inherit;">これは哲学的な質問です。</font><font style="vertical-align: inherit;">型は人ではなく車に必要です。</font><font style="vertical-align: inherit;">コンパイラーは、人々が作成したプログラムであるため、型が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプの現象は人が原因で存在します。</font><font style="vertical-align: inherit;">タイプは、人が「データタイプ」の形で何かを認識するまで存在しません。</font><font style="vertical-align: inherit;">人間の心は、さまざまなエンティティをさまざまなカテゴリに分けます。</font><font style="vertical-align: inherit;">タイプはオブザーバーなしでは意味がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
思考実験をアレンジしましょう。</font><font style="vertical-align: inherit;">Lifeゲームについて考えてみてください。</font><font style="vertical-align: inherit;">正方形のセルで構成される2次元グリッドがあります。</font><font style="vertical-align: inherit;">各セルは、2つの可能な状態にあります。</font><font style="vertical-align: inherit;">「生きている」か「死んでいる」かのどちらかです。</font><font style="vertical-align: inherit;">各セルは、8つの隣接セルと対話できます。</font><font style="vertical-align: inherit;">これらは、垂直方向、水平方向、または斜めに境界を定めるセルです。</font><font style="vertical-align: inherit;">システムの次の状態を見つけるプロセスでは、次のルールが適用されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人口密度が低い場合のように、「生存」セルが2つ未満の「生存」隣接セルが「死ぬ」場合。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「生きている」隣人が2人または3人いる「生きている」細胞は生き残り、次の世代に分類されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4つ以上の「生きている」隣人がいる「生きている」細胞は、あふれているかのように「死ぬ」。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「死んだ」細胞は、ちょうど3つの「生きている」隣人がいて、人口の生殖のように「生きている」ようになります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
外見的には、正方形のセルに分割されたフィールドのように見え、それらは常に「オン」と「オフ」になっています。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でそれを見ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しばらく生命を観察すると、「グライダー」のような安定した構造物がフィールドに現れることがあります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/710/310/04f710310ef2d132545b15df0e19e601.gif"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グライダー見え</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ますか？</font><font style="vertical-align: inherit;">グライダーが画面上を移動します。</font><font style="vertical-align: inherit;">真実？</font><font style="vertical-align: inherit;">少し遅くしましょう。</font><font style="vertical-align: inherit;">このグライダーは本当に存在しますか？</font><font style="vertical-align: inherit;">これらは単に現れたり消えたりする個々の正方形です。</font><font style="vertical-align: inherit;">しかし、私たちの脳はこの構造を客観的に存在するものとして認識することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、正方形は独立していないため（隣同士に依存しているため）「グライダー」が存在すると言え、「グライダー」自体が存在しなくても、形には「グライダー」があるプラトニックなアイデア。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
型付きプログラミング言語で書かれたプログラムを考えてみましょう。</font><font style="vertical-align: inherit;">タイプを観察できます。</font><font style="vertical-align: inherit;">正しい？</font><font style="vertical-align: inherit;">しかし、プログラムはマシンコードにコンパイルされます。</font><font style="vertical-align: inherit;">これらのコードでは、元のプログラムと同じものが表現されています（プログラムの機械表現を読むのは難しいですが）。</font><font style="vertical-align: inherit;">コンピュータの観点からは、タイプはありません。</font><font style="vertical-align: inherit;">彼はビットのシーケンスだけを見ます-ゼロと1のセット（「死んだ」セルと「生きている」セル）。</font><font style="vertical-align: inherit;">タイプは人のためのものであり、車のためのものではありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読者の皆様！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Web開発に理想的なタイプシステムはどれですか。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja462471/index.html">pwnable.kr 16でジョブを解決する-uaf。解放後の脆弱性を使用</a></li>
<li><a href="../ja462473/index.html">マイクロサービスを使用するための環境を開発しています。パート1ベアメタルへのKubernetes HAのインストール（Debian）</a></li>
<li><a href="../ja462475/index.html">Алексей Савватеев: Как бороться с коррупцией при помощи математики (Нобелевская премия по экономике за 2016 год)</a></li>
<li><a href="../ja462477/index.html">科学者はAIを新しい特許の作成者であると主張し、特許法を変更しようとしています</a></li>
<li><a href="../ja462479/index.html">Steam Windowsクライアントローカル権限エスカレーション0day</a></li>
<li><a href="../ja462483/index.html">関数型プログラミング：労働生産性を殺す風変わりなおもちゃ。パート1</a></li>
<li><a href="../ja462485/index.html">関数型プログラミング：労働生産性を殺す風変わりなおもちゃ。パート2</a></li>
<li><a href="../ja462487/index.html">Cython：30倍を超えるPythonコードアクセラレーション</a></li>
<li><a href="../ja462489/index.html">先週のフロントエンドの世界からの新鮮な食材のダイジェストNo.374（2019年7月29日〜8月4日）</a></li>
<li><a href="../ja462493/index.html">マルチモデルDBMS-現代の情報システムの基礎？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>