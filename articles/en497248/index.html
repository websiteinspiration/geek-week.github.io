<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ôüèº üè® üòß Microservices or modular systems? How can a customer choose an approach to the IT architecture of a product ‚úäüèª üêù üîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Microservice and modular systems are types of IT solutions architecture.
 When working with modules, we are finalizing a boxed version of an existing ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Microservices or modular systems? How can a customer choose an approach to the IT architecture of a product</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/497248/"><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microservice and modular systems are types of IT solutions architecture.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When working with modules, we are finalizing a boxed version of an existing IT product. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By the boxed version we mean a monolith, a ready-made system with a core that is delivered to all customers the same way, "as is." </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The refinement consists in creating modules with missing functionality. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We obtain new modules by reusing parts of the monolith (core or other modules). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Business logic is written inside the monolith: for a program (application, site, portal) there is one entry point and one exit point. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When working with microservices, we create an IT product from scratch, composing it from ‚Äúbricks‚Äù - atomic microservices that are responsible for a separate small process (send a letter, receive order information, change the order status, create a client, etc.).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A set of such blocks is combined by business logic into a common system (for example, using BPMS). </font><font style="vertical-align: inherit;">Despite the presence of connections, each block is autonomous and has its own entry and exit points. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Most IT products for our customers begin with modular development. </font><font style="vertical-align: inherit;">Some of them evolve over time to microservices. </font><font style="vertical-align: inherit;">For the other part, microservices are not needed. </font><font style="vertical-align: inherit;">In this article, we will examine why this is exactly so and what criteria help determine whether it is necessary to implement microservices or if you should stick to working with modules.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e49/d21/b9e/e49d21b9e7d70c040a3d7ce537b94c19.jpg" alt="image"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benefits of Modular Architecture</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All CMS systems (Bitrix, Magento, Drupal, Hybris, etc.), CRM, ERP, WMS, and many others have boxed versions. </font><font style="vertical-align: inherit;">They sell well and are in high demand. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at those objective reasons why customers most often choose to work with a modular architecture and willingly purchase boxed solutions.</font></font><br>
<br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">High speed of implementation</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Installing, configuring and filling out directories for such software takes a little time. </font><font style="vertical-align: inherit;">It is realistic for a medium-sized company to start working with a box three to four months after the start, sometimes even a little earlier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For small businesses, this period can be only a few days.</font></font></li>
<li><b> </b><br>
<br>
     . ,       enterprise-   .</li>
<li><b>     </b><br>
<br>
       .            . ,       ,                  ,     .</li>
<li><b> ,  </b><br>
<br>
             .    ,        .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are other subjective factors that can be misleading and influence the decision to use boxes and modules. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Race of manufacturers</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Software sellers warmly convince customers that their solution out of the box is the right one: it has been tested for years, and fashionable, and enterprise, and popular, and marketing ... Any supplier: Bitrix, Magento, SAP, Oracle, OpenCart, Django and everyone else is working hard on marketing and sales techniques. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Misconception about the complexity of improvements.</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Customers are often full of optimism. They choose boxed software and think: ‚ÄúYes, improvements will be needed. But it‚Äôs easy: you don‚Äôt have to invent something new. We have a popular version, but millions of users cannot make mistakes and buy a bad product. ‚Äù</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In their view, the refinement process looks like this: there is a main (boxed) functionality. To "finish" something in it, developers will have to "just" redefine the module or quickly write their own. In this case, it is not necessary to use repeated methods, because everything is supposedly thought out in the monolith: common methods for calculating taxes are prescribed, there are clear rules for writing delivery and payment methods, clear workflow of orders, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In real life, things are different. And after pleasant emotions from the easy start of working with the box, customers are still faced with harsh reality. Most often this happens with companies from medium and large businesses, the projects of which have a unique business logic, and large-scale improvements are needed in them.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If your company is a small business and the software is not your main asset, then most likely, a popular boxed (or better - a cloud) solution will suit you. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at what problems you may encounter when working with a modular architecture and how microservices help to avoid this.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problems of modular systems</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main problem is that all modular systems are not designed to seriously redefine functionality. </font><font style="vertical-align: inherit;">They have a box, ready-made modules - that‚Äôs better to use them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The closer to the enterprise level the size of the project and the complexity of their customizations, the more problems there will be with the completion of the modules. </font><font style="vertical-align: inherit;">Let's talk about the main ones.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problem No. 1. The core of the system becomes a deceleration point, and modularity becomes an unnecessary complication.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's say your project is associated with complex warehouse logic. If you choose a modular architecture, then developers do not just need to create functionality to manage these warehouses - they need to redefine or expand the multicore module, which, in turn, uses kernel methods. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, it is necessary to take into account the complex logic of returns to warehouses: dependence on events from the CRM system, movement of goods between catalogs, etc. It is also worth considering the hidden logic that is associated with the return of funds, bonus points, etc.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When so many redefinitions occur, the monolith changes significantly. </font><font style="vertical-align: inherit;">It is important to remember that the relationship between the volume of new functionality and the number of modules is non-linear: to add one function, you must either make changes to several modules, each of which changes the operation of the other, or redefine a large number of methods of other modules in the new module, which does not change the essence. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After all the changes, the system becomes so complicated that an indecently large number of hours will be required to add the following customizations.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2d3/82f/0de/2d382f0de298b267b9e3ce6ca8f2fd58.webp" alt="image"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problem No. 2. The principle of self-documentation is not supported in modular systems.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The documentation for modular systems is difficult to keep up to date. </font><font style="vertical-align: inherit;">It is a lot of it, and it becomes outdated with each change. </font><font style="vertical-align: inherit;">Refinement of one module entails changes in several other documents (in user, technical documentation), and all of them need to be rewritten. </font></font><br>
Ôªø<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a rule, there is no one to do such work: spending time of valuable IT-specialists on this means simply draining the budget. </font><font style="vertical-align: inherit;">Even the use of documentation storage in code (PHPDoc) does not guarantee its reliability. </font><font style="vertical-align: inherit;">In the end, if the documentation may differ from the implementation, it will necessarily be different.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problem No. 3. Greater coherence of the code - the path to regression: ‚Äúthey changed it here, it fell off‚Äù</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The classic problems of modular systems are in the fight against regression. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TDD development is difficult to use for monoliths because of the great coherence of different methods (you can easily spend 30 lines of tests on five lines of code, plus fixtures). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, in the fight against regression, it is necessary to cover the functional with integration tests. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But in view of the already slow development (after all, you need to develop it carefully to provide for many overrides), customers do not want to pay for complex integration tests. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Functional tests become as big as meaningless. They run for hours, even in parallel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yes, a modern front like PWA can be tested API-functionally. But tests often depend on receiving data from the external circuit - and therefore begin to feil if, for example, test SAP is behind the grocery for N months, and test ‚Äú1C‚Äù sends incorrect data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When you have to upload a small edit for some module, developers should choose from two evils: start a full CI run and spend a lot of time on a deploy or lay out a hotfix without running a test, risking breaking something. It‚Äôs very dramatic when such edits arrive from the marketing department on Black Friday. Of course, sooner or later, regression and human error will happen. Is that familiar?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ultimately, to fulfill business goals, the team goes into emergency mode of operation, skillfully juggles tests and carefully looks at dashboards from the logs - Kibana, Grafana, Zabbix ... But what do we get in the end? </font><font style="vertical-align: inherit;">Burnout. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You must admit that such a situation with regression is not like the ‚Äústable enterprise‚Äù as it should be in the dreams and dreams of the customer.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Issue # 4: Code Connectivity and Platform Update</font></font></h3><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another problem with code connectivity is the difficulty in updating the platform. </font></font><br>
Ôªø<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, Magento contains two million lines of code. Wherever we look, there is a lot of code everywhere (Akeneo, Pimcore, Bitrix). When adding functionality to the kernel, it would be better to take into account changes in your custom modules. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is a live example for Magento. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the end of 2018, a new version of the Magento 2.3 platform was released. Multistores and Elasticsearch have been added to the Open Source Edition. In addition, thousands of bugs were fixed in the kernel and some goodies in OMS were added.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What have e-Commerce projects faced with that have already written multistores in Magento 2.2? They needed to rewrite a bunch of logic in order processing, checkout, product cards in order to use boxed functionality. Indeed, ‚Äúso right‚Äù - why duplicate the functionality of the boxed version in the modules? Reducing the volume of custom code in a large project is always useful - after all, all box methods take into account these multi-warehouses, and updating the box without such refactoring can be pointless (note security issues for simplicity, especially since they can be rolled up without updating). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now imagine: how much time will be spent on such an update and how can this be tested without integration tests, which are difficult to write?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is not surprising that for many, updating the platform takes place either without refactoring, but with an increase in duplication, or (if the team wants to do everything in feng shui) with ‚Äúleaving‚Äù for a long time in refactoring and restoring order.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problem No. 5. Opacity of business processes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the most important problems in project management is that the customer does not see all the logic and all the business processes of the project. </font><font style="vertical-align: inherit;">They can only be restored from code or from documentation (the relevance of which, as we said earlier, is problematic to maintain in modular systems).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yes, Bitrix has a BPM part, while Pimcore has a workflow visualization. </font><font style="vertical-align: inherit;">But this attempt to manage modules through business processes always conflicts with the presence of a kernel. </font><font style="vertical-align: inherit;">In addition, events, complex timers, transactional operations - all this does not occur in BPM monoliths. </font><font style="vertical-align: inherit;">I repeat: this applies to medium and large companies. </font><font style="vertical-align: inherit;">For a small company, the capabilities of modular systems are enough. </font><font style="vertical-align: inherit;">But if we are talking about the enterprise segment, then this solution still lacks a single control center, where you can go and look at the diagram of any process, any status, exactly how something happens, what are the exceptions, timers, events and crowns . </font><font style="vertical-align: inherit;">There is not enough opportunity to change business processes, but not modules. </font><font style="vertical-align: inherit;">The process management of the project is drowning in the speed of change and the coherence of logic.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problem 6. Complexity of system scaling</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you deploy a monolith, it will be deployed in its entirety with all modules on each app server. </font><font style="vertical-align: inherit;">Those. </font><font style="vertical-align: inherit;">you cannot separately increase the service of processing orders and bonuses in a season, separately from the rest of the code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Need more memory and processors, which greatly increases the cost of the cluster.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How microservices save customers from the flaws typical of modular development. </font><font style="vertical-align: inherit;">Microservices Orchestration in Camunda and jBPM</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Spoiler: The solution to the problems listed in the last paragraph is possible using BPMS and orchestrating microservice systems. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BPMS (English business process management system) is software for managing business processes in a company. Popular BPMS that we work with are Camunda and jBPM. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Orchestration describes how services should interact with each other using messaging, including business logic and a sequence of actions. Using BPMS, we do not just draw abstract schemes - our business process will be executed according to the drawn. What we see in the diagram is guaranteed to correlate with how the process works, what microservices are used, what parameters, according to which decision tables, a particular logic is selected.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ct/ik/ul/ctikula_txivfnw4laxpscmckiq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As an example, we take a frequently encountered process - sending an order for delivery. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By any message or direct call, we start order processing with the process of choosing a delivery method. </font><font style="vertical-align: inherit;">The selection logic is set. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, processes, services and development:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">become quickly readable;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">self-documenting (they work exactly as they are drawn, and there is no rassynchron between documentation and the actual work of the code);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">just debugged (it‚Äôs easy to see how this or that process goes and understand what the error is).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will get acquainted with the principles by which business process management systems work.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BPMS Principle No. 1. Development Becomes Visual and Process</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BPMS allows you to create a business process in which the project team (developer or business user) determines the sequence of launch of microservices, as well as the conditions and branches along which it moves. </font><font style="vertical-align: inherit;">In this case, one business process (sequence of actions) may be included in another business process. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All this is clearly presented in BPMS: in real time you can watch these schemes, edit them, put them in a productive way. </font><font style="vertical-align: inherit;">Here, the principle of a self-documenting environment is maximally fulfilled - the process works exactly as it is visualized.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All microservices become process cubes that can be added from a snap to a business user. </font><font style="vertical-align: inherit;">Business manages the process, and the developer is responsible for the availability and correct operation of a particular microservice. </font><font style="vertical-align: inherit;">Moreover, all parties understand the general logic and purpose of the process.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BPMS Principle No. 2. Each service has clear inputs and outputs.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The principle sounds very simple, and it may seem to an inexperienced developer or business user that BPMS does not improve the strategy of writing microservices in any way. </font><font style="vertical-align: inherit;">Like, normal microservices can be written without BPMS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yes, it is possible, but difficult. </font><font style="vertical-align: inherit;">When a developer writes a microservice without BPMS, he inevitably has a desire to save on abstractness. </font><font style="vertical-align: inherit;">Microservices become frankly large, and sometimes they even begin to reuse others. </font><font style="vertical-align: inherit;">There is a desire to save on the transparency of the transfer of the result from one microservice to another. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BPMS encourages you to write more abstractly. </font><font style="vertical-align: inherit;">Development is carried out precisely process, with the definition of input and output.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BPMS Principle No. 3. Concurrency of Queue Processing</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagine the process of processing orders: we need to go to some market place, pick up all the good orders and start processing them. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7b5/a9d/d5a/7b5a9dd5a1bc98e6a13215e99bece0fd.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Look at the diagram (part of the diagram). </font><font style="vertical-align: inherit;">Here it is determined that every 10 minutes we check all the orders of the marketplace, then run in parallel (as indicated by the vertical ‚Äúhamburger‚Äù in the Process Order) the processing of each order. </font><font style="vertical-align: inherit;">If successful, transfer all data to ERP and complete the processing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we suddenly need to raise the logs for processing a specific order, in Camunda, JBoss or any other BPMS, we will be able to completely restore all the data and see in which queue it was and with what input / output parameters.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BPMS Principle No. 4. </font><font style="vertical-align: inherit;">Error and escalation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagine that an error occurred during the delivery process. </font><font style="vertical-align: inherit;">For example (by the way, this is a real case), the transport company took the order, and then the warehouse burned down. </font><font style="vertical-align: inherit;">Another real story: New Year's Eve rush, the product was first delayed, and then, perhaps, it was lost. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, events are triggered by the mouse in BPMS, for example, notification of a client in case delivery time has passed. </font><font style="vertical-align: inherit;">If you received a mistake from the transport company inside, you can start the process on your own branch and interrupt everything: notify, give a discount on the next order, return the money. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All such exceptions are difficult not only to program outside of BPMS (for example, a timer in a timer), but also to be understood in the context of the whole process.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BPMS Principle No. 5. </font><font style="vertical-align: inherit;">The choice of actions for one of the events and interprocess options</font></font><br>
</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Submit the same order in delivery. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In total, we have three scenarios:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the goods were delivered as expected;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the goods were not delivered as expected;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">item has been lost.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Directly in BPMS, we can determine the procedure for the shipment of goods to the transport company and expect one of the events by order:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">successful delivery (messages from the product delivery process that everything was delivered);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or the onset of some time.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the time has not passed, you need to start another service: parsing this specific order with the operator (you need to set a task for it in the OMS / CRM system to find out where the order is) with further notification of the client. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But if in the process of investigation the order was nevertheless delivered, it is necessary to interrupt the investigation and complete the processing of the order. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In BPMS, all interrupts and exceptions are on the BPMS side. </font><font style="vertical-align: inherit;">You do not overload the code with this logic (and the very presence of such logic in the code would make microservices large and poorly reused in other processes).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BPMS Principle No. 6. </font><font style="vertical-align: inherit;">In your Camunda you will see all the logs</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using events and the interprocess option, you:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You see the whole sequence of events in one window (what‚Äôs happening with the order, which branch of the exceptions it went through, etc. - it's easy to see);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can collect all analytics for BI on the basis of BPMS logs alone (without the need to overload microservices with logging events).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, you will be able to collect statistics specifically on the problems of processing, transition rates, all processes of the company. </font><font style="vertical-align: inherit;">There is a unification of the logging information - it is easy to link the event in the delivery with the action of the operator or the event of any other information system. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pay attention to the difference with the modular system: universal logs can also be made there, but when interacting with other systems, you will need to do something with the unification of logging in them, and this is not always possible.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusions: a comparison of microservice and modular architecture</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each type of architecture has its advantages and disadvantages. There is no universal solution. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We do not advocate a massive shift to microservices. On the contrary, for a small business or when using a very small number of customizations, a modular approach will be more suitable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also, we are not opposed to any IT solution (Bitrix, Magento, frameworks like Symfony or Django, etc.), because we develop more than six thousand hours of code every month on these frameworks alone, and the same amount of front'a and microservices. Therefore, we are convinced that it is important to look for a suitable technical solution, and not to promote the use of a specific platform (to which, alas, a significant part of sales in IT is rolling down).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the previous sections of the article, you learned about the disadvantages and advantages of modular architecture. </font><font style="vertical-align: inherit;">We hope this has already helped to evaluate whether the refinement of the boxed version or the creation of microservices from scratch would be more suitable. </font><font style="vertical-align: inherit;">If it was not possible to decide, let's see how different types of architecture change depending on the project life. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the start of the project:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with microservices - you have zero functionality, and you need to write all of it to get to work;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a modular system - from the boxed version a large amount of functionality is immediately available to you, and you can start using the product soon after purchase.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After the first 3-4 months of development (this is the average release date for the first MVP) and beyond:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with microservices - the volume of functionality is gradually aligned in comparison with the boxed version. </font><font style="vertical-align: inherit;">For medium-sized businesses, microservice architecture will catch up with modular fast enough, but for large - generally instantly. </font><font style="vertical-align: inherit;">And in the future, the maintenance and development of a modular system in terms of a functional unit will increase;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a modular system - the speed of development of functionality will be significantly lower than in microservices.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/getpro/habr/post_images/8e3/771/cc5/8e3771cc589bd9e28a8344e2ea2a1b37.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In conclusion, let's look at how orchestration of microservices looks with specific examples.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Services orchestration visualization examples</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider the orchestration of services using Camunda. </font><font style="vertical-align: inherit;">From the following images, you can evaluate how convenient it is to manage microservices using BPMS with an orchestrator. </font><font style="vertical-align: inherit;">All processes are visual, the logic is obvious. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Business processes look like this: </font></font><br>
<img src="https://habrastorage.org/getpro/habr/post_images/ad3/5b5/cd6/ad35b5cd690d2ca590c703ab3ed8d3e4.webp" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Example (order, availability service): </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/56b/f55/d9e/56bf55d9e2fb275a477601628430d2c6.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It can be seen that in this order there was a branch ‚ÄúNo goods‚Äù. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another copy of the order (went to the assembly): The </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/470/5d8/4c1/4705d84c19cebb0ad9c5fca58f41d2fd.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
order went further and, according to the decision table (DMN), went to the processing branch by a certain delivery service operator (Boxberry): </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/af8/d54/486/af8d5448653f276387c54492a93fece2.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Care for the nested process: The </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/14c/b45/693/14cb45693eca190e592e3d2357c92d6b.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nested process worked out: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/14c/b45/693/14cb45693eca190e592e3d2357c92d6b.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
History of business processes: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d78/88b/be8/d7888bbe8dbbb036df2425c2a5d115f0.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Properties of this visualization:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">business processes are easy to read even by an unprepared user;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">they are executable, that is, they work exactly as they are drawn, there is no rassynchron between the "documentation" and the actual work of the code;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the processes are transparent: it is easy to see how a particular import, order, processing went, it is easy to see where the mistake was made.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recall that we at kt.team use both modular and microservice development, choosing the right option for each product individually. </font><font style="vertical-align: inherit;">But if the choice has already been made in favor of microservice architecture, then we are firmly convinced that it is impossible to do without BPM systems like Camunda or jBPM. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
See also: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video on the topic ‚ÄúMicroservice or monolithic architecture: what to choose?‚Äù</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en497232/index.html">Nikolay Petrov: ‚ÄúOpenStreetMap is a project where it is not necessary to communicate with people‚Äù</a></li>
<li><a href="../en497234/index.html">Modifying MQTT Proxy</a></li>
<li><a href="../en497238/index.html">Making SQL Server and PerfMon Friends</a></li>
<li><a href="../en497240/index.html">Analysis of Baruch Sadogursky's report ‚ÄúDevOps for developers (or against them ?!)‚Äù</a></li>
<li><a href="../en497242/index.html">Homemade half mask respirator from improvised materials in 10 minutes</a></li>
<li><a href="../en497254/index.html">Cisco HyperFlex: Launch, Configure, Cloud Integration - April 21-22</a></li>
<li><a href="../en497258/index.html">Tcl / Tk. Alternative file explorer for Linux and Android platforms</a></li>
<li><a href="../en497260/index.html">How Myst developers managed to fit the whole universe on one CD-ROM</a></li>
<li><a href="../en497264/index.html">Personalized interface. Part 2. Automatic navigation settings</a></li>
<li><a href="../en497268/index.html">The heading "Read articles for you." March 2020. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>