<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋🏻 💕 👐 使用OpenCV库识别3D点云的2D截面中的椭圆弧 🚘 🌝 💤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="随着能够接收3D点云（3dOT）的价格实惠的激光扫描仪（激光雷达）的广泛传播以及该技术在各个领域（从机械工程到安全性，从石油工业到建筑）的广泛应用，人们对处理算法的兴趣重新燃起。点云。3d在工业
 
 上的流行应用之一是仅针对已建造，旧的或改装的设备创建设计文档，该设备通常由管道和其他圆柱形几何结构...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>使用OpenCV库识别3D点云的2D截面中的椭圆弧</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490400/"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随着能够接收3D点云（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">的价格实惠的激光扫描仪（激光雷达）的</font><em><font style="vertical-align: inherit;">广泛传播</font></em><font style="vertical-align: inherit;">以及该技术在各个领域（从机械工程到安全性，从石油工业到建筑）的广泛应用，人们对处理算法的兴趣重新燃起。点云。</font><em><font style="vertical-align: inherit;">3d</font></em><font style="vertical-align: inherit;">在工业</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上的流行应用之一</font><font style="vertical-align: inherit;">是仅针对已建造，旧的或改装的设备创建设计文档，该设备通常由管道和其他圆柱形几何结构组成。</font><font style="vertical-align: inherit;">
为了检测</font><em><font style="vertical-align: inherit;">3dOT中的</font></em><font style="vertical-align: inherit;">几何图元</font><font style="vertical-align: inherit;">，通常使用专用的3D库（例如</font><em><font style="vertical-align: inherit;">Microsoft PCL）</font></em></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。使用现成的库的方法以及优点都有缺点。例如，很难将它们合并到通常具有2D尺寸的现有Kadov处理方案中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们考虑如何处理</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，例如泵站，从2D剖面开始并使用整个2D处理库，可在可靠且优化的图像处理库（例如</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）中找到该库</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c2/bu/-i/c2bu-isuyb45ji2pz_6nibzg8zi.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图1.泵站的3D OT模型</font></font></i><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过扫描各种管道结构获得的截面的主要元素是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">椭圆弧</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8w/zl/2h/8wzl2hcgbhlmexqxdvl6ezottgm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图2.平均水平的泵站3D模型的水平横截面</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
对于本文，我们将考虑的范围限制为一个允许检测任意椭圆弧的关键算法-这是用于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弧段增长和区域绑定</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">区域增长和边缘链接</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">的迭代算法</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
增长算法是最明显且易于验证的算法，尽管与统计算法相比是耗时的，但它更适合场景包含一个椭圆形的松散耦合远距离对象的情况。</font><font style="vertical-align: inherit;">这些算法将在以后的文章中讨论。</font></font><br>
<br>
</p><h4>  </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，为简单起见，我们省略了从源</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件中获取部分，对部分进行</font><font style="vertical-align: inherit;">预处理，将其聚类以隔离几何图元的过程，以及随后进行的绑定，校正和其他需要获得模型参数的摄影测量操作的过程。我们将不会以相同的方式讨论启发式搜索算法的参数化。让我们描述</font><font style="vertical-align: inherit;">构建算法的</font><font style="vertical-align: inherit;">所有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本操作</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们假设需要在该图像中检测（识别，分类）椭圆弧（即计算椭圆的参数以及椭圆弧的初始和最终角度），该椭圆是从点云的水平部分切出的。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/co/rj/km/corjkmmhyxcxvrnex89_iex1aei.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图3. 3D模型横截面的椭圆弧之一（平滑后）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了盲目地减少光栅的工作，我们将通过</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概述</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行光栅的所有操作</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV的</font></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findContours</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序</font><font style="vertical-align: inherit;">上的发现</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">垫</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">光栅</font><font style="vertical-align: inherit;">所有外部（不带内部形状）</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的轮廓</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在整数点的载体（在光栅坐标）的载体的形式：</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function">Mat <span class="hljs-title">mat</span><span class="hljs-params">(size)</span></span>;
 <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;Point&gt;&gt; contours;<font></font>
 findContours(mat, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是我们的关键操作，在某些简单情况下可以</font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全解决任务</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是由于并非总是可以找到退化的情况，因此让我们通过轮廓更详细地考虑加工技术。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
反向操作使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">根据现有外部电路生成栅格</font><font style="vertical-align: inherit;">，看起来也很简单：</font></font><br>
<pre><code class="cpp hljs"> drawContours(mat, contours, <span class="hljs-number">-1</span>, Scalar(<span class="hljs-number">255</span>), <span class="hljs-number">-1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它还经常用于遮罩轮廓，绘制或计算面积。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，在初始阶段，我们需要将一</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组补丁</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（一条特定曲线的片段）连接成椭圆弧，从而消除结构的其他组件（例如紧固件）的部分或扫描过程中因阴影产生的光学噪声以及其他原因。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们创建一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">判别函数</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该</font><i><font style="vertical-align: inherit;">函数</font></i><font style="vertical-align: inherit;">将返回轮廓的类型（椭圆，线性线段，阴影或其他），以及轮廓的端点及其旋转的轮廓矩形：</font></font><br>
<pre><code class="cpp hljs"> contourTypeSearch(
   <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;contour, Vec4i &amp;def, RotatedRect &amp;rc);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
矩形的长与宽之比有助于快速区分接近</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线性段的</font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">轮廓</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及较小的</font><i><font style="vertical-align: inherit;">噪声轮廓</font></i><font style="vertical-align: inherit;">。</font><em><font style="vertical-align: inherit;">OpenCV中</font></em></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
旋转的矩形</font><font style="vertical-align: inherit;">具有</font><u><font style="vertical-align: inherit;">复杂的</font></u><font style="vertical-align: inherit;">坐标系。如果不是所需的角度本身，而是所需的</font><i><font style="vertical-align: inherit;">三角函数</font></i><font style="vertical-align: inherit;">，那么从上下文来看，它就变得不那么明显了。如果</font><i><font style="vertical-align: inherit;">使用角度</font></i><font style="vertical-align: inherit;">的</font><i><font style="vertical-align: inherit;">绝对值</font></i><font style="vertical-align: inherit;">，则必须</font><font style="vertical-align: inherit;">考虑</font><font style="vertical-align: inherit;">到</font><u><font style="vertical-align: inherit;">角度是从水平方向到矩形的第一边缘沿逆时针方向计数的，并且具有负值</font></u><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">椭圆轮廓</font><i><font style="vertical-align: inherit;">的端点</font></i><font style="vertical-align: inherit;">是使用我们的过程找到的，该过程会接收到</font><em><font style="vertical-align: inherit;">Mat</font></em><font style="vertical-align: inherit;">栅格</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><u><font style="vertical-align: inherit;"></font></u><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><u><font style="vertical-align: inherit;"></font></u><font style="vertical-align: inherit;"></font><br>
<br>
<i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过遮罩从原始图像中提取出具有区别的轮廓，并返回</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大缺陷</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<pre><code class="cpp hljs"> contourConvFeature(mat, &amp;def, … );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该函数的主要代码是调用两个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过程</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; *hull = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<font></font>
 convexHull(contour, *hull);<font></font>
 <span class="hljs-built_in">vector</span>&lt;Vec4i&gt; *defs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;Vec4i&gt;();<font></font>
 convexityDefects(contour, *hull, *defs);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一个过程</font><font style="vertical-align: inherit;">为研究中的轮廓</font><font style="vertical-align: inherit;">找到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凸多边形</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，第二个过程计算所有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凸缺陷</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">考虑到它决定了轮廓的终点，</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们只</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑最大</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的凸度缺陷。如果轮廓的外部或内部边界具有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特征</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则可能不是这种情况</font><font style="vertical-align: inherit;">。为了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它们</font><font style="vertical-align: inherit;">平滑，我们对研究中的轮廓（而不是整个图像）进行了额外的平滑处理，以免“模糊”轮廓之间的地峡并且不违反原始拓扑。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cb/e2/tl/cbe2tlqhmia2hyb727mcspjsb5w.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图4.凸起缺陷的计算</font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项（a）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">错误地定义了红色终点。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项（b）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确定义端点。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项（c）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在原始形状上重新定义了端点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于在采用的技术中，每次都会</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重新生成</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电路</font><font style="vertical-align: inherit;">，因此我们必须通过</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">详尽的搜索</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过程来重新搜索对应点（或更确切地说，是它们的索引）</font><font style="vertical-align: inherit;">：</font></font><br>
<pre><code class="cpp hljs"> nearestContourPtIdx(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;contour, <span class="hljs-keyword">const</span> Point&amp; pt);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于无法完全摆脱这些特征的情况，还实施了另一种</font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电弧分离</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式</font><font style="vertical-align: inherit;">（与内部/外部电弧分开工作）。例如，在轮廓的外弧</font><font style="vertical-align: inherit;">与其他物体</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接触</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">噪声的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情况下，这一点很重要</font><font style="vertical-align: inherit;">。在这种情况下，您可以使用内部弧。在这种情况下，不必分别处理外部电弧和内部电弧。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同样，根据众所周知</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的圆弧凸</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">率比公式，</font><font style="vertical-align: inherit;">可以近似估计</font><font style="vertical-align: inherit;">圆</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">半径，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并拒绝太大的椭圆：</font></font><br>
<pre><code class="matlab hljs">R = bulge / <span class="hljs-number">2</span> + SQR(<span class="hljs-built_in">hypot</span>) / (<span class="hljs-number">8</span> * bulge);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，对于所有轮廓，找到了它们的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凸度缺陷度量</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（或将它们分类为线性或较小并从过程中删除）。</font><font style="vertical-align: inherit;">在最后阶段，将其他参数（例如旋转尺寸参数等）添加到原始指标，并且</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按大小</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对要研究的完整指标集进行</font><i><font style="vertical-align: inherit;">排序</font></i><font style="vertical-align: inherit;">。</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-keyword">typedef</span> tuple&lt;<span class="hljs-keyword">int</span> , <span class="hljs-comment">// </span>
   RotatedRect, <span class="hljs-comment">//  </span>
   Vec4i, <span class="hljs-comment">//  </span>
   <span class="hljs-keyword">int</span>&gt; <span class="hljs-comment">// </span>
   RectDefMetric;</code></pre><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">端点连接弧段的算法</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生长算法清晰明了：我们以最大的轮廓为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">种子，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后尝试对其进行生长，即找到最接近的斑块并将其附着到满足生长条件的端点。在成长的图中，我们输入</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所需的椭圆弧</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。遮罩</font><font style="vertical-align: inherit;">图形并从原始图形中</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">减去</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图形。我们重复增长过程，</font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直到初始设置用完</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
增长算法的基本过程如下所示：</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-built_in">vector</span>&lt;Point&gt; *patch =<font></font>
    growingContours(contour, def, tmp, hull);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其中</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">轮廓</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是所研究的轮廓，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">def</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是其凸度缺陷，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">船体</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是整个区域的凸多边形，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是辅助缓冲区矩阵。在输出中，我们得到一个矢量增长的轮廓。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该过程包括尝试进行种子生长的一个循环，最后以耗尽可用的补丁进行生长或</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以最大迭代次数</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><i><font style="vertical-align: inherit;">参数为</font></i><font style="vertical-align: inherit;">限制</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tp/se/p1/tpsep1tdzgtvitxcnptg9rxu4m0.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图5.许多没有种子的生长斑块</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
主要困难是选择</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最接近</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">轮廓终点的</font><i><font style="vertical-align: inherit;">斑块</font></i><font style="vertical-align: inherit;">，这样图形只能</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向前</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生长</font><font style="vertical-align: inherit;">。对于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">切线方向</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们取端点附近的弧线的平均线。在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图6中</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示了在某个迭代中用于连接到种子的候选对象。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5g/8x/ij/5g8xijwx2owywp4kgjielcgoft8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图6.被多个生长候选补丁包围的种子。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
对于每个候选补丁，将计算以下度量：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> tuple&lt;
   <span class="hljs-keyword">double</span>, <span class="hljs-comment">//    2      2   </span>
   <span class="hljs-keyword">bool</span>, <span class="hljs-keyword">bool</span>, <span class="hljs-comment">//,  4   </span>
   <span class="hljs-keyword">int</span>, <span class="hljs-comment">// </span>
   Vec4i&gt; <span class="hljs-comment">//  </span>
   DistMetric;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仅考虑落入</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">切向锥的面片</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。然后，选择距离最小的面片，然后通过将连接部分压印到栅格中，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连接</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到种子的相应末端。对于种子的另一端，将搜索与参数匹配的补丁，如果找到，则还将其连接到种子。然后，将种子</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">屏蔽并</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从许多补丁中</font><i><font style="vertical-align: inherit;">减去</font></i><font style="vertical-align: inherit;">。从头开始重复该过程。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在增长过程的最后，我们得到了一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">椭圆弧</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，还有待验证。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，使用标准的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">补丁接收的过程（以路径的形式，我们记得路径和栅格可以与我们互换）并返回</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">旋转的标注</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即完整的椭圆。</font></font><br>
<pre><code class="cpp hljs"> RotatedRect box = fitEllipse(patch);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，我们拒绝过大和过小的椭圆，然后应用我们的原始过程来</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比较</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成的椭圆弧和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">栅格形式</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的初始生长斑</font><i><font style="vertical-align: inherit;">的面积</font></i><font style="vertical-align: inherit;">。此过程包括一些伪装的技巧，因此我们现在将省略其描述。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，我们找到检测到的椭圆的其余参数- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起始角度和终止角度</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（我们已经知道</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fitEllipse的半轴</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要确定起始角和终止角，请按以下步骤进行：将完整的椭圆转换</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为多边形，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并通过直接枚举找到最接近端点的点。他们的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">角坐标</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（实际上是索引），并且将是椭圆弧的开始和结束角度。</font><font style="vertical-align: inherit;">在代码中，它看起来像这样（有点简化）：</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function">pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;
   <span class="hljs-title">ellipseAngles</span><span class="hljs-params">(<span class="hljs-keyword">const</span> RotatedRect &amp;box,
   <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;ell, <span class="hljs-keyword">const</span> Point &amp;ps, 
   <span class="hljs-keyword">const</span> Point &amp;pe, <span class="hljs-keyword">const</span> Point &amp;pm)</span> 
 </span>{
    <span class="hljs-built_in">vector</span>&lt;Point&gt; ell0;<font></font>
    ellipse2Poly(Point(box.center.x, box.center.y), <font></font>
      Size(box.size.width / <span class="hljs-number">2</span>, box.size.height / <span class="hljs-number">2</span>),<font></font>
      box.angle, <span class="hljs-number">0</span>, <span class="hljs-number">355</span>, <span class="hljs-number">5</span>, ell0);
    <span class="hljs-keyword">int</span> i0 = nearestContourPtIdx(ell0, ps);
    <span class="hljs-keyword">int</span> i1 = nearestContourPtIdx(ell0, pe);<font></font>
    cutSides(ell0, i0, i1, i2, ell, <span class="hljs-literal">nullptr</span>);
    <span class="hljs-keyword">return</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(i0, i1);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cutSides</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过程</font><font style="vertical-align: inherit;">考虑了</font><font style="vertical-align: inherit;">椭圆弧遍历</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拓扑</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">总共应考虑绕过索引</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i0，i1，i2的</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">八种可能情况</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们是沿着外轮廓还是沿着内轮廓，并且哪个指数更大，是初始的还是最终的？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
较容易看到代码：</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cutSides</span><span class="hljs-params">(
   <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;ell0, <span class="hljs-keyword">int</span> i0, <span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2, 
   <span class="hljs-built_in">vector</span>&lt;Point&gt; *ell_in, <span class="hljs-built_in">vector</span>&lt;Point&gt; *ell_out)</span>
 </span>{
   <span class="hljs-keyword">if</span> (i0 &lt; i1) {
      <span class="hljs-keyword">if</span> (i2 &gt; i0 &amp;&amp; i2 &lt; i1) {
         <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        }}<font></font>
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (i2 &gt; i1 &amp;&amp; i2 &lt; i0) {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        }}}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在复杂情况下检测椭圆的一些结果</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如图7</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所示</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jv/56/hd/jv56hdcpfuvmi59k0unppjknlq4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在以下文章中，将考虑统计检测方法。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN490386/index.html">其他如何在证券交易所赚钱并降低风险：有股息支付的公司股票</a></li>
<li><a href="../zh-CN490390/index.html">101XP董事总经理Olga Makushenko：“将游戏作为企业发展的5个主要错误”</a></li>
<li><a href="../zh-CN490392/index.html">Catchain：TON区块链共识算法</a></li>
<li><a href="../zh-CN490394/index.html">准将Amiga 500+：让任何人都不会得罪</a></li>
<li><a href="../zh-CN490398/index.html">红霍格沃茨。军官，或为什么历史学家像侦探</a></li>
<li><a href="../zh-CN490404/index.html">5G为什么以及如何改变一切：技术，分阶段实施和用户设备的要素基础</a></li>
<li><a href="../zh-CN490406/index.html">魅力无穷：我们如何创造出无法暴露的羽绒服</a></li>
<li><a href="../zh-CN490408/index.html">FreeBSD：比GNU / Linux好得多</a></li>
<li><a href="../zh-CN490410/index.html">通过互联网连接的实时和人工神经元</a></li>
<li><a href="../zh-CN490412/index.html">也许我们应该使用JavaScript冷静一下？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>