<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📻 🏴󠁧󠁢󠁷󠁬󠁳󠁿 🤾🏾 Qtライブラリでの拡張システムの作成-パート2 🔓 🐂 🤶🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最初の記事に戻り、グラフィカル・インターフェース（GUI）を使用した拡張メカニズムを開発する必要性がどこから来たのかを説明し、プラグインを作成するメカニズムをさらに詳しく説明したいと思います。
 
 ロシアのオペレーティングシステム上のエンジンの自走銃（自動制御システム）からの情報を調整、調整、制御...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Qtライブラリでの拡張システムの作成-パート2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457744/"><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の記事に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">戻り</font><font style="vertical-align: inherit;">、グラフィカル・インターフェース（GUI）を使用した拡張メカニズムを開発する必要性がどこから来たのかを説明し、プラグインを作成するメカニズムをさらに詳しく説明したい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">と</font></a><font style="vertical-align: inherit;">思います。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロシアのオペレーティングシステム上のエンジンの自走銃（自動制御システム）からの情報を調整、調整、制御、収集、分析するための技術ソフトウェアを開発するための任務が与えられました。自走砲と技術プログラムの間の交換は、特別な交換プロトコルに従って、RS-232またはRS422インターフェースを介して実行されます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロシアのオペレーティングシステムのリストの機能を確認および分析した後、AstraLinuxオペレーティングシステムが選択されました。これはDebianディストリビューションに基づく特別な目的のシステムであり、情報を包括的に保護し、安全な自動システムを構築するように設計されています。 Astra Linuxオペレーティングシステムは、Common Edition（無料、汎用）とSpecial Edition（有料、一連の保護アルゴリズムを備えた特別な目的）の2つのバージョンで開発されています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソフトウェアの開発にはQtライブラリを使用しました。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソフトウェアは機能モジュールで構成されており、それぞれがエンジン設定で特定の作業を実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能モジュールは、さまざまなビジュアルコンポーネント、グラフ、およびテーブルで構成されるウィジェットであり、エンジンパラメータがユーザーフレンドリーな形式で表示されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vj/-a/qj/vj-aqjsytqmpwec1i1lqdxx_yxc.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能モジュール「ダッシュボード」</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/au/wr/pt/auwrpt7gvp7trmajuxc6jfd5p4w.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">許容範囲内でパラメーター値を動的に制御できる</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/a3/h-/9b/a3h-9b5zmpxihau19-a5kcxp5fm.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能モジュール自走砲の特性を設定する機能モジュール</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発したソフトウェア（技術プログラム）は、特定の種類のエンジンのみを対象としたものでした。新しいタイプのエンジンでは、新しいソフトウェアを開発する必要があり、ACSの開発段階でそのようなソフトウェアがすでに需要があったにもかかわらず、このソフトウェアの開発、テスト、デバッグの人件費が大幅に増加し、その結果、このソフトウェアの実装が遅れました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような費用のかかる技術的なソフトウェア開発の慣行を回避するために、ACSが同じ交換プロトコルをサポートするすべてのエンジンに適応するソフトウェアパッケージを開発することが決定されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソフトウェアパッケージ開発のコンセプトは、グラフィックモジュールをサポートするプラグインテクノロジーに基づく機能拡張の可能性でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソフトウェアパッケージは、3つの主要部分で構成されています。</font></font><br>
 <br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複合体の機能コア</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拡張システムエンジン</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラグインセット</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コア機能には、ACSとの信頼性の高いデータ交換の確保と次のタスクの実行が含まれます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 特別なプロトコルを使用したRS232通信</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> エンジンパラメータリストの継続的な監視 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> エンジンパラメータ変更のリクエスト</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 読み取りエンジン読み取り要求</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> パラメータを表形式で表示</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 拡張機能からの要求の処理（必要に応じて新しい監視リストを作成し、単一の書き込みおよび読み取り要求）</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の機能を備えた拡張システム：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 拡張機能を検索する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 拡張グラフィックの取得</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 拡張オブジェクトを表示する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> オブジェクトからの要求（信号）をソフトウェアコアにリンクするタスク </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各プラグインはオブジェクトのファクトリであり、プラグインの主な機能はグラフィックオブジェクトを作成することです。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
拡張システムのタスクは、オブジェクトを取得してプログラムのコアに関連付け（既知のインターフェースを使用）、オブジェクトを初期化してアクティブにすることです。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトとカーネルの接続は、仮想クラスのインターフェースを使用して行われます。新しい拡張機能を開発するには、テクノロジープログラムのコアがサポートするインターフェースを知っていれば十分です。プログラムの構造を次の図に示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j2/mp/t0/j2mpt0susizvmrx8vwq8vy1gwxs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラグイン階層を開発します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sc/5-/qv/sc5-qvtudby49jtepinvw_8ihs0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラグインによって作成されたグラフィカルオブジェクトの階層を検討してください。プラグインを使用する場合はQtオブジェクトを操作する必要があるため、Qtライブラリのようなメインクラスは、QtシグナルスロットメカニズムをサポートするQObjectクラスになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のクラスはQWidgetです。独自のグラフィックフォームを作成するために必要です。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、独自のインターフェイスクラスであるinterfaceWidgetが必要です。これを行うには、QWidgetから継承される抽象クラスを作成します。このクラスでは、メインプロジェクトとプラグインオブジェクトを接続するインターフェイス（信号、関数、スロット）が宣言されます。抽象クラスは、メインプロジェクトのインターフェースサポートを提供します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MyFormQtクラス。これは、interfaceWidgetインターフェースクラスから継承し、インターフェースを定義し、モジュールのグラフィックスと内部機能が開発されます。この継承方式のおかげで、MyFormQtクラスはQWidgetクラスの機能とメインアプリケーションオブジェクトとの開発された通信インターフェースをサポートします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/**
   \class interfaceWidget
   \brief  ,      
*/</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">interfaceWidget</span>:</span> <span class="hljs-keyword">public</span> QWidget<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
        <span class="hljs-comment">/// \brief </span>
        <span class="hljs-keyword">virtual</span> ~interfaceWidget() = <span class="hljs-keyword">default</span>;
        <span class="hljs-comment">/// \brief   </span>
        <span class="hljs-comment">/// \param ba,    </span>
        <span class="hljs-comment">/// \param ok,   </span>
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getByte</span><span class="hljs-params">(QByteArray ba, <span class="hljs-keyword">bool</span> ok)</span> </span>= <span class="hljs-number">0</span>;
        <span class="hljs-comment">/// \brief    </span>
        <span class="hljs-comment">/// \param ba,    </span>
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getRetrieveDate</span><span class="hljs-params">(QByteArray ba, <span class="hljs-keyword">bool</span> ok)</span> </span>= <span class="hljs-number">0</span>;
        <span class="hljs-comment">/// \brief    </span>
        <span class="hljs-comment">/// \param fl,  </span>
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">successfullyWritten</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> fl)</span> </span>= <span class="hljs-number">0</span>;
        <span class="hljs-comment">/// \brief     </span>
        <span class="hljs-comment">/// \param ok    </span>
        <span class="hljs-comment">/// \return       </span>
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> QVector&lt;QString &gt; <span class="hljs-title">regParam</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> &amp;ok)</span> </span>= <span class="hljs-number">0</span>;<font></font>
signals:<font></font>
     <font></font>
        <span class="hljs-comment">/// \brief      </span>
        <span class="hljs-comment">/// \param      </span>
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">signal_writeByteByName</span><span class="hljs-params">(QVector&lt;TVARPARAM &gt; vecParam)</span> </span>= <span class="hljs-number">0</span>;
        <span class="hljs-comment">/// \brief     </span>
        <span class="hljs-comment">/// \param nameParam  </span>
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal_getByteByName</span><span class="hljs-params">(QVector&lt;QString &gt; nameParam)</span> </span>= <span class="hljs-number">0</span>;
        <span class="hljs-comment">/// \brief     </span>
        <span class="hljs-comment">/// \param addr      </span>
        <span class="hljs-comment">/// \param ndata -   </span>
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal_getByteByAddress</span><span class="hljs-params">(quint32 addr, quint32 ndata)</span> </span>= <span class="hljs-number">0</span>;
        <span class="hljs-comment">/// \brief      </span>
        <span class="hljs-comment">/// \param addr     </span>
        <span class="hljs-comment">/// \param ba   </span>
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal_writeByteByAddress</span><span class="hljs-params">(quint32 addr, QByteArray ba)</span> </span>= <span class="hljs-number">0</span>;
        <span class="hljs-comment">/// \brief     </span>
        <span class="hljs-comment">/// \param fl, true  , false  </span>
        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal_enableMonitoring</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> fl)</span> </span>= <span class="hljs-number">0</span>;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような階層により、ダイヤモンド型の継承の問題を回避し、作成されたオブジェクトの信号スロットメカニズムを維持することができます。これは、技術ソフトウェアの開発のための提案技術の重要なポイントです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期化とデータ交換プロセスプロジェクト全体はMDI領域に基づいているため、すべてのプラグインが個別のMDIウィンドウとしてロードされます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファクトリプラグインは、クラスMyFormQtのオブジェクトを作成し、作成されたオブジェクトへのポインターをQObjectへのポインターに変換し、それを技術プログラムに渡します。オブジェクトは、dynamic_cast操作を使用してinterfaceWidgetクラスのオブジェクトに変換され、その結果、このオブジェクトのグラフィカルフォームとインターフェイスへの完全なアクセス権を取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファクトリ関数（プラグインでグラフィカル関数オブジェクトを作成）。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//------------------------------------------------------------------</span>
<span class="hljs-function">QObject *<span class="hljs-title">screenOnlinePlugin::getPluginWidget</span><span class="hljs-params">()</span>
</span>{<font></font>
   MyFormQt *screen = <span class="hljs-keyword">new</span> MyFormQt();
   <span class="hljs-keyword">return</span> qobject_cast&lt;QObject *&gt;(screen); <span class="hljs-comment">//   </span><font></font>
}<font></font>
<span class="hljs-comment">//-------------------------------------------</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
技術プログラム（コア）でグラフィカル機能オブジェクトを取得して開始する機能。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//-----------------------------------------------------------------</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PluginSystem::showPluginWidget</span><span class="hljs-params">(QString dirFabrica)</span>
</span>{	<font></font>
   QMdiSubWindow *sWPS = <span class="hljs-keyword">new</span> QMdiSubWindow;<font></font>
   pQtTM-&gt;m_pma-&gt;addSubWindow(sWPS);<font></font>
   sWPS-&gt;setAttribute(Qt::WA_DeleteOnClose, <span class="hljs-literal">true</span>);
  <span class="hljs-comment">//-------- </span>
    <span class="hljs-function">QPluginLoader <span class="hljs-title">loader</span><span class="hljs-params">(dirFabrica)</span></span>;	   <span class="hljs-comment">//   </span><font></font>
    QObject *pobj = qobject_cast&lt;QObject*&gt;(loader.instance());<font></font>
      <span class="hljs-keyword">if</span>(!pobj)
        <span class="hljs-keyword">return</span>;<font></font>
    pluginInterface *fabrica = qobject_cast&lt;pluginInterface *&gt;(pobj);<font></font>
       <span class="hljs-keyword">if</span>(!fabric)
         <span class="hljs-keyword">return</span>;<font></font>
    QObject *ob = fabrica→getPluginWidget();  <span class="hljs-comment">//   </span>
       <span class="hljs-keyword">if</span>(!ob)
         <span class="hljs-keyword">return</span>;<font></font>
 interfaceWidget *interFaceW = <span class="hljs-keyword">dynamic_cast</span>&lt;interfaceWidget *&gt;(ob);
      <span class="hljs-keyword">if</span>(!interFaceW)
        <span class="hljs-keyword">return</span>;
 <span class="hljs-keyword">delete</span> fabrica;<font></font>
<font></font>
  <span class="hljs-comment">//    </span>
  connect(interFaceW, SIGNAL(), <span class="hljs-keyword">this</span>, SLOT());<font></font>
		<font></font>
  sWPS-&gt;setWidget(interFaceW);<font></font>
  sWPS-&gt;show();<font></font>
    <font></font>
  <span class="hljs-comment">//   </span><font></font>
  QVector&lt;QString &gt; vecParam;<font></font>
  vecParam = interFaceW→regParam(paramOK); <span class="hljs-comment">//  </span>
  <span class="hljs-keyword">if</span>(paramOK)<font></font>
    regParamList(vecPlugin[i].namePlugin ,vecParam);<font></font>
}<font></font>
<span class="hljs-comment">//--------------------------------------------------------------------------------</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作成されたQmdiSubWindowウィンドウに、interfaceWidgetクラスのオブジェクト（グラフィカル機能オブジェクト）が配置され、それによって子として設定されます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、show（）メソッドを使用して、オブジェクトの信号とスロットを技術プログラムのコアとウィンドウ表示の最終ステージの信号とスロットに接続（接続）します。 QmdiSubWindowウィンドウが閉じられると、オブジェクトが配置されたサブウィンドウにDeleteOnCloseプロパティが事前に設定されていたため、interfaceWidgetクラスのオブジェクトも削除されます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラフィック機能オブジェクトと技術プログラム間のデータ交換は、データマーシャリングと2つのモードを使用して行われます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 •シングルモード（要求/応答）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 •監視モードでは、ターゲットデバイスとのデータ交換のメカニズムによって決定される周期でデータを常に受信します。</font></font><br>
<br>
<i> —     ,     .                .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シングルモードでは、ユーザーがグラフィック機能オブジェクト（ウィジェット）のボタンを押すと、パラメーターのリストを含む信号が生成されます。そのデータは、ターゲットデバイス（ACS）で読み取られ、グラフィック機能オブジェクトに転送されます。メインプログラムのデータ交換メカニズムは信号を処理し、自走砲からのRS-232データの要求を開始します。受信したデータはQbyteArrayにパッケージ化され、信号と共にグラフィックオブジェクトに送信されます。オブジェクトは要求されたパラメーターのリストを持っているため、それらのタイプを認識し、QbyteArrayに含まれているデータをアンパックして、それらをグラフやテーブル、および特殊なグラフィックウィジェット（矢印インジケーター、デジタルインジケーター、バックライトボタンなど）の形式で表示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
監視モードでは、プラグインの初期化時に、システムはプラグインに必要なパラメーターのリストをすぐに要求し、そのパラメーターの継続的な監視中に、プラグインの追加パラメーターを読み取り、各データ交換サイクルでそれらをバイトのパケットとして発行します。データ交換サイクルの期間は、要求されたパラメーターの数によって異なります。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、テストが行​​われていると同時に、さまざまなタスク用のプラグインのグループが開発されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいプラグインの開発プロセスをスピードアップするプラグインテンプレートが作成されました。新しい機能モジュールの開発にプラグインテンプレートを使用して、新しいグラフィックフォームを作成し、データ処理および視覚化アルゴリズムを実装する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
物理的なドライバーソフトウェアモジュールは、有線のRS-232インターフェイスとワイヤレスWIFIおよびBluetooth用に開発されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、ソフトウェアパッケージは2チャネルモードで動作します。つまり、2つの自走砲と同時に動作します（これはお客様の要件でした）。機能モジュールのプラグインは、ユーザーが2つのチャネルのいずれかに接続します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テスト中に、カーネルによって正常に処理された12のプラグインを同時に起動することができました。そして、12個のプラグインでさえ、このシステムの制限ではありません。 Qtダブルバッファリングシステムにより、プラグインの描画に費やされる時間が削減され、プラグインのちらつきが防止されます。そのため、将来プラグインの数を増やすと、主な負荷はRS-232インターフェースを介してデータを交換するためだけになります。練習では、ACSエンジンのデバッグ、チューニング、テスト中に、同時に動作する3〜4個のプラグインで十分であることを示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作業の結果、さまざまな種類のエンジン（メカトロニクスシステム）の自走砲のチューニング、試運転、テスト用に設計された技術プログラムを迅速に開発するためのソフトウェアパッケージを受け取りました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまなタイプのエンジン用に2セットのプラグインが開発されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定のタイプの自走砲のプラグインセットをソフトウェアパッケージに接続することにより、このタイプの自走砲の構成、試運転、およびテストのための多機能プログラムが得られます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3g/4a/i1/3g4ai1ohrdvj0thcg-ix4uxgmwy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将来的には、特定のタスクのための独自のグラフィックウィジェットの開発に関する記事と、グラフィックオブジェクトのレイアウトに関する別の記事を書く予定です。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja457730/index.html">オフィスにはコントロールの幻想があります-それはリモコンにはありません。Devhabとの会話</a></li>
<li><a href="../ja457734/index.html">イタリアのオープンソース革命が始まります</a></li>
<li><a href="../ja457736/index.html">「ツールは、それが作成するシステムについて考える能力ほど重要ではありません。」マーティンクレップマンへのインタビュー</a></li>
<li><a href="../ja457738/index.html">SD-Accessの実装方法とそれが必要な理由</a></li>
<li><a href="../ja457742/index.html">高可用性とインフラストラクチャの可用性のためのKubernetesとPrometheusの炉床の水平方向の自動スケーリング</a></li>
<li><a href="../ja457746/index.html">気象学とフライト</a></li>
<li><a href="../ja457750/index.html">Symfony 4でJSON RPCを操作する</a></li>
<li><a href="../ja457752/index.html">月面探査機やジョーカーではありません。福島のロボットについて知っていること</a></li>
<li><a href="../ja457754/index.html">Государство и Т-киллеры</a></li>
<li><a href="../ja457756/index.html">アクションの本カフカストリーム。リアルタイムアプリケーションとマイクロサービス»</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>