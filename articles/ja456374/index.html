<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔯 🚵🏿 🔻 プラズマキャッシュブロックチェーンの状態データ構造 🐋 🏂🏿 💇🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、Habrausers様！この記事は、分散型のインターネットであるWeb 3.0に関するものです。Web 3.0では、現代のインターネットの基礎として分散化の概念が導入されています。多くのコンピューターシステムとネットワークには、ニーズに応じたセキュリティと分散化のプロパティが必要です。分...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>プラズマキャッシュブロックチェーンの状態データ構造</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456374/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、Habrausers様！</font><font style="vertical-align: inherit;">この記事は、分散型のインターネットであるWeb 3.0に関するものです。</font><font style="vertical-align: inherit;">Web 3.0では、現代のインターネットの基礎として分散化の概念が導入されています。多くのコンピューターシステムとネットワークには、ニーズに応じたセキュリティと分散化のプロパティが必要です。</font><font style="vertical-align: inherit;">分散ソリューションは、分散レジストリテクノロジーまたはブロックチェーンと呼ばれます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qd/nd/dv/qdnddvdk76wf5sy2ajwn38jp9w0.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロックチェーンは分散レジストリです。</font><font style="vertical-align: inherit;">これは、永久に存続し、履歴が変化しない巨大なデータベースと見なすことができます。ブロックチェーンは、分散型のWebアプリケーションまたはサービスの基礎として使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本質的に、ブロックチェーンはデータベースであるだけでなく、ネットワークでビジネスロジックを実行する機能を備えたネットワーク参加者間の信頼を高める機会でもあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビザンチンのコンセンサスがネットワークの信頼性を高め、一貫性の課題を解決</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DLTがもたらすスケーラビリティは、既存のビジネスネットワークを変化させています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロックチェーンは新しい非常に重要な利点を提供します：</font></font><br>
<br>
<b><ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コストのかかる間違いの防止。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">透過的なトランザクション。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際の商品のデジタル化。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スマートコントラクト。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支払いのスピードとセキュリティ。</font></font></li>
</ol></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Opporty PoEは、暗号化プロトコルを研究し、既存のDLTおよびブロックチェーンソリューションを改善することを目的とするプロジェクトです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどのパブリック分散レジストリシステムにはスケーラビリティプロパティがありません。スループットはかなり低くなっています。</font><font style="vertical-align: inherit;">たとえば、ethereumは〜20 tx / sしか処理しません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くのソリューションは、スケーラビリティプロパティを向上させ、分散を失わないように作成されました（ご存知のように、スケーラビリティ、セキュリティ、分散の3つのうち2つしか知ることができません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も効果的なのは、サイドチェーンソリューションです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラズマのコンセプト</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
概念は、ルートチェーンが子チェーンからの少数のコミットを処理するため、ルートチェーンはすべての中間状態を格納するための最も安全で最終的なレイヤーとして機能します。</font><font style="vertical-align: inherit;">各子チェーンは、独自のコンセンサスアルゴリズムを持つ独自のブロックチェーンとして機能しますが、いくつかの重要な注意点があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スマートコントラクトはルートチェーンで作成され、ルートチェーンの子チェーンのチェックポイントとして機能します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独自のコンセンサスを持つ独自のブロックチェーンとして機能する子チェーンが作成されます。</font><font style="vertical-align: inherit;">子プロセスのチェーン内のすべての状態は詐欺の証拠によって保護されています。これにより、状態間のすべての遷移が有効であり、撤回プロトコルが適用されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に、dappまたは子チェーン（アプリケーションロジック）に固有のスマートコントラクトを子チェーンにデプロイできます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要なツールをルートチェーンから子チェーンに転送できます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 バリデーターは、正直に行動し、ルートチェーン（トランザクションの最終決済のレイヤー）にコメントを送信する経済的インセンティブを持っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、子チェーンで作業しているdappユーザーはルートチェーンとまったく対話するべきではありません。</font><font style="vertical-align: inherit;">さらに、チャイルドチェーンがハッキングされている場合でも、必要なときにいつでもルートチェーンにお金を引き出すことができます。</font><font style="vertical-align: inherit;">チャイルドチェーンからのこれらの出口により、ユーザーは、マークル証明を使用して資金を安全に保管し、特定の金額の所有権を確認できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラズマの主な利点は、現在メインチェーンに過負荷をかけている計算を大幅に促進する能力に関連しています。さらに、Ethereumブロックチェーンは、より広範囲でより並列なデータセットを処理できます。ルートチェーンから離れた時間は、処理とストレージの要件が低いイーサリアムノードにも転送されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラズマキャッシュは、ネットワーク上のトークンに一意のトークンに変換する一意のシリアル番号を与える設計です。これの利点には、確認の必要性の欠如、すべてのタイプのトークン（非fungibleトークンを含む）のサポートの簡素化、および子チェーンからの大量の出口に対する緩和が含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラズマの問題は、チャイルドチェーンからの「大量出口」の概念に関連しています。</font><font style="vertical-align: inherit;">このシナリオでは、ドーターチェーンからの調整された同時終了により、すべての資金を引き出すための計算能力の不足につながる可能性があります。</font><font style="vertical-align: inherit;">その結果、ユーザーはお金を失う可能性があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラズマ実装オプション</font></font></h2><br>
<img src="https://habrastorage.org/webt/vq/qg/hr/vqqghr_ucnoum3q8o1b215zgcic.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ベースプラズマには、多くの実装オプションがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主な違いは次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態を保存および提示する方法に関する情報の保存 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トークンのタイプ（分割可能分割不可）、 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トランザクションのセキュリティ </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンセンサスアルゴリズムのタイプなど</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラズマの主なバリエーション：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UTXOベース-各トランザクションは入力と出力で構成されます。トランザクションを実行して使用できます。使用されなかったトランザクションのリストは、子チェーン自体の状態です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アカウントベース-各アカウントとその残高のリフレクションのみが含まれます。各アカウントは2つのタイプ（ユーザーアカウントとスマートコントラクトアカウント）にできるため、このタイプはイーサリアムで使用されます。</font><font style="vertical-align: inherit;">このタイプの状態ストレージの利点はその単純さであり、マイナス点は、このオプションがスケーラブルでないことです（トランザクションが2回実行されるのを防ぐために特別なnonceプロパティが使用されます）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 この記事の目的は、Plasma Cashブロックチェーンで使用されるデータ構造を説明することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コミットメントがどのように機能するかを正確に理解するには、マークルツリーの概念を明確にする必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マークルツリーのプラズマでの使用</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マークルツリーは、ブロックチェーンの世界で非常に重要なデータ構造です。本質的に、マークルツリーはデータを非表示にする方法で一部のデータセットをキャプチャする機能を提供しますが、ユーザーは一部の情報がセットに含まれていたことを証明できます。たとえば、10個の番号がある場合、これらの番号の証明を作成し、特定の番号がこの一連の番号に含まれていたことを証明できます。これらの証明は一定のサイズが小さいため、Ethereumに公開するのが安価になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを一連のトランザクションに使用できます。特定のトランザクションがこの一連のトランザクションに含まれていることを証明することもできます。これはまさにオペレーターが行うことです。各ブロックは、マークルツリーに変わる一連のトランザクションで構成されます。この木の根は証拠であり、プラズマの各ブロックとともにイーサリアムで公開されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーは、プラズマチェーンから資金を引き出すことができる必要があります。ユーザーがプラズマチェーンを終了する場合は、「終了」トランザクションをイーサリアムに送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラズマキャッシュは、ブロック全体を検証せず、ユーザーのトークンに対応するブランチのみを検証できるようにする特別なマークルツリーを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、トークンを転送するには、履歴を調べて特定のユーザーが必要とするトークンのみをスキャンする必要があります。トークンを転送するとき、ユーザーは履歴全体を別のユーザーに渡すだけで、ストーリー全体をすでに認証できます。最も重要なのは、非常に迅速に行うことです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/is/3z/wxis3zgyhtyh-ruopuffedzcwsk.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステータスと履歴を保存するためのプラズマキャッシュデータ構造</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでも、ブロックにトランザクションが含まれていることの証明とトランザクションが含まれていないことの証明を取得する必要があるため、一部のマークルツリーのみを使用する必要があります。 </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スパースマークルツリー</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パトリシア・トライ</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Opportyはスパースマークルツリーとパトリシアトライの実装を実装しました。スパースマークル</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツリーは標準の</font><font style="vertical-align: inherit;">マークル</font><font style="vertical-align: inherit;">ツリーに似ていますが、その中に含まれるデータにインデックスが付けられ、各データポイントがそのデータポイントのインデックスに対応するシートに配置される点が</font><font style="vertical-align: inherit;">異なります。</font><font style="vertical-align: inherit;">ツリーがあるとし</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">4つの葉を持つメルクラ。デモのために、このツリーに数文字（A、D）を入力します。 Aはアルファベットの最初の文字なので、最初のシートに配置する必要があります。同様に、4番目のシートにDを置くことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、2番目と3番目の葉ではどうなりますか？空のままにしておきます。より正確には、文字を配置する代わりに、特別な値（たとえば、ゼロ）が配置されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツリーは最終的に次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5g/9g/18/5g9g18uvkq5oizxi81z8pbeij48.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
包含の証明は通常のマークルツリーと同じように機能しますが、Cがこのマークルツリーの一部でないことを証明したい場合はどうなりますか？それは簡単です！ Cがツリーの一部である場合、3番目のシートにあることがわかります。 Cがツリーの一部でない場合、3番目の葉はゼロでなければなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要なのは、マークルが含まれているという標準的な証明であり、3番目のシートがゼロであることを示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スパースマークルツリーの最も優れた点は、マークルツリー内のキーと値のストアを実際に表すことです。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、スパースマークルツリービルドを実装するPoEプロトコルコードの一部です。</font></font><br>
 <br>
<pre><code class="plaintext hljs">class SparseTree { <font></font>
//...<font></font>
        buildTree() {<font></font>
    if (Object.keys(this.leaves).length &gt; 0) {<font></font>
      this.levels = []<font></font>
      this.levels.unshift(this.leaves)<font></font>
      for (let level = 0; level &lt; this.depth; level++) {<font></font>
        let currentLevel = this.levels[0]<font></font>
        let nextLevel = {}<font></font>
 <font></font>
        Object.keys(currentLevel).forEach((leafKey) =&gt; {<font></font>
          let leafHash = currentLevel[leafKey]<font></font>
          let isEvenLeaf = this.isEvenLeaf(leafKey)<font></font>
          let parentLeafKey = leafKey.slice(0, -1)<font></font>
          let neighborLeafKey = parentLeafKey + (isEvenLeaf ? '1' : '0')<font></font>
 <font></font>
          let neighborLeafHash = currentLevel[neighborLeafKey]<font></font>
          if (!neighborLeafHash) {<font></font>
            neighborLeafHash = this.defaultHashes[level]<font></font>
          }<font></font>
 <font></font>
          if (!nextLevel[parentLeafKey]) {<font></font>
            let parentLeafHash = isEvenLeaf ?<font></font>
              ethUtil.sha3(Buffer.concat([leafHash, neighborLeafHash])) :<font></font>
              ethUtil.sha3(Buffer.concat([neighborLeafHash, leafHash]))<font></font>
            if (level == this.depth - 1) {<font></font>
              nextLevel['merkleRoot'] = parentLeafHash<font></font>
            } else {<font></font>
              nextLevel[parentLeafKey] = parentLeafHash<font></font>
            }<font></font>
          }<font></font>
        })<font></font>
 <font></font>
        this.levels.unshift(nextLevel)<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードはかなり簡単です。包含/非包含の証明を備えたKey-Valueストアがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各反復では、最後のツリーから開始して、最終ツリーの特定のレベルが埋められます。現在のシートのキーが偶数か奇数かに応じて、隣接する2つのシートを取り、現在のレベルのハッシュを検討します。最後に到達したら、単一のmerkleRoot（一般的なハッシュ）を記述します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このツリーは、最初は空の値ですでに満たされていることを理解する必要があります。そして、大量のIDSトークンを保存するとします。巨大なツリーサイズがあり、生成に非常に長い時間がかかります！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この非最適化には多くの解決策がありますが、オポーティはこのツリーをパトリシアトライに変更することを決定しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Patricia Trieは、Radix TrieとMerkle Trieを組み合わせたものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基数トライデータキーは、データパス自体を格納します！</font><font style="vertical-align: inherit;">これにより、メモリ用に最適化されたデータ構造を作成できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/af/zc/ly/afzclyhgeydkylbnn5hrjj0gs-g.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機会の実装</font></font></h3><br>
<pre><code class="plaintext hljs">buildNode(childNodes, key = '', level = 0) {<font></font>
    let node = {key}<font></font>
    this.iterations++<font></font>
 <font></font>
    if (childNodes.length == 1) {<font></font>
      let nodeKey = level == 0 ?<font></font>
        childNodes[0].key :<font></font>
        childNodes[0].key.slice(level - 1)<font></font>
      node.key = nodeKey<font></font>
 <font></font>
      let nodeHashes = Buffer.concat([Buffer.from(ethUtil.sha3(nodeKey)),<font></font>
        childNodes[0].hash])<font></font>
      node.hash = ethUtil.sha3(nodeHashes)<font></font>
      return node<font></font>
    }<font></font>
 <font></font>
    let leftChilds = []<font></font>
    let rightChilds = []<font></font>
 <font></font>
    childNodes.forEach((node) =&gt; {<font></font>
      if (node.key[level] == '1') {<font></font>
        rightChilds.push(node)<font></font>
      } else {<font></font>
        leftChilds.push(node)<font></font>
      }<font></font>
    })<font></font>
 <font></font>
    if (leftChilds.length &amp;&amp; rightChilds.length) {<font></font>
      node.leftChild = this.buildNode(leftChilds, '0', level + 1)<font></font>
      node.rightChild = this.buildNode(rightChilds, '1', level + 1)<font></font>
      let nodeHashes = Buffer.concat([Buffer.from(ethUtil.sha3(node.key)),<font></font>
        node.leftChild.hash,<font></font>
        node.rightChild.hash])<font></font>
      node.hash = ethUtil.sha3(nodeHashes)<font></font>
    } else if (leftChilds.length &amp;&amp; !rightChilds.length) {<font></font>
      node = this.buildNode(leftChilds, key + '0', level + 1)<font></font>
    } else if (!leftChilds.length &amp;&amp; rightChilds.length) {<font></font>
      node = this.buildNode(rightChilds, key + '1', level + 1)<font></font>
    } else if (!leftChilds.length &amp;&amp; !rightChilds.length) {<font></font>
      throw new Error('invalid tree')<font></font>
    }<font></font>
 <font></font>
    return node<font></font>
  }<font></font>
 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、再帰的に処理し、左右の子サブツリーを個別に作成します。</font><font style="vertical-align: inherit;">同時に、キーの構築はこのツリーのパスのようなものです！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このソリューションはさらに簡単で、かなり最適化されている間は高速に動作します！</font><font style="vertical-align: inherit;">実際、パトリシアツリーは、イーサリアムプロトコルで行われるように、新しいタイプのノード（拡張ノード、ブランチノードなど）を導入することでさらに最適化できますが、この実装はすべての条件を満たすため、高速でメモリ最適化されたデータ構造が得られます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのデータ構造を実装することで、Opportyはトークンの履歴をチェックし、トークンをツリーに含めないことを含めることができるため、プラズマキャッシュを拡張できるようになりました。</font><font style="vertical-align: inherit;">これにより、ブロックとプラズマ子チェーンの検証を大幅に高速化できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">役立つリンク：</font></font></h3><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ホワイトペーパープラズマ</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gitハブ</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用例とアーキテクチャの説明</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライトニングネットワークペーパー</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja456362/index.html">レベル6デザイナー：デザイナーの意欲と開発の仕方</a></li>
<li><a href="../ja456366/index.html">LEDハートボックスの設計方法</a></li>
<li><a href="../ja456368/index.html">Web3を使用してJPMorgan Quorumブロックチェーンでパブリックおよびプライベートトランザクションを実行する</a></li>
<li><a href="../ja456370/index.html">QsanストレージにQoSを実装する</a></li>
<li><a href="../ja456372/index.html">SimbirSoftはITプロフェッショナルを集中的な夏2019に招待します</a></li>
<li><a href="../ja456376/index.html">1つの春のブーツではない：代替案の概要</a></li>
<li><a href="../ja456380/index.html">ネットロジーのプログラミング学部のオープンデー</a></li>
<li><a href="../ja456382/index.html">フロントエンドでのコラボレーションと自動化。13校から学んだこと</a></li>
<li><a href="../ja456386/index.html">オーディオコンテンツの視覚化のためのオープンライブラリ</a></li>
<li><a href="../ja456388/index.html">PVS-Studioの診断開発チャート</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>