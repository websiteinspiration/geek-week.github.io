<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥠 👐🏼 👨‍👨‍👧‍👧 RabbitMQとKafkaの比較：クラスターのフェイルオーバーと高可用性 👆🏻 👨🏽‍🏭 🚫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="フォールトトレランスと高可用性は大きなトピックであるため、RabbitMQとKafkaは別々の記事を扱います。この記事はRabbitMQについてであり、次の記事はRabbitMQと比較したKafkaについてです。記事が長いので気楽に。
 
 フォールトトレランス、一貫性、および高可用性（HA）の戦略...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>RabbitMQとKafkaの比較：クラスターのフェイルオーバーと高可用性</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/471858/"><img src="https://habrastorage.org/webt/hr/j2/oy/hrj2oyxwqv8-wo-vpmagx_dwmia.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォールトトレランスと高可用性は大きなトピックであるため、RabbitMQとKafkaは別々の記事を扱います。この記事はRabbitMQについてであり、次の記事はRabbitMQと比較したKafkaについてです。記事が長いので気楽に。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォールトトレランス、一貫性、および高可用性（HA）の戦略と、各戦略がもたらすトレードオフを検討してください。 RabbitMQはノードのクラスター上で実行でき、分散システムとして分類されます。分散システムに関しては、一貫性とアクセシビリティについてよく話します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの概念は、障害が発生した場合のシステムの動作を説明しています。ネットワーク接続障害、サーバー障害、ハードディスク障害、ガベージコレクションによる一時的なサーバー使用不可、パケット損失、またはネットワーク接続速度の低下。これにより、データの損失や競合が発生する可能性があります。すべてのタイプの障害に対して、完全に一貫性があり（データの損失なし、データの矛盾なし）、アクセス可能な（読み取りおよび書き込み操作を受け入れる）両方のシステムを立ち上げることはほとんど不可能であることがわかります。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一貫性とアクセシビリティはスペクトルのさまざまな端にあり、最適化する方法を選択する必要があることがわかります。</font><font style="vertical-align: inherit;">良い知らせは、RabbitMQではそのような選択が可能であることです。</font><font style="vertical-align: inherit;">ある種の「オタク」レバレッジを利用して、バランスをより優れた一貫性またはアクセス性にシフトします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確認済みのレコードが原因でデータが失われる構成には特に注意を払います。</font><font style="vertical-align: inherit;">出版社、ブローカー、消費者の間には一連の責任があります。</font><font style="vertical-align: inherit;">メッセージがブローカーに送信された後、メッセージを失わないことが彼の仕事です。</font><font style="vertical-align: inherit;">ブローカーがメッセージを受信したことをパブリッシャーに確認した場合、メッセージが失われることはありません。</font><font style="vertical-align: inherit;">しかし、ブローカーとパブリッシャーの構成によっては、これが実際に発生する可能性があることがわかります。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのノードの安定性のプリミティブ</font></font></h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">持続キュー/ルーティング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RabbitMQには2つのタイプのキューがあります：永続的/非永続的です。</font><font style="vertical-align: inherit;">すべてのキューはMnesiaデータベースに保存されます。</font><font style="vertical-align: inherit;">永続キューは、ノードの起動時に再宣言され、再起動、システムクラッシュ、またはサーバークラッシュ（データが保存されている限り）に耐えます。</font><font style="vertical-align: inherit;">つまり、ルーティング（交換）とキューの回復力を宣言している間、キュー/ルーティングのインフラストラクチャはオンラインモードに戻ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノードが再起動すると、不安定なキューとルーティングが削除されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">永続的な投稿</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キューが長いからといって、すべてのメッセージがノードの再起動後も存続するという意味ではありません。</font><font style="vertical-align: inherit;">メッセージのみが復元され、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安定した</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（持続的な）</font><font style="vertical-align: inherit;">パブリッシャーとして確立され</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">持続メッセージはブローカーに追加の負担をかけますが、メッセージの損失が許容できない場合、他に方法はありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hl/nv/gv/hlnvgvt20t-fbikkajwnkirflyo.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">1.安定性マトリックス</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キューミラーリングクラスタリング</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブローカーの損失を乗り切るには、冗長性が必要です。</font><font style="vertical-align: inherit;">複数のRabbitMQノードを1つのクラスターに結合し、複数のノード間でキューを複製することで冗長性を追加できます。</font><font style="vertical-align: inherit;">したがって、1つのノードが落ちても、データが失われることはなく、引き続き使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キューのミラーリング：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての書き込みコマンドと読み取りコマンドを受け取る1つのメインキュー（マスター）</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メインキューからすべてのメッセージとメタデータを受信する1つ以上のミラー。</font><font style="vertical-align: inherit;">これらのミラーはスケーリングのためではなく、冗長性のためだけに存在します。</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/am/-b/ol/am-boljly334-fiqfajsoowe3iu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">2.キューの</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ミラーリングミラーリングは、対応するポリシーによって設定されます。</font><font style="vertical-align: inherit;">その中で、複製速度を選択でき、キューを配置するノードを選択することもできます。</font><font style="vertical-align: inherit;">例：</font></font><br>
<br>
<ul>
<li><code>ha-mode: all</code><br>
</li>
<li><code>ha-mode: exactly, ha-params: 2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> （1つのマスターと1つのミラー）</font></font><br>
</li>
<li><code>ha-mode: nodes, ha-params: rabbit@node1, rabbit@node2</code></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出版社への確認</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一貫した記録を実現するには、発行者確認を確認する必要があります。</font><font style="vertical-align: inherit;">それらがなければ、メッセージを失う可能性があります。</font><font style="vertical-align: inherit;">メッセージをディスクに書き込んだ後、確認がパブリッシャーに送信されます。</font><font style="vertical-align: inherit;">RabbitMQは、メッセージを受信したときではなく、数百ミリ秒の範囲で定期的にディスクに書き込みます。</font><font style="vertical-align: inherit;">キューがミラーリングされると、すべてのミラーがメッセージのコピーをディスクに書き込んだ後にのみ確認が送信されます。</font><font style="vertical-align: inherit;">これは、確認を使用すると遅延が増えることを意味しますが、データのセキュリティが重要な場合は確認が必要です。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フェイルオーバーキュー</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブローカーがシャットダウンまたはクラッシュすると、このノードのすべての主要なキュー（マスター）がブローカーとともに落ちます。次に、クラスターは各マスターの最も古いミラーを選択し、それを新しいマスターとして昇格させます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pq/v_/_a/pqv__ahffpye5i6h_2pdzozyrgi.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 3.ミラーリングされたいくつかのキューとそのポリシー</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Broker 3がクラッシュします。ブローカー2のキューCのミラーがマスターにアップグレードされていることに注意してください。また、ブローカー1のキューC用に新しいミラーが作成されていることにも注意してください。RabbitMQは常に、ポリシーで指定された複製速度を維持しようとします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/df/e7/la/dfe7laf8pyg0pobmrkgteky-wsw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 4.ブローカー3が落ちて、キューが失敗するC</font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
次のブローカー1が落ちる！ブローカーは1人しか残っていません。キューBのミラーがマスターに上がり</font></font><br>
<br>
<img src="https://habrastorage.org/webt/b2/bd/qi/b2bdqi_lz21qoe8hcdmsjy8g5kc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。 5</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブローカー1を返しました。データがブローカーの損失と回復にどれだけ成功したかに関係なく、ミラーリングされたすべてのキューメッセージは再起動時に破棄されます。結果が出るので注意が必要です。これらの影響については、すぐに検討します。したがって、ブローカー1は再びクラスターのメンバーになり、クラスターはポリシーに準拠しようとするため、ブローカー1にミラーを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、ブローカー1とデータの損失が完了したため、ミラーリングされていないキューDは完全に失われました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wi/ql/68/wiql68dzsoerzuibhspllun85ec.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 6.ブローカー1が稼働中</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブローカー3がオンラインに戻ったので、ラインAとBはHAポリシーに合わせてミラーを作成し直しています。</font><font style="vertical-align: inherit;">しかし、1つのノードのすべてのメインラインが今です！</font><font style="vertical-align: inherit;">これは理想的ではなく、ノード間の均一な分散の方が優れています。</font><font style="vertical-align: inherit;">残念ながら、マスターを再調整するための特別なオプションはありません。</font><font style="vertical-align: inherit;">キューの同期を最初に検討する必要があるため、後でこの問題に戻ります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/hj/4n/bghj4n6pdd5ki4oideq7zbwmasi.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">7.ブローカー3がサービスを再開しました。</font><font style="vertical-align: inherit;">1つのノード上のすべてのメインキュー！</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ミラーはどのようにして冗長性とフォールトトレランスを提供するかについてのアイデアを持っているはずです。</font><font style="vertical-align: inherit;">これにより、単一ノードに障害が発生した場合の可用性が確保され、データ損失から保護されます。</font><font style="vertical-align: inherit;">しかし、実際にはすべてがはるかに複雑であるため、まだ完了していません。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいミラーを作成すると、すべての新しいメッセージが常にこのミラーおよびその他のミラーに複製されます。メインキュー内の既存のデータについては、マスターの完全なコピーになる新しいミラーに複製できます。また、既存のメッセージを複製することはできず、新しいメッセージが末尾に到着し、既存のメッセージがメインキューの先頭を離れたときに、メインキューと新しいミラーを時間的に収束させることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この同期は自動または手動で実行され、キューポリシーを使用して制御されます。例を考えてみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのミラーリングされたラインがあります。キューAは自動的に同期され、キューBは手動で同期されます。どちらの行にも、それぞれ10個のメッセージがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vz/zm/5x/vzzm5x_2w3tphqi09kn6h_9_e1c.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 8.同期モードが異なる2つのキュー</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、私たちはブローカー3を失っています</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5x/wp/ki/5xwpki1aoj_-e1hdt0i-gswn-nu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 9.ブローカー3が落ち、</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ブローカー3がサービスを再開しました。クラスターは、新しいノードの各キューのミラーを作成し、新しいキューAをマスターと自動的に同期します。ただし、新しいターンBのミラーは空のままです。したがって、キューAの完全な冗長性と、キューBの既存のメッセージに対して1つのミラーのみが存在します</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zo/hb/ha/zohbhaicbgsjdynexgjhuh70ujg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 10.キューAの新しいミラーは既存のメッセージをすべて受信しますが、キューBの新しいミラーは受信しません</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
。両方のキューにさらに10個のメッセージが到着します。次に、ブローカー2が落ち、キューAがブローカー1にある最も古いミラーにロールバックします。障害が発生しても、データは失われません。ウィザードのキューBには20個のメッセージがあり、ミラーには10個しかありません。このキューは元の10個のメッセージを複製しなかったためです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yy/hc/sz/yyhcszfowfi6eiidhubgqfy1zry.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 11.キューAは</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
メッセージ</font><i><font style="vertical-align: inherit;">を失うことなくブローカー1にロールバックさ</font></i><font style="vertical-align: inherit;">れ、両方のキューにさらに10個のメッセージが到着します。ブローカー1がクラッシュするキューAは、メッセージを失うことなく、問題なくミラーに切り替えます。ただし、キューBには問題があります。この時点で、アクセシビリティまたは一貫性のいずれかを最適化できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクセシビリティを最適化する場合は、</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ha-promote-on-failure</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポリシー</font><font style="vertical-align: inherit;">を</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">always</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に設定する必要があります</font><font style="vertical-align: inherit;">。これはデフォルト値なので、ポリシーをまったく省略できます。この場合、実際には、非同期ミラーでの障害を許可します。これによりメッセージが失われますが、キューは読み取りと書き込みが可能です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4h/hv/_n/4hhv_n4seyvz33pq_sk3my2bnmk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 12.メッセージを失うことなく、回線Aがブローカー3にロールバックされます。行Bは、メッセージが10個失われてブローカー3にロールバックされます。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値をに</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
設定することもでき</font></font><code>ha-promote-on-failure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font><code>when-synced</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この場合、キューはミラーにロールバックするのではなく、データを持つブローカー1がオンラインモードに戻るまで待機します。彼が戻った後、メインキューは再びデータを失うことなくブローカー1に表示されます。データのセキュリティのため、アクセシビリティは犠牲になります。ただし、これは危険なモードであり、データの完全な損失につながる可能性もあります。これについては、近い将来検討する予定です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fk/mx/gx/fkmxgxilgyi8bp_n_-osz6q8be0.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 13.ブローカー1を失った後、ラインBは引き続き使用できません</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは質問をするかもしれません：「多分それは自動同期を決して使用しない方が良いですか？」。</font><font style="vertical-align: inherit;">答えは、同期はブロッキング操作であるということです。</font><font style="vertical-align: inherit;">同期中、メインキューは読み取りまたは書き込み操作を実行できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を考えてみましょう。</font><font style="vertical-align: inherit;">今、私たちは非常に長い列を持っています。</font><font style="vertical-align: inherit;">どのようにしてこのサイズに成長できますか？</font><font style="vertical-align: inherit;">いくつかの理由で：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キューはアクティブに使用されていません。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらは高速回線であり、現在、消費者は遅い </font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらは高速キューであり、障害が発生し、消費者が追いついています</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/es/6q/gy/es6qgy7p-1cu0avxb1xivijyjii.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">14.同期モードが異なる2つの大きなキュー</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ブローカー3がドロップします</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/ta/ue/vgtauedea7kaitatv7oshzottps.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">15.ブローカー3が落ち、各キューに1つのマスターとミラーが残り、ブローカー3が</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
動作を再開し、新しいミラーが作成されます。</font><font style="vertical-align: inherit;">メインキューAは、既存のメッセージを新しいミラーに複製し始めます。この間、キューAは使用できません。</font><font style="vertical-align: inherit;">データ複製には2時間かかるため、このキューのダウンタイムは2時間になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、キューBは期間全体を通じて使用可能なままです。</font><font style="vertical-align: inherit;">彼女はアクセシビリティのために冗長性をいくらか犠牲にしました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qn/rd/ep/qnrdep5m7sszgxjesb_kfwuw-zw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">16.同期中、キューは引き続き使用できません</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
。2時間後、キューAも使用可能になり、読み取りおよび書き込み操作の受け入れを再開する場合があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アップデート</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同期中のこのブロッキング動作により、非常に大きなキューを持つクラスターをアップグレードすることが困難になります。</font><font style="vertical-align: inherit;">ある時点で、ウィザードのあるノードを再起動する必要があります。これは、サーバーの更新中にミラーに切り替えるか、キューを無効にすることを意味します。</font><font style="vertical-align: inherit;">移行を選択した場合、ミラーが同期されていないとメッセージが失われます。</font><font style="vertical-align: inherit;">デフォルトでは、ブローカーの切断中に、非同期ミラーへの移行は実行されません。</font><font style="vertical-align: inherit;">これは、ブローカーが戻るとすぐに、メッセージが失われないことを意味します。唯一の損傷は、単純なキューのみでした。</font><font style="vertical-align: inherit;">ブローカーの無効化ルールはポリシーによって設定され</font></font><code>ha-promote-on-shutdown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">次の2つの値のいずれかを設定できます。</font></font><br>
<br>
<ul>
<li><code>always</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=非同期ミラーへの切り替えを有効化</font></font><br>
</li>
<li><code>when-synced</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=同期されたミラーのみに切り替えます。そうしないと、キューは読み取りおよび書き込みにアクセスできなくなります。</font><font style="vertical-align: inherit;">ブローカーが戻るとすぐにキューが戻ります</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キューが大きい場合、データの損失とアクセス不能のどちらかを選択する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可用性によりデータセキュリティが向上する場合</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
決定を下す前に、もう1つ複雑な点を考慮する必要があります。</font><font style="vertical-align: inherit;">自動同期は冗長性に優れていますが、データのセキュリティにどのように影響しますか？</font><font style="vertical-align: inherit;">もちろん、より優れた冗長性により、RabbitMQは既存のメッセージを失う可能性が低くなりますが、パブリッシャーからの新しいメッセージはどうなりますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、次のことを考慮する必要があります。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パブリッシャーがエラーを返すだけで、上位のサービスまたはユーザーが後で再試行できますか？</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パブリッシャーはメッセージをローカルまたはデータベースに保存して後で再試行できますか？</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パブリッシャーがメッセージをドロップすることしかできない場合、実際には、アクセシビリティの向上によってデータのセキュリティも向上します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、あなたはバランスを探す必要があり、決定は特定の状況に依存します。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ha-promote-on-failureの問題=同期されたとき</font></font></h1><br><font style="vertical-align: inherit;"></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ha-promote-on-failure</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when-synced</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の考え方は</font><font style="vertical-align: inherit;">、非同期ミラーへの切り替えを防ぎ、データの損失を回避することです。キューは読み取りまたは書き込みのためにアクセスできないままです。代わりに、データを失うことなくマスターとして作業を再開できるように、損傷していないデータを使用して落ちたブローカーを返そうとしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし（これは大きいですが）、ブローカーがデータを失った場合、大きな問題があります。キューが失われます！すべてのデータがなくなりました！基本的にメインキューに追いつくミラーがある場合でも、これらのミラーも破棄されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じ名前のノードを再度追加するには、失われたノードを忘れるようにクラスターに指示します（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rabbitmqctl forget_cluster_nodeコマンドを使用）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、同じホスト名で新しいブローカーを起動します。</font><font style="vertical-align: inherit;">クラスターは、失われたノードを記憶している限り、古いキューと非同期ミラーを記憶します。</font><font style="vertical-align: inherit;">クラスターが失われたノードを忘れるように言われると、このキューも忘れられます。</font><font style="vertical-align: inherit;">次に、それを再宣言する必要があります。</font><font style="vertical-align: inherit;">部分的なデータセットを含むミラーはありましたが、すべてのデータが失われました。</font><font style="vertical-align: inherit;">非同期のミラーに切り替えることをお勧めします！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、</font></font><code>ha-promote-on-failure=when-synced</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私の意見では、と</font><font style="vertical-align: inherit;">組み合わせた手動同期（および同期の失敗）</font><font style="vertical-align: inherit;">は非常に危険です。</font><font style="vertical-align: inherit;">文書によると、このようなオプションはデータセキュリティのために存在するとしていますが、それは両刃のナイフです。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マスターの再調整</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
約束どおり、1つ以上のノード上のすべてのマスターの蓄積の問題に戻ります。</font><font style="vertical-align: inherit;">これは、クラスターのローリングアップグレードの結果としても発生する可能性があります。</font><font style="vertical-align: inherit;">3つのノードを持つクラスターでは、すべてのメインキューが1つまたは2つのノードに蓄積されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マスターの再調整は、次の2つの理由で問題が発生する可能性があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">良いリバランスツールはありません</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キュー同期</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リバランスのために、</font><font style="vertical-align: inherit;">公式にはサポートされていない</font><font style="vertical-align: inherit;">サードパーティの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラグイン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります。</font><font style="vertical-align: inherit;">サードパーティのプラグインに関して、RabbitMQのマニュアルに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ように書か</font></a><font style="vertical-align: inherit;">れています。</font><font style="vertical-align: inherit;">自己責任。 " </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HAポリシーを通じてメインキューを移動する別のトリックがあります。</font><font style="vertical-align: inherit;">マニュアルには、</font><font style="vertical-align: inherit;">このため</font><font style="vertical-align: inherit;">の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スクリプト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">記載されてい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次のように機能します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">既存のHAポリシーよりも優先度の高い一時ポリシーを使用してすべてのミラーを削除します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メインキューの移動先のノードでノードモードを使用するようにHA一時ポリシーを変更します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">強制移行のためにキューを同期します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移行が完了した後、一時ポリシーを削除します。</font><font style="vertical-align: inherit;">HA初期ポリシーが有効になり、必要な数のミラーが作成されます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
欠点は、キューが大きい場合や厳密な冗長性要件がある場合、このアプローチが機能しない可能性があることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、RabbitMQクラスターがネットワークパーティションでどのように機能するかを見てみましょう。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接続の中断</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分散システムのノードはネットワークリンクで接続されており、ネットワークリンクは切断される可能性があります。</font><font style="vertical-align: inherit;">停止の頻度は、ローカルインフラストラクチャまたは選択したクラウドの信頼性によって異なります。</font><font style="vertical-align: inherit;">いずれの場合でも、分散システムはそれらを処理できる必要があります。</font><font style="vertical-align: inherit;">繰り返しになりますが、アクセシビリティと一貫性のどちらかを選択できます。また、RabbitMQが両方を同時に提供できることは朗報です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RabbitMQには、2つの主要なオプションがあります。</font></font><br>
<br>
<ul>
<li>   (split-brain).   ,     .<br>
</li>
<li>  .              .           .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、論理的な分離とは何ですか？</font><font style="vertical-align: inherit;">これは、ネットワーク接続が失われたためにクラスターが2つに分割された場合です。</font><font style="vertical-align: inherit;">両側で、ミラーがマスターに上がります。したがって、最終的には、各ターンにいくつかのマスターがいます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mi/4f/bb/mi4fbbuk9maj487alkqsbbykkns.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">17.メインラインと2つのミラー。それぞれ別のノードにあります。</font><font style="vertical-align: inherit;">次に、ネットワーク障害が発生し、1つのミラーが分離します。</font><font style="vertical-align: inherit;">切り離されたノードは、他の2つが落ちたことを確認し、そのミラーをマスターに進めます。</font><font style="vertical-align: inherit;">これで2つのメイン行があり、どちらも書き込みと読み取りが可能です。</font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パブリッシャーが両方のマスターにデータを送信すると、キューの2つの分岐コピーが取得されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまなRabbitMQモードは、アクセシビリティまたは一貫性のいずれかを提供します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無視モード（デフォルト）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このモードはアクセシビリティを提供します。接続が失われた後、論理的な分離が発生します。再接続した後、管理者は優先するパーティションを決定する必要があります。失われた側が再起動され、この側から蓄積されたデータはすべて失われます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ih/rj/ow/ihrjow-ceolx0wy8y2o-cn2yiuk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 18. 3つの発行元が3つのブローカーに関連付けられています。内部的に、クラスターはすべての要求をブローカー2のメインキューに送信します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
今度はブローカー3を失います。彼は他のブローカーが落ちたことを確認し、ミラーをマスターに移動します。これは論理的な分離です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/u_/l8/af/u_l8af-qqcyv4ldqdgwrn4t22ei.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 19.論理的な分離（スプリットブレイン）。レコードは2つの主要な行に分かれ、2つのコピーは分岐します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接続は復元されますが、論理的な分離は残ります。</font><font style="vertical-align: inherit;">管理者は、負けた側を手動で選択する必要があります。</font><font style="vertical-align: inherit;">次の場合、管理者はブローカー3を再起動します。管理者が送信できなかったメッセージはすべて失われます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_o/a9/ft/_oa9ftbuvl6dwnewtgfkrhkyva4.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">20.管理者がブローカー3を切断します</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/ni/y_/xq/niy_xqsgzuvf5ktcta35z98zzxs.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">21.管理者はブローカー3を起動し、クラスターに参加して、そこに残っていたすべてのメッセージを失います。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接続の切断中および切断後、クラスターとこのキューは読み取りと書き込みに使用できました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動修復モード</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分割して再接続した後、クラスター自体が自動的に負けた側を選択することを除いて、無視モードと同様に機能します。</font><font style="vertical-align: inherit;">失われた側は空のクラスターに戻り、キューはその側にのみ送信されたすべてのメッセージを失います。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイノリティモードの一時停止</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
論理的な分離を許可したくない場合、唯一の選択肢は、クラスターのパーティション化後の小さい側での読み取りと書き込みを拒否することです。ブローカーは自分が小さい方にいることを確認すると、一時停止します。つまり、既存の接続をすべて閉じ、新しい接続を拒否します。 1秒に1回、再接続をチェックします。接続が復元されると、作業が再開され、クラスターに参加します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xl/cc/af/xlccafaylyx2nrsz5scaafo1h6u.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 22. 3つの発行元が3つのブローカーに関連付けられています。内部的には、クラスターはすべての要求をブローカー2のメインキューに転送します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
次に、ブローカー1と2はブローカー3から分離されます。ブローカー3はミラーをマスターに上げる代わりに、一時停止してアクセスできなくなります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8h/0_/hc/8h0_hc8vj99u6zaht7cgymlckve.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 23.ブローカー3は一時停止し、すべてのクライアントを切断し、接続要求を拒否します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
接続が復元されると、クラスターに戻ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインラインがブローカー3にある別の例を見てみましょう</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rs/0s/if/rs0siffyxwpdc8imasvfvkapykw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 24.ブローカー3のメインライン。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
その後、接続の同じ損失が発生します。ブローカー3は小さい方なので一時停止します。反対側では、ノードはブローカー3が落ちるのを見るので、ブローカー1と2からの古いミラーがマスターにアップグレードされます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ba/o3/gr/bao3gr7y31x5ljbbpkqkretaaty.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 25.ブローカー3が利用できない場合のブローカー2への</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
接続</font><i><font style="vertical-align: inherit;">。</font></i><font style="vertical-align: inherit;">接続が回復すると、ブローカー3がクラスターに参加します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3z/rp/3k/3zrp3knvfoew7m25bg6bg4dlhju.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 26.クラスターは通常の動作に戻りました。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、我々は一貫性を得ていることを理解することが重要であるが、我々はまた、アクセシビリティを得ることができ</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、我々があれば</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成功した部分のほとんどにクライアントを転送します。</font><font style="vertical-align: inherit;">ほとんどの場合、個人的にはマイノリティの一時停止モードを選択しますが、それは実際には特定のケースに依存します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクセシビリティを確保するには、クライアントがサイトに正常に接続できるようにすることが重要です。</font><font style="vertical-align: inherit;">私たちのオプションを検討してください。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お客様の接続</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接続が失われた後、クライアントをクラスターの主要部分または稼働中のノード（1つのノードで障害が発生した後）に送信する方法については、いくつかのオプションがあります。まず、特定のキューが特定のホストでホストされているが、ルーティングとポリシーはすべてのホストで複製されていることを思い出してください。クライアントは任意のノードに接続でき、内部ルーティングは必要に応じてそれらを指示します。ただし、ノードが一時停止されると接続を拒否するため、クライアントは別のノードに接続する必要があります。ノードが落ちた場合、彼はほとんど何もできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのオプション：</font></font><br>
<br>
<ul>
<li>       ,     ,         .      ,        ,        (  ).         ,    .<br>
</li>
<li>        /   ,    .    ,        ,     .<br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各クライアントにすべてのノードのリストを提供し、クライアントは接続時にそれらの1つをランダムに選択します。</font><font style="vertical-align: inherit;">接続中にエラーが発生した場合、接続するまでリストの次のノードに移動します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DNSを使用して、ドロップまたは一時停止したホストからトラフィックを削除します。</font><font style="vertical-align: inherit;">これは、小さなTTLを使用して行われます。</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RabbitMQクラスタリングには、長所と短所があります。</font><font style="vertical-align: inherit;">最も深刻な欠点は次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスタに参加すると、ノードはデータを破棄します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期をブロックすると、キューにアクセスできなくなります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての困難な決定は、これら2つのアーキテクチャー機能から生じます。</font><font style="vertical-align: inherit;">RabbitMQがクラスターの再結合中にデータを保存できる場合、同期はより高速になります。</font><font style="vertical-align: inherit;">ノンブロッキング同期が可能であれば、大きなキューをより適切にサポートできます。</font><font style="vertical-align: inherit;">これら2つの問題を解決すると、フォールトトレラントで可用性の高いメッセージングテクノロジとしてのRabbitMQのパフォーマンスが大幅に向上します。</font><font style="vertical-align: inherit;">次の状況では、あえてクラスタリングを備えたRabbitMQを推奨しません。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全でないネットワーク。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全でないストレージ。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に長い行。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高可用性の設定については、次の点を考慮してください。</font></font><br>
<br>
<ul>
<li><code>ha-promote-on-failure=always</code><br>
</li>
<li><code>ha-sync-mode=manual</code><br>
</li>
<li><code>cluster_partition_handling=ignore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（または</font></font><code>autoheal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">持続メッセージ</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部のノードに障害が発生したときにクライアントがアクティブノードに接続するようにします</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一貫性（データセキュリティ）のために、次の設定を検討してください。</font></font><br>
<br>
<ul>
<li>Publisher Confirms  Manual Acknowledgements   <br>
</li>
<li><code>ha-promote-on-failure=when-synced</code>,              !   <code>=always</code>.<br>
</li>
<li><code>ha-sync-mode=automatic</code> (        ;  , ,       )<br>
</li>
<li> Pause Minority<br>
</li>
<li> </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォールトトレランスと高可用性のすべての問題についてはまだ検討していません。</font><font style="vertical-align: inherit;">たとえば、管理手順（ローリング更新など）を安全に実行する方法。</font><font style="vertical-align: inherit;">フェデレーションとShovelプラグインについても話し合う必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでも何かを見逃した場合は、お知らせください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、</font><font style="vertical-align: inherit;">DockerとBlockadeを使用してRabbitMQクラスターをポグロミングし、この記事で説明するメッセージ損失のシナリオのいくつかを確認した</font><font style="vertical-align: inherit;">私の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投稿</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も参照</font><font style="vertical-align: inherit;">してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シリーズの以前の記事：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1番</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-habr.com/ru/company/itsumma/blog/416629</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
2番</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-habr.com/ru/company/itsumma/blog/418389</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
3番</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-habr.com/company/itsumma/blog / 437446</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja471840/index.html">面接に行く理由</a></li>
<li><a href="../ja471844/index.html">カザフスタンのEPAM INSIDERを訪れる5つの理由</a></li>
<li><a href="../ja471852/index.html">OpenStreetMap No. 481の世界からのお知らせ（10/01/2019-07/10/2019）</a></li>
<li><a href="../ja471854/index.html">ヒートデス5G</a></li>
<li><a href="../ja471856/index.html">ハリーポッターのポーションパズルの42バージョンすべてを解決します</a></li>
<li><a href="../ja471860/index.html">ペグパーサー</a></li>
<li><a href="../ja471862/index.html">PEGパーサーの実装</a></li>
<li><a href="../ja471864/index.html">PEGパーサーの生成</a></li>
<li><a href="../ja471866/index.html">PEGパーサーの視覚化</a></li>
<li><a href="../ja471868/index.html">愛の遺伝学：一夫一婦の鳥のペアでの協力の基礎としての性間紛争</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>