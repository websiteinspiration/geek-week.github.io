<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔌 🤶🏼 🏘️ 私たちは人生で最も有用なコードを書きましたが、それをゴミ箱に捨てました。私たちと一緒に 💻 🕷️ 🧕🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私はパンチングバッグを地下室にぶら下げ、その上に典型的なマネージャーのストックフォトを貼り付け、スピーカーを中に詰め込んで、私を怒らせるフレーズを演奏しました。たとえば、ナシは言う：「ビジネスはあなたの完全なコードを必要としません。彼は問題を解決して、利益がコストをカバーするようにする必要があります...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>私たちは人生で最も有用なコードを書きましたが、それをゴミ箱に捨てました。私たちと一緒に</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454774/"><img src="https://habrastorage.org/webt/va/e3/mo/vae3moqi-aj-wga-1pj1rqdujdo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はパンチングバッグを地下室にぶら下げ、その上に典型的なマネージャーのストックフォトを貼り付け、スピーカーを中に詰め込んで、私を怒らせるフレーズを演奏しました。たとえば、ナシは言う：「ビジネスはあなたの完全なコードを必要としません。彼は問題を解決して、利益がコストをカバーするようにする必要があります。これにgovnokodが必要な場合は、govnokodが必要になります。そして、私は寄り添い始めています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近、私はナシに「型は難しくて不必要です」というメモを追加しました。この瞬間、強く叩いて手が折れそうになります。私は十分だからです。数か月前、私は自分のキャリアの中で最も悪質なケースの1つを経験しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
友人のAntokhaから、ある大企業のソリューションを支援するように依頼されました。</font><font style="vertical-align: inherit;">私は同意し、私たちは企業の不条理、砕け散る、理解できない同僚とのあらゆる種類の不正との戦争の底なしの深淵に突入しました。</font><font style="vertical-align: inherit;">何も言えないので、タイプについて話し、そのようなゴミが誰にも繰り返されないようにします。</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-（アントハ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rcanedu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は内部プラットフォームツールの開発を委託されました。これは、ソフトウェアエンティティをオブジェクト指向モデルの形式で表現するためのライブラリであり、APIサービスとの統一的な作業のためのものです。つまり、ソースからディスプレイに、またはその逆に移動するデータを操作するためのツールです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようにして、膨大な量のフォーマット、変換、計算、変換が行われます。巨大な構造、複雑な階層、すべてとあらゆるものとの数多くのつながり。そのようなネットワークでは、迷子になるのは非常に簡単です。データの一部が表示され、そのデータで何ができるか、何ができないかがわかりません。それを理解するために多くの時間を費やしてください。これは非常に中毒性があります。タイプの適切な説明のみが問題を解決します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くのソリューションでは適切なタイピングが欠落しているため、実行時とコンパイル時に同じプログラムの動作を実現することがより困難になります。タイプはすべてが同じであり、実行中にも発生するという完全な信頼を与える必要があります。テストでも同じことができます。両方に依存するのが最善です。しかし、タイプとテストのどちらかを選択すると、タイプの方がはるかに信頼性が高く、安価になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フロントを作成する場合、ユーザーとバックエンドの2つの問題の原因があります。すべてがユーザーにとってシンプルです。ユーザーI / Oから抽象化された多くの便利なライブラリとフレームワークがあります（反応、角度、Vueなど）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックエンドに関連して別のストーリーがあります。その種は数多く、その実現は闇です。データを記述するための標準的なアプローチを1つ定義することはできません。このため、「データ構造の正規化」のような松葉杖が発明され、すべての入力データが厳密な構造に削減され、何かがうまくいかない場合、例外または異常な操作が始まります。これにより、開発のスピードが上がり、簡素化されますが、実際には、多くのドキュメント、UML図、機能の説明が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フロントエンドが成熟したため、クライアントとサーバーのパーツの相互作用にアーキテクチャ上の問題が発生しました。バックエンドの上だけのレイアウトではなく、本格的なビジネスになりました。以前は、サーバー側の開発者のみがクライアントとサーバーの相互作用を要求していました。今、表と裏は交渉と緊密な連携を余儀なくされています。 APIデータソースサービスとの連携を構築し、データの真実性の損失を回避し、同時にさらなる変換を簡素化できるツールが必要です。この問題は、コミュニティ全体で対処する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-（フィル）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたがバックエンドであるならば、あなたはアプリケーションのための多くの大人のソリューションとデータモデリングの実践を持っています。たとえば、C＃では、データモデルクラスを使用します。 EntityFrameworkを取得すると、モデルをコーティングするための属性が提供されます。基地に到達する方法をリブに伝えます。次に、このデータを操作するためにそのインターフェースを使用します。これはORMと呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フロントエンドでは、最善の方法を決定しませんでした-私たちは検索して、とんでもない記事を書いて、それからすべてを反駁し、最初からやり直しても、単一の決定には至りません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-（アントハ）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前に書いたものはすべて、1つの大きな問題を抱えていました。ライブラリが最初から開発されるたび、および1つのタイプのクライアント/サーバー相互作用のためにシャープ化されるたび。これはすべて、適切なタイピングがないために起こります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静的型付けがなければ、APIやドメイン式を操作するためのユニバーサルライブラリを想像するのは難しいと思います。それは多くの反射を持ち、膨大な量のドキュメントを含み、1つまたは別のフォームのプラクティスを示すさまざまなアプリケーションに囲まれます。これは単純化ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この種の優れた汎用ツールは、すべてのスライスのデータの完全な図を提供する必要があります。これにより、常にこのデータを処理する方法と、それが必要な理由を正確に把握できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-（フィル）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各エンティティの詳細な説明と管理を可能にし、REST APIやjson-rpcからgraphQLやNQLまで、さまざまなインターフェースを持つさまざまなリソースからこのエンティティのデータを取得できるライブラリが必要です。これにより、成長するコードのベースと構造を厳密かつ順序どおりに保つことができます。シンプルで直感的に使用できます。エンティティの状態の完全かつ正確な説明をいつでも提供します。ユーザーのモジュールをできるだけデータ層から抽象化したいと考えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、既存のものを見ました。何も気に入らなかった。何らかの理由で、データを操作するためのすべてのライブラリは、jsで作成されるか、outの束で作成されます。これらはすべてを台無しにします。彼らは、そのようなライブラリはあまり役に立たない、データのタイプをナビゲートできない、接続を表現できないと言って、開発者に目を向けません。異なるタイプの複数のAPIを使用したり、異種のAPIを使用したりすると、状況は悪化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのライブラリはすべて、タイプによって十分に保護されていませんでした。したがって、彼らは解決するよりも多くの問題を作成します。それらを使用するのではなく、ドメイン固有の決定を行う方が簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、私たちは、タスクが立っていた狭義のlibの代わりに、はるかに強力で抽象的なものを作成することを決定しました-すべてに適しています。</font></font><br>
<br>
<hr><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-（アントハ）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よくあることですが、会社のリポジトリへのアクセスを許可するために、あらゆる種類のアクセスを待っていました。そして、これは数週間続くことがあります。私の場合、たった1つで済みました。現時点では、類似のライブラリを作成した経験に基づいて、タスクを分解し、期限を見積もりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、他の皆と同じように、私は非常に専門的な決定をしたことです。普遍的なツールでの作業は、追加の問題を伴いました。型システムは非常に複雑になり、私も他の誰もこれを設計した経験がありませんでした。さらに悪いことに、私の周りの開発者は、静的型付けについてまったく考えていませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私は正しいと思ったように行動し始めました。日刊紙で、私が何をしているのか、そしてその理由を話しましたが、原則として、誰も私を理解していませんでした。発生した問題に関するチームへの私の質問は常に答えられていません。まるで私がいないかのようでした。非常に複雑で理解できないことをする男。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここではjavaScriptがまったく機能しないことを理解しました。強力なタイピングモデル、javaScriptとの優れた相互作用、大規模なコミュニティと深刻なエコシステムを備えたPLが必要でした。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-（フィル）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私はアントハがtypeScriptの魅力を理解するのを長い間待っていました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-（アントハ）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、あなたを夢中にさせる多くの問題があります。タイピングがありますが、プログラムの実行とユーザーによる実行の間にはまだ完全な対応がありません。 Typescriptは最初は複雑に見えます。彼は我慢しなければならない。あなたはいつも何かのオブジェクトを取って投げたいと思っています。徐々に言語とその型システムを掘り下げていくと、興味深いことが起こり始めます。それは魔法になります。すべてを入力できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-（フィル）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちの人生で初めて、私たちは集まり、何かを始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のステップは、ユーザーがデータスキーマを記述することです。どのように見えるのでしょうか。このようなもの：</font></font><br>
<br>
<pre><code class="javascript">type CustomerSchema = { <font></font>
  id: number;<font></font>
  name: string;<font></font>
}<font></font>
const Customer = new Model&lt;CustomerSchema&gt;(‘Customer’);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは、カスタムを説明するデータスキームがあることを意味します。各顧客には、整数として表されるIDと文字列としての名前があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、このスキームに従ってモデルが作成され、ジェネリックによって送信されます。このアプローチの主な問題は、ジェネリックを使用してデータ型を決定し、そこにタイプスクリプト型を渡すことです。 typescriptの型はコンパイル後に消滅し、それらが必要になるため、これは実行できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このオプションをすぐに廃止したのは良いことです。スキーム自体は、ある意味で、タイプと価値の両方です。これを理解すると、プロパティを宣言するだけでなく、プロパティを使用することが必要になりました。それはすぐに私たちに起こりました。結局のところ、言語にはタイプと意味の両方があるようなものがあります。これらはコンストラクタです。これで、スキーマ宣言は次の形式を取得しました。</font></font><br>
<br>
<pre><code class="javascript"> /**<font></font>
   name: String<font></font>
   String -   js -: StringConstructor<font></font>
              <font></font>
        <font></font>
*/<font></font>
const customerSchema = Schema.create({<font></font>
  id: Number,<font></font>
  name: String,<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはすでに実行できます。ジェネリックもありますが、回路に供給されたオブジェクトから派生しています。そして最も重要なこととして、NumberとStringは実行時に存在します。しかし、問題もあります。ユーザーはここで必要なものをすべて提供できます。例えば：</font></font><br>
<br>
<pre><code class="javascript">const customerSchema = Schema.create({<font></font>
  id: 1,<font></font>
  name: 2,<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何も類型化しなかったからです。ランタイム例外を吐き出すように、 `Schema.create`コードを記述できます。あらゆる種類の `if（！（Property instanceof String））は新しいエラー（" read spec、asshole "）`をスローします。しかし、これは悪いアプローチです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つは、誰もスペックを読み取らないこと、もう1つは、このエラーがいつでも発生する可能性があることです。そして、libを作成すると、潜在的な災害の程度を予測することはできません。このランタイムの</font></font><abbr title="定義、キャスト、マップ、コンパイル、レイトンリー、オーバーヘッド、インスタンス、エンティティフレームワーク-このすべてのたわごとは、正式に正しく敬意をもって書くにはあまりにもあなたの責任です。"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">により、人が殺されたり、住宅地が氾濫したり、ユーザーに罰金に関する誤ったデータが提供されたりする可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを回避する明白な方法があります。ここでは、仕事をして、Schema.createが受け入れるデータのタイプについて説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのように：</font></font><br>
<br>
<pre><code class="javascript">//      <font></font>
type Map&lt;T&gt; = {<font></font>
  [key: string]: T | Map&lt;T&gt;; <font></font>
};<font></font>
<font></font>
/**<font></font>
      ,<font></font>
      ,<font></font>
     .<font></font>
*/<font></font>
type NumberType = Template&lt;NumberConstructor, number, 'number'&gt;;<font></font>
type StringType = Template&lt;StringConstructor, string, 'string'&gt;;<font></font>
type SymbolType = Template&lt;SymbolConstructor, symbol, 'symbol'&gt;;<font></font>
type BooleanType = Template&lt;BooleanConstructor, boolean, 'boolean'&gt;;<font></font>
type DateType = Template&lt;DateConstructor, Date, 'date'&gt;;<font></font>
<font></font>
interface ArrayType extends Array&lt;ExtractTypeValues&lt;Types&gt;&gt; {};<font></font>
<font></font>
type Types = {<font></font>
  Number: NumberType;<font></font>
  String: StringType;<font></font>
  Symbol: SymbolType;<font></font>
  Boolean: BooleanType;<font></font>
  Date: DateType;<font></font>
  Array: ArrayType;<font></font>
};<font></font>
//    <font></font>
type MapTypes= Map&lt;ApplyTemplate&lt;Types&gt;&gt;;<font></font>
//     - <font></font>
type Declaration = ExtractInputTypes&lt;MapTypes&gt;;<font></font>
interface Schema&lt;...&gt; {<font></font>
 //   ,   .<font></font>
 create: &lt;T extends Declaration&gt;(<font></font>
    declaration: ConvertInstanceTypesToConstructorTypes&lt;T&gt;<font></font>
  ) =&gt; Schema&lt;T&gt;;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでAntokhaはびっくりし、別々のタイプのスキームを持つ機能を追加し、タイプの結論を通常の形式で提供しました。</font><font style="vertical-align: inherit;">優れたコンビネーターのように、構造タイピングを最大限に使用して、数十回の変換を通じて、ユーザーはスキーマの属性のタイプをデザイナーではなくプリミティブで見ることができました。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この段落でさえ彼は自分で書いた、なぜなら私はそんなオタクの音節を自分に許しなかったからだ</font></font></i><br>
<br>
<pre><code class="javascript">type CustomerSchema = {<font></font>
  id: number;<font></font>
  name: string;<font></font>
};<font></font>
const customerSchema: CustomerSchema = Schema.create({<font></font>
  id: Number,<font></font>
  name: String,<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、コンストラクターをプリミティブに、またはその逆に自由にマップできます。</font><font style="vertical-align: inherit;">これは非常に単純なケースのようですが、追加された型の数に驚きました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、ユーザーは回路作成者を誤って使用する機会が1つだけあります。</font><font style="vertical-align: inherit;">彼はすべてを何にでもすることができます。</font><font style="vertical-align: inherit;">これは非常に興味深い瞬間です。これが機能することを100％知らない場合、他の誰かの自由を養うために、完全なmoronだけができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、そのような嫌いな人は存在し、codreviewでこのたわごとをスキップする他の嫌いな人がいる同じ世界に存在します。</font><font style="vertical-align: inherit;">したがって、これからも自分を守らなければなりません。</font><font style="vertical-align: inherit;">インスタンスチェックを `Schema.create`に追加します。</font><font style="vertical-align: inherit;">99％の人にとって、これは追加のパフォーマンスオーバーヘッドです;残りは少し早く問題を明らかにします。</font><font style="vertical-align: inherit;">こうするかと長い間考えてきました。</font><font style="vertical-align: inherit;">私は思う-そして彼らは行った！</font><font style="vertical-align: inherit;">しかし、私たちは専門家だからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
進め。</font><font style="vertical-align: inherit;">データスキームを説明するツールはありますが、それを変更するツールはありません。</font><font style="vertical-align: inherit;">ここに問題があります。</font><font style="vertical-align: inherit;">これで、次のようなスキームを使用できます。</font></font><br>
<br>
<pre><code class="javascript">const customerSchema = Schema.create({<font></font>
 id: Number,<font></font>
 name: String,<font></font>
});<font></font>
<font></font>
//   vscode  : id, name <font></font>
Schema.raw(customerSchema). <font></font>
<font></font>
//   <font></font>
//    .<font></font>
Schema.raw(customerSchema).id;<font></font>
<font></font>
//        .<font></font>
Schema.raw(customerSchema).neId;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だが。</font><font style="vertical-align: inherit;">回路オブジェクトの変更を使用して回路にプロパティを追加する機能をユーザーに提供する場合：</font></font><br>
<pre><code class="javascript">const customerSchema = Schema.create({<font></font>
 id: Number,<font></font>
 name: String,<font></font>
});<font></font>
<font></font>
if (true) {<font></font>
  customerSchema.add({gender: String});<font></font>
} <font></font>
<font></font>
//        ,<font></font>
//      gender.<font></font>
//  ,           <font></font>
// .<font></font>
Schema.raw(customerSchema).<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、スキームに変更可能なAPIがある場合、型チェックは機能せず、愚か者はコードを簡単に壊してしまいます。また、ユーザーが性別プロパティをスキームに割り当てることができる場合は、スキームにこのプロパティがあることを考慮してください（そうです、メソッド内でこの型を変更するタイムスクリプトに魔法があります！）。彼はこれをある条件の中で、またはコードベースの別の部分で行うこともできます。コンパイラーは、回路がこの特性を持っている時点を正確に知ることができず、必然的に実行時エラーが発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すぐにはわかりませんでしたが、驚きました。脳は私に時限爆弾を投げ、彼はビジョンを持っていると嘘をつきました。仕事はすでに終わっているので、出口を探す必要がありました。私たちはそれを免除で見つけました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような：</font></font><br>
<br>
<pre><code class="javascript">const customerSchema = Schema.create({<font></font>
 id: Number,<font></font>
 name: String,<font></font>
});<font></font>
<font></font>
// customerSchema.add({gender: String});<font></font>
//      ,    .<font></font>
//  :<font></font>
const customerWithGenderSchema = customerSchema.add({gender: String});<font></font>
<font></font>
//   .<font></font>
// :<font></font>
Schema.raw(customerWithGenderSchema).<font></font>
//  id, name, gender<font></font>
<font></font>
// <font></font>
Schema.raw(customerSchema).<font></font>
//  id, name<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、コンパイル中に回路の状態を正確に把握するために、不変インターフェースを使用します。</font><font style="vertical-align: inherit;">また、内部でどのように機能するかは関係ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回路を作成した後の型推論、および一般的に回路自体が必要である理由は次のとおりです。</font></font><br>
<br>
<pre><code class="javascript">const customerSchema = Schema.create({<font></font>
 id: Number,<font></font>
 name: String,<font></font>
});<font></font>
<font></font>
const repository = RepositoryManager.create(openApiDriver, { <font></font>
 // config<font></font>
});<font></font>
const Customer = Model.create(repository, customerSchema);<font></font>
<font></font>
Customer.getAll().first().<font></font>
//   ide  ,       id, name  gender.<font></font>
//    ,   <font></font>
Customer.getAll().first().age;<font></font>
//   .    ,     , <font></font>
//   .<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スキーマタイプからgetAllタイプを派生させます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのように：</font></font><br>
<br>
<pre><code class="javascript">type MapSchemaToDriver&lt;S extends Schema, D extends Driver&gt; = <font></font>
  InferSchemaDeclaration&lt;S&gt; extends SchemaDeclaration<font></font>
    ? InferDriverMethods&lt;D&gt; extends DriverTemplate&lt;IMRReader, IMRWriter&gt;<font></font>
      ? Repository&lt;InferSchemaDeclaration&lt;S&gt;, InferDriverMethods&lt;D&gt;&gt;<font></font>
      : never<font></font>
    : never;<font></font>
<font></font>
interface Repository&lt;D extends Driver, S extends Schema&gt; {<font></font>
  get: &lt;T extends DSLTerm&gt;(dsl: ParseDSLTerm&lt;T&gt;) =&gt; MapSchemaToDriver&lt;S, D&gt; extends RepositoryTemplate ? ApplyDSLTerm&lt;MapSchemaToDriver&lt;S, D&gt;, T&gt; : Error&lt;’type’, ‘Type error’&gt;;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、タイムスクリプトは次のことを実行できます</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。そのような。コンパイル時にこれを計算してください。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは魔法です。プロキシとデコレータの実際のコンベヤ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データを読み取るメソッドを提供し、コンパイル時に型チェックを使用してこのデータへのアクセスをユーザーに提供するために、「リポジトリ」のタイプを教えました。そして、スキームのタイプに基づいてタイプを推定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらにクーラー。このスキームは実行時にも存在するため、実行時にデータチェックを生成できます。男は書きます：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「ねえ、私は* blah blah blah.com *にリポジトリを持っています。何千もの顧客レコードがあります。</font><font style="vertical-align: inherit;">すべてのクライアントにはIDと名前があると思います。</font><font style="vertical-align: inherit;">そこから最初の100クライアントを取得し、データが有効であれば、画面に表示します。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんど理想的です。</font></font><br>
<br>
<hr><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.5</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードを記述せず、タイプを記述しただけで、これらのパターンを使用して、実用的なソリューションを簡単に作成できます。</font><font style="vertical-align: inherit;">ビジネスのタイプ別にデザインします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カスタムメーター、注文、宇宙船の飛行統計など、ユーザーがどのようなデータを持っているかはわかりません。</font><font style="vertical-align: inherit;">libにあらゆるデータを操作するように教えることができました。</font><font style="vertical-align: inherit;">ユーザーはドメインを簡単に説明し、ライブラリはすべてが正しいことを確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
頭はこのソリューションでどれだけソリューションを改善できるかについて回ります。</font><font style="vertical-align: inherit;">スキームに基づいてデータを自動的に検証し、ユーザーにすべての可能な例外の処理を強制し、ユーザーが特定のデータソースで機能するモジュールを作成できるタイプをライブラリに提供できます。</font><font style="vertical-align: inherit;">ユーザーが受信したいデータの種類がわかっているため、ユーザーがリクエストで有効なセレクターのみを渡すことを許可できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちのライブラリはODMでもORMでもありません-IMR（同形モデル表現）です </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より抽象的には、さまざまなリポジトリ、1つ以上のサービスのさまざまなAPIで動作します。彼女はデータがどのように構造化されているかを気にしません。アナログとは異なり、select-whereを自分で実装することはなく、ユーザーにこの機会を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も重要なのは、ユーザーがアプリケーションの各ブランチのデータの状態を正確に把握できるシステムを作成していることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは基本的にです。バックエンドでは、データレイヤーから抽象化する必要はありません。バックエンドはデータ層です。クライアント側の複雑なシステムでは、ユーザーを除くすべてのサードパーティのデータソースに単一のファサードが必要です。理想的には、フロントエンドアプリケーションを取得して、完全に異なる構造のAPIに転送し、数行のコードを変更すれば、すべてが機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、私たちの会社（本当に便利なものになると、無制限の開発予算を持つ巨大な会社）が私たちの足にキスをし、それを私たちの手に運び、すべてのさらなる作業のためにカルテブランチを与えると確信していました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どんなに。</font></font><br>
<br>
<hr><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">３</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-（アントハ）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちはlibを続けましたが、締め切りを破ることができると感じました。したがって、全員を納得させるオプションをまとめる時間を確保するために、ハードプロセスを行うことにしました。本当に昼も夜も働きます。私は8時間を費やして家に帰り、このプロジェクトで真夜中を殺していたフィルに連絡を取りました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、リポジトリに何かをアップロードしたとき、「そこにはどんな種類の複合型があるのか​​」誰も理解できませんでした。私はデイリーに何度も説明しましたが、完全に無視されていました。正直さに対する熱意と信念は非常に力強いものであり、すぐに結果が誤解を打破するだろうとほぼ確信していました。最後に、リードはレポを調べ、そこでタイプのみが表示されたとき、彼は私が性交をしなかったと考え</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リードは締め切りを迫っています。彼はビジネスのために時間が宣言されているので、何も動かすことができないと言いました。しかし、私は人々がここでどのようにそして何に取り組んでいるのかを見ました、誰も締め切りを気にしないことを完全に知っていました。時々、最小の特徴が何年もの間切断されます。リードは単に強いタイピングのアイデアを受け入れませんでした。彼には型がないので、型には慣れていません。業界、方向性、あら​​ゆるものが変化しており、この非典型的なハッシュのすべてが問題の種を生み出しており、過去のものであるに違いありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-（フィル）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アントハは、問題を解決する方法をチームに伝えるビジョンを持つスーパーマイナーとして雇われました。それで彼らは社会保障面接で彼に話しました。そして今、彼らは彼らが言うことを時間を削減するべきであるAjail兵士を雇うようにそれを上げました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らは異常な解決策を見つけ、それを検討する代わりにすぐに拒否しました。彼らは習慣に逆らうことを望まなかった。それは明らかに技術的な決定ではなく、政治的な決定でした。</font></font><br>
 <br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-（アントハ）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その結果、紛争が発生し、怒りの手紙を交換した。今まで何もしていないと非難され、いくつかのサブタスクを完了するように求められました。終わって出発しました。私は数日間休憩し、リポジトリとローカルストレージからすべてのライブラリソースを完全に削除しました。単純な人間の感情、葛藤、怠惰、傲慢さ、そしてエンジニアリングの発展を永遠に害する他のナンセンスのために、何週間も眠れない夜がパイプに入りました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてその瞬間、私はなぜ開発にソフトスキルが本当に必要なのかを理解しました。</font><font style="vertical-align: inherit;">猫になったり、みんなと友達になったりするためではなく、チームの心理的な快適さと陽気なチームビルディングのためではありません。</font><font style="vertical-align: inherit;">エンジニアリングソリューションを保護するには、ソフトスキルが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誤解、陰謀、ライバル、そしてあらゆる種類の秘密のゲームに対して無防備だからです。</font><font style="vertical-align: inherit;">良いことをするためには、人々に彼らの無実を納得させることができなければなりません。</font><font style="vertical-align: inherit;">そして、私は成功しませんでした。</font></font><br>
<br>
<hr><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-（フィル）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アントカがそれがすべて終わった方法を私に言ったとき-私はめちゃくちゃになりました。やりすぎ！何？！ろくでなしには1人ではなく2人の開発者がおり、私は多くの時間を費やしました、Antonは8時間働いて、それから私に電話して、再び働きました、そして私たちは一緒にこれらのすべてのODM / ORMと他のデータリレーのたわごとについて読んで深く防止しました間違い。私たちは何千人もの同僚が使用するツールを作成しました。要するに、私は決定の質についてのあらゆる主張を理解することができましたが、「あなたがしなかった何か、あなたたちを性交する」ことはできませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アントカがすべてを消したという事実は、私を完全に殺しました。このツールは単なる仕事よりも重要でした。彼らと、企業と、彼らの脂肪の提供と複雑な開発のための快適な環境と一緒にいじってください。そのようなlibが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、私たちはゼロから始め、タイプで終了し、最小限の作業で過敏なことをすることにしました。現在、私たちの予算はすぐに終わります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たくさんのタイプのプライベートリポジトリがありますが、実装はありません。結果として、次のようなものが得られます。</font></font><br>
<br>
<pre><code class="javascript">/*<font></font>
     .<font></font>
    — .<font></font>
       .<font></font>
     <font></font>
*/<font></font>
<font></font>
import { View } from '@view';<font></font>
import { Logger } from '@utils';<font></font>
<font></font>
//   —  ,    .<font></font>
//         .<font></font>
import { Robot } from '@domain/models';<font></font>
<font></font>
// ,       <font></font>
//   <font></font>
function foo() {<font></font>
 Robot.fetch({<font></font>
   location: {<font></font>
     area: 2,<font></font>
     free: true,<font></font>
     key: 'f49a6712', //    - compile-time checked<font></font>
   }<font></font>
 })<font></font>
 .then(View.Grid.display)<font></font>
 .catch(Logger.error);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラー処理戦略について話し合ったとき、アントハと私はほとんど殺し合いました。</font><font style="vertical-align: inherit;">私はモナドのために溺死した-彼はjs / tsの慣用句を約束した。</font><font style="vertical-align: inherit;">その結果、これとそれを行うことを決定し、これを構成レベルで管理しました。</font><font style="vertical-align: inherit;">つまり、別のファイルのどこかで、リクエストが失敗した場合の処理​​方法を決定したことがあり、ここで型システムはPromiseまたはResultモナドがあることを確実に認識します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、データスキーマレベルでエラー処理戦略を定義する機能も追加しました。</font><font style="vertical-align: inherit;">これにより、ユーザーはリクエストごとにこれらの手順を繰り返すことなく、1回のLogger.Errorを書き込むことができます。</font></font><br>
<br>
<pre><code class="javascript">/*<font></font>
   :<font></font>
       ,<font></font>
         -  .<font></font>
     - <font></font>
             .<font></font>
     :<font></font>
*/<font></font>
import { Schema, Model } from 'imr';<font></font>
import { Logger } from '@utils';<font></font>
import { View } from '@view';<font></font>
import { robotSchema } from '@domain/schemas';<font></font>
import { batteryStationService } from '@domain/infrastructure/services/batteryStation';<font></font>
import { Robot } from '@domain/models';<font></font>
import { batteryNode } from '../services/nodeNames';<font></font>
<font></font>
//       <font></font>
// ,       ,       ,<font></font>
//  ,        «»<font></font>
const robotSchemaWithBattery =<font></font>
  robotSchema<font></font>
    .add('battery', Schema.union('li-ion', 'silicon'))<font></font>
    .remove('speed');<font></font>
<font></font>
// ,       <font></font>
//     :<font></font>
function foo(nodeName) {<font></font>
<font></font>
 //   -:   -,      <font></font>
 if (nodeName === batteryNode) {<font></font>
   //   ,      <font></font>
   const CustomerRobot = Model.create(robotSchemaWithBattery, batteryStationService);<font></font>
<font></font>
   CustomerRobot<font></font>
     //        .<font></font>
     // , , 'li-notIon'  <font></font>
     .fetch({ filter: { battery: 'li-ion' } })<font></font>
    <font></font>
     //   .<font></font>
     //   ,      ,     ,   .<font></font>
     //  ,      ,<font></font>
     //      ,      .<font></font>
     .then(View.Grid.display)<font></font>
     .catch(Logger.error)<font></font>
<font></font>
 } else {<font></font>
   Robot<font></font>
     .fetch()<font></font>
     .then(View.Grid.display)<font></font>
     .catch(Logger.error)<font></font>
 }<font></font>
}<font></font>
</code></pre><br>
<hr><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-（フィル）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人生は、あなたがプログラミングで何かを発明したと思うたびに、あなたは真剣に誤解されていることを教えてくれました。この場合、私たちは何かを発明したとは思いませんが、私は、このように深いレベルでデータを操作するための抽象的なツールを類型化しようとした最初の人だったようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、それは私が私のために学んだことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好きでも嫌いでも、開発は応用です。私たちはビジネスの利益のために奉仕します。しかし、ライブラリコードを作成するとき、何十ものチームがソリューションを使用するとき、これは、ビジネスに必要なものを最もよく知っているまれなケースです。あなたはこれを一生勉強してきたからです。ライブラリはどうあるべきか、そのデザインとイデオロギーはビジネスの問題ではなく、技術的なものです。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次回は、説得力のある管理により多くの努力を費やします。私たちは、愚か者に対して最大限の保護を備えた高品質のソリューションを必要としています。</font><font style="vertical-align: inherit;">それ以外の場合は不可能です。</font><font style="vertical-align: inherit;">そうしないと、将来、1000倍以上のお金を失うことになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は大企業が大好きです-彼らは常に高品質のソリューションのための予算を持っています。</font><font style="vertical-align: inherit;">できることだけでなく、伝えることさえできればいいのです。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下も記事に取り組んだ： </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rcanedu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arttom</font></font></a> </blockquote><br>
<br>
<hr><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今と一緒に </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arttom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「We Are Doomed」</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポッドキャスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">やってい</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">記事にあるすべてのもの-開発、業界、生地、および社会保障について可能な限り直接。</font></font></blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja454756/index.html">サイトのパフォーマンスと広告設定の確認、卸売企業の顧客を引き付けるコスト</a></li>
<li><a href="../ja454758/index.html">Windows Defenderを安く陽気に回避する：Mimikatzを難読化する</a></li>
<li><a href="../ja454760/index.html">Intel Optane Memory M15-M10より高速</a></li>
<li><a href="../ja454766/index.html">HBO、思い出させてくれてありがとう...ベラルーシの薬剤師の「チェルノブイリ救急箱」</a></li>
<li><a href="../ja454770/index.html">Samsungスタートアップメンバーシップ-ロシアのスタートアップ向けの新しいプログラム</a></li>
<li><a href="../ja454776/index.html">フリーランスまたはオフィス？フリーランサーの反応</a></li>
<li><a href="../ja454778/index.html">本「機械学習：ビジネスのためのアルゴリズム」</a></li>
<li><a href="../ja454780/index.html">マイクロサービスについて知っていること</a></li>
<li><a href="../ja454788/index.html">慎重な投資家の武器：投資債券の公正価値を考慮する</a></li>
<li><a href="../ja454790/index.html">Javaネイティブイメージ：ユーザビリティチェック</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>