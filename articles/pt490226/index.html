<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëãüèæ üòû üëáüèæ Blending e Unity Terrain: como se livrar dos cruzamentos e parar de fazer seus olhos doerem üíë üìÄ üë©‚Äçüë©‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para ter um mundo realista dentro do jogo, √© necess√°rio levar em considera√ß√£o a intera√ß√£o de v√°rias formas de relevo entre si e com outros modelos. E ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Blending e Unity Terrain: como se livrar dos cruzamentos e parar de fazer seus olhos doerem</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/490226/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ter um mundo realista dentro do jogo, √© necess√°rio levar em considera√ß√£o a intera√ß√£o de v√°rias formas de relevo entre si e com outros modelos. </font><font style="vertical-align: inherit;">E se as linhas de interse√ß√£o vis√≠veis entre os modelos 3D prejudicarem a integridade da imagem, vale a pena considerar como elimin√°-las. </font><font style="vertical-align: inherit;">O caso mais comum dessas linhas, que pode ser familiar para muitos, √© a interse√ß√£o de pain√©is de part√≠culas com geometria opaca. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ja/va/g2/javag2i9gc9lhkwohebgbyklsjc.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro exemplo √© a composi√ß√£o natural perturbadora da interse√ß√£o de rochas e vegeta√ß√£o com a superf√≠cie da paisagem em cenas ao ar livre.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v0/k6/s9/v0k6s98hdon17qotuaryat0vogs.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m de v√°rios m√©todos de suaviza√ß√£o (SSAA, MSAA, CSAA, FXAA, NFAA, CMAA, DLAA, TAA, etc.), que mitigam a apar√™ncia desafiadora de tais linhas de interse√ß√£o, mas n√£o corrigem completamente a situa√ß√£o, existem t√©cnicas mais eficazes. </font><font style="vertical-align: inherit;">N√≥s os consideraremos.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mistura de profundidade</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Unity possui uma solu√ß√£o integrada para eliminar interse√ß√µes vis√≠veis entre part√≠culas transparentes e geometria opaca denominadas part√≠culas macias. </font><font style="vertical-align: inherit;">Os shaders que suportam esse efeito aumentam ainda mais a transpar√™ncia das part√≠culas, dependendo de qu√£o pequena √© a diferen√ßa entre a profundidade do fragmento de part√≠cula e a profundidade da geometria opaca. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mz/wx/9k/mzwx9kecz9hkjps0laijveek-54.png" alt="imagem"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O princ√≠pio de opera√ß√£o de part√≠culas macias</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Obviamente, para a opera√ß√£o correta de part√≠culas macias, √© necess√°rio um buffer de profundidade. </font><font style="vertical-align: inherit;">No caso de sombreamento diferido, o buffer de profundidade √© formado no est√°gio de renderiza√ß√£o de buffers de tela cheia e, levando em considera√ß√£o o MRT (M√∫ltiplos alvos de renderiza√ß√£o, n√£o a tomografia de resson√¢ncia magn√©tica), sua presen√ßa n√£o √© expressa em custos computacionais adicionais.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No caso de sombreamento direto e uso do Unity Legacy Pipeline, era necess√°rio um passe extra para renderizar a geometria opaca para o buffer de profundidade </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Essa passagem √© ativada atribuindo o valor apropriado √† propriedade Camera.depthTextureMode. </font><font style="vertical-align: inherit;">Esta propriedade n√£o est√° dispon√≠vel na janela do inspetor, mas est√° dispon√≠vel na API </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora voc√™ pode implementar sua pr√≥pria vers√£o do Scriptable Render Pipeline com sombreamento para frente, que com a ajuda do MRT pode renderizar simultaneamente o buffer de profundidade e o buffer de cores. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7z/-b/1l/7z-b1lg9zs8xbsywe6evbmanfiw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminando linhas de interse√ß√£o em shaders que suportam part√≠culas macias</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Em geral, n√£o h√° obst√°culos t√©cnicos ao uso do m√©todo de mistura de profundidade para eliminar interse√ß√µes vis√≠veis de modelos 3D com a paisagem:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ver c√≥digo</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Blending</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">depth</span> <span class="hljs-selector-tag">buffer</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendStart</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendEnd</span>;
<span class="hljs-selector-tag">UNITY_DECLARE_DEPTH_TEXTURE</span>(_<span class="hljs-selector-tag">CameraDepthTexture</span>);<font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
    // ...<font></font>
<font></font>
    half4 <span class="hljs-attribute">projPos </span>: TEXCOORD0;<font></font>
};<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
<font></font>
    // ...<font></font>
<font></font>
    o.projPos = ComputeScreenPos(o.pos);<font></font>
    COMPUTE_EYEDEPTH(o.projPos.z);<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">fixed4</span> <span class="hljs-selector-tag">frag</span>(<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">i</span>) : <span class="hljs-selector-tag">COLOR</span><font></font>
{     <font></font>
    fixed4 result = 0;<font></font>
      <font></font>
    // ... <font></font>
<font></font>
    float depth = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.projPos));<font></font>
    float sceneZ = LinearEyeDepth(depth);<font></font>
    float partZ = i.projPos.z;<font></font>
    float fade = saturate( sceneZ - partZ );<font></font>
    result.a = smoothstep( BlendStart, BlendEnd, fade );<font></font>
<font></font>
    // ... <font></font>
       <font></font>
    return result; <font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, essa abordagem tem v√°rias desvantagens. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira desvantagem est√° relacionada ao desempenho. A mistura de profundidade funciona no est√°gio de mistura de tubos de hardware, ou seja, imediatamente ap√≥s a rasteriza√ß√£o e c√°lculo do sombreador de fragmento. Nesse est√°gio, o resultado da execu√ß√£o do shader de fragmento √© misturado com o resultado registrado no buffer de sa√≠da </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] [4] [5], de</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> acordo com a f√≥rmula predefinida pelas chamadas √† API </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[6] [7] [8] [9]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa √© a parte menos progressiva de qualquer pipeline de hardware, no sentido de que funciona exatamente como seu antecessor, h√° vinte anos. A GPU l√™ o valor da mem√≥ria, mistura-o com o valor do shader de fragmento e grava-o novamente na mem√≥ria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tamb√©m h√° uma diferen√ßa em usar a mistura de profundidade para modelos 3D totalmente transparentes ou parcialmente transparentes. Transparente - por exemplo, outdoors de part√≠culas - mesmo sem se misturar em profundidade, toda a renderiza√ß√£o √© transparente. No caso de modelos 3D opacos, a transpar√™ncia real, tang√≠vel e vis√≠vel ao mesclar em profundidade ser√° dotada de apenas um n√∫mero muito pequeno de fragmentos, enquanto a grande maioria deles permanecer√° opaca. Mas o √∫ltimo n√£o significa que a mistura n√£o ser√° usada para sua renderiza√ß√£o - ela simplesmente funcionar√° ociosa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A segunda desvantagem est√° relacionada √† maneira como a cor da mistura √© selecionada. Em resumo, todos os fragmentos que s√£o misturados em um pixel espec√≠fico da tela ficam em um raio que emana da posi√ß√£o mundial da c√¢mera e passa pela posi√ß√£o mundial desse pixel da tela. Isso, por sua vez, significa que, com qualquer altera√ß√£o na posi√ß√£o ou orienta√ß√£o da c√¢mera, a paralaxe ser√° observada: fragmentos do modelo 3D localizado mais perto da c√¢mera se mover√£o mais rapidamente do que fragmentos da paisagem localizados mais longe da c√¢mera </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[10] [11]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Isso √© especialmente vis√≠vel quando visto de perto, com deslocamento lateral constante da c√¢mera. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hz/sc/78/hzsc78n3vvddbvvlgrb3hqkfwxc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paralaxe lateral ao mover a c√¢mera: fragmentos do modelo 3D s√£o deslocados para uma dist√¢ncia maior em compara√ß√£o com fragmentos da paisagem</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/5v/zf/wj/5vzfwjmabznaiprchenxb9eqy3q.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paralaxe lateral ao mover a c√¢mera: ao fixar a c√¢mera em um fragmento da paisagem, percebe-se a rapidez com que os fragmentos do modelo se</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
movem.Quando a c√¢mera √© girada, o paralaxe √© observado imediatamente ao longo de dois eixos das coordenadas da tela. No entanto, na din√¢mica isso √© menos evidente que o paralaxe lateral. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qs/ew/jn/qsewjnfucpdriai47zh9032fwcm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paralaxe azimutal quando a c√¢mera √© deslocada: √© mais dif√≠cil para o c√©rebro reconhecer o padr√£o de paralaxe quando os fragmentos s√£o deslocados ao longo de dois</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
eixos. A zona de mesclagem se torna quase invis√≠vel quando a dire√ß√£o da vis√£o √© perpendicular √† superf√≠cie normal da paisagem, mas o tamanho dessa zona aumenta rapidamente se voc√™ inclinar a c√¢mera para baixo.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hd/r8/gs/hdr8gs_ha63gspkr_eaxowjosna.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alterando a largura da zona de mesclagem enquanto inclina a c√¢mera</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
em profundidade A mesclagem pode ser uma boa op√ß√£o para eliminar as linhas de interse√ß√£o dos modelos 3D com a paisagem, se n√£o a abund√¢ncia de artefatos que a acompanham. </font><font style="vertical-align: inherit;">Este m√©todo √© mais adequado para efeitos de part√≠culas que n√£o s√£o est√°ticas e, como regra, n√£o cont√™m texturas altamente detalhadas; portanto, efeitos de paralaxe n√£o s√£o observados em seus casos.</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mistura do mapa de altura</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra op√ß√£o para implementar a mistura de paisagens √© usar um mapa de altura, ao qual o Unity fornece acesso atrav√©s da API TerrainData </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[12]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conhecendo a posi√ß√£o do objeto Terreno e as dimens√µes do terreno indicadas no TerrainData, e tendo um "mapa de altura" dispon√≠vel, √© poss√≠vel calcular a altura do terreno em qualquer ponto especificado nas coordenadas do mundo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ga/69/za/ga69zap3c3xnluhjfm68g4_roto.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par√¢metros de terreno necess√°rios para amostrar o mapa de altura</font></font></i><br>
<br>
<pre><code class="css hljs">// <span class="hljs-selector-tag">Setting</span> <span class="hljs-selector-tag">up</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">heightmap</span> <span class="hljs-selector-tag">and</span> <span class="hljs-selector-tag">uniforms</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">use</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">shaders</span>... <font></font>
<font></font>
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalTexture</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.TerrainHeightmap</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.terrainData</span><span class="hljs-selector-class">.heightmapTexture</span>);
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalVector</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.HeightmapScale</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.terrainData</span><span class="hljs-selector-class">.heightmapScale</span>);
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalVector</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.TerrainSize</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.terrainData</span><span class="hljs-selector-class">.size</span>);
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalVector</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.TerrainPos</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.transform</span><span class="hljs-selector-class">.position</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, agora, depois de calcular a altura da paisagem, voc√™ tamb√©m pode calcular as coordenadas uv no sombreador para provar o mapa das alturas da paisagem nas coordenadas mundiais.</font></font><br>
<br>
<pre><code class="css hljs">// <span class="hljs-selector-tag">Computes</span> <span class="hljs-selector-tag">UV</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">sampling</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">heightmap</span>... <font></font>
<font></font>
<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">TerrainUV</span>(<span class="hljs-selector-tag">float3</span> <span class="hljs-selector-tag">worldPos</span>)<font></font>
{<font></font>
    return (worldPos.xz - TerrainPos.xz) / TerrainSize.xz;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para poder usar o mesmo c√≥digo em shaders de fragmentos e v√©rtices, a fun√ß√£o tex2Dlod √© usada para amostragem. </font><font style="vertical-align: inherit;">Al√©m disso, o mapa de altura n√£o possui n√≠veis de mip, portanto, amostr√°-lo com a fun√ß√£o tex2D, que calcula automaticamente o n√≠vel de mip, √© basicamente sem sentido.</font></font><br>
<br>
<pre><code class="css hljs">// <span class="hljs-selector-tag">Returns</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">height</span> <span class="hljs-selector-tag">of</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">given</span> <span class="hljs-selector-tag">position</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">world</span> <span class="hljs-selector-tag">space</span>... <font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">TerrainHeight</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">terrainUV</span>)<font></font>
{<font></font>
    float heightmapSample = tex2Dlod(TerrainHeightmap, float4(terrainUV,0,0));<font></font>
    return TerrainPos.y + UnpackHeightmap(heightmapSample) * HeightmapScale.y * 2;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ pode tentar reproduzir a elimina√ß√£o de interse√ß√µes atrav√©s da transpar√™ncia sem usar um buffer de profundidade. </font><font style="vertical-align: inherit;">Isso n√£o resolve outros problemas associados a esse m√©todo, mas permite verificar a operacionalidade da mistura usando um mapa de altura.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ver c√≥digo</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Blending</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">heightmap</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendStart</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendEnd</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainHeightmap</span>; 
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">HeightmapScale</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainSize</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainPos</span>;        <font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
   // ...<font></font>
<font></font>
   float3 <span class="hljs-attribute">worldPos </span>: TEXCOORD0;<font></font>
   float2 <span class="hljs-attribute">heightMapUV </span>: TEXCOORD1;<font></font>
<font></font>
   // ...<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
   <font></font>
    // ...<font></font>
    <font></font>
    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<font></font>
    o.heightMapUV = TerrainUV(o.worldPos);<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">fixed4</span> <span class="hljs-selector-tag">frag</span>(<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">i</span>) : <span class="hljs-selector-tag">COLOR</span><font></font>
{<font></font>
    fixed4 result = 0;<font></font>
<font></font>
    // ... <font></font>
<font></font>
    half height = TerrainHeight(i.heightMapUV);<font></font>
    half deltaHeight = i.worldPos.y - height;<font></font>
    result.a = smoothstep( BlendStart, BlendEnd, deltaHeight );<font></font>
<font></font>
    // ... <font></font>
       <font></font>
    return result; <font></font>
}</code></pre><br>
</div></div><br>
<br>
<img src="https://habrastorage.org/webt/zl/fl/nz/zlflnzwmh3tl6z_dhlvxowot4he.png"><br>
<img src="https://habrastorage.org/webt/-k/qc/f8/-kqcf8fgcmkjj7kt3gxmfpz31zu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mistura de profundidade e eleva√ß√£o. </font><font style="vertical-align: inherit;">A largura da zona de mesclagem difere com os mesmos par√¢metros de sombreador.As</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ilustra√ß√µes usam par√¢metros de mesclagem id√™nticos para ambos os m√©todos. </font><font style="vertical-align: inherit;">A largura das zonas de mesclagem √© visualmente diferente, pois a mesclagem com um mapa de altura n√£o depende do √¢ngulo entre o olhar do observador e o normal da paisagem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A mesclagem com um mapa de altura √© pelo menos em um aspecto melhor do que a mesclagem em profundidade: ela corrige a depend√™ncia da mesclagem vis√≠vel a olho nu no √¢ngulo em que a c√¢mera olha a paisagem. </font><font style="vertical-align: inherit;">Infelizmente, o efeito de paralaxe ainda ser√° observado.</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paisagismo reconstru√ß√£o mistura</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para se livrar da paralaxe, voc√™ precisa misturar um fragmento do modelo 3D com um fragmento da paisagem verticalmente abaixo dele (a sele√ß√£o de cores para mixagem nesse caso n√£o depende da posi√ß√£o e orienta√ß√£o da c√¢mera). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/h8/en/8t/h8en8tgwnrmjvhnunm0wkgcr3cu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como corrigir a paralaxe: escolhendo um fragmento de paisagem para mesclagem</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Claro, estamos falando aqui mais sobre um fragmento de paisagem virtual. Dependendo da posi√ß√£o da c√¢mera, √© poss√≠vel uma situa√ß√£o em que um fragmento da paisagem, com o qual √© necess√°rio misturar um fragmento de um modelo 3D, nem caia no campo de vis√£o da c√¢mera. Existe um problema semelhante na renderiza√ß√£o de reflex√µes locais no espa√ßo da tela (SSLR). Consiste no fato de que √© imposs√≠vel renderizar o reflexo de um fragmento que n√£o est√° na tela </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[13]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No caso da paisagem, a cor do fragmento virtual pode ser reconstru√≠da com alta precis√£o usando texturas auxiliares fornecidas pela API do Unity: mapa normal </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[14]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mapa de luz </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[15]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , texturas ponderadas para camadas de mesclagem </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[16]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e texturas inclu√≠das em composi√ß√£o das camadas </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[17]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ff/hu/zr/ffhuzriatn-pfjxf-nendtckscm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reconstru√ß√£o de um fragmento da paisagem</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Todas as texturas que comp√µem a paisagem s√£o amostradas de acordo com a mesma UV do mapa de altura. </font><font style="vertical-align: inherit;">No caso de camadas, as coordenadas para amostragem s√£o ajustadas pelos par√¢metros de lado a lado especificados para uma camada espec√≠fica </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[18] [19]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ver c√≥digo</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Blending</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">reconstructed</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">fragments</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendStart</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendEnd</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainHeightmapTexture</span>;
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainNormalTexture</span>;
<span class="hljs-selector-tag">sampler2D</span> <span class="hljs-selector-tag">TerrainAlphaMap</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">HeightmapScale</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainSize</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainPos</span>;
<span class="hljs-selector-tag">Float4</span> <span class="hljs-selector-tag">TerrainLightmap_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap0</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap0</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap0_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap1</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap1</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap1_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap2</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap2</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap2_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap3</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap3</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap3_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
   // ...<font></font>
<font></font>
   float3 <span class="hljs-attribute">worldPos </span>: TEXCOORD0;<font></font>
   float2 <span class="hljs-attribute">heightMapUV </span>: TEXCOORD1;<font></font>
#if defined(LIGHTMAP_ON)<font></font>
   float2 <span class="hljs-attribute">modelLightMapUV </span>: TEXCOORD2;<font></font>
   float2 <span class="hljs-attribute">terrainLightMapUV </span>: TEXCOORD3;<font></font>
#endif<font></font>
<font></font>
   // ...<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
   <font></font>
    // ...<font></font>
    <font></font>
    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<font></font>
    o.heightMapUV = TerrainUV(o.worldPos);<font></font>
<font></font>
#if defined(LIGHTMAP_ON)<font></font>
    o.modelLightMapUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;<font></font>
    o.terrainLightMapUV = o.heightMapUV * TerrainLightmap_ST.xy + TerrainLightmap_ST.zw;<font></font>
#endif<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}<font></font>
<span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">TerrainNormal</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">terrainUV</span>)<font></font>
{<font></font>
    return tex2Dlod( TerrainNormalTexture, float4(terrainUV,0,0) ).xyz * 2.0 - 1.0;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv0</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv1</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv2</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv3</span>, <span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">control</span>)<font></font>
{<font></font>
    half4 splat0 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap0, TerrainSplatMap0, uv0);<font></font>
    half4 splat1 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap1, TerrainSplatMap1, uv1);<font></font>
    half4 splat2 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap2, TerrainSplatMap2, uv2);<font></font>
    half4 splat3 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap3, TerrainSplatMap3, uv3);         <font></font>
    half4 result = splat0 * control.r + <font></font>
                   splat1 * control.g + <font></font>
                   splat2 * control.b + <font></font>
                   splat3 * control.a;<font></font>
    return result;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">TerrainNormalMap</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv0</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv1</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv2</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv3</span>, <span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">control</span>)<font></font>
{<font></font>
    half4 n0 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap0, TerrainSplatMap0, uv0);<font></font>
    half4 n1 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap1, TerrainSplatMap1, uv1);<font></font>
    half4 n2 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap2, TerrainSplatMap2, uv2);<font></font>
    half4 n3 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap3, TerrainSplatMap3, uv3);<font></font>
    half3 result = UnpackNormalWithScale(n0, 1.0) * control.r +<font></font>
                   UnpackNormalWithScale(n1, 1.0) * control.g +<font></font>
                   UnpackNormalWithScale(n2, 1.0) * control.b +<font></font>
                   UnpackNormalWithScale(n3, 1.0) * control.a;<font></font>
    result.z += 1e-5;<font></font>
    return result;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">TerrainLightmap</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv</span>, <span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">normal</span>)<font></font>
{<font></font>
#if defined(LIGHTMAP_ON)<font></font>
#if defined(DIRLIGHTMAP_COMBINED)<font></font>
    half4 lm = UNITY_SAMPLE_TEX2D(unity_Lightmap, uv);<font></font>
    half4 lmd = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, uv);<font></font>
    half3 result = DecodeLightmapRGBM(lm, unity_Lightmap_HDR);<font></font>
    result = DecodeDirectionalLightmap(result, lmd, normal);<font></font>
#else<font></font>
    half4 lm = UNITY_SAMPLE_TEX2D(unity_Lightmap, uv);<font></font>
    half3 result = DecodeLightmapRGBM(lm, unity_Lightmap_HDR);<font></font>
#endif                <font></font>
#else<font></font>
    half3 result = UNITY_LIGHTMODEL_AMBIENT.rgb;<font></font>
#endif<font></font>
    return result;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">fixed4</span> <span class="hljs-selector-tag">frag</span>(<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">i</span>) : <span class="hljs-selector-tag">COLOR</span><font></font>
{<font></font>
    fixed4 result = 0;<font></font>
<font></font>
    // ...<font></font>
<font></font>
    // compute model color and put it to the result<font></font>
<font></font>
    // ... <font></font>
<font></font>
    // reconstruction of terrain fragment<font></font>
<font></font>
    float2 splatUV0 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap0);<font></font>
    float2 splatUV1 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap1);<font></font>
    float2 splatUV2 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap2);<font></font>
    float2 splatUV3 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap3);<font></font>
<font></font>
    half4 control = tex2D(_TerrainAlphaMap, i.heightMapUV);<font></font>
    half4 terrainColor = TerrainSplatMap(splatUV0, splatUV1, splatUV2, splatUV3, control);<font></font>
<font></font>
    half3 terrainSurfaceNormal = TerrainNormal(i.heightMapUV);<font></font>
    half3 terrainSurfaceTangent = cross(terrainSurfaceNormal, float3(0,0,1));<font></font>
    half3 terrainSurfaceBitangent = cross(terrainSurfaceTangent, terrainSurfaceNormal);<font></font>
<font></font>
    half3 terrainNormal = TerrainNormalMap(splatUV0, splatUV1, splatUV2, splatUV3, control);<font></font>
    terrainNormal = terrainNormal.x * terrainSurfaceTangent + <font></font>
                    terrainNormal.y * terrainSurfaceBitangent + <font></font>
                    terrainNormal.z * terrainSurfaceNormal;<font></font>
    <font></font>
    half3 terrainLightmapColor = TerrainLightmap(i.heightMapUV, terrainNormal);<font></font>
    terrainColor *= terrainLightmapColor;<font></font>
<font></font>
    // blend model color &amp; terrain color<font></font>
<font></font>
    half height = TerrainHeight(i.heightMapUV);<font></font>
    half deltaHeight = i.worldPos.y - height;<font></font>
    half blendingWeight = smoothstep(BlendStart, BlendEnd, deltaHeight);<font></font>
<font></font>
    result.rgb = lerp(result.rgb, terrainColor, blendingFactor);<font></font>
       <font></font>
    return result; <font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, a mistura com a reconstru√ß√£o de fragmentos da paisagem corrige todos os problemas t√≠picos da mistura de profundidade e da mistura com um mapa de altura, incluindo paralaxe. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mf/pb/0s/mfpb0sfkav-hj-i5xhpll305drc.png"><br>
<img src="https://habrastorage.org/webt/ba/-z/x6/ba-zx6icghn-mnbreobdnekbjay.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paisagismo reconstru√ß√£o mistura</font></font></i><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desempenho de reconstru√ß√£o de fragmentos de terreno</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse momento, √© hora de perguntar: quanto vale esse tipo de compromisso? √Ä primeira vista, a intensidade de recursos da reconstru√ß√£o de fragmentos de paisagem excede em muito a intensidade de recursos da mistura alfa. Para a reconstru√ß√£o, √© necess√°rio executar com uma d√∫zia de opera√ß√µes adicionais de leitura da mem√≥ria. Para a mistura alfa, voc√™ s√≥ precisa de uma opera√ß√£o de leitura da mem√≥ria e uma opera√ß√£o de grava√ß√£o na mem√≥ria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na realidade, tudo depender√° dos recursos da plataforma de hardware. A reconstru√ß√£o de fragmentos √© suportada por compacta√ß√£o de textura, mapeamento mip, poder de processamento do n√∫cleo da GPU e otimiza√ß√µes espec√≠ficas de pipeline de hardware (rejei√ß√£o precoce da profundidade). E contra a mistura alfa, o fato j√° mencionado acima representar√° que √© a parte menos progressiva de qualquer GPU.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, sempre h√° espa√ßo para otimiza√ß√£o. </font><font style="vertical-align: inherit;">Por exemplo, no caso de reconstru√ß√£o da cor da paisagem, a necessidade dessa reconstru√ß√£o √© apenas para uma faixa estreita de fragmentos do modelo 3D localizado n√£o mais do que uma certa altura acima da superf√≠cie da paisagem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A ramifica√ß√£o din√¢mica em shaders pode fornecer resultados de desempenho pouco previs√≠veis, mas h√° dois pontos que devem ser levados em considera√ß√£o:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ignorar c√°lculos desnecess√°rios na ramifica√ß√£o de uma condi√ß√£o deve ser feito se essa condi√ß√£o n√£o for atendida em uma parte significativa dos casos.</font></font></li>
<li>       .   ,             ( ,  ),      GPU.    ‚Äï   (branch granularity),  , , ,          ,      .         ,    ,       .  ,   GPU  ,     ,       . ,      GPU,   ,  1 (PowerVR SGX).</li>
</ol><br>
<img src="https://habrastorage.org/webt/i7/8y/x9/i78yx9mn7egjmojcmxl67crz1kc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualiza√ß√£o de diferentes graus de coer√™ncia</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
No caso da reconstru√ß√£o de fragmentos, esses dois pontos s√£o levados em considera√ß√£o: a condi√ß√£o de ramifica√ß√£o na maioria dos casos permitir√° interromper a implementa√ß√£o de opera√ß√µes de uso intensivo de recursos para reconstruir a cor da paisagem, e essa condi√ß√£o √© coerente, com exce√ß√£o de um n√∫mero muito pequeno de fragmentos (na ilustra√ß√£o, s√£o fragmentos que se encontram na fronteira entre as zonas "vermelha" e "verde"). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/k3/do/ic/k3doicnobaqmuv82xbdfvq_kgas.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coer√™ncia da reconstru√ß√£o de fragmentos da paisagem</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Resta acrescentar alguns coment√°rios sobre esse m√©todo de mesclagem:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Unity fornece todas as texturas necess√°rias apenas se a paisagem tiver o modo Inst√¢ncia de desenho ativado </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[20]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; caso contr√°rio, o mapa normal n√£o estar√° dispon√≠vel, o que, por sua vez, n√£o permitir√° a reconstru√ß√£o correta da ilumina√ß√£o da paisagem para mesclagem.</font></font></li>
<li> Unity API    ,      (base map)         . -          .</li>
<li>         ,   API          (, Metal   16  ). </li>
<li>    3D-  ,     Terrain,     SRP.</li>
<li> 3D-      ,       3D-    . </li>
<li>,   ¬´¬ª ,     ¬´¬ª  .    ,  ¬´¬ª      ,             .  ¬´¬ª          .</li>
</ol><br>
<img src="https://habrastorage.org/webt/9z/yi/y-/9zyiy-6z47y7pxyonhwrl31zyoc.png"><br>
<i>    </i><br>
<br>
<br>
<h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao projetar modelos 3D, √© imposs√≠vel levar em considera√ß√£o a variedade de relevos do terreno com os quais esses modelos devem ser usados. Freq√ºentemente, os modelos 3D precisam ser profundamente "afundados" na paisagem ou girados para ocultar as partes salientes, ou vice-versa - para mostrar as ocultas que devem estar vis√≠veis. Os modelos de "aquecimento" limitam sua aplicabilidade e, se os modelos 3D forem renderizados antes do cen√°rio, isso tamb√©m causar√° um efeito de excesso. A curva, por sua vez, tamb√©m est√° longe de ser adequada para todos os modelos 3D (por exemplo, n√£o para casas e √°rvores). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ue/tg/8y/uetg8yx5ctdsn80stvnnezplgh4.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ocultar os elementos salientes do modelo 3D, ele deve ser "afogado" na paisagem</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Snapping √© um termo familiar aos usu√°rios de editores gr√°ficos. Essa √© uma fun√ß√£o que permite que os pontos de controle ‚Äúfiquem‚Äù nos n√≥s da grade espacial e, nos editores 3D, nas faces e superf√≠cies de outros objetos. Ajustar o mapa das alturas da paisagem no sombreador de v√©rtices pode simplificar bastante o design das cenas. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/4w/1t/xw/4w1txwi3vaczzpne7ewajozlymo.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modelo 3D sem encaixe. Modelo 3D com ajuste de v√©rtice. Modelo 3D com ajuste e mistura de v√©rtices. Modelo 3D com encaixe de v√©rtice, mistura e ilumina√ß√£o est√°tica</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A principal dificuldade na implementa√ß√£o do snap √© que voc√™ precisa descobrir quais v√©rtices do modelo 3D voc√™ precisa encaixar no mapa de altura e quais n√£o valem a pena. </font><font style="vertical-align: inherit;">Os v√©rtices cont√™m apenas informa√ß√µes sobre a natureza local da superf√≠cie (o que n√£o √© suficiente) e n√£o cont√™m informa√ß√µes sobre sua topologia (que √© necess√°ria). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como em outros casos de aplica√ß√£o, esse problema √© mais f√°cil de resolver no est√°gio de modelagem, implementando diretamente os par√¢metros necess√°rios nos v√©rtices. </font><font style="vertical-align: inherit;">Como par√¢metro, voc√™ deve escolher um atributo intuitivo - por exemplo, o fator de pondera√ß√£o para o snap (e n√£o a dist√¢ncia at√© a borda de uma superf√≠cie aberta, como gostar√≠amos de flexibilidade). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7b/gq/2b/7bgq2bdhdlr13qgeqpgcocvo0q8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codifica√ß√£o de pondera√ß√£o para encaixe</font></font></i><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ver c√≥digo</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Per-vertex</span> <span class="hljs-selector-tag">snapping</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">heightmap</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainHeightmapTexture</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">HeightmapScale</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainSize</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainPos</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
<font></font>
   // ...<font></font>
<font></font>
   float3 <span class="hljs-attribute">worldPos </span>: TEXCOORD0;<font></font>
   float2 <span class="hljs-attribute">heightMapUV </span>: TEXCOORD1;<font></font>
<font></font>
   // ...<font></font>
<font></font>
};<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
   <font></font>
    // ...<font></font>
    <font></font>
    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<font></font>
    o.heightMapUV = TerrainUV(o.worldPos);<font></font>
    float snappingWeight = v.color.r;                <font></font>
    half height = TerrainHeight( o.heightMapUV );                <font></font>
    o.worldPos.y = lerp( o.worldPos.y, height, snappingWeight );<font></font>
    o.pos = UnityWorldToClipPos( half4( o.worldPos, 1 ) );<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A aplicabilidade do snap ao v√©rtice √© limitada pela correspond√™ncia geral entre o terreno e a superf√≠cie do modelo 3D. </font><font style="vertical-align: inherit;">Para compensar suas diferen√ßas significativas, √© necess√°rio usar outros m√©todos que consomem mais recursos - por exemplo, modelos 3D com skins.</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclus√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A principal id√©ia que deve ser retirada do artigo: qualquer shader suficientemente complexo e potencialmente escal√°vel precisa de dados b√°sicos. </font><font style="vertical-align: inherit;">E a tarefa do desenvolvedor √© entender como o sistema gr√°fico pode ser operado: quais dados ele fornece, como eles podem ser combinados entre si e como us√°-los em shaders. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No caso geral, podemos concluir que a √∫nica op√ß√£o para superar a estrutura pela qual as possibilidades de efeitos gr√°ficos s√£o limitadas √© combinar os resultados de v√°rios shaders.</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refer√™ncias</font></font></h2><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ver links</font></font></b><div class="spoiler_text"><sup>[1]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.unity3d.com/Manual/SL-CameraDepthTexture.html</a><br>
<sup>[2]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.unity3d.com/ScriptReference/Camera-depthTextureMode.html</a><br>
<sup>[3]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.unity3d.com/ScriptReference/RenderTexture.html</a><br>
<sup>[4]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.khronos.org/opengl/wiki/Framebuffer_Object</a><br>
<sup>[5]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.microsoft.com/en-us/windows/win32/api/d3d11/nf-d3d11-id3d11device-createrendertargetview</a><br>
<sup>[6]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.unity3d.com/ScriptReference/Rendering.BlendMode.html</a><br>
<sup>[7]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.unity3d.com/ScriptReference/Rendering.BlendOp.html</a><br>
<sup>[8]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.khronos.org/opengl/wiki/Blending</a><br>
<sup>[9]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.microsoft.com/en-us/windows/win32/direct3d11/d3d10-graphics-programming-guide-blend-state</a><br>
<sup>[10]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">en.wikipedia.org/wiki/Parallax</a><br>
<sup>[11]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">en.wikipedia.org/wiki/Parallax_scrolling</a><br>
<sup>[12]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainData-heightmapTexture.html</a><br>
<sup>[13]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pdfs.semanticscholar.org/ce6c/fcafe3581a7e4d7184a9727cc504bdc6b295.pdf</a><br>
<sup>[14]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/Terrain-normalmapTexture.html</a><br>
<sup>[15]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/Terrain-lightmapIndex.html</a><br>
<sup>[16]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainData-alphamapTextures.html</a><br>
<sup>[17]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainData-terrainLayers.html</a><br>
<sup>[18]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainLayer-tileSize.html</a><br>
<sup>[19]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainLayer-tileOffset.html</a><br>
<sup>[20]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/Terrain-drawInstanced.html</a><br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt490204/index.html">Resumo dos eventos para recrutadores de RH e TI em mar√ßo de 2020</a></li>
<li><a href="../pt490208/index.html">Se√ß√£o de back-end no DUMP2020: brincadeira, ventilador, falha</a></li>
<li><a href="../pt490210/index.html">Acelerando o frontend. Quando muitas solicita√ß√µes de servidor s√£o boas</a></li>
<li><a href="../pt490222/index.html">Biblioteca Padr√£o da Morte</a></li>
<li><a href="../pt490224/index.html">Discri√ß√£o na moda</a></li>
<li><a href="../pt490242/index.html">Servi√ßo de localiza√ß√£o GSM dos m√≥dulos SIM800x e seu trabalho com a API Yandex.Locator</a></li>
<li><a href="../pt490244/index.html">Otimiza√ß√£o de c√≥digo Python com ctypes</a></li>
<li><a href="../pt490246/index.html">Torres do Kremlin no abra√ßo da Hydra: confer√™ncia de computa√ß√£o paralela e distribu√≠da Hydra 2020</a></li>
<li><a href="../pt490248/index.html">Webinar ‚ÄúWinnum CNC: monitoramento que funciona‚Äù</a></li>
<li><a href="../pt490250/index.html">Horror Set.removeAll</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>