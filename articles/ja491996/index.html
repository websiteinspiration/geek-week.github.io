<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏾 🙌🏾 ☢️ C ++のコルーチンの詳細 👨🏻‍✈️ 🖊️ 🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは同僚。
 
 C ++ 20トピックの調査の一環として、Yandexのハブログからかなり古い（2018年9月）記事に出くわしました。これは、「C ++ 20の準備。実際の例を持つTSをコルーチン」と呼ばれています。それは、次の非常に表現力豊かな投票で終わります。
 
 
 
 「なぜそうで...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C ++のコルーチンの詳細</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/491996/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは同僚。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 20トピックの調査の一環として、Yandexのハブログからかなり古い（2018年9月）記事に出くわしました。これは、「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 20の準備</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">実際の例を持つTSをコルーチン</font></a><font style="vertical-align: inherit;">」と呼ばれてい</font><font style="vertical-align: inherit;">ます。それは、次の非常に表現力豊かな投票で終わります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/a-/m4/xn/a-m4xn5j3yjfy-yl2et7aeek7sc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「なぜそうではない」というのは、「コルーチンの紹介」というタイトルで、David Pilarskiによる記事を決定して翻訳したことです。記事は1年以上前に発行されましたが、とにかくそれが非常に興味深いものであると思います。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だからそれが起こった。多くの疑問、論争、そしてこの機能の準備の後、WG21はC ++でどのように見えるべきかについて共通の意見になりました-そして、それらはC ++ 20に入る可能性が非常に高いです。今（覚えているように、まだ学ぶべきモジュール、概念、範囲がまだあります...）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くはまだコルーチンに反対しています。多くの場合、彼らは開発の複雑さ、多くのカスタマイズのポイント、そしておそらく、最適化されていない動的メモリの割り当てが原因でパフォーマンスが最適化されていないことを訴えます（多分;））。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
承認された（公式に公開された）技術仕様（TS）の開発と並行して、コルチンの別のメカニズムの開発を並行して行う試みも行われています。</font><font style="vertical-align: inherit;">ここでは、TS（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技術仕様</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）に</font><font style="vertical-align: inherit;">記述されているコルーチンについて説明し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">次に、代替のアプローチはGoogleに属します。</font><font style="vertical-align: inherit;">その結果、Googleのアプローチには多くの問題があり、その解決策にはC ++の奇妙な追加機能が必要になることがよくありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最終的に、マイクロソフト（TSの作成者）が開発したバージョンのコルチンを採用することが決定されました。</font><font style="vertical-align: inherit;">この記事で説明するのは、そのようなコルーチンについてです。</font><font style="vertical-align: inherit;">それで、の質問から始めましょう...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチンとは何ですか？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コルーチンは、PythonやC＃など、多くのプログラミング言語にすでに存在しています。</font><font style="vertical-align: inherit;">コルーチンは、非同期コードを作成するもう1つの方法です。</font><font style="vertical-align: inherit;">これらがフローとどのように異なるか、コルーチンを専用言語機能として実装する必要がある理由、そして最後に、それらの使用法についてこのセクションで説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コルーチンとは何かについて深刻な誤解があります。</font><font style="vertical-align: inherit;">それらが使用される環境に応じて、それらは呼び出される場合があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックレスコルーチン</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチンのスタック</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">緑の小川</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">繊維</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゴルチン</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
良いニュース：スタックコルチン、グリーンストリーム、ファイバー、ゴルチンは、まったく同じものです（ただし、異なる方法で使用されることもあります）。これらについては、この記事の後半で説明し、ファイバーまたはスタックコルーチンと呼びます。ただし、スタックレスコルーチンには、個別に説明する必要があるいくつかの機能があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
直感的なレベルを含めてコルーチンを理解するために、関数を簡単に理解し、（このように言えば）「それらのAPI」を理解しましょう。それらを処理する標準的な方法は、呼び出して、終了するまで待つことです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>{
     <span class="hljs-keyword">return</span>; <span class="hljs-comment">//     </span><font></font>
}	<font></font>
foo(); <span class="hljs-comment">//   / </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数を呼び出した後、その作業を一時停止または再開することはすでに不可能です。関数に対して実行できる操作は</font></font><code>start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、およびの</font><font style="vertical-align: inherit;">2つだけ</font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。関数が起動したら、完了するまで待つ必要があります。関数が再度呼び出された場合、その実行は最初から行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コルーチンでは、状況は異なります。それらを開始および停止するだけでなく、一時停止して再開することもできます。コルーチン自体は混雑していないため、コアフローとはまだ異なります（一方、コルーチンは通常流動しており、フローは混雑しています）。これを理解するために、Pythonで定義されたジェネレータを考えてみましょう。このようなものをPythonではジェネレータと呼び、C ++ではコルーチンと呼びます。例はこの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から取られ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_nums</span>():</span>
     num = <span class="hljs-number">0</span>
     <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
          <span class="hljs-keyword">yield</span> num<font></font>
          num = num + <span class="hljs-number">1</span>	<font></font>
<font></font>
nums = generate_nums()<font></font>
	<font></font>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<font></font>
     print(x)<font></font>
	<font></font>
     <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">9</span>:
          <span class="hljs-keyword">break</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードの仕組みは次のとおりです。関数呼び出し</font></font><code>generate_nums</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はコルーチンオブジェクトの作成につながります。</font><font style="vertical-align: inherit;">コルーチンオブジェクトを列挙する各ステップで、コルーチン自体が作業を再開</font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、コード内の</font><font style="vertical-align: inherit;">キーワードの後に​​のみ一時停止し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">次に、シーケンスの次の整数が返されます（forループは、</font></font><code>next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチンを再開する</font><font style="vertical-align: inherit;">関数を呼び出すための構文上の砂糖です</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">コードは、breakステートメントに遭遇することによってループを終了します。</font><font style="vertical-align: inherit;">この場合、コルチンは終わらないが、コルチンが終わって終るという状況は容易に想像できる。</font><font style="vertical-align: inherit;">私たちが見ることができるように、korutine該当する操作に</font></font><code>start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>suspend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>resume</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして最後に、</font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">[注：C ++は作成と破棄の操作も提供しますが、コルーチンを直感的に理解する上で重要ではありません]。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリとしてのコルーチン</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、コルーチンが何であるかがほぼ明らかになりました。</font><font style="vertical-align: inherit;">ファイバーオブジェクトを作成するためのライブラリがあることをご存知かもしれません。</font><font style="vertical-align: inherit;">問題は、コルーチンで動作するライブラリだけでなく、専用の言語機能の形でコルーチンが必要な理由です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、この質問に答え、スタックされたコルーチンとスタックレスのコルーチンの違いを実証しようとしています。</font><font style="vertical-align: inherit;">この違いは、コルチンを言語の一部として理解するための鍵となります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチンのスタック</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、最初にスタックコルーチンとは何か、どのように機能するのか、なぜコルーチンをライブラリとして実装できるのかを説明しましょう。</font><font style="vertical-align: inherit;">それらは設計の点でストリームに似ているため、それらを説明することは比較的簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイバーまたはスタックのコルチンには、関数呼び出しの処理に使用できる個別のスタックがあります。</font><font style="vertical-align: inherit;">この種のコルーチンがどのように機能するかを正確に理解するために、低レベルの観点から関数フレームと関数呼び出しを簡単に見ていきます。</font><font style="vertical-align: inherit;">しかし、最初に、繊維の特性について話しましょう。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼らは自分のスタックを持っています</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイバーの寿命は、それらを呼び出すコードに依存しません（通常、ユーザー定義のスケジューラーがあります）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">繊維はある糸から取り外して別の糸に取り付けることができ、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共同計画（ファイバーは別のファイバー/スケジューラーに切り替えることを決定する必要があります）、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じスレッドで同時に作業することはできません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のプロパティから次の効果が得られます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイバーのコンテキストの切り替えは、OSではなくファイバーのユーザーが実行する必要があります（さらに、OSはファイバーを解放し、それが機能するスレッドを解放することができます）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つのファイバーの間に実際のデータ競合はありません。常にアクティブにできるのは1つだけなので、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイバー設計者は、計算能力を可能なスケジューラーまたは呼び出し元に戻すことが適切な場所と時間を適切に選択できる必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイバーの入力/出力操作は非同期である必要があります。これにより、他のファイバーが互いにブロックせずにタスクを実行できるようになります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ファイバーの動作を詳しく見ていき、最初にスタックが関数呼び出しにどのように関与するかを説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、スタックは、ローカル変数と関数引数を格納するために必要な連続したメモリブロックです。しかし、より重要なのは、いくつかの例外を除いて、各関数呼び出しの後に、呼び出された関数に呼び出し元に戻ってプロセッサレジスタを復元する方法を通知する追加情報がスタックにプッシュされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのレジスタの一部には特別な割り当てがあり、関数を呼び出すと、それらはスタックに格納されます。これらは（ARMアーキテクチャーの場合）</font><font style="vertical-align: inherit;">
レジスターです。SP- </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタックポインター</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LR-通信レジスター</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PC-プログラムカウンター</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックポインター</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（SP）は、現在の関数呼び出しに関連するスタックの先頭のアドレスを含むレジスターです。既存の値のおかげで、スタックに格納されている引数とローカル変数を簡単に参照できます。</font><font style="vertical-align: inherit;">関数を呼び出す場合、</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通信レジスタ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（LR）は非常に重要です。これは、現在の関数の実行が完了した後にコードが実行される戻りアドレス（呼び出し側のアドレス）を格納します。関数が呼び出されると、PCはLRに保存されます。関数が戻ると、LRを使用してPCが復元されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムカウンタ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（PC）は、現在実行中の命令のアドレスです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数が呼び出されるときはいつでも、リンクのリストが保存されるので、関数は、プログラムが終了した後にどこに戻るべきかを知ることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/r2/yk/njr2ykw0o6hrsww5-uq3ybjjddg.png"><br>
 <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を呼び出して返すときのPCおよびLRレジスタの動作</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
スタックコルーチンを実行するとき、呼び出された関数は以前に割り当てられたスタックを使用して、引数とローカル変数を格納します。</font><font style="vertical-align: inherit;">スタックコルチンで呼び出された各関数のすべての情報はスタックに格納されるため、ファイバーはそのコルチン内の関数を中断できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/r2/yk/njr2ykw0o6hrsww5-uq3ybjjddg.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この写真で何が起こるか見てみましょう。</font><font style="vertical-align: inherit;">まず、各ファイバーとスレッドには独自のスタックがあります。</font><font style="vertical-align: inherit;">緑色は、一連のアクションを示すシリアル番号を示します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッド内の通常の関数呼び出し。</font><font style="vertical-align: inherit;">メモリはスタックに割り当てられます。</font></font></li>
<li><b>   </b>.      .     ,      .    .       ,              . </li>
<li>  .</li>
<li><b> </b>.       .</li>
<li>    .</li>
<li>    .</li>
<li><b> </b>.    ,    , ,      .</li>
<li>    .</li>
<li>    .</li>
<li><b> </b> –     ,     . </li>
<li>        ,      .</li>
<li>    .      . </li>
<li>       .    :   ,    . ,          (  ) .</li>
<li>  ,   .</li>
<li>  .</li>
<li><b> </b>.   .     .    ,      .</li>
<li>     .</li>
<li>      , ,     .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタックコルーチンを使用する場合は、コルーチンを使用するための専用の言語機能は必要ありません。</font><font style="vertical-align: inherit;">この目的のために特別に設計されているkorutinyスタック全体がうまくライブラリを使用して実装すること、およびライブラリがすでに存在している：</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swtch.com/libtask </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code.google.com/archive/p/libconcurrency </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.boost.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boost.Fiber </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.boost.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブースト.Coroutine </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべてのライブラリのうち、BoostのみがC ++で、残りはすべてCです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのライブラリの動作の詳細については</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">ドキュメントを</font><font style="vertical-align: inherit;">参照してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、一般に、これらのすべてのライブラリを使用すると、ファイバー用に別のスタックを作成し、コルーチンを（呼び出し元のイニシアチブで）再開して一時停止する（内部から）機会を提供できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を考えてみましょう</font></font><code>Boost.Fiber</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><font></font>
	<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/intrusive_ptr.hpp&gt;</span></span><font></font>
	<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/fiber/all.hpp&gt;</span></span><font></font>
	<font></font>
<span class="hljs-function"><span class="hljs-keyword">inline</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">fn</span><span class="hljs-params">( <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-keyword">const</span>&amp; str, <span class="hljs-keyword">int</span> n)</span> </span>{
     <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; str &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
               boost::this_fiber::yield();<font></font>
     }<font></font>
}<font></font>
	<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
     <span class="hljs-keyword">try</span> {<font></font>
          boost::<span class="hljs-function">fibers::fiber <span class="hljs-title">f1</span><span class="hljs-params">( fn, <span class="hljs-string">"abc"</span>, <span class="hljs-number">5</span>)</span></span>;
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"f1 : "</span> &lt;&lt; f1.get_id() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
          f1.join();<font></font>
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"done."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
	<font></font>
          <span class="hljs-keyword">return</span> EXIT_SUCCESS;<font></font>
     } <span class="hljs-keyword">catch</span> ( <span class="hljs-built_in">std</span>::exception <span class="hljs-keyword">const</span>&amp; e) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"exception: "</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
     } <span class="hljs-keyword">catch</span> (...) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"unhandled exception"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
     }<font></font>
     <span class="hljs-keyword">return</span> EXIT_FAILURE;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boost.Fiber</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の場合</font><font style="vertical-align: inherit;">、ライブラリにはコルーチン用の組み込みスケジューラがあります。</font><font style="vertical-align: inherit;">すべてのファイバーは同じスレッドで実行されます。</font><font style="vertical-align: inherit;">コーランの計画は協調的であるため、ファイバーは最初にいつスケジューラーに制御を戻すかを決定する必要があります。</font><font style="vertical-align: inherit;">この例では、コルーチンを一時停止するyield関数が呼び出されると、これが発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のファイバーがないため、ファイバープランナーは常にコルーチンを再開することを決定します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックレスコルーチン</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタックなしのコルーチンは、スタックのものとはプロパティが少し異なります。</font><font style="vertical-align: inherit;">ただし、スタックされていないコルーチンも開始できるため、中断後に再開できるため、基本的な特性は同じです。</font><font style="vertical-align: inherit;">このタイプのコルーチンは、C ++ 20で見つかる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コルーチンの同様の特性について話す場合-コルーチンは次のことができます：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチンは呼び出し元と密接に関係しています。コルーチンが呼び出されると、実行が彼女に転送され、コルーチンの結果が呼び出し元に転送されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックコルチンの寿命は、そのスタックの寿命と同じです。</font><font style="vertical-align: inherit;">スタックのないコルーチンの寿命は、そのオブジェクトの寿命と同じです。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、スタックレスコルーチンの場合、スタック全体を割り当てる必要はありません。それらはスタックのものよりはるかに少ないメモリを消費しますが、これは正確にはいくつかの制限によるものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、スタックにメモリを割り当てない場合、どのように機能しますか？彼らの場合、スタックコルーチンを操作するときにスタックに保存する必要があるすべてのデータがどこに行くのですか？回答：呼び出し元のスタック上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタックレスコルーチンの秘密は、最上位の関数からのみ一時停止できることです。他のすべての関数の場合、それらのデータは呼び出し側のスタックに配置されるため、corutinから呼び出されるすべての関数は、corutinの作業が中断される前に完了する必要があります。コルーチンがその状態を維持するために必要なすべてのデータは、ヒープに動的に割り当てられます。これには通常、いくつかのローカル変数と引数が必要です。これらは、事前に割り当てる必要のあるスタック全体よりもはるかにコンパクトです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタックレスコルチンのしくみを見てみましょう：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ow/vc/nw/owvcnwldgczpxdmjorsjlrh3yvm.png"><br>
 <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックレスコルチンへの挑戦</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、スタックは1つしかありません。これがスレッドのメインスタックです。</font><font style="vertical-align: inherit;">この図に示されている内容を段階的に見てみましょう（コルーチンのアクティブ化フレームは2色です-黒はスタックに格納されているものを示し、青-ヒープに格納されているものを示しています）。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フレームがスタックに格納されている通常の関数呼び出し</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この関数はコルーチンを作成し</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">つまり、ヒープ上のどこかにアクティベーションフレームを割り当てます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常の関数呼び出し。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corutinを呼び出します</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">コルティンの体は通常のスタックで目立ちます。</font><font style="vertical-align: inherit;">プログラムは、通常の関数の場合と同じ方法で実行されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチンからの通常の関数呼び出し。</font><font style="vertical-align: inherit;">繰り返しますが、すべてはスタック上で引き続き発生します[注：これはコルーチンの最上位の関数ではないため、この時点からコルーチンを一時停止することはできません]</font></font></li>
<li>       [:     .]</li>
<li>  –  ,        ,     .</li>
<li>  </li>
<li><b>  </b> –      ,        +     .</li>
<li>     5.</li>
<li>     6.</li>
<li><b> </b>.        .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、2番目のケースでは、corutinの作業を一時停止および再開するすべての操作で覚える必要のあるデータがはるかに少ないことは明らかですが、coroutineが再開および一時停止できるのは、それ自体のみで、最上位の関数からのみです。すべての関数呼び出しとコルーチンは同じように発生しますが、呼び出しの間は追加のデータを保存する必要があり、関数は中断点にジャンプしてローカル変数の状態を復元できる必要があります。コルーチンフレームと関数フレームの間に他の違いはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コルチンは他のコルーチンを引き起こす可能性もあります（この例には示されていません）。</font><font style="vertical-align: inherit;">スタックレスコルーチンの場合、呼び出しごとに新しいコルーチンデータ用の新しいスペースが割り当てられます（コルーチンの繰り返し呼び出しにより、動的メモリも複数回割り当てることができます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コルーチンが専用の言語機能を提供する必要があるのは、コンパイラがコルーチンの状態を表す変数を決定し、中断点にジャンプするステレオタイプコードを作成する必要があるためです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルチンの活用</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++のコルーチンは、他の言語と同じ方法で使用できます。</font><font style="vertical-align: inherit;">コルーチンはスペルを簡略化します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発電機</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期入力/出力コード </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイジーコンピューティング</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベント駆動型アプリケーション</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事を読むことで、次のことがわかると思います。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++でコルーチンを専用言語機能として実装する必要がある理由</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックコルーチンとスタックレスコルーチンの違いは何ですか？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチンが必要な理由</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja491986/index.html">RemoteLoRa-ON / OFF以上</a></li>
<li><a href="../ja491988/index.html">Red Hat OpenShift 4.2および4.3の新機能</a></li>
<li><a href="../ja491990/index.html">中国のチップADC Hx711と連携（結論）</a></li>
<li><a href="../ja491992/index.html">アナリストの育成</a></li>
<li><a href="../ja491994/index.html">CocoapodsからSwift Package Managerへの移行</a></li>
<li><a href="../ja492000/index.html">非常に最初の製品。バーンアウト</a></li>
<li><a href="../ja492002/index.html">光を吸収する翼：スーパーブラックバタフライの秘密</a></li>
<li><a href="../ja492004/index.html">プログラマーからマネージャーに成長する方法（「海の愛人になりたい」）</a></li>
<li><a href="../ja492006/index.html">PWAの威力：300行のニューラルネットワークJSコードを備えたビデオ監視システム</a></li>
<li><a href="../ja492008/index.html">ITモチベーション調査の結果：開発者は自分の仕事に満足していますか？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>