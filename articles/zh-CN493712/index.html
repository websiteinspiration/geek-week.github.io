<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗 👨‍👨‍👧‍👧 🤽 新的TypeScript功能可增强可用性 👩🏿‍🤝‍👨🏼 🙅🏻 🖖🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="从许多方面来看，TypeScript不再像一种编程语言，而是一种用于整理和记录代码的强大工具，可帮助您编写更好的JavaScript程序。
 
 TypeScript最显着的优势之一是它对ECMAScript规范中描述的一些最新功能的支持。当开发人员升级到新版本的TypeScript时，意味着他具有...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>新的TypeScript功能可增强可用性</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/493712/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从许多方面来看，TypeScript不再像一种编程语言，而是一种用于整理和记录代码的强大工具，可帮助您编写更好的JavaScript程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScript最显着的优势之一是它对ECMAScript规范中描述的一些最新功能的支持。当开发人员升级到新版本的TypeScript时，意味着他具有新的JavaScript功能。而且，使用这些功能并不意味着潜在的兼容性问题。 TypeScript除了引入了最新的JavaScript功能外，还值得注意的是，该语言的创建者不断向TS程序员社区展示旨在提高可用性的新内容。例如，这包括用于代码重构的辅助工具，用于实体重命名以及用于查找程序中使用它们的位置的工具。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ik/dc/io/ikdcio3bkdkuvgg4h-lplk9lvpm.jpeg"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们今天发布的翻译材料将讨论TypeScript的一些有趣的新功能。</font><font style="vertical-align: inherit;">有关TypeScript创新的完整列表，请在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处查看</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不可变的对象和数组</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了使在编译期间以普通变量和函数参数的形式使用不可变数组，在TypeScript中，可以使用辅助类型</font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>ReadonlyArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，它们的使用会在类型注释中引起异质感，尤其是</font></font><code>[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在指定类型后</font><font style="vertical-align: inherit;">使用字符声明数组时</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">TypeScript 3.4引入了一种标记只读数组参数的新方法。</font><font style="vertical-align: inherit;">随即出现了一种新的声明变量的方法，该变量应该是不变的。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过只读参数提高可用性</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，当声明需要作为只读数组使用的函数的参数时，可以使用关键字</font></font><code>readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在下面的示例中，两种方法的签名相同：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">s: ReadonlyArray&lt;string&gt;</span>) </span>{ <span class="hljs-comment">/* ... */</span> }<font></font>
&nbsp;<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">s: readonly string[]</span>) </span>{ <span class="hljs-comment">/* ... */</span> }
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这两种情况下，任何尝试修改数组的尝试（例如，使用其方法</font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）都将导致错误。</font><font style="vertical-align: inherit;">这项创新消除了对辅助泛型类型的需求，这意味着代码更易于阅读。</font><font style="vertical-align: inherit;">对象类型也可以标记为只读实体，但它们仍需要一个helper类型</font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用as const构造提高不可变变量的可用性</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用关键字声明的变量的类型</font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能更改。这个概念存在于JavaScript中。为了组织更严格的类型工作，TypeScript中也采用了它。但是，当使用对象数据类型（例如对象或数组）时，事实证明此类结构并不是真正不变的。使用关键字</font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">意味着在使用常量时，对象或数组的特定实例将保持不变，但是可以轻松更改该对象或数组的内容。例如，在不违反使用const实体的规则的情况下，您可以使用方法将新值添加到数组中</font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，也可以更改对象属性的值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用</font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>ReadonlyArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以告诉TypeScript系统应该将实体视为真正不可变的实体。</font><font style="vertical-align: inherit;">这意味着每次在代码中尝试更改此类实体时，都会发出错误消息。</font></font><br>
<br>
<pre><code class="javascript hljs">interface Person {&nbsp;
&nbsp;&nbsp;<span class="hljs-attr">name</span>: string;&nbsp;<font></font>
}<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> person = {&nbsp;
&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">'Will'</span>&nbsp;
} <span class="hljs-keyword">as</span> Readonly&lt;Person&gt;;<font></font>
person.name = <span class="hljs-string">'Diana'</span>; <span class="hljs-comment">// !</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在TypeScript 3.4中，除其他创新外，出现了const断言（constant语句）的概念，该概念规定了构造的使用</font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是用于声明包含不可变对象和数组的常量的简化方法。</font><font style="vertical-align: inherit;">此类声明是通过</font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在声明末尾</font><font style="vertical-align: inherit;">添加</font><font style="vertical-align: inherit;">常量来</font><font style="vertical-align: inherit;">构建的</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此方法还有一个优点，那就是使用它时，无需在statement中显式指定类型</font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> person = {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">'Will'</span>&nbsp;
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<font></font>
&nbsp;<font></font>
person.name = <span class="hljs-string">'Diana'</span>; <span class="hljs-comment">// !</span><font></font>
&nbsp;<font></font>
<span class="hljs-comment">//      as const</span>
<span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;&nbsp;<font></font>
array.push(<span class="hljs-number">4</span>); <span class="hljs-comment">// !</span>
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">助手类型省略</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScript中有几种帮助程序类型，可以轻松地将现有类型映射到新的类型，或根据其他类型有条件地设置类型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
辅助类型</font></font><code>Partial</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许将对象的所有属性标记为可选。</font><font style="vertical-align: inherit;">事实证明，在TypeScript 3.5发行之前，我一直在项目中使用一种有趣的机制。</font><font style="vertical-align: inherit;">这与现在允许使用的辅助类型相同</font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">顾名思义，此类型允许您从其他类型中排除某些内容。</font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接受键的类型和组合，然后返回一个新的类型，从中排除键所描述的属性。</font><font style="vertical-align: inherit;">我不得不将</font></font><code>Pick</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其</font></font><code>Exclude</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于功能的独立实现</font><font style="vertical-align: inherit;">的日子已经一去不复返了</font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     TypeScript 3.5</span><font></font>
type Omit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;<font></font>
&nbsp;<font></font>
interface A {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propA?: string;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propB?: string;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propC?: string;&nbsp;<font></font>
}<font></font>
&nbsp;<font></font>
type B = Omit&lt;A, <span class="hljs-string">'propA'</span> | <span class="hljs-string">'propC'</span>&gt;;&nbsp;
<span class="hljs-keyword">const</span> b: B = { <span class="hljs-attr">propA</span>: <span class="hljs-string">'hi'</span> }; <span class="hljs-comment">// ;</span>
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScript支持的新JavaScript功能</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当有关JavaScript新功能的建议到达协调的第4阶段时，它们将被视为该语言下一版本的一部分。</font><font style="vertical-align: inherit;">的确，这并不意味着可以在JavaScript中立即使用这些功能，因为它们的支持应该在适当的环境中实现。</font><font style="vertical-align: inherit;">该应用程序应该在应该正常运行的任何地方都可以使用这些机会。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定期向TypeScript编译器添加对新JavaScript功能的支持。</font><font style="vertical-align: inherit;">通常，可将实现这些功能的代码转换为与支持支持中指定的项目构建目标的所有浏览器兼容的JavaScript代码</font></font><code>tsconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍检查null和undefined</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript开发人员熟悉真理和虚假的概念。当真相检查可识别6个值，它总是假的：</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>«»</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>NaN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，，当然，</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。通常，开发人员只需要确定值是true还是false，但是在某些情况下，您只需要确定要调查的值是真实值</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还是</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。例如，如果有必要区分代码</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ||     ,  index  0</span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index || <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 1 &lt;-- </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该代码将通过设置</font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写入的值来工作</font></font><code>index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在所有情况下（值</font></font><code>index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相等</font><font style="vertical-align: inherit;">时除外）</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为了使此代码在任何情况下都能正常工作，需要使用更复杂的测试方案将其重写以找出真正的价值类型。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   ,    </span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index !== <span class="hljs-literal">null</span> &amp;&amp; index !== <span class="hljs-literal">undefined</span> ? : <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 0</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，代码可以使用了，但是它需要使用更复杂的检查。</font><font style="vertical-align: inherit;">用于检查on </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（看起来像两个问号- </font></font><code>??</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">上的值的新运算符</font><font style="vertical-align: inherit;">通过返回位于其左侧部分的值（如果它不等于</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">）来简化这种检查</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">否则，它将返回右侧的内容。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// !</span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index ?? <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 0</span>
getValueOrOne(<span class="hljs-number">2</span>); <span class="hljs-comment">// 2</span>
getValueOrOne(); <span class="hljs-comment">// 1</span>
</code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍可选顺序</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScript 3.7中另一个可用的JavaScript新功能是用于组织可选序列（</font></font><code>?.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">的运算符</font><font style="vertical-align: inherit;">。我首先用Groovy编程语言遇到了这样的运算符。从那时起，我希望它也出现在JavaScript中。此运算符使您可以组织对对象的嵌入属性的访问，而无需不断检查它们的存在。如果在访问属性时此运算符遇到一个值</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则它将仅返回该值而不会引发error </font></font><code>TypeError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> value = foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz;<font></font>
&nbsp;<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> value = foo?.bar?.baz;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可选的序列操作者与上检查的值的运算符组合</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并</font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给出了显影剂甚至更多的可能性，允许，例如，写入到可变任一所述物体的一些嵌套属性的值，或者，如果这样的属性不存在，一些标准值。</font><font style="vertical-align: inherit;">看起来是这样的：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> value = foo?.bar?.baz ?? <span class="hljs-string">'default value'</span>;
</code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍私人课</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自从这种语言问世以来，TypeScript就具有使用access修饰符声明的私有类字段的概念</font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这个概念甚至在ECMAScript标准中描述类之前就已经出现在TypeScript中。但是在TypeScript中，此概念是指在代码编译期间起作用的机制。如果不从类自己的方法访问类的私有字段，则编译器将引发错误。现在，在JavaScript中，有机会声明一个类的私有属性和方法。但是，此功能在语义和语法上都与TypeScript中仍然存在的功能不同。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript中的私有字段未使用access修饰符声明</font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。而是通过在名称的开头放置符号来声明它们</font></font><code>#</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fan</span> </span>{&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;#on = <span class="hljs-literal">false</span>;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;private name = <span class="hljs-string">'fan'</span>;<font></font>
&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;turnOn() {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.#on = <span class="hljs-literal">true</span>;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;isTurnedOn() {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.#on;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> fan = <span class="hljs-keyword">new</span> Fan();&nbsp;<font></font>
fan.isTurnedOn(); <span class="hljs-comment">// false&nbsp;&nbsp;</span><font></font>
fan.turnOn();&nbsp;<font></font>
fan.isTurnedOn(); <span class="hljs-comment">// true</span><font></font>
&nbsp;<font></font>
fan.on; <span class="hljs-comment">//  </span>
fan.#on; <span class="hljs-comment">// </span>
fan.name; <span class="hljs-comment">//   ,    JS</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript现在支持私有字段，</font><font style="vertical-align: inherit;">私有方法</font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提议</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处于批准的第三阶段。</font><font style="vertical-align: inherit;">当前，修饰符</font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>#</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段名称中</font><font style="vertical-align: inherit;">的字符</font><font style="vertical-align: inherit;">不能一起使用。</font><font style="vertical-align: inherit;">两种方法都可以在开发过程中派上用场，哪种方法取决于程序员。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">播客，讨论了声明私有字段的新语法。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code在代码顶层使用await关键字</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
异步编程机制极大地扩展了JavaScript和TypeScript的功能。最初，在这个领域出现了诺言，然后- </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许您编写更简洁的异步代码的设计。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不使用promise的情况之一</font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是异步函数外部的异步方法调用。例如，在模块或应用程序代码的顶层。作为这种情况下的解决方法，您可以建议创建一个立即调用的异步函数表达式（IIFE，即刻调用的函数表达式），并在该表达式内执行异步代码。</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-keyword">async</span> () =&gt; {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/users/sitepen'</span>);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Check out the blog at <span class="hljs-subst">${data.blog}</span>`</span>);&nbsp;<font></font>
})();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScript现在支持JavaScript </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在代码的最高级别</font><font style="vertical-align: inherit;">使用关键字的功能</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这意味着await可以在用关键字声明的函数之外使用</font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这非常擅长编写紧凑清晰的代码。</font><font style="vertical-align: inherit;">的确，</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码顶层</font><font style="vertical-align: inherit;">的表达式</font><font style="vertical-align: inherit;">被批评是因为它们会减慢模块的加载速度，并导致某些模块会减慢整个应用程序的加载速度，因为系统必须等待异步操作完成，然后执行模块的所有代码。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/users/sitepen'</span>);&nbsp;
<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> { ...data };
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增强的TypeScript实验环境</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这不能称为TypeScript的新功能，但是鉴于我们正在谈论TypeScript作为一种工具，因此</font><font style="vertical-align: inherit;">可以将</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScript Playground</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">称为一种有效的工具，用于快速检查任何TypeScript构造并查看这些构造所转换为的JavaScript代码。</font><font style="vertical-align: inherit;">这里的大多数示例都是在TypeScript Playground中经过专门测试的。</font><font style="vertical-align: inherit;">现在，此环境支持选择特定版本的TypeScript的能力（包括对beta版本的支持）。</font><font style="vertical-align: inherit;">它包括几个示例，可以帮助初学者入门TypeScript。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScript是一个工具，可以帮助您编写更好，更具表现力的JavaScript代码。</font><font style="vertical-align: inherit;">使用TypeScript帮助程序工具可以轻松解决复杂的任务，例如重构和重命名实体，而这在普通JavaScript中要复杂得多。</font><font style="vertical-align: inherit;">TypeScript不断引入新的机制，例如</font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">用这种语言，可以观察到对复杂类型的支持的不断改进。</font><font style="vertical-align: inherit;">TypeScript快速实现了最新的JavaScript功能。</font><font style="vertical-align: inherit;">这就是为什么许多人选择TypeScript并将其视为一种工具，语言和生态系统的原因。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">亲爱的读者们！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您发现最有趣的TypeScript新功能是什么？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN493700/index.html">在Azure中使用恶意软件来访问Microsoft 365租户</a></li>
<li><a href="../zh-CN493702/index.html">大规模过渡到远程工作：技术问题和对安全的威胁</a></li>
<li><a href="../zh-CN493704/index.html">在JavaScript中使用TypeScript而不编写TypeScript</a></li>
<li><a href="../zh-CN493706/index.html">认识你的敌人：创建一个Node.js后门</a></li>
<li><a href="../zh-CN493708/index.html">我的家庭Kubernetes集群的剖析</a></li>
<li><a href="../zh-CN493714/index.html">安全备忘单：Node.js</a></li>
<li><a href="../zh-CN493716/index.html">使用as const构造和infer关键字使用TypeScript进行类型推断</a></li>
<li><a href="../zh-CN493718/index.html">讨论：很少使用且当前正在使用的标准UNIX实用程序</a></li>
<li><a href="../zh-CN493720/index.html">完美风暴：技术如何改变食品服务行业</a></li>
<li><a href="../zh-CN493724/index.html">RPA | 通过分析人员实现流程自动化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>