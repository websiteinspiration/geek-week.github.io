<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏽 👩🏾‍🤝‍👨🏿 🕤 La implementación del efecto acuarela en los juegos. 👩‍🎓 🤙🏿 👨‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introducción
 Cuando en enero de 2019 comenzamos a discutir nuestro nuevo juego de tinte. , inmediatamente decidimos que el efecto acuarela sería el e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>La implementación del efecto acuarela en los juegos.</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/494924/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9b/8bc/7c5/f9b8bc7c53c4d97ed983c428ce53926b.gif" alt="imagen"></div><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introducción</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando en enero de 2019 comenzamos a discutir nuestro nuevo juego de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tinte.</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , inmediatamente decidimos que el efecto acuarela sería el elemento más importante. Inspirados por </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este anuncio de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bulgari</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nos dimos cuenta de que la implementación de la pintura de acuarela debería ser coherente con la alta calidad de los recursos restantes que planeamos crear. Encontramos un interesante artículo de investigadores de Adobe </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La técnica de acuarela descrita en ella se veía maravillosa, y debido a su naturaleza vectorial (en lugar de píxel), podría funcionar incluso en dispositivos móviles débiles. Nuestra implementación se basa en este estudio, cambiamos y / o simplificamos partes del mismo porque nuestros requisitos de rendimiento eran diferentes. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tinte</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- este es un juego, por lo tanto, además del dibujo en sí, necesitábamos renderizar todo el entorno 3D y ejecutar la lógica del juego en un solo cuadro. </font><font style="vertical-align: inherit;">También buscamos asegurarnos de que la simulación se realizara en tiempo real y el jugador viera de inmediato lo que se dibujaba.</font></font><br>
<a name="habracut"></a><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e8/277/d95/2e8277d95ed5a29796176e375ecf59c5.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simulación de color de agua en tinte. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este artículo, compartiremos los detalles individuales de la implementación de esta técnica en el motor del juego Unity y hablaremos sobre cómo la adaptamos para que funcione sin problemas en dispositivos móviles de gama baja. </font><font style="vertical-align: inherit;">Hablaremos más sobre las etapas principales de este algoritmo, pero sin demostrar el código. </font><font style="vertical-align: inherit;">Esta implementación se creó en Unity 2018.4.2 y luego se actualizó a la versión 2018.4.7.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué es el tinte?</font></font></h1><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tinte</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Este es un juego de rompecabezas que permite al jugador completar los niveles, mezclando los colores de las acuarelas para que coincidan con los colores del origami. </font><font style="vertical-align: inherit;">El juego fue lanzado en el otoño de 2019 en Apple Arcade para iOS, macOS y tvOS.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/630/d46/bb0630d469679d86535ec46fd97c8f0a.png" width="2224" height="1668"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tinte de captura de pantalla.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requisitos</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La técnica descrita en mi artículo se puede dividir en tres etapas principales realizadas en cada cuadro:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Genere nuevos puntos basados ​​en la entrada del jugador y agréguelos a la lista de puntos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simulación de pintura para todos los puntos en la lista</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Representación puntual</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuación, hablaremos en detalle sobre cómo implementamos cada una de las etapas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestro objetivo era alcanzar 60 FPS, es decir, estas etapas y toda la lógica que se describe a continuación se realizan 60 veces por segundo.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obteniendo entrada</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cada cuadro, transformamos la entrada del jugador (dependiendo de la plataforma, puede ser un toque, la posición del mouse o el cursor virtual) en una estructura </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que contiene la posición, el vector de movimiento, el color y la presión (2). Primero, verificamos la longitud de deslizamiento del jugador en la pantalla y la comparamos con un valor umbral determinado. Con golpes cortos, generamos un punto por cuadro en la posición de entrada. En el caso opuesto, llenamos la distancia entre los puntos de inicio y final del deslizamiento del jugador con nuevos puntos creados con una densidad predeterminada (esto asegura una densidad de pintura constante independientemente de la velocidad del deslizamiento). El color indica la pintura actual utilizada, y la pendiente del movimiento indica la dirección del deslizamiento. Los nuevos puntos creados se agregan a una colección llamada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatList</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que también contiene todos los puntos creados previamente. </font><font style="vertical-align: inherit;">Se utiliza para simular y renderizar pintura en los siguientes pasos. </font><font style="vertical-align: inherit;">Cada punto individual denota una "gota" de pintura que necesita ser renderizada, el componente principal de la pintura de acuarela. </font><font style="vertical-align: inherit;">El dibujo de acuarela terminado será el resultado de renderizar decenas / cientos de puntos de intersección. </font><font style="vertical-align: inherit;">Además, el valor de la vida útil (en cuadros) se asigna al punto recién creado, que determina cuánto tiempo se puede simular el punto.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ccb/e15/628/ccbe15628a553ba6ceb25af2fd2e2e36.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un ejemplo de interpolación de puntos largos de deslizamiento. </font><font style="vertical-align: inherit;">Los círculos huecos indican puntos creados a intervalos regulares.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lona</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al igual que la pintura real, necesitamos un lienzo. </font><font style="vertical-align: inherit;">Para implementarlo, creamos un área limitada en el espacio 3D que se parece a una hoja de papel. </font><font style="vertical-align: inherit;">Las coordenadas de entrada del jugador y todas las demás operaciones, como renderizar una malla, se registran en el espacio del lienzo. </font><font style="vertical-align: inherit;">Del mismo modo, el tamaño en píxeles de cualquier búfer utilizado para simular el dibujo depende del tamaño del lienzo. </font><font style="vertical-align: inherit;">El término "lienzo" como se usa en este artículo no está asociado de ninguna manera con la clase Canvas de la Unidad de interfaz de usuario.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/648/367/1cc/6483671ccaa809a93bcf2a276cdd2471.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El rectángulo verde muestra el área del lienzo en el juego.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mancha</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visualmente, el punto está representado por una malla redonda, cuyo borde consta de 25 vértices. Puede percibirlo como una "gota" que un pincel húmedo deja en un pedazo de papel si lo toca por un momento muy breve. Agregamos un pequeño desplazamiento aleatorio a la posición de cada vértice, lo que garantiza la irregularidad de los bordes de las manchas de pintura.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/baa/daa/9bbbaadaaf2b6d0fc1b295f5739ff083.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplos de mallas de malla.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Para cada vértice, también almacenamos el vector de velocidad hacia afuera, que luego se usa en la fase de simulación. Generamos varias mallas con pequeñas variaciones entre ellos y almacenamos sus datos en un objeto skriptuemy ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un objeto programable</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Cada vez que un jugador dibuja un lugar en tiempo real, le asignamos una malla seleccionada al azar de este conjunto. Vale la pena mencionar que a diferentes resoluciones de pantalla, el lienzo tiene un tamaño diferente en píxeles. Para que en todos los dispositivos el coeficiente del tamaño de los puntos sea el mismo, cuando comienzas el juego, cambiamos la escala de acuerdo con el tamaño del lienzo.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1af/f92/8de/1aff928de51a35f64351fe72f5c10d80.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un ejemplo de vectores spot almacenados con nuevos datos spot.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Cuando se genera una malla de puntos, también guardamos su "área de humectación", que define un conjunto de píxeles que están dentro de los bordes de puntos originales. El área de humectación se usa para simular la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">advección</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Durante la ejecución de la aplicación en el momento de crear cada nuevo lugar, marcamos el lienzo debajo como húmedo. Al simular el movimiento de la pintura, permitimos que se "extienda" sobre aquellas áreas del lienzo que ya se han mojado. Almacenamos el contenido de humedad del lienzo en el búfer global de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mapa húmedo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que se actualiza a medida que se agrega cada nuevo lugar. Además de participar en la mezcla de dos colores, la advección juega un papel importante en la apariencia final del trazo de pintura.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/843/67e/31d84367e786d15bd7fe0f59cbe2e3a5.jpg"></div><br>
<i><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wetmap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de llenado </font><font style="vertical-align: inherit;">, los píxeles dentro de la forma del punto (círculo verde) marcan el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetmap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tampón </font><font style="vertical-align: inherit;">(rejilla) en forma húmeda (verde). </font><font style="vertical-align: inherit;">El búfer de mapa húmedo tiene una resolución mucho más alta. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, cada punto también contiene un valor de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opacidad</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que es una función de su área; </font><font style="vertical-align: inherit;">representa el efecto de almacenar pigmento (una cantidad constante de pigmento en el lugar). </font><font style="vertical-align: inherit;">Cuando el tamaño de un punto aumenta durante la simulación, su opacidad disminuye y viceversa.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a88/870/a5b/a88870a5b213286e20815f3b87ecca5d.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un ejemplo de pintura sin advección (izquierda) y con ella (derecha).</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/341/069/348/341069348c265951c765843ca792b2c8.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplos de advección de pintura.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ciclo de simulación</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una vez que se recibe la entrada del jugador en el cuadro actual y se convierte en nuevos puntos, el siguiente paso es simular los puntos para simular la propagación de las acuarelas. Al comienzo de esta simulación, tenemos una lista de puntos que deben actualizarse y un </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mapa húmedo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> actualizado </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cada cuadro, recorremos la lista de puntos y cambiamos las posiciones de todos los vértices de los puntos usando la siguiente ecuación:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6fe/91a/4b86fe91ae4f677697b43e99a3299ecc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
donde: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el nuevo vector de movimiento, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el parámetro de corrección constante (0.33), </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el vector de pendiente de movimiento = dirección normalizada del deslizamiento del jugador multiplicado por 0.3, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el valor escalar de la rugosidad del lienzo = Random.Range (1,1 + r), </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el parámetro de rugosidad global, para la pintura estándar lo establecemos en 0.4, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el vector de velocidad creado de antemano con la malla de puntos, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el factor de velocidad, el valor escalar que usamos localmente en algunas situaciones para acelerar la advección, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x (t + 1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - posible nueva posición del vértice, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x (t)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - posición actual del vértice, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">br</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es el vector de rugosidad de ramificación = (Random.Range (-r, r), Random.Range (-r, r)), </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w (x)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el valor de humectación en el búfer de mapa húmedo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resultado de tales ecuaciones se llama </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">caminata aleatoria sesgada</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , imita el comportamiento de las partículas en la pintura de acuarela real. Estamos tratando de mover cada vértice del punto hacia afuera desde su centro ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), agregando aleatoriedad. Luego, la dirección del movimiento cambia ligeramente con la dirección del golpe ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) y otra vez se aleatoriza por otro componente de rugosidad ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">br</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Entonces, esta nueva posición de vértice se compara con un </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mapa húmedo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si el lienzo en la nueva posición ya estaba mojado (valor en el búfer de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mapa húmedo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mayor que 0), entonces le damos al vértice una nueva posición </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x (t + 1)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , de lo contrario no cambiamos su posición. </font><font style="vertical-align: inherit;">Como resultado, la pintura se extenderá solo en aquellas áreas del lienzo que ya estaban húmedas. </font><font style="vertical-align: inherit;">En la última etapa, recalculamos el área puntual, que se utiliza en el ciclo de renderizado para cambiar su opacidad.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a69/742/ae4/a69742ae4ee6d91b27bac6397bd317ff.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo de microescala de simulación de advección entre dos puntos activos de pintura.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ciclo de renderizado - Buffer húmedo</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de volver a contar los puntos, puede comenzar a representarlos. En la salida después de la etapa de emulación, la malla de puntos a menudo se deforma (por ejemplo, ocurren intersecciones), por lo tanto, para su representación correcta sin costos adicionales por triangulación repetida, utilizamos una solución con búfer de plantilla de dos pasadas. La interfaz de dibujo de Unity </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphics</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se utiliza para representar puntos </font><font style="vertical-align: inherit;">, y el ciclo de representación se realiza dentro del método Unity </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnPostRender</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Las mallas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puntuales</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se procesan para representar la textura ( </font><em><font style="vertical-align: inherit;">wetBuffer</font></em><font style="vertical-align: inherit;"> ) usando una cámara separada. Al comienzo del ciclo, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se borra y se establece como un objetivo de renderizado mediante </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphics.SetRenderTarget (wetBuffer)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Siguiente para cada punto activo de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatList</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ejecutamos la secuencia que se muestra en el siguiente diagrama:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e7/a09/328/1e7a0932807463744d7fd50a40fddedc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diagrama del ciclo de renderizado. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comenzamos limpiando el búfer de la plantilla antes de cada punto para que el estado del búfer de la plantilla del punto anterior no afecte al nuevo punto. </font><font style="vertical-align: inherit;">Luego seleccionamos el material utilizado para dibujar el lugar. </font><font style="vertical-align: inherit;">Este material es responsable del color del punto, y lo seleccionamos en función del índice de color almacenado en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cuando el jugador </font><em><font style="vertical-align: inherit;">dibujó el</font></em><font style="vertical-align: inherit;"> punto. </font><font style="vertical-align: inherit;">Luego cambiamos la opacidad del color (canal alfa) en función del área de la malla de puntos calculada en el paso anterior. </font><font style="vertical-align: inherit;">La representación en sí se realiza utilizando un sombreador de búfer de plantilla de dos pasos. </font><font style="vertical-align: inherit;">En la primera pasada (Material.SetPass (0)) pasamos la malla de puntos original para registrar las coordenadas en las que se llena la malla. </font><font style="vertical-align: inherit;">Con este pase </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ColorMask</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asignado un valor de 0, por lo que la malla en sí no se representa. </font><font style="vertical-align: inherit;">En la segunda pasada (Material.SetPass (1)) usamos el cuadrilátero descrito alrededor de la malla de puntos. </font><font style="vertical-align: inherit;">Verificamos el valor en el búfer de la plantilla para cada píxel del cuadrilátero; </font><font style="vertical-align: inherit;">si el valor es uno, se representa el píxel; de lo contrario, se omite. </font><font style="vertical-align: inherit;">Como resultado de esta operación, renderizamos la misma forma que la malla de puntos, pero ciertamente no contendrá artefactos no deseados, por ejemplo, auto intersecciones.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a9/06b/beb/1a906bbeb3f003d057430f6fb28e9257.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El procedimiento para realizar la técnica de doble búfer de plantilla (de izquierda a derecha). </font><font style="vertical-align: inherit;">Tenga en cuenta que este búfer de plantilla tiene una resolución mucho más alta que la mostrada, por lo que puede mantener su forma original con gran precisión.</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/15d/3ae/ed515d3aec23cd4eb9041761913afd2c.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un ejemplo de tres puntos de intersección representados de la manera tradicional, que condujeron a la aparición de artefactos (izquierda), y al uso de la técnica de búfer de plantilla de dos pasos con la eliminación de todos los artefactos (derecha).</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Después de representar todos los puntos en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se muestra en la escena del juego. Nuestro lienzo utiliza un sombreador improvisado que combina un </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , un mapa de papel difuso y un mapa normal de papel.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/968/db5/55a/968db555a2a477134013c355e3898e90.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sombreador de lienzo: solo wetBuffer (izquierda), textura de papel agregada (centro), mapa normal agregado (derecha). </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El juego admite un modo para personas con daltonismo, en el que se superponen patrones separados en la parte superior de la pintura. </font><font style="vertical-align: inherit;">Para lograr esto, cambiamos el material de las manchas agregando la textura del patrón con mosaico. </font><font style="vertical-align: inherit;">Los patrones siguen las reglas de mezclar los colores del juego, por ejemplo, azul (barras) + amarillo (círculos) dan verde (círculos en las barras) en la intersección. </font><font style="vertical-align: inherit;">Para mezclar patrones sin problemas, deben renderizarse en el mismo espacio UV. </font><font style="vertical-align: inherit;">Ajustamos las coordenadas UV del cuadrilátero utilizado en la segunda pasada del búfer de plantilla, dividiendo las posiciones x e y (que se especifican en el espacio del lienzo) por el ancho y la altura del lienzo. </font><font style="vertical-align: inherit;">Como resultado, obtenemos los valores correctos de u, v en el espacio de 0 a 1.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b5/057/211/7b50572119f116fae451dd321275a920.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un ejemplo de patrones de daltonismo.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimización - tampón de manchas secas</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como se mencionó anteriormente, una de nuestras tareas era admitir dispositivos móviles de baja potencia. </font><font style="vertical-align: inherit;">El renderizado puntual resultó ser el cuello de botella de nuestro juego. </font><font style="vertical-align: inherit;">Cada punto requiere tres llamadas de sorteo (llamar dos pases + borrar el búfer de plantilla), y dado que la línea de pintura contiene decenas o cientos de puntos, el número de llamadas de sorteo aumenta rápidamente y conduce a una caída en la velocidad de cuadros. </font><font style="vertical-align: inherit;">Para hacer frente a esto, aplicamos dos técnicas de optimización: primero, el dibujo simultáneo de todos los puntos "secos" en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y en segundo lugar, la aceleración local del secado de los puntos después de alcanzar un cierto número de puntos activos. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tampón seco</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es una textura de renderizado adicional agregada al ciclo de renderizado. Como se mencionó anteriormente, cada punto tiene una vida útil (en cuadros), que disminuye con cada cuadro. Después de que la vida útil alcanza 0, la mancha se considera "seca". Los puntos secos ya no se simulan, su forma no cambia y, por lo tanto, no es necesario volver a procesarlos en cada fotograma.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/afe/714/b44afe714c3be2aed6d853d031e2379a.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DryBuffer en acción; las manchas grises muestran las manchas copiadas en dryBuffer.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Cada punto cuya vida útil llega a 0 se elimina de la lista </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatList</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y se "copia" a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Durante el proceso de copia, el ciclo de renderizado se reutiliza, y esta vez </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se establece como la textura de renderizado objetivo </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mezcla adecuada entre </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no se puede lograr simplemente superponiendo los tampones en el sombreador de lienzo, porque la textura de </font><em><font style="vertical-align: inherit;">renderizado del</font></em><font style="vertical-align: inherit;"> tampón </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contiene puntos ya representados con valor alfa (que es equivalente a alfa premultiplicado). </font><font style="vertical-align: inherit;">Evitamos este problema agregando un paso al comienzo del ciclo de renderizado antes de recorrer iterativamente los puntos. </font><font style="vertical-align: inherit;">En este punto, representamos un cuadrilátero del tamaño de una pirámide de recorte de cámara que muestra </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Gracias a esto, cualquier mancha que se presente en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ya se mezclará con manchas secas, previamente pintadas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24e/afe/417/24eafe41762bcd3e7b2363e78c8bb9c0.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una mezcla de manchas húmedas y secas. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El búfer </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> acumula todos los puntos "secos" y no se borra entre fotogramas. </font><font style="vertical-align: inherit;">Por lo tanto, toda la memoria asociada con las manchas caducadas se puede borrar después de que se "copien" en el búfer.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/aa0/5bd/00eaa05bd29ca5c46eb8a845accc0b75.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gracias a la optimización con </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ya no tenemos límites en la cantidad de pintura que un jugador puede aplicar al lienzo.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
El uso de la técnica </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer por</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> separado permite al jugador dibujar con una cantidad casi infinita de pintura, pero no garantiza un rendimiento constante. Como se mencionó anteriormente, el trazo de pintura tiene un </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grosor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> constante </font><font style="vertical-align: inherit;">, que se logra dibujando mediante la interpolación de muchos puntos entre los puntos de inicio y finalización de la pasada. En el caso de muchos golpes rápidos y largos, el jugador puede generar una gran cantidad de puntos activos. Estos puntos se simularán y representarán en el número de fotogramas especificado por su vida útil, lo que en última instancia conduce a velocidades de fotogramas más bajas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para garantizar una velocidad de fotogramas estable, cambiamos el algoritmo para que el número de puntos activos estuviera limitado por un valor constante de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxActiveSplats</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Todos los puntos que exceden este valor instantáneamente se secan. Esto se logra reduciendo la vida útil de los puntos activos más antiguos a 0, por lo que se copian en el búfer de puntos secos antes. Dado que cuando acortamos la vida, obtenemos un lugar en el estado incompleto de la simulación (que parecerá bastante interesante), al mismo tiempo aumentamos la velocidad de propagación de la pintura. Debido al aumento de la velocidad, el punto alcanza casi el mismo tamaño que a velocidad normal con una vida útil estándar.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/907/c68/4c9/907c684c9c3642f6a109b4cadcf8718c.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d79/fe2/72b/d79fe272b648131541bfbf423384fc29.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demostración de un máximo de 40 puntos activos (arriba) y 80 (abajo). </font><font style="vertical-align: inherit;">Las manchas secas copiadas en dryBuffer se muestran en gris. </font><font style="vertical-align: inherit;">El valor indica la "cantidad" de pintura que se puede simular al mismo tiempo. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El valor de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxActiveSplats</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el parámetro de rendimiento más importante, nos permite controlar con precisión el número de llamadas de dibujo que podemos asignar a la representación en acuarela. </font><font style="vertical-align: inherit;">Lo configuramos al inicio, en función de la plataforma y la potencia del dispositivo. </font><font style="vertical-align: inherit;">También puede cambiar este valor durante la ejecución de la aplicación si se detecta una disminución en la velocidad de fotogramas.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusión</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La implementación de este algoritmo se ha convertido en una tarea interesante y desafiante. </font><font style="vertical-align: inherit;">Esperamos que los lectores hayan disfrutado el artículo. </font><font style="vertical-align: inherit;">Puede hacer preguntas en los comentarios al </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">original</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si desea apreciar nuestra acuarela en acción, intente jugar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tinte. </font><font style="vertical-align: inherit;">en el Apple Arcade</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/959/89e/fda/95989efda4d27809e1ce3923b341ac46.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Captura de pantalla de un juego que se ejecuta en Apple TV</font></font></i><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1) S. DiVerdi, A. Krishnaswamy, R. MÄch y D. Ito, "Pintura con polígonos: un motor de procedimiento de acuarela", en IEEE Transactions on Visualization and Computer Graphics, vol. </font><font style="vertical-align: inherit;">19, no. </font><font style="vertical-align: inherit;">5, pp. </font><font style="vertical-align: inherit;">723–735, mayo de 2013. doi: 10.1109 / TVCG.2012.295 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(2) La presión solo se tiene en cuenta al dibujar el Apple Pencil en un iPad.</font></font></blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es494912/index.html">Mi contribución a la protección contra Covid-19</a></li>
<li><a href="../es494916/index.html">Cómo vender cuentas comerciales y generar una ola de interés en los negocios en línea</a></li>
<li><a href="../es494918/index.html">La tercera semana del control remoto - vuelo normal. Reseñas de chicos de IT QIWI sobre el trabajo a tiempo completo desde casa</a></li>
<li><a href="../es494920/index.html">Mal consejo para el desarrollador: qué hacer para "complacer" a la gerencia</a></li>
<li><a href="../es494922/index.html">Nizhny Novgorod para un especialista en TI: perspectivas de trabajo y oportunidades para la vida</a></li>
<li><a href="../es494938/index.html">¡Feliz día de respaldo! No te olvides de el</a></li>
<li><a href="../es494940/index.html">DevOps: ¿qué es, por qué y cuánto demanda?</a></li>
<li><a href="../es494942/index.html">CGI en casa con Unreal Engine y iPhone</a></li>
<li><a href="../es494948/index.html">Cree un buzón VIP en Zimbra Collaboration Open-Source Edition</a></li>
<li><a href="../es494950/index.html">Algunas tendencias de almacenamiento a tener en cuenta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>