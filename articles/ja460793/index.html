<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕎 🧑🏾 🤦🏽 Reactアプリケーションの構造化 👨🏿‍🚒 👩🏻‍🎨 🍵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本日の翻訳は、Reactアプリケーションを構築する際に作成者が使用したアプローチを明らかにしています。特に、ここでは、使用されるフォルダー構造、エンティティの名前、テストファイルが配置される場所などについて説明します。
 
 Reactの最も楽しい機能の1つは、このライブラリーによって、開発者がプロ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Reactアプリケーションの構造化</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/460793/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本日の翻訳は、Reactアプリケーションを構築する際に作成者が使用したアプローチを明らかにしています。特に、ここでは、使用されるフォルダー構造、エンティティの名前、テストファイルが配置される場所などについて説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reactの最も楽しい機能の1つは、このライブラリーによって、開発者がプロ​​ジェクトの構造に関する特定の規則を厳密に遵守する必要がないことです。これの多くはプログラマーの裁量に残っています。このアプローチは、Ember.jsまたはAngularフレームワークで採用されているアプローチとは異なります。開発者により多くの標準機能を提供します。これらのフレームワークは、プロジェクトの構造に関する規則と、ファイルおよびコンポーネントの命名規則を提供します。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/k6/9y/ug/k69yugvbt27p3wtccvzeqrf_v4w.jpeg"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
個人的には、Reactが採用しているアプローチが好きです。事実、私は特定の「合意」に頼ることなく、自分で何かを制御することを好みます。ただし、Angularが提供するプロジェクトを構造化するアプローチには多くの利点があります。自由と多かれ少なかれ厳格なルールの間の選択は、あなたとあなたのチームにより近いものに帰着します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reactを長年使用してきた私は、アプリケーションを構造化するためにさまざまな方法を試してきました。私が適用したアイデアのいくつかは、他のものより成功していることが判明しました。したがって、ここでは、実際に証明されているすべてのことについてお話します。ここであなたに役立つ何かを見つけていただければ幸いです。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、アプリケーションを構造化する「唯一正しい」方法を示すつもりはありません。私のアイデアをいくつか取り入れて、ニーズに合わせて変更することができます。以前と同じように作業を続けることで、あなたは私に反対するかもしれません。異なるチームが異なるアプリケーションを作成し、異なる手段を使用して目標を達成します。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">スレッドの</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ウェブサイトを見ると</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、私が参加している開発、およびそのインターフェースのデバイスを見ると、私が話し合うこれらのルールが尊重されていない場所があります。</font><font style="vertical-align: inherit;">実際のところ、プログラミングにおける「ルール」は、推奨事項としてのみ解釈されるべきであり、あらゆる状況で有効な包括的な標準として解釈されるべきではありません。</font><font style="vertical-align: inherit;">そして、ある種の「ルール」が自分に合わないと思われる場合、自分が取り組んでいるものの品質を向上させるために、これらの「ルール」から逸脱する力を見つけなければなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際に、今、ささいなことをせずに、Reactアプリケーションの構造化についての私のストーリーを提供します。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルールについてあまり心配しないでください。</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、ルールについてあまり気にしないという推奨事項は、会話の最初に奇妙に見えると決めたのかもしれません。しかし、プログラマーがルールを遵守することに関して犯している主な間違いは、プログラマーがルールを過度に重視しているということです。これは、新しいプロジェクトの作業の開始時に特に当てはまります。最初の</font></font><code>index.jsx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクト</font><font style="vertical-align: inherit;">の作成時に</font><font style="vertical-align: inherit;">は、このプロジェクトに最適なものを知ることは不可能です。プロジェクトが発展するにつれて、当然のことながら、このプロジェクトに非常に適した、ある種のファイルとフォルダーの構造になります。作業の継続中に既存の構造がいくらか失敗したことが判明した場合、それを改善することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを読んで、議論されているアプリケーションに何もないと考えていることに気づいたら、これは問題ではありません。各アプリケーションは一意であり、まったく同じ2つの開発チームはありません。したがって、プロジェクトに取り組んでいる各チームは、その構造とプロジェクトでの作業方法に関していくつかの合意に達しています。これにより、チームメンバーは生産的に作業できます。誰かが何かをしている方法について学んだので、努力しないでください、すぐにこれをあなた自身に紹介してください。特定の資料で呼ばれていることを作品に取り入れようとしないでください。この場合でも、問題を解決するための「最も効果的な方法」です。私はそのような推奨事項に関して次の戦略を常に順守し、順守してきました。私には独自のルールがありますが、特定の状況で他の人がどのように行動するかについて読んで、私は成功し、自分にふさわしいと思うものを選びます。これは、時間が経つにつれて、私の作業方法が向上するという事実につながります。同時に、ショックはなく、一から書き直す気はありません。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要なコンポーネントは別のフォルダーにあります</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私がたどり着いたフォルダにコンポーネントファイルを配置する方法は、アプリケーションコンテキストで「重要」、「基本」、「メイン」と見なすことができるコンポーネントは、別々のフォルダに配置されるというものです。</font><font style="vertical-align: inherit;">これらのフォルダは、フォルダにあります</font></font><code>components</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">たとえば、電気店のアプリケーションについて話している場合</font></font><code>&lt;Product&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、製品を説明するために使用される</font><font style="vertical-align: inherit;">コンポーネントは、同様のコンポーネントとして認識できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これが私の意味です：</font></font><br>
<br>
<pre><code class="plaintext hljs">- src/<font></font>
&nbsp;&nbsp;- components/<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;- product/<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- product.jsx<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- product-price.jsx<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;- navigation/<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- navigation.jsx<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;- checkout-flow/<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- checkout-flow.jsx</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、特定の「メイン」コンポーネントでのみ使用される「セカンダリ」コンポーネントは、これらの「メイン」コンポーネントと同じフォルダにあります。このアプローチは実際に実証されています。実際には、そのアプリケーションのために、特定の構造がプロジェクトに表示されますが、フォルダーのネストのレベルは大きすぎません。そのアプリケーションは</font></font><code>../../../</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コンポーネントのインポートコマンドの</font><font style="vertical-align: inherit;">ような外観につながら</font><font style="vertical-align: inherit;">ず、プロジェクトの動きを複雑にしません。このアプローチにより、コンポーネントの明確な階層を構築できます。名前がフォルダの名前と一致するコンポーネントは、「基本」と見なされます。同じフォルダー内にある他のコンポーネントは、「ベース」コンポーネントをパーツに分割する目的を果たします。これにより、このコンポーネントのコードとそのサポートの操作が簡単になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はプロジェクトの特定のフォルダ構造の存在を支持していますが、最も重要なことは適切なファイル名を選択することだと思います。</font><font style="vertical-align: inherit;">フォルダ自体はそれほど重要ではありません。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブコンポーネントにサブフォルダーを使用する</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のアプローチの欠点の1つは、その使用により、多くのファイルを含む「基本」コンポーネントのフォルダーが表示される可能性があることです。たとえば、コンポーネントについて考えてみましょう</font></font><code>&lt;Product&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 CSSファイル（後で説明します）、テストファイル、多くのサブコンポーネント、およびおそらく画像やSVGアイコンなどの他のリソースが添付されます。 「追加」のリストはこれに限定されない。これはすべて、「ベース」コンポーネントと同じフォルダに分類されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本当に気にしません。これは、ファイルに適切な名前が付けられていて、簡単に見つけられる（エディターのファイル検索ツールを使用）場合に適しています。この場合、フォルダー構造は背景にフェードインします。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、このトピックに関するつぶやきが。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、プロジェクトをより広範な構造にしたい場合は、サブコンポーネントを独自のフォルダーに移動することは難しくありません。</font></font><br>
<br>
<pre><code class="javascript hljs">- src/<font></font>
&nbsp;&nbsp;- components/<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;- product/<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- product.jsx<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- ...<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- product-price/<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- product-price.jsx</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストファイルは、テスト中のコンポーネントのファイルと同じ場所にあります。</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションは簡単な推奨事項から始まります。つまり、テストファイルは、助けを借りてチェックされるコードを含むファイルと同じ場所に配置する必要があります。</font><font style="vertical-align: inherit;">また、コンポーネントを互いに近接させるために、コンポーネントをどのように構成するかについても説明します。</font><font style="vertical-align: inherit;">しかし、今では、テストファイルをコンポーネントファイルと同じフォルダーに配置すると便利だと言えるでしょう。</font><font style="vertical-align: inherit;">この場合、テストを含むファイルの名前は、コードを含むファイルの名前と同じです。</font><font style="vertical-align: inherit;">テスト名には、ファイル名拡張子の前に、サフィックスのみが追加され</font></font><code>.test</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネントファイル名：</font></font><code>auth.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストファイル名：</font></font><code>auth.test.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチにはいくつかの長所があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストファイルを簡単に見つけることができます。</font><font style="vertical-align: inherit;">一目で、使用しているコンポーネントのテストがあるかどうかがわかります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要なインポートコマンドはすべて非常に単純です。</font><font style="vertical-align: inherit;">テストでは、テスト済みのコードをインポートするために、フォルダーの出口などを記述する構造を作成する必要はありません</font></font><code>__tests__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そのようなチームは非常にシンプルに見えます。</font><font style="vertical-align: inherit;">たとえば、次のようになります</font></font><code>import Auth from './auth'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、APIリクエストモックなど、テスト中に使用される特定のデータがある場合は、コンポーネントとそのテストが既に存在する同じフォルダーにそれらを配置します。</font><font style="vertical-align: inherit;">必要なすべてのものが1つのフォルダーにある場合、これは生産性の向上に貢献します。</font><font style="vertical-align: inherit;">たとえば、分岐したフォルダー構造を使用していて、プログラマーが特定のファイルが存在することを確信しているが、その名前を思い出せない場合、プログラマーは多くのサブディレクトリでこのファイルを探す必要があります。</font><font style="vertical-align: inherit;">提案されたアプローチでは、1つのフォルダーの内容を確認するだけで、すべてが明らかになります。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CSSモジュール</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CSSモジュールの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大ファンです</font><font style="vertical-align: inherit;">。コンポーネントのモジュラーCSSルールを作成するのに最適であることがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、私は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタイル付きコンポーネント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技術が本当に好きです</font><font style="vertical-align: inherit;">。ただし、多くの開発者が参加したプロジェクトでの作業の過程で、プロジェクトに実際のCSSファイルが存在すると、使いやすさが向上することがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらくご想像のとおり、CSSファイルは、他のファイルと同様に、コンポーネントファイルの隣の同じフォルダーにあります。これにより、クラスの意味をすばやく理解する必要がある場合に、ファイル間の移動が大幅に簡略化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より一般的な推奨事項は、このすべての資料に浸透する本質は、特定のコンポーネントに関連するすべてのコードは、このコンポーネントが配置されているのと同じフォルダーに保持する必要があることです。</font><font style="vertical-align: inherit;">CSSやJSコード、テストコード、その他のリソースを格納するために別々のフォルダーが使用されていた時代は終わりました。</font><font style="vertical-align: inherit;">複雑なフォルダ構造を使用すると、ファイル間の移動が複雑になり、「コードの整理」に役立つことを除いて、明らかな利点はありません。</font><font style="vertical-align: inherit;">相互接続されたファイルを同じフォルダーに保持する-これは、作業中にフォルダー間を移動する時間を短縮することを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CSSのWebpackローダーも作成しました。その機能は、作業の機能に対応しています。</font><font style="vertical-align: inherit;">宣言されたクラス名をチェックし、存在しないクラスを参照するとコンソールにエラーをスローします。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどの場合、1つのコンポーネントコードは1つのファイルに配置されます</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の経験では、プログラマーは通常、1つのファイルに1つだけのReactコンポーネントコードを含めるというルールを厳格に厳守していることがわかります。</font><font style="vertical-align: inherit;">同時に、1つのファイルに多くのコンポーネントを配置する価値はないという考えを完全にサポートします（そのようなファイルに名前を付けるのが難しいことを想像してみてください！）。</font><font style="vertical-align: inherit;">しかし、特定の「大きな」コンポーネントのコードが配置されている同じファイルと、それに関連付けられている「小さな」コンポーネントのコードを配置することには何の問題もないと私は思います。</font><font style="vertical-align: inherit;">そのような移動がコードの純粋さを維持するのに役立つ場合、「小さな」コンポーネントが大きすぎて別のファイルに配置できない場合、これは誰にも害を及ぼすことはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、コンポーネントを作成した場合</font></font><code>&lt;Product&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そして私は価格を表示するための小さなコードが必要です、そして私はこれを行うことができます：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> Price = <span class="hljs-function">(<span class="hljs-params">{ price, currency }</span>) =&gt;</span> (
&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;{currency}
&nbsp;&nbsp;&nbsp;&nbsp;{formatPrice(price)}
&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">const</span> Product = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> {
&nbsp;&nbsp;<span class="hljs-comment">// ,      !</span>
&nbsp;&nbsp;<span class="hljs-keyword">return</span> (
&nbsp;&nbsp;&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">Price</span> <span class="hljs-attr">price</span>=<span class="hljs-string">{props.price}</span> <span class="hljs-attr">currency</span>=<span class="hljs-string">{props.currency}</span> /&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>loads more stuff...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
&nbsp;&nbsp;)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチの良い点は、コンポーネント用に個別のファイルを作成する必要がなく</font></font><code>&lt;Price&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、このコンポーネントはコンポーネント専用に使用できることです</font></font><code>&lt;Product&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このコンポーネントはエクスポートされないため、アプリケーションの他の場所にインポートすることはできません。</font><font style="vertical-align: inherit;">つまり</font></font><code>&lt;Price&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、別の場所にインポートする必要がある場合、</font><font style="vertical-align: inherit;">それ</font><font style="vertical-align: inherit;">を別のファイル</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">入れる</font><font style="vertical-align: inherit;">かどうかの質問は</font><font style="vertical-align: inherit;">、明確で肯定的な答えを与えることができます。</font><font style="vertical-align: inherit;">それ以外の場合は、コード</font></font><code>&lt;Price&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を別のファイルに</font><font style="vertical-align: inherit;">移動せずに実行でき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユニバーサルコンポーネント用の個別のフォルダー</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近はユニバーサルコンポーネントを使用しています。</font><font style="vertical-align: inherit;">彼らは、実際には、（私たちはいつかを公開する予定）当社の設計システムを形成し、これまでのところ、我々は小さな開始している-などのコンポーネントと</font></font><code>&lt;Button&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>&lt;Logo&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">コンポーネントは、サイトの特定の部分に関連付けられていないが、ユーザーインターフェイスの構成要素の1つである場合、「ユニバーサル」であると見なされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様のコンポーネントは、独自のフォルダー（</font></font><code>src/components/generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）にあります。</font><font style="vertical-align: inherit;">これにより、すべてのユニバーサルコンポーネントでの作業が大幅に簡略化されます。</font><font style="vertical-align: inherit;">彼らは一箇所にあります-それは非常に便利です。</font><font style="vertical-align: inherit;">時間の経過とともに、プロジェクトが成長するにつれて、スタイルガイドを開発する予定です（私たちは、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">react-styleguidistの</font></a><font style="vertical-align: inherit;">大ファンです）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）ユニバーサルコンポーネントでの作業をさらに簡素化するため。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エイリアスを使用したエンティティのインポート</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクト内の比較的フラットなフォルダー構造により、インポートコマンドの構造がのように長くなりすぎないことが保証されます</font></font><code>../../</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、彼らなしではそうすることは難しい。</font><font style="vertical-align: inherit;">そのため、</font><font style="vertical-align: inherit;">インポートコマンドを簡略化するエイリアスを設定</font><font style="vertical-align: inherit;">するために</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">babel-plugin-module-resolver</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Webpackでも同じことができますが、Babelプラグインを使用することで、同じインポートコマンドをテストでも機能させることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これをエイリアスのペアで構成しました：</font></font><br>
<br>
<pre><code class="javascript hljs">{
&nbsp;&nbsp;<span class="hljs-attr">components</span>: <span class="hljs-string">'./src/components'</span>,
&nbsp;&nbsp;<span class="hljs-string">'^generic/([\\w_]+)'</span>: <span class="hljs-string">'./src/components/generic/\\1/\\1'</span>,<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は非常に簡単です。</font><font style="vertical-align: inherit;">単語でコマンドを開始して、任意のコンポーネントをインポートできます</font></font><code>components</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">通常のアプローチでは、インポートコマンドは次のようになります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> Product <span class="hljs-keyword">from</span> <span class="hljs-string">'../../components/product/product'</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代わりに、次のように書くことができます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> Product <span class="hljs-keyword">from</span> <span class="hljs-string">'components/product/product'</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どちらのコマンドも同じファイルをインポートします。</font><font style="vertical-align: inherit;">これは、フォルダー構造について考える必要がないため、非常に便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のエイリアスはもう少し複雑です。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-string">'^generic/([\\w_]+)'</span>: <span class="hljs-string">'./src/components/generic/\\1/\\1'</span>,</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは正規表現を使用しています。</font><font style="vertical-align: inherit;">で始まるインポートコマンドを検索し</font></font><code>generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>^</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">式の先頭に</font><font style="vertical-align: inherit;">ある記号</font><font style="vertical-align: inherit;">を使用すると、で始まるコマンドのみを選択できます</font></font><code>generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、</font></font><code>generic/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グループ内の</font><font style="vertical-align: inherit;">後</font><font style="vertical-align: inherit;">にある</font><font style="vertical-align: inherit;">ものをキャプチャし</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">その後、キャプチャしたフラグメント（</font></font><code>\\1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）をコンストラクトで使用し</font></font><code>./src/components/generic/\\1/\\1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、次のようなユニバーサルコンポーネントのインポートコマンドを使用できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> Button <span class="hljs-keyword">from</span> <span class="hljs-string">'generic/button'</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは次のコマンドに変換されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> Button <span class="hljs-keyword">from</span> <span class="hljs-string">'src/components/generic/button/button'</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、このコマンドは、ユニバーサルボタンを説明するJSXファイルをインポートするのに役立ちます。</font><font style="vertical-align: inherit;">このアプローチは、ユニバーサルコンポーネントのインポートを大幅に簡略化するために、すべて実行しました。</font><font style="vertical-align: inherit;">さらに、プロジェクトファイルの構造を変更することを決定した場合にも役立ちます（これは、設計システムが拡大しているため、可能です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、仮名を扱う場合は注意が必要であることに注意したいと思います。</font><font style="vertical-align: inherit;">そのうちのいくつかしかなく、それらが標準のインポート問題を解決するように設計されている場合、すべてが問題ありません。</font><font style="vertical-align: inherit;">しかし、それらがたくさんある場合、それらは良いよりも混乱をもたらす可能性があります。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーティリティ用のユニバーサルlibフォルダー</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントコードではないコードに最適な場所を見つけるために費やしたすべての時間を取り戻したいと思います。ユーティリティ、サービス、補助機能のコードを強調しながら、さまざまな原則に従ってこれをすべて共有しました。このすべてに非常に多くの名前が付いているので、それらすべてについては触れません。ここで、特定のファイルの適切な場所を見つけるために、「ユーティリティ」と「補助関数」の違いを理解しようとはしていません。今では、はるかにシンプルで理解しやすいアプローチを使用しています</font></font><code>lib</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらはすべて1つのフォルダに分類されます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長期的には、このフォルダのサイズが非常に大きくなり、どうにかして構造化する必要があるかもしれませんが、これは完全に正常です。過剰な構造化のエラーを取り除くよりも、何かに特定の構造を備える方が常に簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドプロジェクトでは、フォルダー</font></font><code>lib</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に約100個のファイルが含まれています。</font><font style="vertical-align: inherit;">それらは、特定の機能の実装を含むファイルとテストファイルにほぼ均等に分割されます。</font><font style="vertical-align: inherit;">必要なファイルを見つけるのに問題はありませんでした。</font><font style="vertical-align: inherit;">ほとんどのエディターに組み込まれているインテリジェントな検索エンジンのおかげで、のようなもの</font></font><code>lib/name_of_thing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">入力するだけでほとんどの場合十分で</font><font style="vertical-align: inherit;">あり、必要なものが見つかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、フォルダーからのインポートを簡略化するエイリアスが</font></font><code>lib</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あり、この種のコマンドを使用できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> formatPrice <span class="hljs-keyword">from</span> <span class="hljs-string">'lib/format_price'</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のフォルダが1つのフォルダに格納される原因となるフラットなフォルダ構造に悩まされないでください。</font><font style="vertical-align: inherit;">通常、このような構造は、特定のプロジェクトに必要なすべてです。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネイティブAPIの背後にあるサードパーティライブラリを非表示にする</font></font></font></h2><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セントリーの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
バグ監視システムが本当に好きです</font><font style="vertical-align: inherit;">。アプリケーションのサーバー部分とクライアント部分を開発するときによく使用しました。その助けを借りて、例外をキャッチし、その発生に関する通知を受け取ることができます。これは、サイトで発生した問題に遅れずに対応できる優れたツールです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトでサードパーティのライブラリを使用するときはいつでも、必要に応じて他のライブラリと簡単に置き換えることができるように、ライブラリの作成方法を考えています。多くの場合、私たちが本当に気に入っているのと同じSentryシステムと同様に、これは必要ありません。ただし、念のため、特定のサービスの使用を回避する方法や、それを別のサービスに変更する方法を考えても問題はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題の最善の解決策は、他の人のツールを隠す独自のAPIを開発することです。これは</font></font><code>lib/error-reporting.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、関数をエクスポートする</font><font style="vertical-align: inherit;">モジュール</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">作成するようなもの</font></font><code>reportError()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。このモジュールのコアは、Sentryを使用しています。ただし、Sentryはこのモジュールにのみ直接インポートされ、他の場所にはインポートされません。つまり、Sentryを別のツールに置き換えるのは非常に簡単に見えます。これを行うには、1つの場所で1つのファイルを変更するだけで十分です。このファイルのパブリックAPIが変更されていない限り、プロジェクトの残りの部分では、呼び出し時に</font></font><code>reportError()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sentryではなく他の何かが使用され</font><font style="vertical-align: inherit;">ていること</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">わかり</font><font style="vertical-align: inherit;">ません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モジュールのパブリックAPIは、それがエクスポートする関数とその引数と呼ばれることに注意してください。これらは、モジュールのパブリックインターフェイスとも呼ばれます。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PropTypes（またはTypeScriptやFlowなどのツール）の使用</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私がプログラミングをするとき、私は自分の3つのバージョンを思い浮かべます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">過去のジャックと彼が書いたコード（時々怪しいコード）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今日のジャックと彼が今書いているコード。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未来からのジャック。</font><font style="vertical-align: inherit;">この未来を自分で考えるとき、自分の将来を楽にするコードをどのように書くことができるのか、今の自分に尋ねます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
奇妙に聞こえるかもしれませんが、コードの書き方を考えて、「6か月後にどのように認識されるのか」という質問をすると、私はそれが役に立つと思いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在および将来の生産性を高めるための簡単な方法の1つは</font></font><code>PropTypes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コンポーネントで使用される</font><font style="vertical-align: inherit;">プロパティのタイプ（</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を指定</font><font style="vertical-align: inherit;">することです。</font><font style="vertical-align: inherit;">これにより、タイプミスの可能性を探す時間を節約できます。</font><font style="vertical-align: inherit;">これにより、コンポーネントを使用して、間違ったタイプのプロパティが適用されたり、プロパティの転送を完全に忘れたりする状況を回避できます。</font><font style="vertical-align: inherit;">私たちの場合、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">eslint-react / prop-types</font></a></font><code>PropTypes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルール</font><font style="vertical-align: inherit;">は、使用の必要性をよく思い出させます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
さらに進んだ場合は、プロパティをできるだけ正確に説明することをお勧めします。</font><font style="vertical-align: inherit;">たとえば、これを行うことができます：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="javascript hljs">blogPost: PropTypes.object.isRequired</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これを行う方がはるかに良いでしょう：</font></font><br>
<br>
<pre><code class="javascript hljs">blogPost: PropTypes.shape({
&nbsp;&nbsp;<span class="hljs-attr">id</span>: PropTypes.number.isRequired,
&nbsp;&nbsp;<span class="hljs-attr">title</span>: PropTypes.string.isRequired,
&nbsp;&nbsp;<span class="hljs-comment">//   </span>
}).isRequired</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の例では、必要最小限のチェックが実行されます。</font><font style="vertical-align: inherit;">2番目の方法では、開発者にはるかに役立つ情報が提供されます。</font><font style="vertical-align: inherit;">たとえば、オブジェクトで使用されている特定のフィールドのことを誰かが忘れた場合などに非常に便利です。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サードパーティのライブラリは、本当に必要な場合にのみ使用されます。</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このヒントは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reactフックの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">登場により、</font><font style="vertical-align: inherit;">これまで</font><font style="vertical-align: inherit;">以上に</font><font style="vertical-align: inherit;">関連性</font><font style="vertical-align: inherit;">が</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">高まってい</font></a><font style="vertical-align: inherit;">ます。たとえば、私はスレッドサイトの一部の大規模な変更に従事しており、サードパーティのライブラリの使用に特別な注意を払うことにしました。フックと自分の開発の一部を使用すると、他の誰かのコードを使用しなくても多くのことができることを提案しました。私の推測（これはうれしい驚きでした）は真実であることがわかりました。これ</font><font style="vertical-align: inherit;">については、React-applicationsの状態の管理に関する資料を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">て</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ください</font></a><font style="vertical-align: inherit;">。そのようなアイデアに惹かれたら、最近ではReactとContext APIフックのおかげで、これらのアイデアの実装に非常に遠くまで行けると考えてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、Reduxのように、特定の状況で必要なものがあります。</font><font style="vertical-align: inherit;">そのような決定を完全に回避しようと努力しないことをお勧めします（すでにそれらを使用している場合は、回避することを優先するべきではありません）。</font><font style="vertical-align: inherit;">しかし、プロジェクトに新しいライブラリを含めることを考えている場合は、これが特定の問題の唯一の解決策とはほど遠いことを知っておく必要があります。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントジェネレータの不快な機能</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントジェネレータは、直接接続されていないコンポーネントのペア間の相互作用を確立できるようにする設計パターンです。</font><font style="vertical-align: inherit;">私はこのパターンをよく使用していました。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//    </span>
emitter.send(<span class="hljs-string">'user_add_to_cart'</span>)<font></font>
<font></font>
<span class="hljs-comment">//    </span>
emitter.on(<span class="hljs-string">'user_add_to_cart'</span>, () =&gt; {
&nbsp;&nbsp;<span class="hljs-comment">//  - </span>
})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチを使用すると、コンポーネントを互いに完全に分離できるという事実によって、このパターンの使用について説明しました。コンポーネントをイベントの送信と処理のメカニズムのみを使用してデータを交換できるという事実により、このアプローチを正当化しました。問題は、コンポーネントが「互いに分離されている」という事実だけをもたらしました。コンポーネントは独立したエンティティのように見えるかもしれませんが、これはそうではありません。それらは互いに暗黙的な依存関係を持っているだけです。私はこのパターンの強さを主に考慮したため、これを「暗黙の」依存と呼びます。つまり、コンポーネントがお互いの存在を知らないということです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様のものがReduxにもあります。</font><font style="vertical-align: inherit;">コンポーネントは互いに直接通信しません。</font><font style="vertical-align: inherit;">これらは、アクションと呼ばれる追加の構造と相互作用します。</font><font style="vertical-align: inherit;">のように、イベントが発生したときに何が起こるかというロジックは</font></font><code>user_add_to_cart</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、レデューサーにあります。</font><font style="vertical-align: inherit;">その結果、すべての管理が容易になります。</font><font style="vertical-align: inherit;">さらに、Reduxを使用したアプリケーションの開発に使用されるツールは、アクションとそのソースの検索を簡素化します。</font><font style="vertical-align: inherit;">その結果、イベントの操作時にReduxで使用されるこれらの追加の構造は、プロジェクトにプラスの影響を与えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントジェネレーターでいっぱいの多くのプロジェクトに取り組む機会を得た後、次のことが定期的に行われていることがわかりました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントの表示を待機している一部のコードが削除されました。</font><font style="vertical-align: inherit;">その後、イベントジェネレーターはこれらのイベントをvoidに送信します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントを送信する一部のコードも削除できます。</font><font style="vertical-align: inherit;">結果として、イベントリスナーは何も生成しないイベントを予期します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">誰かが重要でないと見なしたイベントは削除されます。</font><font style="vertical-align: inherit;">これは、イベントが重要だったので、プロジェクトの作業を深刻に混乱させます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不確実性につながるため、これはすべて悪いことです。</font><font style="vertical-align: inherit;">これは、プログラマが作業しているデバイスコードの正確さに自信を失うという事実につながります。</font><font style="vertical-align: inherit;">プログラマーが不要と思われるコードを安全に削除できるかどうかがわからない場合、このコードは通常削除されず、「デッド」コードがプロジェクトに蓄積されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現代の状況では、Context APIまたは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバックプロパティ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用してイベントジェネレーターを使用して解決できる問題を解決し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特別なユーティリティを使用したテストの簡素化</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、コンポーネントのテストに関して別のアドバイスをしたいと思います（ちなみに、これについての</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トレーニングコース</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を書きました</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">このヒントは、コンポーネントのテストプロセスを簡略化する一連のヘルパー関数を作成することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、ユーザーの認証ステータスが、多くのコンポーネントが必要とするコンテキストの小さなフラグメントに格納されているアプリケーションを書いたことがあります。</font><font style="vertical-align: inherit;">各テストで、私はこれを行うことができました：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> wrapper = mount(
&nbsp;&nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserAuth.Provider</span> <span class="hljs-attr">value</span>=&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">ComponentUnderTest</span> /&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">UserAuth.Provider</span>&gt;</span></span>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は小さなヘルパーメカニズムを書きました：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> wrapper = mountWithAuth(ComponentUnderTest, {
&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">'Jack'</span>,
&nbsp;&nbsp;<span class="hljs-attr">userId</span>: <span class="hljs-number">1</span>,<font></font>
})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチには多くの長所があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各テストは非常に明確です。</font><font style="vertical-align: inherit;">テストを見ると、ユーザーがログインしている状態で動作するのか、ユーザーがログインしていない状態で動作するのかがすぐにわかります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">認証メカニズムの実装が変更された場合、更新でき</font></font><code>mountWithAuth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、すべてのテストは引き続き正常に機能します。</font><font style="vertical-align: inherit;">問題は、私のシステムの認証ロジックが1か所にあるということです。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルにこれらの補助ユーティリティを作成しすぎることを恐れないでください</font></font><code>test-utils.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">あなたがそれらの多くを持っているという事実は非常に正常です。</font><font style="vertical-align: inherit;">このようなユーティリティは、プロジェクトのテストプロセスを簡略化します。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで私は私の経験の多くを共有しました。</font><font style="vertical-align: inherit;">私のアドバイスは、コードベースのサポートを改善することであり、さらに重要なのは、成長するプロジェクトでの作業をより楽しくすることです。</font><font style="vertical-align: inherit;">各コードベースには独自の古い問題がありますが、これらの問題がプロジェクトに及ぼす悪影響を軽減し、新しい問題の発生を防ぐことができる手法があります。</font><font style="vertical-align: inherit;">資料の冒頭で、これについてはすでに説明しましたが、繰り返しますが、アドバイスは推奨事項としてのみ考慮してください。</font><font style="vertical-align: inherit;">他の人のアイデアを特定のプロジェクトに適用すると、それらはこのプロジェクトの詳細に従って変換されます。</font><font style="vertical-align: inherit;">結局のところ、プロジェクトの構造については意見が異なり、アプリケーション開発に関連するさまざまな問題を解決するためのアプローチも異なります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読者の皆様！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反応アプリケーションをどのように構成しますか？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja460773/index.html">Javaでのパターンマッチングの実装</a></li>
<li><a href="../ja460777/index.html">これが順番です：Appleがアプリケーション開発者の要件を変更した理由</a></li>
<li><a href="../ja460779/index.html">高度なデバッグ</a></li>
<li><a href="../ja460783/index.html">ノードの評判に関するコンセンサス。必要ですか？</a></li>
<li><a href="../ja460785/index.html">Androidオペレーティングシステム上の電子書籍のアプリケーション。パート1.導入とオフィスアプリケーション</a></li>
<li><a href="../ja460795/index.html">JavaScriptアプリケーションのパフォーマンスを改善するための12のヒント</a></li>
<li><a href="../ja460797/index.html">責任あるJavaScript開発パート2</a></li>
<li><a href="../ja460799/index.html">標準ブラウザAPI支払いリクエスト</a></li>
<li><a href="../ja460801/index.html">現代のJavaScript開発者向けの27の素晴らしいVS Codeツール</a></li>
<li><a href="../ja460803/index.html">夏の読書：技術者向けの本</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>