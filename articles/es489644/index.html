<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📞 🧗🏼 🎩 Partículas blandas en WebGL y OpenGL ES 👨🏻‍🎨 👨🏿‍🤝‍👨🏾 🛌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los sistemas de partículas son algunas de las formas más fáciles de enriquecer visualmente una escena 3D. En una de nuestras aplicaciones de Android, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Partículas blandas en WebGL y OpenGL ES</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489644/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los sistemas de partículas son algunas de las formas más fáciles de enriquecer visualmente una escena 3D. En una de nuestras aplicaciones de Android, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3D Buddha Live Wallpaper es una</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> escena bastante simple, que sería bueno agregar un poco más de detalle. Y cuando pensamos en cómo agregar variedad a la imagen, la decisión más obvia de llenar el espacio vacío alrededor de la estatua de Buda fue agregar nubes de humo o niebla. Gracias al uso de partículas blandas, hemos logrado un resultado bastante bueno. En este artículo, describiremos en detalle la implementación de partículas blandas en WebGL / OpenGL ES puro sin usar bibliotecas de terceros y motores 3D listos para usar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diferencia entre la aplicación antigua y la actualizada incluso superó nuestras expectativas. </font><font style="vertical-align: inherit;">Las partículas de humo simples mejoraron significativamente la escena, la hicieron más rica y completa. </font><font style="vertical-align: inherit;">Las bocanadas de humo son detalles adicionales que "llaman la atención", así como una forma de hacer que la transición entre los objetos principales y el fondo sea más suave:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fy/8a/-e/fy8a-eyk-2aa2jstcglba6zc-du.jpeg"></div><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partículas blandas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, ¿qué son estas partículas blandas? </font><font style="vertical-align: inherit;">Puedes recordar que en muchos juegos antiguos (de Quake 3 y CS 1.6) los efectos del humo y las explosiones tenían límites planos muy claros en la intersección de partículas con una geometría diferente. </font><font style="vertical-align: inherit;">Todos los juegos modernos ya no tienen tales artefactos debido al uso de partículas blandas, es decir, partículas con bordes borrosos, "suaves" alrededor de objetos adyacentes.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Representación</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué se requiere para suavizar las partículas? </font><font style="vertical-align: inherit;">Primero, necesitamos información sobre la profundidad de la escena para determinar la intersección de partículas con otros objetos y suavizarlos. </font><font style="vertical-align: inherit;">Luego, necesitamos determinar la intersección de la escena y las geometrías de las partículas comparando las profundidades de la escena y las partículas en el sombreador de fragmentos, intersecciones donde las profundidades son las mismas. </font><font style="vertical-align: inherit;">A continuación, veremos el proceso de renderizado paso a paso. </font><font style="vertical-align: inherit;">Ambas implementaciones de escena para Android OpenGL ES y WebGL son iguales, la principal diferencia es solo en la carga de recursos. </font><font style="vertical-align: inherit;">La implementación en WebGL es de código abierto y puede obtenerla aquí: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/keaukraine/webgl-buddha</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Representación del mapa de profundidad</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para renderizar un mapa de profundidad de escena, primero debemos crear texturas para el mapa de profundidad y color y asignarlas a un FBO específico. Esto se hace en el método </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initOffscreen ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el archivo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuddhaRenderer.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La representación real de los objetos de escena en un mapa de profundidad en sí se realiza en el método </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drawDepthObjects ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que </font><i><font style="vertical-align: inherit;">dibuja una</font></i><font style="vertical-align: inherit;"> estatua de Buda y un plano de piso. Sin embargo, hay un truco para mejorar el rendimiento. Dado que en esta etapa de representación no necesitamos información de color, sino solo profundidad, la representación en el búfer de color se deshabilita llamando a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gl.colorMask (falso, falso, falso, falso)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y luego se vuelve a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">activar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> llamando a </font><i><font style="vertical-align: inherit;">gl.colorMask (verdadero, verdadero, verdadero, verdadera)</font></i><font style="vertical-align: inherit;"> . </font><i><font style="vertical-align: inherit;">GlcolorMask ()</font></i><font style="vertical-align: inherit;"> función</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede activar y desactivar la grabación de los componentes rojo, verde, azul y alfa por separado, por lo que para desactivar por completo la grabación en el búfer de color, configuramos todos los componentes como falsos y luego los activamos para renderizarlos en la pantalla, exponiéndolos todos a verdadero. </font><font style="vertical-align: inherit;">El resultado de renderizar a la textura de profundidad se puede ver al descomentar la llamada a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drawTestDepth ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el método </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drawScene ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dado que la textura del mapa de profundidad tiene solo un canal, se percibe tan pronto como los canales rojo, azul y verde son cero. </font><font style="vertical-align: inherit;">Una visualización del mapa de profundidad de nuestra escena se ve así:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ht/63/nu/ht63nu3kmrnsmdjy9nke2wcmppw.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderizado de partículas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El código de sombreador utilizado para representar las partículas se encuentra en el archivo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SoftDiffuseColoredShader.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Vamos a ver cómo funciona. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea principal de encontrar la intersección de las geometrías de partículas y escenas es comparar el valor de la profundidad del fragmento actual con el valor almacenado del mapa de profundidad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primer paso para comparar profundidades es linealizar las profundidades, ya que los valores originales son exponenciales. Esto se hace usando la función </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calc_depth ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Aquí se describe bien esta técnica: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://community.khronos.org/t/soft-blending-do-it-yourself-solved/58190</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Para los valores de linealización, necesitamos la variable uniforme </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vec2 uCameraRange</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuyos componentes x e y contienen los valores de los planos de recorte cercanos y lejanos de la cámara. Luego, el sombreador calcula la diferencia lineal entre la profundidad de la partícula y la escena; este valor se almacena en la variable a. Sin embargo, si aplicamos este valor al color del fragmento, obtenemos partículas que son demasiado transparentes: el color se desvanecerá linealmente desde cualquier geometría detrás de la partícula y se desvanecerá bastante rápido. Así es como se ve la visualización de la diferencia lineal en profundidad (puede descomentar la línea de código correspondiente en el sombreador y verla):</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/j9/yy/bv/j9yybvyxepfvjwyjs4jraymi72w.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para hacer que las partículas sean más transparentes solo cerca del borde de la intersección (en la región a = 0), aplicamos la función GLSL </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smoothstep ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al valor de la variable a con el valor de transición de 0 al coeficiente especificado en el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uniforme</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uTransitionSize </font><font style="vertical-align: inherit;">, que determina el ancho de la transición transparente. Si desea obtener más información sobre la función </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smoothstep ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y ver algunos ejemplos interesantes de su uso, le recomendamos que lea este artículo: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.fundza.com/rman_shaders/smoothstep/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El coeficiente final se almacena en la variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para el modo de mezcla de color utilizado en nuestra escena, simplemente multiplique el color de la partícula tomada de la textura por este coeficiente; </font><font style="vertical-align: inherit;">en otras implementaciones de partículas, es posible que deba cambiar, por ejemplo, solo el canal alfa. </font><font style="vertical-align: inherit;">Si descomenta la línea de código en el sombreador para visualizar este coeficiente, el resultado se verá así:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/k9/ha/rd/k9hardw3rfmghkzjrdv9wsb0nqg.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comparación de varios valores del coeficiente de "suavidad" de las partículas:</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hq/ix/6v/hqix6v7kcbvkkkhath792gl8t8k.gif"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimización de renderizado de sprites</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esta escena, se dibujan pequeñas motas de polvo como sprites puntuales (primitivas como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GL_POINTS</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Este modo es conveniente porque crea automáticamente la geometría cuadrada terminada de la partícula con coordenadas de textura. Sin embargo, también tienen inconvenientes que hacen que su uso sea inapropiado para partículas grandes de palos de niebla. En primer lugar, están cortados por los planos de recorte de la matriz de la cámara de acuerdo con las coordenadas del centro del sprite. Esto lleva al hecho de que desaparecen abruptamente de la vista en los bordes de la pantalla. Además, la forma cuadrada del sprite no es muy óptima para el sombreador de fragmentos, ya que se llama en aquellos lugares donde la textura de la partícula está vacía, lo que provoca un rediseño notable. Utilizamos una forma de partícula optimizada, con bordes recortados en aquellos lugares donde la textura es completamente transparente:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/lr/vs/dp/lrvsdpj0icaww4fdnleho4kh9sg.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tales modelos de partículas se denominan comúnmente cartelera. Por supuesto, no se pueden representar como primitivas de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GL_POINTS</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por lo que cada partícula se dibuja por separado. Esto no crea muchas llamadas a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drawElements</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en toda la escena solo hay 18 partículas de niebla. Deben colocarse en coordenadas arbitrarias, escaladas pero giradas de tal manera que siempre estén perpendiculares a la cámara, independientemente de su posición. Esto se logra modificando la matriz descrita en esta respuesta en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StackOverflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Hay </font><font style="vertical-align: inherit;">un método </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalculateMVPMatrixForSprite </font></font></a><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">() en el</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> archivo </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">BuddhaRenderer.js</font></a><font style="vertical-align: inherit;"> que crea matrices MVP para modelos de cartelera. Realiza todas las transformaciones habituales de desplazamiento y escala y luego utiliza</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resetMatrixRotations ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para restablecer el componente de rotación de la matriz de vista de modelo antes de que se multiplique por la matriz de proyección. </font><font style="vertical-align: inherit;">La matriz resultante realiza una transformación como resultado de lo cual el modelo siempre se dirige exactamente a la cámara.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El resultado final se puede ver en vivo aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede aprender y reutilizar el código fuente de Github para sus proyectos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es489632/index.html">FOSS News No. 4 - revisión de noticias gratuitas y de código abierto del 17 al 23 de febrero de 2020</a></li>
<li><a href="../es489636/index.html">Alexey Grachev: Ir Frontend</a></li>
<li><a href="../es489638/index.html">Sistema de archivos interplanetarios: blog simple de IPFS con XSLT</a></li>
<li><a href="../es489640/index.html">Los científicos del MIT lograron obtener electricidad del aire utilizando proteínas bacterianas</a></li>
<li><a href="../es489642/index.html">Patentes divertidas de la industria automotriz</a></li>
<li><a href="../es489650/index.html">Automatización de un periodista. Parte 1: Tareas y Calendarios</a></li>
<li><a href="../es489652/index.html">El resumen de materiales frescos del mundo del front-end para la última semana No. 403 (17-23 de febrero de 2020)</a></li>
<li><a href="../es489660/index.html">Por qué las bases de datos NoSQL son una mala solución para aplicaciones modernas</a></li>
<li><a href="../es489662/index.html">PHP Digest No. 174 (del 10 al 24 de febrero de 2020)</a></li>
<li><a href="../es489664/index.html">NPS, transportador, computación automática y de nuevo ... corutinas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>