<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👗 🛕 👒 ERPの設計における関数型プログラミングの原則の適用 👨🏾‍🚒 🚴🏾 🎸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！
 
 この記事では、関数型プログラミングの観点から、会計システム（ERP、CRM、WMS、MES、B2Bなど）のアーキテクチャーについて説明します。既存のシステムは複雑です。それらはリレーショナルデータスキーマに基づいており、数百の関連テーブルの形で巨大な可変状態を持っています...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ERPの設計における関数型プログラミングの原則の適用</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482938/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、関数型プログラミングの観点から、会計システム（ERP、CRM、WMS、MES、B2Bなど）のアーキテクチャーについて説明します。既存のシステムは複雑です。それらはリレーショナルデータスキーマに基づいており、数百の関連テーブルの形で巨大な可変状態を持っています。さらに、そのようなシステムでの唯一の「信頼できる情報源」は、一次ドキュメント（実際のイベントの印刷物）の時系列のジャーナルです。これは明らかに不変である必要があります（この規則は、バックデート修正が禁止されている監査済みシステムで観察されます）。ドキュメントジャーナルはデータベースボリュームの20％を占め、それ以外はすべて中間的な抽象化と集計です。これはSQLでの作業には便利ですが、ドキュメントとの相互の継続的な同期が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソースに戻り（データの冗長性を排除し、集計の保存を拒否）、すべてのビジネスアルゴリズムを、プライマリドキュメントのストリームに直接適用される関数の形式で実装すると、機能的なDBMSとその上に構築された機能的なERPが得られます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモ化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によってパフォーマンスの問題が解決され</font><font style="vertical-align: inherit;">、関数型コードの量は宣言型SQLの量に見合ったものになり、理解するのが難しくなりません。</font><font style="vertical-align: inherit;">この記事では、TypeScriptおよび</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denoランタイム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Node.jsに類似）で</font><font style="vertical-align: inherit;">最も単純なファイルDBMSを開発することによるアプローチを示し、</font><font style="vertical-align: inherit;">典型的なビジネスタスクを例として使用して、畳み込みのパフォーマンスをテストします。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜこれが関連するのか</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ミュータブルな状態+データの冗長性が悪い。特に、ドキュメントのフローと常に同期している必要がある場合。</font><font style="vertical-align: inherit;">これは、潜在的な資格情報の不一致（バランスが収束しない）の原因であり、副作用の検出が困難です。</font></font><br>
<a name="habracut"></a><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースデータと中間データを格納するための厳密なリレーショナルスキームは、ビッグデータ、異機種システム、および急激な変化の状況、つまり実際にはどこでも高価です。</font><font style="vertical-align: inherit;">ドキュメントを元の形式で保存し、時間順に並べ替えて、「新しいものから古いものへ」の接続を許可し、その逆は不可能にします。</font><font style="vertical-align: inherit;">これにより、ドキュメントから直接シングルパスアルゴリズムを使用してほとんどのユニットを計算でき、他のすべてのテーブルは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ません</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLは時代遅れです。SQLはいつでもあらゆるデータの可用性を想定しているためです。分散システムでは明らかにそうではありません。ビッグデータアルゴリズムを開発する場合、必要なデータの一部を後で表示し、一部を早く表示する準備をする必要があります。</font><font style="vertical-align: inherit;">これには、クエリ言語の再考と、キャッシュに関する意識的な配慮が必要です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最新のPLを使用すると、RDBMSがインストールされないラップトップでローカルに何百万ものレコードを操作する応答システムを作成できます。</font><font style="vertical-align: inherit;">そして、サーバーについて言えば、提案されたスキームには、SPARKクラスターを含め、並列処理の機会が増えます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックグラウンド</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまなビジネスソフトウェア（経理、計画、WMS）でかなり長い間働いていたため、ほぼどこでも2つの問題に遭遇しました。データスキームに変更を加えることの困難さと、これらの変更が行われたときに生産性が頻繁に低下することです。一般に、これらのシステムは、矛盾する要件が課されるため、複雑な構造を持っています</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。1）監査能力。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのプライマリドキュメントを変更せずに保存する必要があります。ディレクトリと操作への分割は非常に条件付きです;大人のシステムでは、ディレクトリはバージョン管理に限定されており、各変更は特別なドキュメントによって行われます。したがって、ソースドキュメントはシステムの不変の部分であり、それが唯一の「真のソース」であり、他のすべてのデータはそこから復元できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2）クエリのパフォーマンス。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、受注明細を作成する場合、システムは割引を考慮に入れて製品の価格を計算する必要があります。割引については、クライアントのステータス、現在の残高、購入履歴、地域の現在のシェアなどを抽出する必要があります。当然のことながら、必要なすべての情報を「オンザフライ」で計算することはできませんが、半完成した形で利用できる必要があります。したがって、既存のシステムは、ドキュメント（投稿）の行の便利な抽象化、および事前計算された集計（累積レジスター、タイムスライス、現在の残高、要約投稿など）を格納します。それらのボリュームはデータベースサイズの最大80％であり、テーブル構造は厳密に固定されており、アルゴリズムが変更されています。プログラマは、集計の正しい更新に注意する必要があります。実際には、これはシステムの変更可能な状態です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3）トランザクションパフォーマンス。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメントを保持する場合は、すべての集計を再カウントする必要があります。これは通常、ブロッキング操作です。</font><font style="vertical-align: inherit;">したがって、集計更新アルゴリズムはシステムで最も苦痛なポイントであり、多数の変更を行うと、何かが破損する大きなリスクがあり、データが「腐食」します。つまり、集計はドキュメントに対応しなくなります。</font><font style="vertical-align: inherit;">この状況は、すべての実装プロジェクトとその後のサポートの惨劇です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいアーキテクチャの基本を確立します</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1）保管。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースの基礎は、現実世界の事実を反映した、時系列順に並べられたドキュメントのジャーナルです。ディレクトリもドキュメントであり、長時間作用します。ドキュメントとディレクトリエントリの各バージョンはどちらも不変です。トランザクション/レジスター/残高の形式で他のデータはシステムに保存されません（強力な挑発的な声明、それは人生では異なって発生しますが、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完璧</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を目指して努力する必要があります</font><font style="vertical-align: inherit;">）。ドキュメントには、いくつかのシステム属性があります。</font></font><br>
<br>
<pre><code class="json">{<font></font>
    "sys": {<font></font>
        "code": "partner.1",  // - ,  <font></font>
        "ts": 1578263624612,  //   <font></font>
        "id": "partner.1^1578263624612",  //    ID<font></font>
        "cache": 1  //    <font></font>
    },<font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と異なる</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ts</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を持つドキュメントは、</font><font style="vertical-align: inherit;">履歴グループを形成します。最後のレコードは関連があると見なされ、残りは履歴です。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシュ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性が設定されている場合、</font><font style="vertical-align: inherit;">グループの最後のエントリがいわゆるトップキャッシュに分類され、同時にすべてのエントリがフルキャッシュに分類されるため、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">id</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codeの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">両方でディレクトリエントリをすばやく抽出でき</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドキュメントはジャーナルの最後に追加でき、途中には追加できません。古いドキュメントの変更または削除（キャンセル）は、常に現在の</font><i><font style="vertical-align: inherit;">tsで</font></i><font style="vertical-align: inherit;">ジャーナルに書き込まれた新しいドキュメントです。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。したがって、因果関係はジャーナル内のドキュメントの位置によって決定され、過去または未来へのジャンプは禁止されています（この場合、会計の受け入れ日、計画の実行日は任意ですが、システムのコアの観点からは、これらは単なる属性です）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2）コミュニケーション。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメントは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idで</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相互に参照できます</font><font style="vertical-align: inherit;">。 「SQL外部キー」とは異なり、エンティティが混同され、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ID</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が一意</font><font style="vertical-align: inherit;">であるため、参照するエンティティのタイプを指定する必要はありません</font><font style="vertical-align: inherit;">。以前のドキュメントから後のドキュメントへのリンクは禁止されています。これは、どのユーザーアルゴリズムでも、現在のドキュメントを処理するときに、サンプルで以前に遭遇した関連ドキュメントを要求できることを意味します（理論的には、カーネルまたはユーザーアルゴリズムによってキャッシュする必要があります）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3）免疫の地平線。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在作業中のドキュメントの一部（いわゆるオープンドキュメント）は修正できないため、イミュニティホライズンの概念が導入され、データベースは2つの物理ストア（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不変ストア</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のストア</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）に分割されます</font><font style="vertical-align: inherit;">。最初のストレージ内のすべてのドキュメントのタイムスタンプは地平線よりも短く、変更されていません。すべての畳み込みの結果はキャッシュされ、再利用されます。それ以降はすべて現在の期間と呼ばれ、要求ごとに2番目のストレージが再度スキャンされます。そのようなスキームは線形時間を与えます。免疫の地平線は、1Cの同僚や会計士がよく知っている用語です。システムのパフォーマンスは</font><s><font style="vertical-align: inherit;">混乱の</font></s><font style="vertical-align: inherit;">サイズにのみ依存します</font></font><s><font style="vertical-align: inherit;"></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在の期間、そしてこの問題では世界のビジネス慣行は無慈悲です-それが少ないほど、より良いです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4）アルゴリズム。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメントジャーナルは、任意の形式（シーケンシャルファイル、ドキュメントデータベース、RDBMSテーブル、外部ストリームから取得）で格納できます。主なものは、それらが直接または逆の発生順に抽出されることです。すべてのビジネスアルゴリズムは、ドキュメントフローに適用されるフィルター（）、削減（）、取得（）、取得（）関数の組み合わせです。 JOINセマンティクスの欠如により、ユーザーはデータベースへのネストされたサブクエリを使用したり、1つのパスに制限したりして、将来必要になる可能性のあるすべてのものをユーザーキャッシュに配置する機会があります。当然、システムキャッシュは、</font><i><font style="vertical-align: inherit;">ID /コード</font></i><font style="vertical-align: inherit;">による要求がすでにあった個別のドキュメントとして保存するのに役立ち</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、および以前に実行された計算の結果（これらの計算の入力パラメーターが完全に一致）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5）メモ化</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、またはキャッシング。</font><font style="vertical-align: inherit;">次の場合、クエリと計算の結果はキャッシュに分類されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメントには</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cache</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性が</font><font style="vertical-align: inherit;">あり、最初の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reduce（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でフルキャッシュに書き込まれ、トップキャッシュのレコードが更新されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメントは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">id / code</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によってリクエストによって取得され</font><font style="vertical-align: inherit;">、不変のストレージにあります。</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reduce（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は不変のストレージで計算を完了し、中間結果が複製されてキャッシュに書き込まれ、計算は現在のストレージで続行されます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RDBMSに基づくシステムの厳密に構造化された「キャッシュ」とは対照的に、システムが動作するにつれて満たされる適応キャッシュがあることがわかります。メモリを節約する必要があるため、キャッシュされる情報の量を制限する必要があるため、たとえば、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filter（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">の結果はキャッシュされず、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reduce（）の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果</font><font style="vertical-align: inherit;">が必要になります。ユーザーには限られたキャッシュ管理ツールが与えられます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6）検索に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は3つのタイプがあり</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。 1つ目は、現在のドキュメントを処理するときに、不正確な基準でいくつかの関連ドキュメントを見つける必要がある場合です。この場合、サブクエリ、またはその</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reduce（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要になる可能性のあるものはすべて事前に保存しておき、必要な場合はこのサンプルを調べます。 2番目のタイプの検索は、履歴データ（いわゆる現在のスライス）なしでディレクトリの関連要素を取得する必要がある場合です。この場合、そのような要素を格納するだけのトップキャッシュが使用されます。 3番目のケースでは、データベースに基づいて新しい順にフルスキャンされます。ユーザーの検索結果をキャッシュするのがどれほど便利かは、議論の余地のある質問です。たとえば、サンプルサイズが限られている場合など、明らかに必要です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7）ドキュメントを追加し、水平線を移動します。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいドキュメントを追加すると、トップキャッシュのみが更新されます。</font><font style="vertical-align: inherit;">ドキュメントを現在のストレージから不変のものに移動する場合-理論的には、キャッシュされたすべての集約を更新する必要があります。この操作は困難であり（転送されたドキュメントの数とキャッシュ内の結果の数によって異なります）、会計期間を閉じることと同様に、最小負荷の時間帯に実行する必要があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シンプルな機能DBMS</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だから、何かを書いてみてください。活字体は、スクリプトのダイナミズムとタイピングの完璧な組み合わせのために選択した</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電王の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランタイム</font><font style="vertical-align: inherit;">活字体とするための便利なサポートのため</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WASM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、同様の存在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">錆のAPI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（これは不正確ですが）理論的にはいくつかのアルゴリズムスピードアップするために私たちにチャンスを与えます、。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DBMSのドキュメントは</font><font style="vertical-align: inherit;">、高速ストリーミングパーサーを作成できるため</font><font style="vertical-align: inherit;">、記号「\ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x01</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」で</font><font style="vertical-align: inherit;">区切られたJSONオブジェクトを含む2つの連続したファイルの形式で保存されます</font><font style="vertical-align: inherit;">。これまでの読み取りAPIは、3つの関数のみで構成されています。</font></font><br>
<br>
<pre><code class="javascript">type Document = any<font></font>
type Result = any<font></font>
<font></font>
public async get(id: string): Promise&lt;Document | undefined&gt;<font></font>
<font></font>
public async gettop(code: string): Promise&lt;Document | undefined&gt;<font></font>
<font></font>
public async reduce(<font></font>
    filter: (result: Result, doc: Document) =&gt; Promise&lt;boolean&gt;, <font></font>
    reducer: (result: Result, doc: Document) =&gt; Promise&lt;void&gt;,<font></font>
    result: Result<font></font>
): Promise&lt;Result&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の関数は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">id</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でドキュメントを返し、2番目は指​​定された</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">最後のドキュメントを返し、</font><font style="vertical-align: inherit;">3番目はフィルターとたたみ込み関数を実行して、フィルター関数、たたみ込み関数、およびバッテリーの初期値を入力として受け取ります。意図的に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィルター（）を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用しないでください</font><i><font style="vertical-align: inherit;">。</font></i><font style="vertical-align: inherit;">最終結果をキャッシュしたいので、</font><i><font style="vertical-align: inherit;">削減（）</font></i><font style="vertical-align: inherit;">チェーン</font><i><font style="vertical-align: inherit;">を</font></i><font style="vertical-align: inherit;">使用し</font><i><font style="vertical-align: inherit;">ます。</font></i><font style="vertical-align: inherit;">チェーン</font><font style="vertical-align: inherit;">の場合、フィルター結果を個別にキャッシュするのは無駄であり、フィルター条件を知らずにたたみ込み結果をキャッシュしても意味がありません。したがって、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reduce（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は入力で計算に必要なすべてのものをすぐに受け取り、3つのパラメーターからの複合ハッシュをメモ化キーとして使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、ユーザーアルゴリズム全体が</font><i><font style="vertical-align: inherit;">フィルター</font></i><font style="vertical-align: inherit;">コールバックの実装です</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reducer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そして結果のバッテリーは任意のシリアライズ可能なオブジェクトにすることができます。</font><font style="vertical-align: inherit;">両方のコールバックがpromiseを返すことに注意してください。つまり、ネストされた</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reduce（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リクエストはそれらの中で許可されます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">promiseのおかげで、ネストされたループ（たとえば、現在のドキュメントの行に沿って）を並列化できます（2番目のテストを参照）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期データ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
購入と販売の会計の最も単純なシステムを考えてみましょう。</font><font style="vertical-align: inherit;">取引先や専門用語の参考図書、売買書類が必要です。</font><font style="vertical-align: inherit;">費用とマージンのコストを考慮したい場合は、別のドキュメントが必要です-収入と費用の比較ですが、これは別の記事のトピックです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パートナーと命名法</font></font></b><br>
<br>
<pre><code class="json">{<font></font>
    "sys": {<font></font>
        "code": "partner.1",<font></font>
        "ts": 1578263624612,<font></font>
        "id": "partner.1^1578263624612",<font></font>
        "cache": 1     <font></font>
    },<font></font>
    "type": "partner.retail",<font></font>
    "name": "   "<font></font>
}<font></font>
{<font></font>
    "sys": {<font></font>
        "code": "invent.1",<font></font>
        "ts": 1578263624612,<font></font>
        "id": "invent.1^1578263624612",<font></font>
        "cache": 1     <font></font>
    },<font></font>
    "type": "invent.material",<font></font>
    "name": "  20"<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
属性</font><font style="vertical-align: inherit;">はカスタムであり、その階層はカーネルでは決して使用されず、カスタムアルゴリズムでのみ使用されます。</font><font style="vertical-align: inherit;">また、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性のセマンティクスは重要ではありません</font><font style="vertical-align: inherit;">-カーネルの場合、それは単なる文字列です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ショッピングと販売</font></font></b><br>
<br>
<pre><code class="json">{<font></font>
    "sys": {<font></font>
        "code": "purch.1",<font></font>
        "ts": 1578263624613,<font></font>
        "id": "purch.1^1578263624613"  <font></font>
    },<font></font>
    "type": "purch",<font></font>
    "date": "2020-01-07",<font></font>
    "partner": "partner.3^1578263624612",<font></font>
    "lines": [<font></font>
        {<font></font>
            "invent": "invent.0^1578263624612",<font></font>
            "qty": 2,<font></font>
            "price": 232.62838134273366<font></font>
        },<font></font>
        {<font></font>
            "invent": "invent.1^1578263624917",<font></font>
            "qty": 24,<font></font>
            "price": 174.0459600393788<font></font>
        }<font></font>
    ]<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドキュメントはタイプ（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">purch | sale</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">のみが異なり</font><font style="vertical-align: inherit;">、行はドキュメントに直接格納されます（リレーショナルスキームでは、別のテーブルにあります）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズムの実装</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">売上高の分析</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
総売上高、平均請求額、およびドキュメントごとの平均行数を考慮します。</font></font><br>
<br>
<pre><code class="javascript">import { FuncDB } from './FuncDB.ts'<font></font>
const db = FuncDB.open('./sample_database/')<font></font>
<font></font>
let res = await db.reduce(<font></font>
    async (_, doc) =&gt; doc.type == 'sale',  //   <font></font>
    async (result, doc) =&gt; {<font></font>
        result.doccou++<font></font>
        doc.lines.forEach(line =&gt; {  //    <font></font>
            result.linecou++<font></font>
            result.amount += line.price * line.qty<font></font>
        })<font></font>
    },<font></font>
    {amount: 0, doccou: 0, linecou: 0}  //  <font></font>
)<font></font>
<font></font>
console.log(`<font></font>
    amount total = ${res.amount}<font></font>
    amount per document = ${res.amount / res.doccou}<font></font>
    lines per document = ${res.linecou / res.doccou}`<font></font>
)</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アイテムおよびパートナー別の回転率</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
実際、これは要約表なので、マップをバッテリーとして使用します。</font></font><br>
<br>
<pre><code class="javascript">class ResultRow { //   <font></font>
    invent_name = ''<font></font>
    partner_name = ''<font></font>
    debit_qty = 0<font></font>
    debit_amount = 0<font></font>
    credit_qty = 0<font></font>
    credit_amount = 0<font></font>
}<font></font>
<font></font>
let res = await db.reduce(<font></font>
    async (_, doc) =&gt; doc.type == 'purch' || doc.type == 'sale',<font></font>
    async (result, doc) =&gt; {<font></font>
        //      await -   <font></font>
        const promises = doc.lines.map(async (line) =&gt; {<font></font>
            const key = line.invent + doc.partner<font></font>
            let row = result.get(key)<font></font>
            if (row === undefined) {<font></font>
                row = new ResultRow()<font></font>
                //      ( )<font></font>
                row.invent_name = (await db.get(line.invent))?.name ?? ' not found'<font></font>
                row.partner_name = (await db.get(doc.partner))?.name ?? ' not found'<font></font>
                result.set(key, row)<font></font>
            }<font></font>
            if (doc.type == 'purch') {<font></font>
                row.debit_qty += line.qty<font></font>
                row.debit_amount += line.qty * line.price<font></font>
            } else if (doc.type == 'sale') {<font></font>
                row.credit_qty += line.qty<font></font>
                row.credit_amount += line.qty * line.price<font></font>
            }<font></font>
        })<font></font>
        await Promise.all(promises)<font></font>
    },<font></font>
    new Map&lt;string, ResultRow&gt;() //   ()<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードのほぼ半分がサブクエリの名前を取得していることがわかります。</font><font style="vertical-align: inherit;">これはサービス関数を作成することで簡単に修正できますが、一般的な理解のためにそのままにしておきます。</font><font style="vertical-align: inherit;">行の処理を並列化していることに注意してください-アイテムがキャッシュにない場合-フルスキャンが起動されます。この場合、結果は待つ必要はありません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベンチマーク</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生成されたデータでのテスト：</font></font><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不変ストレージ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：100 </font><b><font style="vertical-align: inherit;">項目</font></b><font style="vertical-align: inherit;"> + 100の相手方+ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10万</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文書</font></font><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のストレージ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：10項目+ 10の相手方+ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1万</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は文書</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
で先史時代のノートパソコンを使用する</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.16 GHzプロセッサ@インテルCeleronのCPU N2830 </font></font></i><br>
<br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我々は最初のテストでは</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャッシングを証明-最初に販売分析を開始してから、新しい販売ドキュメントを追加して、計算を再開します。</font><font style="vertical-align: inherit;">2回目は不変ストレージが処理されず、計算が10倍高速であることがわかります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果-11.1秒で10万件のドキュメント：</font></font></b><div class="spoiler_text"><i>file: database_immutable.json:<br>
 100200 docs parsed (0 errors)<br>
 50018 docs processed (0 errors)<br>
 <b>11.098s</b> elapsed<br>
file: database_current.json:<br>
 10020 docs parsed (0 errors)<br>
 4987 docs processed (0 errors)<br>
 <b>1.036s</b> elapsed<br>
amount total = 623422871.2641689<br>
amount per document = 11389.839613851627<br>
lines per document = 3.6682561432355896<br>
<br>
file: database_current.json:<br>
 10021 docs parsed (0 errors)<br>
 4988 docs processed (0 errors)<br>
 <b>1.034s</b> elapsed<br>
amount total = 623433860.2641689<br>
amount per document = 11389.832290707558<br>
lines per document = 3.6682073954983925</i></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正直なところ、1秒あたり少なくとも100万件のドキュメントを頼りにしていた。我々は最初のファイルの処理の例を使用して主遅延持ってどこを見てみましょう：</font></font><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.8s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -ファイルを読み取り、JSONは「\で区切られた文字列を抽出</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X01</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」</font></font><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.9s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -にJSONをパースを</font></font><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.4秒</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のオブジェクトを</font><font style="vertical-align: inherit;">- +ユーザアルゴリズムをキャッシュが</font><b><font style="vertical-align: inherit;">見えた</font></b></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
時</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電王源</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイトクラッシャーとしてのV8はうまく機能しないため、Unicodeのデコード時に主な遅延が発生します。つまり、重要な部分をWASM / Rustに書き換えることは非常に簡単であり、通常のオブジェクトデータベースをストレージとして使用すると、JSON解析を回避でき、1秒あたり100万レコードに到達することは現実的ではありません。そして、私は通常の鉄について話しているのではありません。</font><font style="vertical-align: inherit;">最初に新しく生成されたベースで</font></font><br>
<br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目のテスト</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を実行し、次に最初のテストを実行した後。 2回目は、パフォーマンスが3倍に低下しました。最初のテストで、存在しないパートナーとアイテムを参照する販売ドキュメントを追加し、それらをキャッシュ内で見つけられなかったため、システムがフルスキャンを2回実行するよう強制されたためです。しかし、この状況は本質的に緊急であり、通常は次のようになります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結果-13.3秒で10万件のドキュメント：</font></font></b><div class="spoiler_text"><i>file: database_immutable.json:<br>
 100200 docs parsed (0 errors)<br>
 100000 docs processed (0 errors)<br>
 <b>13.307s</b> elapsed<br>
file: database_current.json:<br>
 10020 docs parsed (0 errors)<br>
 10000 docs processed (0 errors)<br>
 <b>1.296s</b> elapsed</i><br>
invent name | partner name | debet qty | debet amount | credit qty | credit amount | balance amount<br>
===========================================================================<br>
invent 92 | partner 50 | 164 | 34795.53690513125 | 338 | 64322.24591475369 | -29526.709009622435<br>
invent 44 | partner 32 | 285 | 57382.115033253926 | 209 | 43572.164405352596 | 13809.95062790133<br>
invent 95 | partner 32 | 340 | 73377.08274368728 | 205 | 42007.69685305944 | 31369.38589062784<br>
invent 73 | partner 32 | 325 | 57874.269249290744 | 300 | 58047.56414301135 | -173.29489372060198<br>
invent 39 | partner 32 | 333 | 69749.88883753444 | 415 | 86369.07805766111 | -16619.189220126675<br>
invent 80 | partner 49 | 388 | 74965.03809449819 | 279 | 51438.03787960939 | 23527.0002148888<br>
invent 99 | partner 49 | 337 | 69360.84770099446 | 292 | 58521.2605634746 | 10839.587137519862<br>
invent 38 | partner 45 | 302 | 63933.21291162898 | 217 | 44866.95192796074 | 19066.26098366824<br>
invent 34 | partner 45 | 343 | 69539.75051653324 | 205 | 41155.65340219566 | 28384.09711433758<br>
invent 41 | partner 45 | 278 | 63474.209440233106 | 258 | 45246.446456763035 | 18227.76298347007<br>
 &lt; tail skipped &gt;</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、ワークロードがなくなり、2つのネストされた非同期リクエストを作成し、ユーザーアルゴリズムのコスト（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.6秒）を取得し</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">Promiseで関数をラップすることは不採算であり、私たちの場合、キャッシュリクエストは同期的に実行され、おそらくこの場所を最適化する必要があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、私は結果に満足しています。スキームはかなり機能していることがわかりました。誰かが考えを持っている場合は、プロジェクトを開発できます。</font><font style="vertical-align: inherit;">完全なテストに必要な</font><font style="vertical-align: inherit;">現実に近い難読化された公開データ（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">請求書</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EDI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">など）</font><font style="vertical-align: inherit;">へのリンクに感謝し</font><font style="vertical-align: inherit;">ます。</font><b><font style="vertical-align: inherit;">UPD </font></b></font><br>
<br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">githubの完全なコード</font></font></a></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;"> 1）</font></b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">トピックの記事</font></a><font style="vertical-align: inherit;">、ありがとう</font></font><br>
<br>
<b><font style="vertical-align: inherit;"></font></b><br>
<b><font style="vertical-align: inherit;"></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VolCh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">先端のため。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同様のアプローチが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CouchDB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">実装されています。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">能力</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">先端のため。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS </font></font></b><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">続きはこちら</font></font></b></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja482928/index.html">Predator Vision：Thermal Vision Effect</a></li>
<li><a href="../ja482930/index.html">系図調査-計量図書、国勢調査、アーカイブ、オープンデータベース</a></li>
<li><a href="../ja482932/index.html">IIoT-または、従業員が意図したとおりに脳を使用できるようにする方法</a></li>
<li><a href="../ja482934/index.html">ERPプロジェクトの失敗（Liqui Moly、Otto、および彼のような他の人）</a></li>
<li><a href="../ja482936/index.html">ASGIの概要：非同期Python Webエコシステムの構築</a></li>
<li><a href="../ja482940/index.html">先週のフロントエンドの世界からの新鮮な食材のダイジェストNo.396（2019年12月30日〜2020年1月5日）</a></li>
<li><a href="../ja482942/index.html">古代のフェディバースの神話と伝説</a></li>
<li><a href="../ja482944/index.html">多成分コンベヤディスペンサー</a></li>
<li><a href="../ja482946/index.html">1СDSSおよびCOCOMO II法によるプロジェクトの期間とコストの見積もり</a></li>
<li><a href="../ja482948/index.html">「1、2、3-クリスマスツリーを燃やす！」または、CANNY 3の小さなコントローラーを初めて見て</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>