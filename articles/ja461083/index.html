<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🔧 ⚛️ 📕 クライアント/サーバーユーティリティWindowsの機能を備えたソフトウェアの作成、パート02 👩🏾 🕊️ 🧖🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Windowsコンソールユーティリティのカスタム実装に関する一連の記事を続けると、TFTP（Trivial File Transfer Protocol）は単純なファイル転送プロトコルです。
 
 前回と同様に、理論について簡単に説明し、必要なものと同様の機能を実装するコードを見て、それを分析します...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>クライアント/サーバーユーティリティWindowsの機能を備えたソフトウェアの作成、パート02</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461083/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windowsコンソールユーティリティのカスタム実装に関する一連の記事を続けると、TFTP（Trivial File Transfer Protocol）は単純なファイル転送プロトコルです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前回と同様に、理論について簡単に説明し、必要なものと同様の機能を実装するコードを見て、それを分析します。</font><font style="vertical-align: inherit;">続きを読む-アンダーカット</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
参照情報をコピーアンドペーストしないでください。リンクは記事の最後にありますが、TFTPは基本的に、アクセス制御設定が削除されたFTPプロトコルの単純化されたバリエーションであり、ファイルを受信して​​転送するコマンド以外には何もありません。 。ただし、実装をもう少しエレガントにして、コードを記述する現在の原則に適応させるために、構文は少し変更されています。動作原理は変更されませんが、インターフェイスであるIMHOが少し論理的になり、FTPとTFTPの良い面を組み合わせています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に、起動時に、クライアントはサーバーのIPアドレスとカスタムTFTPが開いているポートを要求します（標準プロトコルとの互換性がないため、ユーザーにポートを選択するオプションを残すことは適切であると考えました）。その後、接続が発生し、その結果、クライアントはコマンドの1つを送信できます- getまたはputを使用して、ファイルをサーバーに送受信します。</font><font style="vertical-align: inherit;">ロジックを簡素化するために、すべてのファイルはバイナリモードで送信されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロトの実装のために、私は伝統的に4つのクラスを使用しました：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TFTPClient </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TFTPServer </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TFTPClientTester </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TFTPServerTester </font></font></li>
</ul> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストクラスはメインクラスをデバッグするためだけに存在するため、分析はしませんが、コードはリポジトリにあります。記事へのリンクは記事の最後にあります。</font><font style="vertical-align: inherit;">そして今、私は主要なクラスを理解します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TFTPClient</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクラスのタスクは、IPとポート番号でリモートサーバーに接続し、入力ストリーム（この場合はキーボード）からコマンドを読み取り、それを解析してサーバーに転送し、ファイルを転送するか受信するかによって、転送するか、受け取る。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーに接続し、入力ストリームからのコマンドを待機するためのクライアント起動コードは、次のようになります。ここで使用されるいくつかのグローバル変数は、記事の外、プログラムの全文で説明されています。それらの平凡さのために、記事を過負荷にしないために私は引用しません。</font></font><br>
<br>
<pre><code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String ip, <span class="hljs-keyword">int</span> port)</span>
    </span>{
        <span class="hljs-keyword">this</span>.ip = ip;
        <span class="hljs-keyword">this</span>.port = port;
        <span class="hljs-keyword">try</span> {<font></font>
            inicialization();<font></font>
            Scanner keyboard = <span class="hljs-keyword">new</span> Scanner(System.in);
            <span class="hljs-keyword">while</span> (isRunning) {<font></font>
                getAndParseInput(keyboard);<font></font>
                sendCommand();<font></font>
                selector();<font></font>
                }<font></font>
            }<font></font>
        <span class="hljs-keyword">catch</span> (Exception e) {<font></font>
            System.out.println(e.getMessage());<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードブロックで呼び出されたメソッドを見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでファイルが送信されます-スキャナーを使用して、ファイルの内容をバイトの配列として提示し、ソケットに1つずつ書き込み、それを閉じて再度開きます（最も明白な解決策ではありませんが、リソースの解放を保証します） ）、その後、正常な転送に関するメッセージを表示します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String sourcePath, String destPath)</span>
    </span>{<font></font>
<font></font>
        File src = <span class="hljs-keyword">new</span> File(sourcePath);
        <span class="hljs-keyword">try</span> {<font></font>
<font></font>
            InputStream scanner = <span class="hljs-keyword">new</span> FileInputStream(src);
            <span class="hljs-keyword">byte</span>[] bytes = scanner.readAllBytes();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">byte</span> b : bytes)<font></font>
                sout.write(b);<font></font>
            sout.close();<font></font>
            inicialization();<font></font>
            System.out.println(<span class="hljs-string">"\nDone\n"</span>);<font></font>
            }<font></font>
<font></font>
        <span class="hljs-keyword">catch</span> (Exception e) {<font></font>
            System.out.println(e.getMessage());<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードフラグメントは、サーバーからのデータの受信を説明しています。すべてがささいなことですが、コードの最初のブロックだけが対象です。ソケットから読み取る必要があるバイト数を正確に理解するには、転送されたファイルの重量を知る必要があります。サーバー上のファイルサイズは長整数のように見えるため、ここでは4バイトが受け入れられ、その後1つの数値に変換されます。これは非常にJavaのアプローチではなく、SIとかなり似ていますが、その問題を解決します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、すべてが簡単です-ソケットから既知のバイト数を取得し、それらをファイルに書き込んだ後、成功メッセージを表示します。</font></font><br>
<br>
<pre><code class="java hljs">   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String sourcePath, String destPath)</span></span>{
        <span class="hljs-keyword">long</span> sizeOfFile = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">try</span> {<font></font>
<font></font>
<font></font>
            <span class="hljs-keyword">byte</span>[] sizeBytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[Long.SIZE];
           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i&lt; Long.SIZE/Byte.SIZE; i++)<font></font>
           {<font></font>
               sizeBytes[i] = (<span class="hljs-keyword">byte</span>)sin.read();<font></font>
               sizeOfFile*=<span class="hljs-number">256</span>;<font></font>
               sizeOfFile+=sizeBytes[i];<font></font>
           }<font></font>
<font></font>
           FileOutputStream writer = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(destPath));
           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt; sizeOfFile; i++)<font></font>
           {<font></font>
               writer.write(sin.read());<font></font>
           }<font></font>
           writer.close();<font></font>
           System.out.println(<span class="hljs-string">"\nDONE\n"</span>);<font></font>
       }<font></font>
       <span class="hljs-keyword">catch</span> (Exception e){<font></font>
            System.out.println(e.getMessage());<font></font>
       }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
getまたはput以外のコマンドがクライアントウィンドウに入力された場合、showErrorMessage関数が呼び出され、入力の誤りが示されます。</font><font style="vertical-align: inherit;">平凡のため-引用しません。</font><font style="vertical-align: inherit;">もう少し興味深いのは、入力文字列を取得および分割する機能です。</font><font style="vertical-align: inherit;">スキャナーを渡します。そこから、2つのスペースで区切られ、コマンド、送信元アドレス、宛先アドレスを含む行を受け取ることが期待されます。</font></font><br>
<br>
<pre><code class="java hljs">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getAndParseInput</span><span class="hljs-params">(Scanner scanner)</span>
    </span>{
        <span class="hljs-keyword">try</span> {<font></font>
<font></font>
            input = scanner.nextLine().split(<span class="hljs-string">" "</span>);<font></font>
            typeOfCommand = input[<span class="hljs-number">0</span>];<font></font>
            sourcePath = input[<span class="hljs-number">1</span>];<font></font>
            destPath = input[<span class="hljs-number">2</span>];<font></font>
        }<font></font>
        <span class="hljs-keyword">catch</span> (Exception e) {<font></font>
            System.out.println(<span class="hljs-string">"Bad input"</span>);<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コマンドの送信-スキャナーからソケットに入力されたコマンドを送信し、強制的に送信する</font></font><br>
<br>
<pre><code class="java hljs">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendCommand</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">try</span> {<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (String str : input) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : str.toCharArray()) {<font></font>
                    sout.write(ch);<font></font>
                }<font></font>
                sout.write(<span class="hljs-string">' '</span>);<font></font>
            }<font></font>
            sout.write(<span class="hljs-string">'\n'</span>);<font></font>
        }<font></font>
        <span class="hljs-keyword">catch</span> (Exception e) {<font></font>
            System.out.print(e.getMessage());<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セレクターは、入力ストリングに応じてプログラムのアクションを決定する関数です。</font><font style="vertical-align: inherit;">ここではすべてがあまり美しくなく、コードブロックをコードの制限を超えて強制的に使用するための最良の手法は使用されていませんが、これの主な理由は、C＃のデリゲート、C ++からの関数ポインター、または少なくとも恐ろしくひどいgotoなどのJavaでのいくつかの不足です。美しく実現させてください。</font><font style="vertical-align: inherit;">コードをもう少しエレガントにする方法を知っているなら-コメントでの批判を待っています。</font><font style="vertical-align: inherit;">ここには文字列デリゲート辞書が必要なようですが、デリゲートはありません...</font></font><br>
<br>
<pre><code class="java hljs">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selector</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">do</span>{
            <span class="hljs-keyword">if</span> (typeOfCommand.equals(<span class="hljs-string">"get"</span>)){<font></font>
                get(sourcePath, destPath);<font></font>
                <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (typeOfCommand.equals(<span class="hljs-string">"put"</span>)){<font></font>
                put(sourcePath, destPath);<font></font>
                <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
            showErrorMessage();<font></font>
        }<font></font>
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">false</span>);<font></font>
    }<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TFTPServer</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーの機能がクライアントの機能と大きく異なるのは、サーバーへのコマンドがキーボードからではなくソケットから来る点だけです。</font><font style="vertical-align: inherit;">いくつかの方法は一致しているので、ここでは説明しません。違いについてのみ説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで実行するには、入力用のポートを受け取り、ソケットからの入力データを永久ループで処理するrunメソッドを使用します。</font></font><br>
<br>
<pre><code class="java hljs">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>{
            <span class="hljs-keyword">this</span>.port = port;<font></font>
            incialization();<font></font>
            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {<font></font>
                getAndParseInput();<font></font>
                selector();<font></font>
            }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
書き込みが完了するとファイルへの書き込みストリームを開き、ソケットからすべての入力バイトを書き込むwriteToFileFromSocketメソッドのラッパーであるputメソッドは、転送が正常に完了したことを示すメッセージを表示します。</font></font><br>
<br>
<pre><code class="java hljs">    <span class="hljs-function"><span class="hljs-keyword">private</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String source, String dest)</span></span>{<font></font>
            writeToFileFromSocket();<font></font>
            System.out.print(<span class="hljs-string">"\nDone\n"</span>);<font></font>
    };<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeToFileFromSocket</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">try</span> {<font></font>
            FileOutputStream writer = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(destPath));
            <span class="hljs-keyword">byte</span>[] bytes = sin.readAllBytes();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">byte</span> b : bytes) {<font></font>
                writer.write(b);<font></font>
            }<font></font>
            writer.close();<font></font>
        }<font></font>
        <span class="hljs-keyword">catch</span> (Exception e){<font></font>
            System.out.println(e.getMessage());<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
getメソッドはサーバーファイルを提供します。</font><font style="vertical-align: inherit;">プログラムのクライアント側のセクションですでに述べたように、ファイルを正常に転送するには、ファイルのサイズを知っている必要があり、長整数に格納されているため、4バイトの配列に分割し、ソケットバイトに転送してから、クライアントで受信して収集した後数値に戻り、ファイルを構成するすべてのバイトを転送し、ファイルからの入力ストリームから読み取ります。</font></font><br>
<br>
<pre><code class="java hljs">
 <span class="hljs-function"><span class="hljs-keyword">private</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String source, String dest)</span></span>{<font></font>
        File sending = <span class="hljs-keyword">new</span> File(source);
        <span class="hljs-keyword">try</span> {<font></font>
            FileInputStream readFromFile = <span class="hljs-keyword">new</span> FileInputStream(sending);
            <span class="hljs-keyword">byte</span>[] arr = readFromFile.readAllBytes();
            <span class="hljs-keyword">byte</span>[] bytes = ByteBuffer.allocate(Long.SIZE / Byte.SIZE).putLong(sending.length()).array();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;Long.SIZE / Byte.SIZE; i++)<font></font>
                sout.write(bytes[i]);<font></font>
            sout.flush();<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">byte</span> b : arr)<font></font>
                sout.write(b);<font></font>
        }<font></font>
        <span class="hljs-keyword">catch</span> (Exception e){<font></font>
            System.out.println(e.getMessage());<font></font>
        }<font></font>
    };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
getAndParseInputメソッドはクライアントの場合と同じですが、キーボードからではなくソケットからデータを読み取る点が唯一の違いです。</font><font style="vertical-align: inherit;">セレクターのようなリポジトリ内のコード。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、初期化は別のコードブロックで行われます。</font><font style="vertical-align: inherit;">この実装のフレームワークでは、メモリリークに対する保護を提供する目的で、転送が完了した後、リソースが解放され、再び占有されます。</font></font><br>
<br>
<pre><code class="java hljs">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">incialization</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">try</span> {<font></font>
            serverSocket = <span class="hljs-keyword">new</span> ServerSocket(port);<font></font>
            socket = serverSocket.accept();<font></font>
            sin = socket.getInputStream();<font></font>
            sout = socket.getOutputStream();<font></font>
        }<font></font>
        <span class="hljs-keyword">catch</span> (Exception e) {<font></font>
            System.out.print(e.getMessage());<font></font>
        }<font></font>
    }</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要約：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純なデータ転送プロトコルのトピックに関するバリエーションを書いて、それがどのように機能するかを理解しました。</font><font style="vertical-align: inherit;">原則として、私はアメリカを発見しなかったし、あまり新しく書きませんでしたが、Habréに同様の記事はありませんでした。また、cmdユーティリティに関する一連の記事を書く一環として、彼に触れないようにすることは不可能でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リンク：</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコードリポジトリ</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TFTPについて簡単に</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じことですが、ロシア語です。</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja461073/index.html">オンライン地図をスマートフォンのナビゲーターに接続します。パート3-OverpassTurbo</a></li>
<li><a href="../ja461075/index.html">ビジネス分析。ITオブジェクト、コンポーネント、ツール</a></li>
<li><a href="../ja461077/index.html">ペンテスターはどのように調理されますか？デジタルセキュリティインターンの入学試験</a></li>
<li><a href="../ja461079/index.html">渋滞のない都市</a></li>
<li><a href="../ja461081/index.html">ドードーが止まった日。非同期スクリプト</a></li>
<li><a href="../ja461085/index.html">Androidアプリケーションで言語を切り替える</a></li>
<li><a href="../ja461087/index.html">ゲーム用のダンジョンと洞窟を生成する</a></li>
<li><a href="../ja461091/index.html">LED Camelionランプ</a></li>
<li><a href="../ja461093/index.html">OpenStreetMap No. 469の世界からのお知らせ（07/09/2019-07/07/2019）</a></li>
<li><a href="../ja461095/index.html">アポロガイダンスコンピューター-アーキテクチャおよびシステムソフトウェア。パート1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>