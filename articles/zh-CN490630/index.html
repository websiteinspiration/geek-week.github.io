<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐖 🐏 👩🏾‍⚕️ 从磁盘加载NumPy数组：比较memmap（）和Zarr / HDF5 ↪️ 🏥 🔌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="如果您的NumPy数组太大而无法容纳在RAM中，则可以通过将其拆分为片段来对其进行处理。您可以以透明模式进行操作，也可以通过一次从磁盘加载这些片段来显式地执行此操作。 在这种情况下，您可以使用两类工具：
 
 
 

 
 

- NumPy方法memmap()，一种透明的机制，使您可以感知磁盘上的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>从磁盘加载NumPy数组：比较memmap（）和Zarr / HDF5</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/490630/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您的NumPy数组太大而无法容纳在RAM中，则可以通过将其拆分为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片段来对其进行处理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您可以以透明模式进行操作，也可以通过一次从磁盘加载这些片段来显式地执行此操作。</font><font style="vertical-align: inherit;">
在这种情况下，您可以使用两类工具：</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/2n/8r/ck/2n8rckf95tnhx1yrkvvlfy2cf_4.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NumPy方法</font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，一种透明的机制，使您可以感知磁盘上的文件，就好像它全部在内存中一样。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr和HDF5数据存储格式彼此相似，允许在必要时从磁盘加载并将阵列的压缩片段保存到磁盘。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些方法中的每一种都有其优点和缺点。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该材料（我们今天出版的翻译）致力于分析这些数据处理方法的功能，以及在什么情况下可以派上用场的故事。</font><font style="vertical-align: inherit;">特别是，将特别注意为执行计算而优化的数据格式，而不必将其设计为将数据传输给其他程序员。</font></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从磁盘读取数据或将数据写入磁盘会发生什么？</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首次从磁盘读取文件时，操作系统不仅会将数据复制到过程内存。</font><font style="vertical-align: inherit;">首先，它将这些数据复制到其内存中，并将其副本存储在所谓的“缓冲区缓存”中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里有什么用？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事实是，如果您需要再次从同一文件读取同一数据，则操作系统会将数据存储在缓存中。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c5/896/e36/8c5896e36f5312d8e00b92103b7d037f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果再次读取数据，则它不是从磁盘而是从RAM进入程序存储器，这要快几个数量级。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf3/382/7a3/cf33827a346960cbcc33f54835b9bce3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果高速缓存占用的内存用于其他用途，则高速缓存将被自动清除。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当数据写入磁盘时，它会以相反的方向移动。</font><font style="vertical-align: inherit;">首先，它们仅写入缓冲区高速缓存。</font><font style="vertical-align: inherit;">这意味着写操作通常非常快，因为程序不需要将重点放在慢速磁盘上。</font><font style="vertical-align: inherit;">在录制期间，她只需要使用RAM。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed3/6be/592/ed36be592685ca4f42954971e000eb89.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，数据从高速缓存刷新到磁盘。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffc/0bb/0fc/ffc0bb0fc60c346671dfba89e8c78c1c.png"></div><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用memmap处理数组（）</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的情况下，</font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它使我们可以感知磁盘上的文件，就好像它是存储在内存中的数组一样。</font><font style="vertical-align: inherit;">对程序透明的操作系统根据是否将请求的数据缓存在内存中来执行读/写操作，访问缓冲区缓存或硬盘。</font><font style="vertical-align: inherit;">这样的算法在这里执行：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据在缓存中吗？</font><font style="vertical-align: inherit;">如果是的话-非常好-您可以直接与他们联系。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据在磁盘上吗？</font><font style="vertical-align: inherit;">访问它们的速度较慢，但​​是您不必担心，它们将以透明模式加载。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外</font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要注意的是，在大多数情况下，文件的缓冲区高速缓存将内置到程序存储器中。</font><font style="vertical-align: inherit;">这意味着系统不必在缓冲区外的程序存储器中维护数据的其他副本。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47e/922/86e/47e92286e0761142e8f411c84d188e76.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该方法</font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内置在NumPy中：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<font></font>
array = np.memmap(<span class="hljs-string">"mydata/myarray.arr"</span>, mode=<span class="hljs-string">"r"</span>,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtype=np.int16, shape=(<span class="hljs-number">1024</span>, <span class="hljs-number">1024</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
运行此代码，您将拥有一个数组供您使用，该数组的工作对于程序是完全透明的-不管是使用缓冲区高速缓存还是使用硬盘进行工作。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memmap（）的局限性</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管在某些情况下它</font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以很好地显示自己，但是此方法也有局限性：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据必须存储在文件系统中。</font><font style="vertical-align: inherit;">无法从AWS S3等二进制存储下载数据。</font></font></li>
<li>        ,      .   ,       . ,           ,  ,      .</li>
<li>   N-        ,      ,        ,        .         .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们解释最后一点。</font><font style="vertical-align: inherit;">想象一下，我们有一个包含32位（4字节）整数的二维数组。</font><font style="vertical-align: inherit;">每个磁盘读取4096个字节。</font><font style="vertical-align: inherit;">如果您从磁盘顺序读取位于文件中的数据（例如，这些数据在数组的行中），则在每次读取操作之后，我们将有1024个整数。</font><font style="vertical-align: inherit;">但是，如果您读取的数据在文件中的位置与数组中的位置不匹配（例如，数据位于列中），则每次读取操作将只允许您获得1个必需的编号。</font><font style="vertical-align: inherit;">结果，事实证明，要获得相同数量的数据，您必须执行一千次以上的读取操作。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr和HDF5</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了克服上述限制，您可以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或HDF5 </font><font style="vertical-align: inherit;">数据存储格式</font><font style="vertical-align: inherit;">，它们非常相似：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pytables</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h5py</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Python中使用HDF5文件</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这种格式比Zarr还要旧，并且有更多限制，但是它的优点是可以在以不同语言编写的程序中使用。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr是使用同名的Python包实现的格式。</font><font style="vertical-align: inherit;">它比HDF5更现代，更灵活，但您只能（至少现在）在Python环境中使用它。</font><font style="vertical-align: inherit;">根据我的感觉，在大多数情况下，如果不需要对HDF5的多语言支持，值得选择Zarr。</font><font style="vertical-align: inherit;">例如，Zarr具有更好的多线程支持。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，我们将仅讨论Zarr，但是如果您对HDF5格式及其与Zarr的更深层次的比较感兴趣，则可以观看</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用Zarr</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zarr允许您以数组的形式存储数据并将其加载到内存中，并且-以数组的形式写入这些数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是使用Zarr加载数组的方法：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> zarr, numpy <span class="hljs-keyword">as</span> np
<span class="hljs-meta">&gt;&gt;&gt; </span>z = zarr.open(<span class="hljs-string">'example.zarr'</span>, mode=<span class="hljs-string">'a'</span>,
<span class="hljs-meta">... </span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shape=(<span class="hljs-number">1024</span>, <span class="hljs-number">1024</span>),
<span class="hljs-meta">... </span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunks=(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>), dtype=np.int16)
<span class="hljs-meta">&gt;&gt;&gt; </span>type(z)<font></font>
&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">zarr</span>.<span class="hljs-title">core</span>.<span class="hljs-title">Array</span>'&gt;
&gt;&gt;&gt; <span class="hljs-title">type</span>(<span class="hljs-params">z[<span class="hljs-number">100</span>:<span class="hljs-number">200</span>]</span>)
&lt;<span class="hljs-title">class</span> '<span class="hljs-title">numpy</span>.<span class="hljs-title">ndarray</span>'&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，在收到物体的一部分之前，我们将不予处置</font></font><code>numpy.ndarray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">实体</font></font><code>zarr.core.array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就是元数据。</font><font style="vertical-align: inherit;">仅从磁盘中加载切片中包含的数据。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我为什么选择Zarr？</font></font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr规避</font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了上面讨论</font><font style="vertical-align: inherit;">的限制</font><font style="vertical-align: inherit;">：</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据片段可以存储在磁盘上，AWS S3存储中或某些可以使用键/值格式记录的存储系统中。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据片段的大小和结构由程序员确定。</font><font style="vertical-align: inherit;">例如，可以以能够有效地读取位于多维阵列的不同轴上的信息的方式来组织数据。</font><font style="vertical-align: inherit;">HDF5确实如此。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片段可以压缩。</font><font style="vertical-align: inherit;">HDF5也可以这样说。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们更详细地讨论最后两点。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片段尺寸</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设我们正在处理大小为30,000 x 3,000的数组。</font><font style="vertical-align: inherit;">如果您需要读取此数组并沿其轴</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移动，并沿其轴移动</font></font><code>Y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则可以保存包含该数组数据的片段，如下所示（实际上，很可能需要9个以上的片段）：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c3/ef4/df7/8c3ef4df7f8f782bbc28e998913f8e34.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，</font><font style="vertical-align: inherit;">可以有效地加载</font><font style="vertical-align: inherit;">轴</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和轴上的</font><font style="vertical-align: inherit;">数据</font></font><code>Y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">根据程序所需的数据类型，您可以下载例如片段（1、0），（1、1，），（1、2）或片段（0、1），（1、1）， （2，1）。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资料压缩</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个片段都可以压缩。</font><font style="vertical-align: inherit;">这意味着数据可以比磁盘允许您读取未压缩信息的速度更快地进入程序。</font><font style="vertical-align: inherit;">如果将数据压缩3次，则意味着从磁盘上下载数据的速度是未压缩数据的3倍，减去处理器解压缩数据所花费的时间。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/677/f42/f3f/677f42f3fc5539051f4adeb8f391684a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下载片段后，可以将其从程序存储器中删除。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要：memmap（）或Zarr？</font></font></font></h2><br><font style="vertical-align: inherit;"></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用哪种</font><font style="vertical-align: inherit;">
更好- </font><font style="vertical-align: inherit;">还是Zarr？</font></font><br>
<br>
<code>Memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下看起来很有趣：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有许多进程读取同一文件的各个部分。</font><font style="vertical-align: inherit;">由于应用程序的缘故，这些进程</font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将能够共享相同的缓冲区缓存。</font><font style="vertical-align: inherit;">这意味着无论正在运行多少个进程，都只需将数据的一个副本保留在内存中。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开发人员不希望手动管理内存。</font><font style="vertical-align: inherit;">他计划仅依靠操作系统的功能，该功能将自动，无形地解决开发人员的所有内存管理问题。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zarr在以下情况下特别有用（在某些情况下，如将要指出的，HDF5格式也适用）：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据是从远程源而不是从本地文件系统下载的。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统的瓶颈很可能将从磁盘读取。</font><font style="vertical-align: inherit;">数据压缩将允许更有效地利用硬件功能。</font><font style="vertical-align: inherit;">这也适用于HDF5。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果需要获取沿不同轴的多维数组的切片，Zarr通过选择适当的片段大小和结构来帮助优化此类操作。</font><font style="vertical-align: inherit;">HDF5确实如此。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我会在</font></font><code>memmap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zarr </font><font style="vertical-align: inherit;">之间进行选择，</font><font style="vertical-align: inherit;">并且首先尝试使用Zarr-因为此包提供了灵活性以及它实现的数据存储格式。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">亲爱的读者们！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您如何解决使用大型NumPy阵列的问题？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN490620/index.html">当我听到“恢复神经网络”一词时，我爬上去检查备份</a></li>
<li><a href="../zh-CN490622/index.html">应对Web应用程序中的内存泄漏</a></li>
<li><a href="../zh-CN490624/index.html">功能策略HTTP标头和Web浏览器控件</a></li>
<li><a href="../zh-CN490626/index.html">有关数据的完整指南* HTML属性</a></li>
<li><a href="../zh-CN490628/index.html">CSS阻止页面解析时该怎么办？</a></li>
<li><a href="../zh-CN490634/index.html">3月2日至8日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN490636/index.html">3月2日至8日在圣彼得堡举行的数字活动</a></li>
<li><a href="../zh-CN490640/index.html">C ++中的重载。第三部分 重载新/删除语句</a></li>
<li><a href="../zh-CN490642/index.html">用于监视K8s应用程序的插件DevOpsProdigy KubeGraf v1.3.0：新版本和新功能</a></li>
<li><a href="../zh-CN490644/index.html">使用Inotify和Webdav的简单rpm存储库</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>