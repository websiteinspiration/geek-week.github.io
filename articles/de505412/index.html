<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👤 🗞️ 🕊️ Sicherer Zugang zu einem Smart Home ohne öffentliche IP (Teil 2) 👰🏿 🐪 🧘🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung
 Im ersten Teil schrieb ich über die Problemstellung und wie die Wunschliste transformiert wurde. Am Ende habe ich mich für OpenVPN entschi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Sicherer Zugang zu einem Smart Home ohne öffentliche IP (Teil 2)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505412/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im ersten Teil schrieb</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ich über die Problemstellung und wie die Wunschliste transformiert wurde. </font><font style="vertical-align: inherit;">Am Ende habe ich mich für OpenVPN entschieden, aber aufgrund der Tatsache, dass ich beschlossen habe, alles in Docker-Containern auszuführen, stellte sich heraus, dass dies nicht so einfach war. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich muss sofort sagen, dass ich später alles noch einmal überarbeitet habe, wodurch ich einen externen VPS abgelehnt habe. </font><font style="vertical-align: inherit;">Da sich jedoch alles in Containern befindet, bin ich dabei auf eine Reihe interessanter Funktionen gestoßen, die diskutiert werden.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Installation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde nur wichtige Punkte beschreiben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioBroker</font></font></h3><br>
<pre><code class="plaintext hljs">docker run -d --name iobhost  --net=host -v /opt/iobroker/:/opt/iobroker/ --device=/dev/ttyACM0 --env-file /opt/ioBroker_env.list --restart=always buanet/iobroker:latest
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da ich ein MiHome-Gateway habe, sind Sensoren daran angeschlossen, es sind sogar mehrere Szenarien eingerichtet, die ich noch nicht brechen möchte, ich habe ioBroker daran angeschlossen. Er sah die Sensoren, er musste sie nicht wieder an den ZigBee-Stick binden (obwohl es auch solche gibt und einige Tasten damit verbunden sind). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier, damit ioBroker MiHome Gateway kontaktieren und mit dem Parameter --net = host starten kann. Jene. Es verwendet die Host-Schnittstelle. Sie müssen nicht angeben, welche Ports an den Container weitergeleitet werden sollen. Ohne dies könnte er das Gateway nicht sehen, da er über Multicast arbeitet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Parameter --device = / dev / ttyACM0 wird benötigt, um den ZigBee USB-Stick an den Container weiterzuleiten. </font><font style="vertical-align: inherit;">Auch in /opt/ioBroker_env.list musste ich die Zeile USBDEVICES = "/ dev / ttyACM0" hinzufügen. </font><font style="vertical-align: inherit;">Es ist wichtig, dass diese Zeile zum Zeitpunkt des ersten Starts des Containers vorhanden ist, wenn ein leeres Verzeichnis angezeigt wird und die Erstkonfiguration beginnt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können es natürlich später konfigurieren, aber Sie müssen zusätzliche Körperbewegungen ausführen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MQTT-Server</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf einem externen VPS wurde eine Eclipse-Mücke gestartet. </font><font style="vertical-align: inherit;">Zuerst habe ich TLS für ihn eingerichtet, indem ich ein Let's-Verschlüsselungszertifikat ausgestellt habe. </font><font style="vertical-align: inherit;">Dann entschied er, dass die Kunden das Zertifikat vorlegen müssen und erst dann den Namen und das Passwort (Schutz vor Bruteforce). </font><font style="vertical-align: inherit;">Also habe ich es auf selbstsigniert umgestellt, damit Kunden Zertifikate ausschreiben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Openvpn</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwendete beliebte Bilder mit dem Docker Hub. </font><font style="vertical-align: inherit;">Für Server (VPS) kylemanna / openvpn. </font><font style="vertical-align: inherit;">Für den Client (den Heimserver, auf dem ioBroker installiert ist) - ekristen / openvpn-client.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anpassung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier musste ich basteln. </font><font style="vertical-align: inherit;">Dabei fühlte ich, dass die Netzwerkaspekte des Dockers bei der Arbeit mit iptables einen neuen entdeckten, einschließlich </font><font style="vertical-align: inherit;">Netplan, mit dem ich vorher nichts zu tun hatte. </font><font style="vertical-align: inherit;">Eigentlich habe ich mich daher entschlossen, diesen Artikel zu schreiben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VPS-Server</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Installation von OpenVPN und der Konfiguration ist alles Standard, wie unter </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://hub.docker.com/r/kylemanna/openvpn beschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ich zusätzlich getan habe, war, zusätzliche Loopbacks auf dem VPS und dem Heimserver auszulösen. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/etc/netplan/01-netcfg.yaml</font></font></i><br>
<br>
<pre><code class="plaintext hljs">	# This file describes the network interfaces available on your system<font></font>
	# For more information, see netplan(5).<font></font>
	network:<font></font>
	  version: 2<font></font>
	  renderer: networkd<font></font>
	  &lt;b&gt;ethernets:<font></font>
	    lo:<font></font>
	      renderer: networkd<font></font>
	      match:<font></font>
	        name: lo<font></font>
	      addresses:<font></font>
        - 192.168.16.1/32&lt;/b&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fett hervorgehoben das "Additiv". Leerzeichen scheinen nicht angezeigt zu werden, obwohl sie sehr wichtig sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Adressen in den Beispielen verwenden 192.168.6.0 für das Heimnetzwerk und 192.168.16.0 für Loopback. Ich werde versuchen, nirgendwo einen Fehler zu machen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">openvpn.conf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hinzugefügt</font></font><br>
<br>
<pre><code class="plaintext hljs">server 192.168.16.192 255.255.255.192<font></font>
push "dhcp-option DNS 192.168.16.6"<font></font>
push "route 192.168.16.0 255.255.255.128"<font></font>
client-to-client<font></font>
client-config-dir       /etc/openvpn/ccd/</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe speziell einen Loopback von 192.168.16.0/25 erstellt und Adressen von 192.168.16.128/25 an Clients ausgegeben, damit anschließend die Auflösungsregeln in iptables mit einem einzelnen Grid konfiguriert werden können. 192.168.16.0/24 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VPS hat also einen Loopback von 192.168.16.1, auf dem mqtt gespeichert ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Heimserver hat 192.168.16.6. Es gibt iobroker, auch bekannt als DNS für Heimkunden, und definiert eine Reihe von Domänennamen für die Verbindung von einem Heimnetzwerk oder über ein VPN neu. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überall gab es die Idee, seine "echte" IP aus dem Netzwerk zu registrieren. Geben Sie ccd / iobroker ein, um </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iroute 192.168.6.6 255.255.255.255 </font><font style="vertical-align: inherit;">anzugeben</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber anscheinend aufgrund der Tatsache, dass dies eine Adresse aus dem Netzwerk auf der WiFi-Schnittstelle des Heim-Laptops ist und in vielen Fällen das Standard-Gateway ist, gab es Störungen. Einschließlich mit einem Smartphone. Und ich wollte, dass das Heimnetzwerk sowohl mit einem aktiven Kunden als auch ohne ihn funktioniert. Und ich musste den Client nicht hektisch trennen und nach Hause kommen, um Zugriff auf andere Ressourcen zu erhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher habe ich diesen Server und seine Container so konfiguriert, dass sie immer mit Loopback interagieren, unabhängig davon, ob das VPN aktiv ist. Und die gleiche Adresse wurde angesprochen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ccd / iobroker</font></font></i><br>
<br>
<pre><code class="plaintext hljs">iroute 192.168.16.6 255.255.255.255</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, alle VPN-Clients wissen, dass das Netzwerk 192.168.16.0/24 über ein VPN zugänglich ist. Wenn sie Pakete an 192.168.16.1 (Loopback-VPS) senden, wird das Paket verschlüsselt, in den openvpn-Container übertragen, entschlüsselt, die Standardroute geht zu 172.17.0.1 (Standard-Gateway in den Standardcontainern), es gelangt zum Host, alles ist in Ordnung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber wie kann ich den VPN-Client vom VPS-Host aus "pingen" oder auf den Heimserver mit der Adresse 192.168.16.6 zugreifen (und nicht mit seiner temporären IP im VPN-Tunnel, der sich im OpenVPN-Container befindet)? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Offensichtlich muss das Netz 192.168.16.0 an den OpenVPN-Container weitergeleitet werden. Natürlich kann ich sehen, dass es 172.17.0.3 ist. Aber eines Tages könnte sich das ändern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn OpenVPN direkt auf dem Server und nicht im Container bereitgestellt würde, würde alles von selbst funktionieren. </font><font style="vertical-align: inherit;">Und dann musste ich es schlau machen. </font><font style="vertical-align: inherit;">Ich erstelle ein Skript, das von den neuesten im System ausgearbeitet wird, und füge es ein:</font></font><br>
<br>
<pre><code class="plaintext hljs">ipaddr=$(docker inspect -f '{{.NetworkSettings.IPAddress}}' vpn-client)<font></font>
route add -net 192.168.16.0/24 gw $ipaddr</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jene. </font><font style="vertical-align: inherit;">Durch Docker Inspect finde ich die IP-Adresse des laufenden Containers heraus und leite das Grid dann auf die übliche Weise dorthin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Gegensatz zum üblichen rc.local musste ich es googeln, aber wie man tatsächlich ein Skript erstellt, das zuletzt ausgeführt wird. </font><font style="vertical-align: inherit;">Hier eine kurze Anleitung: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie die Datei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/etc/systemd/system/custom.target</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="plaintext hljs">[Unit] <font></font>
Description=My Custom Target<font></font>
Requires=multi-user.target<font></font>
After=multi-user.target<font></font>
AllowIsolate=yes<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie die Datei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/etc/systemd/system/last_command.service</font></font></i> <br>
<br>
<pre><code class="plaintext hljs">[Unit]<font></font>
Description=My custom command<font></font>
After=multi-user.target<font></font>
[Service]<font></font>
Type=simple<font></font>
ExecStart=/usr/local/bin/my_last_command.sh<font></font>
[Install]<font></font>
WantedBy=custom.target<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie das Verzeichnis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/etc/systemd/system/custom.target.wants</font></font></i><br>
<br>
<pre><code class="plaintext hljs">ln -s /etc/systemd/system/last_command.service \   /etc/systemd/system/custom.target.wants/last_command.service<font></font>
systemctl daemon-reload<font></font>
systemctl set-default custom.target</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sofort starten möchten, ohne auf einen Neustart zu warten: systemctl isolate custom.target </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Neustart </font><font style="vertical-align: inherit;">wird die in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExecStart</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beschriebene </font><font style="vertical-align: inherit;">Datei </font><font style="vertical-align: inherit;">/usr/local/bin/my_last_command.sh </font><font style="vertical-align: inherit;">als letzte gestartet </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iptables</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf dem mqtt-Server habe ich zwei Ports ausgelöst: 8883 mit TLS und Authentifizierung, auf die über Remote-Sensoren über das Internet zugegriffen werden kann. Ja, und ich selbst kann den MQTT Explorer irgendwie verbinden und überprüfen, was und wie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1883 bereits ohne TLS, benötigt nur einen Benutzernamen und ein Passwort. Benötigt für zu Hause Sonoff rfBridge, die TLS nicht weiß wie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist nicht beängstigend, da der Datenverkehr von zu Hause mit iobroker, dem Standard-Gateway für 192.168.16.0, zum Server geleitet wird und das Paket an einen Container mit OpenVPN usw. weiterleitet. Sie müssen den Zugriff auf Port 1883 jedoch nur von innen zulassen. Jene. iptables. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Standardansatz besteht darin, den Zugriff auf diesen Port von überall zu verweigern und dann die Regel zu befolgen, die den Zugriff von internen Netzwerken aus ermöglicht.</font></font><br>
<br>
<pre><code class="plaintext hljs">iptables -I INPUT -p tcp -m tcp --dport 1883 -j DROP<font></font>
iptables -I INPUT -s 172.17.0.0/24 -p tcp -m tcp --dport 1883 -j ACCEPT</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Raster wird hier mit 172.17.0.0 angegeben, da ich von OpenVPN zu den „Nachbarn“ als Hide-NAT (ein Iobroker-Container, der von rfBridge aus einem WiFi-Netzwerk stammt) und nicht von den ursprünglichen gehe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so funktioniert es. </font><font style="vertical-align: inherit;">Aber es gibt eine Nuance. </font><font style="vertical-align: inherit;">Mein Port 1883 wird an den mqtt-Container weitergeleitet. </font><font style="vertical-align: inherit;">Und wie sich herausstellte, erfüllt iptables zuerst die DOCKER-USER-Kette. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, mit dieser Regel wurde der Zugriff auf Port 1883 auf die Blockierungsregel erlaubt. </font><font style="vertical-align: inherit;">Über das Internet können Sie auch problemlos eine Verbindung herstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der DOCKER-USER-Kette muss eine Blockierungsregel erstellt werden!</font></font><br>
<br>
<pre><code class="plaintext hljs">iptables -I DOCKR-USER -p tcp -m tcp --dport 1883 -j DROP<font></font>
iptables -I INPUT -s 172.17.0.0/24 -p tcp -m tcp --dport 1883 -j ACCEPT</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die untere Version, die den Zugriff von internen Netzwerken aus ermöglicht, erfordert aus irgendeinem Grund INPUT.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heimserver</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Hauptteil ist der gleiche. </font><font style="vertical-align: inherit;">Obwohl er Kunde war, musste er den Datenverkehr von einem WiFi-Netzwerk (rfBridge) an mqtt auf VPS weiterleiten. </font><font style="vertical-align: inherit;">Jene. </font><font style="vertical-align: inherit;">Verkehrsbewegung: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
rfBridge (192.168.6.8) -&gt; iobroker host (192.168.6.6) -&gt; vpn-client container (172.17.0.?) -&gt; opevpn container auf VPS -&gt; loopback VPS (192.168.16.1) -&gt; mqtt container (Port 1883) Wir </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
erlauben "Forward" -Pakete für das Grid mit Clients und Loopbacks:</font></font><br>
<br>
<pre><code class="plaintext hljs">iptables -A FORWARD -d 192.168.16.0/24 -j ACCEPT</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und fahren Sie mit den Containerspezifikationen fort.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgabe 1</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sich erinnern, wurde die Interaktion zwischen den Subsystemen durch Loopback konfiguriert. </font><font style="vertical-align: inherit;">Jene. </font><font style="vertical-align: inherit;">Es ist erforderlich, dass Pakete auf 192.168.16.6 vom VPN-Client an den Host (172.17.0.1) und nicht an den VPN-Tunnel gesendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie diesen Befehl in einem laufenden Container ausführen, funktioniert alles. </font><font style="vertical-align: inherit;">Nach dem Neustart wird dies vergessen, Sie können dies jedoch in der Konfigurationsdatei iobroker.ovpn angeben </font></font><br>
<code>route 192.168.16.6 255.255.255.255 172.17.0.1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und openvpn installiert diese Route, wenn der Container startet. </font><font style="vertical-align: inherit;">Dies ist auf übliche Weise leicht zu lösen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgabe 2</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pakete aus dem Heimnetzwerk 192.168.6.0 (z. B. von rfBridge) werden an den iobroker-Host gesendet und an den VPN-Client-Container weitergeleitet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe das Netzwerk 192.168.6.0 jedoch absichtlich nicht in die Verschlüsselungsdomäne aufgenommen. Der OpenVPN-Container auf VPS weiß nicht, was mit diesem Netzwerk zu tun ist. Die naheliegende Lösung besteht darin, NAT im VPN-Client so zu gestalten, dass das Paket auf dem VPS von seiner Adresse stammt. Aber es gibt eine Nuance. Wie speichere ich die erforderlichen iptables-Befehle nach dem Neustart des Containers? Iptables-persistent ist dort nicht so einfach zu platzieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können natürlich einen neuen Behälter mit Zusatzstoffen zusammenbauen. Das möchte ich aber nicht, da das Upgrade komplizierter wird. Anstatt "zuletzt getötet und gestartet und die Konfiguration aus dem bereitgestellten Ordner abgerufen zu haben", muss die Assembly gestartet werden ... Nicht dafür kommuniziere ich mit Containern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher habe ich beschlossen, "nach dem Start des Containers gewaltsam Befehle auszuführen, die iptables anweisen, NAT auszuführen". </font><font style="vertical-align: inherit;">Ich habe das Team dafür benutzt </font></font><br>
<code>docker events --filter "container=vpn-client" --filter "event=start"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie hängt und wartet auf das in den Filtern angegebene Ereignis. </font><font style="vertical-align: inherit;">In meinem Fall starten Sie den Container. </font><font style="vertical-align: inherit;">Danach führe ich über Docker Exec die erforderlichen Befehle vom Host darin aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dazu konfiguriere ich analog zu VPS </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/usr/local/bin/my_last_command.sh</font></font></i><br>
<br>
<pre><code class="plaintext hljs">#!/bin/bash<font></font>
cont="vpn-client"<font></font>
ipaddr=$(docker inspect -f '{{.NetworkSettings.IPAddress}}' $cont)<font></font>
route add -net 192.168.16.0/24 gw $ipaddr<font></font>
for (( ; ; ))<font></font>
do<font></font>
  docker events --filter "container=$cont" --filter "event=start"<font></font>
  docker exec -it $cont iptables -t nat -I POSTROUTING -s 192.168.16.0/255.255.255.0 -j MASQUERADE<font></font>
  docker exec -it $cont iptables -t nat -I POSTROUTING -s 192.168.6.0/255.255.255.0 -j MASQUERADE<font></font>
done<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt Beispiele, in denen die Ausgabe von Docker-Ereignissen an die awk-Eingabe übergeben wird, die die Befehle ausführt. </font><font style="vertical-align: inherit;">Es schien mir jedoch einfacher, vor dem Ereignis zu „hängen“, Befehle auszuführen und erneut auf das Ereignis zu warten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ehrlich gesagt wollte ich diesen Beitrag nicht schreiben. Ich habe eine interessante Erfahrung gemacht, aber es stellte sich als "nicht schön" heraus, es ist zu schwierig, ich mag es nicht so sehr. Also habe ich wieder alles überarbeitet, VPS generell abgelehnt. Aber da ich den zweiten Teil versprochen habe ... Außerdem war ich von der Herangehensweise an Docker-Events beeindruckt, ich wollte es teilen. Ich denke, es wird nützlich sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende habe ich mich so entschieden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da ich vis nicht über einen Reverse-Proxy veröffentlichen konnte und mqtt problemlos von außen als Service nutzen kann, benötige ich für diese Aufgabe kein VPS. Ich kann auch Firmware für OTA-Updates auf das Hosting hochladen, da gibt es einen Vorteil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deshalb.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mqtt übernahm wqtt.ru. </font><font style="vertical-align: inherit;">TLS ist (Passwörter werden in einer sicheren Form gesendet). </font><font style="vertical-align: inherit;">Die Geschwindigkeit ist ausgezeichnet (10 ms gegenüber 80 ms für mymqtthub). </font><font style="vertical-align: inherit;">Themen, die in '$ device / &lt;crazy ID&gt; / events' (wie Yandex) umgeschrieben werden müssen, sind nicht erforderlich. </font><font style="vertical-align: inherit;">Jene. </font><font style="vertical-align: inherit;">In diesem Fall können Sie leicht irgendwohin springen. </font><font style="vertical-align: inherit;">Der Preis ist günstig (300 Rubel pro Jahr). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich poste die Firmware für OTA auf der vorhandenen für das Hosting. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Zugang zu vis erfolgt weiterhin über Zerotier. </font><font style="vertical-align: inherit;">Es ist sehr einfach und bequem. </font><font style="vertical-align: inherit;">Und selbst wenn sie kaputt sind, ist es unwahrscheinlich, dass der CO2-Gehalt in meinem Haus dafür angezeigt wird. </font><font style="vertical-align: inherit;">Und selbst wenn dies passiert, wird es bald berühmt, als wenn sie mich persönlich brechen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles ist schön, es funktioniert ohne Fehler, es ist einfach, bei Bedarf Änderungen vorzunehmen, es gibt keine unnötigen Server, die gewartet werden müssen, ich bin zufrieden.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de505394/index.html">Antiquitäten: Nokia E90, der neueste Kommunikator</a></li>
<li><a href="../de505398/index.html">Die dunklen und hellen Seiten der Arbeit bei Yandex</a></li>
<li><a href="../de505400/index.html">Wie sollen die Modelle aussehen?</a></li>
<li><a href="../de505402/index.html">Überlagern einer 3D-Textur mit 3D-Objekten mit p5.js (Teil 2 - Anwenden eines Musters auf einen Würfel)</a></li>
<li><a href="../de505404/index.html">Der einfachste Weg, Englisch mit TED-Videos zu lernen</a></li>
<li><a href="../de505416/index.html">MikroTik im Repeater-Modus - genau wie Eins-Zwei-Drei</a></li>
<li><a href="../de505418/index.html">[Frage] Haben Sie Leute gesehen, die Abonnements für mobile Inhalte verwenden?</a></li>
<li><a href="../en486014/index.html">SLAC Tour: US Department of Energy National Accelerator Laboratory at Stanford</a></li>
<li><a href="../en486018/index.html">Session Survey Results</a></li>
<li><a href="../en486024/index.html">Really simple graphics in R for science and journalism</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>