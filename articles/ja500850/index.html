<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏄 👲🏿 🖕🏼 より多くの開発者はデータベースについてこれを知っているべきです。 ⚔️ 👶🏽 👰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="注意ペレフ。：Jaana Doganは経験豊富なGoogleエンジニアで、現在Goで記述された会社の制作サービスの可観測性を扱っています。この記事では、英語を話す聴衆の間で非常に人気があり、17のポイントで、DBMS（および場合によっては、一般的に分散システム）に関する重要な技術的詳細を収集しました...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>より多くの開発者はデータベースについてこれを知っているべきです。</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/500850/"><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意ペレフ。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：Jaana Doganは経験豊富なGoogleエンジニアで、現在Goで記述された会社の制作サービスの可観測性を扱っています。この記事では、英語を話す聴衆の間で非常に人気があり、17のポイントで、DBMS（および場合によっては、一般的に分散システム）に関する重要な技術的詳細を収集しました。</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/hb/ds/h_/hbdsh_j3x_lkbkxtny1hqmfvkaq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンピュータシステムの大多数は、その状態を監視しているため、何らかのデータストレージシステムが必要です。</font><font style="vertical-align: inherit;">私は長い間データベースの知識を蓄積し、同時に設計のミスを犯し、データの損失と作業の中断につながりました。</font><font style="vertical-align: inherit;">大量の情報を処理するシステムでは、データベースはシステムアーキテクチャの中心であり、最適なソリューションを選択する上で重要な要素です。</font><font style="vertical-align: inherit;">データベースの作業には細心の注意が払われていますが、アプリケーション開発者が提供しようとする問題は、氷山の一角にすぎません。</font><font style="vertical-align: inherit;">このシリーズの記事では、この分野に特化していない開発者に役立ついくつかのアイデアを共有します。</font></font><a name="habracut"></a><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ネットワークが問題の原因ではない場合、99.999％の確率でラッキーです。</font></font></li>
<li> ACID    .</li>
<li>         .</li>
<li>     ,    .</li>
<li>      «»    .</li>
<li>              .</li>
<li>         .</li>
<li>    .</li>
<li>  (stale)         .</li>
<li>      .</li>
<li>    .</li>
<li>        .</li>
<li>     .</li>
<li>        .</li>
<li>        .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> オンライン移行は困難ですが可能です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> データベースの大幅な増加は、予測不能性の増加につながります。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Emmanuel OdekeやRein Henrichsなど、この記事の以前のバージョンについてのフィードバックに感謝したいと思います。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワークが問題の原因でない場合は、99.999％の確率でラッキーです。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
疑問は、現代のネットワークテクノロジーの信頼性と、ネットワーク障害が原因でシステムがアイドル状態になる頻度です。この問題に関する十分な情報はなく、多くの場合、専門のネットワーク、機器、および人員を持つ大規模な組織が研究を支配しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Spanner（Googleのグローバルに分散されたデータベース）の99.999％の可用性率により、Google </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">7.6％</font></a><font style="vertical-align: inherit;">のみ</font><font style="vertical-align: inherit;">がネットワーク関連</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">である</font></a><font style="vertical-align: inherit;">と主張し</font><font style="vertical-align: inherit;">ています。同時に、同社は専用ネットワークを高可用性の「主要な柱」と呼んでいます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BailisとKingsburyに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よる</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">2014年の</font></a><font style="vertical-align: inherit;">研究</font><font style="vertical-align: inherit;">は、</font><font style="vertical-align: inherit;">Peter Deutschが1994年に策定し</font><font style="vertical-align: inherit;">た「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分散コンピューティングの誤解</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」の</font><font style="vertical-align: inherit;">1つに挑戦してい</font><font style="vertical-align: inherit;">ます。ネットワークは本当に信頼できますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
広大なインターネットのために行われた巨大企業の外での本格的な研究は存在しません。また、顧客がネットワークに関して抱えている問題の割合に関する主要なプレーヤーからのデータも不十分です。大規模なクラウドプロバイダーのネットワークスタックが中断し、インターネット全体を数時間無効にできることはよく知られています。これは、これらが多数の人々や企業に影響を与える最も共鳴するイベントであるためです。ネットワークの停止は、これらのケースのすべてが脚光を浴びているわけではない場合でも、はるかに多くのケースで問題の原因となる可能性があります。クラウドサービスのお客様も、問題の原因について何も知りません。障害が発生した場合、サービスプロバイダー側​​のネットワークエラーに関連付けることはほとんど不可能です。彼らにとって、サードパーティのサービスはブラックボックスです。影響を評価できません主要なサービスプロバイダーではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主要なプレーヤーがシステムについて報告しているという事実を考えると、ネットワークの障害がダウンタイムにつながる潜在的な問題のほんの一部しか責任を負わない場合、あなたは幸運であると自信を持って言えます。</font><font style="vertical-align: inherit;">ネットワーク通信は、ハードウェア障害、トポロジーの変更、管理構成の変更、停電などの通常の問題の影響を受けます。</font><font style="vertical-align: inherit;">最近、私は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サメの咬傷</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が起こりうる問題のリストに追加されたことを知って驚いた</font><font style="vertical-align: inherit;">（そう、あなた</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">正しく</font><font style="vertical-align: inherit;">聞いた</font><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ACIDはさまざまなことを意味します</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
頭字語ACIDは、原子性、一貫性、分離、信頼性を意味します。これらのトランザクションプロパティは、障害、エラー、機器の障害などが発生した場合の有効性を保証するように設計されています。 ACIDまたは同様のスキームがないと、アプリケーション開発者が責任の領域とデータベースが担当するものとの間に線を引くことが困難になります。ほとんどのリレーショナルトランザクションデータベースはACID互換であるように試みていますが、NoSQLのような新しいアプローチは、実装にコストがかかるため、ACIDトランザクションなしで多くのデータベースを生み出しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が最初に業界に入ったとき、私たちのテクライドはACIDコンセプトがいかに関連しているかについて話しました。公平に言えば、ACIDは厳密な実装標準ではなく、大まかな説明と見なされることに注意してください。今日、私はそれが特定のカテゴリーの質問を提起する（そして可能な解決策の範囲を提供する）ので、それが主に有用であるとわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのDBMSがACID要件を満たしているわけではありません。同時に、ACIDでサポートされているデータベースの実装では、一連の要件の理解が異なります。 ACIDの異種実装の理由の1つは、ACID要件を実装するために行わなければならない多くの妥協に関連しています。作成者はデータベースをACID互換として提示できますが、境界のケースの解釈は大幅に異なり、「可能性が低い」イベントを処理するメカニズムも異なります。少なくとも、開発者はデータベースの実装の複雑さを大まかに理解して、設計における特別なモードとトレードオフの正しいアイデアを得ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MongoDBがACID要件を満たす方法についての議論は、4番目のバージョンの後でも止まりません。 MongoDBは長い間</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ロギング</font></a><font style="vertical-align: inherit;">をサポートしていませんでした</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ただしデフォルトでは、データは60秒に1回以上ディスクにコミットされませんでした。</font><font style="vertical-align: inherit;">次のシナリオを想像してください：アプリケーションが2つのエントリ（w1とw2）を書き込みます。</font><font style="vertical-align: inherit;">MongoDBはw1を正常に保存しましたが、ハードウェア障害が原因でw2が失われています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s9/ec/bo/s9ecbo4jpb9rjql9cwn5uc9nwdo.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シナリオを示す図。</font><font style="vertical-align: inherit;">MongoDB</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
は、</font><i><font style="vertical-align: inherit;">データをディスクに書き込む時間がなくなる前にクラッシュし</font></i><font style="vertical-align: inherit;">ます。ディスクへのコミットはコストのかかるプロセスです。</font><font style="vertical-align: inherit;">頻繁なコミットを回避することで、開発者は信頼性を犠牲にしながら記録パフォーマンスを向上させます。</font><font style="vertical-align: inherit;">MongoDBは現在ジャーナリングをサポートしていますが、デフォルトでは100ミリ秒ごとにログが記録されるため、ダーティレコードはデータの整合性に影響を与える可能性があります。</font><font style="vertical-align: inherit;">つまり、リスクははるかに低くなりますが、ログとログに表示される変更についても同様のシナリオが可能です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各ベースには、一貫性と分離を確保するための独自のメカニズムがあります。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ACID要件の中で、妥協の範囲がより広いため、一貫性と分離はさまざまな実装の最大数を誇っています。一貫性と分離は非常にコストのかかる機能であると言わなければなりません。それらは調整を必要とし、データの一貫性のために競争を増やします。複数のデータセンターにわたってベースを水平方向にスケーリングする必要がある場合（特に、地理的に異なる地域にある場合）、問題の複雑さは大幅に増大します。途中でアクセシビリティが低下し、ネットワークのセグメンテーションが増加するため、高レベルの一貫性を実現することは非常に困難です。この現象のより一般的な説明については</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、CAPの定理</font></a><font style="vertical-align: inherit;">を参照することをお勧めします</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。アプリケーションが多少の不整合に対処できることも注目に値します。プログラマーは問題の微妙なニュアンスを十分に表現できるため、この問題についてデータベースに大きく依存することなく、不整合に対処できるようにする追加のロジックをアプリケーションに実装できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DBMSは多くの場合、さまざまなレベルの分離を提供します。アプリケーション開発者は、好みに基づいて最も効果的なものを選択できます。分離度が低いと速度が向上し、同時にデータ競合のリスクが高まります。分離度が高いと、この確率は低くなりますが、作業が遅くなり、競合が発生する可能性があります。これにより、データベースにブレーキがかかり、障害が発生します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cw/zp/5w/cwzp5wsf2tpllg7yu9upzq9uroa.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">既存の同時実行モデルとそれらの間の関係の概要</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQL標準では4つの分離レベルしか定義されていませんが、理論上および実際にはその数ははるかに多くなっています。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jepson.io</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、既存の同時実行モデルの優れた概要を提供します。たとえば、Google Spannerは、クロック同期による外部シリアライザビリティを保証します。これはより厳密な絶縁層ですが、標準の絶縁層では定義されていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の分離レベルは、SQL標準で言及されています。</font></font><br>
<br>
<ul>
<li> <b>Serializable</b> (   ):    ,     .   ,          .  ,   <i>Serializable</i>       snapshot- (,  Oracle) -   ,   snapshot-     SQL.</li>
<li> <b>Repeatable reads</b>:         ,  ,    (,  ), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>. </li>
<li> <b>Read committed</b>:     .         ,      .        ,       .</li>
<li> <b>Read uncommitted</b> (    ): «»  ,     ,   .         , ,   <code>COUNT(*)</code>  .</li>
</ul><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シリアル化可能な</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
レベル</font><font style="vertical-align: inherit;">は、データ競合のリスクを最小限に抑え</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">が、実装に最もコストがかかり、システムに最高の競争負荷をもたらします。他の分離レベルは実装が簡単ですが、データ競合の可能性が高くなります。一部のDBMSではカスタム分離レベルを設定できますが、一部のDBMSでは設定が指定されており、すべてのレベルがサポートされているわけではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分離レベルのサポートは特定のDBMSでよく宣伝されますが、その動作を徹底的に調査するだけで、実際に何が起こっているのかを明確にすることができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0m/wa/in/0mwainvvak09ofti4zqrcamwsau.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なるDBMSのさまざまな分離レベルでの同時実行性異常の概要</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
でマーティンKleppmann </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">庵</font></a><font style="vertical-align: inherit;">プロジェクト</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、さまざまな分離レベルを比較し、並行性の異常、およびデータベースが特定の分離レベルに準拠できるかどうかについて話します。</font><font style="vertical-align: inherit;">クレップマンの研究は、データベース設計者が分離レベルをどのように想像するかを示しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常の状態を維持することが困難な場合、楽観的なブロッキングが助けになります</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロッキングは、データベースでの競争を厳しくするだけでなく、アプリケーションサーバーからデータベースへの常時接続を必要とするため、非常に高価になる可能性があります。ネットワークのセグメンテーションは、排他的ロックによって状況を悪化させ、識別して排除することが困難なデッドロックにつながる可能性があります。排他的ブロッキングが適さない場合は、楽観的に役立ちます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">楽観的ロック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、行を読み取るときに、そのバージョン、チェックサム、または最後の変更の時刻を考慮する方法です。このため、レコードを変更する前に、アトミックバージョンの変更がないことを確認できます。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">UPDATE</span> products
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">'Telegraph receiver'</span>, <span class="hljs-keyword">version</span> = <span class="hljs-number">2</span>
<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">version</span> = <span class="hljs-number">1</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、</font></font><code>products</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別の操作によってこの行が以前に変更</font><font style="vertical-align: inherit;">された</font><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">、テーブル</font><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">更新され</font><font style="vertical-align: inherit;">ません。</font><font style="vertical-align: inherit;">この行で他の操作が実行されなかった場合、1行の変更が発生し、更新は成功したと言えます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダーティリードとデータ損失以外にも、他の異常があります。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データの一貫性に関しては、ダーティリードとデータ損失につながる可能性のある競合状態の発生に焦点を当てています。ただし、データの異常はこれに限定されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような異常の1つの例は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">書き込みスキュー</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。歪みは通常は積極的に検索されないため、検出が困難です。これらは、「ダーティ」な読み取りやデータの損失ではなく、データに課せられた論理的制限の違反に関連しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、1人のオペレーターが常時オンコールであることが必要なモニタリングアプリケーションを見てみましょう。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">BEGIN</span> tx1;                      <span class="hljs-keyword">BEGIN</span> tx2;
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(*)
<span class="hljs-keyword">FROM</span> operators
<span class="hljs-keyword">WHERE</span> oncall = <span class="hljs-literal">true</span>;<font></font>
0                               <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(*)
                                <span class="hljs-keyword">FROM</span> operators
                                <span class="hljs-keyword">WHERE</span> oncall = <span class="hljs-literal">TRUE</span>;<font></font>
                                0<font></font>
<span class="hljs-keyword">UPDATE</span> operators                <span class="hljs-keyword">UPDATE</span> operators
<span class="hljs-keyword">SET</span> oncall = <span class="hljs-literal">TRUE</span>               <span class="hljs-keyword">SET</span> oncall = <span class="hljs-literal">TRUE</span>
<span class="hljs-keyword">WHERE</span> userId = <span class="hljs-number">4</span>;               WHERE userId = 2;
<span class="hljs-keyword">COMMIT</span> tx1;                     <span class="hljs-keyword">COMMIT</span> tx2;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の状況で、両方のトランザクションが正常にコミットされると、レコードの歪みが発生します。</font><font style="vertical-align: inherit;">「ダーティー」な読み取りやデータの損失はありませんでしたが、データの整合性が侵害されていることが判明しました。現在、2人が通話中と見なされています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シリアライズ可能な絶縁、回路設計、またはデータベースの制限は、記録の歪みをなくすのに役立ちます。</font><font style="vertical-align: inherit;">開発者は、開発中にそのような異常を識別して、本番環境でそれらを回避できるようにする必要があります。</font><font style="vertical-align: inherit;">同時に、コードベースで歪みを記録することは非常に困難です。</font><font style="vertical-align: inherit;">特に大規模なシステムでは、異なる開発チームが同じテーブルに基づく関数の実装を担当し、データアクセスの機能を互いに調整しない場合。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースとユーザーは手順に必ずしも同意しない</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースの主要な機能の1つは実行順序を保証することですが、この順序自体はソフトウェア開発者には透過的ではない場合があります。データベースは、プログラマが意味する順序ではなく、受け取った順序でトランザクションを実行します。特に負荷の高い並列システムでは、トランザクションの順序を予測することは困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発中、特に非ブロッキングライブラリを使用している場合、スタイルと可読性が低いと、トランザクションが順番に実行されることになりますが、実際には任意の順序でデータベースに到着できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見すると、以下のプログラムではT1とT2が順番に呼び出されますが、これらの関数が非ブロッキングで、結果が</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">promise</font></a><font style="vertical-align: inherit;">の形式ですぐに返される場合</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その後、呼び出しの順序は、データベースに入力された瞬間によって決定されます</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。result1= T1（）//実際の結果は</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
promiseですresult2 = T2（）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原子性が必要な場合（つまり、すべての操作を完了するか中断する必要があります）およびシーケンス重要なのは、操作T1とT2が単一のトランザクションの一部として実行されることです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションレベルのシャーディングをアプリケーションの外に移動できます</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シャーディングは、データベースを水平に分割する方法です。一部のデータベースはデータを自動的に水平に分割できますが、他のデータベースはそうしないか、非常にうまく行いません。データアーキテクトや開発者は、データへのアクセス方法を予測できる場合、このデータベースの作業を委任する代わりに、ユーザー空間に水平パーティションを作成できます。このプロセスは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションレベルのシャーディング</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
悲しいかな、そのような名前は、シャーディングがアプリケーションサービスに存在すると誤解されることがよくあります。実際、データベースの前の別のレイヤーとして実装できます。データの増加と回路の反復によっては、シャーディングの要件が非常に複雑になる場合があります。一部の戦略では、アプリケーションサーバーを再デプロイする必要なしに反復することが役立つ場合があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ti/89/f7/ti89f7ji1fwogfzql4nunhl4qvu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションサーバーがシャーディングサービスから分離されているアーキテクチャの例</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
シャーディングを別のサービスに削除すると、アプリケーションを再デプロイせずにさまざまなシャーディング戦略を使用できる可能性が広がります。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヴィテス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-アプリケーションレベルでのこのようなシャーディングシステムの例。</font><font style="vertical-align: inherit;">VitessはMySQLに水平分割を提供し、クライアントがMySQLプロトコルを介してそれに接続できるようにします。</font><font style="vertical-align: inherit;">システムは、お互いについて何も知らない異なるMySQLノード上のデータをセグメント化します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動インクリメントは危険な場合があります</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUTOINCREMENTは、主キーを生成する一般的な方法です。</font><font style="vertical-align: inherit;">多くの場合、データベースがIDジェネレーターとして使用され、データベースには識別子を生成するように設計されたテーブルがあります。</font><font style="vertical-align: inherit;">自動インクリメントを使用して主キーを生成することが理想とはほど遠いのには、いくつかの理由があります。</font></font><br>
<br>
<ul>
<li>     auto-incrementing    .   ID   .     UUID:        . Auto-incrementing               .   (, MySQL)        ,      -.     ,     .</li>
<li>         .  ID      « »      ,       .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主キーは、データベースの行にアクセスする最も速い方法です。</font><font style="vertical-align: inherit;">レコードを識別するためのより良い方法を使用して、シーケンシャルIDは、テーブルの最も重要な列を無意味なものに変え、意味のない値で埋めることができます。</font><font style="vertical-align: inherit;">したがって、可能であれば、グローバルに一意で自然な主キー（たとえば、ユーザー名）を選択してください。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプローチを決定する前に、自動インクリメントされたIDとUUIDがインデックス作成、パーティション分割、およびシャーディングに与える影響を検討してください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古いデータは役立つ場合があり、ブロックする必要がない場合があります。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マルチバージョン同時実行管理（MVCC）は、上で簡単に説明した一貫性要件の多くを実装します。一部のデータベース（たとえば、Postgres、Spanner）は、トランザクションにMVCCの「フィード」スナップショットを使用しています—データベースの古いバージョンです。スナップショットを使用したトランザクションは、整合性を確保するためにシリアル化することもできます。古いスナップショットから読み取る場合、古いデータが読み取られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、データに基づいて分析を生成したり、概算の集計値を計算したりする場合など、少し古いデータを読み取ると便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古いデータを使用する最初の利点は、待ち時間が短いことです（特に、データベースが地理的に異なる地域に分散している場合）。 2つ目は、読み取り専用トランザクションがブロックされないことです。これは、多くの場合、もちろん古いデータでの作業が許容できる場合、多くを読み取るアプリケーションにとって重要な利点です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5s/cv/uw/5scvuwb8q6aptaylsbyqroquy38.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションサーバーは、5秒間古くなっているローカルレプリカデータを読み取ります。太平洋の反対側で最新バージョンが利用可能であっても、</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
DBMSは古いバージョンを自動的に消去し、場合によっては、これをオンデマンドで実行できるようにします。たとえば、Postgresはユーザーが</font></font><code>VACUUM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オンデマンドで</font><font style="vertical-align: inherit;">実行できるようにし</font><font style="vertical-align: inherit;">、この操作を自動モードで定期的に実行します。 Spannerはガベージコレクターを起動して、1時間以上経過したスナップショットを削除します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間のソースは歪みの影響を受けます</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンピュータサイエンスで最も注意深く守られている秘密は、すべての一時的なAPIが嘘をついていることです。</font><font style="vertical-align: inherit;">実際、私たちの車は正確な現在時刻を知りません。</font><font style="vertical-align: inherit;">コンピュータには、時間をカウントするために使用される振動を生成する水晶振動子が含まれています。</font><font style="vertical-align: inherit;">ただし、それらは十分に正確ではなく、正確な時間よりも進んでいる/遅れている可能性があります。</font><font style="vertical-align: inherit;">シフトは1日あたり20秒に達することがあります。</font><font style="vertical-align: inherit;">したがって、私たちのコンピューターの時刻は、ネットワークと定期的に同期する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NTPサーバーは同期に使用されますが、同期プロセス自体はネットワークが原因で遅延する傾向があります。</font><font style="vertical-align: inherit;">同じデータセンター内のNTPサーバーとの同期でさえ、少し時間がかかります。</font><font style="vertical-align: inherit;">パブリックNTPサーバーを使用すると、さらに歪みが生じる可能性があることは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原子時計とそれに対応するGPSは、現在の時刻を特定するのに適していますが、高価で複雑な設定が必要なため、各マシンにインストールすることはできません。このため、データセンターは段階的なアプローチを採用しています。原子時計やGPS時計は正確な時刻を示し、その後セカンダリサーバーを介して他のマシンに送信されます。これは、各マシンで正確な時刻から特定のシフトがあることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションとデータベースは異なるマシン上にあることが多いため（異なるデータセンターではない場合）、状況はさらに悪化します。したがって、異なるマシンに分散されたDBのノードだけでは時間は異なります。また、アプリケーションサーバーでも異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google TrueTimeのアプローチはまったく異なります。</font><font style="vertical-align: inherit;">ほとんどの人は、この方向でのGoogleの進歩は原子時計とGPS時計への平凡な移行によるものであると信じていますが、これは全体像の一部にすぎません。</font><font style="vertical-align: inherit;">TrueTimeの仕組みは次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TrueTimeは、GPSと原子時計の2つの異なるソースを使用します。</font><font style="vertical-align: inherit;">この時計には、相関のない故障モードがあります</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（5ページの詳細は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を参照してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">re。）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そのため、それらを一緒に使用すると信頼性が向上します。</font></font></li>
<li>  TrueTime  API.            .     -      . Spanner,     Google,   ,     ,       .       ,      ,        .</li>
</ul><br>
<img src="https://habrastorage.org/webt/ge/iw/xv/geiwxvrnosfv3co6k9crz7s7lim.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spannerコンポーネントは、TT.now（）が間隔を返すTrueTimeを使用するため、現在の時刻が特定のマークを過ぎたと言えるまで、Spannerは単純にスリープします。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
現在の時刻を決定する精度が低下すると、Spannerの操作の継続時間が長くなり、生産性が低下します。</font><font style="vertical-align: inherit;">そのため、正確な時計を入手することは不可能ですが、可能な限り高い精度を維持することが重要です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遅延には多くの意味があります</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何十人の専門家に遅延とは何かを尋ねたので、おそらく異なる答えを得るでしょう。</font><font style="vertical-align: inherit;">DBMSでは、レイテンシは「データベースレイテンシ」と呼ばれることが多く、クライアントが認識するレイテンシとは異なります。</font><font style="vertical-align: inherit;">実際、クライアントはネットワーク遅延とデータベース遅延の合計を監視します。</font><font style="vertical-align: inherit;">遅延のタイプを分離する機能は、増大する問題をデバッグする際に重要です。</font><font style="vertical-align: inherit;">メトリックを収集して表示するときは、常に両方のタイプを追跡するようにしてください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のトランザクションについて、パフォーマンス要件を評価する必要があります。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
場合によっては、DBMSのパフォーマンス特性とその制限が、書き込み/読み取りのスループットと遅延の形で示されます。</font><font style="vertical-align: inherit;">これにより、システムの主要なパラメーターの概要を把握できますが、新しいDBMSのパフォーマンスを評価する場合、より包括的なアプローチは、重要な操作を個別に評価することです（各要求またはトランザクション、あるいはその両方）。</font><font style="vertical-align: inherit;">例：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 指定された制限を使用してテーブルX（5,000万行）に新しい行を挿入し、関連するテーブルの行に入力するときのスループットと遅延を書き込みます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 友達の平均数が500人であるとき、特定のユーザーの友達の友達の撤退の遅延。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1時間あたりXエントリで他の500人のユーザーをサブスクライブしているときに、ユーザーの履歴から上位100エントリを取得する際の遅延。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースがパフォーマンス要件を満たしていることを確認するまで、評価と実験にはこのような重大なケースが含まれる場合があります。</font><font style="vertical-align: inherit;">同様の経験則では、待ち時間のメトリックを収集してSLOを決定するときに、この内訳も考慮に入れます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各操作のメトリックを収集するときは、カーディナリティが高いことに注意してください。</font><font style="vertical-align: inherit;">ログ、イベント収集、または分散トレースを使用して、強力なデバッグデータを取得します。</font><font style="vertical-align: inherit;">記事「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイテンシをデバッグしたいですか？</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">»遅延をデバッグする方法に慣れることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネストされたトランザクションは危険な場合があります</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのDBMSがネストされたトランザクションをサポートしているわけではありませんが、これが発生すると、そのようなトランザクションは予期しないエラーを引き起こし、必ずしも簡単に検出できるわけではありません（つまり、何らかの異常があることが明らかになります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネストされたトランザクションは、それらを検出して回避できるクライアントライブラリを使用することで回避できます。ネストされたトランザクションを放棄することが不可能な場合、ネストされたトランザクションが原因で完了したトランザクションが誤って中断されたときの予期しない状況を回避するために、それらを実装するように特に注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トランザクションを異なるレイヤーにカプセル化すると、ネストされたトランザクションが予期せず発生する可能性があり、コードの読みやすさの観点からは、作成者の意図の理解が複雑になる可能性があります。次のプログラムを見てください。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">with</span> newTransaction():<font></font>
   Accounts.create(<span class="hljs-string">"609-543-222"</span>)
   <span class="hljs-keyword">with</span> newTransaction():<font></font>
       Accounts.create(<span class="hljs-string">"775-988-322"</span>)
       <span class="hljs-keyword">throw</span> Rollback();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のコードの結果はどうなりますか？両方のトランザクションをロールバックしますか、それとも内部のみですか？トランザクションの作成をカプセル化するいくつかのライブラリレベルに依存している場合はどうなりますか？そのようなケースを特定して改善できますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの操作（など</font></font><code>newAccount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を持つデータレイヤー</font><font style="vertical-align: inherit;">が、独自のトランザクションですでに実装されている</font><font style="vertical-align: inherit;">と想像してください</font><font style="vertical-align: inherit;">。独自のトランザクションの一部として動作する高レベルのビジネスロジックの一部としてそれらを実行するとどうなりますか？この場合、分離と一貫性はどうなりますか？</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newAccount</span>(<span class="hljs-params">id string</span>) </span>{
  <span class="hljs-keyword">with</span> newTransaction():<font></font>
      Accounts.create(id)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような無限の質問に対する答えを探す代わりに、ネストされたトランザクションを回避することをお勧めします。</font><font style="vertical-align: inherit;">結局のところ、データ層は独自のトランザクションを作成せずに高レベルの操作を実行できる可能性があります。</font><font style="vertical-align: inherit;">さらに、ビジネスロジック自体がトランザクションを開始し、トランザクションに対して操作を実行し、トランザクションをコミットまたは中断することができます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newAccount</span>(<span class="hljs-params">id string</span>) </span>{<font></font>
   Accounts.create(id)<font></font>
}<font></font>
<span class="hljs-comment">// In main application:</span>
<span class="hljs-keyword">with</span> newTransaction():
   <span class="hljs-comment">// Read some data from database for configuration.</span>
   <span class="hljs-comment">// Generate an ID from the ID service.</span><font></font>
   Accounts.create(id)<font></font>
   Uploads.create(id) <span class="hljs-comment">// create upload queue for the user.</span></code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トランザクションをアプリケーションの状態に関連付けないでください</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トランザクションでアプリケーションの状態を使用して特定の値を変更したり、クエリパラメーターを微調整したりすることが魅力的な場合があります。</font><font style="vertical-align: inherit;">考慮すべき重要なニュアンスは、アプリケーションの適切な領域です。</font><font style="vertical-align: inherit;">ネットワークの問題が発生すると、クライアントはトランザクションを再開することがよくあります。</font><font style="vertical-align: inherit;">同時に、トランザクションが他のプロセスによって変化している状態に依存している場合、データ競合の可能性に応じて誤った値を選択する可能性があります。</font><font style="vertical-align: inherit;">トランザクションでは、アプリケーションのデータ競合状態のリスクを考慮する必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> seq int64
<span class="hljs-keyword">with</span> newTransaction():<font></font>
    newSeq := atomic.Increment(&amp;seq)<font></font>
    Entries.query(newSeq)<font></font>
    <span class="hljs-comment">// Other operations...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のトランザクションは、最終結果に関係なく、実行ごとにシーケンス番号を増やします。</font><font style="vertical-align: inherit;">ネットワークの問題が原因でコミットが失敗した場合、再試行すると、要求は別のシーケンス番号で実行されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クエリプランナーはデータベースについて多くのことを伝えることができます。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クエリプランナーは、データベースでのクエリの実行方法を決定します。</font><font style="vertical-align: inherit;">また、リクエストを分析して送信前に最適化します。</font><font style="vertical-align: inherit;">プランナーは、自由に使える信号に基づいて、可能な推定の一部のみを提供できます。</font><font style="vertical-align: inherit;">たとえば、次のクエリに最適な検索方法は何ですか？</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> articles <span class="hljs-keyword">where</span> author = <span class="hljs-string">"rakyll"</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> title;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果は次の2つの方法で抽出できます。</font></font><br>
<br>
<ul>
<li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全表スキャン</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><b><font style="vertical-align: inherit;">表の</font></b><font style="vertical-align: inherit;">各レコードを調べて、同じ著者名の記事を返し、それらを整理できます。</font></font></li>
<li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックススキャン</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：インデックスを使用して、対応する識別子を検索し、これらの行を取得して、それらを配置できます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クエリプランナーのタスクは、最適な戦略を決定することです。クエリプランナーの予測機能は限られていることに注意してください。これは悪い決定につながる可能性があります。 DBAまたは開発者は、それらを使用して非効率的なクエリを診断および微調整できます。 DBMSの新しいバージョンはクエリスケジューラを構成でき、自己診断は新しいバージョンがパフォーマンスの問題を引き起こす場合にデータベースの更新に役立ちます。クエリログの遅延、エラーメッセージの遅延、または実行時統計は、最適化が必要なクエリの特定に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クエリプランナーによって提示される一部のメトリックは、ノイズの影響を受ける可能性があります（特に、レイテンシまたはプロセッサ時間を評価する場合）。</font><font style="vertical-align: inherit;">プランナーへの良い追加は、実行パスを追跡および追跡するためのツールです。</font><font style="vertical-align: inherit;">これらを使用すると、このような問題を診断できます（すべてのDBMSがそのようなツールを提供しているわけではありません）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オンライン移行は困難ですが可能です</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オンライン移行、ライブ移行、またはリアルタイム移行とは、ダウンタイムやデータの破損なしに、あるデータベースから別のデータベースに移行することを意味します。</font><font style="vertical-align: inherit;">移行が同じDBMS /エンジン内で行われる場合、ライブマイグレーションはより簡単に実行できます。</font><font style="vertical-align: inherit;">パフォーマンスと回路の要件が異なる新しいDBMSに移行する必要がある場合、状況は複雑になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オンライン移行にはさまざまなモデルがあります。</font><font style="vertical-align: inherit;">以下はその1つです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">両方のベースに二重エントリを含めます。</font><font style="vertical-align: inherit;">この段階での新しいデータベースには、すべてのデータは含まれていませんが、最新のデータのみを受け取ります。</font><font style="vertical-align: inherit;">これを確認したら、次のステップに進むことができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 両方のデータベースからの読み取りをオンにします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 読み取りと書き込みが主に新しいデータベースで実行されるようにシステムを設定します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データの読み取りを継続しながら、古いデータベースへの書き込みを停止します。</font><font style="vertical-align: inherit;">この段階では、新しいデータベースにはまだいくつかのデータがありません。</font><font style="vertical-align: inherit;">古いデータベースからコピーする必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">古いデータベースは読み取り専用です。</font><font style="vertical-align: inherit;">古いデータベースから新しいデータベースに不足しているデータをコピーします。</font><font style="vertical-align: inherit;">移行が完了したら、パスを新しいデータベースに切り替え、古いデータベースを停止してシステムから削除します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
詳細については</font><font style="vertical-align: inherit;">、このモデルに基づくStripe移行戦略の詳細についての</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">参照することをお勧めし</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースの大幅な増加は予測不能性の増加につながります</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースの増大は、そのサイズに関連する予測できない問題を引き起こします。</font><font style="vertical-align: inherit;">データベースの内部構造についての知識が多ければ多いほど、データベースがどのように拡張されるかを予測できます。</font><font style="vertical-align: inherit;">ただし、いくつかの点はまだ予測不可​​能です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースの増大に伴い、データ量とネットワーク帯域幅の要件に関する以前の想定と期待は時代遅れになる可能性があります。</font><font style="vertical-align: inherit;">それは、潜在的な問題を回避するために、スキームの重大な改訂、運用の大規模な改善、デプロイメントの再考、または他のDBMSへの移行の問題が生じたときです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、既存のデータベースの内部構造に関する優れた知識だけが必要なものだとは考えないでください。</font><font style="vertical-align: inherit;">新しい次元は彼らに新しい未知をもたらすでしょう。</font><font style="vertical-align: inherit;">予測できない問題点、データの不均一な分散、帯域幅と機器に関する予期しない問題、増大するトラフィックとネットワーク内の新しいセグメントにより、データベース、データモデル、配置モデル、およびそのサイズへのアプローチを再考する必要があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事の公開について考えていた当時、元のリストには既に5つのポイントがありました。</font><font style="vertical-align: inherit;">その後、</font><font style="vertical-align: inherit;">他に何をカバーできるかについて、</font><font style="vertical-align: inherit;">大量の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいアイデア</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が生まれました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、この記事では、最大の注意を必要とする最も明白でない問題に触れます。</font><font style="vertical-align: inherit;">ただし、これはトピックが使い果たされたことを意味するものではなく、今後の資料でそのトピックに戻ることはなく、現在のトピックに変更を加えることもありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのブログも読んでください：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースとKubernetes（レビューとビデオレポート）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分散トレース：私たちはすべて間違ったことをしました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Service Mesh：すべてのソフトウェアエンジニアがHYIPテクノロジーについて知っておくべきこと</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja500836/index.html">5月7日に輸送はどうなりますか-異なる地域の異なる検疫</a></li>
<li><a href="../ja500838/index.html">O2の代わりにCO2：裸のほくろラットがけいれん発作をどのように防ぐか</a></li>
<li><a href="../ja500840/index.html">モータルコンバット11フレーム分析</a></li>
<li><a href="../ja500844/index.html">VictoriaMetricsで最適化を行います。アレクサンダーバリャルキン</a></li>
<li><a href="../ja500848/index.html">単一の開発者によるMVP</a></li>
<li><a href="../ja500852/index.html">Avira Free Antivirusアンチウイルスソフトウェアのパスワードスタイラー</a></li>
<li><a href="../ja500854/index.html">検疫中のABBYYオフィスの運用を技術的にどのようにサポートするか</a></li>
<li><a href="../ja500856/index.html">興味のない「おもしろい」の翻訳について</a></li>
<li><a href="../ja500860/index.html">中国では、玄関のドアの前と市民のアパートの中に監視カメラが設置されています</a></li>
<li><a href="../ja500862/index.html">Wheel of Sansara：日常との戦いの原則</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>