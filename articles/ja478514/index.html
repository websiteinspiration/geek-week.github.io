<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌑 🏁 👨🏻‍✈️ 暗号化されたデータを復号化せずに機械学習に使用する 😪 👩‍🔬 🛥️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="暗号化されたデータを復号化せずに機械学習に使用する
 この記事では、高度な暗号化技術について説明します。これは、Julia Computingが実施した研究の概要にすぎません。ここに示す例を商用アプリケーションで使用しないでください。暗号を適用する前に、常に暗号技術者に相談してください。
 
 ここ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>暗号化されたデータを復号化せずに機械学習に使用する</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/478514/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_p/ns/yf/_pnsyfz49v6t61j8whitl-q4qw0.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暗号化されたデータを復号化せずに機械学習に使用する</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、高度な暗号化技術について説明します。</font><font style="vertical-align: inherit;">これは、Julia Computingが実施した研究の概要にすぎません。</font><font style="vertical-align: inherit;">ここに示す例を商用アプリケーションで使用しないでください。</font><font style="vertical-align: inherit;">暗号を適用する前に、常に暗号技術者に相談してください。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font><font style="vertical-align: inherit;">すべての魔法を実装するパッケージをダウンロードできます</font><font style="vertical-align: inherit;">。これは、記事で説明されているコードです。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（もちろん</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flux.jl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">クールな新しい機械学習モデルを開発したとしましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そして今、あなたはあなたのユーザーのためにそれを配備し始めたいと思います。</font><font style="vertical-align: inherit;">どうやってこれをしますか？</font><font style="vertical-align: inherit;">おそらく最も簡単な方法は、モデルをユーザーに提供し、データ上でローカルに実行させることです。</font><font style="vertical-align: inherit;">ただし、このアプローチには欠点があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機械学習モデルは大きく、ユーザーのコンピューターには十分なコンピューティングリソースやディスクリソースがない可能性があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機械学習モデルは頻繁に更新されるため、ネットワーク経由で大量のデータを定期的に送信するのは不便です。 </font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルの開発には時間がかかり、大量のコンピューティングリソースが必要です。</font><font style="vertical-align: inherit;">そして、あなたはあなたのモデルを使うための料金の形でこれに対する補償を望むかもしれません。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、通常、モデルはAPIを介してクラウドで提供できることを思い出します。過去数年にわたって、このようなサービスが数多く登場しました。それぞれの大規模なクラウドプラットフォームは、同様のサービスを企業開発者に提供しています。しかし、潜在的なユーザーは明らかなジレンマに直面しています。彼らのデータはリモートサーバーで処理されるため、信頼できない可能性があります。これには、そのようなサービスの使用を制限する明確な倫理的および法的影響があります。規制された業界、特にヘルスケアおよび金融サービスでは、処理のために患者およびクライアントのデータを第三者に送信することがしばしば不可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のオプションはありますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あることがわかりました！暗号技術における最近の発見により、データ</font><i><font style="vertical-align: inherit;">なしで</font></i><font style="vertical-align: inherit;">コンピューティング</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を解読できます。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">たとえば、ユーザーは、機械学習モデルを起動するクラウドAPIに暗号化されたデータ（たとえば、画像）を送信してから、暗号化された応答を送信します。</font><font style="vertical-align: inherit;">データが復号化されていない段階では、クラウドプロバイダーはソース画像にアクセスできず、計算された予測を復号化できません。</font><font style="vertical-align: inherit;">これはどのようにして可能ですか？</font><font style="vertical-align: inherit;">MNISTデータセットから暗号化された画像に手書き認識のためのサービスを作成する例を見てみましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準同型暗号化について</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暗号化されたデータを使用して計算を実行する機能は、一般に「セキュアコンピューティング」と呼ばれます。</font><font style="vertical-align: inherit;">これは研究の大きな領域であり、あらゆる種類のアプリケーションシナリオに応じて、暗号化への多くのアプローチがあります。</font><font style="vertical-align: inherit;">「準同型暗号化」と呼ばれる手法に焦点を当てます。</font><font style="vertical-align: inherit;">このようなシステムでは、通常、次の操作を使用できます。</font></font><br>
<br>
<ul>
<li><code>pub_key, eval_key, priv_key = keygen()</code> <br>
</li>
<li><code>encrypted = encrypt(pub_key, plaintext)</code> <br>
</li>
<li><code>decrypted = decrypt(priv_key, encrypted)</code> <br>
</li>
<li><code>encrypted′ = eval(eval_key, f, encrypted)</code><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の3つの操作は単純で、非対称暗号化アルゴリズムをすでに使用しているすべてのユーザーに馴染みがあります（たとえば、TLS経由で接続している場合）。</font><font style="vertical-align: inherit;">すべての魔法は最後の操作で発生します。</font><font style="vertical-align: inherit;">暗号化する場合、関数</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を評価</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、暗号化された値の</font><font style="vertical-align: inherit;">評価結果に基づいて計算された別の暗号化された値を返し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">この機能は、そのアプローチにその名前を与えました。</font><font style="vertical-align: inherit;">評価は暗号化操作に関連しています。</font></font><br>
<br>
<pre><code class="julia hljs">f(decrypt(priv_key, encrypted)) == decrypt(priv_key, eval(eval_key, f, encrypted))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、暗号化された値を使用して、任意の準同型を推定できます</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サポートされる機能は</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、暗号化スキームとサポートされる操作によって異なります。 1つだけがサポートされている場合</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（たとえば</font></font><code>f = +</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、スキームは「部分的に準同型」と呼ばれます。もし</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意のスキームを作成できる任意の完全なゲートウェイセットにすることができます。スキームの制限されたサイズの場合、これは別の種類の部分的準同型計算-「ある程度準同型」と呼ばれ、サイズの制限がない場合-「完全準同型」計算と呼ばれます。ブートストラッピング技術を使用して、「何らかの方法で」完全に準同型の暗号化に変えることができますが、これは私たちの記事の範囲を超えています。完全準同型暗号化は比較的最近の発見であり、最初の実用的なスキーム（実用的ではありません）が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Craig Gentryによって2009年</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に公開され</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ました</font></a><font style="vertical-align: inherit;">。後の（そして実用的な）完全に準同型のスキームがいくつかあります。これらのスキームを定性的に実装するソフトウェアパッケージもあります。ほとんどの場合、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft SEAL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用し</font><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パリセード</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">さらに、私は最近、これらの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pure Julia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズムの実装コードを開きました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この記事では、実装されたCKKS暗号化を使用します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CKSの概要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CKKS（</font><font style="vertical-align: inherit;">2016年にアルゴリズムを提案し</font><font style="vertical-align: inherit;">た</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">科学的研究</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cheon-Kim-Kim-Song </font><font style="vertical-align: inherit;">の作者の名前による</font><font style="vertical-align: inherit;">）は、次の基本操作の準同型評価を可能にする準同型暗号化スキームです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複素数</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">ベクトルの</font><font style="vertical-align: inherit;">長さの要素ごとの加算</font><font style="vertical-align: inherit;">。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複雑なベクトルの</font><font style="vertical-align: inherit;">複数の要素の長さ</font><font style="vertical-align: inherit;">。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"></font><code>circshift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベクター内の要素の</font><font style="vertical-align: inherit;">（コンテキスト内の</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">回転</font><font style="vertical-align: inherit;">。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベクトル要素の統合されたペアリング。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメータ</font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、安全性と精度の望ましいレベルに依存し、通常は非常に高いです。この例では、4096に等しくなります（値が大きいほどセキュリティが向上しますが、計算も難しくなり</font></font><code>n log n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">スケーリングはとほぼ同じです</font><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、CKKSを使用した計算は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノイズ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が多くなり</font><font style="vertical-align: inherit;">ます。したがって、結果は概算であり、結果の正確さに影響を与えないように、結果が十分な精度で評価されるように注意する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、そのような制限は、機械学習パッケージの開発者にとって珍しいことではありません。 GPUなどの特別なアクセラレータも通常、数値ベクトルで動作します。さらに、多くの開発者にとって、選択アルゴリズムやマルチスレッドなどの影響により、浮動小数点数はノイズが多いように見えることがあります。ここでの主な違いは、CKKSプリミティブは本当にうるさいですが、実装の複雑さのために明白ではない場合でも、浮動小数点数を使用した算術計算は最初は確定的であることです。しかし、おそらくこれにより、ユーザーはノイズが見た目ほど怖くないことを理解できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、Juliaでこれらの操作を実行する方法を見てみましょう（注：非常に危険なパラメーターが選択されています。これらの操作では、REPLでのライブラリーの使用のみを示します）。</font></font><br>
<br>
<pre><code class="julia hljs">julia&gt; <span class="hljs-keyword">using</span> ToyFHE
<span class="hljs-comment"># Let's play with 8 element vectors</span>
julia&gt; N = <span class="hljs-number">8</span>;
<span class="hljs-comment"># Choose some parameters - we'll talk about it later</span>
julia&gt; ℛ = NegacyclicRing(<span class="hljs-number">2</span>N, (<span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">40</span>))<font></font>
ℤ₁₃₂₉₂₂₇₉₉₇₅₆₈₀₈₁₄₅₇₄₀₂₇₀₁₂₀₇₁₀₄₂₄₈₂₅₇/(x¹⁶ + <span class="hljs-number">1</span>)
<span class="hljs-comment"># We'll use CKKS</span><font></font>
julia&gt; params = CKKSParams(ℛ)<font></font>
CKKS parameters<font></font>
<span class="hljs-comment"># We need to pick a scaling factor for a numbers - again we'll talk about that later</span>
julia&gt; Tscale = FixedRational{<span class="hljs-number">2</span>^<span class="hljs-number">40</span>}<font></font>
FixedRational{<span class="hljs-number">1099511627776</span>,T} <span class="hljs-keyword">where</span> T
<span class="hljs-comment"># Let's start with a plain Vector of zeros</span><font></font>
julia&gt; plain = CKKSEncoding{Tscale}(zero(ℛ))<font></font>
<span class="hljs-number">8</span>-element CKKSEncoding{FixedRational{<span class="hljs-number">1099511627776</span>,T} <span class="hljs-keyword">where</span> T} with indices <span class="hljs-number">0</span>:<span class="hljs-number">7</span>:
 <span class="hljs-number">0.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">0.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">0.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">0.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">0.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">0.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">0.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">0.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
<span class="hljs-comment"># Ok, we're ready to get started, but first we'll need some keys</span><font></font>
julia&gt; kp = keygen(params)<font></font>
CKKS key pair<font></font>
julia&gt; kp.priv<font></font>
CKKS private key<font></font>
julia&gt; kp.pub<font></font>
CKKS public key<font></font>
<span class="hljs-comment"># Alright, let's encrypt some things:</span>
julia&gt; foreach(i-&gt;plain[i] = i+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>:<span class="hljs-number">7</span>); plain
<span class="hljs-number">8</span>-element CKKSEncoding{FixedRational{<span class="hljs-number">1099511627776</span>,T} <span class="hljs-keyword">where</span> T} with indices <span class="hljs-number">0</span>:<span class="hljs-number">7</span>:
 <span class="hljs-number">1.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">2.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">3.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">4.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">5.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">6.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">7.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">8.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span><font></font>
julia&gt; c = encrypt(kp.pub, plain)<font></font>
CKKS ciphertext (length <span class="hljs-number">2</span>, encoding CKKSEncoding{FixedRational{<span class="hljs-number">1099511627776</span>,T} <span class="hljs-keyword">where</span> T})
<span class="hljs-comment"># And decrypt it again</span><font></font>
julia&gt; decrypt(kp.priv, c)<font></font>
<span class="hljs-number">8</span>-element CKKSEncoding{FixedRational{<span class="hljs-number">1099511627776</span>,T} <span class="hljs-keyword">where</span> T} with indices <span class="hljs-number">0</span>:<span class="hljs-number">7</span>:
 <span class="hljs-number">0.9999999999995506</span> - <span class="hljs-number">2.7335193113350057e-16</span><span class="hljs-literal">im</span>
 <span class="hljs-number">1.9999999999989408</span> - <span class="hljs-number">3.885780586188048e-16</span><span class="hljs-literal">im</span>
  <span class="hljs-number">3.000000000000205</span> + <span class="hljs-number">1.6772825551165524e-16</span><span class="hljs-literal">im</span>
  <span class="hljs-number">4.000000000000538</span> - <span class="hljs-number">3.885780586188048e-16</span><span class="hljs-literal">im</span>
  <span class="hljs-number">4.999999999998865</span> + <span class="hljs-number">8.382500573679615e-17</span><span class="hljs-literal">im</span>
  <span class="hljs-number">6.000000000000185</span> + <span class="hljs-number">4.996003610813204e-16</span><span class="hljs-literal">im</span>
  <span class="hljs-number">7.000000000001043</span> - <span class="hljs-number">2.0024593503998215e-16</span><span class="hljs-literal">im</span>
  <span class="hljs-number">8.000000000000673</span> + <span class="hljs-number">4.996003610813204e-16</span><span class="hljs-literal">im</span>
<span class="hljs-comment"># Note that we had some noise. Let's go through all the primitive operations we'll need:</span><font></font>
julia&gt; decrypt(kp.priv, c+c)<font></font>
<span class="hljs-number">8</span>-element CKKSEncoding{FixedRational{<span class="hljs-number">1099511627776</span>,T} <span class="hljs-keyword">where</span> T} with indices <span class="hljs-number">0</span>:<span class="hljs-number">7</span>:
 <span class="hljs-number">1.9999999999991012</span> - <span class="hljs-number">5.467038622670011e-16</span><span class="hljs-literal">im</span>
 <span class="hljs-number">3.9999999999978817</span> - <span class="hljs-number">7.771561172376096e-16</span><span class="hljs-literal">im</span>
   <span class="hljs-number">6.00000000000041</span> + <span class="hljs-number">3.354565110233105e-16</span><span class="hljs-literal">im</span>
  <span class="hljs-number">8.000000000001076</span> - <span class="hljs-number">7.771561172376096e-16</span><span class="hljs-literal">im</span>
   <span class="hljs-number">9.99999999999773</span> + <span class="hljs-number">1.676500114735923e-16</span><span class="hljs-literal">im</span>
  <span class="hljs-number">12.00000000000037</span> + <span class="hljs-number">9.992007221626409e-16</span><span class="hljs-literal">im</span>
 <span class="hljs-number">14.000000000002085</span> - <span class="hljs-number">4.004918700799643e-16</span><span class="hljs-literal">im</span>
 <span class="hljs-number">16.000000000001346</span> + <span class="hljs-number">9.992007221626409e-16</span><span class="hljs-literal">im</span><font></font>
julia&gt; csq = c*c<font></font>
CKKS ciphertext (length <span class="hljs-number">3</span>, encoding CKKSEncoding{FixedRational{<span class="hljs-number">1208925819614629174706176</span>,T} <span class="hljs-keyword">where</span> T})<font></font>
julia&gt; decrypt(kp.priv, csq)<font></font>
<span class="hljs-number">8</span>-element CKKSEncoding{FixedRational{<span class="hljs-number">1208925819614629174706176</span>,T} <span class="hljs-keyword">where</span> T} with indices <span class="hljs-number">0</span>:<span class="hljs-number">7</span>:
 <span class="hljs-number">0.9999999999991012</span> - <span class="hljs-number">2.350516767363621e-15</span><span class="hljs-literal">im</span>
 <span class="hljs-number">3.9999999999957616</span> - <span class="hljs-number">5.773159728050814e-15</span><span class="hljs-literal">im</span>
  <span class="hljs-number">9.000000000001226</span> - <span class="hljs-number">2.534464540987068e-15</span><span class="hljs-literal">im</span>
 <span class="hljs-number">16.000000000004306</span> - <span class="hljs-number">2.220446049250313e-15</span><span class="hljs-literal">im</span>
  <span class="hljs-number">24.99999999998865</span> + <span class="hljs-number">2.0903753311370056e-15</span><span class="hljs-literal">im</span>
  <span class="hljs-number">36.00000000000222</span> + <span class="hljs-number">4.884981308350689e-15</span><span class="hljs-literal">im</span>
 <span class="hljs-number">49.000000000014595</span> + <span class="hljs-number">1.0182491378134327e-15</span><span class="hljs-literal">im</span>
  <span class="hljs-number">64.00000000001077</span> + <span class="hljs-number">4.884981308350689e-15</span><span class="hljs-literal">im</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とても簡単！</font><font style="vertical-align: inherit;">注意深い読者は、CSQが以前の暗号文と少し異なることに気づくかもしれません。</font><font style="vertical-align: inherit;">特に、暗号文は「長さ3」で、スケールははるかに大きくなります。</font><font style="vertical-align: inherit;">これが何で、何が必要かについての説明は、この記事の範囲を超えています。</font><font style="vertical-align: inherit;">計算を続ける前に値を下げる必要があると言えば十分です。そうしないと、「場所」は暗号文で終わります。</font><font style="vertical-align: inherit;">幸い、2つの増加した値をそれぞれ減らすことができます。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-comment"># To get back down to length 2, we need to `keyswitch` (aka</span>
<span class="hljs-comment"># relinerarize), which requires an evaluation key. Generating</span>
<span class="hljs-comment"># this requires the private key. In a real application we would</span>
<span class="hljs-comment"># have generated this up front and sent it along with the encrypted</span>
<span class="hljs-comment"># data, but since we have the private key, we can just do it now.</span><font></font>
julia&gt; ek = keygen(EvalMultKey, kp.priv)<font></font>
CKKS multiplication key<font></font>
julia&gt; csq_length2 = keyswitch(ek, csq)<font></font>
CKKS ciphertext (length <span class="hljs-number">2</span>, encoding CKKSEncoding{FixedRational{<span class="hljs-number">1208925819614629174706176</span>,T} <span class="hljs-keyword">where</span> T})
<span class="hljs-comment"># Getting the scale back down is done using modswitching.</span><font></font>
julia&gt; csq_smaller = modswitch(csq_length2)<font></font>
CKKS ciphertext (length <span class="hljs-number">2</span>, encoding CKKSEncoding{FixedRational{<span class="hljs-number">1.099511626783e12</span>,T} <span class="hljs-keyword">where</span> T})
<span class="hljs-comment"># And it still decrypts correctly (though note we've lost some precision)</span><font></font>
julia&gt; decrypt(kp.priv, csq_smaller)<font></font>
<span class="hljs-number">8</span>-element CKKSEncoding{FixedRational{<span class="hljs-number">1.099511626783e12</span>,T} <span class="hljs-keyword">where</span> T} with indices <span class="hljs-number">0</span>:<span class="hljs-number">7</span>:
 <span class="hljs-number">0.9999999999802469</span> - <span class="hljs-number">5.005163520332181e-11</span><span class="hljs-literal">im</span>
 <span class="hljs-number">3.9999999999957723</span> - <span class="hljs-number">1.0468514951188039e-11</span><span class="hljs-literal">im</span>
  <span class="hljs-number">8.999999999998249</span> - <span class="hljs-number">4.7588542623100616e-12</span><span class="hljs-literal">im</span>
 <span class="hljs-number">16.000000000023014</span> - <span class="hljs-number">1.0413447889166631e-11</span><span class="hljs-literal">im</span>
 <span class="hljs-number">24.999999999955193</span> - <span class="hljs-number">6.187833723406491e-12</span><span class="hljs-literal">im</span>
 <span class="hljs-number">36.000000000002345</span> + <span class="hljs-number">1.860733715346631e-13</span><span class="hljs-literal">im</span>
  <span class="hljs-number">49.00000000001647</span> - <span class="hljs-number">1.442396043149794e-12</span><span class="hljs-literal">im</span>
 <span class="hljs-number">63.999999999988695</span> - <span class="hljs-number">1.0722489563648028e-10</span><span class="hljs-literal">im</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、modswitching（モジュラススイッチング、モジュールスイッチングの略）は暗号文モジュールのサイズを縮小するため、これを無期限に続けることはできません（やや同型の暗号化スキームを使用します）。</font></font><br>
<br>
<pre><code class="julia hljs">julia&gt; ℛ <span class="hljs-comment"># Remember the ring we initially created</span>
ℤ₁₃₂₉₂₂₇₉₉₇₅₆₈₀₈₁₄₅₇₄₀₂₇₀₁₂₀₇₁₀₄₂₄₈₂₅₇/(x¹⁶ + <span class="hljs-number">1</span>)<font></font>
julia&gt; ToyFHE.ring(csq_smaller) <span class="hljs-comment"># It shrunk!</span>
ℤ₁₂₀₈₉₂₅₈₂₀₁₄₄₅₉₃₇₇₉₃₃₁₅₅₃/(x¹⁶ + <span class="hljs-number">1</span>)&lt;/code&gt;<font></font>
    —  (rotations).      keyswitch,       (evaluation key,     ):<font></font>
<font></font>
&lt;source lang=<span class="hljs-string">"julia"</span>&gt;julia&gt; gk = keygen(GaloisKey, kp.priv; steps=<span class="hljs-number">2</span>)<font></font>
CKKS galois key (element <span class="hljs-number">25</span>)<font></font>
julia&gt; decrypt(circshift(c, gk))<font></font>
decrypt(kp, circshift(c, gk))<font></font>
<span class="hljs-number">8</span>-element CKKSEncoding{FixedRational{<span class="hljs-number">1099511627776</span>,T} <span class="hljs-keyword">where</span> T} with indices <span class="hljs-number">0</span>:<span class="hljs-number">7</span>:
  <span class="hljs-number">7.000000000001042</span> + <span class="hljs-number">5.68459112632516e-16</span><span class="hljs-literal">im</span>
  <span class="hljs-number">8.000000000000673</span> + <span class="hljs-number">5.551115123125783e-17</span><span class="hljs-literal">im</span>
  <span class="hljs-number">0.999999999999551</span> - <span class="hljs-number">2.308655353580721e-16</span><span class="hljs-literal">im</span>
 <span class="hljs-number">1.9999999999989408</span> + <span class="hljs-number">2.7755575615628914e-16</span><span class="hljs-literal">im</span>
  <span class="hljs-number">3.000000000000205</span> - <span class="hljs-number">6.009767921608429e-16</span><span class="hljs-literal">im</span>
  <span class="hljs-number">4.000000000000538</span> + <span class="hljs-number">5.551115123125783e-17</span><span class="hljs-literal">im</span>
  <span class="hljs-number">4.999999999998865</span> + <span class="hljs-number">4.133860996136768e-17</span><span class="hljs-literal">im</span>
  <span class="hljs-number">6.000000000000185</span> - <span class="hljs-number">1.6653345369377348e-16</span><span class="hljs-literal">im</span>
<span class="hljs-comment"># And let's compare to doing the same on the plaintext</span>
julia&gt; circshift(plain, <span class="hljs-number">2</span>)
<span class="hljs-number">8</span>-element OffsetArray(::<span class="hljs-built_in">Array</span>{<span class="hljs-built_in">Complex</span>{<span class="hljs-built_in">Float64</span>},<span class="hljs-number">1</span>}, <span class="hljs-number">0</span>:<span class="hljs-number">7</span>) with eltype <span class="hljs-built_in">Complex</span>{<span class="hljs-built_in">Float64</span>} with indices <span class="hljs-number">0</span>:<span class="hljs-number">7</span>:
 <span class="hljs-number">7.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">8.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">1.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">2.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">3.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">4.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">5.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span>
 <span class="hljs-number">6.0</span> + <span class="hljs-number">0.0</span><span class="hljs-literal">im</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HEライブラリの使用の基本について説明しました。</font><font style="vertical-align: inherit;">しかし、これらのプリミティブを使用してニューラルネットワーク予測を計算する前に、それを学習するプロセスを見てみましょう。</font></font><br>
 <br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機械学習モデル</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機械学習やFlux.jlライブラリに慣れていない場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flux.jlのドキュメントを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単に</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">読む</font></a><font style="vertical-align: inherit;">か、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機械学習の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無料の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">紹介を</font></a><font style="vertical-align: inherit;">参照する</font><font style="vertical-align: inherit;">ことをお勧めし</font><font style="vertical-align: inherit;">ます。これは、モデルを暗号化されたデータに適用する際の変更点についてのみ説明するためです。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Flux zooの</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
畳み込みニューラルネットワークを使用して始めましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">データの準備など、同じトレーニングサイクルを実行します。モデルを少し設定するだけです。</font><font style="vertical-align: inherit;">彼女が来た：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> reshape_and_vcat(x)
    <span class="hljs-keyword">let</span> y=reshape(x, <span class="hljs-number">64</span>, <span class="hljs-number">4</span>, size(x, <span class="hljs-number">4</span>))<font></font>
        vcat((y[:,i,:] <span class="hljs-keyword">for</span> i=axes(y,<span class="hljs-number">2</span>))...)
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span><font></font>
model = Chain(<font></font>
    <span class="hljs-comment"># First convolution, operating upon a 28x28 image</span>
    Conv((<span class="hljs-number">7</span>, <span class="hljs-number">7</span>), <span class="hljs-number">1</span>=&gt;<span class="hljs-number">4</span>, stride=(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>), x-&gt;x.^<span class="hljs-number">2</span>),<font></font>
    reshape_and_vcat,<font></font>
    Dense(<span class="hljs-number">256</span>, <span class="hljs-number">64</span>, x-&gt;x.^<span class="hljs-number">2</span>),<font></font>
    Dense(<span class="hljs-number">64</span>, <span class="hljs-number">10</span>),<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「Secure Outsourced Matrix Computation and Application to Neural Networks」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の作業と同じモデルです。</font><font style="vertical-align: inherit;">同じ暗号化スキームを使用しますが、2つの違いがあります。1）単純化のため、モデル自体は暗号化していません。2）各レイヤーの後ベイジアンベクトルが使用されます（Fluxでは、これはデフォルトで行われます）。上記の作業でそれが何だったかはわかりません。おそらく、2番目の点が原因で、モデルのテストセットの精度はわずかに高いことがわかりました（98.6％対98.1％）が、ハイパーパラメトリックな違いも理由である可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
珍しい（機械学習の経験がある人にとって）は、</font></font><code>x.^2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">アクティブ化です。ほとんどの場合、そのような場合、彼らは</font></font><code>tanh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>relu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはより空想的なもの</font><font style="vertical-align: inherit;">を使用します</font><font style="vertical-align: inherit;">。しかし、これらの機能（特に</font></font><code>relu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は通常のテキスト値に対して簡単に計算できますが、暗号化された形式での評価には多くの計算リソースが必要になる場合があります（通常、多項式近似を推定します）。</font><font style="vertical-align: inherit;">幸いなことに、これは</font></font><code>x.^2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">うまくいきます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
学習サイクルの残りの部分は同じままでした。</font></font><code>softmax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">損失関数のために</font><font style="vertical-align: inherit;">モデルから削除しました</font></font><code>logitcrossentropy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（クライアントで復号化した後、そのままにして、softmaxを評価できます）。</font><font style="vertical-align: inherit;">モデルをトレーニングするための完全なコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHubにあり</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、新しいビデオカードでは数分で実行されます。</font></font><br>
 <br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">効果的な運用</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、実行する必要がある操作がわかりました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凝固。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素の二乗。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行列の乗算。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてを2乗するのは簡単なので、すでに上記で検討したので、他の2つの操作を検討します。</font><font style="vertical-align: inherit;">データパケットの長さは64であると想定します（モデルパラメーターとパケットサイズは、現実的なパラメーターの選択の結果として得られた4096要素のベクトルを利用するように選択されていることに気付くでしょう）。</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凝固</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
凝固のしくみを思い出してください。</font><font style="vertical-align: inherit;">元の入力配列のウィンドウ（この場合は7x7）を取得し、各ウィンドウ要素に畳み込みマスク要素を掛けます。</font><font style="vertical-align: inherit;">次に、ウィンドウをいくつかのステップに移動し（この場合、ステップは3、つまり3つの要素を移動します）、プロセスを繰り返します（同じ畳み込みマスクを使用）。</font><font style="vertical-align: inherit;">以下は、</font><font style="vertical-align: inherit;">ステップ</font><font style="vertical-align: inherit;">（青の配列-入力、緑-出力）</font><font style="vertical-align: inherit;">での3x3畳み込み</font><font style="vertical-align: inherit;">のプロセス（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">のアニメーションです</font></font><code>(2, 2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/h5/a3/q3/h5a3q3ea0pljgdagz1wd-k2igdy.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、4つの異なる「チャネル」でたたみ込みを実行します（つまり、異なるマスクでたたみ込みをさらに3回繰り返します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、私たちは何をすべきかを知っています、それはどのように理解するために残っています。</font><font style="vertical-align: inherit;">畳み込みがモデルの最初の操作であるのは幸運です。</font><font style="vertical-align: inherit;">その結果、リソースを節約するために、クライアントでデータを前処理し、（重みを使用せずに）データを暗号化できます。</font><font style="vertical-align: inherit;">これをやろう：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初に、各コンボリューションウィンドウ（つまり、ソース画像からの7x7サンプル）を計算します。これにより、各入力画像に対して64個の7x7行列が得られます。</font><font style="vertical-align: inherit;">2 x増分の7x7ウィンドウの場合、28x28入力画像を評価するための8x8畳み込みウィンドウがあることに注意してください。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各ウィンドウの同じ位置を1つのベクトルで収集しましょう。</font><font style="vertical-align: inherit;">つまり、各画像について、64要素のベクトル、またはサイズ64のパケットの64x64要素のベクトル（合計49の行列64x64）があります。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暗号化します。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、凝固は単純に、マトリックス全体と対応するマスク要素のスカラー倍算になります。</font><font style="vertical-align: inherit;">その後、49個の要素をすべて合計すると、折りたたみの結果が得られます。</font><font style="vertical-align: inherit;">この戦略の実装は次のようになります（プレーンテキスト）。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> public_preprocess(batch)<font></font>
    ka = OffsetArray(<span class="hljs-number">0</span>:<span class="hljs-number">7</span>, <span class="hljs-number">0</span>:<span class="hljs-number">7</span>)
    <span class="hljs-comment"># Create feature extracted matrix</span>
    <span class="hljs-literal">I</span> = [[batch[i′*<span class="hljs-number">3</span> .+ (<span class="hljs-number">1</span>:<span class="hljs-number">7</span>), j′*<span class="hljs-number">3</span> .+ (<span class="hljs-number">1</span>:<span class="hljs-number">7</span>), <span class="hljs-number">1</span>, k] <span class="hljs-keyword">for</span> i′=ka, j′=ka] <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:<span class="hljs-number">64</span>]
    <span class="hljs-comment"># Reshape into the ciphertext</span>
    Iᵢⱼ = [[<span class="hljs-literal">I</span>[k][l...][i,j] <span class="hljs-keyword">for</span> k=<span class="hljs-number">1</span>:<span class="hljs-number">64</span>, l=product(ka, ka)] <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>:<span class="hljs-number">7</span>, j=<span class="hljs-number">1</span>:<span class="hljs-number">7</span>]
<span class="hljs-keyword">end</span><font></font>
Iᵢⱼ = public_preprocess(batch)<font></font>
<span class="hljs-comment"># Evaluate the convolution</span>
weights = model.layers[<span class="hljs-number">1</span>].weight<font></font>
conv_weights = reverse(reverse(weights, dims=<span class="hljs-number">1</span>), dims=<span class="hljs-number">2</span>)<font></font>
conved = [sum(Iᵢⱼ[i,j]*conv_weights[i,j,<span class="hljs-number">1</span>,channel] <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>:<span class="hljs-number">7</span>, j=<span class="hljs-number">1</span>:<span class="hljs-number">7</span>) <span class="hljs-keyword">for</span> channel = <span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<font></font>
conved = map(((x,b),)-&gt;x .+ b, zip(conved, model.layers[<span class="hljs-number">1</span>].bias))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これ（次元の変化の係数）（モジュロ-次元の順序の変化）は、操作と同じ答えを与えます</font></font><code>model.layers[1](batch)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暗号化操作を追加します。</font></font><br>
<br>
<pre><code class="julia hljs">Iᵢⱼ = public_preprocess(batch)<font></font>
C_Iᵢⱼ = map(Iᵢⱼ) <span class="hljs-keyword">do</span> Iij<font></font>
    plain = CKKSEncoding{Tscale}(zero(plaintext_space(ckks_params)))<font></font>
    plain .= OffsetArray(vec(Iij), <span class="hljs-number">0</span>:(N÷<span class="hljs-number">2</span>-<span class="hljs-number">1</span>))<font></font>
    encrypt(kp, plain)<font></font>
<span class="hljs-keyword">end</span>
weights = model.layers[<span class="hljs-number">1</span>].weight<font></font>
conv_weights = reverse(reverse(weights, dims=<span class="hljs-number">1</span>), dims=<span class="hljs-number">2</span>)<font></font>
conved3 = [sum(C_Iᵢⱼ[i,j]*conv_weights[i,j,<span class="hljs-number">1</span>,channel] <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>:<span class="hljs-number">7</span>, j=<span class="hljs-number">1</span>:<span class="hljs-number">7</span>) <span class="hljs-keyword">for</span> channel = <span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<font></font>
conved2 = map(((x,b),)-&gt;x .+ b, zip(conved3, model.layers[<span class="hljs-number">1</span>].bias))<font></font>
conved1 = map(ToyFHE.modswitch, conved2)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウェイトは公開されているため、ここではキースイッチは必要ありません。</font><font style="vertical-align: inherit;">したがって、暗号文の長さは増やしません。</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行列の乗算</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
行列の乗算に移ります。ベクトルの要素の回転を使用して、乗算インデックスの順序を変更できます。</font><font style="vertical-align: inherit;">ベクトル内の行列要素の行ごとの配置を検討してください。</font><font style="vertical-align: inherit;">行のサイズの倍数でベクトルをシフトすると、列の回転の効果が得られます。これは、行列の乗算（少なくとも正方行列）を実装するのに十分なプリミティブです。</font><font style="vertical-align: inherit;">やってみよう：</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> matmul_square_reordered(weights, x)<font></font>
    sum(<span class="hljs-number">1</span>:size(weights, <span class="hljs-number">1</span>)) <span class="hljs-keyword">do</span> k
        <span class="hljs-comment"># We rotate the columns of the LHS and take the diagonal</span>
        weight_diag = diag(circshift(weights, (<span class="hljs-number">0</span>,(k-<span class="hljs-number">1</span>))))
        <span class="hljs-comment"># We rotate the rows of the RHS</span>
        x_rotated = circshift(x, (k-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>))
        <span class="hljs-comment"># We do an elementwise, broadcast multiply</span><font></font>
        weight_diag .* x_rotated<font></font>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
<span class="hljs-keyword">function</span> matmul_reorderd(weights, x)<font></font>
    sum(partition(<span class="hljs-number">1</span>:<span class="hljs-number">256</span>, <span class="hljs-number">64</span>)) <span class="hljs-keyword">do</span> range<font></font>
        matmul_square_reordered(weights[:, range], x[range, :])<font></font>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
fc1_weights = model.layers[<span class="hljs-number">3</span>].W<font></font>
x = rand(<span class="hljs-built_in">Float64</span>, <span class="hljs-number">256</span>, <span class="hljs-number">64</span>)
<span class="hljs-meta">@assert</span> (fc1_weights*x) ≈ matmul_reorderd(fc1_weights, x)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、一般的な行列の乗算には、もっと複雑なものが必要ですが、今のところこれで十分です。</font></font><br>
 <br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクニックの向上</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、テクニックのすべてのコンポーネントが機能します。</font><font style="vertical-align: inherit;">次にコード全体を示します（選択オプションの設定などを除く）。</font></font><br>
 <br>
<pre><code class="julia hljs">ek = keygen(EvalMultKey, kp.priv)<font></font>
gk = keygen(GaloisKey, kp.priv; steps=<span class="hljs-number">64</span>)<font></font>
Iᵢⱼ = public_preprocess(batch)<font></font>
C_Iᵢⱼ = map(Iᵢⱼ) <span class="hljs-keyword">do</span> Iij<font></font>
    plain = CKKSEncoding{Tscale}(zero(plaintext_space(ckks_params)))<font></font>
    plain .= OffsetArray(vec(Iij), <span class="hljs-number">0</span>:(N÷<span class="hljs-number">2</span>-<span class="hljs-number">1</span>))<font></font>
    encrypt(kp, plain)<font></font>
<span class="hljs-keyword">end</span>
weights = model.layers[<span class="hljs-number">1</span>].weight<font></font>
conv_weights = reverse(reverse(weights, dims=<span class="hljs-number">1</span>), dims=<span class="hljs-number">2</span>)<font></font>
conved3 = [sum(C_Iᵢⱼ[i,j]*conv_weights[i,j,<span class="hljs-number">1</span>,channel] <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>:<span class="hljs-number">7</span>, j=<span class="hljs-number">1</span>:<span class="hljs-number">7</span>) <span class="hljs-keyword">for</span> channel = <span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<font></font>
conved2 = map(((x,b),)-&gt;x .+ b, zip(conved3, model.layers[<span class="hljs-number">1</span>].bias))<font></font>
conved1 = map(ToyFHE.modswitch, conved2)<font></font>
Csqed1 = map(x-&gt;x*x, conved1)<font></font>
Csqed1 = map(x-&gt;keyswitch(ek, x), Csqed1)<font></font>
Csqed1 = map(ToyFHE.modswitch, Csqed1)<font></font>
<span class="hljs-keyword">function</span> encrypted_matmul(gk, weights, x::ToyFHE.CipherText)<font></font>
    result = repeat(diag(weights), inner=<span class="hljs-number">64</span>).*x<font></font>
    rotated = x<font></font>
    <span class="hljs-keyword">for</span> k = <span class="hljs-number">2</span>:<span class="hljs-number">64</span><font></font>
        rotated = ToyFHE.rotate(gk, rotated)<font></font>
        result += repeat(diag(circshift(weights, (<span class="hljs-number">0</span>,(k-<span class="hljs-number">1</span>)))), inner=<span class="hljs-number">64</span>) .* rotated
    <span class="hljs-keyword">end</span><font></font>
    result<font></font>
<span class="hljs-keyword">end</span>
fq1_weights = model.layers[<span class="hljs-number">3</span>].W<font></font>
Cfq1 = sum(enumerate(partition(<span class="hljs-number">1</span>:<span class="hljs-number">256</span>, <span class="hljs-number">64</span>))) <span class="hljs-keyword">do</span> (i,range)<font></font>
    encrypted_matmul(gk, fq1_weights[:, range], Csqed1[i])<font></font>
<span class="hljs-keyword">end</span>
Cfq1 = Cfq1 .+ OffsetArray(repeat(model.layers[<span class="hljs-number">3</span>].b, inner=<span class="hljs-number">64</span>), <span class="hljs-number">0</span>:<span class="hljs-number">4095</span>)<font></font>
Cfq1 = modswitch(Cfq1)<font></font>
Csqed2 = Cfq1*Cfq1<font></font>
Csqed2 = keyswitch(ek, Csqed2)<font></font>
Csqed2 = modswitch(Csqed2)<font></font>
<span class="hljs-keyword">function</span> naive_rectangular_matmul(gk, weights, x)
    <span class="hljs-meta">@assert</span> size(weights, <span class="hljs-number">1</span>) &lt; size(weights, <span class="hljs-number">2</span>)<font></font>
    weights = vcat(weights, zeros(eltype(weights), size(weights, <span class="hljs-number">2</span>)-size(weights, <span class="hljs-number">1</span>), size(weights, <span class="hljs-number">2</span>)))<font></font>
    encrypted_matmul(gk, weights, x)<font></font>
<span class="hljs-keyword">end</span>
fq2_weights = model.layers[<span class="hljs-number">4</span>].W<font></font>
Cresult = naive_rectangular_matmul(gk, fq2_weights, Csqed2)<font></font>
Cresult = Cresult .+ OffsetArray(repeat(vcat(model.layers[<span class="hljs-number">4</span>].b, zeros(<span class="hljs-number">54</span>)), inner=<span class="hljs-number">64</span>), <span class="hljs-number">0</span>:<span class="hljs-number">4095</span>)</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
見栄えはよくありませんが、これをすべて実行した場合は、すべての手順を理解する必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、どのような抽象化が私たちの生活を簡素化できるかを考えてみましょう。</font><font style="vertical-align: inherit;">地図作成と機械学習の分野を離れ、プログラミング言語のアーキテクチャに移るので、Juliaで強力な抽象化を使用および作成できるという事実を利用してみましょう。</font><font style="vertical-align: inherit;">たとえば、畳み込みを配列型に抽出するプロセス全体をカプセル化できます。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> BlockArrays
<span class="hljs-string">"""
    ExplodedConvArray{T, Dims, Storage} &lt;: AbstractArray{T, 4}
Represents a an `nxmx1xb` array of images, but rearranged into a
series of convolution windows. Evaluating a convolution compatible
with `Dims` on this array is achievable through a sequence of
scalar multiplications and sums on the underling storage.
"""</span>
<span class="hljs-keyword">struct</span> ExplodedConvArray{T, <span class="hljs-built_in">Dims</span>, Storage} &lt;: <span class="hljs-built_in">AbstractArray</span>{T, <span class="hljs-number">4</span>}
    <span class="hljs-comment"># sx*sy matrix of b*(dx*dy) matrices of extracted elements</span>
    <span class="hljs-comment"># where (sx, sy) = kernel_size(Dims)</span>
    <span class="hljs-comment">#       (dx, dy) = output_size(DenseConvDims(...))</span>
    cdims::<span class="hljs-built_in">Dims</span>
    x::<span class="hljs-built_in">Matrix</span>{Storage}
    <span class="hljs-keyword">function</span> ExplodedConvArray{T, <span class="hljs-built_in">Dims</span>, Storage}(cdims::<span class="hljs-built_in">Dims</span>, storage::<span class="hljs-built_in">Matrix</span>{Storage}) <span class="hljs-keyword">where</span> {T, <span class="hljs-built_in">Dims</span>, Storage}
        <span class="hljs-meta">@assert</span> all(==(size(storage[<span class="hljs-number">1</span>])), size.(storage))<font></font>
        new{T, <span class="hljs-built_in">Dims</span>, Storage}(cdims, storage)
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
Base.size(ex::ExplodedConvArray) = (NNlib.input_size(ex.cdims)..., <span class="hljs-number">1</span>, size(ex.x[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>))
<span class="hljs-keyword">function</span> ExplodedConvArray{T}(cdims, batch::<span class="hljs-built_in">AbstractArray</span>{T, <span class="hljs-number">4</span>}) <span class="hljs-keyword">where</span> {T}<font></font>
    x, y = NNlib.output_size(cdims)<font></font>
    kx, ky = NNlib.kernel_size(cdims)<font></font>
    stridex, stridey = NNlib.stride(cdims)<font></font>
    kax = OffsetArray(<span class="hljs-number">0</span>:x-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>:x-<span class="hljs-number">1</span>)<font></font>
    kay = OffsetArray(<span class="hljs-number">0</span>:x-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>:x-<span class="hljs-number">1</span>)
    <span class="hljs-literal">I</span> = [[batch[i′*stridex .+ (<span class="hljs-number">1</span>:kx), j′*stridey .+ (<span class="hljs-number">1</span>:ky), <span class="hljs-number">1</span>, k] <span class="hljs-keyword">for</span> i′=kax, j′=kay] <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:size(batch, <span class="hljs-number">4</span>)]<font></font>
    Iᵢⱼ = [[<span class="hljs-literal">I</span>[k][l...][i,j] <span class="hljs-keyword">for</span> k=<span class="hljs-number">1</span>:size(batch, <span class="hljs-number">4</span>), l=product(kax, kay)] <span class="hljs-keyword">for</span> (i,j) <span class="hljs-keyword">in</span> product(<span class="hljs-number">1</span>:kx, <span class="hljs-number">1</span>:ky)]<font></font>
    ExplodedConvArray{T, typeof(cdims), eltype(Iᵢⱼ)}(cdims, Iᵢⱼ)<font></font>
<span class="hljs-keyword">end</span>
<span class="hljs-keyword">function</span> NNlib.conv(x::ExplodedConvArray{&lt;:<span class="hljs-built_in">Any</span>, <span class="hljs-built_in">Dims</span>}, weights::<span class="hljs-built_in">AbstractArray</span>{&lt;:<span class="hljs-built_in">Any</span>, <span class="hljs-number">4</span>}, cdims::<span class="hljs-built_in">Dims</span>) <span class="hljs-keyword">where</span> {<span class="hljs-built_in">Dims</span>&lt;:ConvDims}<font></font>
    blocks = reshape([ Base.ReshapedArray(sum(x.x[i,j]*weights[i,j,<span class="hljs-number">1</span>,channel] <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>:<span class="hljs-number">7</span>, j=<span class="hljs-number">1</span>:<span class="hljs-number">7</span>), (NNlib.output_size(cdims)...,<span class="hljs-number">1</span>,size(x, <span class="hljs-number">4</span>)), ()) <span class="hljs-keyword">for</span> channel = <span class="hljs-number">1</span>:<span class="hljs-number">4</span> ],(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>))<font></font>
    BlockArrays._BlockArray(blocks, BlockArrays.BlockSizes([<span class="hljs-number">8</span>], [<span class="hljs-number">8</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], [<span class="hljs-number">64</span>]))
<span class="hljs-keyword">end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでも</font><font style="vertical-align: inherit;">、ソースコードと同様に、</font><font style="vertical-align: inherit;">4つの配列の形式で</font></font><code>BlockArrays</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列を表すために</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">ました。</font><font style="vertical-align: inherit;">これで、少なくとも暗号化されていない配列で、最初のステージのプレゼンテーションがはるかに美しくなりました。</font></font><code>8x8x4x64</code><font style="vertical-align: inherit;"></font><code>8x8x1x64</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="julia hljs">julia&gt; cdims = DenseConvDims(batch, model.layers[<span class="hljs-number">1</span>].weight; stride=(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>), padding=(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), dilation=(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<font></font>
DenseConvDims: (<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>) * (<span class="hljs-number">7</span>, <span class="hljs-number">7</span>) -&gt; (<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>), stride: (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>) pad: (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), dil: (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), flip: <span class="hljs-literal">false</span><font></font>
julia&gt; a = ExplodedConvArray{eltype(batch)}(cdims, batch);<font></font>
julia&gt; model(a)<font></font>
<span class="hljs-number">10</span>×<span class="hljs-number">64</span> <span class="hljs-built_in">Array</span>{<span class="hljs-built_in">Float32</span>,<span class="hljs-number">2</span>}:<font></font>
[snip]<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを暗号化とどのように結び付けますか？</font><font style="vertical-align: inherit;">これを行うには、次のものが必要です。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造（</font></font><code>ExplodedConvArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を暗号化して、各フィールドの暗号文を取得します。</font><font style="vertical-align: inherit;">そのような暗号化された構造での操作は、関数が元の構造で何をするかを検証し、同じことを準同型的に行います。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暗号化されたコンテキストで異なる方法で実行するために、特定の操作をインターセプトします。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸い、Juliaはこのための抽象化を提供します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">つまり、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cassette.jl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メカニズムを使用するコンパイラプラグインです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それが何であり、どのように機能するかはお話ししません。たとえば</font></font><code>Encrypted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">コンテキストを決定できると簡単に説明します。</font><font style="vertical-align: inherit;">次に、このコンテキストでの操作の動作規則を定義します。</font><font style="vertical-align: inherit;">たとえば、2番目の要件としてこれを記述できます。</font></font><br>
<br>
<pre><code class="julia hljs"><span class="hljs-comment"># Define Matrix multiplication between an array and an encrypted block array</span>
<span class="hljs-keyword">function</span> (*::Encrypted{typeof(*)})(a::<span class="hljs-built_in">Array</span>{T, <span class="hljs-number">2</span>}, b::Encrypted{&lt;:BlockArray{T, <span class="hljs-number">2</span>}}) <span class="hljs-keyword">where</span> {T}<font></font>
    sum(a*b <span class="hljs-keyword">for</span> (i,range) <span class="hljs-keyword">in</span> enumerate(partition(<span class="hljs-number">1</span>:size(a, <span class="hljs-number">2</span>), size(b.blocks[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>))))
<span class="hljs-keyword">end</span>
<span class="hljs-comment"># Define Matrix multiplication between an array and an encrypted array</span>
<span class="hljs-keyword">function</span> (*::Encrypted{typeof(*)})(a::<span class="hljs-built_in">Array</span>{T, <span class="hljs-number">2</span>}, b::Encrypted{<span class="hljs-built_in">Array</span>{T, <span class="hljs-number">2</span>}}) <span class="hljs-keyword">where</span> {T}<font></font>
    result = repeat(diag(a), inner=size(a, <span class="hljs-number">1</span>)).*x<font></font>
    rotated = b<font></font>
    <span class="hljs-keyword">for</span> k = <span class="hljs-number">2</span>:size(a, <span class="hljs-number">2</span>)<font></font>
        rotated = ToyFHE.rotate(GaloisKey(*), rotated)<font></font>
        result += repeat(diag(circshift(a, (<span class="hljs-number">0</span>,(k-<span class="hljs-number">1</span>)))), inner=size(a, <span class="hljs-number">1</span>)) .* rotated
    <span class="hljs-keyword">end</span><font></font>
    result<font></font>
<span class="hljs-keyword">end</span>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、ユーザーは上記のすべてを最小限の手作業で書くことができます。</font></font><br>
<br>
<pre><code class="julia hljs">kp = keygen(ckks_params)<font></font>
ek = keygen(EvalMultKey, kp.priv)<font></font>
gk = keygen(GaloisKey, kp.priv; steps=<span class="hljs-number">64</span>)
<span class="hljs-comment"># Create evaluation context</span><font></font>
ctx = Encrypted(ek, gk)<font></font>
<span class="hljs-comment"># Do public preprocessing</span><font></font>
batch = ExplodedConvArray{eltype(batch)}(cdims, batch);<font></font>
<span class="hljs-comment"># Run on encrypted data under the encryption context</span><font></font>
Cresult = ctx(model)(encrypt(kp.pub, batch))<font></font>
<span class="hljs-comment"># Decrypt the answer</span>
decrypt(kp, Cresult)</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これでも十分ではないかもしれません。</font><font style="vertical-align: inherit;">暗号システムのパラメータ（つまり、modswitch、keyswitchなどをいつ適用するか）は、応答の精度とパフォーマンスの間の妥協点を反映しており、実行可能コードに大きく依存しています。</font><font style="vertical-align: inherit;">実行しようとしているコードをコンパイラーで分析し、特定のレベルのセキュリティーと必要な精度のパラメーターを提案してから、最小限の手動介入でコードを生成します。</font></font><br>
 <br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
任意の計算を自動的かつ安全に実行するという夢を実現することは、どのシステムにとっても困難な作業です。しかし、ジュリアのメタプログラミング機能と使いやすい構文により、このツールは適切な開発プラットフォームになっています。 RAMPARTSコラボレーション（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">論文</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JuliaConトーク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は、この方向への最初のステップをすでに</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">踏襲し</font></a><font style="vertical-align: inherit;">ています。単純なJuliaコードが完全に同種のPALISADEライブラリにコンパイルされています。 Julia Computingが</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">最近発表さ</font></a><font style="vertical-align: inherit;">れたヴェローナのRAMPARTSエキスパートと協力</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この次世代システムのバージョン。</font><font style="vertical-align: inherit;">昨年、準同型暗号化システムのパフォーマンスにより、実用的なレベルに近い速度で興味深い計算を評価できます。</font><font style="vertical-align: inherit;">門は開いています。</font><font style="vertical-align: inherit;">アルゴリズム、ソフトウェア、ハードウェアの新しい開発により、準同型暗号化は間違いなく何百万人ものユーザーのプライバシーを保護するための主要な技術になるでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題をより詳しく理解したい場合は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ToyFHEリポジトリを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チェックし</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">てください</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このトピックに関連する暗号化への受け入れ可能な入門になることを願う</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はまだあり</font><font style="vertical-align: inherit;">ます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja478502/index.html">みんなのためのスマートテクノロジー</a></li>
<li><a href="../ja478504/index.html">ノートパソコンの進化に伴って職場がどのように変化するか</a></li>
<li><a href="../ja478506/index.html">SiC：マイクロエレクトロニクスはシリコンだけではありません</a></li>
<li><a href="../ja478508/index.html">サービスとしての電報</a></li>
<li><a href="../ja478510/index.html">DINS QA EVENING 12/12/19にご招待します。私たちはJenkins Pipelineを作成し、テストの起動を彼らの助けを借りて並列化する方法を学びます</a></li>
<li><a href="../ja478516/index.html">HoudiniとUnityの手続き型道路</a></li>
<li><a href="../ja478518/index.html">Zextras / Zimbra OSEにオフィスインフラストラクチャを展開した経験</a></li>
<li><a href="../ja478522/index.html">認めます、ワトソン、あなたは完全に困惑していますか？</a></li>
<li><a href="../ja478526/index.html">Windows ServerとMikrotik上の一連のOpenVPNとLinuxへの移行</a></li>
<li><a href="../ja478528/index.html">ペット（ファンタスティックストーリー）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>