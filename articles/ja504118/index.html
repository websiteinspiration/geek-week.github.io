<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕡 👌 🐷 オンラインコースの自動ヒントシステム 🤹🏼 ✍🏽 👨🏼‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私はJetBrains Researchでソフトウェアエンジニアリングに機械学習技術を適用することを専門とするグループで働いています。この記事では、私たちのプロジェクトの1つである、オンラインプログラミングコースの自動ヒントシステムについて説明します。
 
 オンラインプログラミングコースは、さらな...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>オンラインコースの自動ヒントシステム</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/504118/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JetBrains Research</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でソフトウェアエンジニアリングに機械学習技術を適用することを専門とするグループで</font><font style="vertical-align: inherit;">働いてい</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">この記事では、私たちのプロジェクトの1つである、オンラインプログラミングコースの自動ヒントシステムについて説明します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オンラインプログラミングコースは、さらなる教育を受けるための一般的な方法です。このようなコースでは、学生はテキストを読んだり、新しい教材を説明するビデオを見たりして、いくつかの実際的な問題を解決することができます。自動テストシステムは、事前に準備された一連のテストで送信された各ソリューションを実行し、テスト結果を生徒に通知します。このタイプのトレーニングには、従来の教育システムに比べて多くの明らかな利点があります。学生の数に制限はなく、都合の良い時間に、都合の良い場所で勉強できます。ただし、デメリットもあります。たとえば、弱いフィードバック。教師は生徒に間違いの内容と注意事項を説明しますが、自動テストシステムはソリューションの正確性のみを検証できます。もちろんコメントでコースの作成者に助けを求めることができますが、特にそのような要求が多い場合、答えは長い間待たなければなりません。この問題は、プロンプトを発行する自動システムによって解決できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、ソースコードの問題を見つけるための古典的なアプローチ（コードのにおいの定義、リファクタリングの推奨、エラーの予測）は、ここでは効果的ではありません。大規模な産業プロジェクト向けに開発されたものであり、実際的な問題の解決は通常、1つの方法でしかできません。ただし、私たちのタスク用に特別に設計されたソリューションがあります。通常、彼らはどういうわけか間違った決定と正しい決定の違いを分析し、テンプレートの助けを借りて、「26行目でintをlongに置き換える」のようなヒントが生成されます。このようなヒントは、解決策を修正する方法を示していますが、エラーが何であるかを述べていないため、教師の説明とはかけ離れています。したがって、生徒はエラーを自己分析する意欲を失います。教師は通常、「入力データのサイズ制限に注意してください。-または--intオーバーフローがあります。私たちの調査では、決定を修正するのではなく、決定を修正するのに役立つより高いレベルのヒントを提供するという目標を設定しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに議論するために、いくつかの概念を紹介する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象構文ツリー（AST）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、プログラムコードの</font><b><font style="vertical-align: inherit;">ツリーの</font></b><font style="vertical-align: inherit;">ような表現で、コードのセマンティクスに関する完全な情報が含まれていますが、構文の詳細（書式、角かっこ、コンマ）は省略されています。ツリー内の各頂点は、タイプ（持つ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">number_literal、primitive_type、for_statement</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、等）、ラベル（「1」、「566」、等のため</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">number_literal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、「長い」、「二重」など「INT」を、 Eの。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primitive_type</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、空の文字列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for_statement</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">編集スクリプト</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ある抽象構文ツリーを別の構文ツリーに変換する一連の基本的な変更（頂点の追加、頂点の削除、頂点の移動、頂点ラベルの変更）です。</font><font style="vertical-align: inherit;">ASTを構築して編集スクリプトを生成するために、GumTreeライブラリを使用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、次の2つのコードを考えてみます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
   <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;<font></font>
   tmp++;<font></font>
}</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> そして</font></font><br>
<pre><code class="java hljs"><span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10</span>; i++) {<font></font>
   tmp++;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の場合、ASTは次のようになります</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5v/nu/gc/5vnugc_dg8ghsx1xq9judo55bfm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。2番目の場合、このように</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fm/rz/sn/fmrzsnkntprzrtyun68k0dtl5eg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なります。便宜上、一部の頂点は色で強調表示されています。</font><font style="vertical-align: inherit;">次に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のツリーを2番目のツリーに変換</font><b><font style="vertical-align: inherit;">する編集スクリプト</font></b><font style="vertical-align: inherit;">は次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zf/4u/e2/zf4ue2ulz1h8nu23m2zhstclvgq.png" width="450"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、間違ったソリューションを正しいソリューションと比較すると、編集スクリプトの形式で修正を得ることができます。問題は、プロンプトをこの修正に関連付ける方法です。すでに送信されたソリューションのすべての修正について、誰かがヒントを書いた場合、タスクは古典的な分類問題に削減されます。しかし、残念ながら、データには通常ラベルが付けられていません。この問題を解決するために、頻繁に発生するエラーを強調表示し、少なくともそれらにマークを付けます。将来的には、ペギングの段階で、専門家がヒントを書く必要があります。ヒントは、学生が正しい判断を下せるように設計された一貫したテキストです。得られたマークアップされた修正サンプルを使用して、分類子をトレーニングしました。次に、各ステージについて詳しく説明します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rq/4s/fb/rq4sfbxbtrzdg4v_ihcrl2fk7uy.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステップ1：データの準備。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まず、ASTを構築することが不可能であった誤った決定が排除されました。さらに、ソリューションからコメントが削除され、変数名が標準化され、同型構造が1種類に削減されました（数式で余分な括弧が削除され、オプションの括弧がif-sとfor-sに追加され、型がtry-catchの型結合構文でアルファベット順にソートされました） 。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステップ2：修正を強調表示します。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当初は、クラスタリングの段階で、最後の誤った決定と各セッションの最初の権利の間の変更を使用するように計画されていました。ただし、同じエラーをさまざまな方法で修正できることがわかりました。エラー修正方法を標準化するために、同じセッションからの正しい解決策ではなく、すべての既知の正しい解決策との違いを探し、結果として生じる編集スクリプトの最も短いものを使用することが決定されました。分類の段階で、新しい誤ったソリューションについて、編集スクリプトが同じ方法で検索されました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステップ3：一般的なエラーを特定する。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つの問題の解決策の修正データベースは、階層的凝集クラスタリングアルゴリズムを使用してクラスタ化されました。このアルゴリズムは次のように機能します。最初に、各要素が独自のクラスターに配置され、次に各ステップで、近くのクラスターのペアが1つになり、1つにマージされます。このプロセスは、最も近いクラスター間の距離が大きすぎる場合、または残っているクラスターが少なすぎる場合に終了します。結果として得られたクラスターの中で最大のもののいくつかは手動でラベル付けされました。結果のクラスターの図の例を以下に示します。</font></font><br>
<img src="https://habrastorage.org/webt/ax/vm/p2/axvmp2m7jgctkzlsjwijtmcgame.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4番目のステップ：分類器の構築。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この作業では、重み付けされた投票を持つk個の最近傍のアルゴリズムを使用しました。新しい要素を分類するために、それらが属するクラスに投票するトレーニングセットからそれに最も近いk要素があり、要素が新しい要素に近いほど、その声の重みが大きくなります。分類する際、考えられるエラーは3番目のステップで見つけたものに限定されないため、分類の結果だけでなく、その信頼度も重要であることを覚えておく価値があります。信頼度がしきい値を下回っている場合は、エラーを特定できなかったため、ヒントが得られたと考えられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用されている分類およびクラスタリングアルゴリズムが機能するためには、編集スクリプト間の距離の関数が必要であることに気付くでしょう。</font><font style="vertical-align: inherit;">さまざまなアプローチを比較するために、広範な作業が行われました。</font><font style="vertical-align: inherit;">以下では、検討されるアプローチについて簡単に説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのセット間の距離の古典的な関数は、ジャカード係数です。</font><font style="vertical-align: inherit;">マルチセットAとBのペアの場合、Jacquard係数の値は次の式で計算できます。</font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn><mo>&amp;#x2212;</mo><mfrac><mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>A</mi><mo>&amp;#x2229;</mo><mi>B</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow></mrow><mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>A</mi><mo>&amp;#x222A;</mo><mi>B</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow></mrow></mfrac></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.33ex" height="4.384ex" viewBox="0 -1186 4017 1887.7" role="img" focusable="false" style="vertical-align: -1.63ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/JetBrains-education/blog/504118/&amp;usg=ALkJrhgfXorteM35AKt_yk3YlP3zIDfKrw#MJMAIN-31" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/JetBrains-education/blog/504118/&amp;usg=ALkJrhgfXorteM35AKt_yk3YlP3zIDfKrw#MJMAIN-2212" x="722" y="0"></use><g transform="translate(1501,0)"><g transform="translate(342,0)"><rect stroke="none" width="2053" height="60" x="0" y="220"></rect><g transform="translate(60,587)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/JetBrains-education/blog/504118/&amp;usg=ALkJrhgfXorteM35AKt_yk3YlP3zIDfKrw#MJMAIN-7C" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/JetBrains-education/blog/504118/&amp;usg=ALkJrhgfXorteM35AKt_yk3YlP3zIDfKrw#MJMATHI-41" x="278" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/JetBrains-education/blog/504118/&amp;usg=ALkJrhgfXorteM35AKt_yk3YlP3zIDfKrw#MJMAIN-2229" x="1029" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/JetBrains-education/blog/504118/&amp;usg=ALkJrhgfXorteM35AKt_yk3YlP3zIDfKrw#MJMATHI-42" x="1696" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/JetBrains-education/blog/504118/&amp;usg=ALkJrhgfXorteM35AKt_yk3YlP3zIDfKrw#MJMAIN-7C" x="2456" y="0"></use></g><g transform="translate(60,-442)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/JetBrains-education/blog/504118/&amp;usg=ALkJrhgfXorteM35AKt_yk3YlP3zIDfKrw#MJMAIN-7C" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/JetBrains-education/blog/504118/&amp;usg=ALkJrhgfXorteM35AKt_yk3YlP3zIDfKrw#MJMATHI-41" x="278" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/JetBrains-education/blog/504118/&amp;usg=ALkJrhgfXorteM35AKt_yk3YlP3zIDfKrw#MJMAIN-222A" x="1029" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/JetBrains-education/blog/504118/&amp;usg=ALkJrhgfXorteM35AKt_yk3YlP3zIDfKrw#MJMATHI-42" x="1696" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/company/JetBrains-education/blog/504118/&amp;usg=ALkJrhgfXorteM35AKt_yk3YlP3zIDfKrw#MJMAIN-7C" x="2456" y="0"></use></g></g></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo>−</mo><mfrac><mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>A</mi><mo>∩</mo><mi>B</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow></mrow><mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>A</mi><mo>∪</mo><mi>B</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow></mrow></mfrac></math></span></span><script type="math/tex" id="MathJax-Element-1">1 - \frac{|A \cap B|}{|A \cup B|}</script><br>
<br><br>
<br>
<img src="https://habrastorage.org/webt/ml/nq/7q/mlnq7qjrugywiju5fv3fgrbn7kq.png" width="500"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的な変更のためのベクトルを追加すると、編集シナリオ全体を特徴付けるベクトルを取得できます。コサイン距離は、ベクトル間の距離の関数として使用されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素の同等性ではなく、類似性の度合いに基づいて、ファジージャガード係数を決定することもできます。基本変更の類似性は、ヒューリスティック式、または前の段落のコサイン距離とベクトル化を使用して決定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用される最後のアプローチは、単語のバッグまたは単語のバッグです。このアプローチのフレームワークでは、コンテキストに関するさまざまな情報を考慮して、最初の基本的な変更がいくつかの方法で文字列にエンコードされ、次にそのような文字列のディクショナリがコンパイルされ、各要素に一意の数値識別子が割り当てられ、要素のマルチセットのベクトル表現としてベクトルが使用されます。 i番目のタイプの要素の数。ベクトル間の距離もコサインです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、実際の部分に移りましょう。この作業では、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Stepik</font></a><font style="vertical-align: inherit;">プラットフォームが提供する匿名のJava言語データセットを使用しました。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。そのため、解決策にはいくつかの可能なアプローチがありましたが、それでも最適なパラメーターを選択する必要があります。このために、4つのタスクが選択され、主題とソリューションの平均サイズが異なりました。これらの問題に関する決定の各セッションから、最後の不正な試行（存在する場合）および最初の正しい試行（存在する場合）が選択されました。結果のサンプルは、テストとトレーニングに分けられました。テストサンプルとトレーニングの一部に手動でマークを付けました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、ソリューションの品質のメトリックを決定する必要があります。私たちの作業では、精度-リコール曲線の下のメトリックエリアが選択されました。これを使用するには、分類子のしきい値信頼度のさまざまな値の精度と再現率の値を計算し、結果の曲線の下の面積を計算します。得られた値が大きいほど、分類が良好になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果の精度再現</font></font><br>
<br>
<img src="https://habrastorage.org/webt/33/gi/25/33gi25r6xikbfbwyjdilehg0li0.png" width="600"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
率</font><font style="vertical-align: inherit;">曲線を以下に示します。</font><font style="vertical-align: inherit;">交差検証を使用して、パラメーターの組み合わせの品質を評価しました。</font><font style="vertical-align: inherit;">トレーニングサンプルのラベル付けされた部分は10の部分に分割され、その後9つの部分が割り当てられていない部分と一緒にクラスター化されました。</font><font style="vertical-align: inherit;">結果として得られるクラスターは、それらに含まれるマークされた要素に基づいて自動的にラベル付けされました。</font><font style="vertical-align: inherit;">このプロセスを10回繰り返し、テスト結果を平均しました。</font><font style="vertical-align: inherit;">独立した評価を得るために、6つの問題（パラメーターの選択に関与しなかった2つを含む）のテストサンプルで最適な構成をテストしました。</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕事</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相互検証</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">試験サンプル</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あ</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.770</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.741</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.858</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.857</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.793</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.793</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.713</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.727</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.778</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.722</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数字は非常にエキサイティングですが、この方法で把握することで学んだ間違いを見てみましょう。</font><font style="vertical-align: inherit;">たとえば、問題Eを考えます。この問題では、フローの最小値と最大値を見つける必要があります。</font><font style="vertical-align: inherit;">条件について詳しくは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらをご覧ください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">いくつかのクラスターについて考えてみましょう。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空のコレクション/配列の要素へのアクセス</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクラスターには、学生が空のストリームのケース、つまり空のコレクションの処理を忘れたソリューションが含まれています。</font><font style="vertical-align: inherit;">ソリューション自体は非常に多様ですが、修正は似ています：ifが追加され、コレクション/配列のサイズをチェックし、それらの要素またはnullをacceptメソッドに渡します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(
       Stream&lt;? extends T&gt; stream,
       Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; order,
       BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> T&gt; minMaxConsumer)</span> </span>{<font></font>
   Object[] array = stream.sorted(order).toArray();<font></font>
   minMaxConsumer.accept((T) array[<span class="hljs-number">0</span>], (T) array[array.length - <span class="hljs-number">1</span>]);<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームを再利用</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streamクラスの各インスタンスは1回だけ使用されることが想定されています。</font><font style="vertical-align: inherit;">このクラスターには、ストリームの再利用を試みるソリューションが含まれています。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(
       Stream&lt;? extends T&gt; stream,
       Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; order,
       BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> T&gt; minMaxConsumer)</span> </span>{<font></font>
<font></font>
   <span class="hljs-keyword">if</span> (stream.count() == <span class="hljs-number">0</span>) {<font></font>
       minMaxConsumer.accept(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
   } <span class="hljs-keyword">else</span> {<font></font>
       T min = stream.min(order).get();<font></font>
       T max = stream.max(order).get();<font></font>
       minMaxConsumer.accept(min, max);<font></font>
   }<font></font>
}<font></font>
</code></pre><br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(
       Stream&lt;? extends T&gt; stream,
       Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; order,
       BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> T&gt; minMaxConsumer)</span> </span>{<font></font>
<font></font>
   T min = stream.min(order).orElse(<span class="hljs-keyword">null</span>);<font></font>
   T max = stream.max(order).orElse(<span class="hljs-keyword">null</span>);<font></font>
   minMaxConsumer.accept(min, max);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのソリューションは、最初にすべてのストリーム値をコレクションに格納し、それを使用していくつかの新しいストリームを作成することで修正できます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパレータを使用せずに並べ替え</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の一般的な問題は、パラメーターとして渡されるコンパレーターを使用せずにソートすることです。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(
       Stream&lt;? extends T&gt; stream,
       Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; order,
       BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> T&gt; minMaxConsumer)</span> </span>{<font></font>
   List&lt;T&gt; list = stream.sorted()<font></font>
           .collect(Collectors.toList());<font></font>
   <span class="hljs-keyword">if</span> (list.isEmpty()) {<font></font>
       minMaxConsumer.accept(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
   } <span class="hljs-keyword">else</span> {<font></font>
       minMaxConsumer.accept(list.get(<span class="hljs-number">0</span>),<font></font>
               		    list.get(list.size() - <span class="hljs-number">1</span>));<font></font>
   }<font></font>
}<font></font>
</code></pre><br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(
       Stream&lt;? extends T&gt; stream,
       Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; order,
       BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> T&gt; minMaxConsumer)</span> </span>{<font></font>
   Object[] array = stream.sorted().toArray();<font></font>
   <span class="hljs-keyword">if</span> (array.length &gt; <span class="hljs-number">0</span>)<font></font>
       minMaxConsumer.accept((T) array[<span class="hljs-number">0</span>], <font></font>
    (T) array[array.length - <span class="hljs-number">1</span>]);
   <span class="hljs-keyword">else</span>
       minMaxConsumer.accept(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような決定は、コンパレータを適切な場所に転送することによって修正されます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプションの不注意な使用</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Optionalオブジェクトに何も格納されていない場合、そのコンテンツを取得しようとすると例外がスローされます。</font><font style="vertical-align: inherit;">このような解決策を修正するには、getではなくgetOrElseメソッドを使用するか、抽出する前にオブジェクトの存在を確認する必要があります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(
       Stream&lt;? extends T&gt; stream,
       Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; order,
       BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> T&gt; minMaxConsumer)</span> </span>{<font></font>
   List&lt;T&gt; list = stream.collect(Collectors.toList());<font></font>
   minMaxConsumer.accept(list.stream().min(order).get(),<font></font>
                         list.stream().max(order).get());<font></font>
}<font></font>
</code></pre><br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(
       Stream&lt;? extends T&gt; stream,
       Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; order,
       BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> T&gt; minMaxConsumer)</span> </span>{<font></font>
<font></font>
   <span class="hljs-keyword">final</span> List&lt;Optional&lt;T&gt;&gt; minMax= Arrays.asList(<font></font>
           Optional.empty(),<font></font>
           Optional.empty());<font></font>
   stream.peek(x -&gt; {<font></font>
       <span class="hljs-keyword">if</span> (minMax.get(<span class="hljs-number">0</span>).isEmpty()) {<font></font>
           minMax.set(<span class="hljs-number">0</span>, Optional.of(x));<font></font>
           minMax.set(<span class="hljs-number">1</span>, Optional.of(x));<font></font>
       } <span class="hljs-keyword">else</span> {
           <span class="hljs-keyword">if</span> (order.compare(x, minMax.get(<span class="hljs-number">0</span>).get()) &lt; <span class="hljs-number">0</span>) {<font></font>
               minMax.set(<span class="hljs-number">0</span>, Optional.of(x));<font></font>
           }<font></font>
           <span class="hljs-keyword">if</span> (order.compare(x, minMax.get(<span class="hljs-number">1</span>).get()) &gt; <span class="hljs-number">0</span>) {<font></font>
               minMax.set(<span class="hljs-number">1</span>, Optional.of(x));<font></font>
           }<font></font>
       }<font></font>
   }).count();<font></font>
   minMaxConsumer.accept(minMax.get(<span class="hljs-number">0</span>).get(), minMax.get(<span class="hljs-number">1</span>).get());<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acceptメソッドを呼び出す</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
returnステートメントとは異なり、acceptメソッドを呼び出してもメソッドは終了しません。</font><font style="vertical-align: inherit;">このような決定は、acceptが呼び出された後にreturnステートメントを追加するか、コードの残りの部分をelseブロックに移動することによって修正されます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(
       Stream&lt;? extends T&gt; stream,
       Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; order,
       BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> T&gt; minMaxConsumer)</span> </span>{<font></font>
   List&lt;T&gt; list = stream.sorted(order)<font></font>
           .collect(Collectors.toList());<font></font>
   <span class="hljs-keyword">if</span> (list.isEmpty())<font></font>
       minMaxConsumer.accept(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
   minMaxConsumer.accept(list.get(<span class="hljs-number">0</span>),<font></font>
                         list.get(list.size() - <span class="hljs-number">1</span>));<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無効な最後のアイテムインデックス</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
n個の要素のリストでは、後者のインデックスはn-1です。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(
       Stream&lt;? extends T&gt; stream,
       Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; order,
       BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> T&gt; minMaxConsumer)</span> </span>{<font></font>
   List&lt;T&gt; list = stream.sorted(order)<font></font>
    .collect(Collectors.toList());<font></font>
   <span class="hljs-keyword">if</span> (list.isEmpty()) {<font></font>
       minMaxConsumer.accept(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
   } <span class="hljs-keyword">else</span> {<font></font>
       minMaxConsumer.accept(list.get(<span class="hljs-number">0</span>), list.get(list.size()));<font></font>
   }<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパレーターでのnull値の使用</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパレーターがnull値を正しく処理する必要があるかどうかは、哲学的問題です。</font><font style="vertical-align: inherit;">使用したコンパレータの実装はnullになることを予期していませんでした。</font><font style="vertical-align: inherit;">ストリーム自体にはnullはありませんが、中間結果をどこかに保存すると、初期値がnullになる可能性があります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(
       Stream&lt;? extends T&gt; stream,
       Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; order,
       BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> T&gt; minMaxConsumer)</span> </span>{<font></font>
   Object[] minMaxHolder = <span class="hljs-keyword">new</span> Object[]{<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>};<font></font>
   stream.forEach(val -&gt; {<font></font>
       <span class="hljs-keyword">if</span> (order.compare(val, (T) minMaxHolder[<span class="hljs-number">0</span>]) &lt; <span class="hljs-number">0</span>) {<font></font>
           m[<span class="hljs-number">0</span>] = val;<font></font>
       }<font></font>
       <span class="hljs-keyword">if</span> (order.compare(val, (T) minMaxHolder[<span class="hljs-number">1</span>]) &gt; <span class="hljs-number">0</span>) {<font></font>
           m[<span class="hljs-number">1</span>] = val;<font></font>
       }<font></font>
   });<font></font>
   minMaxConsumer.accept((T) minMaxHolder[<span class="hljs-number">0</span>], (T) minMaxHolder[<span class="hljs-number">1</span>]);<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスでソリューションをラップする</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラットフォームは1つのメソッドの形でソリューションを取得することを期待していましたが、多くのユーザーが外部クラス宣言とインポートを備えた本格的なプログラムを送信しました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソートされたメソッドの誤った使用</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streamクラスのすべての関数メソッドは、クラスの新しいインスタンスを返し、古いインスタンスを変更しません。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(
       Stream&lt;? extends T&gt; stream,
       Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; order,
       BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> T&gt; minMaxConsumer)</span> </span>{<font></font>
   stream.sorted(order);<font></font>
   T[] array = (T[]) stream.toArray();<font></font>
   <span class="hljs-keyword">if</span> (t.length == <span class="hljs-number">0</span>) {<font></font>
       minMaxConsumer.accept(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
   } <span class="hljs-keyword">else</span> {<font></font>
       minMaxConsumer.accept(array [<span class="hljs-number">0</span>], array [array .length - <span class="hljs-number">1</span>]);<font></font>
   }<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不正なストリーム処理</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
空のストリームの場合、null値が渡されることが予期されていました。</font><font style="vertical-align: inherit;">一部のソリューションでは、この場合、acceptメソッドがまったく呼び出されませんでした。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(
       Stream&lt;? extends T&gt; stream,
       Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; order,
       BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> T&gt; minMaxConsumer)</span> </span>{<font></font>
   List&lt;Object&gt; list = Arrays.asList(<font></font>
    stream.sorted(order).toArray());<font></font>
   <span class="hljs-keyword">if</span>(arrayList.size() &gt; <span class="hljs-number">0</span>) {<font></font>
       minMaxConsumer.accept((T) list.get(<span class="hljs-number">0</span>), (T) list.get(list.size()-<span class="hljs-number">1</span>));<font></font>
   }<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空の不適切なフローチェック</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のソリューションは、スレッドの無効性を明示的にチェックしようとしますが、それは間違っています。</font><font style="vertical-align: inherit;">場合によっては、チェックが意味をなさない場合（たとえば、nullに等しいオブジェクトがない場合）、countは最終操作であるため、これを使用すると、ストリームをさらに使用できなくなります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(
       Stream&lt;? extends T&gt; stream,
       Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; order,
       BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> T&gt; minMaxConsumer)</span> </span>{
   <span class="hljs-keyword">if</span> (stream.equals(<span class="hljs-keyword">null</span>)) {<font></font>
       minMaxConsumer.accept(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
   } <span class="hljs-keyword">else</span> {<font></font>
       List&lt;T&gt; list = stream.sorted(order)<font></font>
               .collect(Collectors.toList());<font></font>
       minMaxConsumer.accept(list.get(<span class="hljs-number">0</span>),<font></font>
                             list.get(list.size() - <span class="hljs-number">1</span>));<font></font>
   }<font></font>
}<font></font>
</code></pre><br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(
       Stream&lt;? extends T&gt; stream,
       Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; order,
       BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> T&gt; minMaxConsumer)</span> </span>{<font></font>
<font></font>
   <span class="hljs-keyword">if</span> (stream.count() &gt; <span class="hljs-number">0</span>) {<font></font>
       List&lt;T&gt; list = stream.sorted(order)<font></font>
               .collect(Collectors.toList());<font></font>
       minMaxConsumer.accept(list.get(<span class="hljs-number">0</span>),<font></font>
                             list.get(list.size() - <span class="hljs-number">1</span>));<font></font>
   }<font></font>
   minMaxConsumer.accept(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比較演算子の混乱</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、学生はしばしば比較の兆候で混乱しています。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(
       Stream&lt;? extends T&gt; stream,
       Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; order,
       BiConsumer&lt;? <span class="hljs-keyword">super</span> T, ? <span class="hljs-keyword">super</span> T&gt; minMaxConsumer)</span> </span>{<font></font>
   Object[] minMaxHolder = <span class="hljs-keyword">new</span> Object[]{<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>};<font></font>
   stream.forEach(x -&gt; {<font></font>
       <span class="hljs-keyword">if</span> (minMaxHolder[<span class="hljs-number">0</span>] == <span class="hljs-keyword">null</span>) {<font></font>
           minMaxHolder[<span class="hljs-number">0</span>] = x;<font></font>
           minMaxHolder[<span class="hljs-number">1</span>] = x;<font></font>
       }<font></font>
       <span class="hljs-keyword">if</span> (order.compare((T) minMaxHolder[<span class="hljs-number">0</span>], x) &lt; <span class="hljs-number">0</span>)<font></font>
           minMaxHolder[<span class="hljs-number">0</span>] = x;
       <span class="hljs-keyword">if</span> (order.compare((T) minMaxHolder[<span class="hljs-number">1</span>], x) &gt; <span class="hljs-number">0</span>)<font></font>
           minMaxHolder[<span class="hljs-number">1</span>] = x;<font></font>
   });<font></font>
   minMaxConsumer.accept((T) minMaxHolder[<span class="hljs-number">0</span>], (T) minMaxHolder[<span class="hljs-number">1</span>]);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
得られた結果から、選択したアプローチを使用して、オンライントレーニングプラットフォームでプロンプトを自動的に発行できると結論付けることができます。</font><font style="vertical-align: inherit;">このペーパーでは、最も単純な分類アルゴリズムを使用しました。</font><font style="vertical-align: inherit;">現在、この問題におけるより複雑なニューラルネットワークアプローチの適用性を調査しています。</font><font style="vertical-align: inherit;">それらの使用は比較的少数のソリューションによって複雑になりますが、予備データは、そのようなアプローチが最終的な分類として依然として利点を与えることを示しています。</font><font style="vertical-align: inherit;">プロジェクトのソースコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で私たちのグループの他のプロジェクトについて知ることができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の執筆者：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artyom Lobanov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">JetBrains Researchの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソフトウェアエンジニアリングにおける機械学習手法の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">研究</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">者</font></a><font style="vertical-align: inherit;">、研究者。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja504108/index.html">Kubernetesの学習：7月6〜8日の基本プログラム、7月13〜15日の上級</a></li>
<li><a href="../ja504110/index.html">障害者向けのリソースを作成する際のQAとその役割</a></li>
<li><a href="../ja504112/index.html">Victor Scherb：「私のOSMとの知り合いの話は、OsmAndアプリケーションと密接に関連しています」</a></li>
<li><a href="../ja504114/index.html">1つのウィンドウで複数のLinux端末を実行する</a></li>
<li><a href="../ja504116/index.html">機械学習上のGIS：最適な場所にある店舗と「ラストマイル」の開発</a></li>
<li><a href="../ja504124/index.html">PyCaretを使用してPower BIにクラスタリングを実装する方法</a></li>
<li><a href="../ja504126/index.html">主要なPythonの欠陥</a></li>
<li><a href="../ja504130/index.html">トレーニングビデオの作成方法：テクニカルライターの10の秘密</a></li>
<li><a href="../ja504132/index.html">場合。検索需要の調査に基づく新しいIT製品の市場投入</a></li>
<li><a href="../ja504134/index.html">技術者の自己動機付け：先延ばしの方程式、シュレッダー効果およびフードトリック</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>