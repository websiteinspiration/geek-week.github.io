<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏽 🤳🏻 👴🏿 死亡日标准图书馆 🎿 🌟 🏊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在布拉格的前一天，C ++标准化委员会对更改ABI的问题进行了一系列调查，最终决定不对其进行任何更改。大厅里没有掌声。
 我认为我们尚未完全意识到此决定带来的后果，而且我不认为原则上可以对语言的发展产生积极影响。
 
 
 
 什么是ABI？
 ABI-一组约定，用于定义程序以二进制形式表示，如何在...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>死亡日标准图书馆</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490222/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在布拉格的前一天，C ++标准化委员会对更改ABI的问题进行了一系列调查，最终决定不对其进行任何更改。</font><font style="vertical-align: inherit;">大厅里没有掌声。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为我们尚未完全意识到此决定带来的后果，而且我不认为原则上可以对语言的发展产生积极影响。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7a/j5/al/7aj5al5kxo5gjlw1lbrr0ftlemq.png"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么是ABI？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ABI-一组约定，用于定义程序以二进制形式表示，如何在其中声明名称，定义类标记以及定义函数调用约定。</font><font style="vertical-align: inherit;">实际上，这是一种二进制协议，但未进行版本控制。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了不使您对术语感到困惑，让我们看一下ABI更改带来的后果及其在程序中的细分示例：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您执行以下任何操作，则不能在新版本的编译库中使用导出的符号：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在现有课程中添加了新字段</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改类/函数的模板参数，将模板函数转换为非模板，反之亦然，添加</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可变参数模板</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内联</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">说明符</font><font style="vertical-align: inherit;">应用于某些内容</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在函数声明中添加了默认参数</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宣布了新的虚拟方法</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有很多，但是上面的例子是委员会提到的主要例子，也正是这些例子，由于这些例子，标准中的大多数提议都被当场销毁了。</font><font style="vertical-align: inherit;">我省略了违反ABI的选项，在此期间，程序的源代码也会中断（例如，删除或更改功能）。</font><font style="vertical-align: inherit;">但是，并非总是如此。</font><font style="vertical-align: inherit;">例如，删除一个函数并不总是需要破坏源代码。</font></font><code>std::string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它在中有一个转换运算符</font></font><code>std::string_view</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我很高兴摆脱它，尽管删除它会破坏ABI，但不会在源代码中引起重大问题。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么要打破ABI</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，如果破坏当前的ABI，可以对标准库的实现进行一些有用的更改：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加快关联容器的速度</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加快您的工作速度</font></font><code>std::regex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（目前，运行PHP并使用正则表达式进行搜索要比使用标准表达式更快</font></font><code>std::regex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在某些变化</font></font><code>std::string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及在其他容器的布局</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类接口的统一性：目前，出于稳定性考虑，它们的某些实现有意不对应于单个接口</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更重要的是，库的设计中的更改必须在不遇到ABI安全问题的情况下进行。</font><font style="vertical-align: inherit;">由于上述原因，这是目前不可行的所有清单，但不完整：</font></font><br>
<br>
<ul>
<li><code>std::scoped_lock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 被添加以不破坏abi更改 </font></font><code>lock_guard</code></li>
<li><code>int128_t</code>    ,    <code>intmax_t</code>. ,    ,    ,  <code>intmax_t</code>   <i>deprecated</i></li>
<li><code>std::unique_ptr</code>           ,     <i>zero-overhead</i>     </li>
<li>   <code>error_code</code>     - ,       ABI</li>
<li><code>status_code</code>     ABI</li>
<li>    <code>recursive_directory_iterator</code>  ,     ABI</li>
<li>      <code>&lt;cstring&gt;</code> <code>constexpr</code> ( <code>strlen</code>)     ,   ABI</li>
<li>  UTF-8  <code>std::regex</code> —  ABI</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加支持</font></font><code>realloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并返回已分配内存的大小是多态分配器的ABI分解</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为多态类型创建隐式虚拟析构函数</font></font></li>
<li><font style="vertical-align: inherit;"></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果当前的ABI损坏，则可以更改</font><font style="vertical-align: inherit;">返回类型y</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常，我们真的需要和</font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以及</font></font><code>emplace_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吗？</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><code> std::shared_ptr</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 也会导致ABI故障</font></font></li>
<li><code>[[no_unique_address]]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果我们不关心保存当前的ABI，则可以由编译器输出</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
列表不止于此。</font><font style="vertical-align: inherit;">我认为WG21应该努力保持此类清单的最新状态。</font><font style="vertical-align: inherit;">但是我会注意到和我在一起的每个人都说“这将破坏ABI”。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们还想改变什么？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我不知道。</font><font style="vertical-align: inherit;">我不知道我不知道。</font><font style="vertical-align: inherit;">但是，如果让我猜测，我会说以下内容：</font></font><br>
<br>
<ul>
<li>     C++23      ABI,    -        ,    ABI.          </li>
<li>   ,  ,          ,    ,          ABI</li>
<li>        ABI,       </li>
<li>    ,     ABI</li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Tombstone</a>      ABI</li>
</ul><br>
<h2> ABI  </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在上一次ABI讨论中，在布拉格进行了一些调查，但是没有告诉我们任何事情。</font><font style="vertical-align: inherit;">根据您是悲观主义者还是乐观主义者，您对当前结果的理解可能会有所不同。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关键事实：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WG21不想破坏23中的ABI</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WG21认为有必要在将来的C ++版本（C ++ 26或更高版本）中破坏ABI。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WG21将花一些时间来考虑违反ABI的提案</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WG21不保证永恒的稳定性</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WG21认为重要的是保持性能优先，甚至损害语言稳定性</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些声明有许多要点，但尚未达成共识。</font><font style="vertical-align: inherit;">奇怪的是，委员会一分为二。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算命</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在哪个版本的C ++中等待更改</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有这些民意调查的明显缺点是，我们还没有决定</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何时确切</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打破ABI。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在C ++ 23中？不，绝对不会。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在C ++ 26中？有些人打算投票，但另一部分人可能会投票支持C ++ 41或退休之时，而他们不必支持当前的项目。刚才提到的问题之一是C ++- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一些</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">；非常舒适！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没有理由相信，如果现在不能违反ABI，那么以后就可以违反。需要稳定性的人落后于标准数年。因此，如果我们现在不打破它，人们将继续依赖从未承诺过的ABI，也许还要十年甚至二十年。我们进行这项调查的简单事实最终被投票反对不违反ABI，这表明整个生态系统正在逐渐变得僵硬和停滞-每天问题只会变得更加严重，而且价格可能更高。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为三年来进行的调查不会改变任何事情。这就像全球变暖：每个人都同意，有一天我们需要解决这个问题。然后让我们在2070年禁止柴油吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
计划在未来五年内完成的所有工作都可能永远不会发生。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于违反ABI的报价</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WG21投票决定将更多时间用于违反当前ABI的提案。</font><font style="vertical-align: inherit;">这意味着几件事：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将在委员会中噪音最大的会议室中浪费更多的时间来讨论此问题，而对那些有更多机会获得通过的提案则少花些时间，最后我们将全部拒绝。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将寻找不会破坏ABI的替代方法（将在下面进行讨论）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能会引入ABI的部分更改（另请参见下文）</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性能比ABI稳定性更重要</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就像问一个五岁的孩子是否想要糖果。</font><font style="vertical-align: inherit;">当然，我们将对绩效的重要性进行投票。</font><font style="vertical-align: inherit;">但是，我担心仍然有人投票反对。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我看来，委员会希望同时坐在两个椅子上。</font><font style="vertical-align: inherit;">这是不可能的：</font></font><br>
<blockquote><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bryce Adelstein Lelbach</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> @blebach-</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 性能</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -稳定性</font><font style="vertical-align: inherit;">ABI-</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 更改某些内容的能力</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从建议的选项中选择两个选项。</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
语言的稳定性和ABI当然会相互冲突，从而迫使我们提出这样一个基本问题-什么是C ++，什么是它的标准库？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常在这种情况下，</font><font style="vertical-align: inherit;">要</font><font style="vertical-align: inherit;">记住术语“性能”，“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">零成本</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象”，“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不为您不使用的产品付费</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”。</font><font style="vertical-align: inherit;">而ABI的稳定性贯穿于所有这一切。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">后果深远</font></font></h2><br>
<img src="https://habrastorage.org/getpro/habr/post_images/5d7/90b/d50/5d790bd50abd97b45921c4f61a8ef757.webp" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我深信，决定在23年内不打破ABI是委员会有史以来最大的错误。</font><font style="vertical-align: inherit;">我知道有人相信相反的说法。</font><font style="vertical-align: inherit;">但是，这可能很快就会发生：</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学习的噩梦</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
说实话。所有依赖ABI的程序都可能在某处违反</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ODR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原则</font><font style="vertical-align: inherit;">或使用不兼容的标志，幸运的是，这些标志仍然有效。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新程序必须从源代码中编译，我们需要从源代码中构建程序集的工具，而不是从某处获得并以某种方式插入到项目中的库的集合。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是的，从源代码构建并不是一件容易的事情。但是我们需要鼓励对产品采用这种方法，定期更新编译器，以便人们在发行后一个月而不是十年后可以从新引入的功能中受益。需要鼓励使用正确，可靠，可扩展和可复制的解决方案，开源库和依赖系统。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该委员会拒绝违反ABI，公开声明它将在其存在的整个过程中支持写得不好的程序。</font><font style="vertical-align: inherit;">即使您没有链接到通过apt-install获得的库（实际上是为系统使用的），也会有其他人，因为委员会给予了他们祝福。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一大步。</font><font style="vertical-align: inherit;">如果我们没有动力去教别人良好的语言习惯？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对标准库失去兴趣</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于我们不愿意违反ABI而造成的图书馆性能损失估计为5-10％。</font><font style="vertical-align: inherit;">这个数字只会随着时间增长。</font><font style="vertical-align: inherit;">让我们看一些例子：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您是大型公司，则可以为自己购买一个新的数据中心，或向支持自己的图书馆的程序员团队付费</font></font></li>
<li>    ,   5%              ,     </li>
<li>   ,   5-10%  ,               VR-</li>
<li>   ,        —     </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为，在这里，我会随意问：“我绝对应该使用C ++及其标准库！”和“也许我不应该使用标准库？还是我原则上不应该使用C ++？也许.NET，julia或Rust会是更好的解决方案？”当然，有很多因素会影响答案，但是我们看到了最近发生的事情。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
许多游戏开发人员都对标准库持怀疑态度。他们宁愿开发自己的替代产品（例如</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EASTL）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，也不愿利用STL。 Facebook </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">愚蠢</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，谷歌</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abseil</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就像雪球一样。</font><font style="vertical-align: inherit;">如果人们不使用标准库，他们就没有兴趣对其进行改进。</font><font style="vertical-align: inherit;">性能是使磁带库保持运转的关键因素。</font><font style="vertical-align: inherit;">没有性能的保证，其开发将花费更少的精力。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt;&gt; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://twitter.com/foonathan" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JonathanMüller</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> @foonathan </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果不能提供更好的性能，那么使用标准库中的容器有什么意义呢？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">泰特斯·温特斯</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> @TitusWinters </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也许是因为它们很常见且易于访问？</font><font style="vertical-align: inherit;">（这两个事实并不意味着同一件事）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
投票保护ABI就像在说标准库应该努力成为麦当劳-他也无处不在，他很稳定并且从技术上解决了任务。</font></font><br>
</blockquote> <h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">委员会如何考虑打破ABI的提案？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于无法接受要约而导致违反ABI，因此提供了多种选择来缓解疼痛：</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加新名称</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/9db/f42/6f8/9dbf426f89a37d487fb3b446edebc89d.webp" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是第一个显而易见的解决方案。如果我们不能改变</font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们可以补充</font></font><code>std::fast_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吗？造成这种情况不好的原因有很多。在支持成本和教育方面，将类型添加到标准库都是昂贵的。引入新类后，将不可避免地出现数千篇文章，说明应使用哪个容器。例如，我应该使用</font></font><code>std::scoped_lock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还是</font></font><code>std::lock_guard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？我不知道！我每次都需要Google。还有一个问题，好名声迟早会终止。在程序执行过程中，我们还会遇到一些开销，因为所有容器必须不断地相互转换，因此很难控制类中的大量转换重载，等等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
具有讽刺意味的是，但支持上述解决方案的人也可能会认为C ++语言太复杂。</font><font style="vertical-align: inherit;">将重复项添加到库中绝对不会使其变得更容易。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是我们可以接受此优惠为标准！</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一些图书馆开发商声称，他们的报价由于违反了ABI而被拒绝，尽管他们实际上并未违反任何内容，或者可以更改它们以规避ABI的失败。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为一个愤世嫉俗的人，我很难相信。</font><font style="vertical-align: inherit;">事实是，在没有此类建议之前，可以应用这些建议的方案非常有限。</font><font style="vertical-align: inherit;">ABI审核小组（ARG）可以在此问题上提供帮助，但他们可能会再次为该类/功能推荐另一个名称。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">局部违反Abi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主要思想不是破坏整个ABI，而只是针对特定的类或功能对其进行更改。</font><font style="vertical-align: inherit;">这种方法的问题是，在链接阶段而不是错误的情况下，我们将在程序启动期间就已经看到了问题，这会让我们感到惊讶。</font><font style="vertical-align: inherit;">该委员会在更改标记时已经在C ++ 11中尝试了这种方法</font></font><code>std::string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">一切都不好。</font><font style="vertical-align: inherit;">一切都太糟糕了，以至于这个事实仍然被用来支持维持当前的ABI。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个索引级别</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解决ABI某些问题的方法是能够通过指针访问类的数据，然后类的标记就是该指针。这个想法非常接近</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PIMPL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">习惯用法</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">因为它的ABI使其</font><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">得到了积极的应用</font><font style="vertical-align: inherit;">。是的，这可以解决类成员的问题，但是使用虚方法怎么办？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从更严格的角度考虑问题，我们正在讨论的是为ABI框架中包含的所有内容添加另一种间接级别（按指针索引）和在堆中额外分配内存。实际上，在STL中，所有内容都包含在此框架内，因为它是通用类的集合。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，这种方法的代价将是巨大的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为该问题的解决方案，标准中已经有一些建议。</font><font style="vertical-align: inherit;">他们中的一些人希望使PIMPL成为语言的功能之一，因此您可以在ABI稳定性和高性能之间进行选择。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
具有讽刺意味的是，但是，为了将库类型转换为PIPML类型，我们需要...打破ABI。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每三年重新汇编一次所有代码</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大声说出我的想法。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标准中的所有当前报价必须被销毁</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
矛盾的是，C ++从未像现在这样活跃。</font><font style="vertical-align: inherit;">在布拉格，有250人为他工作，包括：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数值</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线性代数</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音讯</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一码</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步I / O</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2D和3D图形</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">许多其他功能</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有这些建议都由一个共同的事实统一起来-与我们目前的标准相比，它们更具可选择性。人们只是试图从他们的研究和工作领域，或者是不断发展变化的领域中标准化事物。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尤其是，Unicode算法非常不稳定，并且会随着时间而迅速变化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，这种恐怖的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网络</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">织机在地平线上</font><font style="vertical-align: inherit;">。试图对可能导致安全问题的任何事情进行标准化是非常非常不负责任的，同时又无法在以后进行更改（记住有关ABI的信息）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于C ++决定使其稳定，因此所有这些建议都必须销毁并销毁。我不想被摧毁，但这必须做到。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是他们仍然不会这样做。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在最佳情况下，我们不会在新版本的C ++中犯错误并标准化事物的当前状态，然后让所有事物缓慢分解，因为不可能对其进行修复（对于Networking TS，我们似乎根本无法进行任何更改，因此我们将不得不标准化十年前存在的内容，那么当然仍然可以对库进行重大改进，但是让我们再讲一次这个故事）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，当然，我们会犯很多错误。</font></font><br>
<br>
<blockquote>&gt;&gt; <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><b>Ólafur Waage</b></a> @olafurw<br>
(      ,    )<br>
<br>
 ,  !<br>
<br>
         .       ,      ( : , , )?<br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><b>Hyrum Wright</b></a> @hyrumwright<br>
    ,    ,  .       —    ,      .<br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有些错误是权衡取舍，是有意为之，而其他错误很多年来却未引起注意。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
时间流逝，但是标准库停滞不前。以前做出的取舍逐渐开始困扰我们，后来成为现有代码中真正的“瓶颈”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有些事情实际上是无法更改的，因为它们已嵌入在API中。我们都有一个想法，即更改现有API有多困难。但是，如果我们可以破坏ABI，部分代码仍可以修复和改进。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在接下来的40年中，C ++仍将继续流行。如果我们无法意识到需要随时以不可预测的方式进行更改，那么原则上唯一的正确选择就是不要玩这个游戏。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个人都知道标准的关联容器使用不到十年才有意义。</font><font style="vertical-align: inherit;">但是，为什么我们认为标准中更大的提案会更成功呢？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您对标准的报价</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将被</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破坏，我的</font><font style="vertical-align: inherit;">出价</font><b><font style="vertical-align: inherit;">也</font></b><font style="vertical-align: inherit;">将被破坏。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">委员会原则上可以打破ABI吗？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
许多人确信委员会原则上不能做出这样的决定，因为那样的话，图书馆开发人员只会忽略它。</font><font style="vertical-align: inherit;">所有这些痛苦地类似于手臂摔跤，委员会决定不参加比赛。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是事实是，任何产品的开发人员都有自己的用户。</font><font style="vertical-align: inherit;">用户是那些首先需要了解对他们施加哪些折衷的人。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
许多人很偶然地依赖ABI，而没有做出明智的选择。</font><font style="vertical-align: inherit;">许多人也依赖稳定，因为当然每个人都希望依靠稳定。</font><font style="vertical-align: inherit;">但是，就像其他任何事情一样，稳定性是有代价的，现在整个C ++生态系统为此付出了代价。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN490198/index.html">信任但要验证！在演示厅Pult.ru中使用带爱普生投影仪的家庭影院演示区</a></li>
<li><a href="../zh-CN490202/index.html">查询计数：Django基本性能测试</a></li>
<li><a href="../zh-CN490204/index.html">2020年3月HR和IT招聘人员的事件摘要</a></li>
<li><a href="../zh-CN490208/index.html">DUMP2020的后端部分：戏ter，迷，失败</a></li>
<li><a href="../zh-CN490210/index.html">加快前端速度。当许多服务器请求都很好时</a></li>
<li><a href="../zh-CN490224/index.html">时尚的隐形</a></li>
<li><a href="../zh-CN490226/index.html">Blending和Unity Terrain：如何摆脱交叉点并停止使眼睛受伤</a></li>
<li><a href="../zh-CN490232/index.html">使用AWS ELB进行负载平衡</a></li>
<li><a href="../zh-CN490242/index.html">SIM800x模块的GSM定位服务及其与Yandex.Locator API的配合</a></li>
<li><a href="../zh-CN490244/index.html">使用ctypes的Python代码优化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>