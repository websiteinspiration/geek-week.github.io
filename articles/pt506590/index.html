<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍🏽 👭 📴 Conferência DEVOXX UK. Escolha uma estrutura: Docker Swarm, Kubernetes ou Mesos. Parte 2 👨🏼‍🏭 🐊 ➗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Docker Swarm, Kubernetes e Mesos são as estruturas de orquestração de contêineres mais populares. Em seu discurso, Arun Gupta compara os seguintes asp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Conferência DEVOXX UK. Escolha uma estrutura: Docker Swarm, Kubernetes ou Mesos. Parte 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/506590/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Docker Swarm, Kubernetes e Mesos são as estruturas de orquestração de contêineres mais populares. </font><font style="vertical-align: inherit;">Em seu discurso, Arun Gupta compara os seguintes aspectos do trabalho de Docker, Swarm e Kubernetes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desenvolvimento local.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recursos de implantação</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplicativos multicontainer.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descoberta de serviço descoberta de serviço.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serviço de dimensionamento.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atribuições executadas uma vez.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integração com o Maven.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma atualização "contínua".</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criando um cluster de banco de dados do Couchbase.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, você terá uma idéia clara do que cada instrumento de orquestração tem a oferecer e aprenderá como usar essas plataformas de maneira eficaz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arun Gupta é o principal tecnólogo de produtos de código aberto da Amazon Web Services que desenvolve as comunidades de desenvolvedores Sun, Oracle, Red Hat e Couchbase há mais de 10 anos. Ele tem uma vasta experiência trabalhando em liderar equipes multifuncionais envolvidas no desenvolvimento e implementação de campanhas e programas de marketing. Ele liderou a equipe de engenharia da Sun, é um dos fundadores da equipe Java EE e criador da filial americana do Devoxx4Kids. Arun Gupta é autor de mais de 2 mil posts em blogs de TI e fez apresentações em mais de 40 países.</font></font><a name="habracut"></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conferência DEVOXX UK. Escolha uma estrutura: Docker Swarm, Kubernetes ou Mesos. Parte 1</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
O conceito de escala da Scale significa a capacidade de controlar o número de réplicas aumentando ou diminuindo o número de instâncias de aplicativos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fw/gv/v3/fwgvv3n1z5ac0srlzcdfpw93qxq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo: se você quiser dimensionar o sistema para 6 réplicas, use o comando docker service scale web = 6. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juntamente com o conceito de Serviço Replicado no Docker, existe o conceito de Serviço Global de serviços compartilhados. Digamos que eu queira executar uma instância do mesmo contêiner em cada nó do cluster; nesse caso, é um contêiner do aplicativo de monitoramento da web Prometheus. Esse aplicativo é usado quando você precisa coletar métricas sobre a operação de hosts. Nesse caso, você usa o subcomando - - mode = global - - name = prom prom / Prometheus.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oy/33/4b/oy334but50yvcsudtdiufymmirg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, o aplicativo Prometheus será iniciado em todos os nós do cluster, sem exceção, e se novos nós forem adicionados ao cluster, ele será iniciado automaticamente no contêiner e nesses nós. Espero que você entenda a diferença entre Serviço Replicado e Serviço Global. Geralmente, o Serviço Replicado é onde você inicia.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kn/aw/fn/knawfnwwuw8w3blgvr5u-gfrgv8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, examinamos os conceitos básicos ou entidades básicas do Docker e agora consideraremos as entidades do Kubernetes. O Kubernetes também é um tipo de planejador, uma plataforma para orquestração de contêineres. Deve-se lembrar que o principal conceito do planejador é saber como agendar contêineres em hosts diferentes. Se você for para um nível superior, podemos dizer que orquestração significa expandir seus recursos para gerenciar clusters, obter certificados etc. Nesse sentido, o Docker e o Kubernetes são plataformas de orquestração, ambas com um planejador interno.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A orquestração é um gerenciamento automatizado de entidades relacionadas - clusters de máquinas virtuais ou contêineres. Kubernetes é uma coleção de serviços que implementam um cluster de contêineres e sua orquestração. Ele não substitui o Docker, mas expande significativamente seus recursos, simplificando o gerenciamento de implantação, roteamento de rede, consumo de recursos, balanceamento de carga e tolerância a falhas dos aplicativos em execução. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comparado ao Kubernetes, o Docker concentra-se em trabalhar com contêineres, criando suas imagens usando um arquivo docker. Se você comparar os objetos Docker e Kubernetes, poderá dizer que o Docker gerencia os contêineres, enquanto o Kubernetes gerencia o próprio Docker.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quantos de vocês já lidaram com contêineres Rocket? Alguém usa Rocket em produção? Apenas uma pessoa levantou a mão no corredor, esta é uma imagem típica. Essa é uma alternativa ao Docker, que ainda não se enraizou na comunidade de desenvolvedores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, a essência do Kubernetes é o Pod. É um grupo relacionado de contêineres que usam um espaço para nome comum, armazenamento compartilhado e endereço IP compartilhado. Todos os contêineres na lareira se comunicam através do host local. Isso significa que você não poderá colocar o aplicativo e o banco de dados no mesmo lar. Eles devem ser colocados em diferentes pods, porque possuem requisitos de escala diferentes.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xw/7g/39/xw7g39gpxvoahlobcyzap0-dch8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, você pode colocar em um pod, por exemplo, um contêiner WildFly, um contêiner de login, um proxy ou um contêiner de cache, e deve abordar com responsabilidade a composição dos componentes do contêiner que será dimensionado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Geralmente, você agrupa seu contêiner no conjunto de réplicas, porque deseja executar um certo número de instâncias na lareira. O Conjunto de réplicas solicita que você inicie quantas réplicas o serviço de dimensionamento do Docker exige e informa quando e como fazê-lo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os pods são semelhantes aos contêineres, no sentido de que, se um pod falhar em um host, ele será reiniciado em um pod diferente com um endereço IP diferente. Como desenvolvedor Java, você sabe que quando cria um aplicativo java e ele se comunica com o banco de dados, não pode confiar em um endereço IP dinâmico. Nesse caso, o Kubernetes usa o Serviço - esse componente publica o aplicativo como um serviço de rede, criando um nome de rede permanente estático para um conjunto de lareiras, enquanto equilibra simultaneamente a carga entre as lareiras. Pode-se dizer que esse é o nome do serviço do banco de dados e o aplicativo java não depende do endereço IP, mas apenas interage com o nome constante do banco de dados.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é obtido pelo fato de que cada Pod é fornecido com uma etiqueta específica, armazenada no armazenamento distribuído etcd, e o Serviço monitora essas etiquetas, fornecendo um link entre os componentes. Ou seja, os pods e serviços interagem de maneira estável usando esses rótulos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos ver como criar um cluster Kubernetes. Para isso, como no Docker, precisamos de um nó mestre e um nó de trabalho. Um nó em um cluster geralmente é representado por uma máquina física ou virtual. Aqui, como no Docker, o assistente é uma estrutura de controle central que permite controlar todo o cluster por meio do gerenciador de agendador e controlador. Por padrão, um nó principal existe no singular, mas há muitas ferramentas novas que permitem criar vários nós principais.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/p_/vz/vt/p_vzvtatvsax9qkpzam3g6qi-yk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O nó mestre fornece interação do usuário usando o servidor API e contém o armazenamento distribuído etcd, que contém a configuração do cluster, o status de seus objetos e metadados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os nós de trabalho do nó de trabalho são projetados exclusivamente para a execução de contêineres; para isso, eles têm dois serviços Kubernetes instalados - um roteador de rede de serviço proxy e um agente do agendador kubelet. Enquanto esses nós estão em execução, o Docker os monitora usando systemd (CentOS) ou monit (Debian), dependendo do sistema operacional que você está usando.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere a arquitetura Kubernetes de forma mais ampla. Temos um mestre, que inclui um servidor de API (pods, serviços etc.), gerenciado usando o CLI kubectl. O Kubectl permite criar recursos do Kubernetes. Ele envia comandos para o servidor da API, como "criar em", "criar serviço", "criar um conjunto de réplicas". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, aqui estão o Scheduler, o Controller Manager e o repositório etcd. O gerente do controlador, após receber as instruções do servidor da API, mapeia rótulos de réplicas para rótulos da lareira, garantindo uma interação estável entre os componentes. O planejador, tendo recebido a tarefa para criar under, varre os nós de trabalho e o cria onde é fornecido. Naturalmente, ele obtém essas informações do etcd.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, temos vários nós em funcionamento, e o servidor da API se comunica com os agentes Kubelet contidos neles, informando como os pods devem ser criados. Aqui está o proxy que fornece acesso a um aplicativo que usa esses pods. Meu cliente é mostrado à direita no slide - essa é uma solicitação da Internet, enviada ao balanceador de carga, que se refere ao proxy, que distribui a solicitação por envio e envia a resposta de volta. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/p3/ap/gd/p3apgd2pykmapgqbmvzwk5krzd0.jpeg"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você vê o slide final, que descreve o cluster Kubernetes e como todos os seus componentes funcionam.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos falar mais sobre o Service Discovery e o balanceador de carga do Docker. Quando você inicia seu aplicativo Java, isso geralmente acontece em vários contêineres em vários hosts. Há um componente do Docker Compose, que facilita a execução de aplicativos com vários contêineres. Descreve aplicativos multicontainer e os lança usando um ou mais arquivos de configuração yaml.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bs/tf/au/bstfau9gn_rprqjs1vsxljmhp5k.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por padrão, esses são os arquivos docker-compose.yaml e docker-compose.override.yaml, com vários arquivos especificados usando - f. No primeiro arquivo, você escreve o serviço, imagens, réplicas, tags, etc. O segundo arquivo é usado para substituir a configuração. Depois de criar o docker-compose.yaml, ele é implantado no cluster de vários hosts que o Docker Swarm criou anteriormente. Você pode criar um arquivo de configuração básico, docker-compose.yaml, no qual adicionará arquivos de configuração específicos para diferentes tarefas, indicando portas, imagens, etc. específicas, falaremos sobre isso mais tarde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste slide, você vê um exemplo simples de um arquivo de descoberta de serviço. A primeira linha indica a versão e a linha 2 indica que se refere aos serviços de banco de dados e da web.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/b-/4y/ip/b-4yiphrszxkitrj1wsnlybscem.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quero que meu serviço da web se comunique com o db-service depois de "aumentar". Esses são aplicativos java simples implantados em contêineres do WildFly. Na linha 11, escrevo o ambiente couchbase_URI = db. Isso significa que meu serviço db usa esse banco de dados. Na linha 4, a imagem couchbase é indicada e, nas linhas 5-9 e 15-16, respectivamente, as portas necessárias para garantir a operação dos meus serviços.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A chave para entender o processo de descoberta de serviço é que você cria algum tipo de dependência. Você indica que o contêiner da web deve iniciar antes do contêiner db, mas isso é apenas no nível do contêiner. Como sua aplicação reage, como começa - essas são coisas completamente diferentes. Por exemplo, geralmente o contêiner "aumenta" em 3 a 4 segundos, no entanto, o lançamento do contêiner do banco de dados leva muito mais tempo. Portanto, a lógica do lançamento do seu aplicativo deve ser "assada" no seu aplicativo java. Ou seja, o aplicativo deve executar ping no banco de dados para garantir que esteja pronto. Como o banco de dados couchbase é uma API REST, você deve chamar essa API e perguntar: “Ei, você está pronto? Nesse caso, estou pronto para lhe enviar perguntas!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, as dependências no nível do contêiner são determinadas usando o serviço docker-compose, mas no nível do aplicativo, as dependências e a viabilidade são determinadas com base em pesquisas de responsabilidade. Em seguida, você pega o arquivo docker-compose.yaml e o implementa no Docker de vários hosts usando o comando docker stack deploy e o subcomando - - compose-file = docker-compose.yaml webapp. Portanto, você tem uma pilha grande na qual existem vários serviços que resolvem vários problemas. Basicamente, essas são as tarefas de lançamento de contêineres.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6v/mc/1q/6vmc1qxqno204x2oaymesl-hrsc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver como o balanceador de carga funciona. No exemplo acima, usando o comando docker service create, criei um serviço - o contêiner WildFly, especificando o número da porta no formato 8080: 8080. Isso significa que a porta 8080 no host - a máquina local - será mapeada para a porta 8080 dentro do contêiner, para que você possa acessar o aplicativo através do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">host local</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 8080. Essa será a porta de acesso a todos os nós de trabalho. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6v/06/dc/6v06dcpdnkzfwwlb9e-_npqeqo0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembre-se de que o balanceador de carga é orientado a host, não a contêiner. Ele usa as portas 8080 de cada host, independentemente de os contêineres estarem em execução no host ou não, porque agora o contêiner trabalha em um host e, após a conclusão da tarefa, pode ser transferido para outro host.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, as solicitações do cliente são recebidas pelo balanceador de carga, ele as redireciona para qualquer um dos hosts e, usando a tabela de endereços IP, ele chega ao host com o contêiner não executando, ele redireciona automaticamente a solicitação ao host em que o contêiner está sendo executado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um salto único não é caro, mas é completamente "contínuo" em termos de escalar seus serviços para cima ou para baixo. Graças a isso, você pode ter certeza de que sua solicitação irá exatamente para o host em que o contêiner está sendo executado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos ver como o Service Discovery no Kubernetes funciona. Como eu disse, um serviço é uma abstração na forma de um conjunto de lareiras com o mesmo endereço IP e número de porta e um simples balanceador de carga TCP / UDP. O slide a seguir mostra o arquivo de configuração do Service Discovery.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/l2/_h/ew/l2_hew4bmc8dg_bsq0he-pf9dgy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Criando recursos como pods, serviços, réplicas etc. </font><font style="vertical-align: inherit;">acontece com base no arquivo de configuração. </font><font style="vertical-align: inherit;">Você vê que é dividido em 3 partes usando as linhas 17 e 37, que consistem apenas em - - -. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejamos a linha 39 primeiro - ela diz tipo: ReplicaSet, ou seja, o que estamos criando. </font><font style="vertical-align: inherit;">As linhas 40-43 contêm metadados, com as linhas 44 especificando a especificação para o nosso conjunto de réplicas. </font><font style="vertical-align: inherit;">A linha 45 indica que eu tenho 1 réplica, seus rótulos estão listados abaixo; nesse caso, o nome é wildfly. </font><font style="vertical-align: inherit;">Ainda mais baixo, começando na linha 50, é indicado em quais contêineres essa réplica deve ser lançada - isto é wildfly-rs-pod, e as linhas 53-58 contêm a especificação desse contêiner. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
23:05 min </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para continuar em breve ...</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/1dgUXNVQS5o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um pouco de publicidade :)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obrigado por ficar com a gente. Você gosta dos nossos artigos? Deseja ver materiais mais interessantes? Ajude-nos fazendo um pedido ou recomendando aos seus amigos o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VPS na nuvem para desenvolvedores a partir de US $ 4,99</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analógico exclusivo de servidores </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">básicos </font></font></a><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">que foi inventado por nós para você: </font></b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Toda a verdade sobre o VPS (KVM) E5-2697 v3 (6 núcleos) 10GB DDR4 480GB SSD 1Gbps de 10GB de US $ 19 ou como dividir o servidor?</font></a><font style="vertical-align: inherit;"> (as opções estão disponíveis com RAID1 e RAID10, até 24 núcleos e até 40GB DDR4). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2 vezes mais barato no data center Equinix Tier IV em Amsterdã?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Somente nós temos </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 TVs Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV a partir de US $ 199</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na Holanda!</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - de US $ 99! </font></font></b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leia sobre</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como criar um prédio de infraestrutura. </font><font style="vertical-align: inherit;">classe c usando servidores Dell R730xd E5-2650 v4 que custam 9.000 euros por um centavo?</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt506572/index.html">Criando uma loja on-line do SPA protótipo no htmlix.js</a></li>
<li><a href="../pt506574/index.html">Visualização de uma lista de mulheres vencedoras do Prêmio Nobel na forma de cristais em 3d usando Vue, WebGL, three.js</a></li>
<li><a href="../pt506578/index.html">Volume de chumbo gerenciado</a></li>
<li><a href="../pt506586/index.html">FizzBuzz lógico</a></li>
<li><a href="../pt506588/index.html">O que é um algoritmo! (parte 2)</a></li>
<li><a href="../pt506594/index.html">Melhores práticas do Redis, parte 3</a></li>
<li><a href="../pt506598/index.html">Microsoft: Rust является 'лучшим шансом' в отрасли программирования безопасных систем</a></li>
<li><a href="../pt506600/index.html">O contrato para o desenvolvimento do site em termos de gerenciamento de projetos (teoria + amostra)</a></li>
<li><a href="../pt506604/index.html">Simultaneidade e eficiência: Python vs FSM</a></li>
<li><a href="../pt506606/index.html">Criação de clicker PIXI.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>