<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤒 👰🏽 ⏺️ Paul Graham: Kürze = Stärke 🚘 😶 🙎🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei HackerNews haben wir heute eine Diskussion über den Artikel von Paul Graham aus dem Jahr 2002 geführt und beschlossen, seine Übersetzung aus der N...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Paul Graham: Kürze = Stärke</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillfactory/blog/502926/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei HackerNews haben wir heute </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Diskussion über den</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Artikel von Paul Graham </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">aus dem Jahr</font></a><font style="vertical-align: inherit;"> 2002 geführt und beschlossen, seine Übersetzung aus der </font><font style="vertical-align: inherit;">Nichtexistenz </font><font style="vertical-align: inherit;">wiederzubeleben.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da8/643/390/da8643390d5501c1411a3ba972dbe2ac.jpg" alt="Bild"></div><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Die Menge an Bedeutung, die </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
durch algebraische Zeichen </font><font style="vertical-align: inherit;">auf einen kleinen Raum komprimiert wird </font><font style="vertical-align: inherit;">, ist ein weiterer Umstand, der </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
die Überlegungen </font><font style="vertical-align: inherit;">erleichtert, </font><font style="vertical-align: inherit;">die wir gewohnt sind, mit ihrer Hilfe fortzusetzen." </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - Charles Babbage (1791-1871)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In einer Diskussion um den Artikel </font><font style="vertical-align: inherit;">LL1 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revenge</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf der LL1-Mailingliste brachte Paul Prescod eine Idee zum Ausdruck, die mich nicht aus den Augen lässt.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pythons Ziel ist Regelmäßigkeit und Lesbarkeit, aber nicht Kürze.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf den ersten Blick sollte eine Programmiersprache wahrscheinlich nicht behaupten, es zu sein. </font><font style="vertical-align: inherit;">Nach meinem Verständnis ist Kürze (Prägnanz, Prägnanz, Kompaktheit) = Stärke. </font><font style="vertical-align: inherit;">Und wenn ja, dann erhalten wir eine Substitution, wir bekommen:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pythons Ziel ist Regelmäßigkeit und Lesbarkeit, aber keine Leistung.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist wiederum kein sehr guter Kompromiss (wenn es sich wirklich um einen Kompromiss handelt), der es wert ist, gemacht zu werden. </font><font style="vertical-align: inherit;">Es scheint, als ob Sie sagen: Das Ziel der Python-Sprache ist es nicht, eine effektive Programmiersprache zu sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ist Kürze = Stärke? </font><font style="vertical-align: inherit;">Dies scheint eine wichtige Frage zu sein, vielleicht die wichtigste für diejenigen, die an der Entwicklung von Sprachen beteiligt sind. </font><font style="vertical-align: inherit;">Ich bin mir noch nicht sicher, ob die Antwort einfach "Ja" lautet, aber für den Anfang ist dies eine gute Hypothese.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hypothese</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meine Hypothese ist, dass Kürze Macht ist oder dass sie so nahe beieinander liegen, dass man sie mit Ausnahme von pathologischen Fällen für etwas Identisches halten kann.</font></font><br>
<a name="habracut"></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kürze, so scheint es mir, ist das, wofür Programmiersprachen geschaffen wurden. Computer würden sich genauso freuen, wenn sie Anweisungen direkt in Maschinensprache erhalten würden. Ich denke, der Hauptgrund, warum wir Hochsprachen entwickeln werden, ist der Vorteil, zehn Zeilen in einer Hochsprache auszudrücken (und vor allem zu denken), was 1000 Zeilen Maschinencode erfordern würde. Mit anderen Worten, das Hauptziel von Hochsprachen ist es, den Quellcode kürzer zu machen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der kürzere Quellcode der Zweck von Hochsprachen ist und die Stärke von etwas ein Maß dafür ist, wie gut das Ziel erreicht wird, dann ist die Stärke der Programmiersprache, wie stark sie Ihre Programme reduziert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Umgekehrt macht eine Sprache, die Ihre Programme nicht kleiner macht, eine schlechte Arbeit in einer Programmiersprache, genau wie ein Messer, das schlecht schneidet oder unleserlich druckt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metriken</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und in welchem ​​Sinne ist weniger? </font><font style="vertical-align: inherit;">Das häufigste Maß für die Größe des Quellcodes ist die Anzahl der Zeilen. </font><font style="vertical-align: inherit;">Aber diese Maßnahme ist nur wegen der Einfachheit der Messung üblich, und ich glaube nicht, dass irgendjemand glaubt, dass es ein guter Test für die Programmgröße ist. </font><font style="vertical-align: inherit;">Sprachen haben unterschiedliche Konventionen, was in einer Zeile platziert werden kann. </font><font style="vertical-align: inherit;">Einige Zeilen in C haben möglicherweise nur ein oder zwei Trennzeichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer einfacher Test ist die Anzahl der Zeichen im Programm, aber dieser ist nicht zu gut. </font><font style="vertical-align: inherit;">Einige Sprachen (wie Perl) haben kürzere Bezeichner als andere.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke, das beste Maß für die Größe eines Programms kann die Anzahl der Elemente sein, wobei das Element etwas ist, das zu einem separaten Scheitelpunkt im Quellbaum werden kann. Der Name einer Variablen oder Funktion ist ein Element. eine ganze Zahl oder eine reelle Zahl ist ein Element; Ein Textliteral-Segment ist ein Element. Ein Element einer Muster- oder Formatanweisung ist ein Element. Es gibt Grenzfälle (ist "-5" ein oder zwei Elemente?), Aber ich denke, die meisten sind in allen Sprachen gleich, sodass sie den Vergleich nicht zu sehr beeinflussen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Maßnahme sollte konkretisiert werden und erfordert bei einigen bestimmten Sprachen möglicherweise eine zusätzliche Interpretation, aber es scheint mir, dass versucht wird, das Richtige zu messen: die Anzahl der Programmteile. </font><font style="vertical-align: inherit;">Der Quellbaum ist das, was Sie in Ihrem Kopf zeichnen, um das Programm darzustellen, und daher ist die Größe dieses Baums proportional zum Arbeitsaufwand, der zum Schreiben oder Lesen erforderlich ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Design</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Maßnahme würde es uns ermöglichen, verschiedene Sprachen zu vergleichen, aber dies ist zumindest für mich nicht der Grundwert. Der Wert des Kürze-Tests ist ein Leitfaden für das Entwerfen von Sprachen. Der nützlichste Sprachvergleich besteht darin, zwei mögliche Variationen derselben Sprache zu vergleichen. Was kann ich in der Sprache tun, um Programme zu verkürzen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die konzeptionelle Belastung eines Programms proportional zu seiner Komplexität ist und ein bestimmter Programmierer einer bestimmten konzeptionellen Belastung standhalten kann, entspricht dies der Frage: Wie kann er Programmierern helfen, mehr zu tun? Und das scheint mir dasselbe zu sein wie zu fragen: Wie gestaltet man eine gute Sprache?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Übrigens wird die Falschheit dieses bereits bärtigen Sprichworts „Alle Sprachen sind gleich“ am deutlichsten beim Entwerfen von Sprachen deutlich. Wenn Sie eine neue Sprache erstellen, vergleichen Sie ständig zwei Sprachen - eine, in der ich X machen würde, und die andere, in der ich nicht machen würde - damit Entscheide, was besser ist. Wenn es eine sinnlose Frage wäre, könntest du genauso gut eine Münze werfen.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Ziel der Kürze zu haben, scheint ein guter Weg zu sein, um neue Ideen zu finden. </font><font style="vertical-align: inherit;">Wenn Sie einen Weg finden, Programme zu verkürzen, ist dies kein Zufall: Sie haben wahrscheinlich eine nützliche neue Abstraktion gefunden. </font><font style="vertical-align: inherit;">Sie könnten sogar ein Programm schreiben, das sich wiederholende Blöcke im Quellcode abruft. </font><font style="vertical-align: inherit;">Neue Ideen finden sich in Sprachen, die den Ruf haben, prägnant zu sein: Forth, Joy, Icon.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergleich</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste, der über diese Dinge schrieb, war, soweit ich weiß, Fred Brooks mit seinem Buch Mythical Man-Month. Er schrieb, dass Programmierer unabhängig von der Sprache dieselbe Menge an Code generieren. Als ich es in meinen 20ern zum ersten Mal las, war es eine große Überraschung, und es schien mir, dass dies enorme Konsequenzen hatte. Dies bedeutete, dass (a) die einzige Möglichkeit, Programme schneller zu schreiben, darin besteht, eine kürzere Sprache zu verwenden, und (b) derjenige, der sich die Mühe gemacht hat, die Wettbewerber zu fragen, die dies nicht tun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Brooks Vermutung, wenn sie wahr ist, kann die Essenz des Hackens sein. Seitdem habe ich im Laufe der Jahre auf alles geachtet, was für das Thema relevant wäre: von theoretischen Studien bis zu Geschichten über einzelne Projekte. Ich habe nichts gesehen, was dieser Hypothese widersprechen würde.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber ich habe keine klaren Beweise gesehen, und ich erwarte nicht, sie zu sehen. Studien wie der Vergleich der Programmiersprachen von Lutz Prekelt liefern zwar die erwarteten Ergebnisse, verwenden jedoch tendenziell Aufgaben, die für einen aussagekräftigen Test zu klein sind. Der beste Test für eine Sprache ist, was in Programmen passiert, die in einem Monat geschrieben wurden. Und wenn Sie wie ich davon überzeugt sind, dass der Hauptzweck von Sprachen darin besteht, eine gute Sprache zu sein, in der sie denken (und nicht eine Sprache, in der sie dem Computer Anweisungen geben, nachdem Sie darüber nachgedacht haben), dann ist der eigentliche Test für die Sprache Was Neues kannst du darauf schreiben? Daher ist der Vergleich von Sprachen, die auf einer vordefinierten Spezifikation basieren, etwas falsch.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der eigentliche Test für die Sprache ist, wie gut Sie neue Probleme finden und lösen können, aber nicht die Aufgaben, die von jemand anderem formuliert wurden. Dies sind verschiedene Kriterien. In der Kunst funktionieren Werkzeuge wie Stickerei und Mosaik gut, wenn Sie im Voraus wissen, was Sie erhalten möchten, aber absolut unanständig, wenn Sie es nicht wissen. Wenn Sie beim Schreiben eines Bildes ein Bild anzeigen möchten (was Sie tun sollten, wenn Sie so komplexe Dinge wie beispielsweise das Bild einer Person anzeigen), sollten Sie ein flexibleres Werkzeug wie Bleistift, Tinte oder Ölfarben verwenden. Natürlich werden Wandteppiche und Mosaike einfach so hergestellt: Zuerst wird ein Bild erstellt und dann nur noch kopiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass es unwahrscheinlich ist, dass wir die relative Stärke der Programmiersprachen richtig vergleichen können. Wir werden genaue Vergleiche haben, aber keine korrekten. Insbesondere Studien, die explizit auf Sprachvergleiche abzielen, verwenden wahrscheinlich kleine Aufgaben und verwenden notwendigerweise einen vordefinierten Satz von Aufgaben. Daher werden die mächtigsten Sprachen tendenziell unterschätzt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berichte in diesem Bereich sind wahrscheinlich weniger aussagekräftig als „wissenschaftliche“ Studien, aber wahrscheinlich aussagekräftiger. Zum Beispiel führte Ulf Wieger von Ericsson eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Studie durch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und kam zu dem Schluss, dass Erlang 4-10 mal kürzer als C ++ ist und die Geschwindigkeit der Softwareentwicklung proportional höher ist:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Vergleich der internen Projekte in Ericsson zeigt eine ähnliche Produktivität in Codezeilen pro Stunde, einschließlich aller Entwicklungsphasen, unabhängig von der verwendeten Sprache (Erlang, PLEX, C, C ++ oder Java). </font><font style="vertical-align: inherit;">Unterschiede in den Sprachen - nur in der Gesamtmenge des Quellcodes.</font></font><br>
</blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Studie zeigt auch deutlich, dass sie nicht in Brooks 'Buch erscheint (da nur Zeilen mit debuggtem Code gemessen wurden): Programme, die in leistungsfähigeren Sprachen geschrieben wurden, enthalten tendenziell weniger Fehler. </font><font style="vertical-align: inherit;">Dies ist bereits völlig ausreichend, und wahrscheinlich ist dies bei Aufgaben wie Netzwerk-Switches wichtiger als die Leistung des Programmierers.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schmeckt</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende können Sie Ihrem Instinkt vertrauen. Was ist Programmieren in dieser Sprache? Ich denke, um eine bessere Sprache zu schaffen, sollten Sie überempfindlich werden, wie gut die Sprache es Ihnen ermöglicht, darin zu denken, und dann eine Sprache auswählen oder entwickeln, die Ihnen am besten geeignet erscheint. Wenn eine Eigenschaft der Sprache unpraktisch oder einschränkend ist - keine Sorge, Sie werden davon erfahren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine solche Überempfindlichkeit führt jedoch dazu, dass ungeschickte Sprachen für Sie unerträglich werden. </font><font style="vertical-align: inherit;">Ich finde das Programmieren in Sprachen, die keine unerträglich einschränkenden Makros haben, so als würde jemand, der an dynamisches Tippen gewöhnt ist, die Rückkehr zu Sprachen als unerträglich einschränkend betrachten, wobei Typen für jede deklarierte Variable beschrieben werden sollten und es unmöglich ist, eine Liste mit Elementen zu deklarieren verschiedene Typen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und ich bin nicht allein. </font><font style="vertical-align: inherit;">Ich kenne viele Lisp-Hacker, mit denen etwas Ähnliches passiert ist. </font><font style="vertical-align: inherit;">Tatsächlich könnte das genaueste Maß für die relative Stärke einer Programmiersprache der Anteil der Programmierer sein, die eine bestimmte Sprache kennen und unabhängig vom Fachgebiet Arbeiten ausführen, in denen diese Sprache verwendet werden sollte.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einschränkungen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wahrscheinlich wissen viele Hacker, wie es sich anfühlt, wenn die Sprache restriktiv erscheint. </font><font style="vertical-align: inherit;">Dies ist wahrscheinlich das gleiche Gefühl wie wenn Sie auf der Straße, auf der Sie fahren möchten, im Stau stecken bleiben und einen langen Umweg machen müssen. </font><font style="vertical-align: inherit;">Sie möchten etwas sagen und die Sprache erlaubt Ihnen dies nicht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich ist eine einschränkende Sprache keine prägnante Sprache. </font><font style="vertical-align: inherit;">Das Problem ist nicht, dass Sie etwas nicht ausdrücken können, sondern dass der Umweg, zu dem diese Sprache Sie zwingt, zu lang ist. </font><font style="vertical-align: inherit;">Machen Sie dieses Gedankenexperiment: Sie möchten eine Art Programm schreiben, und die Sprache erlaubt es Ihnen nicht, es so zu machen, wie Sie es geplant haben, sondern macht es kürzer. </font><font style="vertical-align: inherit;">Zumindest für mich wäre das nicht zu restriktiv. </font><font style="vertical-align: inherit;">Als würde ein Polizist Sie von einem Stau auf eine kürzere Straße anstatt auf einen langen Umweg leiten. </font><font style="vertical-align: inherit;">Beeindruckend!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint mir, dass das Gefühl der Begrenztheit im Grunde (um 90 Prozent?) Darauf zurückzuführen ist, dass Sie gezwungen sind, das Programm in der Sprache, in der Sie schreiben, länger zu machen als in der Sprache, in der Sie denken. </font><font style="vertical-align: inherit;">Begrenztheit ist im Grunde eine unzureichende Kürze. Wenn eine Sprache also einschränkend zu sein scheint, bedeutet dies, dass sie nicht kurz genug ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesbarkeit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Zitat, mit dem ich begonnen habe, erwähnt auch zwei andere Eigenschaften: Regelmäßigkeit und Lesbarkeit. </font><font style="vertical-align: inherit;">Ich verstehe nicht wirklich, was Regelmäßigkeit ist und welche Vorteile regulärer und lesbarer Code im Vergleich zu nur lesbarem Code bietet. </font><font style="vertical-align: inherit;">Aber ich glaube zu wissen, was unter Lesbarkeit zu verstehen ist, und es scheint mir auch, dass dies mit Kürze zu tun hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier müssen wir mit den Konzepten der Lesbarkeit einer einzelnen Codezeile und der Lesbarkeit des gesamten Programms vorsichtig sein. </font><font style="vertical-align: inherit;">Nur das Letzte ist wichtig. </font><font style="vertical-align: inherit;">Ich bin damit einverstanden, dass eine Zeile in BASIC höchstwahrscheinlich besser lesbar ist als eine Zeile in Lisp, aber ein in BASIC geschriebenes Programm enthält mehr Zeilen als dasselbe in Lisp geschriebene Programm. </font><font style="vertical-align: inherit;">Das Lesen des BASIC-Programms erfordert mehr Aufwand.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamtaufwand = Aufwand zum Lesen einer Zeile * Anzahl der Zeilen</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich bin mir nicht so sicher, ob die Lesbarkeit proportional zur Kürze ist, aber definitiv ist die Kürze ein Faktor für die Lesbarkeit (siehe die obige Formel). Es macht also kaum Sinn zu sagen, dass der Zweck der Sprache die Lesbarkeit ist, aber nicht die Kürze.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für einen Benutzer, der eine bestimmte Sprache zum ersten Mal sieht, bedeutet die zeilenweise Lesbarkeit, dass diese Sprache für ihn harmlos erscheint. Daher kann die zeilenweise Lesbarkeit eine gute Marketingentscheidung sein, obwohl es sich um eine schlechte Entwurfsentscheidung handelt. Es ist isomorph in Bezug auf die Zahlungsweise in Raten: Anstatt sich von einer großen Anzahlung einschüchtern zu lassen, bieten Sie dem Käufer eine kleine monatliche Zahlung an. Die Zahlung in Teilen ist für ihn letztendlich unrentabel, ebenso wie die zeilenweise Lesbarkeit - für den Programmierer. Der Käufer muss viele kleine Zahlungen leisten, genauso wie der Programmierer viele lesbare Zeilen separat lesen muss.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Verhältnis bestand bereits vor dem Aufkommen der Programmiersprachen. </font><font style="vertical-align: inherit;">Wenn Sie Romane und Zeitungsartikel lesen, kann Ihre erste Erfahrung beim Lesen eines Artikels in Mathematik beängstigend sein: Das Lesen einer Seite dauert eine halbe Stunde. </font><font style="vertical-align: inherit;">Trotzdem bin ich mir sicher, dass das Problem nicht in der Notation liegt, wie es auf den ersten Blick scheinen mag. </font><font style="vertical-align: inherit;">Ein Artikel in Mathematik ist schwer zu lesen, da die Ideen selbst komplex sind. </font><font style="vertical-align: inherit;">Wenn Sie dieselben Ideen in Prosa ausdrücken (wie es Mathematiker getan haben, bevor sie an eine kurze Notation gedacht haben), wäre das Lesen nicht einfacher, da diese einzelne Seite zu einem ganzen Buch werden würde.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In welchem ​​Maße?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige waren mit der Idee der Kürze = Stärke nicht einverstanden. Ich denke, anstatt zu streiten, ob dies so ist, wäre es sinnvoller zu fragen, inwieweit Kürze Macht ist. Weil es klar ist, dass Kürze eines der Hauptziele von Programmiersprachen ist. Und wenn nicht, was ist ihr Zweck und wie wichtig sind diese anderen Funktionen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich schlage dies vor, um die Diskussion nicht ziviler zu gestalten. Ich möchte wirklich die Antwort wissen. Wann, wenn überhaupt, wird die Sprache prägnant genug?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hypothese, mit der ich begann, war, dass bis auf einige pathologische Fälle die Kürze mit der Stärke identisch ist. </font><font style="vertical-align: inherit;">Ich meinte, dass sie in jeder von jemandem entwickelten Sprache identisch sein werden, aber wenn jemand eine Sprache speziell erstellen möchte, um diese Hypothese zu widerlegen, wird es wahrscheinlich funktionieren. </font><font style="vertical-align: inherit;">Aber da bin ich mir auch nicht sicher.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprachen, aber keine Programme</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sollte klargestellt werden, dass es sich um die Kürze der Sprachen handelt, nicht um einzelne Programme. Natürlich können einige Programme sehr eng geschrieben werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe darüber in dem Buch „About Lisp“ geschrieben. Damit sich das Makro rechtfertigen kann, muss es im Verhältnis zu seiner eigenen Länge um ein Vielfaches mehr Platz sparen. Wenn ein umfangreiches Makro bei jeder Verwendung zehn Codezeilen speichert und das Makro selbst aus zehn Zeilen besteht, sparen Sie Zeilen, wenn Sie es mehr als zweimal verwenden. Dies ist jedoch immer noch ein schlechter Schritt, da Makrodefinitionen schwieriger zu lesen sind als normaler Code. Möglicherweise müssen Sie das Makro 10 oder 20 Mal verwenden, bevor sich die Lesbarkeit verbessert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich bin sicher, dass in jeder Sprache solche Kompromisse möglich sind (obwohl ich vermute, dass der Einsatz in starken Sprachen erhöht wird). Jeder Programmierer hat jemals Code gesehen, der aufgrund zweifelhafter Programmiertechniken extrem verkürzt ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher ist es - zumindest für mich - unbestreitbar, dass Programme präzise genug sein können. Die Frage ist, können die Sprachen selbst kurz sein? Können Sprachen Programmierer zwingen, auf Kosten der Lesbarkeit kurz (in Elementen) zu schreiben?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Grund, warum man sich eine zu prägnante Sprache kaum vorstellen kann, ist, dass es wahrscheinlich einen längeren Weg geben wird, wenn es eine zu kompakte Art gibt, etwas auszudrücken. Wenn Ihnen beispielsweise die Verwendung von Makros oder Funktionen auf hoher Ebene in Lisp zu dicht erscheint, können Sie Code schreiben, der für Pascal isomorph ist. Wenn Sie die Fakultät in der Sprache von Arc nicht als Aufruf einer übergeordneten Funktion ausdrücken möchten, </font></font><br>
<br>
<code>(rec zero 1 * 1-)</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
können Sie auch eine rekursive Definition schreiben: </font></font><br>
<br>
<code>(rfn fact (x) (if (zero x) 1 (* x (fact (1- x)))))</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl ich nicht sofort Beispiele nennen kann, interessiert mich die Frage: Kann die Sprache zu kurz sein? Gibt es Sprachen, die Sie zwingen, unleserlichen Code zu schreiben? Wenn jemand Beispiele hat, würde ich mich freuen, sie zu sehen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Denken Sie daran: Ich interessiere mich für Programme mit einer hohen Dichte gemäß dem oben beschriebenen Maß an "Elementen", aber nicht für Programme, die kurz sind, nur weil Trennzeichen weggelassen werden können und alles Namen hat, die ein Zeichen lang sind.) </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wurde zuerst </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier veröffentlicht</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br>
<hr><br>
<br>
<img src="https://habrastorage.org/webt/nk/j2/oz/nkj2oztxanscb6lhq19l-dfv2z8.jpeg" alt="Bild" align="left"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erfahren Sie in SkillFactory-Onlinekursen, wie Sie einen begehrten Beruf von Grund auf neu erlernen oder Ihre Fähigkeiten und Ihr Gehalt verbessern können:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data Scientist Profession Course (24 Monate) </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beruf Data Analyst Kurs (18 Monate)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python für Webentwicklungskurs (9 Monate)</font></font></a></li>
</ul> <br>
<br clear="left"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de502916/index.html">Unit-Tests für RxSwift-Code</a></li>
<li><a href="../de502918/index.html">Fehler mit der Direktive #line im Visual C ++ - Compiler</a></li>
<li><a href="../de502920/index.html">Da haben wir die Leistung neuer Prozessoren in der Cloud für 1C nach dem Gilyov-Test getestet</a></li>
<li><a href="../de502922/index.html">Crowd Marketing als Instrument zur Steigerung der geschäftlichen Vitalität</a></li>
<li><a href="../de502924/index.html">Snom D735 IP-Telefon Bewertung</a></li>
<li><a href="../de502928/index.html">Minikonferenz "Sicheres Arbeiten mit Cloud-Diensten"</a></li>
<li><a href="../de502930/index.html">Azure DevOps und App Center anstelle von Testfarmen: Vereinfachen und beschleunigen Sie die mobile Entwicklung mit Cloud-Diensten</a></li>
<li><a href="../de502932/index.html">Patrick Mackenzies Gesetz: Softwareökonomie ist mehr als Sie denken, selbst wenn man Patrick Mackenzies Gesetz berücksichtigt</a></li>
<li><a href="../de502934/index.html">So senken Sie die Werbekosten in Yandex.Direct und Google Ads: 9 Life Hacks</a></li>
<li><a href="../de502940/index.html">Wie man einen Newsletter nicht in Spam verwandelt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>