<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🏭 🕵️ 👨🏿‍⚖️ Des centaines de milliers de routes par seconde par cœur. Expérience Yandex.Routing 🖖🏻 😍 💂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelques semaines, Danya Tararukhin a raconté sur Habré comment notre service est apparu, Yandex.Routing, et comment il aide les entreprises av...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Des centaines de milliers de routes par seconde par cœur. Expérience Yandex.Routing</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/496818/"><img src="https://habrastorage.org/webt/it/we/vn/itwevn4ivk3h4pncvonx-mh4w70.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a quelques semaines, Danya Tararukhin a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raconté</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur Habré comment notre service est apparu, Yandex.Routing, et comment il aide les entreprises avec la logistique. </font><font style="vertical-align: inherit;">En créant la plate-forme, nous avons résolu plusieurs problèmes intéressants, dont l'un est dédié au message d'aujourd'hui. </font><font style="vertical-align: inherit;">Je veux parler de la planification d'itinéraire elle-même et des ressources nécessaires pour cela.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trouver le meilleur itinéraire entre plusieurs points est un problème d'optimisation discret classique. </font><font style="vertical-align: inherit;">Pour le résoudre, vous devez connaître les distances et les temps de trajet entre tous les points. </font><font style="vertical-align: inherit;">C'est-à-dire connaître la matrice des distances et des temps. </font><font style="vertical-align: inherit;">Il y a deux ans, un long calcul matriciel était un problème très critique pour nous et a bloqué le développement. </font><font style="vertical-align: inherit;">La recherche de la solution optimale avec la matrice connue a pris 10 minutes, mais le calcul de toutes les cellules de la matrice pour des tâches importantes (pour plusieurs milliers de commandes) a pris des heures.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour résoudre le problème avec cinq mille commandes, vous devez connaître les distances et les temps de trajet entre tous les points. Ce sont deux matrices de nombres avec une dimension de 5000x5000. Nous planifions des itinéraires de messagerie pour toute la journée, et le matin, le courrier arrivera d'un point à un autre et le soir - pour un autre. Vous devez donc calculer la matrice des temps et des distances pour chaque heure de la journée. Toutes les heures de la journée ne sont pas uniques, mais le temps de liège (matin et soir) doit être bien couvert. Par conséquent, nous sommes arrivés à une configuration avec des tranches de treize heures. Au total, nous avons besoin de deux cubes (temps et distances) de 13x5000x5000 chacun. Ce sont 325 millions d'itinéraires, calculés selon le vrai graphe routier, dont 165 millions de contours. Le calcul d'un itinéraire dans un algorithme bien optimisé de l'équipe Yandex.Maps prend environ 10 ms, pour un total de 900 heures de calculs.Même en parallèle avec 900 CPU, vous devez attendre 1 heure. Nous ne pouvions pas démarrer un tel service, nous avions besoin d'un algorithme plus adapté.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour une lecture plus approfondie, il est utile de connaître </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'algorithme de Dijkstra</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour trouver le chemin le plus court dans un graphique. Il peut être imaginé comme une «vague» émanant du point de départ de l'itinéraire et faisant le tour du graphique jusqu'à ce que le point d'arrivée soit atteint. Dans ce cas, le temps d'exécution de l'algorithme est proportionnel aux bords du graphique, c'est-à-dire la zone couverte par la vague: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cz/7s/em/cz7seml-ef9d058gdfhgkoe50_k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
presque tous les candidats à une entrevue lors d'une entrevue connaissent la première étape de l'optimisation d'une telle tâche: vous pouvez démarrer la vague des deux côtés et terminer la recherche lorsque les vagues se rencontrent. La superficie totale de deux vagues de demi-rayon est inférieure à une grande.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2g/ch/2c/2gch2cvzqgbjwduk9_agsqhvrma.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le vrai graphique de route est assez structuré, et cela peut être utilisé. Lorsque vous cherchez la distance la plus courte entre Moscou et Saint-Pétersbourg, dans la Dijkstra classique, vous serez obligé de répartir la vague en cercle et de trier toutes les rues et ruelles de Moscou, les villes et villages de la région de Moscou, les rues de Tver et Novgorod. C'est une énorme quantité de calcul, mais vous pouvez vous préparer à l'avance et vous souvenir des itinéraires optimaux entre les villes (alias raccourcis) et ne pas les répéter pendant l'exécution. Ensuite, pour trouver l'itinéraire entre deux points dans la hiérarchie Dijkstra, vous devez calculer les distances les plus courtes jusqu'au raccourci souhaité. Étant donné que les niveaux de hiérarchie peuvent ne pas être deux, mais 5-6, ils réduisent considérablement le temps de recherche.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'équipe du routeur de cartes a mis en œuvre de telles optimisations depuis un certain temps. Ce sont eux qui ont permis d'atteindre 10 ms pour trouver un itinéraire entre deux points. :) Donc pour l'instant, nous n'avons pas réussi à résoudre notre problème. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le mode de recherche point à point étant déjà extrêmement optimisé, nous pouvons optimiser le calcul de la série dans la matrice. Une ligne est la distance d'un point à tous les autres. Pendant que nous recherchons la distance jusqu'au point le plus éloigné, nous calculons simultanément les distances vers les plus proches. Par conséquent, le calcul de la série équivaut au calcul de la distance jusqu'au point le plus éloigné. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jp/6i/qa/jp6iqadxummylqmj1suh0h2ppe8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous regardons le temps de calcul de la série en utilisant cet algorithme et rappelons que le calcul séquentiel de 5000 routes prendrait environ 5000 * 10 ms = 50 s:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jv/c_/v9/jvc_v98yos03l5xd5w57394s4dk.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le graphique montre le temps de calcul d'une ligne dans une matrice de distance de taille 1 * N pour différents N (selon des données réelles). On peut voir que le calcul de la ligne de taille 1 * 5000 qui nous intéresse tient en 1,3 seconde. Une ligne de tendance a été ajoutée au graphique, ce qui montre que le temps de calcul s'allonge légèrement plus lentement que linéairement en N, de l'ordre de N ** 0,74</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Déjà pas mal! Avec cet algorithme, nous pouvons calculer notre cube en 13 * 5000 * 1,3 s = 84 500 s = près de 24 heures. Il est facilement parallèle en rangées et lorsque vous utilisez 50 CPU, les distances sont calculées en une demi-heure. L'ordre de complexité de l'algorithme de calcul du cube est O (N ** 1,74):</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9c/cr/xd/9ccrxdjoher2ks-ijoa7ur3rd2m.png"><br>
<i>    13   N*N    50 CPU (    13*N/50).      ,        5000 ,           .      10 000,   :      .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sous cette forme, il y a deux ans et demi, nous avons lancé la première version de notre API, qui résout le problème logistique. Les clients se plaignaient souvent d'un long temps de décision, et ils sont faciles à comprendre: vous avez commencé la tâche à résoudre, attendez 1 heure, vous obtenez la solution et vous comprenez que vous avez oublié de fixer le temps de travail avec le conducteur, vous le corrigez et tout recommence. Les conducteurs commencent à devenir nerveux, car ils risquent d'entrer dans l'heure de pointe du matin, ou même n'ont pas le temps de livrer la commande à temps. Il fallait faire quelque chose. Nous ne voulions pas «lancer» le problème du fer: nous nous préparions à de lourdes charges, cela aurait nécessité beaucoup de fer et l'achat de serveurs ne se fait pas d'un coup. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une étude d'articles universitaires a montré qu'il existe des algorithmes de complexité linéaire pour cette tâche </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! (Dans l'article par référence, il y a un large aperçu de toutes sortes de méthodes modernes d'accélération de Dijkstra, y compris pour le cas de la matrice.) Le calcul de la matrice en temps linéaire ne me convenait pas. Un de nos développeurs s'est porté volontaire pour écrire un prototype, et c'est ce qui s'est passé: Le </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/3o/lq/ag3olqspwhrjrvtodp699z6bl64.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temps de calculer une matrice de taille N * N sur un CPU en utilisant l'algorithme "fast matrix". La complexité est obtenue de l'ordre de O (N ** 1,1). Les N élevés sont éliminés de la ligne de tendance, car la génération de la réponse et son téléchargement sur le réseau influencent déjà davantage le temps.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
115 secondes par matrice 5000x5000 utilisant un seul cœur et une dépendance quasi linéaire de N. La fiction est devenue une réalité! L'idée de l'algorithme combine les deux idées décrites ci-dessus: Dijkstra pour la recherche en série et hiérarchique. De toute évidence, en commençant à calculer la deuxième ligne, à un moment donné, nous allons à nouveau parcourir la même zone du graphique que nous venons de parcourir, en calculant la ligne précédente. Par conséquent, mémorisons les distances les plus courtes vers toutes les destinations aux nœuds du graphe hiérarchique. Lorsque nous commençons à calculer la série suivante, puis, ayant atteint un tel nœud, nous obtiendrons immédiatement presque toutes les distances à d'autres points. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ch/3y/os/ch3yosqi1h0od0dtee_tn_dsqem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un an et demi, cela nous a permis de gagner une demi-heure avec </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logistique et réduire considérablement l'apport en fer. </font><font style="vertical-align: inherit;">Auparavant, pour une grande demande, nous avions besoin de 50 cœurs pendant une demi-heure, mais maintenant - 13 cœurs pendant 2 minutes. </font><font style="vertical-align: inherit;">Cela représente environ 200 000 itinéraires par seconde et par cœur. </font><font style="vertical-align: inherit;">Ce cas rare où le nouvel algorithme ne ferme pas seulement la classe des problèmes, mais élargit nos idées sur le possible.</font></font><br>
 <br>
<hr><sub><sup><a name="arxiv"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Article «Planification d'itinéraire dans les réseaux de transport», voir le paragraphe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.7.2 «Chemins les plus courts en lots»</font></font></a></sup></sub></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr496802/index.html">Simple Made Easy - Rich Hickey (avec traduction en russe)</a></li>
<li><a href="../fr496804/index.html">Installation et configuration de Docker sur le sous-système Windows Linux (WSL)</a></li>
<li><a href="../fr496810/index.html">Analyse financière générale en Python (Partie 3)</a></li>
<li><a href="../fr496812/index.html">Zoom - négligence banale ou espionnage ciblé?</a></li>
<li><a href="../fr496816/index.html">Pouvez-vous sentir le candidat, est-il vivant?</a></li>
<li><a href="../fr496820/index.html">Pièges de Terraform</a></li>
<li><a href="../fr496822/index.html">Comment les startups aux États-Unis meurent à cause du coronavirus</a></li>
<li><a href="../fr496824/index.html">Votre environnement de travail nordique</a></li>
<li><a href="../fr496826/index.html">Des millions de sprites à plus de 120 images par seconde</a></li>
<li><a href="../fr496828/index.html">Où trouver des freelances qui seront amusants? (Spoiler: pas Upwork)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>