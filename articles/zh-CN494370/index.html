<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶🏽 💼 😅 通过Python开发人员的眼光看清架构 😴 ⛪️ 🤴🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="你好！我叫Eugene，我是Python开发人员。在过去的一年半中，我们的团队开始积极应用“清洁架构”的原理，摆脱了传统的MVC模型。今天，我将讨论我们如何实现这一目标，它给我们带来了什么以及为什么直接从其他PL转移方法并不总是一个好的解决方案。
 
 
 
 七年来，Python一直是我的主要开发...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>通过Python开发人员的眼光看清架构</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/exness/blog/494370/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">你好！我叫Eugene，我是Python开发人员。在过去的一年半中，我们的团队开始积极应用“清洁架构”的原理，摆脱了传统的MVC模型。今天，我将讨论我们如何实现这一目标，它给我们带来了什么以及为什么直接从其他PL转移方法并不总是一个好的解决方案。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t_/hs/tl/t_hstlzmkevavrg4y8tazjdfu4c.png"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
七年来，Python一直是我的主要开发工具。当他们问我最喜欢他的时候，我回答这是他</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出色的可读性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。第一次相识始于对</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“编程集体思想”一</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">书的阅读</font><font style="vertical-align: inherit;">。我对其中描述的算法很感兴趣，但是所有示例都使用当时我还不熟悉的语言。这并不常见（Python尚未在机器学习中成为主流），列表通常以伪代码或使用图表编写。但是在快速介绍了该语言之后，我欣赏了它的简洁性：一切都很</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简单明了，没有多余和令人分心的东西，只是描述过程的本质</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它的主要优点是语言的惊人设计，非常直观的语法糖。</font><font style="vertical-align: inherit;">这种表现力在社区中一直受到赞赏。</font><font style="vertical-align: inherit;">什么是“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">导入此内容</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”，必须出现在任何教科书的第一页上：它看起来像是一个看不见的监督者，会不断评估您的行为。</font><font style="vertical-align: inherit;">在论坛上，初学者值得</font><font style="vertical-align: inherit;">在清单中的变量名称中</font><font style="vertical-align: inherit;">使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CamelCase</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此，讨论的角度立即转向参考PEP8的拟议代码的成语。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对优雅的追求以及强大的语言活力创造了许多具有真正令人愉悦的API的库。&nbsp;</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管如此，Python虽然功能强大，但它只是一个工具，允许您编写表达性的，具有自我</font><font style="vertical-align: inherit;">说明性的</font><font style="vertical-align: inherit;">代码，但它</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能保证此功能</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，也不</font><b><font style="vertical-align: inherit;">保证</font></b><font style="vertical-align: inherit;"> PEP8的兼容性。</font><font style="vertical-align: inherit;">当我们在Django上看似简单的在线商店开始盈利并因此增加功能时，有一点我们了解到它并不是那么简单，即使进行基本更改也需要越来越多的努力，最重要的是，这种趋势</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正在增长。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发生了什么事，什么都出错了？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">错误的代码</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
错误代码不是不遵循PEP8或不满足圈复杂度要求的代码。</font><font style="vertical-align: inherit;">首先，错误代码是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不受控制的依赖关系</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它导致以下事实：程序一个位置的更改导致其他部分的更改无法预测。</font><font style="vertical-align: inherit;">我们正在失去对代码的控制；扩​​展功能需要对项目进行详细研究。</font><font style="vertical-align: inherit;">这样的代码失去了灵活性，并且无法进行更改，而程序本身变得“脆弱”。&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">干净的建筑</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
选择的应用程序体系结构应该避免这个问题，而且我们不是第一个遇到此问题的人：Java社区已经有很长时间讨论创建最佳的应用程序设计了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
早在2000年，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Robert Martin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（也称为Bob叔叔）在他的文章“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Design and Design Principles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">设计和设计原则</font></a><font style="vertical-align: inherit;">）中就</font><font style="vertical-align: inherit;">以令人难忘的缩写</font><b><font style="vertical-align: inherit;">SOLID</font></b><font style="vertical-align: inherit;">汇集了设计OOP应用程序的五项原则。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这些原则已为社区所接受，并且远远超出了Java生态系统。然而，它们本质上是非常抽象的。后来，人们进行了几次尝试来开发基于SOLID原理的通用应用程序设计。其中包括：“六角形体系结构”，“端口和适配器”，“球状体系结构”，尽管实现细节不同，但它们都有很多共同点。 2012年，同一位罗伯特·马丁（Robert Martin）发表了一篇文章，在那里他提出了自己的版本《</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清洁建筑</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">》。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c32/3a9/769/c323a9769c90f4e28a17e1d5c05ab160.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
据Bob叔叔说，架构主要是“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">边界和障碍</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”，有必要清楚地了解需求并限制软件接口，以免失去对应用程序的控制。为此，该程序</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分为几层</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">从一层转到另一层，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只能传输数据</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（简单的结构和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DTO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">可以充当data </font><font style="vertical-align: inherit;">）-这是边界的规则。</font><font style="vertical-align: inherit;">另一个最常被引用的短语是“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用程序应该尖叫</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”，这意味着</font><i><font style="vertical-align: inherit;">应用程序</font></i><font style="vertical-align: inherit;">中的主要内容不是所使用的框架或数据存储技术，而是该应用程序的实际功能，执行的功能- </font><font style="vertical-align: inherit;">应用程序</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">业务逻辑。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，图层不具有线性结构，而是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有层次结构</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，还有另外两个规则：</font></font><br>
 <br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内层的优先级规则</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -由内层决定与外界交互的接口；</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依赖性规则</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -依赖性应从内层指向外层。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后一条规则在Python世界中是非常不典型的。</font><font style="vertical-align: inherit;">要应用任何复杂的业务逻辑方案，您始终需要访问外部服务（例如，数据库），但是要避免这种依赖性，业务逻辑层</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须自己声明</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将与外界交互</font><b><font style="vertical-align: inherit;">的接口</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该技术称为</font><font style="vertical-align: inherit;">`` </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依赖倒置</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ''（SOLID中的字母D），并广泛用于具有静态类型的语言中。</font><font style="vertical-align: inherit;">根据Robert Martin所说，这是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOP附带</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><b><font style="vertical-align: inherit;">主要优点</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这三个规则是Clean Architecture的本质：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过境规则；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依赖规则；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内层的优先级规则。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种方法的优点包括：</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">易于测试</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -分别隔离各层，可以在不进行猴子修补的情况下对其进行测试，可以根据其重要性程度为不同的层设置涂层的粒度；</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">易于更改的业务规则</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为所有</font><b><font style="vertical-align: inherit;">规则</font></b><font style="vertical-align: inherit;">都收集在一个地方，不会散布在项目中，也不会与低级代码混合；</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不受外部代理的影响</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：在某些情况下，业务逻辑与外界之间存在抽象，因此您可以更改外部源而不会影响内部层。</font><font style="vertical-align: inherit;">如果您没有将业务逻辑绑定到外部代理程序的特定功能（例如数据库事务），则此方法有效。</font></font></li>
<li><b> </b>,   ,     ,      .</li>
</ul><br>
<blockquote>     ,    .           .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>.     «<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> Clean Architecture</a>».<br>
</blockquote><br>
<h2>  Python</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个理论，可以在Robert Martin的原始文章，报告和书中找到实际应用的示例。它们依赖于Java世界中的几种常见设计模式：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">适配器，网关，交互器，Fasade，存储库，DTO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那么，Python呢？就像我说的那样，简洁主义在Python社区中很有价值，而扎根于其他人远非它会扎根于我们这一事实。三年前，我第一次谈到这个话题，但是关于在Python中使用Clean Architecture的话题没有很多资料，但是Google的第一个链接是</font><font style="vertical-align: inherit;">Leonardo Giordani </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：作者详细介绍了为使用TDD方法查找房地产的网站创建API的过程，应用清洁架构。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不幸的是，尽管作出了周密的解释并遵循了鲍勃叔叔的所有教,，但这个例子还是很</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可怕的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
项目API包含一种方法-获取具有可用过滤器的列表。我认为，即使对于新手开发人员来说，此类项目的代码也不会超过15行。但是在这种情况下，他拿了六个小包。您可以引用一个并非完全成功的布局，这是事实，但是在任何情况下，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都很难有人</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考该项目</font><b><font style="vertical-align: inherit;">来解释这种方法的有效性</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有一个更严重的问题，如果您不阅读本文并立即开始研究该项目，那么就很难理解。考虑业务逻辑的实现：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> rentomatic.response_objects <span class="hljs-keyword">import</span> response_objects <span class="hljs-keyword">as</span> res<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoomListUseCase</span>(<span class="hljs-params">object</span>):</span>
&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, repo</span>):</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.repo = repo<font></font>
&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(<span class="hljs-params">self, request_object</span>):</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> request_object:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> res.ResponseFailure.build_from_invalid_request_object(<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request_object)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">try</span>:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rooms = self.repo.list(filters=request_object.filters)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> res.ResponseSuccess(rooms)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exc:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> res.ResponseFailure.build_system_error(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"{}: {}"</span>.format(exc.__class__.__name__, <span class="hljs-string">"{}"</span>.format(exc)))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实现业务逻辑的RoomListUseCase类（不是很类似于业务逻辑，对吗？）由</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象初始化项目的</font><font style="vertical-align: inherit;">。但是什么是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回购协议</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？当然，从上下文中，我们可以了解到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实现了用于访问数据的Repository模板，如果我们查看RoomListUseCase的主体，我们知道它必须具有一个list方法，其输入是一个过滤器列表，在输出中不清楚，您需要查看在ResponseSuccess中。而且，如果场景更复杂，可以访问数据源？原来了解回购是什么，您</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只能参考实现</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是她在哪里？它位于一个单独的模块中，该模块与RoomListUseCase无关。因此，要了解正在发生的事情，您需要进入上层（框架的层次），并在创建对象时查看馈入类的输入的内容。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可能会认为我列出了动态类型的缺点，但这并非完全正确。它是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动态类型，可让您编写富有表现力的紧凑型代码</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我想到了与微服务的类比，当我们将一个整体切成微服务时，由于具有可以在微服务内部完成的任何事情（PL，框架，体系结构）的能力，因此设计具有更高的刚性，但是它必须符合声明的接口。所以在这里：当我们将项目划分为多个层时，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">层之间的关系必须与合同一致</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而在层内部，合同是可选的。否则，您需要保持很大的头脑。记住，我曾说过，代码错误的问题是依赖关系，因此，在没有显式接口的情况下，我们会再次滑回我们想要摆脱的位置-由于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺少明显的因果关系</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<blockquote>    <i>repo</i>     RoomListUseCase,    execute — <b>   </b>.       -    ,   ,     .     -        . ,   ,    ,  <i>repo</i>   .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总的来说，那时我在一个新项目中放弃了Clean Architecture，再次应用了经典的MVC。但是，在填补了下一批锥体之后，一年后，他又回到了这个想法，最后，我们开始在Python 3.5+中启动服务。如您所知，他带来了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型注释</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据类</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：两个强大的界面描述工具。基于它们，我草绘了服务的原型，结果已经好多了：尽管仍然有很多代码，尤其是与框架集成时，各层却停止了分散。但这足以在小型项目中开始采用这种方法。逐渐地，出现了专注于最大程度地使用类型注释的框架：apistar（现在为starlette），meltframework。 pydantic / FastAPI捆绑包现在很常见，并且与此类框架的集成变得更加容易。这是上述restomatic / services.py示例的样子：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Optional, List
<span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Room</span>(<span class="hljs-params">BaseModel</span>):</span><font></font>
&nbsp;&nbsp;&nbsp;code: str<font></font>
&nbsp;&nbsp;&nbsp;size: int<font></font>
&nbsp;&nbsp;&nbsp;price: int<font></font>
&nbsp;&nbsp;&nbsp;latitude: float<font></font>
&nbsp;&nbsp;&nbsp;longitude: float<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoomFilter</span>(<span class="hljs-params">BaseModel</span>):</span>
&nbsp;&nbsp;&nbsp;code: Optional[str] = <span class="hljs-literal">None</span>
&nbsp;&nbsp;&nbsp;price_min: Optional[int] = <span class="hljs-literal">None</span>
&nbsp;&nbsp;&nbsp;price_max: Optional[int] = <span class="hljs-literal">None</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoomStorage</span>:</span>
&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_rooms</span>(<span class="hljs-params">self, filters: RoomFilter</span>) -&gt; List[Room]:</span> ...<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoomListUseCase</span>:</span>
&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, repo: RoomStorage</span>):</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.repo = repo<font></font>
&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_rooms</span>(<span class="hljs-params">self, filters: RoomFilter</span>) -&gt; List[Room]:</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rooms = self.repo.get_rooms(filters=filters)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> rooms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RoomListUseCase-实现项目业务逻辑的类。您不应该注意show_rooms方法所做的只是对RoomStorage的调用这一事实（我没有给出此示例）。在现实生活中，还可以进行折扣计算，根据广告对列表进行排名等。但是，该模块是自给自足的。如果要在另一个项目中使用此方案，则必须实现RoomStorage。从模块中可以清楚地看到所需的内容。与前面的示例不同，这样的层</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是自给自足的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且在更改时不必牢记整个上下文。从非系统性依赖只能是pytantic，为什么，它将在框架的插件中变得很清楚。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有依赖</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这是提高代码可读性的另一种方式，而不是其他上下文，即使是新手开发人员也将能够理解该模块的功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
业务逻辑场景不必一定是一个类；以下是以函数形式的类似场景的示例：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rool_list_use_case</span>(<span class="hljs-params">filters: RoomFilter, repo: RoomStorage</span>) -&gt; List[Room]:</span><font></font>
&nbsp;&nbsp;&nbsp;rooms = repo.get_rooms(filters=filters)<font></font>
&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> rooms</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是与框架的连接：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> List
<span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Depends
<span class="hljs-keyword">from</span> rentomatic <span class="hljs-keyword">import</span> services, adapters<font></font>
app = FastAPI()<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_use_case</span>() -&gt; services.RoomListUseCase:</span>
&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> services.RoomListUseCase(adapters.MemoryStorage())<font></font>
<font></font>
<span class="hljs-meta">@app.post("/rooms", response_model=List[services.Room])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rooms</span>(<span class="hljs-params">filters: services.RoomFilter, use_case=Depends(<span class="hljs-params">get_use_case</span>)</span>):</span>
&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> use_case.show_rooms(filters)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用get_use_case函数，FastAPI实现了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依赖注入</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式</font><font style="vertical-align: inherit;">。我们无需担心数据序列化，所有工作都由FastAPI与pydantic一起完成。不幸的是，数据并不总是适合于在餐厅现场直播的业务逻辑格式，相反，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">业务逻辑不知道数据来自何处-带有斜杠，请求正文，Cookie等</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在这种情况下，房间功能的主体将对输入和输出数据进行一定的转换，但是在大多数情况下，如果我们使用API​​，那么这样一个简单的代理功能就足够了。&nbsp;</font></font><br>
<br>
<blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>   , ,    ,    RoomStorage.  ,     15 ,     ,      ,         .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正如规范的“干净架构”模型所建议的那样，我故意没有分开业务逻辑层。</font><font style="vertical-align: inherit;">Room类应该位于表示域区域的Entity域区域层中，但是对于此示例，则不需要这样做。</font><font style="vertical-align: inherit;">通过合并Entity和UseCase层，该项目不会停止成为Clean Architecture实施。</font><font style="vertical-align: inherit;">罗伯特·马丁本人曾多次说过，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">层数可以</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上下</font><b><font style="vertical-align: inherit;">变化</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">同时，该项目符合清洁建筑的主要标准：</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">越境</font><b><font style="vertical-align: inherit;">规则</font></b><font style="vertical-align: inherit;">：大体模型，本质上是DTO，</font><b><font style="vertical-align: inherit;">跨越边界</font></b><font style="vertical-align: inherit;">；</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依赖规则</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：业务逻辑层独立于其他层；</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部层的优先级规则</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：业务逻辑层定义接口（RoomStorage），业务逻辑通过该接口与外界交互。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今天，我们团队中使用上述方法实施的几个项目正在开发中。</font><font style="vertical-align: inherit;">我尝试通过这种方式来组织最小的服务。</font><font style="vertical-align: inherit;">它训练得很好-提出之前我从未想过的问题。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，这里的业务逻辑是什么？</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，如果您正在编写某种代理，这远非总是显而易见的。</font><font style="vertical-align: inherit;">另一个重要的一点是要</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学会不同的想法。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。当我们完成一项任务时，我们通常会开始考虑框架，所使用的服务，是否需要在此处进行存储，最好在哪里存储可以缓存的数据的行。在指示“干净架构”的方法中，我们必须首先实现业务逻辑，然后再继续实现与基础架构的交互，因为根据罗伯特·马丁说，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">架构</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><b><font style="vertical-align: inherit;">主要任务</font></b><font style="vertical-align: inherit;">是延迟与任何基础</font><b><font style="vertical-align: inherit;">架构之间</font></b><font style="vertical-align: inherit;">的连接时间。基础结构层将成为您应用程序的组成部分。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总的来说，我看到在Python中使用Clean Architecture的良好前景。</font><font style="vertical-align: inherit;">但是，最有可能的形式将与其他PL接受的形式显着不同。</font><font style="vertical-align: inherit;">在过去的几年中，我看到社区中对建筑这一主题的兴趣大大增加。</font><font style="vertical-align: inherit;">因此，在上一届PyCon会议上，有几篇关于DDD使用的报告，应该单独记录来自</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">干实验室的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人员</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在我们公司中，许多团队已经在某种程度上实施了所描述的方法。</font><font style="vertical-align: inherit;">我们都在做同样的事情，我们已经成长，我们的项目已经成长，Python社区必须与之合作，定义通用的样式和语言，例如，曾经成为所有Django的样式和语言。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN494350/index.html">3月和4月在线活动摘要</a></li>
<li><a href="../zh-CN494354/index.html">知识和条件</a></li>
<li><a href="../zh-CN494356/index.html">Linux新手Aircrack-ng教程</a></li>
<li><a href="../zh-CN494364/index.html">GDPR：同意处理个人数据</a></li>
<li><a href="../zh-CN494366/index.html">从3月27日开始，为期一周的在线mitaps（背面，移动，QA，PM等）</a></li>
<li><a href="../zh-CN494372/index.html">全俄验证软件-内部视图</a></li>
<li><a href="../zh-CN494374/index.html">电动巴士及其电池：什么是钛酸锂？（第1部分）</a></li>
<li><a href="../zh-CN494376/index.html">层次深度缓冲区</a></li>
<li><a href="../zh-CN494380/index.html">战略产品管理导论</a></li>
<li><a href="../zh-CN494384/index.html">功能调查</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>