<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÑ üñïüèΩ üë©üèø‚ÄçüöÄ Creating roguelike in Unity from scratch: dungeon generator üë®üèª‚ÄçüöÄ üòÜ ü§ì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This time we will plunge into the implementation of the algorithm of the dungeon generator. In the last article, we created the first room, and now we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Creating roguelike in Unity from scratch: dungeon generator</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495588/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This time we will plunge into the implementation of the algorithm of the dungeon generator. In the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">last article,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we created the first room, and now we will generate the rest of the dungeon level. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But before we get started, I would like to fix a mistake from a previous post. In fact, in recent weeks I have learned something new, which is why some of the work I have done is outdated, and I want to talk about it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Remember the Position class we created? In fact, Unity already has a built-in class that performs exactly the same functions, but with slightly better control - it is easier to declare and process. This class is called Vector2Int. Therefore, before starting, we will remove the Position class from MapManager.cs and replace each Position variable with the Vector2Int variable.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/b7d/f40/656b7df4053976af99cbd2d359edd494.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The same thing needs to be done in several places in the DungeonGenerator.cs script. </font><font style="vertical-align: inherit;">Now let's get down to the rest of the algorithm.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stage 7 - room / hall generation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will start with a small change to the function FirstRoom () created last time. </font><font style="vertical-align: inherit;">Instead of creating another function to generate all the other elements of the map and duplicate a bunch of code, we simply transform this function, turning it into a generalized GenerateFeature (). </font><font style="vertical-align: inherit;">Therefore, change the name from FirstRoom to GenerateFeature. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we will need to pass parameters to this function. </font><font style="vertical-align: inherit;">First of all, you need to know what function it generates - a room or a corridor. </font><font style="vertical-align: inherit;">We can just pass a string called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Next, the function needs to know the starting point of the element, that is, from which wall it comes from (because we always create a new element from the wall of the older element), and for this, passing as the Wall argument is enough. </font><font style="vertical-align: inherit;">Finally, the first room to be created has special characteristics, so we need an optional bool variable that tells whether the item is the first room. </font><font style="vertical-align: inherit;">By default, it is false: bool isFirst = false. </font><font style="vertical-align: inherit;">So the function title will change from this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5f/b79/d17/e5fb79d178098b3bcde238ff733f9ca9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
on this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45e/124/afc/45e124afc4b4f60b12ab18deaa060719.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fine. </font><font style="vertical-align: inherit;">The next step is to change the way you calculate the width and height of the element. </font><font style="vertical-align: inherit;">While we calculate them, getting a random value between the min and max values ‚Äã‚Äãof the height and width of the rooms - this is ideal for rooms, but will not work for corridors. </font><font style="vertical-align: inherit;">So, so far we have the following:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f5/c0d/976/2f5c0d9765a596c2d2188b56b1f7b7ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But the corridors will have a constant size of 3 in width or height, depending on the orientation. </font><font style="vertical-align: inherit;">Therefore, we need to check what the element is - a room or a corridor, and then perform the appropriate calculations.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/071/163/df8/071163df82fc248fc92d370672369743.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So. </font><font style="vertical-align: inherit;">we check if the item is a room. </font><font style="vertical-align: inherit;">If yes, then we do the same as before </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - we get a random number in the interval between min and max of height and width. </font><font style="vertical-align: inherit;">But now in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else of</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the same if you need to do something a little different. </font><font style="vertical-align: inherit;">We need to check the orientation of the corridor. </font><font style="vertical-align: inherit;">Fortunately, when generating a wall, we save information about which direction it is directed, so we use it to get the orientation of the corridor.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91a/a84/328/91aa84328140d1414b8512843e1cd397.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But we have not yet declared the variable minCorridorLength. </font><font style="vertical-align: inherit;">You need to go back to variable declarations and declare it, right above maxCorridorLength.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/857/6e1/f138576e1dc1cb4a9949fd51e8c5fe47.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now back to our conditional switch statements. </font><font style="vertical-align: inherit;">What we are doing here: we get the value of the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direction of the</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wall, that is, where the wall is looking, from which the corridor will go. </font><font style="vertical-align: inherit;">Direction can have only four possible values: South, North, West and East. </font><font style="vertical-align: inherit;">In the case of South and North, the corridor will have a width of 3 (two walls and a floor in the middle) and a variable height (length). </font><font style="vertical-align: inherit;">For West and East, everything will be the other way around: the height will be constantly equal to 3, and the width will have a variable length. </font><font style="vertical-align: inherit;">So let's do it.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e2/175/8d6/0e21758d6d2e17406ce516c3fef6ccf5.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wow. </font><font style="vertical-align: inherit;">And that‚Äôs where we ended up with sizing the new item. </font><font style="vertical-align: inherit;">Now you need to decide where to put it. </font><font style="vertical-align: inherit;">We placed the first room in a random place within the threshold values ‚Äã‚Äãrelative to the center of the map.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fb/d53/010/6fbd5301066f6b0ba77ab90142370a5d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But for all other elements, this will not work. They should start next to the random point on the wall from which the element is generated. So let's change the code. First, we need to check if the element is the first room. If this is the first room, then we define the starting points in the same way as before - as half the width and height of the map.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d29/44d/ff3d2944da973a48200a6c9c3066d20d.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if the element is not the first room, then we get a random point on the wall from which the element is generated. First, we need to check if the wall has a size of 3 (this will mean that it is the end point of the corridor), and if so, then the middle point will always be selected, that is, index 1 of the wall array (with 3 elements, the array has indices 0, 1, 2). But if the size is not equal to 3 (the wall is not the end point of the corridor), then we take a random point in the interval between point 1 and the length of the wall minus 2. This is necessary to avoid passages created in the corner. That is, for example, on a wall with a length of 6, we exclude indexes 0 and 5 (first and last), and select a random point among points 1, 2, 3 and 4.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/4e1/703/ee24e1703c28b4cfa96e98d84a76c790.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we have the position of the point on the wall at which a new element will be created. But we cannot just start generating an element from there, because this way it will be blocked by already placed walls. It is also important to note that the element begins to be generated from its lower left corner, and then the increment is performed to the right and up, so we must set the initial position in different places, depending on the direction in which the wall is looking. In addition, the first column x and the first row y will be walls, and if we start a new element right next to a point on the wall, we can create a corridor ending in a corner of the room, and not in a suitable place on the wall.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, if the wall is directed to the north, then it is necessary that the element starts in one position to the north along the y axis, but in a random number of positions to the west along the x axis, in the range from 1 to the width of the room-2. </font><font style="vertical-align: inherit;">In the south direction, the x axis acts the same, but the starting position on the y axis is the position of the point on the wall minus the height of the room. </font><font style="vertical-align: inherit;">The western and eastern walls follow the same logic, only with inverted axes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But before doing all this, we need to save the position of the wall point in the Vector2Int variable so that we can manipulate it later.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/374/129/41a/37412941a3a58f32fd2dd38c1fc2c252.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Great. </font><font style="vertical-align: inherit;">Let's do that.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/2c7/ec0/1402c7ec0596d77f9a9b70b5eac076a9.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we generated an element with the size and position, and the next step is to place the element on the map. </font><font style="vertical-align: inherit;">But first, we need to find out if there really is space on the map for this element in this position. </font><font style="vertical-align: inherit;">For now, we just call the CheckIfHasSpace () function. </font><font style="vertical-align: inherit;">It will be highlighted in red, because we have not yet implemented it. </font><font style="vertical-align: inherit;">We will do this right after we finish what needs to be done here in the GenerateFeature () function. </font><font style="vertical-align: inherit;">Therefore, ignore the red underline and continue.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/805/942/b2080594237c23cae023cabb20b2d20e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the next part, walls are created. </font><font style="vertical-align: inherit;">Until we touch it, with the exception of the fragment in the second </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> loop </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/227/d7f/e2b/227d7fe2bf3c2eef41f423e36b4afc79.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
While writing this post, I noticed that these if-else constructs are completely wrong. For example, some walls in them will receive a length of 1. This happens because when the position is to be added, say, to the north wall, then if it was at the corner with the east wall, it will not be added to the east wall, as it should. This caused annoying bugs in the generation algorithm. Let's eliminate them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fixing them is pretty simple. It is enough to delete everything </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> so that the position passes through all the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> constructs </font><font style="vertical-align: inherit;">, and does not stop at the first if it returned </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Then the last </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (the one that is not </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) is changed to </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which checks that the position has already been added as Wall, and if it is not, adds it as Floor.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/784/834/65c784834461a2d8b05d1d39dd9ee44c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Amazing, we're almost done here. </font><font style="vertical-align: inherit;">Now we have a completely new element, created in the right place, but it is the same as our first room: it is completely enclosed by walls. </font><font style="vertical-align: inherit;">This means that the player will not be able to get to this new place. </font><font style="vertical-align: inherit;">That is, we need to convert a point on the wall (which, as we recall, is stored in a variable of type Vector2Int) and the corresponding point on the wall of a new element in Floor. </font><font style="vertical-align: inherit;">But only when the element is not the first room.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/350/67f/5ac/35067f5ac7db26fd304578b8dd53326c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This piece of code checks to see if the new item is the first room. </font><font style="vertical-align: inherit;">If not, it converts the last position of the wall to the floor, and then checks the direction the wall is looking in order to check which tile of the new element should turn into the floor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have reached the last part of the GenerateFeature () function. </font><font style="vertical-align: inherit;">It already has lines that add information about the element that the function creates.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fe/165/626/4fe165626aca42951f86568a4d6649c7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we need to change something. </font><font style="vertical-align: inherit;">Firstly, the element type is not always equal to Room. </font><font style="vertical-align: inherit;">Fortunately, the required variable is passed to the function as a parameter, namely the type string. </font><font style="vertical-align: inherit;">So let's just replace ‚ÄúRoom‚Äù here with type.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b57/d12/f17/b57d12f17802ec40e0c609d26803f661.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Good. </font><font style="vertical-align: inherit;">Now, for the algorithm generating all the elements of the game to work correctly, we need to add new data here. </font><font style="vertical-align: inherit;">Namely, an int that counts the number of items created and a list of all items created. </font><font style="vertical-align: inherit;">We go up to the place where we declare all the variables and declare an int with the name countFeatures, as well as a List of elements with the name allFeatures. </font><font style="vertical-align: inherit;">The list of all elements must be public, and the int counter can be private.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcb/ebf/8dd/bcbebf8ddbc768864ba70331317cc72c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now back to the GenerateFeature () function and add a few lines to the end: incrementing the countFeatures variable and adding a new element to the allFeatures list.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e6/8a8/496/5e68a8496d7047c87650a609acb912cf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, our GenerateFeature () is almost complete. </font><font style="vertical-align: inherit;">Later we will need to return to it to fill in the empty CheckIfHasSpace function, but first we need to create it. </font><font style="vertical-align: inherit;">That‚Äôs what we‚Äôll do now.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stage 8 - check if there is a place</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's create a new function right after the GenerateFeature () function completes. She needs two arguments: the position at which the element begins, and the position at which it ends. You can use two Vector2Int variables as them. The function should return a bool value so that it can be used in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to check for space.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/998/f03/cad/998f03cad9a6bd8a05bd7d8b9658bad6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is underlined in red, because so far it hasn‚Äôt returned anything. Soon we will fix it, but for now we will not pay attention. In this function, we will loop through all the positions between the beginning and the end of the element, and check whether the current position in MapManager.map is null or something is already there. If there is something there, then we stop the function and return false. If not, then continue. If the function reaches the end of the loop without meeting the filled places, then return true. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, before checking the position for null, we need a line to check whether the position is within the map. Because otherwise, we may get an array index error and a game crash.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/473/582/a5b/473582a5b560d6738de08b2f6190cf6b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fine. </font><font style="vertical-align: inherit;">Now back to the place where we insert this function inside the GenerateFeature () function. </font><font style="vertical-align: inherit;">We need to fix this call because it does not pass the necessary arguments. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we want to insert an </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if statement</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to check if there is enough space for the element. </font><font style="vertical-align: inherit;">If the result is false, then we end the function without inserting a new element into MapManager.map.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/068/661/e53/068661e533ef21536a51f17ae3de570b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We need to pass the required arguments, that is, two Vector2Int variables. </font><font style="vertical-align: inherit;">With the first, everything is simple, this is the position with the x and y coordinates of the element's start point.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c1/869/26d/0c186926d741d2423c791500adbed2cd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second is harder, but not by much. </font><font style="vertical-align: inherit;">This is the starting point plus height for y and width for x, subtracting 1 from both (because the start has already been taken into account).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a18/f85/4a9/a18f854a9e0a0bbe5883012bf2e313ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's move on to the next step - creating an algorithm to call the GenerateFeature () function.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stage 9 - call generated elements</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Back to the GenerateDungeon () function created in the previous part of the article. </font><font style="vertical-align: inherit;">Now it should look like this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/57c/5e3/3e957c5e316f5329e935353e961df47b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The call to FirstRoom () is underlined in red because we changed the name of this function. </font><font style="vertical-align: inherit;">So let's just call the first room generation.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d6/926/908/8d692690826997750f3bc860ae9216f0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We passed the necessary arguments: ‚ÄúRoom‚Äù as type, because the first room will always be Room, new Wall (), because the first room will not be created from any other, so we just pass null, and this is quite normal. Instead of new Wall (), you can substitute </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , this is a matter of personal preference. The last argument determines whether the new element is the first room, so in our case we pass </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we come to the main point. We use a for loop that will run 500 times - yes, we will try to add elements 500 times. But if the number of created elements (countFeatures variable) is equal to the maximum specified number of elements (maxFeatures variable), then we interrupt this cycle.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e6/410/ded/9e6410ded47210776fcda40ae2492229.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first step in this loop is to declare the element from which the new element will be created. </font><font style="vertical-align: inherit;">If we have created only one element (the first room), then it will be the original one. </font><font style="vertical-align: inherit;">Otherwise, we randomly select one of the already created elements.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddb/e84/f92/ddbe84f92cbb06f56e3ccce561dde991.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we will choose which wall of this element will be used to create the new element.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/e7c/0e4/7ade7c0e438985098eed6f5dbdd42e6d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Please note that we do not have this ChoseWall () function yet. </font><font style="vertical-align: inherit;">Let's write it quickly. </font><font style="vertical-align: inherit;">Go down to the end of the function and create it. </font><font style="vertical-align: inherit;">It should return a wall, and use an element as an argument, so that the function can select the wall of this element.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aeb/631/9f1/aeb6319f1ee6f601474d0aa0e32e2c77.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I created it between the CheckIfHasSpace () and DrawMap () functions. </font><font style="vertical-align: inherit;">Note that if you are working in Visual Studio, which is installed with Unity, you can use the - / + fields on the left to collapse / expand parts of the code to simplify the work. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this function we will find the wall from which the element has not yet been created. </font><font style="vertical-align: inherit;">Sometimes we will get elements with one or more walls of which other elements are already attached, so we need to check again and again whether any of the random walls is free. </font><font style="vertical-align: inherit;">To do this, we use a for loop repeated ten times - if after these ten times a free wall is not found, then the function returns null.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/44a/028/b1044a028bf9ab566a0120690311396d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now back to the GenerateDungeon () function and pass the original element as a parameter to the ChoseWall () function.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/281/8aa/0a32818aafc77ddd87f1ffac21b6981e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The line </font></font><code>if (wall == null) continue;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">means that if the wall search function returned false, then the original element cannot generate a new element, therefore the function will </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continue the</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cycle, that is, it could not create a new element and proceeds to the next iteration of the cycle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we need to select the type for the next item. </font><font style="vertical-align: inherit;">If the source element is a room, then the next one must be a corridor (we do not want the room to lead directly to another room without a corridor between them). </font><font style="vertical-align: inherit;">But if this is a corridor, then we need to create the likelihood that another corridor or room will be next.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b22/df0/954/b22df0954bbe21d82506d42e5118a70f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fine. </font><font style="vertical-align: inherit;">Now we just need to call the GenerateFeature () function, passing it the wall and type as parameters.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a07/90b/834/a0790b83479f46dc17c57fbb981aef81.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, go to the Unity inspector, select the GameManager object and change the values ‚Äã‚Äãto the following:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cc/09c/786/9cc09c786641bf85a89674cc33042ebf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you now click on the play button, then you will already see the results!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As I said, this is not the best dungeon. </font><font style="vertical-align: inherit;">We got a lot of dead ends. </font><font style="vertical-align: inherit;">But it is fully functional, and it guarantees that you will not have a room that is not connected to any other. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I hope you enjoyed it! </font><font style="vertical-align: inherit;">In the next post, we will create a player who will move through the dungeon, and then we will turn the map from ASCII into sprite.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.UI;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Post3</span> : <span class="hljs-title">MonoBehaviour</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapWidth;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapHeight;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMaxRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMaxRoom;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> minCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxFeatures;
    <span class="hljs-keyword">int</span> countFeatures;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isASCII;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> List&lt;Feature&gt; allFeatures;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        MapManager.map = <span class="hljs-keyword">new</span> Tile[mapWidth, mapHeight];<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GenerateDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        GenerateFeature(<span class="hljs-string">"Room"</span>, <span class="hljs-keyword">new</span> Wall(), <span class="hljs-literal">true</span>);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) {<font></font>
            Feature originFeature;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (allFeatures.Count == <span class="hljs-number">1</span>) {<font></font>
                originFeature = allFeatures[<span class="hljs-number">0</span>];<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {<font></font>
                originFeature = allFeatures[Random.Range(<span class="hljs-number">0</span>, allFeatures.Count - <span class="hljs-number">1</span>)];<font></font>
            }<font></font>
<font></font>
            Wall wall = ChoseWall(originFeature);<font></font>
            <span class="hljs-keyword">if</span> (wall == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
            <span class="hljs-keyword">string</span> type;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (originFeature.type == <span class="hljs-string">"Room"</span>) {<font></font>
                type = <span class="hljs-string">"Corridor"</span>;<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) &lt; <span class="hljs-number">90</span>) {<font></font>
                    type = <span class="hljs-string">"Room"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                    type = <span class="hljs-string">"Corridor"</span>;<font></font>
                }<font></font>
            }<font></font>
<font></font>
            GenerateFeature(type, wall);<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (countFeatures &gt;= maxFeatures) <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
<font></font>
        DrawMap(isASCII);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GenerateFeature</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> type, Wall wall, <span class="hljs-keyword">bool</span> isFirst = <span class="hljs-literal">false</span></span>)</span> {<font></font>
        Feature room = <span class="hljs-keyword">new</span> Feature();<font></font>
        room.positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
<font></font>
        <span class="hljs-keyword">int</span> roomWidth = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> roomHeight = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) {<font></font>
            roomWidth = Random.Range(widthMinRoom, widthMaxRoom);<font></font>
            roomHeight = Random.Range(heightMinRoom, heightMaxRoom);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">int</span> xStartingPoint;
        <span class="hljs-keyword">int</span> yStartingPoint;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint = mapWidth / <span class="hljs-number">2</span>;<font></font>
            yStartingPoint = mapHeight / <span class="hljs-number">2</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">int</span> id;
            <span class="hljs-keyword">if</span> (wall.positions.Count == <span class="hljs-number">3</span>) id = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> id = Random.Range(<span class="hljs-number">1</span>, wall.positions.Count - <span class="hljs-number">2</span>);<font></font>
<font></font>
            xStartingPoint = wall.positions[id].x;<font></font>
            yStartingPoint = wall.positions[id].y;<font></font>
        }<font></font>
<font></font>
        Vector2Int lastWallPosition = <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth);<font></font>
            yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint ++;<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    xStartingPoint -= roomWidth;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    xStartingPoint++;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
         <span class="hljs-keyword">if</span> (!CheckIfHasSpace(<span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint), <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint + roomWidth - <span class="hljs-number">1</span>, yStartingPoint + roomHeight - <span class="hljs-number">1</span>))) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        room.walls = <span class="hljs-keyword">new</span> Wall[<span class="hljs-number">4</span>];<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; room.walls.Length; i++) {<font></font>
            room.walls[i] = <span class="hljs-keyword">new</span> Wall();<font></font>
            room.walls[i].positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
            room.walls[i].length = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">switch</span> (i) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"South"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"North"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"West"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"East"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; roomHeight; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; roomWidth; x++) {<font></font>
                Vector2Int position = <span class="hljs-keyword">new</span> Vector2Int();<font></font>
                position.x = xStartingPoint + x;<font></font>
                position.y = yStartingPoint + y;<font></font>
<font></font>
                room.positions.Add(position);<font></font>
<font></font>
                MapManager.map[position.x, position.y] = <span class="hljs-keyword">new</span> Tile();<font></font>
                MapManager.map[position.x, position.y].xPosition = position.x;<font></font>
                MapManager.map[position.x, position.y].yPosition = position.y;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">0</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">0</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (y == (roomHeight - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">1</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">1</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">2</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">2</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == (roomWidth - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">3</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">3</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (MapManager.map[position.x, position.y].type != <span class="hljs-string">"Wall"</span>) {<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Floor"</span>;<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!isFirst) {<font></font>
            MapManager.map[lastWallPosition.x, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y - <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y + <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    MapManager.map[lastWallPosition.x - <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    MapManager.map[lastWallPosition.x + <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        room.width = roomWidth;<font></font>
        room.height = roomHeight;<font></font>
        room.type = type;<font></font>
        allFeatures.Add(room);<font></font>
        countFeatures++;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckIfHasSpace</span>(<span class="hljs-params">Vector2Int start, Vector2Int end</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = start.y; y &lt;= end.y; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = start.x; x &lt;= end.x; x++) {
                <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= mapWidth || y &gt;= mapHeight) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">if</span> (MapManager.map != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">Wall <span class="hljs-title">ChoseWall</span>(<span class="hljs-params">Feature feature</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            <span class="hljs-keyword">int</span> id = Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) / <span class="hljs-number">25</span>;
            <span class="hljs-keyword">if</span> (!feature.walls[id].hasFeature) {
                <span class="hljs-keyword">return</span> feature.walls[id];<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawMap</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> isASCII</span>)</span> {
        <span class="hljs-keyword">if</span> (isASCII) {<font></font>
            Text screen = GameObject.Find(<span class="hljs-string">"ASCIITest"</span>).GetComponent&lt;Text&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">string</span> asciiMap = <span class="hljs-string">""</span>;<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = (mapHeight - <span class="hljs-number">1</span>); y &gt;= <span class="hljs-number">0</span>; y--) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; mapWidth; x++) {
                    <span class="hljs-keyword">if</span> (MapManager.map[x, y] != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">switch</span> (MapManager.map[x, y].type) {
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Wall"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"#"</span>;
                                <span class="hljs-keyword">break</span>;
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Floor"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"."</span>;
                                <span class="hljs-keyword">break</span>;<font></font>
                        }<font></font>
                    }<font></font>
                    <span class="hljs-keyword">else</span> {<font></font>
                        asciiMap += <span class="hljs-string">" "</span>;<font></font>
                    }<font></font>
<font></font>
                    <span class="hljs-keyword">if</span> (x == (mapWidth - <span class="hljs-number">1</span>)) {<font></font>
                        asciiMap += <span class="hljs-string">"\n"</span>;<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
<font></font>
            screen.text = asciiMap;<font></font>
        }<font></font>
    }<font></font>
}</code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en495570/index.html">Depth of rabbit hole or C ++ interview at PVS-Studio</a></li>
<li><a href="../en495572/index.html">Hardware Ecosystem Community Launches Podcast for Everyone in the Electronics Industry</a></li>
<li><a href="../en495574/index.html">Visitor Detection and Counting: Cloud vs. camera counter</a></li>
<li><a href="../en495576/index.html">Self-propelled platform on the esp8266 MK with micropython</a></li>
<li><a href="../en495580/index.html">Cucumber JVM - Not Just BDD</a></li>
<li><a href="../en495592/index.html">How to use dictionaries (and not only)</a></li>
<li><a href="../en495594/index.html">Start making money on software: creating mini-digital-business</a></li>
<li><a href="../en495596/index.html">Remote work in the office. RDP, Port Knocking, Mikrotik: simple and safe</a></li>
<li><a href="../en495602/index.html">Starting with Core Data! Difficult in simple words [Part 2]</a></li>
<li><a href="../en495604/index.html">Temporary localization on Symfony 4 + Twig</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>