<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî® üßúüèæ ‚ÄºÔ∏è Reibungslose Sortierung üë©üèæ‚Äçü§ù‚Äçüë©üèª üò∑ üéº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir tauchen weiterhin in eine Vielzahl von Haufen ein. 
 
 Heute analysieren wir eine elegante Bestellmethode, bei der spezielle Haufen basierend auf ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Reibungslose Sortierung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/496852/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img align="left" width="350" height="350" src="https://habrastorage.org/webt/rn/rl/bg/rnrlbgzncwdiackzlubtakt02u0.jpeg"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir tauchen weiterhin in eine Vielzahl von Haufen ein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heute analysieren wir eine elegante Bestellmethode, bei der spezielle Haufen basierend auf den Zahlen von Leonardo verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele haben von dieser Sortierung geh√∂rt, aber nur wenige wissen genau, wie sie funktioniert. Heute werden wir sehen, dass nichts kompliziert ist. </font><font style="vertical-align: inherit;">
Die Methode wurde von der legend√§ren Edsger Dijkstra erfunden. Neben den vielen hellsten Errungenschaften in der Theorie der Algorithmen ist er auch der Autor einer solch witzigen Aussage: </font><i><font style="vertical-align: inherit;">‚ÄûStudenten, die zuvor Basic studiert haben, ist es fast unm√∂glich, gute Programmierung zu unterrichten. Als potenzielle Programmierer haben sie eine irreversible geistige Verschlechterung erfahren. ‚Äú</font></i><font style="vertical-align: inherit;"> 
Ich hoffe, es ist keine Gottesl√§sterung, dass die Animation im Artikel mit VBA erstellt wurde :-)</font></font><br>
<br>
<img width="750" height="1" src="https://habrastorage.org/webt/63/4u/g_/634ug_fmfdzyhgeg6ta-ddcdpau.gif"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img align="right" width="195" height="280" src="https://habrastorage.org/webt/fq/vt/v1/fqvtv1xelqwwshwtuxa3frztsle.jpeg"></a><br clear="left"><font style="vertical-align: inherit;"></font><br>
<br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="EDISON Software - Webentwicklung"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - Webentwicklung"></a><br clear="right">
     EDISON.<br>
<br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    </a>,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   Android  iOS</a>.<br>
<br>
    ! ;-)</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Heap-Sortierung an sich ist sehr gut, da ihre zeitliche Komplexit√§t </font><font style="vertical-align: inherit;">unabh√§ngig von den Daten </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> betr√§gt </font><font style="vertical-align: inherit;">. Um kein Array darzustellen, verschlechtert sich die Komplexit√§t von Heapsort niemals auf </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></b><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , was beispielsweise bei einer schnellen Sortierung passieren kann. Die Kehrseite der Medaille ist, dass das Sortieren nach einem bin√§ren Haufen nicht beschleunigt werden kann, </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Komplexit√§t </font><font style="vertical-align: inherit;">auch nicht erwartet werden kann (aber das gleiche schnelle Sortieren kann unter bestimmten Bedingungen solche Indikatoren erreichen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen stand eine Frage auf der Tagesordnung: Ist es m√∂glich, so zu erfinden, dass die zeitliche Komplexit√§t des Sortierens nach einem Haufen einerseits nicht geringer ist als</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber in einem g√ºnstigen Szenario (insbesondere wenn ein fast sortiertes Array verarbeitet wird) auf </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erh√∂ht </font><font style="vertical-align: inherit;">? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Problem wurde von Edsger Dijkstra pers√∂nlich angesprochen, der herausfand, dass dies m√∂glich ist. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird davon ausgegangen, dass diejenigen, die diesen Artikel lesen, verstehen, wie das Sortieren nach Heap im Allgemeinen funktioniert. Sie wissen, was Sortierbaum ist und warum ein Sieben erforderlich ist. </font><font style="vertical-align: inherit;">Wenn jemand L√ºcken in diesem Wissen hat, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">empfehle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ich </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Ihnen, den vorherigen Artikel zu lesen</font></a><font style="vertical-align: inherit;"> , bevor </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Sie mit dem Lesen</font></a><font style="vertical-align: inherit;"> fortfahren </font><font style="vertical-align: inherit;">.</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist los mit einem bin√§ren Heap?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns einen Blick darauf werfen, wie Heapsort ein fast geordnetes Array sortiert und warum dieser Algorithmus solche eingehenden Daten nicht schneller verarbeitet.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><div style="text-align:center;"><img width="646" height="303" src="https://habrastorage.org/webt/mr/x_/g9/mrx_g9exydmumk4rh-efffgvw_u.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klicken Sie auf die Animation, um zum Artikel ‚ÄûSortieren nach der n-Pyramide‚Äú zu gelangen.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Das erste, was Ihnen auff√§llt, ist, dass beim Sieben die Maxima st√§ndig an die Wurzel des Heaps verschoben werden, die dem ersten Element des Arrays entspricht. Wenn das Eingabearray fast geordnet ist, bedeutet dies f√ºr den Algorithmus nur wenig Arbeit. Kleinere Elemente werden immer noch zuerst den Baum hinuntergehen, d. H. Gehen Sie n√§her an das Ende des Arrays heran, nicht an den Anfang.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite Verlangsamungsfaktor, der nicht so offensichtlich ist, ist, dass der Standard-Bin√§rheap selbst immer ein ausgeglichener Baum ist. </font><font style="vertical-align: inherit;">Bei urspr√ºnglich bestellten Daten spielt dies eine negative Rolle. </font><font style="vertical-align: inherit;">Wenn das urspr√ºngliche Array zuf√§llige Daten enth√§lt, werden diese gleichm√§√üig in einem ausgeglichenen Baum verteilt, und das mehrfache Sieben durchl√§uft alle Zweige ungef√§hr gleich oft. </font><font style="vertical-align: inherit;">Bei fast geordneten Daten ist ein unausgeglichener Baum vorzuziehen. In diesem Fall werden die Daten in dem Teil des Arrays, der l√§ngeren Zweigen des Baums entspricht, seltener verarbeitet als in anderen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leonardo-Nummern</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um beide Probleme zu l√∂sen, schlug Dijkstra vor, spezielle bin√§re Haufen zu verwenden, die auf Leonardo-Zahlen basieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leonardo-Zahlen sind fast wie Fibonacci-Zahlen, aber nur besser. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Reihe von Leonardo-Zahlen wird rekursiv angegeben: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten 20 Leonardo-Zahlen: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1, 1, 3, 5, 9, 15, 25, 41, 67 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, 13529 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Absolut jede ganze Zahl kann als die Summe von Leonardo-Zahlen mit unterschiedlichen Seriennummern dargestellt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist in unserem Fall sehr n√ºtzlich. Array von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elemente k√∂nnen nicht immer als ein einzelner Haufen von Leonardo dargestellt werden (wenn </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keine Leonardo-Zahl ist). </font><font style="vertical-align: inherit;">Aber dann kann jedes Array immer in mehrere Subarrays unterteilt werden, die einer unterschiedlichen Anzahl von Leonardo entsprechen, d. H. </font><font style="vertical-align: inherit;">Haufen unterschiedlicher Ordnung sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Beispiel eines Arrays des 21. Elements, das aus drei Leonard-Haufen besteht. </font><font style="vertical-align: inherit;">In jedem der Haufen entspricht die Anzahl der Knoten einer beliebigen Anzahl von Leonardo.</font></font><br>
<br>
<div style="text-align:center;"><img width="760" height="369" src="https://habrastorage.org/webt/-9/w7/1b/-9w71bwg0hst69nkbnewpiyku9m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wichtige Punkte zu wissen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeder Leonardov-Stapel ist ein unausgeglichener Bin√§rbaum.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wurzel jedes Heaps ist das letzte (und nicht das erste, wie in einem regul√§ren bin√§ren Heap) Element des entsprechenden Subarrays.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeder Knoten mit all seinen Nachkommen ist auch ein Leonard-Haufen kleinerer Ordnung.</font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haufen bauen und abbauen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Wiederholungsformel f√ºr Leonardo-Zahlen ist </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sehr zufrieden mit der Einheit am Ende. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und deshalb. Angenommen, wir haben zwei benachbarte Subarrays im Array, die Heaps entsprechen, die auf zwei benachbarten Leonardo-Zahlen aufgebaut sind. Mit dem Element unmittelbar nach diesen Subarrays k√∂nnen diese Subarrays zu einem gemeinsamen Heap kombiniert werden, der der n√§chsten Leonard-Nummer entspricht.</font></font><br>
<br>
<div style="text-align:center;"><img width="694" height="423" src="https://habrastorage.org/webt/ds/jv/5b/dsjv5bfc0ao4k9d-frevjzg3wee.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gehen die Elemente im Array durch und bauen eine Reihe von Leonard-Haufen. Wenn Sie das Element verwenden, k√∂nnen Sie die beiden vorherigen Heaps kombinieren (dies ist nur dann m√∂glich, wenn die beiden vorherigen Heaps zwei aufeinander folgenden Leonardo-Zahlen entsprechen), und dann kombinieren. Wenn eine Kombination nicht m√∂glich ist (die beiden vorherigen Heaps entsprechen nicht zwei aufeinanderfolgenden Leonardo-Nummern), bildet das aktuelle Element einfach einen neuen Heap eines Elements, das der ersten (oder zweiten, wenn die erste zuvor verwendet wird) Leonardo-Nummer entspricht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der zweiten Stufe des Algorithmus erfolgt der umgekehrte Prozess - wir analysieren die Haufen. Wenn wir die Wurzel im Heap entfernen, erhalten wir zwei kleinere Heaps, die den beiden vorherigen Leonardo-Zahlen entsprechen. Dies kann geschehen, weil: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 1 = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In Fibonacci-Zahlen gibt es keine solche n√ºtzliche Einheit, daher verwenden wir den Fibonacci-Heap nicht.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Smooth Sort :: Smoothsort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der endg√ºltige Algorithmus:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I. Erstellen Sie eine Reihe von Leonard-Haufen aus dem Array, von denen jeder ein Sortierbaum ist.</font></font></b><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I.1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durchlaufen Sie die Elemente des Arrays von links nach rechts.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberpr√ºfen Sie, ob das aktuelle Element die beiden am weitesten links liegenden Heaps im vorhandenen Heap von Leonard-Heaps kombinieren kann:</font></font><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1.a. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ja, dann kombinieren wir die beiden am weitesten links liegenden Heaps zu einem. Das aktuelle Element wird zur Wurzel dieses Heaps. Wir durchsuchen den kombinierten Heap.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1.b. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn nicht, f√ºgen Sie das aktuelle Element als neuen Heap (der bisher aus einem Knoten besteht) zum vorhandenen Heap von Leonard-Heaps hinzu.</font></font></li>
</ul></li>
</ul></li>
<li><b>II.      ,       :</b><ul>
<li><b>II.1.</b>     .          ,      .</li>
<li><b>II.2.</b>   (     )       (     ).</li>
<li><b>II.3.</b>    ,         .     .</li>
<li><b>II.4.</b>      (    ),          .</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.5. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem das maximale Element an das Ende verschoben wurde, nahm der sortierte Teil des Arrays zu und der unsortierte Teil ab. </font><font style="vertical-align: inherit;">Wiederholen Sie die Schritte II.1-II.4 f√ºr den verbleibenden unsortierten Teil des Arrays.</font></font></li>
</ul></li>
</ul><br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/wo/hc/ve/wohcve4fi78vdotmyfuw9pr2yyo.gif"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel f√ºr eine Python-Implementierung</font></font></h3><br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> random<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">smoothsort</span>(<span class="hljs-params">lst</span>):</span><font></font>
<font></font>
    <span class="hljs-comment">#    </span><font></font>
    leo_nums = leonardo_numbers(len(lst))<font></font>
<font></font>
<font></font>
    <span class="hljs-comment">#       </span><font></font>
    heap = []<font></font>
<font></font>
    <span class="hljs-comment">#   </span>
    <span class="hljs-comment">#       </span>
    <span class="hljs-comment">#       </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(lst)):
        <span class="hljs-keyword">if</span> len(heap) &gt;= <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> heap[<span class="hljs-number">-2</span>] == heap[<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>:<font></font>
            heap.pop()<font></font>
            heap[<span class="hljs-number">-1</span>] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> len(heap) &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> heap[<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>:<font></font>
                heap.append(<span class="hljs-number">0</span>)
            <span class="hljs-keyword">else</span>:<font></font>
                heap.append(<span class="hljs-number">1</span>)<font></font>
        restore_heap(lst, i, heap, leo_nums)<font></font>
<font></font>
    <span class="hljs-comment">#  </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> reversed(range(len(lst))):
        <span class="hljs-keyword">if</span> heap[<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">2</span>:<font></font>
            heap.pop()<font></font>
        <span class="hljs-keyword">else</span>:<font></font>
            k = heap.pop()<font></font>
            t_r, k_r, t_l, k_l = get_child_trees(i, k, leo_nums)<font></font>
            heap.append(k_l)<font></font>
            restore_heap(lst, t_l, heap, leo_nums)<font></font>
            heap.append(k_r)<font></font>
            restore_heap(lst, t_r, heap, leo_nums)<font></font>
<font></font>
<span class="hljs-comment">#   ,     </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leonardo_numbers</span>(<span class="hljs-params">hi</span>):</span><font></font>
<font></font>
    a, b = <span class="hljs-number">1</span>, <span class="hljs-number">1</span><font></font>
    numbers = []<font></font>
    <span class="hljs-keyword">while</span> a &lt;= hi:<font></font>
        numbers.append(a)<font></font>
        a, b = b, a + b + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> numbers<font></font>
<font></font>
<span class="hljs-comment">#        </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">restore_heap</span>(<span class="hljs-params">lst, i, heap, leo_nums</span>):</span><font></font>
    <font></font>
    <span class="hljs-comment">#      </span><font></font>
    <font></font>
    current = len(heap) - <span class="hljs-number">1</span><font></font>
    k = heap[current]<font></font>
<font></font>
    <span class="hljs-keyword">while</span> current &gt; <span class="hljs-number">0</span>:<font></font>
        j = i - leo_nums[k]<font></font>
        <span class="hljs-keyword">if</span> (lst[j] &gt; lst[i] <span class="hljs-keyword">and</span>
            (k &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> lst[j] &gt; lst[i<span class="hljs-number">-1</span>] <span class="hljs-keyword">and</span> lst[j] &gt; lst[i<span class="hljs-number">-2</span>])):<font></font>
            lst[i], lst[j] = lst[j], lst[i]<font></font>
            i = j<font></font>
            current -= <span class="hljs-number">1</span><font></font>
            k = heap[current]<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span><font></font>
<font></font>
    <span class="hljs-comment"># </span><font></font>
    <font></font>
    <span class="hljs-keyword">while</span> k &gt;= <span class="hljs-number">2</span>:<font></font>
        t_r, k_r, t_l, k_l = get_child_trees(i, k, leo_nums)<font></font>
        <span class="hljs-keyword">if</span> lst[i] &lt; lst[t_r] <span class="hljs-keyword">or</span> lst[i] &lt; lst[t_l]:
            <span class="hljs-keyword">if</span> lst[t_r] &gt; lst[t_l]:<font></font>
                lst[i], lst[t_r] = lst[t_r], lst[i]<font></font>
                i, k = t_r, k_r<font></font>
            <span class="hljs-keyword">else</span>:<font></font>
                lst[i], lst[t_l] = lst[t_l], lst[i]<font></font>
                i, k = t_l, k_l<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span><font></font>
<font></font>
<span class="hljs-comment">#         ,</span>
<span class="hljs-comment">#     </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_child_trees</span>(<span class="hljs-params">i, k, leo_nums</span>):</span><font></font>
<font></font>
    t_r, k_r = i - <span class="hljs-number">1</span>, k - <span class="hljs-number">2</span>
    t_l, k_l = t_r - leo_nums[k_r], k - <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> t_r, k_r, t_l, k_l<font></font>
<font></font>
<span class="hljs-comment">#  </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">n</span>):</span><font></font>
    lst = list(range(n))<font></font>
    random.shuffle(lst)<font></font>
    print(lst)<font></font>
    smoothsort(lst)<font></font>
    print(lst)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitliche Komplexit√§t</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir ein fast geordnetes Array als Eingabe nehmen, zeigt die Visualisierung, warum ein solches Array viel schneller verarbeitet wird.</font></font><br>
<br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/x1/g1/kg/x1g1kglflod3zdnc2vuiqumjoyy.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einsparungen entstehen nur durch Sieben. In fast geordneten Daten sinkt das Sieben flach in den Baum, auch nachdem sich die Haufen in der zweiten Stufe allm√§hlich aufgel√∂st haben. In den anf√§nglich zuf√§lligen Daten ist das Sieben teurer, da es oft in seinem Haufen auf die allerletzte Ebene f√§llt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns die Gesamtzeitkomplexit√§t sch√§tzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der ersten Phase iterieren wir √ºber n Elemente und f√ºgen sie den bereits links vorhandenen Heaps hinzu. Das Hinzuf√ºgen zum Heap selbst kostet ungef√§hr in O (1), aber f√ºr den Heap m√ºssen Sie einen Siebvorgang durchf√ºhren. In geordneten Daten kostet ein flaches Sieben h√§ufig O (1) f√ºr ein Element, das dem Heap hinzugef√ºgt wird. Bei ungeordneten Daten wird das Sieben f√ºr jede Addition in </font><nobr><font style="vertical-align: inherit;">O (log </font></nobr><nobr><b><font style="vertical-align: inherit;">n</font></b></nobr><nobr><font style="vertical-align: inherit;"> )</font></nobr><font style="vertical-align: inherit;"> berechnet.</font></font><nobr><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da das Sieben aufgrund von Zuf√§lligkeiten oft bis zum Grund durch die Ebenen des Baumes gehen muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher ist in der ersten Stufe die beste Zeitkomplexit√§t: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
f√ºr fast geordnete Daten - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
f√ºr zuf√§llige Daten - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr die zweite Stufe ist die Situation √§hnlich. Wenn Sie das n√§chste Maximum austauschen, m√ºssen Sie den Heap, an dessen Wurzel er sich befand, erneut sieben. Und die Siebmetriken f√ºr geordnete und ungeordnete Daten sind unterschiedlich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der zweiten Stufe ist die beste Zeitkomplexit√§t dieselbe wie in der ersten: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
f√ºr fast geordnete Daten - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
f√ºr zuf√§llige Daten - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinzuf√ºgen von Zeitkomplexit√§t f√ºr die erste und zweite Stufe: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
f√ºr fast geordnete Daten - O (2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
f√ºr zuf√§llige Daten - O (2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen ist die schlechteste und durchschnittliche Zeitkomplexit√§t f√ºr eine reibungslose Sortierung O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dijkstra hat in seinen Berechnungen (mit denen ich Sie nicht langweilen werde) bewiesen, dass die beste Komplexit√§t </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reibungslos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tendiert, </font><font style="vertical-align: inherit;">je geordneter die eingehenden Daten sind. </font><font style="vertical-align: inherit;">Daher der Name - reibungslose Sortierung.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zus√§tzliche Speicherkomplexit√§t</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Daten in eine Reihe von Leonard-Haufen zu zerlegen, m√ºssen Sie sich nur genau merken, welche Leonardo-Nummern bei jedem Schritt beteiligt sind. </font><font style="vertical-align: inherit;">Wenn man diese Zahlen kennt, werden die Haufen selbst algorithmisch ausgerichtet. </font><font style="vertical-align: inherit;">Diese Zahlenreihe w√§chst sehr schnell, sodass Sie selbst f√ºr gro√üe Arrays einen sehr kleinen Satz von Leonard-Zahlen ben√∂tigen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomial-Heap-Sortierung :: Binomial-Heap-Sortierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt eine Baumstruktur, die der von uns aussortierten sehr √§hnlich ist - einen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomialhaufen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies ist auch eine Reihe von Haufen unterschiedlicher Gr√∂√üe, bei denen die Anzahl der Knoten jeweils eine Zweierpotenz ist. </font><font style="vertical-align: inherit;">Jedes Array mit einer beliebigen Anzahl von Elementen kann in diesen Heap erweitert werden, da jede nat√ºrliche Anzahl in die Summe von zwei verschiedenen Graden zerlegt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Prinzip k√∂nnen Sie eine reibungslose Sortierung basierend auf Binomen durchf√ºhren:</font></font><br>
<br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/rw/p9/0y/rwp90yy_ub8vvvk2uczfoa4db8y.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wird es schneller funktionieren? </font><font style="vertical-align: inherit;">Kaum. </font><font style="vertical-align: inherit;">Der Binomialheap ist nicht bin√§r, und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im letzten Artikel haben wir herausgefunden, dass das Erh√∂hen der Anzahl der Nachkommen nicht beschleunigt, sondern den Bildschirm verlangsamt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Au√üerdem k√∂nnen Sie feststellen, dass der Binomialheap l√§ngere Verzweigungen aufweist, weshalb benachbarte geordnete Bereiche des Arrays etwas langsamer miteinander verbunden sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist nicht bekannt, ob der Dijkstra-Binomialhaufen allgemein als m√∂gliche Grundlage f√ºr seinen Algorithmus angesehen wurde. </font><font style="vertical-align: inherit;">Wie dem auch sei, der Leonardov-Haufen ist wahrscheinlich optimaler.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trailer der n√§chsten Serie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst wenn ein Binomialstapel nicht die beste Option f√ºr eine reibungslose Sortierung ist, sollten Sie ihn nicht vollst√§ndig verwerfen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Binomialbaum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leicht modifiziert ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und v√∂llig andere (sehr k√ºhne) Ideen verwendet werden, um ihn zu umgehen, erhalten wir einen originellen und effektiven Algorithmus, der seine eigenen Vorteile hat. </font><font style="vertical-align: inherit;">Wor√ºber werden wir das n√§chste Mal sprechen?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/1l/ay/j-/1layj-xmzm4dl7p5yv7_5iag5pa.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klicken Sie auf die Animation, um zum Artikel mit der n√§chsten Sortierung nach Heap zu gelangen.</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die glatte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glatte </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leonardo-Zahl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomialhaufen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomialhaufen</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serienartikel:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excel-Anwendung AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sorte austauschen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einf√ºgungssortierungen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Auswahl sortieren</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: N-Pyramiden</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Leonardo Numbers</font></font></b></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap-Sortierung: schwacher Heap</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B√ºndelsorten: Kartesischer Baum</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Heap-Sortierungen: Spiegelhaufen, Mini-Heap, Sieben von unten nach oben</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Jung Heap</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sortierungen zusammenf√ºhren</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Verteilung sortieren</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hybridsortierung</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die heutige reibungslose Sortierung wurde der AlgoLab-App hinzugef√ºgt. </font><font style="vertical-align: inherit;">Sowie einen Bonus - und das Sortieren mit einem Binomialstapel. </font><font style="vertical-align: inherit;">Wer also die Daten auf den Heap-Heaps pers√∂nlich steuern m√∂chte, aktualisiert die Excel-Datei mit Makros.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de496840/index.html">Musk glaubt, dass 12.000 Satelliten die Astronomen nicht st√∂ren werden. Seine Meinung stimmt nicht mit dem Modell √ºberein</a></li>
<li><a href="../de496842/index.html">Ein einfaches Epidemiemodell mit grundlegenden Python-Tools</a></li>
<li><a href="../de496846/index.html">Sprachmechanik von Stapeln und Zeigern</a></li>
<li><a href="../de496848/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 340 (vom 6. bis 12. April)</a></li>
<li><a href="../de496850/index.html">Maven Plugin f√ºr JPackage aus Java 14</a></li>
<li><a href="../de496856/index.html">Smart Home ohne Fernbedienungen, aber mit einem W√ºrfel</a></li>
<li><a href="../de496858/index.html">FOSS News Nr. 11 - eine √úberpr√ºfung der freien und Open-Source-Software f√ºr den 6. bis 12. April 2020</a></li>
<li><a href="../de496860/index.html">Erster DI: Erster DI f√ºr Schnittstellen f√ºr Typoskriptanwendungen</a></li>
<li><a href="../de496862/index.html">Arduino Bubble Display</a></li>
<li><a href="../de496864/index.html">Audit Wallets in CryptoNote</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>