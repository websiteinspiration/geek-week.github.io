<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔨 🧜🏾 ‼️ Reibungslose Sortierung 👩🏾‍🤝‍👩🏻 😷 🎼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir tauchen weiterhin in eine Vielzahl von Haufen ein. 
 
 Heute analysieren wir eine elegante Bestellmethode, bei der spezielle Haufen basierend auf ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Reibungslose Sortierung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/496852/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img align="left" width="350" height="350" src="https://habrastorage.org/webt/rn/rl/bg/rnrlbgzncwdiackzlubtakt02u0.jpeg"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir tauchen weiterhin in eine Vielzahl von Haufen ein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heute analysieren wir eine elegante Bestellmethode, bei der spezielle Haufen basierend auf den Zahlen von Leonardo verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele haben von dieser Sortierung gehört, aber nur wenige wissen genau, wie sie funktioniert. Heute werden wir sehen, dass nichts kompliziert ist. </font><font style="vertical-align: inherit;">
Die Methode wurde von der legendären Edsger Dijkstra erfunden. Neben den vielen hellsten Errungenschaften in der Theorie der Algorithmen ist er auch der Autor einer solch witzigen Aussage: </font><i><font style="vertical-align: inherit;">„Studenten, die zuvor Basic studiert haben, ist es fast unmöglich, gute Programmierung zu unterrichten. Als potenzielle Programmierer haben sie eine irreversible geistige Verschlechterung erfahren. “</font></i><font style="vertical-align: inherit;"> 
Ich hoffe, es ist keine Gotteslästerung, dass die Animation im Artikel mit VBA erstellt wurde :-)</font></font><br>
<br>
<img width="750" height="1" src="https://habrastorage.org/webt/63/4u/g_/634ug_fmfdzyhgeg6ta-ddcdpau.gif"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img align="right" width="195" height="280" src="https://habrastorage.org/webt/fq/vt/v1/fqvtv1xelqwwshwtuxa3frztsle.jpeg"></a><br clear="left"><font style="vertical-align: inherit;"></font><br>
<br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="EDISON Software - Webentwicklung"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - Webentwicklung"></a><br clear="right">
     EDISON.<br>
<br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    </a>,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   Android  iOS</a>.<br>
<br>
    ! ;-)</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Heap-Sortierung an sich ist sehr gut, da ihre zeitliche Komplexität </font><font style="vertical-align: inherit;">unabhängig von den Daten </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beträgt </font><font style="vertical-align: inherit;">. Um kein Array darzustellen, verschlechtert sich die Komplexität von Heapsort niemals auf </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></b><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , was beispielsweise bei einer schnellen Sortierung passieren kann. Die Kehrseite der Medaille ist, dass das Sortieren nach einem binären Haufen nicht beschleunigt werden kann, </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Komplexität </font><font style="vertical-align: inherit;">auch nicht erwartet werden kann (aber das gleiche schnelle Sortieren kann unter bestimmten Bedingungen solche Indikatoren erreichen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen stand eine Frage auf der Tagesordnung: Ist es möglich, so zu erfinden, dass die zeitliche Komplexität des Sortierens nach einem Haufen einerseits nicht geringer ist als</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber in einem günstigen Szenario (insbesondere wenn ein fast sortiertes Array verarbeitet wird) auf </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erhöht </font><font style="vertical-align: inherit;">? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Problem wurde von Edsger Dijkstra persönlich angesprochen, der herausfand, dass dies möglich ist. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird davon ausgegangen, dass diejenigen, die diesen Artikel lesen, verstehen, wie das Sortieren nach Heap im Allgemeinen funktioniert. Sie wissen, was Sortierbaum ist und warum ein Sieben erforderlich ist. </font><font style="vertical-align: inherit;">Wenn jemand Lücken in diesem Wissen hat, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">empfehle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ich </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Ihnen, den vorherigen Artikel zu lesen</font></a><font style="vertical-align: inherit;"> , bevor </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Sie mit dem Lesen</font></a><font style="vertical-align: inherit;"> fortfahren </font><font style="vertical-align: inherit;">.</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist los mit einem binären Heap?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns einen Blick darauf werfen, wie Heapsort ein fast geordnetes Array sortiert und warum dieser Algorithmus solche eingehenden Daten nicht schneller verarbeitet.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><div style="text-align:center;"><img width="646" height="303" src="https://habrastorage.org/webt/mr/x_/g9/mrx_g9exydmumk4rh-efffgvw_u.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klicken Sie auf die Animation, um zum Artikel „Sortieren nach der n-Pyramide“ zu gelangen.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Das erste, was Ihnen auffällt, ist, dass beim Sieben die Maxima ständig an die Wurzel des Heaps verschoben werden, die dem ersten Element des Arrays entspricht. Wenn das Eingabearray fast geordnet ist, bedeutet dies für den Algorithmus nur wenig Arbeit. Kleinere Elemente werden immer noch zuerst den Baum hinuntergehen, d. H. Gehen Sie näher an das Ende des Arrays heran, nicht an den Anfang.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite Verlangsamungsfaktor, der nicht so offensichtlich ist, ist, dass der Standard-Binärheap selbst immer ein ausgeglichener Baum ist. </font><font style="vertical-align: inherit;">Bei ursprünglich bestellten Daten spielt dies eine negative Rolle. </font><font style="vertical-align: inherit;">Wenn das ursprüngliche Array zufällige Daten enthält, werden diese gleichmäßig in einem ausgeglichenen Baum verteilt, und das mehrfache Sieben durchläuft alle Zweige ungefähr gleich oft. </font><font style="vertical-align: inherit;">Bei fast geordneten Daten ist ein unausgeglichener Baum vorzuziehen. In diesem Fall werden die Daten in dem Teil des Arrays, der längeren Zweigen des Baums entspricht, seltener verarbeitet als in anderen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leonardo-Nummern</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um beide Probleme zu lösen, schlug Dijkstra vor, spezielle binäre Haufen zu verwenden, die auf Leonardo-Zahlen basieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leonardo-Zahlen sind fast wie Fibonacci-Zahlen, aber nur besser. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Reihe von Leonardo-Zahlen wird rekursiv angegeben: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten 20 Leonardo-Zahlen: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1, 1, 3, 5, 9, 15, 25, 41, 67 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, 13529 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Absolut jede ganze Zahl kann als die Summe von Leonardo-Zahlen mit unterschiedlichen Seriennummern dargestellt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist in unserem Fall sehr nützlich. Array von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elemente können nicht immer als ein einzelner Haufen von Leonardo dargestellt werden (wenn </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keine Leonardo-Zahl ist). </font><font style="vertical-align: inherit;">Aber dann kann jedes Array immer in mehrere Subarrays unterteilt werden, die einer unterschiedlichen Anzahl von Leonardo entsprechen, d. H. </font><font style="vertical-align: inherit;">Haufen unterschiedlicher Ordnung sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Beispiel eines Arrays des 21. Elements, das aus drei Leonard-Haufen besteht. </font><font style="vertical-align: inherit;">In jedem der Haufen entspricht die Anzahl der Knoten einer beliebigen Anzahl von Leonardo.</font></font><br>
<br>
<div style="text-align:center;"><img width="760" height="369" src="https://habrastorage.org/webt/-9/w7/1b/-9w71bwg0hst69nkbnewpiyku9m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wichtige Punkte zu wissen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeder Leonardov-Stapel ist ein unausgeglichener Binärbaum.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wurzel jedes Heaps ist das letzte (und nicht das erste, wie in einem regulären binären Heap) Element des entsprechenden Subarrays.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeder Knoten mit all seinen Nachkommen ist auch ein Leonard-Haufen kleinerer Ordnung.</font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haufen bauen und abbauen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Wiederholungsformel für Leonardo-Zahlen ist </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sehr zufrieden mit der Einheit am Ende. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und deshalb. Angenommen, wir haben zwei benachbarte Subarrays im Array, die Heaps entsprechen, die auf zwei benachbarten Leonardo-Zahlen aufgebaut sind. Mit dem Element unmittelbar nach diesen Subarrays können diese Subarrays zu einem gemeinsamen Heap kombiniert werden, der der nächsten Leonard-Nummer entspricht.</font></font><br>
<br>
<div style="text-align:center;"><img width="694" height="423" src="https://habrastorage.org/webt/ds/jv/5b/dsjv5bfc0ao4k9d-frevjzg3wee.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gehen die Elemente im Array durch und bauen eine Reihe von Leonard-Haufen. Wenn Sie das Element verwenden, können Sie die beiden vorherigen Heaps kombinieren (dies ist nur dann möglich, wenn die beiden vorherigen Heaps zwei aufeinander folgenden Leonardo-Zahlen entsprechen), und dann kombinieren. Wenn eine Kombination nicht möglich ist (die beiden vorherigen Heaps entsprechen nicht zwei aufeinanderfolgenden Leonardo-Nummern), bildet das aktuelle Element einfach einen neuen Heap eines Elements, das der ersten (oder zweiten, wenn die erste zuvor verwendet wird) Leonardo-Nummer entspricht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der zweiten Stufe des Algorithmus erfolgt der umgekehrte Prozess - wir analysieren die Haufen. Wenn wir die Wurzel im Heap entfernen, erhalten wir zwei kleinere Heaps, die den beiden vorherigen Leonardo-Zahlen entsprechen. Dies kann geschehen, weil: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 1 = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In Fibonacci-Zahlen gibt es keine solche nützliche Einheit, daher verwenden wir den Fibonacci-Heap nicht.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Smooth Sort :: Smoothsort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der endgültige Algorithmus:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I. Erstellen Sie eine Reihe von Leonard-Haufen aus dem Array, von denen jeder ein Sortierbaum ist.</font></font></b><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I.1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durchlaufen Sie die Elemente des Arrays von links nach rechts.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überprüfen Sie, ob das aktuelle Element die beiden am weitesten links liegenden Heaps im vorhandenen Heap von Leonard-Heaps kombinieren kann:</font></font><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1.a. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ja, dann kombinieren wir die beiden am weitesten links liegenden Heaps zu einem. Das aktuelle Element wird zur Wurzel dieses Heaps. Wir durchsuchen den kombinierten Heap.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1.b. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn nicht, fügen Sie das aktuelle Element als neuen Heap (der bisher aus einem Knoten besteht) zum vorhandenen Heap von Leonard-Heaps hinzu.</font></font></li>
</ul></li>
</ul></li>
<li><b>II.      ,       :</b><ul>
<li><b>II.1.</b>     .          ,      .</li>
<li><b>II.2.</b>   (     )       (     ).</li>
<li><b>II.3.</b>    ,         .     .</li>
<li><b>II.4.</b>      (    ),          .</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.5. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem das maximale Element an das Ende verschoben wurde, nahm der sortierte Teil des Arrays zu und der unsortierte Teil ab. </font><font style="vertical-align: inherit;">Wiederholen Sie die Schritte II.1-II.4 für den verbleibenden unsortierten Teil des Arrays.</font></font></li>
</ul></li>
</ul><br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/wo/hc/ve/wohcve4fi78vdotmyfuw9pr2yyo.gif"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel für eine Python-Implementierung</font></font></h3><br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> random<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">smoothsort</span>(<span class="hljs-params">lst</span>):</span><font></font>
<font></font>
    <span class="hljs-comment">#    </span><font></font>
    leo_nums = leonardo_numbers(len(lst))<font></font>
<font></font>
<font></font>
    <span class="hljs-comment">#       </span><font></font>
    heap = []<font></font>
<font></font>
    <span class="hljs-comment">#   </span>
    <span class="hljs-comment">#       </span>
    <span class="hljs-comment">#       </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(lst)):
        <span class="hljs-keyword">if</span> len(heap) &gt;= <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> heap[<span class="hljs-number">-2</span>] == heap[<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>:<font></font>
            heap.pop()<font></font>
            heap[<span class="hljs-number">-1</span>] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> len(heap) &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> heap[<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>:<font></font>
                heap.append(<span class="hljs-number">0</span>)
            <span class="hljs-keyword">else</span>:<font></font>
                heap.append(<span class="hljs-number">1</span>)<font></font>
        restore_heap(lst, i, heap, leo_nums)<font></font>
<font></font>
    <span class="hljs-comment">#  </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> reversed(range(len(lst))):
        <span class="hljs-keyword">if</span> heap[<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">2</span>:<font></font>
            heap.pop()<font></font>
        <span class="hljs-keyword">else</span>:<font></font>
            k = heap.pop()<font></font>
            t_r, k_r, t_l, k_l = get_child_trees(i, k, leo_nums)<font></font>
            heap.append(k_l)<font></font>
            restore_heap(lst, t_l, heap, leo_nums)<font></font>
            heap.append(k_r)<font></font>
            restore_heap(lst, t_r, heap, leo_nums)<font></font>
<font></font>
<span class="hljs-comment">#   ,     </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leonardo_numbers</span>(<span class="hljs-params">hi</span>):</span><font></font>
<font></font>
    a, b = <span class="hljs-number">1</span>, <span class="hljs-number">1</span><font></font>
    numbers = []<font></font>
    <span class="hljs-keyword">while</span> a &lt;= hi:<font></font>
        numbers.append(a)<font></font>
        a, b = b, a + b + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> numbers<font></font>
<font></font>
<span class="hljs-comment">#        </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">restore_heap</span>(<span class="hljs-params">lst, i, heap, leo_nums</span>):</span><font></font>
    <font></font>
    <span class="hljs-comment">#      </span><font></font>
    <font></font>
    current = len(heap) - <span class="hljs-number">1</span><font></font>
    k = heap[current]<font></font>
<font></font>
    <span class="hljs-keyword">while</span> current &gt; <span class="hljs-number">0</span>:<font></font>
        j = i - leo_nums[k]<font></font>
        <span class="hljs-keyword">if</span> (lst[j] &gt; lst[i] <span class="hljs-keyword">and</span>
            (k &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> lst[j] &gt; lst[i<span class="hljs-number">-1</span>] <span class="hljs-keyword">and</span> lst[j] &gt; lst[i<span class="hljs-number">-2</span>])):<font></font>
            lst[i], lst[j] = lst[j], lst[i]<font></font>
            i = j<font></font>
            current -= <span class="hljs-number">1</span><font></font>
            k = heap[current]<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span><font></font>
<font></font>
    <span class="hljs-comment"># </span><font></font>
    <font></font>
    <span class="hljs-keyword">while</span> k &gt;= <span class="hljs-number">2</span>:<font></font>
        t_r, k_r, t_l, k_l = get_child_trees(i, k, leo_nums)<font></font>
        <span class="hljs-keyword">if</span> lst[i] &lt; lst[t_r] <span class="hljs-keyword">or</span> lst[i] &lt; lst[t_l]:
            <span class="hljs-keyword">if</span> lst[t_r] &gt; lst[t_l]:<font></font>
                lst[i], lst[t_r] = lst[t_r], lst[i]<font></font>
                i, k = t_r, k_r<font></font>
            <span class="hljs-keyword">else</span>:<font></font>
                lst[i], lst[t_l] = lst[t_l], lst[i]<font></font>
                i, k = t_l, k_l<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span><font></font>
<font></font>
<span class="hljs-comment">#         ,</span>
<span class="hljs-comment">#     </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_child_trees</span>(<span class="hljs-params">i, k, leo_nums</span>):</span><font></font>
<font></font>
    t_r, k_r = i - <span class="hljs-number">1</span>, k - <span class="hljs-number">2</span>
    t_l, k_l = t_r - leo_nums[k_r], k - <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> t_r, k_r, t_l, k_l<font></font>
<font></font>
<span class="hljs-comment">#  </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">n</span>):</span><font></font>
    lst = list(range(n))<font></font>
    random.shuffle(lst)<font></font>
    print(lst)<font></font>
    smoothsort(lst)<font></font>
    print(lst)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitliche Komplexität</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir ein fast geordnetes Array als Eingabe nehmen, zeigt die Visualisierung, warum ein solches Array viel schneller verarbeitet wird.</font></font><br>
<br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/x1/g1/kg/x1g1kglflod3zdnc2vuiqumjoyy.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einsparungen entstehen nur durch Sieben. In fast geordneten Daten sinkt das Sieben flach in den Baum, auch nachdem sich die Haufen in der zweiten Stufe allmählich aufgelöst haben. In den anfänglich zufälligen Daten ist das Sieben teurer, da es oft in seinem Haufen auf die allerletzte Ebene fällt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns die Gesamtzeitkomplexität schätzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der ersten Phase iterieren wir über n Elemente und fügen sie den bereits links vorhandenen Heaps hinzu. Das Hinzufügen zum Heap selbst kostet ungefähr in O (1), aber für den Heap müssen Sie einen Siebvorgang durchführen. In geordneten Daten kostet ein flaches Sieben häufig O (1) für ein Element, das dem Heap hinzugefügt wird. Bei ungeordneten Daten wird das Sieben für jede Addition in </font><nobr><font style="vertical-align: inherit;">O (log </font></nobr><nobr><b><font style="vertical-align: inherit;">n</font></b></nobr><nobr><font style="vertical-align: inherit;"> )</font></nobr><font style="vertical-align: inherit;"> berechnet.</font></font><nobr><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da das Sieben aufgrund von Zufälligkeiten oft bis zum Grund durch die Ebenen des Baumes gehen muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher ist in der ersten Stufe die beste Zeitkomplexität: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
für fast geordnete Daten - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
für zufällige Daten - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für die zweite Stufe ist die Situation ähnlich. Wenn Sie das nächste Maximum austauschen, müssen Sie den Heap, an dessen Wurzel er sich befand, erneut sieben. Und die Siebmetriken für geordnete und ungeordnete Daten sind unterschiedlich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der zweiten Stufe ist die beste Zeitkomplexität dieselbe wie in der ersten: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
für fast geordnete Daten - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
für zufällige Daten - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hinzufügen von Zeitkomplexität für die erste und zweite Stufe: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
für fast geordnete Daten - O (2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
für zufällige Daten - O (2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen ist die schlechteste und durchschnittliche Zeitkomplexität für eine reibungslose Sortierung O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dijkstra hat in seinen Berechnungen (mit denen ich Sie nicht langweilen werde) bewiesen, dass die beste Komplexität </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reibungslos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tendiert, </font><font style="vertical-align: inherit;">je geordneter die eingehenden Daten sind. </font><font style="vertical-align: inherit;">Daher der Name - reibungslose Sortierung.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusätzliche Speicherkomplexität</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Daten in eine Reihe von Leonard-Haufen zu zerlegen, müssen Sie sich nur genau merken, welche Leonardo-Nummern bei jedem Schritt beteiligt sind. </font><font style="vertical-align: inherit;">Wenn man diese Zahlen kennt, werden die Haufen selbst algorithmisch ausgerichtet. </font><font style="vertical-align: inherit;">Diese Zahlenreihe wächst sehr schnell, sodass Sie selbst für große Arrays einen sehr kleinen Satz von Leonard-Zahlen benötigen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomial-Heap-Sortierung :: Binomial-Heap-Sortierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt eine Baumstruktur, die der von uns aussortierten sehr ähnlich ist - einen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomialhaufen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies ist auch eine Reihe von Haufen unterschiedlicher Größe, bei denen die Anzahl der Knoten jeweils eine Zweierpotenz ist. </font><font style="vertical-align: inherit;">Jedes Array mit einer beliebigen Anzahl von Elementen kann in diesen Heap erweitert werden, da jede natürliche Anzahl in die Summe von zwei verschiedenen Graden zerlegt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Prinzip können Sie eine reibungslose Sortierung basierend auf Binomen durchführen:</font></font><br>
<br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/rw/p9/0y/rwp90yy_ub8vvvk2uczfoa4db8y.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wird es schneller funktionieren? </font><font style="vertical-align: inherit;">Kaum. </font><font style="vertical-align: inherit;">Der Binomialheap ist nicht binär, und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im letzten Artikel haben wir herausgefunden, dass das Erhöhen der Anzahl der Nachkommen nicht beschleunigt, sondern den Bildschirm verlangsamt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Außerdem können Sie feststellen, dass der Binomialheap längere Verzweigungen aufweist, weshalb benachbarte geordnete Bereiche des Arrays etwas langsamer miteinander verbunden sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist nicht bekannt, ob der Dijkstra-Binomialhaufen allgemein als mögliche Grundlage für seinen Algorithmus angesehen wurde. </font><font style="vertical-align: inherit;">Wie dem auch sei, der Leonardov-Haufen ist wahrscheinlich optimaler.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trailer der nächsten Serie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst wenn ein Binomialstapel nicht die beste Option für eine reibungslose Sortierung ist, sollten Sie ihn nicht vollständig verwerfen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Binomialbaum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leicht modifiziert ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und völlig andere (sehr kühne) Ideen verwendet werden, um ihn zu umgehen, erhalten wir einen originellen und effektiven Algorithmus, der seine eigenen Vorteile hat. </font><font style="vertical-align: inherit;">Worüber werden wir das nächste Mal sprechen?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/1l/ay/j-/1layj-xmzm4dl7p5yv7_5iag5pa.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klicken Sie auf die Animation, um zum Artikel mit der nächsten Sortierung nach Heap zu gelangen.</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die glatte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glatte </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leonardo-Zahl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomialhaufen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binomialhaufen</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serienartikel:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excel-Anwendung AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sorte austauschen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfügungssortierungen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Auswahl sortieren</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: N-Pyramiden</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Leonardo Numbers</font></font></b></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap-Sortierung: schwacher Heap</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bündelsorten: Kartesischer Baum</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Heap-Sortierungen: Spiegelhaufen, Mini-Heap, Sieben von unten nach oben</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Jung Heap</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sortierungen zusammenführen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Verteilung sortieren</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hybridsortierung</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die heutige reibungslose Sortierung wurde der AlgoLab-App hinzugefügt. </font><font style="vertical-align: inherit;">Sowie einen Bonus - und das Sortieren mit einem Binomialstapel. </font><font style="vertical-align: inherit;">Wer also die Daten auf den Heap-Heaps persönlich steuern möchte, aktualisiert die Excel-Datei mit Makros.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de496840/index.html">Musk glaubt, dass 12.000 Satelliten die Astronomen nicht stören werden. Seine Meinung stimmt nicht mit dem Modell überein</a></li>
<li><a href="../de496842/index.html">Ein einfaches Epidemiemodell mit grundlegenden Python-Tools</a></li>
<li><a href="../de496846/index.html">Sprachmechanik von Stapeln und Zeigern</a></li>
<li><a href="../de496848/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 340 (vom 6. bis 12. April)</a></li>
<li><a href="../de496850/index.html">Maven Plugin für JPackage aus Java 14</a></li>
<li><a href="../de496856/index.html">Smart Home ohne Fernbedienungen, aber mit einem Würfel</a></li>
<li><a href="../de496858/index.html">FOSS News Nr. 11 - eine Überprüfung der freien und Open-Source-Software für den 6. bis 12. April 2020</a></li>
<li><a href="../de496860/index.html">Erster DI: Erster DI für Schnittstellen für Typoskriptanwendungen</a></li>
<li><a href="../de496862/index.html">Arduino Bubble Display</a></li>
<li><a href="../de496864/index.html">Audit Wallets in CryptoNote</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>