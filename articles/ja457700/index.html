<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎖️ 🚈 🧑🏽‍🤝‍🧑🏼 passport.jsとサードパーティサービスを含まないNode.js認証ガイド 🥔 🔠 👋🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本日の翻訳を公開している記事の著者によると、Google Firebase Authentication、AWS Cognito、Auth0などの認証サービスの人気が高まっていることがわかります。 passport.jsなどの一般的なソリューションが業界標準になりました。しかし、現在の状況を考えると...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>passport.jsとサードパーティサービスを含まないNode.js認証ガイド</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/457700/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本日の翻訳を公開している記事の著者によると、Google Firebase Authentication、AWS Cognito、Auth0などの認証サービスの人気が高まっていることがわかります。 passport.jsなどの一般的なソリューションが業界標準になりました。しかし、現在の状況を考えると、開発者が認証システムの運用にどのようなメカニズムが関与しているかを完全に理解することは一般的ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この資料は、Node.jsでユーザー認証を整理する問題に焦点を当てています。その中で、実際の例では、システムでのユーザー登録の組織とシステムへのユーザーのエントリーの組織が検討されています。これにより、JWTテクノロジーの操作やユーザーの偽装などの問題が発生します。</font><font style="vertical-align: inherit;">
これにも注意し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">てください</font></a></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/8q/s0/uv/8qs0uvft-oqo_nmhu1vwlpf4rjw.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node.jsプロジェクトのコードを含むgithubリポジトリ。そのいくつかの例がこの記事で提供されています。</font><font style="vertical-align: inherit;">このリポジトリを独自の実験のベースとして使用できます。</font></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクト要件</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで扱うプロジェクトの要件は次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーの電子メールアドレスとパスワードが格納されるデータベースの存在。clientIdとclientSecret、またはプライベートキーとパブリックキーの一種の組み合わせ。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">強力で効率的な暗号アルゴリズムを使用してパスワードを暗号化します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この資料を執筆している現時点では、既存の暗号アルゴリズムの中で最も優れているのはArgon2だと思います。</font><font style="vertical-align: inherit;">SHA256、SHA512、MD5などの単純な暗号アルゴリズムを使用しないようにお願いします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、</font><font style="vertical-align: inherit;">パスワードのハッシュ化アルゴリズムの選択に関する詳細が記載さ</font><font style="vertical-align: inherit;">れている</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すばらしい資料をご覧になることをお勧めします。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムへのユーザーの登録</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムで新しいユーザーが作成されると、そのユーザーのパスワードをハッシュしてデータベースに保存する必要があります。</font><font style="vertical-align: inherit;">データベース内のパスワードは、電子メールアドレスとユーザーに関するその他の情報（たとえば、ユーザープロファイル、登録時間など）と共に保存されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> argon2 <span class="hljs-keyword">from</span> <span class="hljs-string">'argon2'</span>;<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span> </span>{<font></font>
&nbsp;&nbsp;public <span class="hljs-keyword">async</span> SignUp(email, password, name): <span class="hljs-built_in">Promise</span>&lt;any&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> passwordHashed = <span class="hljs-keyword">await</span> argon2.hash(password);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> userRecord = <span class="hljs-keyword">await</span> UserModel.create({
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">password</span>: passwordHashed,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;email,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//    - !!!</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">user</span>: {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">email</span>: userRecord.email,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">name</span>: userRecord.name,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーアカウント情報は次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b3/df3/027/2b3df30272e36e256f719b93ddf1197c.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Robo3Tを使用してMongoDBから取得したユーザーデータ</font></font></font></i><br>
 <br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーログイン</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ユーザーがログインしようとしたときに実行されるアクションの図です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/449/370/7e2/4493707e27d80de68619e12f8e7a8639.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーログインユーザーがログインする</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
と、次のようになります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアントはサーバーに公開識別子とユーザーの秘密鍵の組み合わせを送信します。</font><font style="vertical-align: inherit;">これは通常、メールアドレスとパスワードです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーは、メールアドレスでデータベース内のユーザーを検索します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーがデータベースに存在する場合、サーバーは送信されたパスワードをハッシュし、何が起こったかをデータベースに保存されているパスワードハッシュと比較します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検証が成功すると、サーバーはいわゆるトークンまたは認証トークン-JSON Web Token（JWT）を生成します。&nbsp;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JWTは一時的なキーです。</font><font style="vertical-align: inherit;">クライアントは、認証されたエンドポイントへのリクエストごとに、このキーをサーバーに送信する必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> argon2 <span class="hljs-keyword">from</span> <span class="hljs-string">'argon2'</span>;<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span> </span>{<font></font>
&nbsp;&nbsp;public <span class="hljs-keyword">async</span> Login(email, password): <span class="hljs-built_in">Promise</span>&lt;any&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> userRecord = <span class="hljs-keyword">await</span> UserModel.findOne({ email });
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span> (!userRecord) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'User not found'</span>)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;} <span class="hljs-keyword">else</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> correctPassword = <span class="hljs-keyword">await</span> argon2.verify(userRecord.password, password);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span> (!correctPassword) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Incorrect password'</span>)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">user</span>: {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">email</span>: userRecord.email,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">name</span>: userRecord.name,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">token</span>: <span class="hljs-keyword">this</span>.generateJWT(userRecord),<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パスワードの検証は、argon2ライブラリを使用して実行されます。</font><font style="vertical-align: inherit;">これは、いわゆる「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイムアタック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」</font><font style="vertical-align: inherit;">を防ぐため</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">このような攻撃を実行する際、サーバーが応答を形成するのに必要な時間の分析に基づいて、攻撃者はブルートフォースでパスワードを解読しようとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、JWTを生成する方法について説明します。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JWTとは何ですか？</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSON Web Token（JWT）は文字列エンコードされたJSONオブジェクトです。</font><font style="vertical-align: inherit;">トークンはCookieを置き換えるものとして理解できます。これにはトークンよりもいくつかの利点があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トークンは3つの部分で構成されます。</font><font style="vertical-align: inherit;">これは、ヘッダー、ペイロード、および署名です。</font><font style="vertical-align: inherit;">次の図にその外観を示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f16/a11/08d/f16a1108de7e0a5d8e4754725aacc830.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JWT</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
トークンデータは、秘密鍵や署名を使用せずにクライアント側でデコードできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、たとえば、トークン内にエンコードされたメタデータを転送する場合に役立ちます。</font><font style="vertical-align: inherit;">このようなメタデータは、ユーザーの役割、プロファイル、トークンの有効期間などを記述できます。</font><font style="vertical-align: inherit;">これらは、フロントエンドアプリケーションでの使用を目的としています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デコードされたトークンは次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/734/5fa/3e57345fafedf8eaa0d326190aa03b47.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デコードされたトークン</font></font></font></i><br>
 <br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node.jsでのJWTの生成</font></font></font></h2><br><font style="vertical-align: inherit;"></font><code>generateToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザー認証サービスの作業を完了するために必要な</font><font style="vertical-align: inherit;">
関数</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">作成してみましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
jsonwebtokenライブラリを使用してJWTを作成できます。</font><font style="vertical-align: inherit;">このライブラリはnpmにあります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> jwt <span class="hljs-keyword">from</span> <span class="hljs-string">'jsonwebtoken'</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span> </span>{<font></font>
&nbsp;&nbsp;private generateToken(user) {<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> data =&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">_id</span>: user._id,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">name</span>: user.name,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">email</span>: user.email<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;};<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> signature = <span class="hljs-string">'MySuP3R_z3kr3t'</span>;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> expiration = <span class="hljs-string">'6h'</span>;<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> jwt.sign({ data, }, signature, { <span class="hljs-attr">expiresIn</span>: expiration });<font></font>
&nbsp;&nbsp;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで最も重要なのは、エンコードされたデータです。</font><font style="vertical-align: inherit;">秘密のユーザー情報をトークンで送信しないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
署名（ここでは定数</font></font><code>signature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は、JWTの生成に使用される秘密データです。</font><font style="vertical-align: inherit;">署名が悪用されないようにすることが非常に重要です。</font><font style="vertical-align: inherit;">署名が侵害された場合、攻撃者はユーザーに代わってトークンを生成し、セッションを盗むことができます。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンドポイント保護とJWT検証</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、クライアントコードはすべてのリクエストでJWTを安全なエンドポイントに送信する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエストヘッダーにJWTを含めることをお勧めします。</font><font style="vertical-align: inherit;">これらは通常、Authorizationヘッダーに含まれています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/4dd/19d/b5c4dd19dfd705c210c9b4f5ce5212cf.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Authorizationヘッダー次</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
に、サーバーで、高速ルート用のミドルウェアであるコードを作成する必要があります。</font><font style="vertical-align: inherit;">次のコードをファイルに入れます</font></font><code>isAuth.ts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> jwt <span class="hljs-keyword">from</span> <span class="hljs-string">'express-jwt'</span>;<font></font>
<font></font>
<span class="hljs-comment">//      ,  JWT      Authorization,        req.body,    ,      ,     .&nbsp;</span>
<span class="hljs-keyword">const</span> getTokenFromHeader = <span class="hljs-function">(<span class="hljs-params">req</span>) =&gt;</span> {
&nbsp;&nbsp;<span class="hljs-keyword">if</span> (req.headers.authorization &amp;&amp; req.headers.authorization.split(<span class="hljs-string">' '</span>)[<span class="hljs-number">0</span>] === <span class="hljs-string">'Bearer'</span>) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> req.headers.authorization.split(<span class="hljs-string">' '</span>)[<span class="hljs-number">1</span>];<font></font>
&nbsp;&nbsp;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> jwt({
&nbsp;&nbsp;<span class="hljs-attr">secret</span>: <span class="hljs-string">'MySuP3R_z3kr3t'</span>, <span class="hljs-comment">//      ,     JWT</span><font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-attr">userProperty</span>: <span class="hljs-string">'token'</span>, <span class="hljs-comment">//       ,     services/auth:generateToken -&gt; 'req.token'</span><font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-attr">getToken</span>: getTokenFromHeader, <span class="hljs-comment">//       </span>
})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースからユーザーアカウントに関する完全な情報を取得し、リクエストに添付できると便利です。</font><font style="vertical-align: inherit;">私たちの場合、この機能はファイルのミドルウェアを使用して実装されています</font></font><code>attachCurrentUser.ts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ここにその簡略化されたコードがあります：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (req, res, next) =&gt; {
&nbsp;<span class="hljs-keyword">const</span> decodedTokenData = req.tokenData;
&nbsp;<span class="hljs-keyword">const</span> userRecord = <span class="hljs-keyword">await</span> UserModel.findOne({ <span class="hljs-attr">_id</span>: decodedTokenData._id })<font></font>
<font></font>
&nbsp;&nbsp;req.currentUser = userRecord;<font></font>
<font></font>
&nbsp;<span class="hljs-keyword">if</span>(!userRecord) {
&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> res.status(<span class="hljs-number">401</span>).end(<span class="hljs-string">'User not found'</span>)<font></font>
&nbsp;} <span class="hljs-keyword">else</span> {
&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> next();<font></font>
&nbsp;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメカニズムを実装すると、ルートはリクエストを実行しているユーザーに関する情報を受け取ることができます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> isAuth <span class="hljs-keyword">from</span> <span class="hljs-string">'../middlewares/isAuth'</span>;
&nbsp;&nbsp;<span class="hljs-keyword">import</span> attachCurrentUser <span class="hljs-keyword">from</span> <span class="hljs-string">'../middlewares/attachCurrentUser'</span>;
&nbsp;&nbsp;<span class="hljs-keyword">import</span> ItemsModel <span class="hljs-keyword">from</span> <span class="hljs-string">'../models/items'</span>;<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (app) =&gt; {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;app.get(<span class="hljs-string">'/inventory/personal-items'</span>, isAuth, attachCurrentUser, (req, res) =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> user = req.currentUser;<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> userItems = <span class="hljs-keyword">await</span> ItemsModel.find({ <span class="hljs-attr">owner</span>: user._id });<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> res.json(userItems).status(<span class="hljs-number">200</span>);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これでルートが</font></font><code>inventory/personal-items</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保護されました。</font><font style="vertical-align: inherit;">これにアクセスするには、ユーザーは有効なJWTを持っている必要があります。</font><font style="vertical-align: inherit;">さらに、ルートはユーザー情報を使用して、必要な情報をデータベースで検索できます。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トークンが侵入者から保護されるのはなぜですか？</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JWTの使用について読んだ後、「JWTデータをクライアント側でデコードできる場合、ユーザーIDまたはその他のデータを変更するような方法でトークンを処理することは可能ですか？」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トークンのデコード-操作は非常に簡単です。</font><font style="vertical-align: inherit;">ただし、サーバー上でJWTに署名するときに使用されたその秘密データである署名がないと、このトークンを「やり直す」ことはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このため、この機密データの保護が非常に重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーは、isAuthミドルウェアの署名を検証します。</font><font style="vertical-align: inherit;">express-jwtライブラリーがチェックを担当します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、JWTテクノロジーがどのように機能するかを理解した後、JWTテクノロジーがもたらすいくつかの興味深い追加機能について説明します。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーを偽装する方法は？</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーの偽装は、パスワードを知らなくても特定のユーザーとしてシステムにログインするために使用される手法です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この機能は、特権管理者、開発者、またはサポートスタッフにとって非常に役立ちます。偽装により、ユーザーはシステムを操作しているときにのみ現れる問題を解決できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パスワードを知らなくても、ユーザーに代わってアプリケーションを操作できます。これを行うには、正しい署名とユーザーを説明する必要なメタデータを使用してJWTを生成するだけで十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定のユーザーを装ってシステムに入るトークンを生成できるエンドポイントを作成します。このエンドポイントを使用できるのは、システムの特権管理者だけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、このユーザーに、他のユーザーよりも高い特権レベルが関連付けられているロールを割り当てる必要があります。</font><font style="vertical-align: inherit;">これは、さまざまな方法で実行できます。</font><font style="vertical-align: inherit;">たとえば</font></font><code>role</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、データベースに保存されているユーザー情報に</font><font style="vertical-align: inherit;">フィールド</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">追加するだけ</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">十分</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f69/c19/30e/f69c1930ec89fdf649d73772cc7754bc.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザー情報</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の</font><i><font color="#999999"><font style="vertical-align: inherit;">新しいフィールド</font></font></i></font><code>role</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スーパー管理者</font><font style="vertical-align: inherit;">フィールドの値</font><font style="vertical-align: inherit;">はになります</font></font><code>super-admin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ユーザーの役割をチェックする新しいミドルウェアを作成する必要があります。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (requiredRole) =&gt; {
&nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>(req.currentUser.role === requiredRole) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> next();<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;} <span class="hljs-keyword">else</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> res.status(<span class="hljs-number">401</span>).send(<span class="hljs-string">'Action not allowed'</span>);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
isAuthおよびattachCurrentUserの後に配置する必要があります。</font><font style="vertical-align: inherit;">次に、スーパー管理者がログインしたいユーザーの代わりにJWTを生成するエンドポイントを作成します。</font></font><br>
<br>
<pre><code class="javascript hljs">&nbsp;&nbsp;<span class="hljs-keyword">import</span> isAuth <span class="hljs-keyword">from</span> <span class="hljs-string">'../middlewares/isAuth'</span>;
&nbsp;&nbsp;<span class="hljs-keyword">import</span> attachCurrentUser <span class="hljs-keyword">from</span> <span class="hljs-string">'../middlewares/attachCurrentUser'</span>;
&nbsp;&nbsp;<span class="hljs-keyword">import</span> roleRequired <span class="hljs-keyword">from</span> <span class="hljs-string">'../middlwares/roleRequired'</span>;
&nbsp;&nbsp;<span class="hljs-keyword">import</span> UserModel <span class="hljs-keyword">from</span> <span class="hljs-string">'../models/user'</span>;<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (app) =&gt; {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;app.post(<span class="hljs-string">'/auth/signin-as-user'</span>, isAuth, attachCurrentUser, roleRequired(<span class="hljs-string">'super-admin'</span>), (req, res) =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> userEmail = req.body.email;<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> userRecord = <span class="hljs-keyword">await</span> UserModel.findOne({ <span class="hljs-attr">email</span>: userEmail });<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>(!userRecord) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> res.status(<span class="hljs-number">404</span>).send(<span class="hljs-string">'User not found'</span>);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> res.json({
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">user</span>: {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">email</span>: userRecord.email,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">name</span>: userRecord.name<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">jwt</span>: <span class="hljs-keyword">this</span>.generateToken(userRecord)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;})<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.status(<span class="hljs-number">200</span>);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、不思議なことは何もありません。</font><font style="vertical-align: inherit;">特権管理者は、ログインするユーザーに代わってユーザーのメールアドレスを知っています。</font><font style="vertical-align: inherit;">上記のコードのロジックは、コードがどのように機能するかを非常に連想させ、一般ユーザーのシステムに入力を提供します。</font><font style="vertical-align: inherit;">主な違いは、ここではパスワードがチェックされないことです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここではパスワードは必要ないため、ここではパスワードは検証されません。</font><font style="vertical-align: inherit;">エンドポイントセキュリティはミドルウェアによって提供されます。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サードパーティの認証サービスとライブラリに依存しても問題はありません。</font><font style="vertical-align: inherit;">これにより、開発者は時間を節約できます。</font><font style="vertical-align: inherit;">しかし、彼らはまた、認証システムの動作の基礎となる原則、およびそのようなシステムの機能を保証するものについて知る必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、JWT認証の可能性を探り、パスワードのハッシュに適切な暗号アルゴリズムを選択することの重要性について説明しました。</font><font style="vertical-align: inherit;">ユーザーの偽装メカニズムの作成について検討しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
passport.jsのようなもので同じことをするのは簡単ではありません。</font><font style="vertical-align: inherit;">認証は大きなトピックです。</font><font style="vertical-align: inherit;">おそらく、私たちは彼女に戻ります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読者の皆様！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node.jsプロジェクトの認証システムをどのように作成しますか？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></div></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja457686/index.html">Sberbankが生体認証処理の同意を収集する方法</a></li>
<li><a href="../ja457690/index.html">Yandex.Money metapからの妄想ビデオ</a></li>
<li><a href="../ja457692/index.html">全国のNB-Fi標準と請求システムに関する考察</a></li>
<li><a href="../ja457696/index.html">﻿複数文字定数を使用することの危険性</a></li>
<li><a href="../ja457698/index.html">実験：DoS攻撃に対抗するツールとしてプロキシを使用する</a></li>
<li><a href="../ja457702/index.html">KOMPAS-3D APIの操作→レッスン16→制御文字</a></li>
<li><a href="../ja457704/index.html">GPUが分岐を処理する方法</a></li>
<li><a href="../ja457706/index.html">ロボットはSAP ERPをテストします</a></li>
<li><a href="../ja457710/index.html">2019年のニューラルネットワークのすばらしい機能</a></li>
<li><a href="../ja457712/index.html">VerizonとBGP Optimizerが大規模なオフラインを実現した方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>