<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😠 💯 🤹 いくつかのマイクロ最適化の問題について 👊 👋🏻 🤜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="バックグラウンド
 かつて、C ++列挙でビットフラグを操作するためのツールの改善についての会話が同僚と始まりました。その時点で、IsEnumFlagSet関数が既にありました。この関数は、テストする変数を最初の引数として、2番目にチェックするフラグのセットを受け取ります。なぜ古き良きビットワイズよ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>いくつかのマイクロ最適化の問題について</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482766/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックグラウンド</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
かつて、C ++列挙でビットフラグを操作するためのツールの改善についての会話が同僚と始まりました。</font><font style="vertical-align: inherit;">その時点で、IsEnumFlagSet関数が既にありました。この関数は、テストする変数を最初の引数として、2番目にチェックするフラグのセットを受け取ります。</font><font style="vertical-align: inherit;">なぜ古き良きビットワイズよりも優れているのですか？</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span> (IsEnumFlagSet(state, flag)) <font></font>
{<font></font>
<font></font>
}<font></font>
<span class="hljs-comment">// vs</span>
<span class="hljs-keyword">if</span> (state &amp; flag) <font></font>
{<font></font>
<font></font>
}<font></font>
</code></pre><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では-読みやすさ。</font><font style="vertical-align: inherit;">私はめったにビットフラグとビット操作を操作することはほとんどないので、他の誰かのコードを表示するときは、「注意！</font><font style="vertical-align: inherit;">ある種の魔法が起こっているかもしれません。」</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少し悲しみ</font></font></b><div class="spoiler_text"> , ++      - ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"> </a>  ) —       , ,  - std::bitset:<br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span> (state.Test(particularFlags)) {}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に、フラグの設定や削除の操作中に読みやすさが低下します。</font><font style="vertical-align: inherit;">比較：</font></font><br>
<br>
<pre><code class="cpp hljs">state |= flag; <span class="hljs-comment">//    enum class,     |=</span><font></font>
state &amp;= ~flag;<font></font>
<span class="hljs-comment">//vs</span><font></font>
RaiseEnumFlag(state, flag);<font></font>
ClearEnumFlag(state, flag);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスカッション中に、関数の作成に関するアイデアも表明さ</font></font><code>SetEnumFlag(state, flag, isSet)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れました。3番目の引数に応じて、</font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラグが立てられるか削除されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この引数は実行時</font></font><code>RaiseEnumFlag/ClearEnumFlag</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">渡されると想定されているため、ペアと比較してオーバーヘッドなしで実行</font><font style="vertical-align: inherit;">することは明らかに不可能です。</font><font style="vertical-align: inherit;">しかし、学問的な関心のために、私は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">鉱山に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">降りて</font><font style="vertical-align: inherit;">マイクロ最適化の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">悪魔に</font></a><font style="vertical-align: inherit;">それを最小化したいと思いました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.素朴な実装</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、列挙型を紹介します（単純化するために列挙型クラスは使用しません）。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;limits&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;random&gt;</span></span><font></font>
<font></font>
<span class="hljs-keyword">enum</span> Flags : <span class="hljs-keyword">uint32_t</span><font></font>
{<font></font>
  One = <span class="hljs-number">1u</span> &lt;&lt; <span class="hljs-number">1</span>,<font></font>
  Two = <span class="hljs-number">1u</span> &lt;&lt; <span class="hljs-number">2</span>,<font></font>
  Three = <span class="hljs-number">1u</span> &lt;&lt; <span class="hljs-number">3</span>,<font></font>
  OneOrThree = One | Three,<font></font>
  Max = <span class="hljs-number">1u</span> &lt;&lt; <span class="hljs-number">31</span>,<font></font>
  All = <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-keyword">uint32_t</span>&gt;::max()<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして実装自体：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetFlagBranched</span><span class="hljs-params">(Flags&amp; x, Flags y, <span class="hljs-keyword">bool</span> cond)</span>
</span>{
  <span class="hljs-keyword">if</span> (cond) {<font></font>
    x = Flags(x | y);<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    x = Flags(x &amp; (~y));<font></font>
  }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.ミクロ最適化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
素朴な実装には明らかな分岐があります。これを私が算術に移したいのですが、これを現在実行しようとしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、パラメーターに基づいて、ある結果から別の結果に切り替えることができる式を選択する必要があります。</font><font style="vertical-align: inherit;">例えば、</font></font><br>
<br>
<pre><code class="plaintext hljs">(x | y) &amp; ¬p</code></pre><br>
<ol>
<li><font style="vertical-align: inherit;"></font><code>p = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラグ</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">作成する</font><font style="vertical-align: inherit;">とき</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="plaintext hljs">(x | y) &amp; ¬0 ≡ (x | y) &amp; 1 ≡ x | y</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"></font><code>p = y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラグが削除された</font><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="plaintext hljs">(x | y) &amp; ¬y ≡ (x &amp; ¬y) | (y &amp; ¬y) ≡ (x &amp; ¬y) | 0 ≡ x &amp; ¬y</code></pre><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、変数に応じてパラメーター値の変化を算術的に「パック」する必要があります</font></font><code>cond</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（覚えておいてください-分岐は禁止されています）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初</font></font><code>p = y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はと</font><font style="vertical-align: inherit;">仮定し</font><font style="vertical-align: inherit;">、</font></font><code>cond</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trueの</font></font><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合は</font><font style="vertical-align: inherit;">リセットを試み</font><font style="vertical-align: inherit;">、そうでない場合はすべてそのままにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数を直接操作する</font></font><code>cond</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法はありません。算術型に変換するときに、trueの場合、下位のユニットが1つだけ取得されます。理想的には、すべての場所でユニットを取得する必要があり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（UPD：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">引き続き使用できます</font></a><font style="vertical-align: inherit;">）。その結果、ビット単位のシフトを使用するよりも優れた方法が思い浮かびました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シフト量を決定します。すべてのビットをすぐにシフトすることはできないため、1回の操作でパラメーターをリセットできます</font></font><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準では、シフト量はタイプサイズよりも小さいことが要求されているためです。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正当ではない</font></font></b><div class="spoiler_text">,    asm  shift arithmetic left (SAL)    «The count range is limited to 0 to 31 (or 63 if 64-bit mode and REX.W is used)»<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、最大シフトサイズを計算し、予備的な式を記述します</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> shiftSize = <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">underlying_type_t</span>&lt;Flags&gt;) * <span class="hljs-number">8</span> - <span class="hljs-number">1</span>;<font></font>
(x | y) &amp; ~ ( y &gt;&gt; shiftSize * cond);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、式の結果の最下位ビットを個別に処理します</font></font><code>y &gt;&gt; shiftSize * cond</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">(x | y) &amp; ~ (( y &gt;&gt; shiftSize * cond) &amp; ~cond);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分岐包装に発生した</font></font><code>shiftSize * cond</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- CONDで偽または真に応じて、シフト値は、それぞれ0または31になります、と私たちのパラメータは、どちらかと等しくなります</font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または0の</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とき、何が起こります</font></font><code>shiftSize = 31</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合</font></font><code>cond = true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我々はビットをシフト</font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最上位ビットが、その結果として、右に31で</font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小となり</font><font style="vertical-align: inherit;">著しい</font><font style="vertical-align: inherit;">、そして他のすべてがリセットされます。</font><font style="vertical-align: inherit;">U </font></font><code>~cond</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逆に、最下位ビットは0で、他のすべてのビットは1です。</font><font style="vertical-align: inherit;">これらの値をビットごとに乗算すると、きれいな0が得られます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ときに</font></font><code>cond = false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何のずれが発生していない、</font></font><code>~cond</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての桁にそれが1あり、これらの値のビットごとの乗算が得られます</font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチのトレードオフに注意したいと思います。これはすぐにはわかりません。分岐を使用せずに</font></font><code>x | y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのような</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合</font><i><font style="vertical-align: inherit;">でも</font></i><font style="vertical-align: inherit;">（つまり、単純バージョンの分岐の1つ</font><font style="vertical-align: inherit;">）を計算</font><font style="vertical-align: inherit;">し、「追加の」算術演算により、それを望ましい結果に変換します。</font><font style="vertical-align: inherit;">そして、これらすべては、追加の計算のオーバーヘッドが分岐よりも少ない場合に意味があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、最終的な解決策は次のとおりです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetFlagsBranchless</span><span class="hljs-params">(Flags&amp; x, Flags y, <span class="hljs-keyword">bool</span> cond)</span>
</span>{
  <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> shiftSize = <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">underlying_type_t</span>&lt;Flags&gt;) * <span class="hljs-number">8</span> - <span class="hljs-number">1</span>;<font></font>
  x = Flags((x | y) &amp; ~(( y &gt;&gt; shiftSize * cond) &amp; ~cond));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（シフトの大きさは、一読することがより正確である</font></font><code>std::numeric_limits::digits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コメントを参照してください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.比較</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分岐せずにソリューション</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装した</font><font style="vertical-align: inherit;">ので、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">quick-bench.comに移動</font></a><font style="vertical-align: inherit;">してその利点を確認しました。開発には主にclangを使用するため、ベンチマーク（clang-9.0）を実行することにしました。しかし、それから驚きが私を待っていました... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/j8/ar/se/j8arset8k9nbzroo2ws7a2flzeu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これは-O3でです。最適化がなければ、それはさらに悪くなります。どうやってそうなった？誰が責任を負い、何をすべきか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは「パニックを回避します！」と命じます。そして、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">godbolt.orgを見てみましょう</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（quick-benchはasmリストも提供しますが、godboltはこの点でより便利に見えます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、最適化のレベル-O3についてのみ説明します。では、clangが単純な実装のためにどのコードを生成したのでしょうか？</font></font><br>
<br>
<pre><code class="plaintext hljs">SetFlagBranched(Flags&amp;, Flags, bool):          # @SetFlagBranched(Flags&amp;, Flags, bool)<font></font>
        mov     eax, dword ptr [rdi]<font></font>
        mov     ecx, esi<font></font>
        not     ecx<font></font>
        and     ecx, eax<font></font>
        or      eax, esi<font></font>
        test    edx, edx<font></font>
        cmove   eax, ecx<font></font>
        mov     dword ptr [rdi], eax<font></font>
        ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
悪くないでしょ？クランはまた、トレードオフする方法を知っている、それがあることを理解</font><font style="vertical-align: inherit;">するために条件ジャンプコマンドを使用するように速くなります</font><font style="vertical-align: inherit;">計算</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の両方</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の枝をし、条件付き移動コマンド、使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">伴わない</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作業に分岐予測器を。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブランチレス実装コード：</font></font><br>
<br>
<pre><code class="plaintext hljs">SetFlag(Flags&amp;, Flags, bool):                   # @SetFlag(Flags&amp;, Flags, bool)<font></font>
        mov     eax, dword ptr [rdi]<font></font>
        or      eax, esi<font></font>
        test    edx, edx<font></font>
        mov     ecx, 31<font></font>
        cmove   ecx, edx<font></font>
        shr     esi, cl<font></font>
        not     esi<font></font>
        or      esi, edx<font></font>
        and     esi, eax<font></font>
        mov     dword ptr [rdi], esi<font></font>
        ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほぼ「ブランチレス」-私は、通常の乗算​​をここで注文し、私の友人である条件付きの移動を行いました。おそらくコンパイラは正しく、この場合のテスト+ cmoveはimulより高速ですが、私はアセンブラがあまり得意ではありません（知識のある人は、コメントで教えてください）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つ興味深いのは、興味深いことです。実際、最適化後の両方の実装では、コンパイラーは要求されたものを正確に生成せず、結果はその中間でした：cmoveは両方のバリアントで使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8番目のバージョン以前のClangは、一般に実際の条件付き遷移を使用します。これにより、「ブランチレス」バージョンの速度がほぼ1.5倍遅くなります。</font></font><br>
<br>
<pre><code class="plaintext hljs">SetFlag(Flags&amp;, Flags, bool):                   # @SetFlag(Flags&amp;, Flags, bool)<font></font>
        mov     eax, dword ptr [rdi]<font></font>
        or      eax, esi<font></font>
        mov     cl, 31<font></font>
        test    edx, edx<font></font>
        jne     .LBB0_2<font></font>
        xor     ecx, ecx<font></font>
.LBB0_2:<font></font>
        shr     esi, cl<font></font>
        not     esi<font></font>
        or      esi, edx<font></font>
        and     eax, esi<font></font>
        mov     dword ptr [rdi], eax<font></font>
        ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのような結論を下すことができますか？明らかに「不必要にマイクロ最適化を行わないでください」に加えて、マシンコードでの作業結果を常に確認するようにアドバイスできない限り、コンパイラーがすでに初期バージョンを十分に最適化しており、「不可解な」最適化ではそれが理解されず、それにもかかわらず条件付きで熟考する場合があります。乗算ではなく遷移。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点で、「しかし」ではなくても、終了することができます。単純な実装のgccコードはclangコードと同じですが、ブランチレスバージョンです。</font></font><br>
<br>
<pre><code class="plaintext hljs">SetFlag(Flags&amp;, Flags, bool):<font></font>
        movzx   edx, dl<font></font>
        mov     eax, esi<font></font>
        or      eax, DWORD PTR [rdi]<font></font>
        mov     ecx, edx<font></font>
        sal     ecx, 5<font></font>
        sub     ecx, edx<font></font>
        shr     esi, cl<font></font>
        not     esi<font></font>
        or      esi, edx<font></font>
        and     esi, eax<font></font>
        mov     DWORD PTR [rdi], esi<font></font>
        ret</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のどちらも使用していないことなく、私たちの発現を最適化するために、このようなエレガントな方法のために、開発者に関して</font></font><code>imul</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、また</font></font><code>cmove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ここで何が起こるか：bool変数condはビット単位で左に5文字シフトされ（列挙型のタイプはuint32_tで、サイズは32ビット、つまり100000 </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2であるため</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、結果から減算されます。したがって、</font><font style="vertical-align: inherit;">cond = trueの場合は</font><font style="vertical-align: inherit;">11111 </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 31 </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それ以外の場合は0になります。言うまでもなく、そのようなオプションは、条件付きの移動の最適化を考慮しても、単純なオプションよりも高速ですか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/il/-k/sv/il-ksv3hfdrbu0npoffcva7c67o.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、結果は非常に奇妙でした-コンパイラによっては、ブランチなしのオプションは、ブランチありの実装よりも高速または低速になることがあります。</font><font style="vertical-align: inherit;">clangを助け、gccメソッドに従って式を変換してみましょう（同時に、</font></font><code>~((y &gt;&gt; shiftSize * cond) &amp; ~cond)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de Morgan部分を</font><font style="vertical-align: inherit;">簡略化し</font><font style="vertical-align: inherit;">ます-clangとgccの両方がこれを行います）。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetFlagVerbose</span><span class="hljs-params">(Flags&amp; x, Flags y, <span class="hljs-keyword">bool</span> b)</span>
</span>{
  <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> shiftSize = <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">underlying_type_t</span>&lt;Flags&gt;) + <span class="hljs-number">1</span>;<font></font>
  x = Flags( (x | y) &amp; ( ~(y &gt;&gt; ((b &lt;&lt; shiftSize) - b)) | b) );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなヒントは、clangのトランクバージョンにのみ影響し、gccと同様のコードを実際に生成します（ただし、元の「ブランチレス」では同じテスト+ cmoveです）。MSVCは</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どうですか？</font><font style="vertical-align: inherit;">どちらのバージョンでも、分岐せずに正直なimulが使用され（clang / gccオプションよりも高速/低速であることがわかりません-クイックベンチはこのコンパイラをサポートしていません）、単純なバージョンでは条件ジャンプが表示されました。</font><font style="vertical-align: inherit;">悲しいが本当。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、主な結論は、高水準コードでのプログラマーの意図が常にマシンコードに反映されているとはほど遠いということです。これにより、ベンチマークやリストを表示しなければ、マイクロ最適化は無意味になります。</font><font style="vertical-align: inherit;">さらに、マイクロ最適化の結果は、通常のバージョンよりも良くも悪くもなる可能性があります-それはすべてコンパイラーに依存しており、プロジェクトがクロスプラットフォームの場合、深刻な問題になる可能性があります。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja482752/index.html">「新しい叙事詩」。象を分けて食べる</a></li>
<li><a href="../ja482756/index.html">それは霧の緑の未来ですか？</a></li>
<li><a href="../ja482758/index.html">完璧なキーボードへの道</a></li>
<li><a href="../ja482762/index.html">42,000,000,000回の訪問。2019年にまとめたPornHub</a></li>
<li><a href="../ja482764/index.html">Rhasspyは、オープンソースで完全にオフラインの音声ツールキットです。ロシア語の認識。クラウドへの漏れなし</a></li>
<li><a href="../ja482768/index.html">DeepRegistryはいつ登場しますか？すべてを制御する世界の規制当局の愛について</a></li>
<li><a href="../ja482772/index.html">2020年のプログレッシブWebアプリケーション</a></li>
<li><a href="../ja482774/index.html">黒ソシニキと最高のプロモーション方法。大人、薬局、エッセイ、デート。シェスタコフ| People PRO＃75</a></li>
<li><a href="../ja482776/index.html">高さマップと視差</a></li>
<li><a href="../ja482778/index.html">アパートの回復と換気。ダクトとSMSなし</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>