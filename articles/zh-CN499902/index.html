<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏🏽 💿 🍆 TCP重置攻击如何工作 📘 🐴 📬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="使用大小不超过几个字节的单个数据包执行TCP重置攻击。由攻击者创建和传输的由欺骗代替的TCP段欺骗了两个受害者终止TCP连接，中断了它们之间的连接，这可能很关键。
 
 
 这种攻击在现实世界中产生了后果。对TCP协议本身的更改引起了对它的使用的担心。据信，该攻击是“中国大防火墙”（金盾）的重要组成...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>TCP重置攻击如何工作</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499902/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用大小不超过几个字节的单个数据包执行TCP重置攻击。</font><font style="vertical-align: inherit;">由攻击者创建和传输的由欺骗代替的TCP段欺骗了两个受害者终止TCP连接，中断了它们之间的连接，这可能很关键。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0e/768/854/d0e7688544d90ce84fd01f7aae77b348.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种攻击在现实世界中产生了后果。</font><font style="vertical-align: inherit;">对TCP协议本身的更改引起了对它的使用的担心。</font><font style="vertical-align: inherit;">据信，该攻击是“中国大防火墙”（金盾）的重要组成部分，中国政府使用该防火墙对中国境外的互联网进行审查。</font><font style="vertical-align: inherit;">尽管她有令人印象深刻的背景，但了解这种攻击背后的机制并不一定需要深入了解TCP。</font><font style="vertical-align: inherit;">当然，了解它的精妙之处可以教会您很多有关实施TCP协议的功能，并且，正如我们很快将看到的，您甚至可以只用一台笔记本电脑对自己进行这种攻击。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这篇文章中，我们：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学习TCP基础知识</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解攻击的工作原理。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们用一个简单的Python脚本对自己进行攻击。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在开始分析攻击机制之前，让我们首先了解一下它在现实世界中的用法。</font></font><a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">防火墙中如何使用TCP重置攻击？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
长防火墙（GFW）是中国政府用来审查内部中国用户互联网的一套系统和技术。</font><font style="vertical-align: inherit;">GFW主动阻止和断开与该国家/地区内外服务器的连接，并被动监视受禁止内容的Internet通信。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了防止用户甚至连接到受禁服务器，GFW使用了</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DNS污染</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP阻止等技术</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（它们都需要单独撰写文章）。</font><font style="vertical-align: inherit;">但是，有时需要允许GFW防火墙建立连接，然后在中间断开连接。</font><font style="vertical-align: inherit;">例如，如果要对连接执行缓慢的，挂起的分析（例如，它与其他操作的关联），则这是必需的。</font><font style="vertical-align: inherit;">或者，如果防火墙需要分析在连接过程中交换的数据，然后使用此信息来决定是继续还是阻止它，则使用它。</font><font style="vertical-align: inherit;">例如，新闻网站的流量可能被允许，但是包含禁止关键字的视频将被审查。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，GFW需要能够中断已经建立的连接的工具。</font><font style="vertical-align: inherit;">TCP重置攻击就是这样一种工具。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP重置攻击如何起作用？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在TCP重置攻击中，攻击者断开两个受害者之间的连接，发送一条或两条伪造消息，告诉他们立即断开连接。这些消息称为</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP重置段</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在没有攻击者参与的正常操作中，计算机在接收到意外的TCP流量并希望发送方停止发送时会发送TCP丢弃段。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TCP重置攻击恶意利用了这种机制，诱使受害者过早地终止TCP连接，向其发送伪造的重置段。如果正确设置了错误的重置段，则接收者会将其用作真实段，并关闭其连接部分，从而中断有关此连接的信息的进一步传输。为了继续进行数据交换，受害者可以尝试创建新的TCP连接，但是攻击者可能有机会重置此新连接。幸运的是，由于攻击者需要时间来构建和发送伪造的数据包，因此丢弃攻击实际上仅对长期连接有效。短期连接。例如，用于传输小型网页，通常有时间按时完成任务攻击者何时才能重置它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从某种意义上说，发送伪造的TCP段是一个简单的过程，因为TCP和IP都没有自己的验证发送方身份的方式。有一个称为IPSec的IP扩展可提供身份验证，但使用范围不广。 Internet服务提供商必须拒绝传输来自明显错误的IP地址的IP数据包，但是据称此检查非常平庸。接收者所能做的就是以数据包或段中的源IP地址和端口为准，并尽可能使用更高级别的协议（例如</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/2014/03/27/how-does-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）来识别发送者</font><font style="vertical-align: inherit;">。但是，由于TCP转储数据包本身是TCP协议的一部分，因此无法使用这些高级协议进行验证。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管发送假段很简单，但制作假段并执行成功的TCP重置攻击仍然是一项艰巨的任务。</font><font style="vertical-align: inherit;">要了解为什么会发生这种情况，我们需要了解TCP协议的操作。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP如何工作</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TCP协议的目的是向接收方发送数据块的精确副本。</font><font style="vertical-align: inherit;">例如，如果我的服务器通过TCP将HTML发送到您的计算机，则计算机</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的TCP堆栈</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（其操作系统中处理TCP的部分）应以与服务器发送它的形式和顺序完全相同的形式输出HTML。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54d/bf5/d64/54dbf5d644d0a3d8ece1cff6cde7b790.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，我的HTML并不是以这种完美的顺序在Internet上传输的。它分为许多小片段（称为</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP片段</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），每个</font><em><font style="vertical-align: inherit;">片段</font></em><font style="vertical-align: inherit;">都通过Internet单独传输，并由计算机的TCP堆栈按传输顺序重新创建。恢复的输出称为</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP流</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。每个TCP段都是在其自己的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP数据包中传输的</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是，要了解这种攻击，我们无需了解有关IP的任何详细信息。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/468/904/175/4689041752b8fa9f66c57c696c4be2ef.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将段转换为流需要特别小心，因为Internet不可靠。</font><font style="vertical-align: inherit;">TCP段可能会丢失。</font><font style="vertical-align: inherit;">它们可能会故障，发送两次，损坏并经历许多其他灾难。</font><font style="vertical-align: inherit;">因此，TCP协议的目的是确保在不可靠的网络上进行可靠的数据传输。</font><font style="vertical-align: inherit;">TCP执行此任务，要求连接双方保持彼此之间的紧密联系，并不断发送有关接收到哪些数据块的信息。</font><font style="vertical-align: inherit;">这使发件人可以了解收件人尚未收到的数据，并重新传输丢失的数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要了解该过程如何工作，我们需要了解发送者和接收者如何使用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP序列号</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用于标记和跟踪通过TCP传输的数据。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP序列号</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过TCP连接传输的每个字节都有一个由发送方分配的序列号。</font><font style="vertical-align: inherit;">接收机使用序列号将接收到的数据移至原始顺序。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/402/fbc/144/402fbc144a2864f986debfb2ea9b6412.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当两台计算机协商TCP连接时，每台计算机都会发送另一个随机</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起始序列号</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这是机器将分配给它发送的第一个字节的序列号。每个后续字节都分配有前一个字节的序号加1。TCP段包含</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP标头</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这些</font><em><font style="vertical-align: inherit;">标头</font></em><font style="vertical-align: inherit;">是附加到段开头的元数据。段主体中第一个字节的序列号包含在此段的TCP报头中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
应该注意的是，TCP连接是双向的，也就是说，数据可以在两个方向上传输，并且TCP连接中的每台机器都充当发送者和接收者。因此，每台机器都必须分配和处理自己独立的序列号集。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确认收到数据</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当机器接收到TCP段时，它会告诉该段的发送方它已被接收。</font><font style="vertical-align: inherit;">接收者通过发送一个段</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（“ acknowledge”的缩写）来</font><font style="vertical-align: inherit;">完成此操作，该段</font><font style="vertical-align: inherit;">包含</font><font style="vertical-align: inherit;">他期望从发送者接收到的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一个</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字节</font><font style="vertical-align: inherit;">的序列号</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">发送方使用此信息来了解接收方已成功接收到所有其他字节（直到此数字）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过段</font><font style="vertical-align: inherit;">的TCP报头中</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标志的存在</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和相应的确认编号</font><font style="vertical-align: inherit;">来</font><font style="vertical-align: inherit;">指示</font><font style="vertical-align: inherit;">段。</font><font style="vertical-align: inherit;">TCP协议中只有6个标记，其中包括（如我们将很快看到的）一个标记</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（“ reset”-“ reset”的缩写），指示重置段。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/242/452/e35/242452e35d360faf406441ab93f8c383.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意：TCP还允许使用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择性ACK</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，当接收器收到数字范围内的部分但不是全部段时发送。例如，“我收到了1000-3000和4000-5000字节，但没有收到3001-3999。”为简单起见，在讨论TCP重置攻击时，我将不考虑选择性ACK。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果发件人发送数据但未收到</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于他们在一定时间间隔内的数据，他认为数据已丢失并重新发送，并为其提供了相同的序列号。这意味着，如果接收者两次接受相同的字节，那么它会轻而易举地使用序列号来消除重复项，而不会中断流。接收者可以接受重复的数据，这是因为原始段是在以后被接收，再次发送之后接收的，或者是因为原始段已被成功接收，但是相应的段</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在发送者的途中丢失了。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6d/22f/a09/e6d22fa098d7375dab30e6c8341ff358.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管这样的重复数据非常少见，但由它引起的过多资源浪费不会导致问题。</font><font style="vertical-align: inherit;">如果所有数据迟早都到达接收者，并且相应的数据</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到达发送者，则TCP连接将执行其工作。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为假段选择序列号</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建虚假段时，</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">攻击者需要给他一个序列号。</font><font style="vertical-align: inherit;">接收者很高兴您需要接受序列号不一致的段，并以正确的顺序独立地连接它们。</font><font style="vertical-align: inherit;">但是，它们的功能是有限的。</font><font style="vertical-align: inherit;">如果接收方收到的序列号“太”乱序的段，则将其丢弃。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，对于成功的TCP重置攻击，需要一个合理的序列号。</font><font style="vertical-align: inherit;">但是，什么是这样的数字呢？</font><font style="vertical-align: inherit;">对于大多数段（尽管，我们将在后面看到，但不是</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），答案取决于</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP窗口</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><em><font style="vertical-align: inherit;">大小</font></em><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP窗口大小</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
想象一下一台1990年代初期的古老计算机，它连接到现代的千兆位光纤网络。超高速网络可以惊人的速度将数据传输到这台老式计算机，其速度比计算机处理数据的速度快。这将困扰我们，因为只有在接收者可以处理之前，TCP段才被视为已接收。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/299/76a/8a529976a3acd7a28babb9e8220bcb7d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
计算机具有</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP缓冲区</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，当计算机处理之前到达的数据时，新到达的数据将在其中等待处理。但是，此缓冲区的大小有限。如果收件人无法应付网络发送给他的数据量，则缓冲区将溢出。当缓冲区已满时，接收者别无选择，只能摆脱冗余数据。接收者不会发送</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">丢弃的数据，因此，当接收者的缓冲区中有可用空间时，发送者必须重新发送它们。如果接收者没有时间处理数据，则网络可以以多快的速度传输数据都没有关系。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
想象一下一个过于热心的朋友，他以比您能阅读的速度快的速度向您发送一封完整的信件到您的邮件。邮箱内有一定的缓冲空间，但在其满后，所有未放置的字母都会掉落到地面，狐狸和其他生物会在这里吞噬它们。一个朋友将不得不重新发送他吃过的信件，但是现在您将有时间接收他以前的消息。发送太多收件人无法处理的信件或数据量会浪费能源和传输通道。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“太多”-它有多少数据？发送方如何理解何时发送更多数据，何时值得等待？这是</font><em><font style="vertical-align: inherit;">TCP窗口大小</font></em><font style="vertical-align: inherit;">派上用场的地方。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。收件人窗口的大小是发件人可以随时传送给他的未确认字节的最大数量。假设接收者报告其窗口大小为100,000（我们将很快发现它如何传递此值），因此发送者发送100,000个字节。假设到发送方发送十万个字节时，接收方已发送了</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些字节的前10,000个段。这意味着尚未确认90,000字节。由于窗口大小为100,000，因此发送者可以在等待新的字节之前再传输10,000个字节</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果在发送完这10,000个额外字节后</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果未收到，则发送方将达到其100,000个未确认字节的限制。因此，发件人将不得不等待并停止发送数据（除非重新传输他认为丢失的数据），直到他收到新的数据为止</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afa/5df/46f/afa5df46f3304b04abbf629ca6ef34a0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在打开连接时执行的握手过程中，TCP连接的每一侧都会将其窗口的大小通知对方。此外，在连接过程中可以动态更改窗口大小。具有较大TCP缓冲区的计算机可以声明较大的窗口大小，以最大化吞吐量。这样一来，与之通信的机器就可以通过TCP连接连续传输数据，而无需暂停或等待确认。 TCP缓冲区较小的计算机可能会被迫报告较小的窗口大小。有时，发件人完全填满了窗口，并被迫等待直到确认了某些段。因此，带宽会受到影响，但是有必要确保TCP缓冲区不溢出。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e3/d5e/5e0/8e3d5e5e0e4b574c6896e6ef7adc94bc.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TCP窗口的大小是对传输的未确认数据量的严格限制。</font><font style="vertical-align: inherit;">我们可以使用它来计算最大可能的序列号（在下面的等式中，我指定为</font></font><code>max_seq_no</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），发送者可以在当前时间发送该</font><font style="vertical-align: inherit;">序列号</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<blockquote><code>max_seq_no = max_acked_seq_no + window_size</code></blockquote><br>
<code>max_acked_seq_no</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是收件人已发送的最大序列号</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是发件人知道收件人已正确接收的最大序列号。</font><font style="vertical-align: inherit;">由于发送方只能发送</font></font><code>window_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未确认的字节，因此它可以发送的最大序列号为</font></font><code>max_acked_seq_no + window_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，TCP规范指出接收者应忽略其接收到的，具有有效窗口之外的序列号的任何数据。例如，如果接收者确认了所有不超过15,000的字节，并且其窗口大小为30,000，则它将接收序列号介于15,000至（15,000 + 30,000 = 45,000）之间的任何数据。而且，接收者完全忽略了此间隔之外的序列号数据。如果该段包含数据，其中一些位于该窗口内，而某些位于该窗口外，则该窗口内的数据将被接受并确认，但其外部的数据将被丢弃。请注意，我们仍然忽略</font><font style="vertical-align: inherit;">在文章开头简短提及</font><font style="vertical-align: inherit;">的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择性内容的</font></font><code>ACK</code></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能性</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于大多数TCP段，此规则为我们提供了可接受序列号的间隔。</font><font style="vertical-align: inherit;">但是，如前所述，对段</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的限制甚至比对普通数据传输段的限制更为严格。</font><font style="vertical-align: inherit;">就像我们将很快看到的那样，这样做是为了使称为</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“盲TCP重置攻击”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的TCP重置</font><em><font style="vertical-align: inherit;">攻击</font></em><font style="vertical-align: inherit;">的变体复杂化</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RST段可接受的序列号</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果常规段的序列号在下一个预期序列号与该序列号之间加上窗口大小之间，则可以接受。但是，</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅在</font><font style="vertical-align: inherit;">数据包</font><font style="vertical-align: inherit;">的序列号</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一个预期序列号</font><em><font style="vertical-align: inherit;">完全相等</font></em><font style="vertical-align: inherit;">时才接收</font><font style="vertical-align: inherit;">数据包</font><font style="vertical-align: inherit;">。让我们回到前面的示例，在该示例中接收方发送了确认号15,000。对于</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要接收</font><font style="vertical-align: inherit;">的数据包</font><font style="vertical-align: inherit;">，其序列号必须恰好是15,000。如果接收方收到</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的序列号不等于15,000的段，则他将不接受它。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/596/b55/1d9596b55bb0ac4946ed16ff6b878dff.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果序列号在间隔之外，则接收器将完全忽略它。</font><font style="vertical-align: inherit;">但是，如果它在预期序列号的窗口内，则接收器发送“质询</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">”（“ ACK呼叫”）。</font><font style="vertical-align: inherit;">这是一个段，告诉发送方该段</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的序列号无效。</font><font style="vertical-align: inherit;">他还告诉发送者接收者期望的序列号。</font><font style="vertical-align: inherit;">发送者可以使用</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼叫中的</font><font style="vertical-align: inherit;">此信息</font><font style="vertical-align: inherit;">来重新创建并重新发送其信息</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
直到2010年，TCP才没有施加这些附加的段限制</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据与其他任何规则相同的规则，接受或拒绝</font><font style="vertical-align: inherit;">细分</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，这也简化了</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">盲目TCP重置攻击</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">盲目TCP攻击</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果攻击者能够拦截受害者之间交换的流量，则他可以读取受害者的TCP数据包的序列号和确认号。他可以使用此信息来选择要提供给他的假段的序列号</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是，如果攻击者无法拦截受害者的流量，他将不知道要插入哪个序列号。但是他仍然可以传输</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有任意数量的不同序列号的</font><font style="vertical-align: inherit;">任意数量的段</font><font style="vertical-align: inherit;">，希望其中之一被证明是正确的。这种攻击称为盲TCP重置攻击。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就像我们已经说过的那样，在TCP协议的初始版本中，攻击者只需获取序列号</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在接收者的TCP窗口中。</font><font style="vertical-align: inherit;">一篇标题为“在窗口中滑动”的文章表明，这使得盲目攻击变得太容易了，因为几乎可以肯定的成功是，攻击者只需发送成千上万个网段。</font><font style="vertical-align: inherit;">为了解决这个问题，强制接收者接受该段的规则</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">被上述更严格的标准所取代。</font><font style="vertical-align: inherit;">由于执行TCP重置攻击的新规则，数百万个段需要盲目发送，这使得它们实际上是无法实现的。</font><font style="vertical-align: inherit;">有关详细信息，请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC-5963</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对自己进行TCP重置攻击</font></font></h2><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：我在OSX上测试了此过程，但是收到一些评论，说它在Linux上无法正常工作。</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们了解了有关执行TCP重置攻击的所有信息。</font><font style="vertical-align: inherit;">攻击者必须：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">观察</font><font style="vertical-align: inherit;">两个受害者之间的</font><font style="vertical-align: inherit;">网络流量（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“嗅探”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">嗅探启用了标志的TCP段</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并读取其确认编号</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制作一个错误的TCP段，使其标志打开，</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且序列号等于所截获的段的确认编号（请注意，这意味着传输速度慢，否则所选的序列号将很快过时。（要增加成功的机会，您可以</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以较大的序列号间隔</font><font style="vertical-align: inherit;">传输多个段</font><font style="vertical-align: inherit;">）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将伪造的片段发送给一个或两个受害者，希望这能断开他们的TCP连接</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了练习，让我们在同一台计算机上对自己进行TCP攻击，并通过进行通信</font></font><code>localhost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为此，我们需要：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置两个终端窗口之间的TCP连接</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编写处理流量嗅探的攻击程序</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">修改程序，使其产生并发送假段</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们开始吧。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.在两个终端窗口之间建立TCP连接</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将使用工具配置TCP连接，该工具</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><code>netcat</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下可在许多操作系统上使用。</font><font style="vertical-align: inherit;">任何其他</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP客户端都可以</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在第一个终端窗口中，我们将执行以下命令：</font></font><br>
<br>
<blockquote><code>nc -nvl 8000</code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此命令启动一个TCP服务器，侦听我们本地计算机上的端口</font></font><code>8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在第二个终端窗口中，执行以下命令：</font></font><br>
<br>
<blockquote><code>nc 127.0.0.1 8000</code></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该命令尝试通过</font></font><code>127.0.0.1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">端口</font><font style="vertical-align: inherit;">的IP地址创建与计算机的TCP连接</font></font><code>8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在，在终端的两个窗口之间，应该建立一个TCP连接。</font><font style="vertical-align: inherit;">尝试在一个窗口中输入内容-数据将必须通过TCP连接传输并出现在另一窗口中。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/911/301/786/911301786c4f56287f80d38f67ef73f6.gif"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.流量监听</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将编写一个攻击程序，该程序使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><code>scapy</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流行的Python网络库</font><font style="vertical-align: inherit;">执行流量监听</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该程序使用scapy读取终端的两个窗口之间传输的数据，尽管它不是连接的一部分。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
程序代码发布在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我在GitHub上的存储库中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该程序将嗅探连接流量并将其显示在终端上。</font><font style="vertical-align: inherit;">该代码的主要核心是</font><font style="vertical-align: inherit;">位于文件末尾</font></font><code>sniff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的库中</font><font style="vertical-align: inherit;">的方法调用</font></font><code>scapy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="python hljs">t = sniff(<font></font>
        iface=<span class="hljs-string">'lo0'</span>,<font></font>
        lfilter=is_packet_tcp_client_to_server(localhost_ip, localhost_server_port, localhost_ip),<font></font>
        prn=log_packet,<font></font>
        count=<span class="hljs-number">50</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这段代码告诉我们</font></font><code>scapy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在接口上嗅探数据包</font></font><code>lo0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并捕获所有数据包的详细信息，这是我们TCP连接的一部分。</font><font style="vertical-align: inherit;">该调用具有以下参数：</font></font><br>
<br>
<ul>
<li><code>iface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-命令</font></font><code>scapy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">监听网络接口</font></font><code>lo0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或本地主机</font></font></li>
<li><code>lfilter</code> —  ,  <code>scapy</code>   ,      IP- localhost   .   ,        ,   <code>lo0</code>.     ,     .</li>
<li><code>prn</code> — ,  <code>scapy</code>     ,    <code>lfilter</code>.          .       ,      <code>RST</code>.</li>
<li><code>count</code> —  ,  <code>scapy</code>    .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要测试该程序，请从步骤1开始配置TCP连接。克隆我的GitHub存储库，按照配置说明进行操作，并在终端的第三个窗口中运行该程序。</font><font style="vertical-align: inherit;">在TCP连接的终端之一中输入一些文本。</font><font style="vertical-align: inherit;">您应该看到该程序将开始记录有关连接段的信息。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.发送假包裹 </font></font><code>RST</code></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们已经建立了连接，程序可以嗅探通过它的所有TCP段。我们剩下的唯一事情就是修改程序，使其通过传输假段来执行TCP重置攻击</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。为此，我们将更改功能</font></font><code>prn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（请参阅上面的参数列表），调用</font></font><code>scapy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">满足功能要求的软件包</font></font><code>lfilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在函数的修改版本中，我们研究它，提取必要的参数，然后使用这些参数来构建和发送该段，而不是简单地修复相应的包</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设我们截取了一个从</font></font><code>(src_ip, src_port)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k开始</font><font style="vertical-align: inherit;">的段</font></font><code>(dst_ip, dst_port)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。他设置</font></font><code>ACK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了</font><font style="vertical-align: inherit;">一个标志</font><font style="vertical-align: inherit;">，确认号为100,000。要制造和发送细分，我们：</font></font><br>
<br>
<ul>
<li>  IP-   ,    .  ,         .          ,  .</li>
<li>  <code>RST</code> ,     ,    <code>RST</code></li>
<li>        ,      ,    </li>
<li>  <code>send</code>  <code>scapy</code>     —   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要根据需要修改我们以前的程序，请取消注释</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该行</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并注释掉其上方的行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们准备进行全面攻击。</font><font style="vertical-align: inherit;">根据步骤1配置TCP连接。在终端的第三个窗口中，从步骤2运行攻击程序。</font><font style="vertical-align: inherit;">然后在TCP连接的终端之一中输入一些文本。</font><font style="vertical-align: inherit;">在您输入文本的终端中，TCP连接将突然神秘地断开。</font><font style="vertical-align: inherit;">攻击完成了！</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad9/2a2/b18/ad92a2b18c1533c47d88ab4ff10dedf7.gif"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进一步的工作</font></font></h3><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">继续尝试使用攻击工具。</font><font style="vertical-align: inherit;">跟踪如果从程序包的序列号中添加或减去1会发生什么</font></font><code>RST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">确保它必须</font><font style="vertical-align: inherit;">与</font><font style="vertical-align: inherit;">截获的数据包</font><font style="vertical-align: inherit;">的值</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相等</font></font><code>ack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li> Wireshark       <code>lo0</code>    .            TCP-,       <code>RST</code>.   <code>ip.src == 127.0.0.1 &amp;&amp; ip.dst == 127.0.0.1 &amp;&amp; tcp.port == 8000</code>       .</li>
<li>  ,      .           <code>RST</code>,       <code>RST</code>         ,      .   ,      <code>RST</code>,       .</li>
</ol><br>
<h2></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TCP重置攻击既深刻又简单。</font><font style="vertical-align: inherit;">祝您实验顺利，</font><font style="vertical-align: inherit;">如有疑问或意见</font><font style="vertical-align: inherit;">，请</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">告诉我</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN499884/index.html">我对CustDev的11件事</a></li>
<li><a href="../zh-CN499894/index.html">屋子里唱歌的东西。Chipolo ONE智能钥匙扣追踪器评测</a></li>
<li><a href="../zh-CN499896/index.html">我们正确地离开了远程站点：如何在Telegram中组织我们的工作和项目的工作？</a></li>
<li><a href="../zh-CN499898/index.html">IT人员与隔离的关系，他们在自我隔离中的工作以及使用的方法</a></li>
<li><a href="../zh-CN499900/index.html">产品分析工具：免费，非接触式，在线</a></li>
<li><a href="../zh-CN499904/index.html">“我很害怕”。该怎么办？</a></li>
<li><a href="../zh-CN499906/index.html">在玩具行业中使用AR的示例</a></li>
<li><a href="../zh-CN499908/index.html">深入探讨：如何在数字世界中实现选择自由</a></li>
<li><a href="../zh-CN499910/index.html">决策平衡。叉子“随机体验”</a></li>
<li><a href="../zh-CN499920/index.html">SSH小技巧</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>