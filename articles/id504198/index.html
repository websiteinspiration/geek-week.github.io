<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙁 🧖🏾 👌🏽 SwiftUI di rak: Animasi. Bagian 1 👨‍👨‍👦 🍙 ✅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini saya menemukan artikel baru di mana orang-orang mencoba mereproduksi konsep yang menarik menggunakan SwiftUI. Inilah yang mereka lakukan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SwiftUI di rak: Animasi. Bagian 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504198/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baru-baru ini saya menemukan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baru </font><font style="vertical-align: inherit;">di mana orang-orang mencoba mereproduksi konsep yang menarik menggunakan SwiftUI. Inilah yang mereka lakukan: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mempelajari kode mereka dengan penuh minat, tetapi mengalami frustrasi. Tidak, tidak dalam arti bahwa mereka melakukan sesuatu yang salah, tidak sama sekali. Saya hanya tidak belajar dari kode mereka praktis tidak ada yang baru. Implementasi mereka lebih tentang Combine daripada tentang animasi. Dan saya memutuskan untuk </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membangun lunopark</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk menulis artikel saya tentang animasi di SwiftUI, menerapkan konsep yang sama, tetapi menggunakan 100% kemampuan animasi built-in, walaupun itu tidak terlalu efektif. Belajar - sampai akhir. Untuk bereksperimen - begitu dengan binar :) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inilah yang saya dapat:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, untuk pengungkapan penuh topik, saya harus berbicara secara rinci tentang dasar-dasar. Teks itu ternyata sangat banyak, dan karena itu, saya memecahnya menjadi dua artikel. Ini adalah bagian pertama dari itu - lebih tepatnya, tutorial tentang animasi secara umum, tidak berhubungan langsung dengan animasi pelangi, yang akan saya bahas secara rinci di artikel selanjutnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada artikel ini, saya akan berbicara tentang dasar-dasar, yang tanpanya Anda dapat dengan mudah menjadi bingung dalam contoh yang lebih kompleks. Banyak hal yang akan saya bicarakan, dalam satu atau lain bentuk, telah dijelaskan dalam artikel berbahasa Inggris seperti seri ini ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Saya, di sisi lain, tidak terlalu fokus pada menyebutkan cara-cara bekerja seperti pada menggambarkan bagaimana tepatnya ini bekerja. </font><font style="vertical-align: inherit;">Dan seperti biasa, saya banyak bereksperimen, jadi saya segera berbagi hasil yang paling menarik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
peringatan: di bawah kucing ada banyak gambar dan animasi gif.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLDR</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proyek ini tersedia di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Anda dapat melihat hasil saat ini dengan animasi pelangi di TransitionRainbowView (), tapi saya tidak akan terburu-buru di tempat Anda, tetapi saya menunggu artikel berikutnya. </font><font style="vertical-align: inherit;">Selain itu, saat menyiapkannya, saya menyisir kode sedikit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada artikel ini, kami hanya akan membahas dasar-dasarnya, dan hanya memengaruhi konten folder Basa.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengantar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya akui, saya tidak akan menulis artikel ini sekarang. Saya punya rencana yang menurutnya artikel tentang animasi seharusnya yang ketiga atau bahkan keempat berturut-turut. Namun, saya tidak bisa menolak, saya benar-benar ingin memberikan sudut pandang alternatif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya ingin segera memesan. Saya tidak percaya bahwa ada kesalahan yang dibuat dalam artikel yang disebutkan, atau pendekatan yang digunakan di dalamnya tidak benar. Tidak semuanya. Itu membangun model objek dari proses (animasi), yang, menanggapi sinyal yang diterima, mulai melakukan sesuatu. Namun, bagi saya, artikel ini kemungkinan besar mengungkapkan kerja dengan kerangka kerja Combine. Ya, kerangka kerja ini adalah bagian penting dari SwiftUI, tetapi ini lebih tentang gaya yang bereaksi seperti pada umumnya daripada tentang animasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pilihan saya tentu tidak lebih elegan, lebih cepat dan lebih mudah dirawat. Namun, ini mengungkapkan jauh lebih baik apa yang ada di bawah naungan SwiftUI, dan memang inilah tujuan artikel - untuk mencari tahu dulu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang saya katakan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel sebelumnya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oleh SwiftUI, saya mulai terjun ke dunia pengembangan ponsel dengan SwiftUI, mengabaikan UIKit. Ini, tentu saja, memiliki harga, tetapi ada keuntungannya. Saya tidak mencoba untuk tinggal di biara baru sesuai dengan piagam lama. Jujur, saya belum tahu ada charter, jadi saya tidak punya penolakan terhadap yang baru. Itulah mengapa, artikel ini, bagi saya, dapat bernilai tidak hanya bagi pemula, seperti saya, tetapi juga bagi mereka yang mempelajari SwiftUI sudah memiliki latar belakang dalam bentuk pengembangan di UIKit. Menurut saya, banyak orang tidak memiliki tampilan yang segar. Jangan melakukan hal yang sama, mencoba memasukkan alat baru ke dalam gambar lama, tetapi ubah visi Anda sesuai dengan kemungkinan baru.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami 1c-toreukan melalui ini dengan "bentuk terkendali". Ini adalah semacam SwiftUI di dunia 1s, yang terjadi lebih dari 10 tahun yang lalu. Faktanya, analoginya cukup akurat, karena formulir yang dikelola hanyalah cara baru untuk menggambar antarmuka. Namun, ia benar-benar mengubah interaksi klien-server aplikasi secara keseluruhan, dan gambaran dunia di benak para pengembang pada khususnya. Ini tidak mudah, saya sendiri tidak mau mempelajarinya selama sekitar 5 tahun, karena Saya berpikir bahwa banyak peluang yang terputus hanya diperlukan untuk saya. Tetapi, seperti yang telah ditunjukkan oleh praktik, pengkodean pada formulir yang dikelola tidak hanya mungkin, tetapi hanya perlu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, jangan membicarakannya lagi. </font><font style="vertical-align: inherit;">Saya mendapatkan panduan yang terperinci dan independen yang tidak memiliki referensi, atau tautan lain dengan artikel yang disebutkan atau masa lalu yang ke-1. </font><font style="vertical-align: inherit;">Selangkah demi selangkah, kami akan menyelami detail, fitur, prinsip, dan batasan. </font><font style="vertical-align: inherit;">Pergilah.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bentuk Animasi</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana animasi bekerja secara umum</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, ide utama animasi adalah transformasi perubahan diskrit tertentu menjadi proses yang berkelanjutan. Misalnya, jari-jari lingkaran adalah 100 unit, menjadi 50 unit. Tanpa animasi, perubahan akan terjadi secara instan, dengan animasi - lancar. Bagaimana itu bekerja? Sangat sederhana. Untuk perubahan yang mulus, kita perlu menginterpolasi beberapa nilai dalam segmen "Itu ... Itu telah menjadi". Dalam hal jari-jari, kita harus menggambar beberapa lingkaran menengah dengan jari-jari 98 unit, 95 unit, 90 unit ... 53 unit dan, akhirnya, 50 unit. SwiftUI dapat melakukan ini dengan mudah dan alami, cukup bungkus kode yang melakukan perubahan ini denganAnimation {...}. Tampaknya ajaib ... Sampai Anda ingin menerapkan sesuatu yang sedikit lebih rumit daripada "halo dunia".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita beralih ke contoh. Objek paling sederhana dan paling mudah dipahami untuk animasi dianggap sebagai animasi bentuk. Bentuk (Saya masih akan memanggil struktur yang sesuai dengan protokol bentuk bentuk) di SwiftUI adalah struktur dengan parameter yang dapat masuk ke dalam batas-batas ini. Itu itu adalah struktur yang memiliki fungsi tubuh (rect: CGRect) -&gt; Path. Semua runtime yang diperlukan untuk menggambar formulir ini adalah untuk meminta garis besarnya (hasil fungsi adalah objek tipe Path, pada kenyataannya, itu adalah kurva Bezier) untuk ukuran yang diperlukan (ditentukan sebagai parameter fungsi, persegi panjang dari tipe CGRect).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bentuk adalah struktur yang disimpan. Dengan menginisialisasi itu, Anda menyimpan semua parameter yang Anda butuhkan untuk menggambar garis besarnya. Ukuran pemilihan untuk formulir ini dapat berubah, maka yang diperlukan hanyalah mendapatkan nilai Path baru untuk frame CGRect baru, dan voila. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita mulai mengkode:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">Circle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.green)<font></font>
            .frame(height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habra"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.gray)<font></font>
                )<font></font>
<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)<font></font>
            .frame(width: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>, height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habr"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.green)<font></font>
                )<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleTestView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">50</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">CircleView</span>(radius: radius)<font></font>
               .frame(height: <span class="hljs-number">200</span>)
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$radius, <span class="hljs-keyword">in</span>: <span class="hljs-number">42</span>...<span class="hljs-number">100</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.radius = <span class="hljs-number">50</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set default radius"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/pf/3j/eo/pf3jeo651jcwbhazddldv-rgxhy.gif"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, kita memiliki lingkaran (Lingkaran ()), jari-jari yang dapat kita ubah menggunakan penggeser. Ini terjadi dengan lancar, seperti slider memberi kita semua nilai perantara. Namun, ketika Anda mengklik tombol "set jari-jari default", perubahan itu juga tidak terjadi secara instan, tetapi sesuai dengan instruksi withAnimation (.linear (durasi: 1)). Linier, tanpa akselerasi, membentang selama 1 detik. Kelas! Kami menguasai animasinya! Kami tidak setuju :) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi bagaimana jika kami ingin menerapkan bentuk kami sendiri dan menghidupkan perubahannya? Apakah sulit melakukan ini? Mari kita periksa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya membuat salinan Lingkaran sebagai berikut:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{
        <span class="hljs-keyword">let</span> radius = <span class="hljs-built_in">min</span>(rect.width, rect.height) / <span class="hljs-number">2</span>
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: rect.width / <span class="hljs-number">2</span>, y: rect.height / <span class="hljs-number">2</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-type">Path</span>(){path <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> rect.width &gt; rect.height{<font></font>
                path.move(to: <span class="hljs-type">CGPoint</span>(x: center.x, y: <span class="hljs-number">0</span>))
                <span class="hljs-keyword">let</span> startAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
                path.addArc(center: center, radius: radius, startAngle: startAngle, endAngle:  startAngle + <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>), clockwise: <span class="hljs-literal">false</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                path.move(to: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: center.y))
                <span class="hljs-keyword">let</span> startAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
                path.addArc(center: center, radius: radius, startAngle: startAngle, endAngle:  startAngle + <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>), clockwise: <span class="hljs-literal">false</span>)<font></font>
            }<font></font>
            path.closeSubpath()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jari-jari lingkaran dihitung setengah lebih kecil dari lebar dan tinggi perbatasan area layar yang dialokasikan untuk kita. </font><font style="vertical-align: inherit;">Jika lebarnya lebih besar dari ketinggian, kita mulai dari tengah batas atas (Catatan 1), jelaskan lingkaran penuh dalam arah searah jarum jam (Catatan 2), dan tutup garis besar kami di sini. </font><font style="vertical-align: inherit;">Jika tingginya lebih besar dari lebar, kita mulai dari tengah batas kanan, kami juga menggambarkan lingkaran penuh searah jarum jam dan menutup kontur.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan 1</font></font></b>
                        <div class="spoiler_text">Apple     (  )  .  ,      (0, 0),         (x, y),  x —  ,  y —  . ..        y.   y —   .  ,        .  90    , 180  — , 270  — .</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan 2</font></font></b>
                        <div class="spoiler_text">   1   ,   “ ”  “ ”         .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"></a>  Core Graphics (SwiftUI      ):<br>
<blockquote>In a flipped coordinate system (the default for UIView drawing methods in iOS), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.</blockquote></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita periksa bagaimana lingkaran baru kita akan merespons perubahan di blok withAnimation:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)<font></font>
            .frame(width: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>, height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habr"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.green)<font></font>
                )<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleTestView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">50</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
                <span class="hljs-type">HStack</span>{
                <span class="hljs-type">CircleView</span>(radius: radius)<font></font>
                    .frame(height: <span class="hljs-number">200</span>)
                <span class="hljs-type">CustomCircleView</span>(radius: radius)<font></font>
                    .frame(height: <span class="hljs-number">200</span>)<font></font>
            }<font></font>
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$radius, <span class="hljs-keyword">in</span>: <span class="hljs-number">42</span>...<span class="hljs-number">100</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.radius = <span class="hljs-number">50</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set default radius"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/ba/qp/5obaqpgty5ckwvic5uxzscqtix4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wow! </font><font style="vertical-align: inherit;">Kami belajar cara membuat gambar bentuk bebas kami sendiri dan menghidupkannya! </font><font style="vertical-align: inherit;">Begitu? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak juga. </font><font style="vertical-align: inherit;">Semua pekerjaan di sini dilakukan oleh .frame modifier (lebar: self.radius * 2, tinggi: self.radius * 2). </font><font style="vertical-align: inherit;">Di dalam blok withAnimation {...} kita ubah</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Negara</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebuah variabel, ia mengirimkan sinyal untuk menginisialisasi ulang CustomCircleView () dengan nilai radius baru, nilai baru ini jatuh ke pengubah .frame (), dan pengubah ini sudah dapat menganimasikan perubahan parameter. Bentuk CustomCircle () kami bereaksi terhadap ini dengan animasi, karena itu tidak bergantung pada apa pun selain ukuran area yang dipilih untuk itu. Mengubah area terjadi dengan animasi, (mis. Secara bertahap, menginterpolasi nilai-nilai antara antara itu-telah menjadi), oleh karena itu lingkaran kami digambar dengan animasi yang sama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita sederhanakan (atau masih menyulitkan?) Bentuk kita sedikit. Kami tidak akan menghitung jari-jari berdasarkan ukuran area yang tersedia, tetapi kami akan mentransfer jari-jari dalam bentuk yang sudah jadi, yaitu. menjadikannya parameter struktur tersimpan.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{
        <span class="hljs-comment">//let radius = min(rect.width, rect.height) / 2</span><font></font>
...<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>(radius: radius)<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)
            <span class="hljs-comment">//.frame(height: self.radius * 2)</span><font></font>
...<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/g9/ju/pp/g9juppbsuti7iazguvffuy02fiu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nah, sihir itu hilang dan tidak dapat diperbaiki lagi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mengecualikan pengubah bingkai () dari CustomCircleView () kami, menggeser tanggung jawab untuk ukuran lingkaran ke bentuk itu sendiri, dan animasi menghilang. </font><font style="vertical-align: inherit;">Tapi itu tidak masalah, untuk mengajarkan formulir untuk menghidupkan perubahan dalam parameternya tidak terlalu sulit. </font><font style="vertical-align: inherit;">Untuk melakukan ini, Anda perlu menerapkan persyaratan protokol Animatable:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span>, <span class="hljs-title">Animatable</span></span>{
    <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span>{
         <span class="hljs-keyword">get</span>{<font></font>
             radius<font></font>
         }<font></font>
         <span class="hljs-keyword">set</span>{
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"new radius is \(newValue)"</span>)<font></font>
            radius = newValue<font></font>
         }<font></font>
     }<font></font>
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{<font></font>
	...<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/f1/1-/xs/f11-xshpugfdigdwhnle4nupbek.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voila! </font><font style="vertical-align: inherit;">Keajaiban kembali lagi! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan sekarang kita dapat dengan yakin mengatakan bahwa bentuk kita benar-benar animasi - ia dapat mencerminkan perubahan dalam parameternya dengan animasi. </font><font style="vertical-align: inherit;">Kami memberi sistem jendela di mana ia dapat menjejalkan nilai-nilai yang diinterpolasi yang diperlukan untuk animasi. </font><font style="vertical-align: inherit;">Jika ada jendela seperti itu, perubahan akan dianimasikan. </font><font style="vertical-align: inherit;">Jika tidak, perubahan dilakukan tanpa animasi, mis. </font><font style="vertical-align: inherit;">segera. </font><font style="vertical-align: inherit;">Tidak ada yang rumit, bukan?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AnimatableModifier</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara menghidupkan perubahan di dalam Tampilan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi mari kita langsung ke View. </font><font style="vertical-align: inherit;">Misalkan kita ingin menggerakkan posisi elemen di dalam wadah. </font><font style="vertical-align: inherit;">Dalam kasus kami, itu akan menjadi persegi panjang sederhana warna hijau dan lebar 10 unit. </font><font style="vertical-align: inherit;">Kami akan menghidupkan posisinya secara horizontal.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SimpleView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">ZStack</span>{
                <span class="hljs-type">Rectangle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.gray)
                <span class="hljs-type">BorderView</span>(position: position)<font></font>
            }<font></font>
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$position, <span class="hljs-keyword">in</span>: <span class="hljs-number">0</span>...<span class="hljs-number">1</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.position = <span class="hljs-number">0</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set to 0"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderView</span>: <span class="hljs-title">View</span>,  <span class="hljs-title">Animatable</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Reding position: \(position)"</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.position<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.position = newValue
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"setting position: \(position)"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">let</span> borderWidth: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">init</span>(position: <span class="hljs-type">CGFloat</span>, borderWidth: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">10</span>){
        <span class="hljs-keyword">self</span>.position = position
        <span class="hljs-keyword">self</span>.borderWidth = borderWidth
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"BorderView init"</span>)<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-keyword">self</span>.borderWidth)<font></font>
                .offset(x: <span class="hljs-keyword">self</span>.getXOffset(inSize: geometry.size), y: <span class="hljs-number">0</span>)
                <span class="hljs-comment">// .borderIn(position: position)</span><font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getXOffset</span><span class="hljs-params">(inSize: CGSize)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"calculating position: \(position)"</span>)
        <span class="hljs-keyword">return</span> -inSize.width / <span class="hljs-number">2</span> + inSize.width * position<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/7l/b-/pr/7lb-pry2ta71tvntbemngt8duts.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas! </font><font style="vertical-align: inherit;">Bekerja! </font><font style="vertical-align: inherit;">Sekarang kita tahu segalanya tentang animasi! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak juga. </font><font style="vertical-align: inherit;">Jika Anda melihat konsol, maka kita akan melihat yang berikut:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posisi </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
penghitungan </font><font style="vertical-align: inherit;">init BorderView </font><font style="vertical-align: inherit;">: 0,4595176577568054 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Posisi </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
penghitungan </font><font style="vertical-align: inherit;">init </font><font style="vertical-align: inherit;">BorderView: 0,468130886554718 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Posisi </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
penghitungan </font><font style="vertical-align: inherit;">init BorderView </font><font style="vertical-align: inherit;">: 0,0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, setiap perubahan dalam nilai posisi menggunakan slider menyebabkan BorderView menginisialisasi ulang dengan nilai baru. Itulah mengapa kita melihat pergerakan garis hijau yang mulus setelah slider, slider hanya sangat sering melaporkan perubahan variabel, dan itu terlihat seperti animasi, tetapi tidak. Menggunakan bilah geser sangat mudah saat Anda men-debug animasi. Anda dapat menggunakannya untuk melacak beberapa kondisi transisi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kedua, kita melihat bahwa posisi penghitungan hanya menjadi sama dengan 0, dan tidak ada log perantara, seperti halnya dengan animasi lingkaran yang benar. Mengapa?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya, seperti pada contoh sebelumnya, ada di pengubah. </font><font style="vertical-align: inherit;">Kali ini, pengubah .offset () mendapatkan nilai indentasi baru, dan ia menghidupkan perubahan itu sendiri. </font><font style="vertical-align: inherit;">Itu </font><font style="vertical-align: inherit;">sebenarnya, itu bukan perubahan pada parameter posisi yang kami maksudkan untuk animasi, tetapi perubahan horisontal dari indentasi dalam pengubah .offset () yang diturunkan darinya. </font><font style="vertical-align: inherit;">Dalam hal ini, ini adalah pengganti yang tidak berbahaya, hasilnya sama. </font><font style="vertical-align: inherit;">Tetapi karena mereka telah datang, mari kita menggali lebih dalam. </font><font style="vertical-align: inherit;">Mari kita buat pengubah kita sendiri, yang akan menerima posisi (dari 0 hingga 1) pada input, itu akan menerima ukuran area yang tersedia dan menghitung indentasi.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderPosition</span>: <span class="hljs-title">ViewModifier</span></span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span><font></font>
            content<font></font>
            .offset(x: <span class="hljs-keyword">self</span>.getXOffset(inSize: geometry.size), y: <span class="hljs-number">0</span>)<font></font>
            .animation(<span class="hljs-literal">nil</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getXOffset</span><span class="hljs-params">(inSize: CGSize)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-keyword">let</span> offset = -inSize.width / <span class="hljs-number">2</span> + inSize.width * position
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"at position  \(position) offset is \(offset)"</span>)
        <span class="hljs-keyword">return</span> offset<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">borderIn</span><span class="hljs-params">(position: CGFloat)</span></span> -&gt; some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">BorderPosition</span>(position: position))<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di BorderView asli, masing-masing, GeometryReader tidak lagi diperlukan, serta fungsi untuk menghitung indentasi:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderView</span>: <span class="hljs-title">View</span>,  <span class="hljs-title">Animatable</span></span>{<font></font>
    ...<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-keyword">self</span>.borderWidth)<font></font>
                .borderIn(position: position)<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hd/3i/r0/hd3ir0e-_jji7qwiasacdwpnpx4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya, kami masih menggunakan pengubah .offset () di dalam pengubah kami, tetapi setelah itu kami menambahkan pengubah .animation (nil), yang memblokir animasi offset kami sendiri. </font><font style="vertical-align: inherit;">Saya mengerti bahwa pada tahap ini Anda dapat memutuskan bahwa cukup untuk menghapus kunci ini, tetapi kemudian kita tidak akan sampai ke dasar kebenaran. </font><font style="vertical-align: inherit;">Dan kebenarannya adalah bahwa trik kami dengan data animatable untuk BorderView tidak berfungsi. </font><font style="vertical-align: inherit;">Bahkan, jika Anda melihat dokumentasi untuk protokol </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animatable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Anda akan melihat bahwa implementasi protokol ini hanya didukung untuk AnimatableModifier, GeometryEffect, dan Shape. </font><font style="vertical-align: inherit;">Lihat tidak ada di antara mereka.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendekatan yang tepat adalah menghidupkan modifikasi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendekatan itu sendiri, ketika kami meminta Lihat untuk menganimasi beberapa perubahan, salah. </font><font style="vertical-align: inherit;">Untuk tampilan, Anda tidak bisa menggunakan pendekatan yang sama seperti untuk formulir. </font><font style="vertical-align: inherit;">Sebagai gantinya, animasi harus disematkan di setiap pengubah. </font><font style="vertical-align: inherit;">Sebagian besar pengubah bawaan sudah mendukung animasi di luar kotak. </font><font style="vertical-align: inherit;">Jika Anda ingin animasi untuk pengubah Anda sendiri, Anda dapat menggunakan protokol AnimatableModifier alih-alih ViewModifier. </font><font style="vertical-align: inherit;">Dan di sana Anda dapat menerapkan hal yang sama seperti ketika animasi perubahan bentuk, seperti yang kami lakukan di atas.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderPosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> startDate: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"reading position: \(position) at time \(Date().timeIntervalSince(startDate))"</span>)
            <span class="hljs-keyword">return</span> position<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {<font></font>
            position = newValue<font></font>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"setting position: \(position) at time \(Date().timeIntervalSince(startDate))"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
...<font></font>
    }<font></font>
    ...<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/p2/l3/ys/p2l3yslis_hirenud-lpkt8xaoa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang semuanya benar. </font><font style="vertical-align: inherit;">Pesan di konsol membantu untuk memahami bahwa animasi kami benar-benar berfungsi, dan .animation (nil) di dalam pengubah tidak mengganggu sama sekali. </font><font style="vertical-align: inherit;">Tapi mari kita cari tahu bagaimana cara kerjanya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, Anda perlu memahami apa itu pengubah.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita memiliki pandangan. Seperti yang saya katakan di bagian sebelumnya, ini adalah struktur dengan parameter yang tersimpan dan instruksi perakitan. Instruksi ini, pada umumnya, tidak mengandung urutan tindakan, yang merupakan kode biasa yang kita tulis dalam gaya non-deklaratif, tetapi daftar sederhana. Ini mencantumkan View lainnya, pengubah yang diterapkan padanya, dan wadah di mana mereka disertakan. Kami belum tertarik pada wadah, tetapi mari kita bicara lebih lanjut tentang pengubah.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengubah lagi struktur dengan parameter yang disimpan, dan Lihat instruksi pemrosesan. </font><font style="vertical-align: inherit;">Ini sebenarnya instruksi yang sama dengan View - kita dapat menggunakan pengubah lain, menggunakan wadah (misalnya, saya menggunakan GeometryReader sedikit lebih tinggi) dan bahkan View lainnya. </font><font style="vertical-align: inherit;">Tetapi kami hanya memiliki konten yang masuk, dan kami perlu mengubahnya menggunakan instruksi ini. </font><font style="vertical-align: inherit;">Parameter pengubah adalah bagian dari instruksi. </font><font style="vertical-align: inherit;">Tetapi yang paling menarik adalah mereka disimpan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam artikel sebelumnya, saya mengatakan bahwa instruksi itu sendiri tidak disimpan, bahwa itu dilemparkan setiap kali setelah Lihat diperbarui. </font><font style="vertical-align: inherit;">Semuanya begitu, tetapi ada nuansa. </font><font style="vertical-align: inherit;">Sebagai hasil dari pekerjaan instruksi ini, kami tidak mendapatkan gambaran yang cukup, seperti yang saya katakan sebelumnya - itu adalah penyederhanaan. </font><font style="vertical-align: inherit;">Pengubah tidak hilang setelah pengoperasian instruksi ini. </font><font style="vertical-align: inherit;">Mereka tetap demikian sementara View induk ada.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa analogi primitif</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana kita menggambarkan tabel dengan gaya deklaratif? </font><font style="vertical-align: inherit;">Baiklah, kita akan mendaftar 4 kaki dan meja. </font><font style="vertical-align: inherit;">Mereka akan menggabungkan mereka ke dalam semacam wadah, dan dengan bantuan beberapa pengubah akan menentukan bagaimana mereka diikat satu sama lain. </font><font style="vertical-align: inherit;">Misalnya, setiap kaki akan menunjukkan orientasi sehubungan dengan meja, dan posisi - kaki mana yang disematkan ke sudut mana. </font><font style="vertical-align: inherit;">Ya, kita bisa membuang instruksi setelah perakitan, tetapi paku akan tetap ada di meja. </font><font style="vertical-align: inherit;">Begitu juga para modifikator. </font><font style="vertical-align: inherit;">Saat keluar dari fungsi tubuh, kita belum cukup meja. </font><font style="vertical-align: inherit;">Menggunakan body, kami membuat elemen tabel (tampilan), dan pengencang (pengubah), dan meletakkan semuanya di laci. </font><font style="vertical-align: inherit;">Meja itu sendiri dirakit oleh robot. </font><font style="vertical-align: inherit;">Pengencang apa yang Anda masukkan ke dalam kotak untuk setiap kaki, Anda akan mendapatkan meja seperti itu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi .modifier (BorderPosition (position: position)), yang dengannya kami mengubah struktur BorderPosition menjadi pengubah, hanya menempatkan sekrup tambahan di laci ke kaki meja. Struktur BorderPosition adalah sekrup ini. Render, pada saat rendering, mengambil kotak ini, mengeluarkan leg darinya (Rectangle () dalam kasus kami), dan secara berurutan mendapatkan semua pengubah dari daftar, dengan nilai yang tersimpan di dalamnya. Fungsi tubuh masing-masing pengubah adalah instruksi tentang cara mengencangkan kaki ke atas meja dengan sekrup ini, dan struktur itu sendiri dengan sifat yang disimpan, ini adalah sekrup itu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa penting untuk memahami ini dalam konteks animasi? Karena animasi memungkinkan Anda untuk mengubah parameter dari satu pengubah tanpa mempengaruhi yang lain, dan kemudian membuat ulang gambar. Jika Anda melakukan hal yang sama dengan mengubah beberapa</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameter - ini akan menyebabkan reinisialisasi View bersarang, struktur pengubah, dan sebagainya, di sepanjang rantai. Tapi animasinya tidak. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan, ketika kita mengubah nilai posisi ketika kita menekan tombol, itu berubah. Sampai akhir. Tidak ada status peralihan disimpan dalam variabel itu sendiri, yang tidak dapat dikatakan tentang pengubah. Untuk setiap bingkai baru, nilai-nilai parameter pengubah berubah sesuai dengan kemajuan animasi saat ini. Jika animasi berlangsung 1 detik, maka setiap 1/60 detik (iphone menunjukkan jumlah frame per detik), nilai animatableData di dalam pengubah akan berubah, maka akan dibaca oleh render untuk rendering, setelah itu, setelah 1/60 detik lainnya akan menjadi diubah lagi, dan baca lagi oleh render.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa karakteristiknya, pertama-tama kita mendapatkan keadaan akhir dari seluruh Tampilan, mengingatnya, dan baru kemudian mekanisme animasi mulai membuka nilai posisi yang diinterpolasi ke dalam pengubah. Keadaan awal tidak disimpan di mana pun. Di suatu tempat di perut SwiftUI, hanya perbedaan antara kondisi awal dan akhir yang disimpan. Perbedaan ini setiap kali dikalikan dengan sebagian kecil dari waktu yang telah berlalu. Ini adalah bagaimana nilai interpolasi dihitung, yang kemudian diganti menjadi data animatable. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perbedaan = </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baja </font></font><br><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">- Apakah </font></i><i><font style="vertical-align: inherit;">Nilai Saat Ini = Baja - Perbedaan * (1 - Waktu Berlalu) </font></i><i><font style="vertical-align: inherit;">
Waktu Berlalu = Waktu Dari MulaiAnimasi / DurasiAnimasi Nilai</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
saat ini perlu dihitung berapa kali dari jumlah frame yang perlu kami tampilkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa "Apakah" tidak digunakan secara eksplisit? Faktanya adalah bahwa SwiftUI tidak menyimpan keadaan awal. Hanya perbedaan yang disimpan: jadi, jika terjadi beberapa jenis kegagalan, Anda dapat mematikan animasi, dan pergi ke keadaan "menjadi" saat ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendekatan ini memungkinkan Anda untuk membuat animasi dapat dibalik. Misalkan, di suatu tempat di tengah satu animasi, pengguna menekan tombol lagi, dan kami lagi mengubah nilai variabel yang sama. Dalam hal ini, yang perlu kita lakukan untuk mengalahkan perubahan ini dengan indah adalah mengambil "Current" di dalam animasi pada saat perubahan baru sebagai "It", mengingat Perbedaan baru, dan memulai animasi baru berdasarkan "Became" baru dan "Perbedaan" baru. . Ya, pada kenyataannya, transisi dari satu animasi ke animasi lain ini mungkin sedikit lebih sulit untuk mensimulasikan inersia, tetapi artinya, saya pikir, dapat dimengerti.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang menarik adalah bahwa animasi setiap frame meminta nilai saat ini di dalam pengubah (menggunakan pengambil). Ini, seperti yang Anda lihat dari catatan layanan di log, bertanggung jawab atas status "Baja". Kemudian, menggunakan setter, kita mengatur status baru yang berlaku untuk frame ini. Setelah itu, untuk frame berikutnya, nilai saat ini dari modifier kembali diminta - dan lagi "Telah menjadi", yaitu. Nilai akhir animasi bergerak. Sangat mungkin bahwa salinan struktur pengubah digunakan untuk animasi, dan pengambil satu struktur (pengubah nyata dari Tampilan aktual) digunakan untuk mendapatkan nilai "Baja", dan satu setter lainnya (pengubah sementara yang digunakan untuk animasi) digunakan. Saya belum menemukan cara untuk memastikan hal ini, tetapi dengan indikasi tidak langsung semuanya terlihat seperti itu. Bagaimanapun,perubahan dalam animasi tidak memengaruhi nilai tersimpan dari struktur pengubah dari Tampilan saat ini. Jika Anda memiliki ide tentang bagaimana mencari tahu persis apa yang sebenarnya terjadi dengan pengambil dan penyetel, tulis tentang itu di komentar, saya akan memperbarui artikel.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa parameter</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hingga saat ini, kami hanya memiliki satu parameter untuk animasi. </font><font style="vertical-align: inherit;">Mungkin timbul pertanyaan, tetapi bagaimana jika lebih dari satu parameter diteruskan ke pengubah? </font><font style="vertical-align: inherit;">Dan apakah keduanya perlu dianimasikan pada saat bersamaan? </font><font style="vertical-align: inherit;">Begini caranya dengan pengubah bingkai (width: height :) misalnya. </font><font style="vertical-align: inherit;">Bagaimanapun, kita dapat secara bersamaan mengubah lebar dan tinggi Tampilan ini, dan kami ingin perubahan terjadi dalam satu animasi, bagaimana cara melakukannya? </font><font style="vertical-align: inherit;">Lagipula, parameter AnimatableData adalah satu, apa yang harus diganti?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda melihat, Apple hanya memiliki satu persyaratan untuk data animatable. Tipe data yang Anda gantikan harus memenuhi protokol VectorArithmetic. Protokol ini mensyaratkan objek untuk memastikan operasi aritmatika minimum yang diperlukan untuk dapat membentuk segmen dua nilai, dan menginterpolasi titik-titik di dalam segmen ini. Operasi yang diperlukan untuk ini adalah penjumlahan, pengurangan dan penggandaan. Kesulitannya adalah kita harus melakukan operasi ini dengan satu objek yang menyimpan beberapa parameter. Itu kita harus mengemas seluruh daftar parameter kita dalam wadah yang akan menjadi vektor. Apple menyediakan objek seperti itu di luar kotak, dan menawarkan kami untuk menggunakan solusi turnkey untuk kasus yang tidak terlalu sulit. Ini disebut AnimatablePair.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita ubah tugas sedikit. </font><font style="vertical-align: inherit;">Kami membutuhkan pengubah baru yang tidak hanya akan memindahkan bilah hijau, tetapi juga mengubah ketinggiannya. </font><font style="vertical-align: inherit;">Ini akan menjadi dua parameter pengubah independen. </font><font style="vertical-align: inherit;">Saya tidak akan memberikan kode lengkap dari semua perubahan yang perlu dilakukan, Anda bisa melihatnya di github di file SimpleBorderMove. </font><font style="vertical-align: inherit;">Saya hanya akan menampilkan pengubah itu sendiri:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TwoParameterBorder</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> startDate: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">AnimatablePair</span>&lt;<span class="hljs-type">CGFloat</span>, <span class="hljs-type">CGFloat</span>&gt; {
        <span class="hljs-keyword">get</span> {
           <span class="hljs-built_in">print</span>(<span class="hljs-string">"animation read position: \(position), height: \(height)"</span>)
           <span class="hljs-keyword">return</span> <span class="hljs-type">AnimatablePair</span>(position, height)<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.position = newValue.first
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"animating position at \(position)"</span>)
            <span class="hljs-keyword">self</span>.height = newValue.second
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"animating height at \(height)"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(position: <span class="hljs-type">CGFloat</span>, height: <span class="hljs-type">CGFloat</span>){
        <span class="hljs-keyword">self</span>.position = position
        <span class="hljs-keyword">self</span>.height = height<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span><font></font>
            content<font></font>
                .animation(<span class="hljs-literal">nil</span>)<font></font>
                .offset(x: -geometry.size.width / <span class="hljs-number">2</span> + geometry.size.width * <span class="hljs-keyword">self</span>.position, y: <span class="hljs-number">0</span>)<font></font>
                .frame(height: <span class="hljs-keyword">self</span>.height * (geometry.size.height - <span class="hljs-number">20</span>) + <span class="hljs-number">20</span>)<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vn/0q/mi/vn0qmirl31w63mzgjvijsw-f-ps.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menambahkan bilah geser lain dan tombol untuk mengubah kedua parameter sekaligus secara acak di tampilan induk dari SimpleView, tetapi tidak ada yang menarik, jadi untuk kode lengkap, selamat datang di github. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya berfungsi, kami benar-benar mendapatkan perubahan yang konsisten dalam pasangan parameter yang dikemas dalam tuple AnimatablePair. </font><font style="vertical-align: inherit;">Tidak buruk. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak ada yang membingungkan dalam implementasi ini? </font><font style="vertical-align: inherit;">Secara pribadi, saya tegang ketika saya melihat desain ini:</font></font><br>
<br>
<pre><code class="swift hljs">        
<span class="hljs-keyword">self</span>.position = newValue.first
<span class="hljs-keyword">self</span>.height = newValue.second
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak menunjukkan di mana pun parameter mana yang harus menjadi yang pertama dan yang kedua. Bagaimana SwiftUI memutuskan nilai mana yang harus dimasukkan pertama dan nilai mana yang kedua? Nah, bukankah itu cocok dengan nama-nama parameter fungsi dengan nama-nama atribut struktur?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gagasan pertama adalah urutan atribut dalam parameter fungsi dan tipenya, seperti yang terjadi pada @EnvironmentObject. Di sana, kita cukup meletakkan nilai-nilai di dalam kotak, tanpa memberi mereka label, dan kemudian kita mengeluarkannya, juga tanpa menunjukkan label apa pun. Di sana, ketik penting, dan dalam satu jenis, pesan. Dalam urutan apa mereka dimasukkan ke dalam kotak, dengan cara yang sama dan mendapatkannya. Saya mencoba urutan berbeda dari argumen fungsi, urutan argumen untuk menginisialisasi struktur, urutan atribut struktur itu sendiri, umumnya membenturkan kepala saya ke dinding, tetapi tidak dapat membingungkan SwiftUI sehingga mulai menganimasikan posisi dengan nilai ketinggian dan sebaliknya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian saya sadar. Saya sendiri menunjukkan parameter mana yang akan menjadi yang pertama dan yang kedua dalam pengambil. SwiftUI tidak perlu tahu persis bagaimana kita menginisialisasi struktur ini. Itu bisa mendapatkan nilai animatableData sebelum perubahan, mendapatkannya setelah perubahan, menghitung perbedaan di antara mereka, dan mengembalikan perbedaan yang sama, diskalakan proporsional dengan interval waktu yang telah berlalu, ke penyetel kami. Secara umum tidak perlu tahu apa-apa tentang nilai itu sendiri di dalam AnimatableData. Dan jika Anda tidak membingungkan urutan variabel dalam dua baris yang berdekatan, maka semuanya akan berurutan, tidak peduli betapa rumitnya struktur dari sisa kode. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi mari kita periksa. Bagaimanapun, kita dapat membuat vektor penampung kita sendiri (oh, aku menyukainya, buat implementasi kita sendiri dari objek yang ada, Anda mungkin telah memperhatikan ini dari artikel sebelumnya).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ao/v4/an/aov4an8tjqou27syes6klcckwy0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menggambarkan struktur dasar, menyatakan dukungan untuk protokol VectorArithmetic, membuka kesalahan tentang protokol yang tidak sesuai, klik perbaikan, dan kami mendapatkan deklarasi dari semua fungsi yang diperlukan dan parameter yang dihitung. </font><font style="vertical-align: inherit;">Tinggal mengisi saja. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan cara yang sama, kita mengisi objek kita dengan metode yang diperlukan untuk protokol AdditiveArithmetic (VectorArithmetic menyertakan dukungannya).</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyAnimatableVector</span>: <span class="hljs-title">VectorArithmetic</span></span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> - <span class="hljs-params">(lhs: MyAnimatableVector, rhs: MyAnimatableVector)</span></span> -&gt; <span class="hljs-type">MyAnimatableVector</span> {
        <span class="hljs-type">MyAnimatableVector</span>(position: lhs.position - rhs.position, height: lhs.height - rhs.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> + <span class="hljs-params">(lhs: MyAnimatableVector, rhs: MyAnimatableVector)</span></span> -&gt; <span class="hljs-type">MyAnimatableVector</span> {
        <span class="hljs-type">MyAnimatableVector</span>(position: lhs.position + rhs.position, height: lhs.height + rhs.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scale</span><span class="hljs-params">(by rhs: Double)</span></span> {
        <span class="hljs-keyword">self</span>.position = <span class="hljs-keyword">self</span>.position * <span class="hljs-type">CGFloat</span>(rhs)
        <span class="hljs-keyword">self</span>.height = <span class="hljs-keyword">self</span>.height * <span class="hljs-type">CGFloat</span>(rhs)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> magnitudeSquared: <span class="hljs-type">Double</span>{
         <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.position * <span class="hljs-keyword">self</span>.position) + <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.height * <span class="hljs-keyword">self</span>.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> zero: <span class="hljs-type">MyAnimatableVector</span>{
        <span class="hljs-type">MyAnimatableVector</span>(position: <span class="hljs-number">0</span>, height: <span class="hljs-number">0</span>)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">CGFloat</span>
}</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya pikir mengapa kita membutuhkan + dan - jelas. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">skala adalah fungsi penskalaan. </font><font style="vertical-align: inherit;">Kami mengambil perbedaan "Itu - Itu telah menjadi" dan kalikan dengan tahap animasi saat ini (dari 0 ke 1). </font><font style="vertical-align: inherit;">"Itu menjadi + Perbedaan * (1 - Tahap)" dan akan ada nilai saat ini yang harus kita telusuri di animatableData</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nol mungkin diperlukan untuk menginisialisasi objek baru yang nilainya akan digunakan untuk animasi. </font><font style="vertical-align: inherit;">Animasi menggunakan .zero di awal, tapi saya tidak tahu persis bagaimana caranya. </font><font style="vertical-align: inherit;">Namun, saya tidak berpikir ini penting.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">magnitudeSquared adalah produk skalar dari vektor yang diberikan dengan dirinya sendiri. </font><font style="vertical-align: inherit;">Untuk ruang dua dimensi, ini berarti panjang vektor kuadrat. </font><font style="vertical-align: inherit;">Ini mungkin digunakan untuk dapat membandingkan dua objek satu sama lain, bukan secara elemen, tetapi secara keseluruhan. </font><font style="vertical-align: inherit;">Tampaknya tidak digunakan untuk tujuan animasi.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, fungsi “- =” “+ =” juga termasuk dalam dukungan protokol, tetapi untuk struktur mereka dapat dihasilkan secara otomatis dalam formulir ini.</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> -= <span class="hljs-params">(lhs: <span class="hljs-keyword">inout</span> MyAnimatableVector, rhs: MyAnimatableVector)</span></span> {<font></font>
        lhs = lhs - rhs<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> += <span class="hljs-params">(lhs: <span class="hljs-keyword">inout</span> MyAnimatableVector, rhs: MyAnimatableVector)</span></span> {<font></font>
        lhs = lhs + rhs<font></font>
    }<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk lebih jelasnya, saya menjabarkan semua logika ini dalam bentuk diagram. </font><font style="vertical-align: inherit;">
Gambar bisa diklik. </font><font style="vertical-align: inherit;">
Apa yang kita dapatkan selama animasi disorot dalam warna merah - setiap centang berikutnya (1/60 detik) timer memberi nilai t baru, dan kami, dalam setter pengubah kami, mendapatkan nilai baru data animatable. </font><font style="vertical-align: inherit;">Begitulah cara animasi bekerja di bawah tenda. </font><font style="vertical-align: inherit;">Pada saat yang sama, penting untuk memahami bahwa pengubah adalah struktur yang tersimpan, dan salinan pengubah saat ini dengan keadaan saat ini yang baru digunakan untuk menampilkan animasi.</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/zl/ag/q4/zlagq42atcapum-br2sj00ikubu.png"></a><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa AnimatableData hanya bisa menjadi struktur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada satu hal lagi. Anda tidak bisa menggunakan kelas sebagai objek AnimatableData. Secara formal, Anda bisa mendeskripsikan untuk kelas semua metode yang diperlukan dari protokol terkait, tetapi ini tidak akan lepas landas, dan inilah sebabnya. Seperti yang Anda ketahui, kelas adalah tipe data referensi, dan struktur adalah tipe data berbasis nilai. Ketika Anda membuat satu variabel berdasarkan yang lain, dalam kasus kelas, Anda menyalin tautan ke objek ini, dan dalam kasus struktur, Anda membuat objek baru berdasarkan nilai-nilai yang sudah ada. Berikut adalah contoh kecil yang menggambarkan perbedaan ini:</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TestStruct</span></span>{
        <span class="hljs-keyword">var</span> value: <span class="hljs-type">CGFloat</span>
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scaled</span><span class="hljs-params">(by: CGFloat)</span></span>{
            <span class="hljs-keyword">self</span>.value = <span class="hljs-keyword">self</span>.value * by<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span></span>{
        <span class="hljs-keyword">var</span> value: <span class="hljs-type">CGFloat</span>
        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scaled</span><span class="hljs-params">(by: CGFloat)</span></span>{
             <span class="hljs-keyword">self</span>.value = <span class="hljs-keyword">self</span>.value * by<font></font>
        }<font></font>
        <span class="hljs-keyword">init</span>(value: <span class="hljs-type">CGFloat</span>){
            <span class="hljs-keyword">self</span>.value = value<font></font>
        }<font></font>
    }<font></font>
        <span class="hljs-keyword">var</span> stA = <span class="hljs-type">TestStruct</span>(value: <span class="hljs-number">5</span>)
        <span class="hljs-keyword">var</span> stB = stA<font></font>
        stB.scaled(by: <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"structs: a = \(stA.value), b = \(stB.value))"</span>) <span class="hljs-comment">//structs: a = 5.0, b = 10.0)</span>
        <span class="hljs-keyword">var</span> clA = <span class="hljs-type">TestClass</span>(value: <span class="hljs-number">5</span>)
        <span class="hljs-keyword">var</span> clB = clA<font></font>
        clB.scaled(by: <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"classes: a = \(clA.value), b = \(clB.value))"</span>) <span class="hljs-comment">//classes: a = 10.0, b = 10.0)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan animasi hal yang persis sama terjadi. Kami memiliki objek AnimatableData yang mewakili perbedaan antara "dulu" dan "menjadi". Kita perlu menghitung bagian dari perbedaan ini untuk mencerminkan di layar. Untuk melakukan ini, kita harus menyalin perbedaan ini dan mengalikannya dengan angka yang mewakili tahap animasi saat ini. Dalam kasus struktur, ini tidak akan mempengaruhi perbedaan itu sendiri, tetapi dalam kasus kelas itu akan. Frame pertama yang kita gambar adalah status "tadinya". Untuk melakukan ini, kita perlu menghitung Baja + Perbedaan * Tahap Saat Ini - Perbedaan. Dalam kasus kelas, dalam frame pertama kita mengalikan selisihnya dengan 0, memusatkannya, dan semua frame berikutnya digambar sehingga perbedaannya = 0. i.e. animasi tampaknya digambar dengan benar, tetapi sebenarnya kita melihat transisi instan dari satu negara ke yang lain, seolah-olah tidak ada animasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda mungkin dapat menulis semacam kode tingkat rendah yang membuat alamat memori baru untuk hasil perkalian - tetapi mengapa? </font><font style="vertical-align: inherit;">Anda bisa menggunakan struktur - mereka dibuat untuk itu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagi mereka yang ingin benar-benar memahami bagaimana SwiftUI menghitung nilai-nilai perantara, dengan operasi apa dan pada saat apa, </font><font style="vertical-align: inherit;">pesan-pesan didorong ke konsol </font><font style="vertical-align: inherit;">dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proyek</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Selain itu, saya memasukkan sleep 0,1 detik di sana untuk mensimulasikan perhitungan sumber daya intensif di dalam animasi, bersenang-senang :)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animasi layar: .transition ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hingga saat ini, kami berbicara tentang menghidupkan perubahan dalam nilai yang diteruskan ke pengubah atau formulir. Ini adalah alat yang sangat kuat. Tetapi ada alat lain yang juga menggunakan animasi - ini adalah animasi dari tampilan dan hilangnya View. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam artikel terakhir, kita berbicara tentang fakta bahwa dalam gaya deklaratif if-else, ini sama sekali tidak mengontrol aliran kode dalam runtime, melainkan pandangan Schrödinger. Ini adalah wadah yang berisi dua Tampilan pada saat yang sama, yang memutuskan mana yang akan ditampilkan sesuai dengan kondisi tertentu. Jika Anda melewatkan blok lain, maka EmptyView ditampilkan, bukan tampilan kedua. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beralih di antara dua Tampilan juga dapat dianimasikan. Untuk melakukan ini, gunakan pengubah .transition ().</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TransitionView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">let</span> views: [<span class="hljs-type">AnyView</span>] = [<span class="hljs-type">AnyView</span>(<span class="hljs-type">CustomCircleTestView</span>()), <span class="hljs-type">AnyView</span>(<span class="hljs-type">SimpleBorderMove</span>())]<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> currentViewInd = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">ZStack</span>{
                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                        }<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-type">HStack</span>{
                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">10</span>)<font></font>
                        .fill(ind == <span class="hljs-keyword">self</span>.currentViewInd ? <span class="hljs-type">Color</span>.green : <span class="hljs-type">Color</span>.gray)<font></font>
                        .overlay(<font></font>
                            <span class="hljs-type">Text</span>(<span class="hljs-string">"\(ind + Int(1))"</span>))<font></font>
                        .onTapGesture{<font></font>
                            withAnimation{<font></font>
                                <span class="hljs-keyword">self</span>.currentViewInd = ind<font></font>
                            }<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
                .frame(height: <span class="hljs-number">50</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita perhatikan cara kerjanya. Pertama-tama, di muka, bahkan pada tahap inisialisasi dari tampilan induk, kami membuat dan menempatkan beberapa Tampilan dalam array. Array bertipe AnyView, karena elemen array harus memiliki tipe yang sama, jika tidak mereka tidak dapat digunakan di ForEach. Jenis hasil buram dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebelumnya </font><font style="vertical-align: inherit;">, ingat? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, kami menentukan enumerasi indeks array ini, dan untuk masing-masing indeks kami tampilkan tampilan dengan indeks ini. Kami terpaksa melakukan ini, dan tidak langsung beralih dari View, karena untuk bekerja dengan ForEach, kami perlu menetapkan pengenal internal untuk setiap elemen sehingga SwiftUI dapat beralih pada konten koleksi. Sebagai alternatif, kita harus membuat pengidentifikasi proksi di setiap Tampilan, tetapi mengapa, jika indeks dapat digunakan?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami membungkus setiap tampilan dari koleksi dalam suatu kondisi, dan menunjukkannya hanya jika itu aktif. Namun, jika konstruksi lain tidak bisa ada di sini, kompiler akan mengambilnya untuk kontrol aliran, jadi kami menempatkan semua ini dalam Grup sehingga kompiler memahami persis apa itu Lihat, atau lebih tepatnya, instruksi untuk ViewBuilder untuk membuat wadah ConditionalContent opsional &lt;View1, View2&gt;. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, ketika mengubah nilai currentViewInd, SwiftUI menyembunyikan tampilan aktif sebelumnya, dan menunjukkan yang sekarang. Bagaimana Anda menyukai navigasi ini di dalam aplikasi?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ua/kr/gd/uakrgd2tzwv9hik_egmn1fglsfw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua yang masih harus dilakukan adalah menempatkan perubahan currentViewInd di bungkus withAnimation, dan beralih antar windows akan menjadi lancar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tambahkan .transition modifier, tentukan .scale sebagai parameter. </font><font style="vertical-align: inherit;">Ini akan membuat animasi tampilan dan lenyapnya masing-masing tampilan ini berbeda - menggunakan penskalaan alih-alih transparansi yang digunakan oleh SwiftUI default.</font></font><br>
<br>
<pre><code class="swift hljs">                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                                .transition(.scale)<font></font>
                        }<font></font>
                    }<font></font>
                }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/l5/ib/d-/l5ibd-y7m986miqinbv56qaslfc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan bahwa tampilan muncul dan menghilang dengan animasi yang sama, hanya hilangnya menghilang dalam urutan terbalik. </font><font style="vertical-align: inherit;">Bahkan, kita dapat menetapkan animasi untuk penampilan dan hilangnya tampilan secara individual. </font><font style="vertical-align: inherit;">Transisi asimetris digunakan untuk ini.</font></font><br>
<br>
<pre><code class="swift hljs">                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                               .transition(.asymmetric(<font></font>
                                    insertion: insertion: <span class="hljs-type">AnyTransition</span>.scale(scale: <span class="hljs-number">0.1</span>, anchor: .leading).combined(with: .opacity),<font></font>
                                    removal: .move(edge: .trailing)))<font></font>
                        }<font></font>
                    }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mq/xg/ji/mqxgji1ton95qn6ywl23xhl2mzm.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animasi .scale yang sama digunakan untuk muncul di layar, tetapi sekarang kami telah menentukan parameter untuk penggunaannya. Itu tidak dimulai dengan ukuran nol (titik), tetapi dengan ukuran 0,1 dari yang biasa. Dan posisi awal jendela kecil bukan di tengah layar, tetapi bergeser ke tepi kiri. Selain itu, tidak satu transisi bertanggung jawab atas penampilan, tetapi dua. Mereka dapat dikombinasikan dengan .combined (with :). Dalam hal ini, kami telah menambahkan transparansi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hilangnya tampilan sekarang disajikan oleh animasi lain - menyapu tepi kanan layar. Saya membuat animasi sedikit lebih lambat sehingga Anda dapat melihatnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan seperti biasa, saya tidak sabar untuk menulis versi animasi transit saya sendiri. Ini bahkan lebih sederhana daripada bentuk atau pengubah animasi.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpinTransitionModifier</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-keyword">let</span> angle: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> anchor: <span class="hljs-type">UnitPoint</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        content<font></font>
            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle), anchor: anchor)<font></font>
            .clipped()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">AnyTransition</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinIn</span><span class="hljs-params">(anchor: UnitPoint)</span></span> -&gt; <span class="hljs-type">AnyTransition</span> {<font></font>
        .modifier(<font></font>
            active: <span class="hljs-type">SpinTransitionModifier</span>(angle: -<span class="hljs-number">90</span>, anchor: anchor),<font></font>
            identity: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">0</span>, anchor: anchor))<font></font>
    }<font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinOut</span><span class="hljs-params">(anchor: UnitPoint)</span></span> -&gt; <span class="hljs-type">AnyTransition</span> {<font></font>
        .modifier(<font></font>
            active: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">90</span>, anchor: anchor),<font></font>
            identity: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">0</span>, anchor: anchor))<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/k-/mu/eck-muqydvucs1o59dkbnzpnw6e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mulai dengan, kita menulis pengubah biasa di mana kita mentransfer angka tertentu - sudut rotasi dalam derajat, serta titik relatif di mana rotasi ini terjadi. Kemudian, kami memperluas jenis AnyTransition dengan dua fungsi. Itu bisa saja satu, tapi menurut saya lebih nyaman. Saya merasa lebih mudah untuk menetapkan nama yang berbicara kepada masing-masing dari mereka daripada mengontrol derajat rotasi secara langsung dalam Tampilan itu sendiri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jenis AnyTransition memiliki metode pengubah statis, di mana kami melewati dua pengubah, dan kami mendapatkan objek AnyTransition yang menggambarkan transisi yang mulus dari satu negara ke yang lain. identitas adalah pengubah keadaan normal dari tampilan animasi. Aktif adalah keadaan awal animasi untuk tampilan tampilan, atau akhir animasi untuk penghilangan, mis. ujung segmen lainnya, negara bagian di mana akan diinterpolasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, spinIn menyiratkan bahwa saya akan menggunakannya untuk membuat tampilan muncul dari luar layar (atau ruang yang dialokasikan untuk Tampilan) dengan memutar searah jarum jam di sekitar titik yang ditentukan. spinOut berarti tampilan akan menghilang dengan cara yang sama, berputar di sekitar titik yang sama, juga searah jarum jam. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menurut ide saya, jika Anda menggunakan titik yang sama untuk tampilan dan hilangnya Tampilan, Anda mendapatkan efek memutar seluruh layar di sekitar titik ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua animasi didasarkan pada mekanik pengubah standar. Jika Anda menulis pengubah khusus, Anda harus menerapkan persyaratan protokol AnimatableModifier, seperti yang kami lakukan pada TwoParameterBorder, atau menggunakan pengubah bawaan di dalamnya yang menyediakan animasi default sendiri. Dalam hal ini, saya mengandalkan animasi .rotationEffect () bawaan di dalam pengubah SpinTransitionModifier saya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengubah .transition () hanya menjelaskan apa yang harus dipertimbangkan sebagai titik awal dan akhir dari animasi. Jika kita perlu meminta status AnimatableData sebelum memulai animasi, untuk meminta pengubah AnimatableData keadaan saat ini, menghitung perbedaan, dan kemudian menganimasikan penurunan dari 1 ke 0, lalu .transition () hanya mengubah data asli. Anda tidak terikat pada kondisi Tampilan Anda, Anda tidak didasarkan padanya. Anda secara eksplisit menentukan sendiri kondisi awal dan akhir, dari mereka Anda mendapatkan AnimatableData, menghitung perbedaan dan menganimasinya. Kemudian, di akhir animasi, tampilan Anda saat ini muncul.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Omong-omong, identitas adalah pengubah yang akan tetap diterapkan pada Tampilan Anda di akhir animasi. Kalau tidak, kesalahan di sini akan menyebabkan lompatan di akhir animasi penampilan, dan awal animasi penghilangan. Jadi transisi dapat dianggap sebagai "dua dalam satu" - menerapkan pengubah spesifik secara langsung ke tampilan + kemampuan untuk menganimasikan perubahannya saat tampilan muncul dan menghilang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejujurnya, mekanisme kontrol animasi ini tampaknya sangat kuat bagi saya, dan saya sedikit menyesal kami tidak dapat menggunakannya untuk animasi apa pun. Saya tidak akan menolak untuk membuat animasi tertutup tanpa akhir. Namun, kita akan membicarakannya di artikel selanjutnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk melihat dengan lebih baik bagaimana perubahan itu sendiri terjadi, saya mengganti Lihat pengujian kami dengan kotak dasar, ditandatangani dengan angka, dan dibingkai.</font></font><br>
<br>
<pre><code class="swift hljs">                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-comment">//self.views[ind]</span>
                            <span class="hljs-type">Rectangle</span>()<font></font>
                                .fill(<span class="hljs-type">Color</span>.gray)<font></font>
                                .frame(width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)<font></font>
                                .border(<span class="hljs-type">Color</span>.black, width: <span class="hljs-number">2</span>)<font></font>
                                .overlay(<span class="hljs-type">Text</span>(<span class="hljs-string">"\(ind + 1)"</span>))<font></font>
                              .transition(.asymmetric(<font></font>
                                  insertion: .spinIn(anchor: .bottomTrailing),<font></font>
                                  removal: .spinOut(anchor: .bottomTrailing)))<font></font>
                        }<font></font>
                    }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/4s/u9/vx4su9aoaqzuqzi2wq8uctpxe7c.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan untuk membuat gerakan ini lebih baik, saya menghapus .clipped () dari pengubah SpinTransitionModifier:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpinTransitionModifier</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-keyword">let</span> angle: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> anchor: <span class="hljs-type">UnitPoint</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        content<font></font>
            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle), anchor: anchor)
            <span class="hljs-comment">//.clipped()</span><font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/ml/0i/ihml0id6hnttwuhbjuv5s28jhaa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Omong-omong, sekarang kita perlu SpinTransitionModifier di modifier kita sendiri sama sekali. </font><font style="vertical-align: inherit;">Itu dibuat hanya untuk menggabungkan dua pengubah, rotasi, Efek, dan kliping () menjadi satu, sehingga animasi rotasi tidak melampaui ruang lingkup yang dipilih untuk Tampilan kami. </font><font style="vertical-align: inherit;">Sekarang, kita dapat menggunakan .rotationEffect () langsung di dalam .modifier (), kita tidak memerlukan perantara dalam bentuk SpinTransitionModifier.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat Melihat Mati</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Poin yang menarik adalah siklus hidup tampilan jika ditempatkan dalam if-else. </font><font style="vertical-align: inherit;">Lihat, meskipun dimulai, dan direkam sebagai elemen array, tidak disimpan dalam memori. </font><font style="vertical-align: inherit;">Semua dia</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Negara</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameter diatur ulang ke default saat berikutnya mereka muncul di layar. Ini hampir sama dengan inisialisasi. Terlepas dari kenyataan bahwa objek-struktur itu sendiri masih ada, render menghapusnya dari bidang pandangnya, karena itu tidak. Di satu sisi, ini mengurangi penggunaan memori. Jika Anda memiliki sejumlah besar Tampilan kompleks dalam array, render harus menggambar semuanya secara konstan, bereaksi terhadap perubahan - ini memengaruhi kinerja secara negatif. Jika saya tidak salah, itulah yang terjadi sebelum pembaruan Xcode 11.3. Sekarang, tampilan tidak aktif diturunkan dari memori render. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sisi lain, kita harus memindahkan semua kondisi penting di luar cakupan Pandangan ini. Untuk ini, yang terbaik adalah menggunakan variabel @EnvironmentObject.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kembali ke siklus hidup, harus juga dicatat bahwa pengubah .onAppear {}, jika seseorang terdaftar di dalam Tampilan ini, berfungsi segera setelah mengubah kondisi dan tampilan Tampilan di layar, bahkan sebelum animasi dimulai. </font><font style="vertical-align: inherit;">Karenanya, onDisappear {} dipicu setelah akhir animasi penghilangan. </font><font style="vertical-align: inherit;">Ingatlah ini jika Anda berencana untuk menggunakannya dengan animasi transisi.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa berikutnya? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fiuh </font><font style="vertical-align: inherit;">Ternyata cukup banyak, tetapi secara rinci, dan, saya harap, secara cerdas. </font><font style="vertical-align: inherit;">Jujur, saya berharap untuk berbicara tentang animasi pelangi sebagai bagian dari satu artikel, tetapi saya tidak bisa berhenti pada waktunya dengan detailnya. </font><font style="vertical-align: inherit;">Jadi tunggu kelanjutannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagian berikut menunggu kita:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penggunaan gradien: linier, melingkar dan sudut - semuanya akan berguna</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warna bukan warna sama sekali: pilih dengan bijak.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">animasi melingkar: cara memulai dan berhenti, dan cara berhenti segera (tanpa animasi, mengubah animasi - ya, ada juga)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">animasi aliran saat ini: prioritas, ganti, animasi berbeda untuk objek yang berbeda</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">detail tentang timing animasi: kami akan mengarahkan timing di tail dan di sure, hingga implementasi timingCurve kami sendiri (oh, teruskan aku tujuh :))</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bagaimana mengetahui saat saat animasi yang diputar</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika SwiftUI tidak cukup</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya akan membicarakan semua ini secara rinci menggunakan contoh membuat animasi pelangi, seperti pada gambar:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak pergi dengan cara mudah, tetapi mengumpulkan semua garu yang bisa saya jangkau, mewujudkan animasi ini pada prinsip-prinsip yang dijelaskan di atas. </font><font style="vertical-align: inherit;">Kisah tentang ini seharusnya menjadi sangat informatif, dan kaya akan trik dan segala jenis peretasan, tentang yang hanya ada sedikit laporan, dan yang akan bermanfaat bagi mereka yang memutuskan untuk menjadi perintis di SwiftUI. </font><font style="vertical-align: inherit;">Ini akan muncul kira-kira dalam satu atau dua minggu. </font><font style="vertical-align: inherit;">Ngomong-ngomong, Anda bisa berlangganan agar tidak ketinggalan. </font><font style="vertical-align: inherit;">Tetapi ini, tentu saja, hanya jika materi itu tampak bermanfaat bagi Anda, dan metode penyajiannya disetujui. </font><font style="vertical-align: inherit;">Kemudian, langganan Anda akan membantu membawa dengan cepat artikel baru ke atas, membawanya ke khalayak yang lebih luas lebih awal. </font><font style="vertical-align: inherit;">Kalau tidak, tulis di komentar apa yang salah.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id504186/index.html">Paul Graham: Cara Menulis Teks yang Berguna (Lengkap)</a></li>
<li><a href="../id504188/index.html">Karantina, sistem online, dan ilmu data. Siapa yang berpikir tentang retensi pelanggan?</a></li>
<li><a href="../id504190/index.html">MVCC sebagai salah satu cara untuk memastikan isolasi transaksi</a></li>
<li><a href="../id504194/index.html">Hasil survei pengembang di Stack Overflow 2020 (+ habraopros)</a></li>
<li><a href="../id504196/index.html">NFC: Parsing Near Field Communication Technology</a></li>
<li><a href="../id504204/index.html">Lokakarya IBM: Quarkus (Ultrafast Java for Microservices), Jakarta EE, dan OpenShift</a></li>
<li><a href="../id504208/index.html">Cara Mengotomasi Pusat Layanan Bersama</a></li>
<li><a href="../id504210/index.html">Apa itu Deno dan apakah itu akan menggantikan Node.js?</a></li>
<li><a href="../id504214/index.html">Pengembangan DATA VAULT dan transisi ke DATA BISNIS DATA</a></li>
<li><a href="../id504216/index.html">Berapa umur rumah ini? Bagaimana saya membuat peta usia rumah di St. Petersburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>