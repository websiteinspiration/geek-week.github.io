<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏧 🕳️ 🥄 GPU的简单哈希表 📦 🎵 🚰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我在Github上发布了一个名为A Simple GPU Hash Table的新项目。
 
 这是用于GPU的简单哈希表，每秒可以处理数亿个插入。在装有NVIDIA GTX 1060的笔记本电脑上，该代码在大约210毫秒内插入了6400万随机生成的键值对，并在大约64毫秒内删除了3200万对键值对...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>GPU的简单哈希表</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/492560/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/m2/fd/e_/m2fde_n27bcwfhvj00ovkweqofm.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我在Github上发布了一个</font><font style="vertical-align: inherit;">名为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Simple GPU Hash Table</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">新项目</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是用于GPU的简单哈希表，每秒可以处理数亿个插入。</font><font style="vertical-align: inherit;">在装有NVIDIA GTX 1060的笔记本电脑上，该代码在大约210毫秒内插入了6400万随机生成的键值对，并在大约64毫秒内删除了3200万对键值对。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也就是说，笔记本电脑的速度约为每秒3亿次插入和每秒5亿次清除。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该表是用CUDA编写的，尽管可以将相同的技术应用于HLSL或GLSL。</font><font style="vertical-align: inherit;">该实现有几个限制，以确保视频卡具有高性能：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅处理32位密钥和相同的值。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈希表具有固定大小。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且此大小应等于2度。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于键和值，您需要保留一个简单的定界标记（在上面的代码中为0xffffffff）。</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有锁的哈希表</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哈希表使用带有</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线性感应的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开放式寻址</font><font style="vertical-align: inherit;">，也就是说，它只是存储在内存中的一组键值对数组，并具有出色的缓存性能。</font><font style="vertical-align: inherit;">链接不是这种情况，这意味着在链接列表中查找指针。</font><font style="vertical-align: inherit;">哈希表是存储元素的简单数组</font></font><code>KeyValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KeyValue</span>
{</span>
    <span class="hljs-keyword">uint32_t</span> key;
    <span class="hljs-keyword">uint32_t</span> value;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该表的大小等于2的幂，而不是质数，因为使用pow2 / AND-mask，一条快速指令就足够了，而模块运算符要慢得多。这在线性感应的情况下很重要，因为在表的线性搜索中，插槽索引必须包装在每个插槽中。结果，在每个时隙中模运算增加了操作成本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该表仅存储每个项目的键和值，而不存储键哈希。由于该表仅存储32位密钥，因此哈希计算非常快。上面的代码使用Murmur3哈希，该哈希仅执行一些移位，XOR和乘法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哈希表使用的阻塞保护技术不依赖于内存分配顺序。即使某些写入操作违反了其他此类操作的顺序，哈希表仍将保持正确的状态。我们将在下面讨论。该技术非常适合视频卡，其中有数千个线程在竞争。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哈希表中的键和值被初始化为空。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以修改该代码，以便它可以处理64位键和值。密钥需要原子的读，写和交换操作（比较和交换）。值需要原子读取和写入操作。幸运的是，在CUDA中，对32位和64位值的读写操作是原子的，只要它们自然对齐即可（请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），现代的视频卡支持64位原子操作与交换的比较。</font><font style="vertical-align: inherit;">当然，切换到64位时，性能会略有下降。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈希表状态</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哈希表中的每个键值对可以具有以下四种状态之一：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">键和含义为空。</font><font style="vertical-align: inherit;">在这种状态下，哈希表被初始化。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">密钥已被记录，但尚未值。</font><font style="vertical-align: inherit;">如果此时另一个执行线程正在读取数据，则它将返回一个空值。</font><font style="vertical-align: inherit;">这很正常，如果另一个执行线程早一点起作用，也会发生同样的事情，而我们正在谈论的是竞争性数据结构。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">键和值都被记录。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该值可用于其他执行线程，但该键尚未提供。</font><font style="vertical-align: inherit;">之所以会发生这种情况，是因为CUDA编程模型暗示了排序不正确的内存模型。</font><font style="vertical-align: inherit;">这是正常现象；无论如何，键仍然为空，即使该值不再如此。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个重要的细微差别是，一旦密钥被写入插槽，它就不再移动-即使密钥被删除，我们也将在下面讨论。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哈希表代码甚至可以用于顺序不佳的内存模型，这些内存模型不知道读取和写入内存的顺序。</font><font style="vertical-align: inherit;">当我们分析哈希表中的插入，搜索和删除时，请记住每个键值对都处于上述四种状态之一。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插入哈希表</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将键值对插入哈希表的CUDA函数如下所示：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">uint32_t</span> prev = atomicCAS(&amp;hashtable[slot].key, kEmpty, key);
        <span class="hljs-keyword">if</span> (prev == kEmpty || prev == key)<font></font>
        {<font></font>
            hashtable[slot].value = value;<font></font>
            <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity<span class="hljs-number">-1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要插入键，代码将从插入的键的哈希开始在哈希表数组上进行迭代。在数组的每个插槽中，通过交换执行原子比较操作，其中将该插槽中的键与空键进行比较。如果检测到不匹配，则将插槽中的密钥更新为插入的密钥，然后返回插槽的原始密钥。如果此原始密钥为空或与插入的密钥相对应，则代码找到适合插入的插槽，并将插入的值带入插槽。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果在一个内核调用中</font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有几个具有相同键的元素，那么它们的任何值都可以写入键槽中。</font><font style="vertical-align: inherit;">这被认为是正常的：调用期间的键值写操作之一将成功，但是由于所有这些操作都是在多个执行线程中并行发生的，因此我们无法预测对存储器的哪个写操作将是最后一个。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈希表搜索</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关键查找器代码：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">gpu_hashtable_lookup</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key)</span>
</span>{
        <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> hashtable[slot].value;<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> kEmpty;<font></font>
            }<font></font>
            slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了找到存储在表中的键的值，我们从所需键的哈希开始对数组进行迭代。</font><font style="vertical-align: inherit;">在每个插槽中，我们检查密钥是否是我们要寻找的密钥，如果是，则返回其值。</font><font style="vertical-align: inherit;">我们还检查键是否为空，如果是，则中断搜索。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果找不到密钥，那么代码将返回一个空值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有这些搜索操作都可以在插入和删除过程中竞争地执行。</font><font style="vertical-align: inherit;">表中的每一对将具有上述流的四个状态之一。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈希表删除</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
密钥删除代码：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_delete</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
        {<font></font>
            hashtable[slot].value = kEmpty;<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
删除密钥是不寻常的：我们将密钥保留在表中，并将其值（而不是密钥本身）标记为空。</font><font style="vertical-align: inherit;">该代码与极为相似</font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，不同之处在于，当找到键的匹配项时，其值将为空。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如上所述，将密钥写入插槽后，它将不再移动。</font><font style="vertical-align: inherit;">即使您从表中删除一个项目，该键仍然保留，只是其值变为空。</font><font style="vertical-align: inherit;">这意味着我们不需要使用原子操作来写入插槽的值，因为当前值是否为空并不重要-它仍将为空。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调整哈希表大小</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以通过创建更大的表并在旧表中插入非空元素来调整哈希表的大小。</font><font style="vertical-align: inherit;">我没有实现此功能，因为我想使示例代码保持简单。</font><font style="vertical-align: inherit;">此外，在CUDA程序中，内存分配通常是在主机代码中完成的，而不是在CUDA内核中完成的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无锁等待空闲哈希表”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文章</font><font style="vertical-align: inherit;">介绍了如何更改这种受锁保护的数据结构。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">竞争力</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在上面的代码段，所述功能</font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且</font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在一个时间过程中的一个键-值对。</font><font style="vertical-align: inherit;">在下面</font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他们</font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并行处理一对数组，每个对在单独的GPU执行线程中：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// CPU code to invoke the CUDA kernel on the GPU</span>
<span class="hljs-keyword">uint32_t</span> threadblocksize = <span class="hljs-number">1024</span>;
<span class="hljs-keyword">uint32_t</span> gridsize = (numkvs + threadblocksize - <span class="hljs-number">1</span>) / threadblocksize;<font></font>
gpu_hashtable_insert_kernel&lt;&lt;&lt;gridsize, threadblocksize&gt;&gt;&gt;(hashtable, kvs, numkvs);<font></font>
<font></font>
<span class="hljs-comment">// GPU code to process numkvs key/values in parallel</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert_kernel</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">const</span> KeyValue* kvs, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> numkvs)</span>
</span>{
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> threadid = blockIdx.x*blockDim.x + threadIdx.x;
    <span class="hljs-keyword">if</span> (threadid &lt; numkvs)<font></font>
    {<font></font>
        gpu_hashtable_insert(hashtable, kvs[threadid].key, kvs[threadid].value);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可锁定的哈希表支持并发插入，搜索和删除。由于键值对始终处于四种状态之一，并且键不动，因此即使使用不同类型的操作，该表也可以保证正确性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如果我们并行处理一个插入和删除的数据包，并且输入对的数组中包含重复的键，那么我们将无法预测哪些对将“获胜”-它们将最后写入哈希表。假设我们用一个输入对数组调用一个插入代码</font></font><code>A/0 B/1 A/2 C/3 A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。当完成的代码中，对</font></font><code>B/1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与被</font></font><code>C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证是存在于该表中，但在同一时间的任何对将出现在它</font></font><code>A/0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>A/2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这可能是问题，也可能不是问题-这完全取决于应用程序。您可能事先知道输入数组中没有重复的键，或者对您上次写入哪个值也可能没有关系。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果这对您来说是个问题，则需要将重复的对拆分为不同的系统CUDA调用。在CUDA中，任何内核调用操作总是在下一个内核调用之前结束（至少在同一线程内。在不同线程中，内核并行执行）。如果在上面的示例中，用调用一个核</font></font><code>A/0 B/1 A/2 C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而</font><font style="vertical-align: inherit;">用调用另一个核</font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则键</font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将获得一个值</font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们关于该功能是否的谈话</font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在哈希表中使用一个简单的（纯）或可变（易失性）的指针对阵列。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CUDA文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指出：</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编译器可以自行决定优化对全局或共享内存的读取和写入操作。可以使用关键字</font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... </font><font style="vertical-align: inherit;">禁用这些优化</font><font style="vertical-align: inherit;">：...对此变量的任何链接都将编译为内存中的实际读取或写入指令。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正确性考量不需要应用</font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果执行线程使用早期读取操作中的缓存值，则意味着它将使用一些过时的信息。</font><font style="vertical-align: inherit;">但是，这仍然是来自内核调用中某个时刻哈希表的正确状态的信息。</font><font style="vertical-align: inherit;">如果需要使用最新信息，可以使用指针</font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是性能会略有下降：根据我的测试，当删除3200万个项目时，速度从5亿个删除/秒降低到4.5亿个删除/秒。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性能</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在插入6400万个元素并删除3200万个元素的测试中，</font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU的哈希表</font><font style="vertical-align: inherit;">与它们之间</font><font style="vertical-align: inherit;">几乎没有</font><font style="vertical-align: inherit;">竞争</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f10/342/41f/f1034241fbcf8c6f9ac61e2061aabf4a.png"></div><br>
<code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在插入和删除元素以及随后的释放时花费了70691毫秒</font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（从数百万个元素中释放会花费很多时间，因为内部</font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行了大量内存分配）。老实说，存在</font></font><code>std:unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全不同的限制。这是一个执行的CPU线程，它支持任何大小的键值，在高利用率下工作良好，并且在多次删除后显示稳定的性能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GPU和程序间通信的哈希表的持续时间为984毫秒。这包括将表放置到内存中并将其删除所需的时间（一次性分配1 GB的内存，这在CUDA中需要花费一些时间），插入和删除元素以及对其进行迭代。还考虑到了视频卡内存中的所有复制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哈希表本身花费了271毫秒。这包括视频卡插入和删除项目所花费的时间，并且没有考虑复制到内存并遍历结果表所花费的时间。如果GPU表寿命很长，或者哈希表完全包含在视频卡的内存中（例如，创建一个哈希表将由另一个GPU代码而不是中央处理器使用），则测试结果是有意义的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于其高带宽和主动并行化，该视频卡的哈希表显示出高性能。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺点</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哈希表体系结构要牢记几个问题：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">聚类会干扰线性探测，因此表中的键远非理想。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用此功能不会删除键，</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且随着时间的推移，表会</font><font style="vertical-align: inherit;">变得</font><font style="vertical-align: inherit;">混乱。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，哈希表的性能可能会逐渐降低，特别是如果哈希表存在很长时间并且在其中执行许多插入和删除操作时。</font><font style="vertical-align: inherit;">减轻这些缺点的一种方法是以较低的利用率重新哈希新表并在重新哈希时过滤远程键。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了说明所描述的问题，我使用上面的代码创建了一个包含1.28亿个元素的表，我将循环插入400万个元素，直到填充1.24亿个插槽（利用率约为0.96）。</font><font style="vertical-align: inherit;">这是结果表，每一行都是对CUDA核心的调用，其中在一个哈希表中插入了400万个新元素：</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">利用率 </font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插入持续时间4194304个元素</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11.608448毫秒（361.314798万键/秒）</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,03</font></font></td>
<td>11,751424  (356,918799  /.)</td>
</tr>
<tr>
<td>0,06</td>
<td>11,942592  (351,205515  /.)</td>
</tr>
<tr>
<td>0,09</td>
<td>12,081120  (347,178429  /.)</td>
</tr>
<tr>
<td>0,12</td>
<td>12,242560  (342,600233  /.)</td>
</tr>
<tr>
<td>0,16</td>
<td>12,396448  (338,347235  /.)</td>
</tr>
<tr>
<td>0,19</td>
<td>12,533024  (334,660176  /.)</td>
</tr>
<tr>
<td>0,22</td>
<td>12,703328  (330,173626  /.)</td>
</tr>
<tr>
<td>0,25</td>
<td>12,884512  (325,530693  /.)</td>
</tr>
<tr>
<td>0,28</td>
<td>13,033472  (321,810182  /.)</td>
</tr>
<tr>
<td>0,31</td>
<td>13,239296  (316,807174  /.)</td>
</tr>
<tr>
<td>0,34</td>
<td>13,392448  (313,184256  /.)</td>
</tr>
<tr>
<td>0,37</td>
<td>13,624000  (307,861434  /.)</td>
</tr>
<tr>
<td>0,41</td>
<td>13,875520  (302,280855  /.)</td>
</tr>
<tr>
<td>0,44</td>
<td>14,126528  (296,909756  /.)</td>
</tr>
<tr>
<td>0,47</td>
<td>14,399328  (291,284699  /.)</td>
</tr>
<tr>
<td>0,50</td>
<td>14,690304  (285,515123  /.)</td>
</tr>
<tr>
<td>0,53</td>
<td>15,039136  (278,892623  /.)</td>
</tr>
<tr>
<td>0,56</td>
<td>15,478656  (270,973402  /.)</td>
</tr>
<tr>
<td>0,59</td>
<td>15,985664  (262,379092  /.)</td>
</tr>
<tr>
<td>0,62</td>
<td>16,668673  (251,627968  /.)</td>
</tr>
<tr>
<td>0,66</td>
<td>17,587200  (238,486174  /.)</td>
</tr>
<tr>
<td>0,69</td>
<td>18,690048  (224,413765  /.)</td>
</tr>
<tr>
<td>0,72</td>
<td>20,278816  (206,831789  /.)</td>
</tr>
<tr>
<td>0,75</td>
<td>22,545408  (186,038058  /.)</td>
</tr>
<tr>
<td>0,78</td>
<td>26,053312  (160,989275  /.)</td>
</tr>
<tr>
<td>0,81</td>
<td>31,895008  (131,503463  /.)</td>
</tr>
<tr>
<td>0,84</td>
<td>42,103294  (99,619378  /.)</td>
</tr>
<tr>
<td>0,87</td>
<td>61,849056  (67,815164  /.)</td>
</tr>
<tr>
<td>0,90</td>
<td>105,695999  (39,682713  /.)</td>
</tr>
<tr>
<td>0,94</td>
<td>240,204636  (17,461378  /.)</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
随着利用率的提高，生产率下降。在大多数情况下，这是不希望的。如果应用程序将元素插入表中，然后将其丢弃（例如，当计数书中的单词时），那么这不是问题。但是，如果应用程序使用寿命很长的哈希表（例如，在用户经常插入和删除信息时在图形编辑器中存储图像的非空部分），则此行为可能会很麻烦。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，他测量了6400万次插入后探测哈希表的深度（利用率0.5）。平均深度为0.4774，因此大多数按键位于最佳位置或距最佳位置一个插槽中。最大探测深度为60。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，我在表中测量了1.24亿个插件的发声深度（利用率0.97）。平均深度已经是10.1757，最大深度是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6474</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（!!）。在高利用率下，线性探测性能会急剧下降。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最好将此哈希表保持在较低水平。但是随后我们通过消耗内存来提高生产力。幸运的是，对于32位键和值，这是合理的。如果在上面的示例中，表中保存了1.28亿个元素，利用率系数为0.25，那么我们可以在其中放置不超过3200万个元素，并且剩余的9600万个插槽将丢失-每对8个字节，丢失768 MB的内存。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，我们正在谈论视频卡内存的丢失，这是比系统内存更有价值的资源。</font><font style="vertical-align: inherit;">尽管大多数支持CUDA的现代台式机图形卡至少具有4 GB的内存（在撰写本文时，NVIDIA 2080 Ti具有11 GB），但是丢失此类容量将不是最明智的决定。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
稍后，我将写更多有关为视频卡创建哈希表的信息，这些哈希表在探测深度以及重用远程插槽的方式方面都没有问题。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">感应深度测量</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要确定按键听起来的深度，我们可以从其实际表索引中提取键哈希（表中的理想索引）：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// get_key_index() -&gt; index of key in hash table</span>
<span class="hljs-keyword">uint32_t</span> probelength = (get_key_index(key) - hash(key)) &amp; (hashtablecapacity<span class="hljs-number">-1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于附加代码中的两个二进制数具有魔力，并且哈希表的容量等于2的幂，因此即使将键索引移到表的开头，该方法也可以使用。</font><font style="vertical-align: inherit;">取一个散列为1但插入插槽3的键。然后对于容量为4的表，我们得到的</font></font><code>(3 — 1) &amp; 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值等于2。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您有任何疑问或意见，请在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter上</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给我写信，</font><font style="vertical-align: inherit;">或在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源库中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打开一个新主题</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此代码的灵感来自一些出色的文章：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">世界上最简单的无锁哈希表</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无锁的免等待哈希表</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将来，我将继续写有关视频卡哈希表的实现，并将分析其性能。</font><font style="vertical-align: inherit;">我计划使用在方便于视频卡的数据结构中使用原子操作来链接，哈希Robin Hood和布谷鸟哈希。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN492540/index.html">游戏“等一下！” 在arduino上</a></li>
<li><a href="../zh-CN492546/index.html">使用Nikto检查任何站点的漏洞</a></li>
<li><a href="../zh-CN492548/index.html">Unity机器学习：教MO代理跳过墙</a></li>
<li><a href="../zh-CN492552/index.html">如何在巴塞罗那隔离区生活和工作</a></li>
<li><a href="../zh-CN492558/index.html">您好，这是COVID19：冠状病毒是否存在于智能手机表面？</a></li>
<li><a href="../zh-CN492562/index.html">隔离程序中的三个有用的Apache Ignite网络研讨会</a></li>
<li><a href="../zh-CN492566/index.html">贪婪点击搜索算法与图顶点部分枚举结合的分析</a></li>
<li><a href="../zh-CN492568/index.html">通过FSIS USRN和python获取Rosreestr的摘录。第2部分</a></li>
<li><a href="../zh-CN492572/index.html">Java世界的当前状态：最流行的编程语言之一的趋势和事实</a></li>
<li><a href="../zh-CN492574/index.html">关于起飞概率的思考：配备Momentum True Wireless 2的Apple AirPods</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>