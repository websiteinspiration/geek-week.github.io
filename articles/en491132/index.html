<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙎🏾 👨🏼‍🌾 🧙🏼 When the bloom filter does not fit 🤹🏼 🚉 🧠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I knew from the university about the Bloom filter , a probabilistic data structure named after Burton Bloom. But I did not have the opportunity to use...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>When the bloom filter does not fit</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491132/"><img src="https://habrastorage.org/webt/7x/rh/8w/7xrh8wafuzqnbs-o1jpgzjxtruw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I knew from the university about </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Bloom filter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a probabilistic data structure named after Burton Bloom. But I did not have the opportunity to use it. Last month, such an opportunity appeared - and this structure literally fascinated me. However, I soon found some flaws in her. This article is a story about my brief love affair with the Bloom filter.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the process of researching </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP spoofing,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> it was necessary to check the IP addresses in the incoming packets, comparing them with the geographical location of our data centers. For example, packages from Italy should not go to the Brazilian data center. This problem may seem simple, but in the ever-changing landscape of the Internet it is far from simple. Suffice it to say that in the end I accumulated a lot of large text files with approximately the following content: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7cf/4b4/f67/7cf4b4f67fdf8b4d8a88c2685051c15f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This means that a request from the resolved IP address 192.0.2.1 was recorded in Cloudflare data center number 107. This data came from many sources, including our active and passive samples, the logs of some domains that we own (for example,</font></font><code>cloudflare.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), open sources (for example, BGP tables), etc. The same line is usually repeated in several files. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the end, I got a gigantic dataset of this kind. </font><font style="vertical-align: inherit;">At some point, in all the collected sources, I counted 1 billion lines. </font><font style="vertical-align: inherit;">Usually I write bash scripts for preprocessing the input data, but on this scale this approach did not work. </font><font style="vertical-align: inherit;">For example, removing duplicates from this tiny file of 600 MiB and 40 million lines takes ... eternity: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfa/dc1/9c0/bfadc19c083b6a31bc34b568cdc81d74.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suffice it to say that deduplicating lines with ordinary commands of the type </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in various configurations (see </font></font><code>--parallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>--buffer-size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>--unique</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) was not the best for such a large data set.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloom filters</font></font></h1><br>
<img src="https://habrastorage.org/getpro/habr/post_images/3a6/110/0e6/3a61100e64277b6a515666b8bf0293f9.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Illustration of </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">David Epstein</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the public domain</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Then it dawned on me: do not sort the lines! You need to remove duplicates, so some kind of 'set' data structure will work much faster. In addition, I roughly know the size of the input file (the number of unique lines), and the loss of some data is not critical, that is, the probabilistic data structure is quite suitable.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is perfect for Bloom filters!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
While you are reading</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia on Bloom filters</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, this is how I look at this data structure.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How would you implement</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the plurality</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Given an ideal hash function and infinite memory, we can simply create an infinite bitmap and set a bit number for each element</font></font><code>hash(item)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This provides the ideal data structure for the "multitude." </font><font style="vertical-align: inherit;">Right? </font><font style="vertical-align: inherit;">Trivially. </font><font style="vertical-align: inherit;">Unfortunately, hash functions collide, and infinite memory does not exist, so in our reality we have to compromise. </font><font style="vertical-align: inherit;">But we can calculate the probability of collisions and manage this value. </font><font style="vertical-align: inherit;">For example, we have a good hash function and 128 GB of memory. </font><font style="vertical-align: inherit;">We can calculate that the collision probability for each new element is 1 to 1099511627776. When you add more elements, the probability increases as the bitmap is filled. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, we can apply more than one hash function and get a denser bitmap. </font><font style="vertical-align: inherit;">This is where the Bloom filter works well, which is a set of mathematical data with four variables:</font></font><br>
<br>
<ul>
<li><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - number of inserted elements (cardinal number)</font></font><br>
</li>
<li><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - memory used by the bitmap</font></font><br>
</li>
<li><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the number of hash functions calculated for each input</font></font><br>
</li>
<li><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - probability of false positive coincidence</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Given the cardinal number </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the desired probability of false positives </font></font><code>p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the Bloom filter returns the required memory </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the required number of hash functions </font></font><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Check out this </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excellent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thomas Hurst </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">visualization of</font></a><font style="vertical-align: inherit;"> how parameters affect each other.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-bloom</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Guided by intuition, I added the probabilistic tool mmuniq-bloom to my arsenal, which takes the input STDIN and returns only unique lines in STDOUT. </font><font style="vertical-align: inherit;">It should be much faster than a combination of </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font><code>uniq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There he is:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-bloom.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For simplicity and speed, I initially set a few parameters. First, unless otherwise stated, mmuniq-bloom uses eight hash functions k = 8. This seems to be close to the optimal number for our data size, and the hash function can quickly produce eight decent hashes. Then we align the memory </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the bitmap to the power of two to avoid an expensive operation </font></font><code>%modulo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which in assembler comes down to slow </font></font><code>div</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If the array is equal to the power of two, we can simply use bitwise AND (for fun, read </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">how compilers optimize some division operations by multiplying by a magic constant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we can run it on the same data file that we used before:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3fa/019/d05/3fa019d05b8d6a72ad1ea3bde9c15a19.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh, that is much better! 12 seconds instead of two minutes. The program uses an optimized data structure, a relatively limited amount of memory, optimized line parsing and good output buffering ... and with all this, 12 seconds seems like an eternity compared to the tool </font></font><code>wc -l</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/953/ede/adb/953edeadb5701d03f92c7717f159f20d.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is happening? I understand that counting strings in is </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">easier than calculating unique strings, but is the 26-time difference really justified? What does the CPU take in </font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Must be for computing hashes. The utility </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not spend the processor, doing all this strange math for each of the 40 million lines. I use a rather non-trivial hash function </font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, for sure it burns the processor, right? Let's verify by running only the hash function, but </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">performing no operations with the Bloom filter: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f5e/7a0/e0f/f5e7a0e0f26a3136ca3d0a9b362e0fe3.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is strange. </font><font style="vertical-align: inherit;">The calculation of the hash function takes only about two seconds, although the entire program in the previous run was executed for 12 seconds. </font><font style="vertical-align: inherit;">Does one Bloom filter work for 10 seconds? </font><font style="vertical-align: inherit;">How is this possible? </font><font style="vertical-align: inherit;">This is such a simple data structure ...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secret Weapon - Profiler</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It's time to apply the right tool for this task - let's run the profiler and see what the processor is working on. First, let's run </font></font><code>strace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to verify that there are no unexpected system calls: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7bc/29b/87c/7bc29b87cdeadac9a11ce78aa61129f6.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything looks good. Ten calls to </font></font><code>mmap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 ms each (3971 μs) are intriguing, but that's fine. We pre-fill the memory with </font></font><code>MAP_POPULATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, to later prevent errors due to the lack of a page. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What is the next step? Of course it is </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/1da/aa8/acc/1daaa8acc9e3a84d1f591ad94cd84387.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then let's see the result: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/637/38f/3e2/63738f3e2a4bb1207927ecbc45b0cf3b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, we really burn 87.2% of the cycles in the main code. Let's see where exactly. The team </font></font><code>perf annotate process_line --source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immediately shows something unexpected. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/17f/f6f/cc8/17ff6fcc833def72269a07f7fd54d9f0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We see that 26.90% of the processor burned out in</font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, But that's not all! The compiler correctly inserts the function and expands the loop. It turns out that most of the cycles go to this </font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or to the line </font></font><code>uint64_t v = *p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5c0/a3e/59c/5c0a3e59c8f954146bed3b2f1478e0ba.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviously perf is wrong, how can such a simple string take up so many resources? But repeating the test with any other profiler shows the same problem. For example, I like to use google-perftools with kcachegrind because of the colorful diagrams: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8af/fbd/e9e/8affbde9e2b92d4da89d445314ec4654.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The result of the visualization is as follows: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/130/ea3/9f9/130ea39f9a8c6a22c252381c3af88045.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let me summarize what we have discovered so far. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The standard utility </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">processes a 600 MiB file for 0.45 s processor time. Our optimized tool </font></font><code>mmuniq-bloom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">runs 12 seconds. The processor is burned on one instruction </font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dereferencing memory ...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/6aa/3dd/e6a/6aa3dde6a6562dad5d0b3b2fa94c4565.jpg"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image of </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jose Nicdao</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , CC BY / 2.0</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Oh! How could I forget. Random access to memory is</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">really</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slow! Very, very, very slow!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
According to the</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">numbers every programmer should know</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a single access to RAM takes about 100 ns. Let's count: 40 million lines, 8 hashes each. Since our Bloom filter has a size of 128 MiB, on</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">our old hardware</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it does not fit into the L3 cache! Hashes are evenly distributed over a wide range of memory - each of them generates a cache miss. Put it all together, and it turns out ...</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b54/7e8/2e6/b547e82e6368f26843834121b1765103.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It turns out that 32 seconds burn out only on memory accesses. The real program fits in just 12 seconds, because the Bloom filter still benefits from caching. This is easy to see with </font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2b8/199/785/2b8199785c666437f37b9d96c209670f.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yes, we should have had a minimum of 320 million cache misses (LLC-load-misses), but only 280 million happened: this still does not explain why the program worked in just 12 seconds. But it does not matter. It is important that the number of cache misses is a real problem, and we can solve it only by reducing the number of memory accesses. Let's try to configure the Bloom filter to use only one hash function: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/052/bec/d4f/052becd4ffe91553d1d3b01bfa53755b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ay! It really hurts! To get a collision probability of 1 per 10,000 lines, the Bloom filter required 64 gigabytes of memory. It's horrible!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, it does not seem that the speed has increased significantly. </font><font style="vertical-align: inherit;">It took the operating system 22 seconds to prepare the memory for us, but we still spent 11 seconds in the user space. </font><font style="vertical-align: inherit;">I believe that now all the advantages of a rarer access to memory are compensated by a lower probability of getting into the cache due to the sharply increased memory size. </font><font style="vertical-align: inherit;">Earlier, 128 MiB was enough for the Bloom filter!</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refusing Bloom Filters</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is just getting ridiculous. </font><font style="vertical-align: inherit;">To reduce the likelihood of false positives, you must either use a lot of hashes in the Bloom filter (for example, eight) with a lot of memory accesses, or leave one hash function, but use huge amounts of memory. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We actually do not have a memory limit, we want to minimize the number of calls to it. </font><font style="vertical-align: inherit;">We need a data structure that costs a maximum of one cache miss per element and uses less than 64 gigabytes of RAM ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, you can implement complex data structures, such as </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a cuckoo filter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but there is certainly an easier option. </font><font style="vertical-align: inherit;">What about the good old linear probing hash table? </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c29/a0d/136/c29a0d136e80e5fc0a6f90f1cab1378e.png"><br>
<i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Illustration of </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vadims Podans</font></font></a></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meet mmuniq-hash</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is the new version of mmuniq-bloom using a hash table:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq-hash.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Instead of the bits for the Bloom filter, we now store 64-bit hashes from </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the 'siphash24' function</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This provides much better protection against hash collisions: much better than one per 10,000 lines. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's count. </font><font style="vertical-align: inherit;">Adding a new item to a hash table, say with 40 million entries, gives the chance of hash collisions </font></font><code>40 000 000/2^64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is about 1 in 461 billion - a fairly low probability. </font><font style="vertical-align: inherit;">But we do not add one element to the pre-filled set! </font><font style="vertical-align: inherit;">Instead, we add 40 million rows to the initially empty set. </font><font style="vertical-align: inherit;">According to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the birthday paradox</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , this greatly increases the likelihood of collisions. </font><font style="vertical-align: inherit;">A reasonable approximation would be an estimate </font></font><code>'~n^2/2m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, in our case it is</font></font><code>~(40M^2)/(2*(2^64))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It turns out one chance out of 23,000. In other words, with a good hash function, we expect a collision in one of the 23,000 random sets of 40 million elements. This is a non-zero probability, but still better than in the Bloom filter, and it is completely tolerable for our use case. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code with a hash table works faster, it has better memory access patterns and lower probability of false positives than in the Bloom filter.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/0ea/5c5/817/0ea5c5817289f136355f452748da0f86.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Don't be alarmed by the “hash conflicts” line, it just shows how full the hash table is. </font><font style="vertical-align: inherit;">We use linear sensing, so when we get into the full set, we just take the next empty one. </font><font style="vertical-align: inherit;">In our case, we have to skip an average of 0.7 sets to find an empty spot in the table. </font><font style="vertical-align: inherit;">This is normal. </font><font style="vertical-align: inherit;">Since we iterate over the sets in a linear order, the memory must be qualitatively full. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From the previous example, we know that our hash function takes about two seconds. </font><font style="vertical-align: inherit;">We conclude that 40 million memory accesses take about four seconds.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lessons learned</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modern processors are really good at sequential access to memory when it is possible to predict sampling patterns (see </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cache prefetching</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Random access to memory, on the other hand, is very expensive. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Advanced data structures are very interesting, but be careful. Modern computers require the use of cache-optimized algorithms. When working with large data sets that do not fit in L3, optimization over the number of hits is preferred, rather than optimization over the amount of memory used. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It’s fair to say that Bloom filters perform great when placed in the L3 cache. But if not, then they are terrible. This is not news: Bloom filters are optimized for the amount of memory, not the number of calls to it. For example, see</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scientific article on cuckoo filters</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another thing is endless discussions about hash functions. Honestly, in most cases this does not matter. The cost of counting even complex hash functions seems to be </font></font><code>siphash24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">small compared to the cost of random access to memory. In our case, simplifying the hash function will bring only a small benefit. CPU time is just wasted somewhere else - waiting for memory! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One colleague often says: “It can be assumed that modern processors are infinitely fast. They work at infinite speed, until they </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rest</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> against the </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">wall of memory</font></a><font style="vertical-align: inherit;"> . " </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, do not repeat my mistake. You always need to first perform profiling with</font></font><code>perf stat -d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and look at the IPC counter (instructions per cycle). </font><font style="vertical-align: inherit;">If it is less than one, this usually means that the program is stuck waiting for memory. </font><font style="vertical-align: inherit;">The optimal values ​​are above two. </font><font style="vertical-align: inherit;">This means that the workload is mainly on the CPU. </font><font style="vertical-align: inherit;">Unfortunately, in my tasks, IPC is still low ...</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Superior mmuniq</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With the help of colleagues, I wrote an improved version of the mmuniq tool based on a hash table. </font><font style="vertical-align: inherit;">Here is the code:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mmuniq.c</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It can dynamically change the size of the hash table, supports input with an arbitrary cardinal number. </font><font style="vertical-align: inherit;">Then it processes the data in packets, effectively using the hint </font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the CPU, which speeds up the program by 35-40%. </font><font style="vertical-align: inherit;">Be careful, abundant use </font></font><code>prefetch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the code rarely gives effect. </font><font style="vertical-align: inherit;">To use this function, I specially reordered the algorithms. </font><font style="vertical-align: inherit;">With all the improvements, the execution time was reduced to 2.1 seconds:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e40/4df/9c4/e404df9c42a97be2f1051a69f98116e6.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the end</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The creation of a basic tool that tries to outperform the 'sort / uniq' combination has revealed some hidden features of modern computing. </font><font style="vertical-align: inherit;">Having sweated a little, we accelerated the program from more than two minutes to two seconds. </font><font style="vertical-align: inherit;">During development, we learned about the delay in random access to memory, as well as the power of cache-friendly data structures. </font><font style="vertical-align: inherit;">Bizarre data structures attract attention, but in practice it is often more efficient to reduce the number of random accesses to memory.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en491116/index.html">Modern Identification Standards: OAuth 2.0, OpenID Connect, WebAuthn</a></li>
<li><a href="../en491118/index.html">Developer Heart: Devkits of the 5th generation of consoles (Part 1)</a></li>
<li><a href="../en491120/index.html">$ mol: 4 years later</a></li>
<li><a href="../en491122/index.html">Forensic analysis of HiSuite backups</a></li>
<li><a href="../en491130/index.html">Vue Features to Remember</a></li>
<li><a href="../en491134/index.html">5 stages of inevitability of adoption of ISO / IEC 27001 certification. Negation</a></li>
<li><a href="../en491136/index.html">Projecting content in Angular or lost ng-content documentation</a></li>
<li><a href="../en491138/index.html">Satellite and Ansible Tower Integration</a></li>
<li><a href="../en491146/index.html">UML for developers</a></li>
<li><a href="../en491150/index.html">How I hacked scammers, or just the insides of phishing panels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>