<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“• ğŸ‘¨ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ¤›ğŸ¾ Mengapa Flutter menang? ğŸ¤¦ğŸ½ ğŸ¥š ğŸ¤±ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tahun lalu, saya telah menulis aplikasi Flutter untuk iOS dan Android. Sebelum itu, saya memiliki dan memiliki 5 tahun pengalaman dengan Xamarin. Suda...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Mengapa Flutter menang?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501340/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tahun lalu, saya telah menulis aplikasi Flutter untuk iOS dan Android. </font><font style="vertical-align: inherit;">Sebelum itu, saya memiliki dan memiliki 5 tahun pengalaman dengan Xamarin. </font><font style="vertical-align: inherit;">Sudah 5 tahun yang luar biasa. </font><font style="vertical-align: inherit;">Terima kasih kepada Xamarin dan cintaku pada kerangka ini, saya, pada prinsipnya, pindah ke kamp pengembang, alat ini membantu saya menghasilkan banyak uang, pengetahuan, dan menemukan kolega yang luar biasa. </font><font style="vertical-align: inherit;">Jadi mengapa saya menulis di Flutter sekarang? </font><font style="vertical-align: inherit;">Jawaban singkat, karena Flutter mencakup semua kebutuhan pengembangan lintas platform.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/qo/ua/rw/qouarwd80cvkhylqpiukpop86n8.jpeg"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sedikit sejarah</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Koreksi saya jika saya salah, tetapi 2009 dalam banyak hal adalah kunci untuk pengembangan ponsel pada umumnya dan pengembangan lintas platform pada khususnya. Pada tahun 2009, iPhone 3gs dirilis, yang memungkinkan Anda menjalankan aplikasi pihak ketiga dari AppStore. Untuk pertama kalinya kesempatan ini muncul setahun sebelumnya di iPhone 3g, tetapi 3gs telah menjadi iPhone yang benar-benar "populer". Sekali lagi, setahun sebelumnya, pada bulan September 2008, Android diperkenalkan kepada publik dan pada tahun 2009 banyak produsen ponsel mulai mencoba Android untuk model ponsel baru mereka. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada musim semi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2009, Nitobi memperkenalkan PhoneGap, kerangka kerja baru untuk membuat aplikasi lintas platform berbasis HTML5, CSS dan JS. Di tahun yang sama, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di bulan September</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ximian merilis MonoTouch, yang memungkinkan Anda menulis aplikasi iOS menggunakan Mono dan C #. Pada tahun 2009 yang sama, pada bulan Desember, Rovio Entertainment merilis game untuk iOS dan, untuk sesaat, Maemo, yang dalam banyak hal menandai awal dari industri game mobile - Angry Birds. Contoh terakhir di sini bukan kebetulan.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kerangka kerja lintas platform pertama "untuk rakyat" dapat dianggap PhoneGap (pengembang Qt, jangan melempar batu). Itu adalah ide yang luar biasa dan sangat jelas - untuk membawa web ke dunia pengembangan ponsel. Pada 2009, kemampuan web sudah mulai melampaui browser ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">halo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> node.js), sementara menulis aplikasi web di JS cukup mudah. Poin kedua, yang tidak kalah pentingnya adalah rendering UI. Cara rendering terjadi terletak pada mesin browser dan semua mesin ini kurang lebih mengikuti standar W3C untuk HTML, CSS dan DOM. Setiap pengembang web yang telah membuat situs mengharapkan situsnya akan terlihat </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hampir</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">identik di browser apa pun, di platform apa pun. Ini, menurut saya, adalah aspek terpenting dari web sebagai platform terbuka. Mengapa saya harus belajar bahasa / kerangka kerja baru untuk menggambar UI untuk setiap platform, jika untuk waktu yang lama ada standar untuk pemodelan UI untuk browser yang berbeda.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah itu, Cordova berputar dari PhoneGap, dan darinya Ionic. Tampaknya ini adalah kerangka kerja yang ideal, tetapi ada 2 poin: kinerja dan integrasi OS. Salah satu tujuan utama atau, jika Anda mau, tolok ukur aplikasi, ditulis pada solusi lintas platform adalah "keaslian" mereka. Itu Idealnya, 100% pengguna harus mempertimbangkan bahwa aplikasi lintas platform Anda adalah asli. Dan ini berarti harus seperti asli, berfungsi seperti asli dan memiliki semua kemungkinan integrasi dengan OS. Pada awalnya, semua poin untuk PhoneGap tidak dapat dicapai, kapasitas smartphone 10 tahun yang lalu tidak cukup untuk rendering UI 60 fps, integrasi dengan OS sangat minim. Sekarang ada beberapa aplikasi pada Ionic yang sulit dibedakan dari yang asli, tetapi meniru aplikasi asli masih merupakan tugas.dan tidak diberikan seperti itu. Mari kita rangkum sedikit. Menulis aplikasi web, atau lebih tepatnya aplikasi hybrid di iOS dan Android, adalah mungkin dan nyaman. Lebih mudah karena mekanisme rendering UI sepenuhnya terletak pada platform WebView, plus ada lapisan programmer yang sudah terlatih yang berpengalaman dalam web.</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, dalam aplikasi hybrid, kinerja dan integrasi OS mungkin timpang.</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pada saat yang sama dengan PhoneGap, MonoTouch diluncurkan pada 2009, yang kemudian dinamai Xamarin.iOS. Juga, pada tahun yang sama, Titanium dirilis, yang pada gilirannya juga memungkinkan penulisan aplikasi iOS pada javascript. Pada awalnya, Titanium bekerja dengan paradigma yang persis sama dengan PhoneGap - mengandalkan WebView. Tapi kemudian mereka mengadopsi pendekatan Xamarin. Apa pendekatan ini? Itu bisa dilihat sebagai sesuatu di tengah. Pendekatan Xamarin / Titanium / React.Native adalah bahwa alih-alih mencoba membuat / memigrasikan render UI yang ada / yang ada, kerangka kerja hanya berintegrasi dengan yang asli, yang ada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alih-alih menggambar formulir dalam HTML, Xamarin memanggil elemen UI asli untuk ini (UITextField, TextEdit, dll). Memang, mengapa menciptakan kembali kemudi? Semua elemen UI yang diperlukan ada di SDK dan runtime asli, Anda hanya perlu belajar cara berkomunikasi dengan mereka dari VM Anda (mono, v8, dll). Pada saat yang sama, seperti yang sudah Anda tebak, Anda dapat menggunakan C #, JS, TS, F #, Kotlin, dll, dan pada saat yang sama kode yang tidak secara langsung berinteraksi dengan UI adalah 100% lintas-platform. Anda bisa melangkah lebih jauh. UITextField dan TextEdit yang sama adalah entitas yang identik secara konseptual, mereka memiliki beberapa properti yang mirip dan antarmuka interaksi, dan oleh karena itu, Anda dapat membuat Entri abstrak (halo Xamarin.Forms) dan hanya bekerja dengannya, untuk jarang ( </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak terlalu</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) pengecualian turun ke elemen UI platform. Saya tidak menyebutkan bahwa jika vm Anda dapat bekerja dengan UI secara native, kemungkinan besar vm Anda dapat memanggil API platform apa pun. Ini sepertinya pilihan yang sempurna. UI asli, kinerja asli (hi Bridges in React.Native), 100% integrasi OS. Apakah ini benar-benar sempurna? Kemungkinan besar - tidak, dan masalahnya adalah bahwa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada kenyataannya solusi ini tidak menyelesaikan masalah pengembangan lintas platform - UI tunggal. Mereka menyamarkannya</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Saya ingin menulis sekali, jalankan di mana-mana. Ini jauh dari moto terbaik untuk semua jenis program dan masalah, tetapi cocok dengan UI. Saya ingin menulis UI yang sama untuk semua orang, terlepas dari platform. Mengapa pengembang web dapat membiarkan dirinya menggunakan HTML dan CSS untuk menulis situs yang kemudian akan ditampilkan dengan cara yang sama di Safari di iOS dan Chrome di Android, tetapi tidak ada pengembang asli?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faktanya, programmer telah lama menulis UI berkinerja tinggi dengan basis kode umum untuk iOS dan Android. Programmer ini disebut pengembang game. Angry Birds ditulis pada mesin Cocos2d-x, Cuphead on Unity, dan Fortnite on Unreal Engine. Jika mesin gim dapat menampilkan adegan menakjubkan di ponsel Anda, maka tombol dan daftar dengan animasi yang halus pasti akan bisa. Jadi mengapa tidak ada yang menggunakannya dalam nada ini? Jawabannya sederhana dan dangkal, mereka tidak dimaksudkan untuk ini. Saat Anda membuka gim, sepenuhnya tergantung pada senter seberapa mirip UI itu dengan yang asli, Anda hampir tidak perlu berinteraksi dengan geolokasi, tombol, kamera video, dll. Saat Anda bermain, Anda menjalani kehidupan yang berbeda di dunia kecil Anda yang ditampilkan melalui Canvas di UIViewController / Activity Anda. karena itu</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mesin game memiliki integrasi yang relatif buruk dengan OS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sehingga tidak ada (atau saya belum melihat) meniru mesin top UI asli.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Subtotal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk kerangka kerja lintas platform yang ideal, kita perlu:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemetaan UI asli </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kinerja UI Asli </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemampuan 100% untuk memanggil API OS apa saja, seolah-olah itu adalah aplikasi asli </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda sekarang berpikir bahwa saya akan mulai gagal di bawah Flutter, tetapi saya sudah mendengar komentar marah: "Di mana Qt!? </font><font style="vertical-align: inherit;">Dia bisa melakukan semua ini! " </font><font style="vertical-align: inherit;">Memang, Qt sampai tingkat tertentu cocok dengan kriteria ini. </font><font style="vertical-align: inherit;">Meskipun saya sangat meragukan yang pertama dari mereka. </font><font style="vertical-align: inherit;">Tapi masalah utama Qt bukanlah kesulitan menulis UI asli, masalah utama adalah C ++. </font><font style="vertical-align: inherit;">Lalu aku sudah menyeka wajahku dari ludah penyandera persalinan di plus. </font><font style="vertical-align: inherit;">Pro adalah pisau Swiss pada steroid anabolik, pada pro Anda dapat melakukan segalanya. </font><font style="vertical-align: inherit;">Tapi saya, sebagai pengembang frontend, tidak perlu ini semua. </font><font style="vertical-align: inherit;">Saya membutuhkan bahasa yang sederhana dan dapat dimengerti yang bekerja dengan UI dan I / O. </font><font style="vertical-align: inherit;">Jadi, tiga poin kami di atas ditambahkan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mudah dipelajari dan bahasa yang cukup ekspresif </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rantime yang cocok dengan paradigma pembangunan frontend </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nah, sekarang setelah kami menyoroti beberapa metrik alat lintas platform yang baik untuk mengembangkan aplikasi seluler, kita dapat membahas masing-masing dari mereka dan melihat bagaimana itu diterapkan di Flutter.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemetaan UI asli</font></font></h4><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ir/oi/wf/iroiwftbrxuuh_35cjdasl7sgkc.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang kami ketahui sebelumnya, ada dua pendekatan yang berlawanan untuk bekerja dengan UI dalam kerangka kerja lintas platform. </font><font style="vertical-align: inherit;">Ini adalah render UI menggunakan WebView atau panggilan elemen UI asli di setiap platform. </font><font style="vertical-align: inherit;">Setiap pendekatan memiliki kelebihan dan kekurangan. </font><font style="vertical-align: inherit;">Tetapi mereka tidak mencakup seluruh kebutuhan pengembang: terlihat tidak dapat dibedakan dari UI asli + kinerja asli. </font><font style="vertical-align: inherit;">Flutter menutupi semua kebutuhan ini dengan kepala. </font><font style="vertical-align: inherit;">Tim Flutter menghabiskan sejumlah sumber daya untuk menciptakan elemen â€œasliâ€ dalam kerangka itu sendiri. </font><font style="vertical-align: inherit;">Semua widget di Flutter dibagi menjadi tiga kategori besar:</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cupertino Widgets</font></font></a> </li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget material</font></font></a> </li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget umum lainnya</font></font></a> </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda pergi ke bagian cupertino, Anda akan melihat bahwa widget ini tidak dapat dibedakan dari elemen iOS asli. </font><font style="vertical-align: inherit;">Sebagai pengembang yang telah menggunakan Flutter untuk sementara waktu, saya dapat mengonfirmasi bahwa mereka tidak dapat dibedakan. </font><font style="vertical-align: inherit;">Jika Anda menggunakan CupertinoDatePicker, misalnya, saat menggulir Anda akan merasakan hal yang persis sama, umpan balik yang bagus dari mesin Taptic / Haptic di iPhone Anda seolah-olah itu adalah elemen asli dari aplikasi asli. </font><font style="vertical-align: inherit;">Saya akan mengatakan lebih banyak, secara berkala saya membuka aplikasi situs realtor.com di iPhone saya dan sampai saat ini saya tidak tahu bahwa itu ditulis dalam Flutter (atau pada sesuatu yang bukan asli).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutter tidak hanya memungkinkan Anda untuk menggunakan widget "asli" untuk 2 platform, tetapi juga membuatnya sendiri, dan itu sangat mudah! Seluruh paradigma adalah bahwa semuanya berfungsi widget. Anda dapat membuat elemen UI dan animasi yang luar biasa kompleks dalam waktu singkat. Pesona dan kebijaksanaan pendekatan untuk bekerja dengan UI di Flutter baru-baru ini dijelaskan dalam </font><font style="vertical-align: inherit;">artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di Habr, saya sarankan membaca. Karena semua ini bekerja pada mesin grafis tunggal yang secara langsung merender semua ini untuk setiap platform (kita akan membicarakannya nanti), Anda dapat yakin bahwa semuanya akan ditampilkan sesuai rencana.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal lain yang cukup menakjubkan. </font><font style="vertical-align: inherit;">Flutter mendukung platform yang dimulai dengan iOS 8 dan Android API v16. </font><font style="vertical-align: inherit;">Dari perspektif rendering UI, Flutter tidak terlalu masalah API mana yang tersedia pada platform tertentu. </font><font style="vertical-align: inherit;">Dia akan memiliki kesempatan untuk bekerja dengan Canvas dan semacam interaksi dengan subsistem grafis. </font><font style="vertical-align: inherit;">Dan ini berarti kita dapat menggambar elemen UI terbaru dari AndroidX, misalnya, pada ponsel yang berusia 8 tahun. </font><font style="vertical-align: inherit;">Tentu saja ada pertanyaan tentang kinerja pendekatan ini pada platform tertua yang didukung, tetapi ini adalah pertanyaan lain.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kinerja UI Asli</font></font></h4><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/bs/as/ld/bsasld-hwweszsjqmucvaavtkyu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, pendekatan Flutter pada rendering UI lebih dekat dengan aplikasi hybrid seperti Ionic. </font><font style="vertical-align: inherit;">Kami memiliki satu mesin untuk rendering UI di semua platform, ini adalah </font><font style="vertical-align: inherit;">Perpustakaan Grafik </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Google membeli Skia sebagai produk pada tahun 2005 dan mengubahnya menjadi proyek Open Source. </font><font style="vertical-align: inherit;">Ini setidaknya menunjukkan bahwa ini adalah produk yang cukup matang. </font><font style="vertical-align: inherit;">Beberapa fitur kinerja Skia:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Copy-on-write</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk elemen grafik dan tipe data lainnya</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gunakan memori tumpukan sedapat mungkin untuk mengurangi fragmentasi </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keamanan benang, untuk paralelisasi yang lebih baik</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak menemukan tes kinerja Skia yang meyakinkan dibandingkan dengan perpustakaan serupa (lihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kairo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), tetapi beberapa tes menunjukkan kenaikan kinerja 50% rata-rata, kecuali dalam beberapa situasi tertentu. Ya, ini tidak terlalu penting, karena tes ini didasarkan pada penggunaan OpenGL pada desktop, dan ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skia dapat berinteraksi dengan banyak backend GPU. Sejak </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baru-baru ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">waktu di iOS, sejak versi 11, Flutter menggunakan Metal sebagai GPU backend secara default. Di Android, dimulai dengan API 24 - Vulkan. Untuk versi di bawah ini - OpenGL. Semua ini memberi kita keuntungan yang nyata dalam produktivitas. Pada platform "perangkat keras" lainnya, seperti yang saya pahami, Skia / Flutter menggunakan OpenGL, yang pada prinsipnya tidak menghalangi kita untuk menulis aplikasi dengan kinerja grafis yang memadai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Web terpisah. Saat ini, seluruh tampilan UI masih ada di bundel Canvas / HTML. Karena itu, Skia sama sekali tidak terlibat dalam proses ini. Plus, Dart VM tidak berinteraksi langsung dengan DOM. Pertama adalah konversi ke js. Semua ini tidak memiliki efek terbaik pada produktivitas dan langsung terlihat oleh mata telanjang. Namun, </font><font style="vertical-align: inherit;">pekerjaan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sedang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dilakukan untuk mengimplementasikan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CanvasKit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di Flutter, yang pada gilirannya akan memungkinkan Skia untuk digunakan di browser melalui WebGL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akhirnya, programmer C # telah menggunakan SkiaSharp untuk waktu yang relatif lama - pembungkus atas Skia untuk Mono / .Net x. </font><font style="vertical-align: inherit;">Dan komunitas Xamarin menggunakan lib ini untuk menggambar elemen UI khusus dan ini adalah perpustakaan yang sangat populer. </font><font style="vertical-align: inherit;">Jika ini bukan kemenangan, maka saya tidak tahu apa itu.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemampuan 100% untuk memanggil OS API apa pun</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam Flutter ada 2 prinsip interaksi dengan dunia "luar":</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saluran platform</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antarmuka fungsi asing</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saluran Platform memungkinkan Anda untuk berinteraksi dengan runtime / API asli melalui sistem pengiriman pesan. Dari sudut pandang arsitektur, ini dapat dilihat sebagai berikut. Secara visual, Flutter hanyalah Kanvas, yang direntangkan ke layar penuh di satu-satunya Activity / UIViewController aplikasi asli Anda. Ini persis pendekatan yang sama yang saya gunakan pengembang game (mesin game). Itu Anda dapat membuka proyek iOS / Android dari aplikasi Anda dan menambahkan fungsionalitas lain ke Swift / Kotlin / dll. Masalahnya adalah bahwa runtime asli dan Dart VM tidak akan tahu apa-apa tentang satu sama lain (selain fakta bahwa runtime asli akan tahu bahwa aplikasi memiliki Canvas dan ada sesuatu yang ditampilkan di sana). Lebih lanjut, jika Anda, misalnya, membuka file MainActivity.kt proyek Android Anda, Anda akan melihat sesuatu seperti ini:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span>: <span class="hljs-type">FlutterActivity</span></span>() {
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<font></font>
    GeneratedPluginRegistrant.registerWith(<span class="hljs-keyword">this</span>)<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pernahkah Anda memperhatikan bahwa Aktivitas Anda mewarisi dari FlutterActivity? Ini memberi kami peluang untuk mengonfigurasi mekanisme pengiriman pesan langsung ke Flutter / DartVM. Untuk melakukan ini, kita perlu mengganti metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">configureFlutterEngine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan itu akan menentukan nama metode yang dipanggil dan nama saluran untuk mengirim pesan asinkron. Semua. Ini memungkinkan untuk menulis kode asli apa pun kepada kami dan memanggil API asli apa pun! Pada saat yang sama, sudah ada sejumlah besar plugin (paket) yang menyelamatkan Anda dari penulisan kode asli, Anda hanya dapat menggunakan Dart. Ini luar biasa! Anda menulis UI secara terpisah dan sekali untuk platform apa pun, gunakan DartVM untuk bekerja dengan UI, I / O dan hanya sebagai komponen komputasi, gunakan plugin yang mengimplementasikan fitur asli dan yang mencakup 99% dari semua fungsionalitas. Dan jika ini tidak cukup, Anda menulis secara asli dan berkomunikasi melalui mekanisme pesan. Cerita.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mekanisme kedua adalah antarmuka fungsi Asing atau FFI. Ini adalah istilah yang cukup umum untuk mekanisme iterope dengan bahasa lain, terutama C. Di dunia .Net, mekanisme ini disebut P / Invoke, untuk JVM itu adalah JNI. Singkatnya, ini adalah kemampuan untuk berinteraksi dengan perpustakaan yang ditulis dalam C / C ++ / etc. Pada saat .Net Framework, misalnya, tidak ada perangkat lunak yang ditulis dalam C # dan sebagian besar perangkat lunak ditulis dalam C / C ++, sehingga diperlukan mekanisme untuk bekerja dengan perpustakaan ini. Hal yang sama berlaku untuk JVM, Python, sebut saja. FFI adalah satu atau lain cara yang digunakan dalam semua kerangka kerja lintas platform. Baru-baru ini, DartVM juga mulai mendukung FFI untuk interoperasi dengan C dan JavaScript! Meskipun fitur ini dalam cabang beta, tetapi sudah tersedia untuk digunakan (dengan risiko dan risiko Anda sendiri).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, Flutter dan DartVM mencakup 100% kemungkinan pada platform asli, dan bahkan lebih banyak lagi.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mudah dipelajari dan bahasa yang cukup ekspresif</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mengakui dengan jujur, sementara Dart bagi saya tetap bukan bahasa terbaik di dunia. Tidak ada sistem tipe yang ketat, tidak ada roti fungsional, seperti Pattern Matching atau fitur Immutability (seperti mereka akan dikirimkan segera), dll. Tentang sistem tipe, Dart pada awalnya dipahami sebagai bahasa "tanpa tipikal", ala JS, tetapi untuk dukungan normal untuk kompilasi AOT, tetap diperlukan untuk membawa sistem tipe ke yang lebih ketat, meskipun tidak sepenuhnya, menurut saya. Masih mengganggu saya untuk bekerja dengan tanda tangan metode, yaitu dengan argumen. Semua tanda kurung ini, </font></font><code>@required</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk beberapa alasan </font><font style="vertical-align: inherit;">, mengamuk </font><font style="vertical-align: inherit;">. Tapi panah adalah bahasa yang sangat mudah dipelajari. Dalam sintaksis, ini adalah persilangan antara Java dan JS untuk saya. Dart banyak memaafkan, seperti JS. Secara umum, ini adalah bahasa yang cukup mudah dipelajari, saya belum mengalami masalah berarti.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rantime yang cocok dengan paradigma pembangunan frontend</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita bicara tentang Dart VM. </font><font style="vertical-align: inherit;">Secara umum, Dart VM mencakup banyak hal, dari GC ke Profiler dan Observatory. </font><font style="vertical-align: inherit;">Di sini saya ingin berbicara hanya tentang GC dan runtime bersyarat. </font><font style="vertical-align: inherit;">Anda dapat membiasakan diri dengan cara kerja runtime dan terdiri dari apa di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Saya bukan ahli dalam bidang ini, tetapi untuk diri saya sendiri, saya mencatat beberapa keuntungan dari Dart VM, yang akan saya coba gambarkan. </font><font style="vertical-align: inherit;">Sebelum itu, saya ingin mencatat bahwa Dart dan VM yang sesuai pada awalnya dikembangkan sebagai pengganti JS, yang, seolah-olah, mengisyaratkan fokus pada pengembangan frontend. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isolat</font></font></b><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/_s/_n/kl/_s_nklwnaygqk8dey70z0yerdco.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dart VM memiliki konsep Isolate. Isolate adalah kombinasi dari satu utas utama yang berjalan langsung pada kode Dart dan heap terisolasi, di mana objek dari kode Dart sebenarnya dialokasikan. Ini adalah struktur yang disederhanakan. Isolate juga memiliki thread bantu / sistem, ada utas OS yang dapat masuk dan keluar dari Isolate, dll. Tumpukan juga ada di Isolate tetapi Anda, sebagai pengguna, tidak beroperasi di atasnya. Hal utama yang perlu ditekankan di sini adalah bahwa jika Anda melihat satu Isolate, maka ini adalah lingkungan utas tunggal. Secara default, Flutter menggunakan satu Isolate default. Tidak menyerupai apa pun? Ya ini adalah lingkungan JS. Sama seperti di JS, programmer Dart tidak dapat bekerja dengan multithreading. Seseorang mungkin berpikir bahwa ini adalah kekacauan, penyederhanaan dan pelanggaran hak-hak pengembang nyata, tapi saya pikir ketika bekerja dengan UI,ketika Anda beroperasi dengan DOM bersyarat (dan tidak menggambar poligon di layar), Anda tidak perlu; berbahaya untuk beroperasi dengan beberapa utas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini, tentu saja, saya licik, jika Anda benar-benar ingin, maka Anda dapat menggunakan Isolate yang diluncurkan secara terpisah untuk melakukan tugas paralel (halo WebWorkers) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda dapat melihat secara detail bagaimana Anda dapat bekerja dengan Isolate in Flutter tambahan. Secara umum, Isolates, seperti namanya, tidak tahu apa-apa tentang satu sama lain, tidak menjaga hubungan satu sama lain dan berkomunikasi melalui sistem pesan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain pendekatan single-thread, fakta bahwa tumpukan terpisah dialokasikan untuk setiap Isolat tanpa kemampuan untuk memanipulasi tumpukan utas ini, menurut pendapat saya, pendekatan yang sangat baik. Jika Anda menulis aplikasi server yang memanipulasi sejumlah besar garis, misalnya, dan garis-garis ini disimpan dalam tumpukan, di mana mereka muncul dan menghilang dengan kecepatan yang luar biasa, sambil memecah-mecah memori dan menambahkan pekerjaan GC, segala cara mentransfer garis-garis ini, atau setidaknya sebagian, dari tumpukan di tumpukan akan menghemat sumber daya dan meningkatkan kinerja. Contohnya begitu-begitu, tetapi Anda mengerti saya. Tetapi ketika bekerja dengan UI, di mana ada, kemungkinan, cukup banyak elemen UI yang dapat memiliki masa hidup yang pendek (misalnya, animasi), tetapi pada saat yang sama hanya satu klien dan jumlah data yang diproses dapat diabaikan dibandingkan dengan aplikasi server,kemampuan untuk langsung bekerja dengan stack sama sekali tidak perlu. Saya tidak berbicara tentang tinju / unboxing, yang bisa dalam hal ini dan yang benar-benar tidak ada gunanya. Dan perlu dicatat bahwa objek dalam Dart VM dialokasikan cukup sering. Bahkan untuk menghasilkan jumlah ganda dari metode Dart, VM secara terpisah mengalokasikan bagian di heap. Bagaimana GC menangani beban ini? Mari kita lihat.</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Young Space Scavenger (dan Parallel Mark Sweep)</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pertama, seperti semua GC, GC di Dart VM memiliki generasi. Juga, GC dalam Dart VM dapat dibagi sesuai dengan prinsip kerja menjadi 2 komponen: Young Space Scavenger dan Parallel Mark Sweep. Saya tidak akan membahas prinsip terakhir, ini adalah prinsip pembersihan memori yang cukup populer, yang diterapkan hampir di mana-mana dan tidak memberi Flutter keunggulan khusus. Kami tertarik pada yang pertama. Prinsip kerja Young Space Scavenger diilustrasikan dengan baik dalam gambar berikut:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d3/yq/ik/d3yqikji__3j3f9zehdkrm4-t0a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini jelas menunjukkan kelebihan dari pendekatan ini. Young Space Scavenger bekerja untuk objek-objek terbaru dalam memori, dapat kita katakan bahwa untuk generasi objek pertama / nol. Seringkali, dan ini adalah karakteristik dari Flutter / Dart VM, sebagian besar objek baru memiliki umur yang pendek. Dalam situasi di mana Anda mengalokasikan banyak objek yang tidak berumur panjang, memori bisa sangat terfragmentasi. Dalam hal ini, Anda harus membayar memori atau waktu prosesor untuk memperbaiki masalah (walaupun Anda seharusnya tidak memperbaiki masalah dengan metode tersebut). Young Space Scavenger menyelesaikan masalah ini. Jika Anda melihat gambar di atas, maka benar-benar tidak ada 6 langkah, Anda tidak perlu menghapus potongan memori pertama, secara default kami berpikir bahwa potongan ini kosong setelah menyalin objek ke yang kedua. Nah, ketika menyalin objek yang masih hidup ke potongan kedua,kami secara alami mengaturnya satu per satu tanpa membuat fragmentasi. Semua ini memungkinkan VM untuk mengalokasikan banyak objek baru dengan harga yang agak rendah.</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idle Time GC</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Seperti yang Anda pahami, tim Flutter dan Dart VM bekerja sama secara erat dan hasil kerja sama ini dapat dianggap sebagai Idle Time GC. Seperti namanya, ini adalah pengumpulan sampah saat tidak ada yang terjadi. Dalam konteks Flutter, pada saat ketika aplikasi secara visual tidak mengubah apa pun. Tidak ada animasi, gulir, atau interaksi pengguna. Pada saat-saat ini, Flutter mengirim pesan ke VM Dart yang sekarang, pada prinsipnya, adalah waktu yang tepat untuk memulai pengumpulan sampah. Selanjutnya, pengumpul sampah memutuskan apakah ia harus memulai pekerjaannya. Tentu saja, pengumpulan sampah dalam hal ini terjadi untuk objek yang lebih tua yang dikelola melalui Parallel Mark Sweep, yang dengan sendirinya merupakan proses yang agak mahal dan Idle Time GC adalah mekanisme yang sangat berguna dalam hal ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada hal-hal lain seperti</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komposisi Geser</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pointer Terkompresi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Yang pertama adalah mekanisme defragmentasi memori setelah menjalankan Parallel Mark Sweep. </font><font style="vertical-align: inherit;">Ini juga merupakan proses yang mahal dan hanya berfungsi jika ada Waktu Idle. </font><font style="vertical-align: inherit;">Pendekatan kedua, Compressed Pointer, kompres pointer 64-bit menjadi 32 bit, yang menghemat memori (saya pikir ini jauh lebih berguna di lingkungan server daripada di ponsel).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ringkasan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda membaca hingga baris ini, maka, pertama, selamat, dan kedua, saya harus mengatakan bahwa saya tidak punya pengalaman menulis artikel, jadi saya tidak mengerti jika saya berhasil menyampaikan maksud saya. Dan idenya sederhana, ketika Anda menulis aplikasi seluler dengan Flutter, ternyata asli. Dan dalam bentuk bonus Anda mendapatkan kecepatan pengembangan aplikasi yang sangat baik. Hot Reload / Restart hanyalah hal yang sangat diperlukan dalam pengembangan Frontend. Bisakah Anda membayangkan beberapa penyetel yang perlu membangun / mengkompilasi seluruh proyek untuk setiap browser, misalnya, dengan setiap perubahan warna tombol? Tentu saja tidak. Secara umum, Hot Reload / Restart layak mendapatkan artikel terpisah. Tapi saya terganggu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengalaman saya dengan Flutter memberi tahu saya bahwa kerangka kerja ini akan dominan dalam waktu dekat. </font><font style="vertical-align: inherit;">Secara berkala, saya melakukan wawancara untuk posisi pengembang Flutter dan dalam setengah kasus, perusahaan yang mencari pengembang Flutter sebenarnya memiliki staf pengembang asli seluler. </font><font style="vertical-align: inherit;">Mereka hanya mencoba Flutter pada proyek interior / samping, puas / senang dan perlahan-lahan pindah ke Flutter. </font><font style="vertical-align: inherit;">Bagi saya ini adalah kemenangan yang nyata. </font><font style="vertical-align: inherit;">Apa yang tidak bisa dikatakan tentang Xamarin, sayangnya. </font><font style="vertical-align: inherit;">Cukup sering, keputusan untuk memilih Xamarin semata-mata karena fakta bahwa sisa tumpukan ditulis dalam. Net, dan ini adalah lereng yang licin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai rangkuman, saya ingin mengatakan bahwa jika Anda berpikir tentang sisi mana yang harus didekati ketika mengembangkan aplikasi seluler baru Anda, lihat Flutter.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id501328/index.html">Memperkenalkan Visual Studio Codespaces: Cloud Development, Dimanapun Anda Berada</a></li>
<li><a href="../id501330/index.html">Layanan microser di C ++. Fiksi atau kenyataan?</a></li>
<li><a href="../id501332/index.html">Rapat itu mudah. Tiga tips latihan harian</a></li>
<li><a href="../id501336/index.html">FOSS News No. 15 - ulasan berita gratis dan sumber terbuka untuk 4-10 Mei 2020</a></li>
<li><a href="../id501338/index.html">Di dalam mesin virtual Python. Bagian 1</a></li>
<li><a href="../id501342/index.html">Sertifikasi Online Microsoft - Catatan Lapangan</a></li>
<li><a href="../id501344/index.html">Ventilasi pasokan dikombinasikan dengan AC saluran (bagian 1 - listrik)</a></li>
<li><a href="../id501346/index.html">Tinjauan umum tentang keyboard mekanis Vortex Core RGB</a></li>
<li><a href="../id501352/index.html">Kafka menyerang balik</a></li>
<li><a href="../id501354/index.html">Tampilan baru pada gaya kode</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>