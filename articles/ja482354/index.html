<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏽 🚣🏾 👙 ConfigureAwait：よくある質問 🙋🏽 🔕 🏴󠁧󠁢󠁷󠁬󠁳󠁿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！Stephen Taubによる記事「ConfigureAwait FAQ」の翻訳を紹介します。
 
 
 
 Async/ await は7年以上前に.NETに追加されました。この決定は、.NETエコシステムだけでなく、他の多くの言語やフレームワークにも反映されています。現時点で...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ConfigureAwait：よくある質問</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482354/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！</font><font style="vertical-align: inherit;">Stephen Taubによる</font><font style="vertical-align: inherit;">記事</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ConfigureAwait FAQ」の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳を紹介します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ps/pj/sm/pspjsmmgsimr2lachonj6idmnj8.png" alt="画像"><br>
<br>
<code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>await </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は7年以上前に.NETに追加されました。この決定は、.NETエコシステムだけでなく、他の多くの言語やフレームワークにも反映されています。現時点では、.NETの多くの改善が非同期を使用する追加の言語構成要素に関して実装されており、非同期サポートを備えたAPIが実装されています。インフラストラクチャでは</font><font style="vertical-align: inherit;">、時計のよう</font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font></font><code>await </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能</font><font style="vertical-align: inherit;">するため、基本的な改善が行われています</font><font style="vertical-align: inherit;">（特に、パフォーマンスと診断機能）。 NET Core）。</font></font><br>
<br>
<code>ConfigureAwait </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-一面</font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それは質問を上げ続けています。</font><font style="vertical-align: inherit;">それらの多くに答えられることを願っています。</font><font style="vertical-align: inherit;">私は、この記事を最初から最後まで読みやすくすると同時に、よくある質問への回答（FAQ）のスタイルで実行できるようにして、将来参照できるようにします。</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際に対処するために</font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、少し前に戻ります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SynchronizationContextとは何ですか？</font></font></h3><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Threading.SynchronizationContextの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ドキュメントによると、</font><font style="vertical-align: inherit;">「さまざまな同期モデルで同期コンテキストを配布するための基本的な機能を提供します。」この定義は完全に明白ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
99.9％のケースでは</font><font style="vertical-align: inherit;">、非同期実行のデリゲートを受け入れる</font></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想メソッド</font></font><code>Post</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">持つ型として単に使用さ</font><font style="vertical-align: inherit;">れます（</font></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他の仮想メンバーがありますが、あまり一般的ではないため、この記事では説明しません）。</font></font><code>Post </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本型の</font><font style="vertical-align: inherit;">方法は、</font><font style="vertical-align: inherit;">文字通り</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ただ呼び出す</font></font></a> <code>ThreadPool.QueueUserWorkItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供デリゲートを非同期に実行するため。派生型はオーバーライドされる</font></font><code>Post</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、デリゲートは適切な場所で適切なタイミングで実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、WindowsフォームにはSynchronizationContextから派生した</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があり、これ</font><font style="vertical-align: inherit;">をオーバーライド</font></font><code>Post</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して同等のを作成</font><font style="vertical-align: inherit;">します</font></font><code>Control.BeginInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。つまり、この</font></font><code>Post</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドを呼び出すと、対応するコントロールに関連付けられたスレッド（いわゆるUIスレッド）の後の段階でデリゲートが呼び出されます。 Windowsフォームの中心は、Win32メッセージ処理です。メッセージループは、新しいメッセージが処理されるのを待つUIスレッドで実行されます。これらのメッセージは、マウスの移動、クリック、キーボード入力、デリゲートによる実行に利用できるシステムイベントなどによってトリガーされます。したがって、</font></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowsフォームアプリケーションにUIスレッドの</font><font style="vertical-align: inherit;">インスタンスがある場合</font><font style="vertical-align: inherit;">、その中で操作を実行するには、デリゲートをメソッドに渡す必要があります</font></font><code>Post</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows Presentation Foundation（WPF）にも</font><font style="vertical-align: inherit;">、同様にデリゲートをUIストリームに（「を使用して」）リダイレクト</font><font style="vertical-align: inherit;">するオーバーライドされたメソッド</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">持つ</font><font style="vertical-align: inherit;">派生</font></font><code>SynchronizationContext </code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があり</font><font style="vertical-align: inherit;">、これはWindowsフォームコントロールではなくWPFマネージャーによって制御されます。</font><font style="vertical-align: inherit;">
また、Windows RunTime（WinRT）には独自の</font><font style="vertical-align: inherit;">派生</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">型があり</font></a><font style="vertical-align: inherit;">、これによってデリゲートがと共にUIスレッドキューに配置され</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">
これが「UIスレッドでデリゲートを実行する」というフレーズの背後にあるものです。また、独自</font><font style="vertical-align: inherit;">のメソッド</font><font style="vertical-align: inherit;">といくつかの実装</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">実装することもできます</font><font style="vertical-align: inherit;">。たとえば、デリゲートが実行されているスレッドを心配することはできませんが</font><font style="vertical-align: inherit;">、自分</font><font style="vertical-align: inherit;">のメソッドのデリゲートが</font></font><code>Post</code><font style="vertical-align: inherit;"></font><code>Dispatcher.BeginInvoke</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><code>CoreDispatcher</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"></font><code>Post </code><font style="vertical-align: inherit;"></font><code>Post </code><font style="vertical-align: inherit;"></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ある程度の並列処理で実行されます。</font></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この方法で</font><font style="vertical-align: inherit;">スペシャル</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">実装できます</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MaxConcurrencySynchronizationContext</span> : <span class="hljs-title">SynchronizationContext</span><font></font>
{<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> SemaphoreSlim _semaphore;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxConcurrencySynchronizationContext</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> maxConcurrencyLevel</span>)</span> =&gt;<font></font>
        _semaphore = <span class="hljs-keyword">new</span> SemaphoreSlim(maxConcurrencyLevel);<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Post</span>(<span class="hljs-params">SendOrPostCallback d, <span class="hljs-keyword">object</span> state</span>)</span> =&gt;<font></font>
        _semaphore.WaitAsync().ContinueWith(<span class="hljs-keyword">delegate</span><font></font>
        {<font></font>
            <span class="hljs-keyword">try</span> { d(state); } <span class="hljs-keyword">finally</span> { _semaphore.Release(); }<font></font>
        }, <span class="hljs-keyword">default</span>, TaskContinuationOptions.None, TaskScheduler.Default);<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Send</span>(<span class="hljs-params">SendOrPostCallback d, <span class="hljs-keyword">object</span> state</span>)</span><font></font>
    {<font></font>
        _semaphore.Wait();<font></font>
        <span class="hljs-keyword">try</span> { d(state); } <span class="hljs-keyword">finally</span> { _semaphore.Release(); }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
xUnitフレームワークには、</font><font style="vertical-align: inherit;">SynchronizationContextの</font><font style="vertical-align: inherit;">同様の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装があり</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。ここでは、並列テストに関連するコードの量を減らすために使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでの利点は、抽象化の場合と同じです。実装の詳細を知らなくても、プログラマが望む方法でデリゲートをキューに入れるために使用できる単一のAPIが提供されます。いくつかの作業を行う必要があるライブラリを作成し、デリゲートをキューに入れて元のコンテキストに戻すとします。これを行うには、それをキャプチャする必要があります。</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要なものが終了したら、</font></font><code>Post </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このコンテキスト</font><font style="vertical-align: inherit;">のメソッドを呼び出して、</font><font style="vertical-align: inherit;">実行のためにデリゲートを渡すだけで済みます。 Windowsフォームで何をする必要があるかを知る必要はありません</font></font><code>Control </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そしてそれを使用する</font></font><code>BeginInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WPFを使用するために、</font></font><code>BeginInvoke </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uを</font></font><code>Dispatcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、または何らかの形でコンテキストとのxUnitのためにそのターンを取得します。</font><font style="vertical-align: inherit;">私がしなければならないのは、現在のもの</font></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">つかん</font><font style="vertical-align: inherit;">で後で使うことだけです。</font><font style="vertical-align: inherit;">このため</font></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のプロパティがあります</font></font><code>Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは次のように実装できます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoWork</span>(<span class="hljs-params">Action worker, Action completion</span>)</span><font></font>
{<font></font>
    SynchronizationContext sc = SynchronizationContext.Current;<font></font>
    ThreadPool.QueueUserWorkItem(_ =&gt;<font></font>
    {<font></font>
        <span class="hljs-keyword">try</span> { worker(); }
        <span class="hljs-keyword">finally</span> { sc.Post(_ =&gt; completion(), <span class="hljs-literal">null</span>); }<font></font>
    });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><code>Current </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドを使用して</font><font style="vertical-align: inherit;">
、プロパティから特別なコンテキストを設定できます</font></font><code>SynchronizationContext.SetSynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスクスケジューラとは</font></font></h3><br>
<code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは「プランナー」の一般的な抽象概念です。一部のフレームワークには、彼のために実装された独自の抽象化があり</font></font><code>System.Threading.Tasks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、例外</font><font style="vertical-align: inherit;">はあり</font><font style="vertical-align: inherit;">ません。</font></font><code>Task </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キューに入れて実行できる代理人がいる</font><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">、代理人はに関連付けられ</font></font><code>System.Threading.Tasks.TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><code>Post </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デリゲートをキューに入れるための</font><font style="vertical-align: inherit;">仮想メソッドもあり</font><font style="vertical-align: inherit;">（デリゲート呼び出しは標準メカニズムを使用して実装され</font></font><code>TaskScheduler </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">）、</font><font style="vertical-align: inherit;">抽象メソッドを提供します</font></font><code>QueueTask </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（タスクコールはメソッドを使用して実装されます</font></font><code>ExecuteTask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
返されるデフォルトのスケジューラ</font></font><code>TaskScheduler.Default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はスレッドプールです。あり</font></font><code>TaskScheduler </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">得ると呼び出しの時間と場所を設定するためのメソッドをオーバーライドすることも可能</font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。たとえば、主要なライブラリにはタイプが含まれています</font></font><code>System.Threading.Tasks.ConcurrentExclusiveSchedulerPair</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このクラスのインスタンスは、2つのプロパティを提供します</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><code>ExclusiveScheduler </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>ConcurrentScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。でスケジュールされたタスク</font></font><code>ConcurrentScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は並行して実行できますが</font></font><code>ConcurrentExclusiveSchedulerPair </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、作成時に</font><font style="vertical-align: inherit;">指定さ</font><font style="vertical-align: inherit;">れ</font><font style="vertical-align: inherit;">た制約を考慮に入れます</font><font style="vertical-align: inherit;">（同様に</font></font><code>MaxConcurrencySynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><code>ConcurrentScheduler </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスク</font></font><code>ExclusiveScheduler </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bが実行され、一度に実行できる排他タスクが1つだけの</font><font style="vertical-align: inherit;">場合、タスク</font><font style="vertical-align: inherit;">は実行</font><font style="vertical-align: inherit;">され</font><font style="vertical-align: inherit;">ません</font><font style="vertical-align: inherit;">。この動作は、読み取り/書き込みロックと非常によく似ています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">現在の</font></font><code>TaskScheduler </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティ</font></font><code>Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を返す</font><font style="vertical-align: inherit;">プロパティ</font><font style="vertical-align: inherit;">があります</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ただし、</font></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それ</font><font style="vertical-align: inherit;">とは異なり</font><font style="vertical-align: inherit;">、現在のスケジューラをインストールする方法はありません。代わりに、スケジューラは現在のタスクに関連付けられています</font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。したがって、たとえば、このプログラムはを出力します</font></font><code>True</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>StartNew</code><font style="vertical-align: inherit;"></font><code>ExclusiveScheduler </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インスタンス</font></font><code>ConcurrentExclusiveSchedulerPair</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">実行され、</font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このスケジューラにインストールされ</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Threading.Tasks;<font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> cesp = <span class="hljs-keyword">new</span> ConcurrentExclusiveSchedulerPair();<font></font>
        Task.Factory.StartNew(() =&gt;<font></font>
        {<font></font>
            Console.WriteLine(TaskScheduler.Current == cesp.ExclusiveScheduler);<font></font>
        }, <span class="hljs-keyword">default</span>, TaskCreationOptions.None, cesp.ExclusiveScheduler).Wait();<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味深いことに、これ</font></font><code>TaskScheduler </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は静的メソッド</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">提供します</font></font><code>FromCurrentSynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">メソッドは新しい</font></font><code>TaskScheduler </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスクを</font><font style="vertical-align: inherit;">作成</font></font><code>SynchronizationContext.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、メソッドを使用</font><font style="vertical-align: inherit;">して、返された</font><font style="vertical-align: inherit;">コンテキスト</font><font style="vertical-align: inherit;">で実行するタスクをキューに入れます</font></font><code>Post</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SynchronizationContextとTaskSchedulerはどのように待機に関連していますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ボタンを備えたUIアプリケーションを作成する必要があるとしましょう。</font><font style="vertical-align: inherit;">ボタンを押すと、Webサイトからテキストがダウンロードされ、</font></font><code>Content </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボタンに</font><font style="vertical-align: inherit;">設定され</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">ボタンは、それが配置されているストリームのUIからのみアクセスできるようにする必要があります。したがって、日付と時刻を正常にロードして</font></font><code>Content </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボタン</font><font style="vertical-align: inherit;">に配置したい場合は、</font><font style="vertical-align: inherit;">ボタンを制御しているストリームからこれを行う必要があります。</font><font style="vertical-align: inherit;">この条件が満たされない場合、例外が発生します。</font></font><br>
<br>
<pre><code class="cs hljs">System.InvalidOperationException: <span class="hljs-string">'        ,     .'</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手動で使用</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して</font></font><code>Content </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、たとえば次の</font><font style="vertical-align: inherit;">よう</font><font style="vertical-align: inherit;">に、ソースコンテキスト</font><font style="vertical-align: inherit;">にインストール</font><font style="vertical-align: inherit;">でき</font><font style="vertical-align: inherit;">ます</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> HttpClient s_httpClient = <span class="hljs-keyword">new</span> HttpClient();<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">downloadBtn_Click</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> sender, RoutedEventArgs e</span>)</span><font></font>
{<font></font>
    s_httpClient.GetStringAsync(<span class="hljs-string">"http://example.com/currenttime"</span>).ContinueWith(downloadTask =&gt;<font></font>
    {<font></font>
        downloadBtn.Content = downloadTask.Result;<font></font>
    }, TaskScheduler.FromCurrentSynchronizationContext());<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして</font></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接</font><font style="vertical-align: inherit;">使用できます</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> HttpClient s_httpClient = <span class="hljs-keyword">new</span> HttpClient();<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">downloadBtn_Click</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> sender, RoutedEventArgs e</span>)</span><font></font>
{<font></font>
    SynchronizationContext sc = SynchronizationContext.Current;<font></font>
    s_httpClient.GetStringAsync(<span class="hljs-string">"http://example.com/currenttime"</span>).ContinueWith(downloadTask =&gt;<font></font>
    {<font></font>
        sc.Post(<span class="hljs-keyword">delegate</span><font></font>
        {<font></font>
            downloadBtn.Content = downloadTask.Result;<font></font>
        }, <span class="hljs-literal">null</span>);<font></font>
    });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、これらのオプションはどちらも明示的にコールバックを使用します。</font><font style="vertical-align: inherit;">代わりに</font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font><font style="vertical-align: inherit;">を使用できます</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> HttpClient s_httpClient = <span class="hljs-keyword">new</span> HttpClient();<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">downloadBtn_Click</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> sender, RoutedEventArgs e</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">string</span> text = <span class="hljs-keyword">await</span> s_httpClient.GetStringAsync(<span class="hljs-string">"http://example.com/currenttime"</span>);<font></font>
    downloadBtn.Content = text;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><code>Content </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上記の手動で実装されたバージョンの場合、デフォルトでは、タスク待機は</font></font><code>SynchronizationContext.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">およびを</font><font style="vertical-align: inherit;">参照するため</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">
これらすべてが「正常に機能」</font><font style="vertical-align: inherit;">し、UIスレッドで</font><font style="vertical-align: inherit;">正常に構成</font><font style="vertical-align: inherit;">されます</font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 C＃で何かを「期待」すると、コンパイラーはコードを変換して（メソッドを呼び出すことにより</font></font><code>GetAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）「待機中」（</font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">の「期待」（この場合はタスク）</font><font style="vertical-align: inherit;">をポーリングし</font><font style="vertical-align: inherit;">ます。 「待機」は、待機が完了したときに状態マシンにコールバックするコールバック（「継続」と呼ばれることが多い）をアタッチする役割を果たします。彼は、コールバック登録中に取得したコンテキスト/スケジューラーを使用してこれを実装します。少し最適化して構成します。これは次のようなものです。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">object</span> scheduler = SynchronizationContext.Current;
<span class="hljs-keyword">if</span> (scheduler <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span> &amp;&amp; TaskScheduler.Current != TaskScheduler.Default)<font></font>
{<font></font>
    scheduler = TaskScheduler.Current;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、まず設定されているかどうかをチェックし</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">設定されて</font><font style="vertical-align: inherit;">いない場合は非標準のものがあるかどうかを</font><font style="vertical-align: inherit;">チェックします</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">存在する場合、コールバックがコールの準備ができると、キャプチャされたスケジューラが使用されます。</font><font style="vertical-align: inherit;">そうでない場合、コールバックは、予期されたタスクを完了する操作の一部として実行されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureAwaitの機能（false）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドは</font></font><code>ConfigureAwait </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特別ではありません。コンパイラやランタイムによって特別な方法で認識されることはありません。これは、構造を返し（</font></font><code>ConfiguredTaskAwaitable </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元のタスクをラップする）、ブール値を取る</font><font style="vertical-align: inherit;">一般的なメソッド</font><font style="vertical-align: inherit;">です。</font></font><code>await </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正しいパターンを実装する任意のタイプで使用できることを</font><font style="vertical-align: inherit;">忘れないでください</font><font style="vertical-align: inherit;">。別のタイプが返された場合、これは、コンパイラが</font></font><code>GetAwaiter </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インスタンス</font><font style="vertical-align: inherit;">のメソッド</font><font style="vertical-align: inherit;">（パターンの一部）に</font><font style="vertical-align: inherit;">アクセスする</font><font style="vertical-align: inherit;">が</font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、タスクから直接ではなく、から</font><font style="vertical-align: inherit;">返されたタイプから</font><font style="vertical-align: inherit;">アクセスすることを意味し</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。これにより</font></font><code>await </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、この特別なウェイターの</font><font style="vertical-align: inherit;">動作を変更できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
待機する</font></font><code>ConfigureAwait(continueOnCapturedContext: false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代わりに</font><font style="vertical-align: inherit;">返されたタイプ</font><font style="vertical-align: inherit;">を待機</font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">することは、上記で説明したコンテキスト/スケジューラキャプチャの実装に直接影響します。ロジックは次のようになります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">object</span> scheduler = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">if</span> (continueOnCapturedContext)<font></font>
{<font></font>
    scheduler = SynchronizationContext.Current;<font></font>
    <span class="hljs-keyword">if</span> (scheduler <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span> &amp;&amp; TaskScheduler.Current != TaskScheduler.Default)<font></font>
    {<font></font>
        scheduler = TaskScheduler.Current;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言い換える</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、コールバックの現在のコンテキストまたはスケジューラを使用していても、それが欠落していることを示しています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜConfigureAwait（false）を使用する必要があるのですか？</font></font></h3><br>
<code>ConfigureAwait(continueOnCapturedContext: false) </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元のコンテキストまたはスケジューラでの強制的なコールバックを防止するために使用されます。これにはいくつかの利点があり</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。パフォーマンスの向上。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出しだけではなく、コールバックをキューイングするオーバーヘッドがあります。これは、追加の作業（および通常は追加の割り当て）を必要とするためです。さらに、実行時に最適化を使用することはできません（コールバックがどのように呼び出されるかが正確にわかっている場合はさらに最適化できますが、抽象化の任意の実装に渡されると、制限が課される場合があります）。負荷の高いエリアでは、現在</font></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および現在の</font><font style="vertical-align: inherit;">チェックのための追加コストも</font></font><code>TaskScheduler </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（どちらも静的フローへのアクセスを意味します）オーバーヘッドが大幅に増加する可能性があります。後のコード</font></font><code>await </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が元のコンテキストで実行する必要がない</font><font style="vertical-align: inherit;">場合、</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それを</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">すると、これらの費用をすべて回避できます。不必要にキューに入れる必要がないため、利用可能なすべての最適化を使用でき、ストリームの静的への不要なアクセスも回避できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デッドロック防止。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font></font><code>await </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">してネットワークから何かをダウンロード</font><font style="vertical-align: inherit;">するライブラリメソッドを検討してください</font><font style="vertical-align: inherit;">。あなたは使用して、例えば、完了タスクのタスクを待って、この方法および同期ブロックを呼び出す</font></font><code> .Wait()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か、</font></font><code>.Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>.GetAwaiter()</code> <code>.GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。現在の呼び出しが発生した場合にどうなるかを考えてみましょう</font></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"></font><code>MaxConcurrencySynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が使用する単一のスレッド（UIスレッドなど）のコンテキストである場合は、</font><font style="vertical-align: inherit;">明示的に</font><font style="vertical-align: inherit;">、または暗黙</font><font style="vertical-align: inherit;">的に使用して</font><font style="vertical-align: inherit;">、その</font><font style="vertical-align: inherit;">中の操作の数を1に制限します</font><font style="vertical-align: inherit;">。したがって、単一のスレッドでメソッドを呼び出し、それをブロックして、操作が完了するのを待ちます。ダウンロードはネットワーク経由で開始され、その完了を待ちます。デフォルトでは、待機は</font></font><code>Task </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在の</font><font style="vertical-align: inherit;">待機を</font><font style="vertical-align: inherit;">キャプチャし</font></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（この場合も同様）、ネットワークからのダウンロードが完了すると、キューに入れられてコールバックに戻ります。</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これにより、残りの操作が呼び出されます。ただし、キュー内のコールバックを処理できる唯一のスレッドは、操作の完了を待機している間、現在ブロックされています。そして、この操作はコールバックが処理されるまで完了しません。デッドロック！コンテキストが同時実行性を1に制限していない場合でも発生する可能性がありますが、リソースは何らかの方法で制限されています。同じ状況を想像してください。</font></font><code>MaxConcurrencySynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">操作を1回実行する代わりに、コンテキストの4つの呼び出しをキューに入れます。</font><font style="vertical-align: inherit;">各呼び出しが行われ、その完了を見越してロックされます。</font><font style="vertical-align: inherit;">すべてのリソースは、非同期メソッドの完了を待ってブロックされるようになりました。リソースの完了を許可するのは、それらのコールバックがこのコンテキストによって処理される場合のみです。</font><font style="vertical-align: inherit;">しかし、彼はすでに完全に占領されています。</font><font style="vertical-align: inherit;">再びデッドロック。</font><font style="vertical-align: inherit;">代わり</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">ライブラリメソッドを使用した場合</font><font style="vertical-align: inherit;">、コールバックを元のコンテキストにキューイングしないため、デッドロックスクリプトが回避されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureAwait（true）を使用する必要がありますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いいえ、使用していないものを明示的に示す必要がある場合を除きます</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（たとえば、静的分析の警告を非表示にするなど）。</font></font><code>ConfigureAwait(true) </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">意味のあることは何もしません。</font><font style="vertical-align: inherit;">あなたが比較する</font></font><code>await task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>await task.ConfigureAwait(true)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-それらは機能的に同一になります。</font><font style="vertical-align: inherit;">したがって、コード</font></font><code>ConfigureAwait(true)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">存在する場合は、</font><font style="vertical-align: inherit;">悪影響を与えることなく削除できます。</font><font style="vertical-align: inherit;">状況によっては、構成を制御するために変数を渡す必要があるため、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッド</font></font><code>ConfigureAwait </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は論理値を取ります。</font><font style="vertical-align: inherit;">ただし、99％の場合、falseが設定され</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いつConfigureAwaitを使用するか（false）？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションレベルのコードを実装するか、汎用のライブラリコードを実装するかによって異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションを作成する場合、通常、いくつかのデフォルトの動作が必要です。アプリケーションモデル/環境（たとえば、Windowsフォーム、WPF、ASP.NET Core）が特別なものを公開する</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、これには十分な理由があります。これは、コードがアプリケーションモデル/環境との適切な相互作用のために同期コンテキストを処理できることを意味します。たとえば、アプリケーションモデルが公開されているかどうかに関係なく、Windowsフォームアプリケーションでイベントハンドラー、xUnitでのテスト、またはASP.NET MVCコントローラーでコードを記述する場合、アプリケーションモデルがある</font><font style="vertical-align: inherit;">場合</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それ</font><font style="vertical-align: inherit;">を使用する必要があり</font><font style="vertical-align: inherit;">ます。これは、使用され</font></font><code>ConfigureAwait(true)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ている</font><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">、</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コールバック/継続が元のコンテキストに送り返されます-すべてが正常に行われます。</font><font style="vertical-align: inherit;">ここから、一般的なルールを策定でき</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。アプリケーションレベルのコードを記述する場合</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、使用しない</font></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><i><font style="vertical-align: inherit;">ください</font></i></font><code>ConfigureAwait(false)</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">クリックハンドラーに戻りましょう。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> HttpClient s_httpClient = <span class="hljs-keyword">new</span> HttpClient();<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">downloadBtn_Click</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> sender, RoutedEventArgs e</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">string</span> text = <span class="hljs-keyword">await</span> s_httpClient.GetStringAsync(<span class="hljs-string">"http://example.com/currenttime"</span>);<font></font>
    downloadBtn.Content = text;<font></font>
}</code></pre><br>
<code>downloadBtn.Content = text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元のコンテキストで実行する必要があります。</font><font style="vertical-align: inherit;">コードがこのルールに違反し、代わり</font></font><code>ConfigureAwait (false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にそれを使用した場合、元のコンテキストでは使用されません。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> HttpClient s_httpClient = <span class="hljs-keyword">new</span> HttpClient();<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">downloadBtn_Click</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> sender, RoutedEventArgs e</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">string</span> text = <span class="hljs-keyword">await</span> s_httpClient.GetStringAsync(<span class="hljs-string">"http://example.com/currenttime"</span>).ConfigureAwait(<span class="hljs-literal">false</span>); <span class="hljs-comment">// </span><font></font>
    downloadBtn.Content = text;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは不適切な動作につながります。</font><font style="vertical-align: inherit;">同じことが、古典的なASP.NET依存アプリケーションのコードにも当てはまります</font></font><code>HttpContext.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用した場合、</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その後関数を使用しようとする</font></font><code>Context.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と問題が発生する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが、汎用ライブラリを区別するものです。彼らは彼らが使用されている環境を気にしないので、一部には普遍的です。それらは、Webアプリケーション、クライアントアプリケーション、またはテストから使用できます。ライブラリコードは、それを使用できるアプリケーションモデルに依存しないため、問題ではありません。 Agnosticは、ライブラリがアプリケーションモデルと対話するために何もしないことも意味します。たとえば、汎用ライブラリはそれらについて何も知らないため、ユーザーインターフェイスコントロールにアクセスできません。特定の環境でコードを実行する必要がないため、継続/コールバックを強制的に元のコンテキストに強制することを回避でき、これを使用してこれを行います</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これにより、パフォーマンスと信頼性が向上します。これにより、次のようになります。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">汎用ライブラリコードを記述している場合は、を使用します</font></font><code>ConfigureAwait(false)</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これが、.NET Coreランタイムライブラリで待機するすべて（またはほぼすべて）がConfigureAwait（false）を使用する理由です。バグである可能性が高いいくつかの例外を除いて、それらは修正されます。たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このPR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はの欠落した呼び出し</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">修正し</font><font style="vertical-align: inherit;">ました</font></font><code>HttpClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、これはどこでも意味がありません。</font><font style="vertical-align: inherit;">たとえば、汎用ライブラリの大きな例外の1つ（または少なくともそれについて考える必要がある場合）は、これらのライブラリに呼び出しへのデリゲートを受け入れるAPIがある場合です。</font><font style="vertical-align: inherit;">このような場合には、ライブラリーは非常に論争の汎用ライブラリのためにこれらの仮定を行い、発信者からの潜在的なアプリケーションレベルのコードを受け入れ想像し、例えば、どこLINQメソッドの非同期バージョン：。</font></font><code>public static async IAsyncEnumerable&lt;T&gt; WhereAsync(this IAsyncEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; predicate)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">万一それが</font></font><code>predicate </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元で呼び出すこと</font></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？それは実装に依存して、呼び出し元のコード</font></font><code>WhereAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、そしてこれが彼がそれを使用しないことに決めた理由</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特別な場合でも、一般的な推奨事項に従ってください：</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 汎用ライブラリ/ app-model-agnosticコードを記述している場合。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureAwait（false）は、コールバックが元のコンテキストで実行されないことを保証しますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いいえ、これにより、元のコンテキストのキューに入れられなくなります。</font><font style="vertical-align: inherit;">ただし、これは、後のコード</font></font><code>await </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が元のコンテキストで実行されないことを</font><font style="vertical-align: inherit;">意味しません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、すでに完了した操作が同期的に返され、強制的にキューに返されるわけではないためです。</font><font style="vertical-align: inherit;">したがって、待機時間までに完了したタスクを使用するかどうかに関係なく、そのタスクが予期されている場合</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その直後のコードは、現在も有効なコンテキストで現在のスレッドで実行され続けます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドの最初の待機でのみConfigureAwait（false）を使用できますが、残りの待機では使用できませんか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的には違います。以前のFAQを思い出してください。</font></font><code>await task.ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待機時間までに完了したタスクが含まれている</font><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">（実際にはかなり頻繁に発生します）、</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドはメソッド内で次のコードを実行し続け、以前と同じコンテキストにあるため、</font><font style="vertical-align: inherit;">使用して</font><font style="vertical-align: inherit;">も意味がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注目すべき例外の1つは、最初の</font></font><code>await </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントは常に非同期で終了し、予期された操作は、特別な</font></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">orの</font><font style="vertical-align: inherit;">ない環境でコールバックすること</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。たとえば</font></font><code>CryptoStream </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ランタイムライブラリでは、.NETは潜在的に計算集中型のコードが呼び出し側コードの同期呼び出しの一部として実行されていないことを確認します。これを行うには、彼は特別な</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">awaiter</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の待機後のコードがスレッドプールスレッドで実行されるようにします。</font><font style="vertical-align: inherit;">ただし、この場合でも、次の待機がまだを使用していることがわかり</font></font><code> ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">技術的にはこれは必須ではありませんが、使用されなかった理由を理解する必要がないため、コードレビューが大幅に簡略化され</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.Runを使用してConfigureAwait（false）の使用を回避することは可能ですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、書いた場合：</font></font><br>
<br>
<pre><code class="cs hljs">Task.Run(<span class="hljs-keyword">async</span> <span class="hljs-keyword">delegate</span><font></font>
{<font></font>
    <span class="hljs-keyword">await</span> SomethingAsync(); <span class="hljs-comment">//    </span>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font></font><code>SomethingAsync()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デリゲートに渡されるように、余分であろう</font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームスレッドプールで実行される上記のコードには変化が、その結果、</font></font><code>SynchronizationContext.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値を返しません</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。さらに、</font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暗黙的に使用する</font></font><code>TaskScheduler.Default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、</font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デリゲート内の値も返されます</font></font><code>Default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。つまり、</font></font><code>await </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用されたかどうかに関係なく、同じ動作をし</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。また、指定されたラムダ内のコードで何ができるかを保証できません。コードがある場合：</font></font><br>
<br>
<pre><code class="cs hljs">Task.Run(<span class="hljs-keyword">async</span> <span class="hljs-keyword">delegate</span><font></font>
{<font></font>
    SynchronizationContext.SetSynchronizationContext(<span class="hljs-keyword">new</span> SomeCoolSyncCtx());
    <span class="hljs-keyword">await</span> SomethingAsync(); <span class="hljs-comment">//    SomeCoolSyncCtx</span>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、内部のコード</font></font><code>SomethingAsync </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は実際に</font></font><code>SynchronizationContext.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インスタンスを</font><font style="vertical-align: inherit;">参照し</font><font style="vertical-align: inherit;">ます</font></font><code>SomeCoolSyncCtx </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これ</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、SomethingAsync内の未構成の期待の</font><font style="vertical-align: inherit;">両方</font><font style="vertical-align: inherit;">が、このコンテキストに返されます。したがって、このアプローチを使用するには、キューに入れたすべてのコードが実行できることとできないこと、およびそのアクションが障害になる可能性があるかどうかを理解する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは、追加のタスクオブジェクトを作成/キューイングする必要があるためにも発生します。これは、パフォーマンス要件に応じて、アプリケーション/ライブラリにとって重要な場合と重要でない場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、このような回避策は、メリットよりも多くの問題を引き起こし、意図しない結果をもたらす可能性があることにも注意してください。</font><font style="vertical-align: inherit;">たとえば、一部の静的分析ツールは、</font></font><code>ConfigureAwait(false)</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA2007を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用しない期待にフラグを</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">立て</font></a><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">アナライザーの電源を入れ、そのようなトリックを使用しないようにする</font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、アナライザーがマークを付ける可能性が高くなります。</font><font style="vertical-align: inherit;">これにはさらに多くの作業が必要になる場合があります。たとえば、アナライザーの重要性のためにアナライザーを無効にしたい場合があり、実際に使用する必要があるコードベースの他の場所をスキップする必要があります</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SynchronizationContext.SetSynchronizationContextを使用して、ConfigureAwait（false）の使用を回避できますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
番号。</font><font style="vertical-align: inherit;">可能ですが。</font><font style="vertical-align: inherit;">使用する実装によって異なりますが、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部の開発者はこれを行います。</font></font><br>
<br>
<pre><code class="cs hljs">Task t;<font></font>
SynchronizationContext old = SynchronizationContext.Current;<font></font>
SynchronizationContext.SetSynchronizationContext(<span class="hljs-literal">null</span>);
<span class="hljs-keyword">try</span><font></font>
{<font></font>
    t = CallCodeThatUsesAwaitAsync(); <span class="hljs-comment">// await'     </span><font></font>
}<font></font>
<span class="hljs-keyword">finally</span> { SynchronizationContext.SetSynchronizationContext(old); }
<span class="hljs-keyword">await</span> t; <span class="hljs-comment">//  -    </span></code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、内部のコード</font></font><code>CallCodeThatUsesAwaitAsync </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が現在のコンテキストをとして表示する</font><font style="vertical-align: inherit;">ことを強制することを期待して</font><font style="vertical-align: inherit;">い</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">そうなります。</font><font style="vertical-align: inherit;">ただし、このオプションは、それがどれ影響はありません</font></font><code>await </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見ています</font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、コードがスペシャル</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">実行されると、そのスペシャル</font><font style="vertical-align: inherit;">はその</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中</font></font><code>CallCodeThatUsesAwaitAsync </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を見てキューに入れられます</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下のよう</font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FAQ、同じ注意事項がここで適用されますが、このアプローチの特定の結果であり、ブロック内のコードは</font></font><code>try </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、異なるコンテキストを設定（または非標準タスクスケジューラを使用してコードを呼び出す）ことによって、これらの試みを妨害することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このテンプレートでは、小さな変更にも注意する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs">SynchronizationContext old = SynchronizationContext.Current;<font></font>
SynchronizationContext.SetSynchronizationContext(<span class="hljs-literal">null</span>);
<span class="hljs-keyword">try</span><font></font>
{<font></font>
    <span class="hljs-keyword">await</span> t;<font></font>
}<font></font>
<span class="hljs-keyword">finally</span> { SynchronizationContext.SetSynchronizationContext(old); }
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は何ですか？</font><font style="vertical-align: inherit;">少しわかりにくいですが、印象的です。</font><font style="vertical-align: inherit;">待機が最終的にコールバックを引き起こす/元のスレッドで続行するという保証はありません。</font><font style="vertical-align: inherit;">返品を意味します</font></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元のスレッドではソースへのアクセスが発生しない可能性があり、その場合、このスレッドの後続の作業項目で誤ったコンテキストが表示される可能性があります。</font><font style="vertical-align: inherit;">これに対処するために、特別なコンテキストを設定する適切に記述されたアプリケーションモデルは、通常、追加のカスタムコードを呼び出す前に手動でリセットするコードを追加します。</font><font style="vertical-align: inherit;">また、これが1つのスレッドで発生した場合でも、コンテキストが適切に復元されない場合があります。</font><font style="vertical-align: inherit;">そして、それが別のスレッドで動作する場合、これは間違ったコンテキストのインストールにつながる可能性があります。</font><font style="vertical-align: inherit;">等。</font><font style="vertical-align: inherit;">理想からは程遠い。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetAwaiter（）.GetResult（）を使用する場合、ConfigureAwait（false）を使用する必要がありますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
番号。</font></font><code>ConfigureAwait </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバックのみに影響します。</font><font style="vertical-align: inherit;">特に、テンプレートで</font></font><code>awaiter </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、プロパティ</font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、メソッド、</font></font><code>GetResult </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>OnCompleted </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（オプションでUnsafeOnCompletedメソッドを使用して）</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">提供する</font><font style="vertical-align: inherit;">必要があります</font><font style="vertical-align: inherit;">。</font></font><code>ConfigureAwait </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は動作</font></font><code>{Unsafe}OnCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">のみ影響する</font><font style="vertical-align: inherit;">ため、を直接呼び出す</font></font><code>GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合は、それを実行するかどうかに関係なく</font><font style="vertical-align: inherit;">、動作に違い</font></font><code>TaskAwaiter </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はあり</font></font><code>ConfiguredTaskAwaitable.ConfiguredTaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ません。</font><font style="vertical-align: inherit;">したがって、それを</font></font><code>task.ConfigureAwait(false).GetAwaiter().GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">置き換えることができるとわかった場合は、</font></font><code>task.GetAwaiter().GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（さらに、本当にそのような実装が必要かどうかを検討してください）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特別なSynchronizationContextや特別なTaskSchedulerが存在しない環境でコードが実行されることを知っています。</font><font style="vertical-align: inherit;">ConfigureAwait（false）を使用できませんか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多分。</font><font style="vertical-align: inherit;">それはあなたが決して自信がないことに依存します。</font><font style="vertical-align: inherit;">前の質問で述べたように、作業しているアプリケーションのモデルが特別なもの</font></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">指定せず、特別なもの</font><font style="vertical-align: inherit;">でコードを呼び出さないからと</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いって、別のユーザーまたはライブラリのコードがそれらを使用しないというわけではありません。</font><font style="vertical-align: inherit;">したがって、これを確認するか、少なくともそのようなオプションが可能であるというリスクを認識する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET CoreではConfigureAwait（false）を適用する必要がないと聞きました。</font><font style="vertical-align: inherit;">そうですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法ではありません。 .NET Frameworkで作業するときと同じ理由で、.NET Coreで作業するときに必要です。この点で何も変更されていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の環境が独自の環境を公開するかどうかが変更されました</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。特に、.NET Frameworkの従来のASP.NETには独自のが</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">SynchronizationContext</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ありますが、ASP.NET Coreにはありません。つまり、ASP.NET Coreアプリケーションで実行されているコードでは、デフォルト</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">特別なコードが表示され</font><font style="vertical-align: inherit;">ない</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、この環境の</font><font style="vertical-align: inherit;">必要性</font><font style="vertical-align: inherit;">が少なくなり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、これはカスタム</font></font><code>SynchronizationContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ユーザーコード（またはアプリケーションで使用される他のライブラリコード）がユーザーコンテキストを設定し、特別なタスクスケジューラでスケジュールされたタスクでコードを呼び出すか、コードを呼び出す場合、</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASP.NET Coreは非標準のコンテキストまたはスケジューラを参照します。使用が必要な場合があります</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">もちろん、同期ロック（とにかくWebアプリケーションで行う必要がある）を回避し、場合によってはパフォーマンスの小さなオーバーヘッドに反対しない場合は、を使用せずに実行できます</font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAsyncEnumerableで「foreachが完了するのを待つ」ときにConfigureAwaitを使用できますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい。</font><font style="vertical-align: inherit;">例については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSDNの記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を参照してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<code>Await foreach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターンと一致するため、でリストするために使用できます</font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">また、APIの正しいスコープを表す要素をリストするためにも使用できます。</font><font style="vertical-align: inherit;">.NETランタイムライブラリには</font><font style="vertical-align: inherit;">、適切なテンプレートに</font><font style="vertical-align: inherit;">ラップ</font><font style="vertical-align: inherit;">して</font><font style="vertical-align: inherit;">対応する</font><font style="vertical-align: inherit;">特別なタイプを返す</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拡張</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">が</font></a><font style="vertical-align: inherit;">含ま</font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れて</font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">います</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">コンパイラが</font><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">列挙子</font><font style="vertical-align: inherit;">への呼び出しを生成するとき</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらの呼び出しは、返された構成済みの列挙型構造のタイプに関連しており、必要に応じて期待に応えます。</font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"></font><code>Boolean </code><font style="vertical-align: inherit;"></font><code>MoveNextAsync </code><font style="vertical-align: inherit;"></font><code>DisposeAsync </code><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureAwaitを 'await using' IAsyncDisposableと一緒に使用できますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、少し複雑ですが。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に</font></font><code> IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、.NETランタイムライブラリは、拡張メソッドを提供</font></font><code>ConfigureAwait </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するために</font></font><code>IAsyncDisposable </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>await using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それは適切なテンプレートを（つまり、それが適切な方法を提供し、実装しているので、うまく動作します</font></font><code>DisposeAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">await</span> <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> MyAsyncDisposableClass().ConfigureAwait(<span class="hljs-literal">false</span>))<font></font>
{<font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでの問題は、型</font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">の拡張メソッドから返された</font><font style="vertical-align: inherit;">型で</font><font style="vertical-align: inherit;">はなく</font></font><code>MyAsyncDisposableClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">型になっていること</font><font style="vertical-align: inherit;">です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
これを回避するには、次の行を追加します。</font></font><code>System.Runtime.CompilerServices.ConfiguredAsyncDisposable</code><font style="vertical-align: inherit;"></font><code>ConfigureAwait </code><font style="vertical-align: inherit;"></font><code>IAsyncDisposable</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> MyAsyncDisposableClass();
<span class="hljs-keyword">await</span> <span class="hljs-keyword">using</span> (c.ConfigureAwait(<span class="hljs-literal">false</span>))<font></font>
{<font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これでタイプが</font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再び必要になります</font></font><code>MyAsyncDisposableClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これには、の範囲を拡大する効果もあり</font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">必要に応じて、すべてを中括弧で囲むことができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureAwait（false）を使用しましたが、待機した後もAsyncLocalがコードに流れ込みました。</font><font style="vertical-align: inherit;">これはバグですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いいえ、これはかなり予想されることです。</font><font style="vertical-align: inherit;">データフロー</font></font><code>AsyncLocal&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>ExecutionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とは別の</font><font style="vertical-align: inherit;">部分</font><font style="vertical-align: inherit;">です</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">あなたは明示的にストリームを無効にしない限り</font></font><code>ExecutionContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font><code>ExecutionContext.SuppressFlow()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>ExecutionContext </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（したがってデータ</font></font><code>AsyncLocal &lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は常に通過します</font></font><code>awaits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">かかわらず、ために使用されているかどうかの、</font></font><code>ConfigureAwait </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オリジナルのキャプチャ避けます</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">詳細については、この</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">言語ツールを使用すると、ライブラリでConfigureAwait（false）を明示的に使用する必要がなくなりますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図書館の開発者は時々</font></font><code>ConfigureAwait(false) </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、より侵襲性の低い代替品</font><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">して要求</font><font style="vertical-align: inherit;">する必要性について不満を言う</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在それらは、少なくとも言語/コンパイラ/ランタイムに組み込まれていません。</font><font style="vertical-align: inherit;">しかしながら、これは、例えば、実装することができる方法として、多くの提案がされている</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味のあるトピック、新しく興味深いアイデアがある場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元の記事の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">著者が</font><font style="vertical-align: inherit;">ディスカッションに招待します。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja482340/index.html">ジュニアからミドル：パーサー</a></li>
<li><a href="../ja482344/index.html">ロシアでの社会的格付けの導入に備えましょう</a></li>
<li><a href="../ja482346/index.html">ASP.NET MVC-ADO.NETを介してMySQLを操作する</a></li>
<li><a href="../ja482348/index.html">疑いを持たないゲーム開発者のためのトポロジーと包括的な分析：単一の3Dベクトルの圧縮</a></li>
<li><a href="../ja482352/index.html">私が風に150kをほとんど投げたとき、またはアパートに強制換気を設置した歴史</a></li>
<li><a href="../ja482356/index.html">通常のWindowsユーザーの観点から、エクスプローラーなしでWindows Serverを使用する</a></li>
<li><a href="../ja482358/index.html">Rustでのパニックの仕組み</a></li>
<li><a href="../ja482360/index.html">Habra探偵：彼らはUFOの友達です</a></li>
<li><a href="../ja482362/index.html">ほぼ無政府状態：Fidonetの簡単な歴史、インターネット経由での勝利を気にしないプロジェクト</a></li>
<li><a href="../ja482364/index.html">あなたが[たぶん] Javaについて知らなかったこと</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>