<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌑 👹 👏🏼 Nativer FPGA-Softprozessor mit Hochsprachen-Compiler oder Song of the Mouse 👨‍👦 👩🏽‍🏭 🧑🏼‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eigener FPGA-Softprozessor mit Hochsprachen-Compiler oder Song of the Mouse - Erfahrung in der Anpassung eines Hochsprachen-Compilers an den Stapelpro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Nativer FPGA-Softprozessor mit Hochsprachen-Compiler oder Song of the Mouse</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491604/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigener FPGA-Softprozessor mit Hochsprachen-Compiler oder Song of the Mouse - Erfahrung in der Anpassung eines Hochsprachen-Compilers an den Stapelprozessorkern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein häufiges Problem für Softwareprozessoren ist das Fehlen von Entwicklungswerkzeugen für sie, insbesondere wenn ihr Befehlssystem keine Teilmenge der Anweisungen eines ihrer beliebten Prozessorkerne ist. Entwickler müssen in diesem Fall dieses Problem lösen. Die direkte Lösung besteht darin, einen Assembler-Compiler zu erstellen. In modernen Realitäten ist es jedoch nicht immer bequem, in Assembler zu arbeiten, da sich das Befehlssystem im Verlauf der Projektentwicklung beispielsweise aufgrund sich ändernder Anforderungen ändern kann. Daher ist die Aufgabe der einfachen Implementierung eines Hochsprachen-Compilers (JAV) für einen Softwareprozessor relevant.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python-Compiler - Uzh scheint ein einfaches und praktisches Toolkit für die Entwicklung von Software für Softwareprozessoren zu sein. Das Toolkit zum Definieren von Grundelementen und Makros als Funktionen der Zielsprache ermöglicht die Implementierung kritischer Stellen in der Assemblersprache des Prozessors. In diesem Dokument werden die wichtigsten Punkte der Compileranpassung für Prozessoren mit Stapelarchitektur erläutert.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anstelle eines Epigraphs: </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie eine erwachsene Maus nehmen </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und sie vorsichtig halten und </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
die Nadeln hineinstecken, erhalten </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie einen Igel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn dieser Igel, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nase verstopft, um nicht zu atmen, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wo tiefer, in den Fluss werfen, werden </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie eine Halskrause bekommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn diese Halskrause, halten Sie </font><font style="vertical-align: inherit;">
Ihren </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kopf in einem Schraubstock, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ziehen Sie fester am Schwanz </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie werden eine Schlange bekommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn dies schon, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nachdem er zwei Messer vorbereitet hat ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Allerdings wird er wahrscheinlich sterben, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aber die Idee ist gut!</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 In vielen Fällen ist es bei der Implementierung von Messgeräten und Forschungsgeräten vorzuziehen, rekonfigurierbare FPGA / FPGA-Lösungen als Hauptkern des Systems zu verwenden. Dieser Ansatz hat viele Vorteile aufgrund der Fähigkeit, einfach und schnell Änderungen an der Arbeitslogik vorzunehmen, sowie aufgrund der Hardwarebeschleunigung von Datenverarbeitungs- und Steuersignalen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für eine Vielzahl von Aufgaben wie digitale Signalverarbeitung, eingebettete Steuerungssysteme, Datenerfassungs- und Analysesysteme hat sich der Ansatz bewährt, der darin besteht, die von der FPGA-Logik implementierten Lösungsblöcke für kritische Prozesse und Programmsteuerelemente auf der Basis von einem oder einem zu kombinieren Mehrere Softwareprozessoren für die allgemeine Verwaltung und Koordination sowie für die Implementierung der Interaktion mit dem Benutzer oder externen Geräten / Knoten. </font><font style="vertical-align: inherit;">Die Verwendung von Softwareprozessoren in diesem Fall ermöglicht es uns, den Zeitaufwand für das Debuggen und Überprüfen von Systemsteuerungsalgorithmen oder Interaktionsalgorithmen einzelner Knoten geringfügig zu reduzieren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typische Wunschliste</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 In diesem Fall erfordern Softprozessoren häufig keine ultrahohe Leistung (da dies einfacher zu erreichen ist, verwende ich die logischen FPGA- und Hardwareressourcen). </font><font style="vertical-align: inherit;">Sie können recht einfach sein (und aus Sicht moderner Mikrocontroller - fast primitiv), weil </font><font style="vertical-align: inherit;">Sie können auf ein komplexes Interrupt-System verzichten, arbeiten nur mit bestimmten Knoten oder Schnittstellen. Es ist nicht erforderlich, ein bestimmtes Befehlssystem zu unterstützen. </font><font style="vertical-align: inherit;">Es kann viele von ihnen geben, während jeder von ihnen nur einen bestimmten Satz von Algorithmen oder Unterprogrammen ausführen kann. </font><font style="vertical-align: inherit;">Die Kapazität von Softprozessoren kann auch beliebig sein, einschließlich nicht eines Vielfachen eines Bytes - abhängig von den Anforderungen der aktuellen Aufgabe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typische Ziele für Softprozessoren sind:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ausreichende Funktionalität des Befehlssystems, möglicherweise für die Aufgabe optimiert;</font></font></li>
<li>   , ..      ;</li>
<li> –   ,        .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Ein Problem für Softwareprozessoren ist natürlich das Fehlen von Entwicklungswerkzeugen für sie, insbesondere wenn ihr Befehlssystem keine Teilmenge der Anweisungen eines ihrer beliebten Prozessorkerne ist. </font><font style="vertical-align: inherit;">Entwickler müssen in diesem Fall dieses Problem lösen. </font><font style="vertical-align: inherit;">Die direkte Lösung besteht darin, einen Assembler-Compiler für den Softwareprozessor zu erstellen. </font><font style="vertical-align: inherit;">In modernen Realitäten ist es jedoch nicht immer bequem, in Assembler zu arbeiten, insbesondere wenn sich das Teamsystem während der Entwicklung des Projekts ändert, beispielsweise aufgrund sich ändernder Anforderungen. </font><font style="vertical-align: inherit;">Daher ist es logisch, zu den obigen Anforderungen die Anforderung einer einfachen Implementierung eines Hochsprachen-Compilers (HLV) für den Soft-Prozessor hinzuzufügen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellkomponenten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Stapelprozessoren erfüllen diese Anforderungen mit einem hohen Prozentsatz an Compliance </font><font style="vertical-align: inherit;">Es besteht keine Notwendigkeit, Register zu adressieren. Die Bittiefe des Befehls kann gering sein.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Bittiefe der Daten für sie kann variieren und ist nicht an die Bittiefe des Befehlssystems gebunden. </font><font style="vertical-align: inherit;">Da es sich de facto (wenn auch mit einigen Einschränkungen) um eine Hardware-Implementierung der Zwischendarstellung des Programmcodes während der Kompilierung handelt (eine virtuelle gestapelte Maschine oder in Bezug auf kontextfreie Grammatiken - ein Geschäftsautomat), ist es mit geringen Arbeitskosten möglich, die Grammatik einer beliebigen Sprache in ausführbaren Code zu übersetzen. </font><font style="vertical-align: inherit;">Darüber hinaus ist für Stapelprozessoren die Fort-Sprache praktisch die „Muttersprache“. </font><font style="vertical-align: inherit;">Die Arbeitskosten für die Implementierung eines Fort-Compilers für einen Stapelprozessor sind mit denen von Assembler vergleichbar, wobei die Implementierung von Programmen in Zukunft wesentlich flexibler und effizienter ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der Aufgabe, ein System zum Sammeln von Daten von intelligenten Sensoren in einem Modus nahe der Echtzeit aufzubauen, wurde der Fort-Prozessor als Referenzlösung (das sogenannte Referenzdesign) des in [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">beschriebenen Soft-Prozessors ausgewählt </font><font style="vertical-align: inherit;">(im Folgenden beschrieben) manchmal mit dem Spitznamen des Autors als whiteTiger-Prozessor bezeichnet). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seine Hauptmerkmale:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daten trennen und Stapel zurückgeben</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Architektur der Harvard-Speicherorganisation (separater Programm- und Datenspeicher, einschließlich Adressraum);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweiterung mit Peripheriegeräten über einen einfachen Parallelbus.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Prozessor verwendet keine Pipeline, die Ausführung der Befehle erfolgt per Push-Pull:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Befehle und Operanden abrufen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ausführung des Befehls und Speichern des Ergebnisses.</font></font></li>
</ol></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Der Prozessor wird durch einen UART-Loader mit Programmcode ergänzt, mit dem Sie das ausführbare Programm ändern können, ohne das Projekt für FPGAs neu zu kompilieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Bezug auf die Konfiguration des Blockspeichers im FPGA wird die Kapazität der Befehle auf 9 Bit eingestellt. Die Bittiefe der Daten ist auf 32 Bit eingestellt, kann aber grundsätzlich beliebig sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Prozessorcode wird in VHDL ohne Verwendung spezifischer Bibliotheken geschrieben, sodass Sie mit diesem Projekt an FPGAs aller Hersteller arbeiten können.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für eine relativ weit verbreitete Verwendung, das Verringern der "Eingabeschwelle" sowie das Wiederverwenden von Code und das Anwenden von Codeentwicklungen ist es zweckmäßiger, auf eine andere Java-Engine als Fort umzusteigen (dies ist teilweise auf den Aberglauben und die falschen Vorstellungen von Mine-Stream-Programmierern hinsichtlich der Komplexität dieser Sprache und der Lesbarkeit ihres Codes zurückzuführen (Übrigens hat einer der Autoren dieser Arbeit eine ähnliche Meinung zu C-ähnlichen Sprachen)). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf einer Reihe von Faktoren wurde die Python-Sprache (Python) für das Experiment ausgewählt, um den Softwareprozessor und die Java Language Engine zu „binden“. Dies ist eine allgemeine Programmiersprache auf hoher Ebene, die sich auf die Verbesserung der Entwicklerproduktivität und der Lesbarkeit von Code konzentriert und verschiedene Programmierparadigmen unterstützt, darunter strukturelle, objektorientierte, funktionale, imperative und aspektorientierte [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für unerfahrene Entwickler ist die Erweiterung MyHDL [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">interessant </font><font style="vertical-align: inherit;">, mit der Hardwareelemente und -strukturen in Python beschrieben und in VHDL- oder Verilog-Code übersetzt werden können. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor einiger Zeit wurde der Uzh-Compiler [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">angekündigt </font><font style="vertical-align: inherit;">- ein kleiner Compiler für den Zmey-FPGA-Softwareprozessor (32-Bit-Stack-Architektur mit Multithreading-Unterstützung - wenn Sie die Kette von Versionen / Modifikationen / Verifizierungen verfolgen - Zmey ist ein entfernter Nachkomme des whiteTiger-Prozessors). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uzh ist auch eine statisch kompilierte Teilmenge von Python, die auf dem vielversprechenden raddsl-Toolkit basiert (eine Reihe von Tools zum schnellen Erstellen von Prototypen von DSL-Compilern) [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ].</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit können die Faktoren, die die Wahl der Arbeitsrichtung beeinflusst haben, ungefähr so ​​formuliert werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interesse an Tools, die die "Einstiegsschwelle" für unerfahrene Entwickler von Geräten und Systemen auf FPGAs senken (syntaktisch ist Python für Anfänger nicht so "beängstigend" wie VHDL);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Streben nach Harmonie und einem einzigen Stil im Projekt (es ist theoretisch möglich, die erforderlichen Hardwareblöcke und Software des Softwareprozessors in Python zu beschreiben);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zufälliger Zufall.</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kleine, „fast“ bedeutungslose Nuancen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Der Quellcode des Zmey-Prozessors ist nicht geöffnet, es ist jedoch eine Beschreibung der Funktionsprinzipien und einiger Architekturfunktionen verfügbar. </font><font style="vertical-align: inherit;">Obwohl es auch stapelbar ist, gibt es eine Reihe von wesentlichen Unterschieden zum whiteTiger-Prozessor:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stapel sind Software - d.h. </font><font style="vertical-align: inherit;">durch Zeiger dargestellt und an verschiedenen Adressen im Datenspeicher abgelegt;</font></font></li>
<li>     ,      - ;</li>
<li>          ;</li>
<li>  ,         .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Dementsprechend berücksichtigt der Uzh-Compiler diese Funktionen. Der Compiler akzeptiert Python-Code und generiert am Ausgang einen Boot-Stream, um den Programmspeicher und den Prozessordatenspeicher zu initiieren. Der entscheidende Punkt ist, dass alle Sprachfunktionen in der Kompilierungsphase verfügbar sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Uzh-Compiler zu installieren, laden Sie einfach sein Archiv herunter und entpacken Sie ihn in einen beliebigen Ordner (es ist besser, die allgemeinen Empfehlungen für spezielle Software einzuhalten - um Pfade zu vermeiden, die Kyrillisch und Leerzeichen enthalten). Sie müssen auch das raddsl-Toolkit herunterladen und in den Hauptordner des Compilers entpacken.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Compiler-Testordner enthält Beispiele für Programme für den Soft-Prozessor, der src-Ordner enthält die Quelltexte der Compiler-Elemente. </font><font style="vertical-align: inherit;">Der </font></font><b><code>c.py C:\D\My_Docs\Documents\uzh-master\tests\abc.py</code> </b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfachheit halber ist </font><font style="vertical-align: inherit;">es besser, eine kleine Batch-Datei (Erweiterung .cmd) mit dem Inhalt: zu erstellen, </font><font style="vertical-align: inherit;">wobei abc.py der Name der Datei mit dem Programm für den Soft-Prozessor ist.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Schlange beißt sich in den Schwanz oder leckt Eisen und Software</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Um Uzh an den whiteTiger-Prozessor anzupassen, sind einige Änderungen erforderlich, und der Prozessor selbst muss leicht korrigiert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Glücklicherweise gibt es im Compiler nicht viele Stellen, die angepasst werden müssen. </font><font style="vertical-align: inherit;">Die wichtigsten "hardwareabhängigen" Dateien:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asm.py - Assembler und die Bildung von Zahlen (Literalen);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gen.py - Regeln zur Codegenerierung auf niedriger Ebene (Funktionen, Variablen, Übergänge und Bedingungen);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream.py - einen Boot-Stream bilden;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">macro.py - Makrodefinitionen - Erweiterungen der Basissprache mit hardwarespezifischen Funktionen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Im ursprünglichen WhiteTiger-Prozessordesign initialisiert der UART-Loader nur den Programmspeicher. </font><font style="vertical-align: inherit;">Der Bootloader-Algorithmus ist einfach, aber gut etabliert und zuverlässig:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beim Empfang eines bestimmten Steuerbytes setzt der Loader den aktiven Pegel auf der internen Leitung des Prozessor-Resets.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der zweite Bytebefehl setzt den Speicheradresszähler zurück.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Folgende ist eine Folge von Notizbüchern des übertragenen Wortes, beginnend mit dem jüngsten, kombiniert mit einer Notizbuchnummer.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nach jedem Byte mit einem gepackten Notizbuch folgt ein Paar Steuerbytes, von denen das erste den aktiven Pegel in der Speicherschreibberechtigungszeile festlegt und das zweite ihn zurücksetzt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Abschluss der Sequenz gepackter Notebooks wird der aktive Pegel in der Rücksetzzeile durch das Steuerbyte entfernt. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Da der Compiler auch Datenspeicher verwendet, muss der Loader so geändert werden, dass er auch den Datenspeicher initialisieren kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da der Datenspeicher an der Logik des Prozessorkerns beteiligt ist, müssen seine Daten- und Steuerleitungen gemultiplext werden. </font><font style="vertical-align: inherit;">Hierzu werden zusätzliche Signale DataDinBtemp, LoaderAddrB, DataWeBtemp eingeführt - Daten, Adresse und Aufzeichnungsauflösung für den Port-In-Speicher. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Der Bootloader-Code sieht jetzt folgendermaßen aus:</font></font><br>
<br>
<pre><code class="vhdl hljs">uart_unit: <span class="hljs-keyword">entity</span> work.uart
<span class="hljs-comment">--uart_unit: entity uart</span>
  <span class="hljs-keyword">Generic</span> <span class="hljs-keyword">map</span>(<font></font>
    ClkFreq =&gt; <span class="hljs-number">50_000_000</span>,<font></font>
    Baudrate =&gt; <span class="hljs-number">115200</span>)
  <span class="hljs-keyword">port</span> <span class="hljs-keyword">map</span>(<font></font>
    clk =&gt; clk,<font></font>
    rxd =&gt; rx,<font></font>
    txd =&gt; tx,<font></font>
    dout =&gt; receivedByte,<font></font>
    received =&gt; received,<font></font>
    din =&gt; transmitByte,<font></font>
    transmit =&gt; transmit);<font></font>
    <font></font>
<span class="hljs-keyword">process</span>(clk)
<span class="hljs-keyword">begin</span>
  <span class="hljs-keyword">if</span> rising_edge(clk) <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">if</span> received = <span class="hljs-string">'1'</span> <span class="hljs-keyword">then</span>
      <span class="hljs-keyword">case</span> conv_integer(receivedByte) <span class="hljs-keyword">is</span>
      <span class="hljs-comment">-- 0-F   - 0-3 bits</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> <span class="hljs-number">15</span> =&gt; CodeDinA(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<font></font>
		                  DataDinBtemp(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
      <span class="hljs-comment">-- 10-1F -4-7bits</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">16</span> <span class="hljs-keyword">to</span> <span class="hljs-number">31</span> =&gt; CodeDinA(<span class="hljs-number">7</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">4</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<font></font>
		                   DataDinBtemp(<span class="hljs-number">7</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">4</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>); 
      <span class="hljs-comment">-- 20-2F -8bit </span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">32</span> <span class="hljs-keyword">to</span> <span class="hljs-number">47</span> =&gt; CodeDinA(<span class="hljs-number">8</span>) &lt;= receivedByte(<span class="hljs-number">0</span>);<font></font>
	                   DataDinBtemp(<span class="hljs-number">11</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">8</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
	  <span class="hljs-keyword">when</span> <span class="hljs-number">48</span> <span class="hljs-keyword">to</span> <span class="hljs-number">63</span> =&gt; DataDinBtemp(<span class="hljs-number">15</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">12</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
	  <span class="hljs-keyword">when</span> <span class="hljs-number">64</span> <span class="hljs-keyword">to</span> <span class="hljs-number">79</span> =&gt; DataDinBtemp(<span class="hljs-number">19</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">16</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
	  <span class="hljs-keyword">when</span> <span class="hljs-number">80</span> <span class="hljs-keyword">to</span> <span class="hljs-number">95</span> =&gt; DataDinBtemp(<span class="hljs-number">23</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">20</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
	  <span class="hljs-keyword">when</span> <span class="hljs-number">96</span> <span class="hljs-keyword">to</span> <span class="hljs-number">111</span> =&gt; DataDinBtemp(<span class="hljs-number">27</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">24</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);
        <span class="hljs-keyword">when</span> <span class="hljs-number">112</span> <span class="hljs-keyword">to</span> <span class="hljs-number">127</span> =&gt; DataDinBtemp(<span class="hljs-number">31</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">28</span>) &lt;= receivedByte(<span class="hljs-number">3</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span>);<font></font>
<font></font>
      <span class="hljs-comment">-- F0 addr=0</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">240</span> =&gt; CodeAddrA &lt;= (<span class="hljs-keyword">others</span> =&gt; <span class="hljs-string">'0'</span>);
      <span class="hljs-comment">-- F1 - WE=1</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">241</span> =&gt; CodeWeA &lt;= <span class="hljs-string">'1'</span>;
      <span class="hljs-comment">-- F2 WE=0 addr++</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">242</span> =&gt; CodeWeA &lt;= <span class="hljs-string">'0'</span>; CodeAddrA &lt;= CodeAddrA + <span class="hljs-number">1</span>;
      <span class="hljs-comment">-- F3 RESET=1</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">243</span> =&gt; int_reset &lt;= <span class="hljs-string">'1'</span>;
      <span class="hljs-comment">-- F4 RESET=0</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">244</span> =&gt; int_reset &lt;= <span class="hljs-string">'0'</span>;<font></font>
<font></font>
      <span class="hljs-comment">-- F5 addr=0</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">245</span> =&gt; LoaderAddrB &lt;= (<span class="hljs-keyword">others</span> =&gt; <span class="hljs-string">'0'</span>);
      <span class="hljs-comment">-- F6 - WE=1</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">246</span> =&gt; DataWeBtemp &lt;= <span class="hljs-string">'1'</span>;
      <span class="hljs-comment">-- F7 WE=0 addr++</span>
        <span class="hljs-keyword">when</span> <span class="hljs-number">247</span> =&gt; DataWeBtemp &lt;= <span class="hljs-string">'0'</span>; LoaderAddrB &lt;= LoaderAddrB + <span class="hljs-number">1</span>;<font></font>
		  <font></font>
		  <font></font>
        <span class="hljs-keyword">when</span> <span class="hljs-keyword">others</span> =&gt; <span class="hljs-keyword">null</span>;
      <span class="hljs-keyword">end</span> <span class="hljs-keyword">case</span>;
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;
  <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;
<span class="hljs-keyword">end</span> <span class="hljs-keyword">process</span>;<font></font>
<font></font>
<span class="hljs-comment">---- end of loader</span><font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei einem aktiven Rücksetzpegel werden die Signale DataDinBtemp, LoaderAddrB und DataWeBtemp mit den entsprechenden Datenspeicherports verbunden.</font></font><br>
<br>
<pre><code class="vhdl hljs">…
    <span class="hljs-keyword">if</span> reset = <span class="hljs-string">'1'</span> <span class="hljs-keyword">or</span> int_reset = <span class="hljs-string">'1'</span> <span class="hljs-keyword">then</span>
      DSAddrA &lt;= (<span class="hljs-keyword">others</span> =&gt; <span class="hljs-string">'0'</span>);      <font></font>
      <font></font>
      RSAddrA &lt;= (<span class="hljs-keyword">others</span> =&gt; <span class="hljs-string">'0'</span>);<font></font>
      RSAddrB &lt;= (<span class="hljs-keyword">others</span> =&gt; <span class="hljs-string">'0'</span>);<font></font>
      RSWeA &lt;= <span class="hljs-string">'0'</span>;<font></font>
      <font></font>
      DataAddrB &lt;= LoaderAddrB;<font></font>
		DataDinB&lt;=DataDinBtemp;<font></font>
		DataWeB&lt;=DataWeBtemp;<font></font>
      DataWeA &lt;= <span class="hljs-string">'0'</span>;<font></font>
…<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entsprechend dem Bootloader-Algorithmus muss das Modul stream.py geändert werden. Jetzt hat es zwei Funktionen. Die erste Funktion - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_val ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - teilt das Eingabewort in die gewünschte Anzahl von Tetraden auf. Für 9-Bit-Anweisungen des whiteTiger-Prozessors werden sie in Gruppen von drei Tetraden und 32-Bit-Daten in einer Folge von acht Tetraden umgewandelt. Die zweite Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bildet den Bootstrap direkt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die endgültige Form des Stream-Moduls:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_val</span>(<span class="hljs-params">x, by_4</span>):</span><font></font>
  r = []<font></font>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(by_4):<font></font>
    r.append((x &amp; <span class="hljs-number">0xf</span>) | (i &lt;&lt; <span class="hljs-number">4</span>))<font></font>
    x &gt;&gt;= <span class="hljs-number">4</span>
  <span class="hljs-keyword">return</span> r<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make</span>(<span class="hljs-params">code, data, core=<span class="hljs-number">0</span></span>):</span>
  <span class="hljs-comment">#        0  </span>
  stream = [<span class="hljs-number">243</span>,<span class="hljs-number">245</span>] 
  <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data:
    <span class="hljs-comment">#    32- </span>
    <span class="hljs-comment">#         </span>
    stream += get_val(x, <span class="hljs-number">8</span>) + [<span class="hljs-number">246</span>, <span class="hljs-number">247</span>]
  <span class="hljs-comment">#       0</span>
  stream += [<span class="hljs-number">240</span>]
  <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> code:
    <span class="hljs-comment">#    9-  </span>
    <span class="hljs-comment">#         </span>
    stream += get_val(x, <span class="hljs-number">3</span>) + [<span class="hljs-number">241</span>, <span class="hljs-number">242</span>]
  <span class="hljs-comment">#  </span>
  stream.append(<span class="hljs-number">244</span>)<font></font>
<font></font>
  <span class="hljs-keyword">return</span> bytearray(stream)<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Die folgenden Änderungen im Compiler wirken sich auf das Modul asm.py aus, das das Prozessorbefehlssystem (Befehlsmnemonik und Befehlsopcodes werden geschrieben) und die Art und Weise der Darstellung / Kompilierung numerischer Werte - Literale - beschreibt. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Befehle werden in ein Wörterbuch gepackt, und die Funktion lite () ist für Literale verantwortlich. Wenn mit dem Befehlssystem alles einfach ist - die Liste der Mnemonics und der entsprechenden Opcodes ändert sich nur, dann ist die Situation mit Literalen etwas anders. Der Zmey-Prozessor verfügt über 8-Bit-Anweisungen und es gibt eine Reihe spezieller Anweisungen zum Arbeiten mit Literalen. In whiteTiger gibt das 9. Bit an, ob der Opcode ein Befehl oder ein Teil einer Zahl ist.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das höchste (9.) Bit eines Wortes 1 ist, wird der Opcode als Zahl interpretiert - beispielsweise bilden vier aufeinanderfolgende Opcodes mit einem Vorzeichen einer Zahl eine 32-Bit-Zahl. </font><font style="vertical-align: inherit;">Ein Zeichen für das Ende einer Nummer ist das Vorhandensein des Befehls-Opcodes. Um die Bestimmtheit zu gewährleisten und die Einheitlichkeit sicherzustellen, ist das Ende der Nummernbestimmung der Opcode des NOP-Befehls („keine Operationen“). </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen sieht die modifizierte Funktion lit () folgendermaßen aus:</font></font><br>
<br>
<pre><code class="python hljs">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lit</span>(<span class="hljs-params">x</span>):</span>
  x &amp;= <span class="hljs-number">0xffffffff</span><font></font>
  r = [] <font></font>
  <span class="hljs-keyword">if</span> (x&gt;&gt;<span class="hljs-number">24</span>) &amp; <span class="hljs-number">255</span> :<font></font>
    r.append(int((x&gt;&gt;<span class="hljs-number">24</span>) &amp; <span class="hljs-number">255</span>) | <span class="hljs-number">256</span>)
  <span class="hljs-keyword">if</span> (x&gt;&gt;<span class="hljs-number">16</span>) &amp; <span class="hljs-number">255</span>:<font></font>
    r.append(int((x&gt;&gt;<span class="hljs-number">16</span>) &amp; <span class="hljs-number">255</span>) | <span class="hljs-number">256</span>)
  <span class="hljs-keyword">if</span> (x&gt;&gt;<span class="hljs-number">8</span>) &amp; <span class="hljs-number">255</span>:<font></font>
    r.append(int((x&gt;&gt;<span class="hljs-number">8</span>) &amp; <span class="hljs-number">255</span>) | <span class="hljs-number">256</span>)<font></font>
  r.append(int(x &amp; <span class="hljs-number">255</span>) | <span class="hljs-number">256</span>)<font></font>
  r += asm(<span class="hljs-string">"NOP"</span>)
  <span class="hljs-keyword">return</span> list(r)<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die wichtigsten und wichtigsten Änderungen / Definitionen befinden sich im gen.py-Modul. </font><font style="vertical-align: inherit;">Dieses Modul definiert die grundlegende Logik der Arbeit / Ausführung von Code auf hoher Ebene auf Assembler-Ebene:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedingte und bedingungslose Sprünge;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionen aufrufen und Argumente an sie übergeben;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rückkehr von Funktionen und Rückgabe von Ergebnissen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anpassungen der Größe des Programmspeichers, des Datenspeichers und der Stapel;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abfolge von Aktionen beim Start des Prozessors.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Um Java zu unterstützen, muss der Prozessor in der Lage sein, beliebig mit Speicher und Zeigern zu arbeiten und über einen Speicherbereich zum Speichern lokaler Variablenfunktionen verfügen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Zmey-Prozessor wird ein Rückgabestapel verwendet, um mit lokalen Variablen und Funktionsargumenten zu arbeiten - Funktionsargumente werden darauf übertragen und während der weiteren Arbeit wird über das Zeigerregister des Rückgabestapels auf sie zugegriffen (Lesen, Ändern nach oben / unten, Lesen an der Zeigeradresse). Da sich der Stapel physisch im Datenspeicher befindet, werden solche Operationen im Wesentlichen einfach auf Speicheroperationen zurückgeführt, und globale Variablen befinden sich im selben Speicher.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In whiteTiger sind Rückgabe- und Datenstapel dedizierte Hardware-Stapel mit ihrem Adressraum und haben keine Stapelzeigeranweisungen. Folglich müssen Operationen mit Übergabe von Argumenten an Funktionen und Arbeiten mit lokalen Variablen über den Datenspeicher organisiert werden. Es ist wenig sinnvoll, das Volumen der Datenstapel zu erhöhen und für die mögliche Speicherung relativ großer Datenfelder zurückzugeben. Es ist logischer, einen etwas großen Datenspeicher zu haben. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Um mit lokalen Variablen zu arbeiten, wurde ein dediziertes LocalReg-Register hinzugefügt, dessen Aufgabe darin besteht, einen Zeiger auf den für lokale Variablen zugewiesenen Speicherbereich (eine Art Heap) zu speichern. Es wurden auch Operationen für die Arbeit damit hinzugefügt (Datei cpu.vhd - Befehlsdefinitionsbereich):</font></font><br>
<br>
<pre><code class="vhdl hljs">
          <span class="hljs-comment">-- group 1; pop 0; push 1;</span>
          <span class="hljs-keyword">when</span> cmdLOCAL =&gt; DSDinA &lt;= LocalReg;
			 <span class="hljs-keyword">when</span> cmdLOCALadd =&gt; DSDinA &lt;= LocalReg; LocalReg &lt;= LocalReg+<span class="hljs-number">1</span>;
			 <span class="hljs-keyword">when</span> cmdLOCALsubb =&gt; DSDinA &lt;= LocalReg; LocalReg &lt;= LocalReg-<span class="hljs-number">1</span>;<font></font>
…<font></font>
          <span class="hljs-comment">-- group 2; pop 1; push 0;</span>
          <span class="hljs-keyword">when</span> cmdSETLOCAL =&gt; LocalReg &lt;= DSDinA;<font></font>
…<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LOCAL - Gibt den aktuellen Wert des LocalReg-Zeigers an den Datenstapel zurück. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SETLOCAL - Legt den neuen Zeigerwert fest, der vom Datenstapel empfangen wird. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LOCALadd - belässt den aktuellen Wert des Zeigers auf dem Datenstapel und erhöht ihn um 1; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LOCALsubb - Belässt den aktuellen Wert des Zeigers auf dem Datenstapel und verringert ihn um 1. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LOCALadd und LOCALsubb werden hinzugefügt, um die Anzahl der Ticks während der Übergabe von Funktionsparametern zu verringern und umgekehrt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Gegensatz zum ursprünglichen whiteTiger wurden die Datenspeicherverbindungen geringfügig geändert. Jetzt wird der In-Speicher-Port ständig von der Ausgabe der ersten Zelle des Datenstapels adressiert. Die Ausgabe der zweiten Zelle des Datenstapels wird ihrer Eingabe zugeführt:</font></font><br>
<br>
<pre><code class="vhdl hljs"><span class="hljs-comment">-- ++</span>
DataAddrB &lt;= DSDoutA(DataAddrB<span class="hljs-symbol">'range</span>);<font></font>
DataDinB &lt;= DSDoutB;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Die Logik zum Ausführen der Befehle STORE und FETCH wurde ebenfalls geringfügig korrigiert. FETCH empfängt den Ausgabewert des Ports im Speicher oben im Datenstapel, und STORE steuert einfach das Schreibfreigabesignal für Port B:</font></font><br>
<br>
<pre><code class="vhdl hljs">…
          <span class="hljs-comment">-- group 3; pop 1; push 1;</span>
          <span class="hljs-keyword">when</span> cmdFETCH =&gt; DSDinA &lt;= DataDoutB;<font></font>
…<font></font>
          <span class="hljs-keyword">when</span> cmdSTORE =&gt;            <font></font>
            DataWeB &lt;= <span class="hljs-string">'1'</span>;<font></font>
…<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Rahmen der Schulung sowie für einige Hardwareunterstützungen für Schleifen auf niedriger Ebene (und auf Compilerebene der Fort-Sprache) wurde dem whiteTiger-Kern ein Stapel von Schleifenzählern hinzugefügt (Aktionen ähneln denen beim Deklarieren von Daten und Rückgabestapeln):</font></font><br>
<br>
<pre><code class="vhdl hljs">…
<span class="hljs-comment">--  </span>
<span class="hljs-keyword">type</span> TCycleStack <span class="hljs-keyword">is</span> <span class="hljs-keyword">array</span>(<span class="hljs-number">0</span> <span class="hljs-keyword">to</span> LocalSize-<span class="hljs-number">1</span>) <span class="hljs-keyword">of</span> DataSignal;
<span class="hljs-keyword">signal</span> CycleStack: TCycleStack;
<span class="hljs-keyword">signal</span> CSAddrA, CSAddrB: StackAddrSignal;
<span class="hljs-keyword">signal</span> CSDoutA, CSDoutB: DataSignal;
<span class="hljs-keyword">signal</span> CSDinA, CSDinB: DataSignal;
<span class="hljs-keyword">signal</span> CSWeA, CSWeB: <span class="hljs-built_in">std_logic</span>;<font></font>
…<font></font>
<span class="hljs-comment">--  </span>
<span class="hljs-keyword">process</span>(clk)
<span class="hljs-keyword">begin</span>
  <span class="hljs-keyword">if</span> rising_edge(clk) <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">if</span> CSWeA = <span class="hljs-string">'1'</span> <span class="hljs-keyword">then</span><font></font>
      CycleStack(conv_integer(CSAddrA)) &lt;= CSDinA;<font></font>
      CSDoutA &lt;= CSDinA;<font></font>
    <span class="hljs-keyword">else</span><font></font>
      CSDoutA &lt;= CycleStack(conv_integer(CSAddrA));<font></font>
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;
  <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;
<span class="hljs-keyword">end</span> <span class="hljs-keyword">process</span>;<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zykluszählerbefehle wurden hinzugefügt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DO - verschiebt die Anzahl der Iterationen des Zyklus vom Datenstapel zum Zählerstapel und legt den inkrementierten Wert des Befehlszählers auf den Rückgabestapel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LOOP - prüft, ob der Zähler auf Null gesetzt ist. Wenn er nicht erreicht wird, wird das oberste Element des Zählerstapels dekrementiert und der Übergang zur Adresse am oberen Rand des Rückgabestapels ausgeführt. Wenn die Oberseite des Zählerstapels Null ist, wird das obere Element zurückgesetzt, und die Rücksprungadresse zum Beginn des Zyklus von der Oberseite des Rückgabestapels wird ebenfalls zurückgesetzt.</font></font><br>
<br>
<pre><code class="vhdl hljs">
	<span class="hljs-keyword">when</span> cmdDO =&gt; <span class="hljs-comment">-- DO - </span>
               RSAddrA &lt;= RSAddrA + <span class="hljs-number">1</span>; <span class="hljs-comment">-- </span>
               RSDinA &lt;= ip + <span class="hljs-number">1</span>;<font></font>
               RSWeA &lt;= <span class="hljs-string">'1'</span>;<font></font>
				<font></font>
               CSAddrA &lt;= CSAddrA + <span class="hljs-number">1</span>; <span class="hljs-comment">--</span><font></font>
         		CSDinA &lt;= DSDoutA;<font></font>
 		         CSWeA &lt;= <span class="hljs-string">'1'</span>;<font></font>
		         DSAddrA &lt;= DSAddrA - <span class="hljs-number">1</span>; <span class="hljs-comment">--</span>
		         ip &lt;= ip + <span class="hljs-number">1</span>;	<span class="hljs-comment">-- </span><font></font>
<font></font>
      <span class="hljs-keyword">when</span> cmdLOOP =&gt; <span class="hljs-comment">--            </span>
           <span class="hljs-keyword">if</span> conv_integer(CSDoutA) = <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
	          ip &lt;= ip + <span class="hljs-number">1</span>;	<span class="hljs-comment">-- </span>
		         RSAddrA &lt;= RSAddrA - <span class="hljs-number">1</span>; <span class="hljs-comment">-- </span>
		         CSAddrA &lt;= CSAddrA - <span class="hljs-number">1</span>; <span class="hljs-comment">-- </span>
            <span class="hljs-keyword">else</span>
		         CSDinA &lt;= CSDoutA - <span class="hljs-number">1</span>;<font></font>
		         CSWeA &lt;= <span class="hljs-string">'1'</span>;<font></font>
		         ip &lt;= RSDoutA(ip<span class="hljs-symbol">'range</span>);
            <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;<font></font>
			 <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können Sie den Code für das gen.py-Modul ändern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
* _SIZE-Variablen benötigen keine Kommentare und erfordern nur die Ersetzung der im Prozessorkernprojekt angegebenen Werte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die STUB-Liste ist ein temporärer Stub, um einen Platz für Übergangsadressen zu erstellen und diese dann mit dem Compiler zu füllen (aktuelle Werte entsprechen dem 24-Bit-Adressraum des Codespeichers). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
STARTUP-Liste - Legt die Reihenfolge der Aktionen fest, die der Kernel nach einem Zurücksetzen ausführt. In diesem Fall wird die Startadresse des Speichers lokaler Variablen auf 900 und der Übergang zum Startpunkt festgelegt (wenn Sie nichts ändern, wird der Start- / Einstiegspunkt in der Anwendung in den Datenspeicher in der Datenspeicheradresse geschrieben 2):</font></font><br>
<br>
<pre><code class="python hljs">STARTUP = asm(<span class="hljs-string">"""
900  SETLOCAL
2 NOP FETCH JMP
"""</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Definition von func () schreibt die Aktionen vor, die ausgeführt werden, wenn die Funktion aufgerufen wird, nämlich die Übertragung von Funktionsargumenten in den Bereich lokaler Variablen und die Speicherzuordnung für ihre eigenen lokalen Variablen der Funktion.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">@act</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">t, X</span>):</span><font></font>
  t.c.entry = t.c.globs[X]<font></font>
  t.c.entry[<span class="hljs-string">"offs"</span>] = len(t.c.code) <span class="hljs-comment"># - 1</span>
  args = t.c.entry[<span class="hljs-string">"args"</span>]<font></font>
  temps_size = len(t.c.entry[<span class="hljs-string">"locs"</span>]) - args
<span class="hljs-comment">#      </span>
  t.out = asm(<span class="hljs-string">"LOCALadd STORE "</span> * args)
  <span class="hljs-keyword">if</span> temps_size:
<span class="hljs-comment">#      </span>
    t.out += asm(<span class="hljs-string">"LOCAL %d PLUS SETLOCAL"</span> % temps_size)
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Epilog () definiert Aktionen bei der Rückkehr von einer Funktion. Dabei wird der Speicher temporärer Variablen freigegeben und zum Aufrufpunkt zurückgekehrt.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">epilog</span>(<span class="hljs-params">t, X</span>):</span>
  locs_size = len(t.c.entry[<span class="hljs-string">"locs"</span>])
<span class="hljs-comment">#    </span>
  t.out = asm(<span class="hljs-string">"RET"</span>)
  <span class="hljs-keyword">if</span> locs_size:
<span class="hljs-comment">#    ()  </span>
    t.out = asm(<span class="hljs-string">"LOCAL %d MINUS SETLOCAL"</span> % locs_size) + t.out
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Arbeit mit Variablen erfolgt über ihre Adressen. Die Schlüsseldefinition hierfür lautet push_local (), wodurch die Adresse der Variablen "high-level" auf dem Datenstapel verbleibt.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push_local</span>(<span class="hljs-params">t, X</span>):</span>
<span class="hljs-comment">#          </span>
<span class="hljs-comment">#  </span>
  t.out = asm(<span class="hljs-string">"LOCAL %d MINUS"</span> % get_loc_offset(t, X))
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgenden Schlüsselpunkte sind bedingte und bedingungslose Übergänge. </font><font style="vertical-align: inherit;">Der bedingte Sprung im whiteTiger-Prozessor überprüft das zweite Element des Datenstapels auf 0 und springt zur Adresse oben im Stapel, wenn die Bedingung erfüllt ist. </font><font style="vertical-align: inherit;">Ein bedingungsloser Sprung setzt einfach den Wert des Befehlszählers auf den Wert oben im Stapel.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">@act</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">goto_if_0</span>(<span class="hljs-params">t, X</span>):</span><font></font>
  push_label(t, X)<font></font>
  t.out += asm(<span class="hljs-string">"IF"</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><font></font>
<font></font>
<span class="hljs-meta">@act</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">goto</span>(<span class="hljs-params">t, X</span>):</span><font></font>
  push_label(t, X)<font></font>
  t.out += asm(<span class="hljs-string">"JMP"</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgenden zwei Definitionen spezifizieren Bitverschiebungsoperationen - nur auf einer niedrigen Ebene werden Schleifen angewendet (dies führt zu einer gewissen Verbesserung der Codegröße) - im Original setzt der Compiler einfach die erforderliche Anzahl von Elementarverschiebungsoperationen in eine Reihe.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">@act</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shl_const</span>(<span class="hljs-params">t, X</span>):</span>
  t.out = asm(<span class="hljs-string">"%d DO SHL LOOP"</span> %(X<span class="hljs-number">-1</span>))
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><font></font>
<font></font>
<span class="hljs-meta">@act</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shr_const</span>(<span class="hljs-params">t, X</span>):</span>
  t.out = asm(<span class="hljs-string">"%d DO SHR LOOP"</span> %(X<span class="hljs-number">-1</span>))
  <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptdefinition des Compilers auf niedriger Ebene ist ein Satz von Regeln für Sprachoperationen und das Arbeiten mit dem Speicher:</font></font><br>
<br>
<pre><code class="python hljs">stmt = rule(alt(<font></font>
  seq(Push(Int(X)), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"%d"</span> % v.X))),<font></font>
  seq(Push(Local(X)), push_local),<font></font>
  seq(Push(Global(X)), push_global),<font></font>
  seq(Load(), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"NOP FETCH"</span>))),<font></font>
  seq(Store(), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"STORE"</span>))),<font></font>
  seq(Call(), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"CALL"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"+"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"PLUS"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"-"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"MINUS"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"&amp;"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"AND"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"|"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"OR"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"^"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"XOR"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"*"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"MUL"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"&lt;"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"LESS"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"&gt;"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"GREATER"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"=="</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"EQUAL"</span>))),<font></font>
  seq(BinOp(<span class="hljs-string">"~"</span>), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"NOT"</span>))),<font></font>
  seq(ShlConst(X), shl_const),<font></font>
  seq(ShrConst(X), shr_const),<font></font>
  seq(Func(X), func),<font></font>
  seq(Label(X), label),<font></font>
  seq(Return(X), epilog),<font></font>
  seq(GotoIf0(X), goto_if_0),<font></font>
  seq(Goto(X), goto),<font></font>
  seq(Nop(), to(<span class="hljs-keyword">lambda</span> v: asm(<span class="hljs-string">"NOP"</span>))),<font></font>
  seq(Asm(X), to(<span class="hljs-keyword">lambda</span> v: asm(v.X)))<font></font>
))<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dem Modul macro.py können Sie das Wörterbuch der Zielsprache mithilfe von Makrodefinitionen im Assembler des Zielprozessors etwas erweitern. </font><font style="vertical-align: inherit;">Für den Java-Compiler unterscheiden sich die Definitionen in macro.py nicht von den "nativen" Operatoren und Funktionen der Sprache. </font><font style="vertical-align: inherit;">So wurden beispielsweise im ursprünglichen Compiler E / A-Funktionen des Werts im externen Port definiert. </font><font style="vertical-align: inherit;">Testsequenzen von Operationen mit Speicher und lokalen Variablen und eine Zeitverzögerungsoperation wurden hinzugefügt.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">@macro(1,0)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">testasm</span>(<span class="hljs-params">c,x</span>):</span>
  <span class="hljs-keyword">return</span> Asm(<span class="hljs-string">"1 1 OUTPORT 0 1 OUTPORT 11 10 STORE 10 FETCH 1 OUTPORT  15 100 STORE 100  FETCH 1 OUTPORT"</span>)<font></font>
<font></font>
<span class="hljs-meta">@macro(1,0)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">testlocal</span>(<span class="hljs-params">c,x</span>):</span>
   <span class="hljs-keyword">return</span> Asm(<span class="hljs-string">"1 100 STORE 2 101 STORE 100 SETLOCAL LOCAL NOP FETCH 1 OUTPORT LOCAL 1 PLUS NOP FETCH 1 OUTPORT"</span>)<font></font>
<font></font>
<span class="hljs-meta">@prim(1, 0)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delay</span>(<span class="hljs-params">c, val</span>):</span>
  <span class="hljs-keyword">return</span> [val, Asm(<span class="hljs-string">"DO LOOP"</span>)]<font></font>
<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Ein kleines Testprogramm auf hoher Ebene für unseren Prozessor enthält die Definition einer Funktion zur Berechnung der Fakultät und die Hauptfunktion, die die serielle Ausgabe von Fakultätswerten von 1 bis 7 an den Port in einer Endlosschleife implementiert.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fact</span>(<span class="hljs-params">n</span>):</span>
  r = <span class="hljs-number">1</span>
  <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">1</span>:<font></font>
    r *= n<font></font>
    n -= <span class="hljs-number">1</span>
  <span class="hljs-keyword">return</span> r<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>
  n=<span class="hljs-number">1</span>
  <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
     digital_write(<span class="hljs-number">1</span>, fact(n))<font></font>
     delay(<span class="hljs-number">10</span>)<font></font>
     n=(n+<span class="hljs-number">1</span>)&amp;<span class="hljs-number">0x7</span><font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es kann zum Kompilieren beispielsweise durch ein einfaches Skript oder über die Befehlszeile in der folgenden Reihenfolge </font><font style="vertical-align: inherit;">
gestartet werden </font><font style="vertical-align: inherit;">: </font><font style="vertical-align: inherit;">Als Ergebnis wird eine Bootdatei stream.bin generiert, die über die serielle Schnittstelle (in modernen Realitäten über eine von Konvertern bereitgestellte virtuelle serielle Schnittstelle) auf den Prozessorkern im FPGA übertragen werden kann USB-UART-Schnittstellen). </font><font style="vertical-align: inherit;">Das Programm belegt somit 146 Wörter (9 Bit) des Programmspeichers und 3 im Datenspeicher.</font></font><br>
<code>c.py C:\D\My_Docs\Documents\uzh-master\tests\fact2.py<br>
</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Im Allgemeinen scheint der Uzh-Compiler ein einfaches und praktisches Toolkit für die Entwicklung von Software für Softwareprozessoren zu sein. </font><font style="vertical-align: inherit;">Es ist eine großartige Alternative zum Assembler, zumindest im Hinblick auf die Benutzerfreundlichkeit des Programmierers. </font><font style="vertical-align: inherit;">Das Toolkit zum Definieren von Grundelementen und Makros als Funktionen der Zielsprache ermöglicht die Implementierung kritischer Stellen in der Assemblersprache des Prozessors. </font><font style="vertical-align: inherit;">Für Prozessoren mit Stapelarchitektur ist das Compiler-Anpassungsverfahren nicht zu kompliziert und langwierig. </font><font style="vertical-align: inherit;">Wir können sagen, dass dies nur dann der Fall ist, wenn die Verfügbarkeit des Quellcodes des Compilers hilft - die Schlüsselabschnitte des Compilers ändern sich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ergebnisse der Prozessorsynthese (32-Bit-Kapazität, 4 KB Programmspeicher und 1 KB RAM) für die FPGA Altera Cyclone V-Serie ergeben Folgendes:</font></font><br>
<br>
<pre><code class="plaintext hljs">Family	Cyclone V<font></font>
Device	5CEBA4F23C7<font></font>
Logic utilization (in ALMs)	694 / 18,480 ( 4 % )<font></font>
Total registers	447<font></font>
Total pins	83 / 224 ( 37 % )<font></font>
Total virtual pins	0<font></font>
Total block memory bits	72,192 / 3,153,920 ( 2 % )<font></font>
Total DSP Blocks	2 / 66 ( 3 % )<font></font>
</code></pre><br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literatur</font></font></b></i><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Vierter</font></a><font style="vertical-align: inherit;"> Prozessor auf VHDL // </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m.habr.com/de/post/149686</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python - Wikipedia // </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Python</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir beginnen FPGA auf Python _ Habr // </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m.habr.com/en/post/439638</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MyHDL // </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.myhdl.org</font></font></a> </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub - true-grue_uzh_ Uzh-Compiler // </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/true-grue/uzh</font></font></a> </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub - true-grue_raddsl_ Tools für das Rapid Prototyping von DSL-Compilern // </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/true-grue/raddsl</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sovietov.com/txt/dsl_python_conf.pdf</font></font></a> </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Autor dankt den Entwicklern des Zmey-Softwareprozessors und des Uzh-Compilers für Beratung und Geduld.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de491590/index.html">Wir analysieren Empfehlungen zum Schutz personenbezogener Daten und zur Informationssicherheit - worauf Sie achten sollten</a></li>
<li><a href="../de491592/index.html">Von Galaxienmodellen zu Atomen - einfache Tricks in der KI-Implementierung beschleunigen Simulationen milliardenfach</a></li>
<li><a href="../de491594/index.html">Neue Kryptografiemethode, die perfekte Geheimhaltung verspricht, wurde mit Skepsis aufgenommen</a></li>
<li><a href="../de491600/index.html">Stadt und Daten: Analyse der Gehentfernung von Objekten in Prag mittels Data Science</a></li>
<li><a href="../de491602/index.html">Podcast: Warum die Arbeit eines unerfahrenen IT-Redakteurs eine Art „Militärdrama“ ist und was wir damit machen</a></li>
<li><a href="../de491606/index.html">So erstellen Sie ein Startmenü und eine Minikarte</a></li>
<li><a href="../de491608/index.html">Animationstipps von Cuphead und God of War</a></li>
<li><a href="../de491610/index.html">Deklarative Datenfilterung vorne. Js / ts</a></li>
<li><a href="../de491612/index.html">Vergleich der Dynamik von Notierungen zweier Aktien in Python am Beispiel von Vorzugs- und Stammaktien der Sberbank</a></li>
<li><a href="../de491614/index.html">Warum Masterhost zum Scheitern verurteilt war: ein Einblick</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>