<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕚 🥦 👨‍👩‍👧‍👦 彩色窗口：虚拟构造函数，CRTP和复杂的模板 👨🏽‍🎓 💰 👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在相当长的时间内，当在基本参数中传递派生类时，就已经知道了一种非平凡的设计模式：
 

template<class T> class Base { … };  class Derived : public Base<Derived> { … };
 该模板有自己的名称-CRTP：好奇重复模板模式，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>彩色窗口：虚拟构造函数，CRTP和复杂的模板</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/507146/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在相当长的时间内，</font><font style="vertical-align: inherit;">当在基本参数中传递派生类时，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就已经</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">知道了一种</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">非平凡的设计模式</font></a><font style="vertical-align: inherit;">：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">Base</span>
{</span><font></font>
	…<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base&lt;Derived&gt;<font></font>
{<font></font>
	…<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该模板有自己的名称-CRTP：好奇重复模板模式，其翻译为“奇怪的重复模式”。我为这个本来就很奇怪的构造增加了更多的奇怪之处：我将其概括为整个继承链。是的，确实可以做到，但是为此，您必须</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">付出灵魂</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的代价。要了解我是如何做到的以及必须支付的价格，请您进一步阅读本文以了解详细信息。</font></font><a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，我们将</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各种奇怪的方法和其他不好的方法</font><font style="vertical-align: inherit;">来处理</font><s><font style="vertical-align: inherit;">可怕的变态</font></s><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想立即警告您：请勿将此处描述的材料视为严重问题。我敢肯定，在95-99％的情况下，所有这些在实践中将永远对您没有用。这是一种有趣的数学，一种锻炼心灵的方法。在实践中，这不太可能有用，但是将时间花在此上很有趣。只有在这种情况下，C ++语言及其功能才能充当数学。我提前警告您，因为如果您在这里寻找严肃且实用的东西，您可能会感到失望。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
立即进入异国情调，就好像您突然发现自己在一个国家，那里有两个月亮，三个太阳，植物的叶子是蓝色或淡紫色的，实际上这里的许多平常事物都是……奇怪和不寻常的……如果您沉迷于灰色的日常生活中，不久前阅读类似的内容，然后您来到了地址...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多色的窗户</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那是很久以前。</font><font style="vertical-align: inherit;">大约三年前。</font><font style="vertical-align: inherit;">然后</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font><s><font style="vertical-align: inherit;">坐在沉重的草地上，</font></s><font style="vertical-align: inherit;">只理解了</font><font style="vertical-align: inherit;">Meyers S一书中的C ++ 11/14 </font><font style="vertical-align: inherit;">的</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zen</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基础-“有效和现代的C ++”。</font><font style="vertical-align: inherit;">它还提到了这种模式。</font><font style="vertical-align: inherit;">之后，当我感到自己已经</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获得启发时，我</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">掌握了新标准的基础，并准备以新的方式看待旧事物，因此我开始在自己的记忆中刷新一本有关Windows API的书：Shchupak Yu。-“ Win32 API。</font><font style="vertical-align: inherit;">有效的应用程序开发。” </font><font style="vertical-align: inherit;">在开始时，它描述了用于创建和显示窗口的最小C语言程序：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><font></font>
<font></font>
HWND hMainWnd;<font></font>
TCHAR szClassName[] = TEXT(<span class="hljs-string">"MyClass"</span>);<font></font>
MSG msg;<font></font>
WNDCLASSEX *wc;<font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{<font></font>
	HDC hDC;<font></font>
	PAINTSTRUCT ps;<font></font>
	RECT rect;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span>(uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		SetClassLongPtr(hWnd, <span class="hljs-number">-10</span>, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"Hello, world!"</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		DestroyWindow(hWnd);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		PostQuitMessage(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="hljs-keyword">int</span> nCmdShow)</span>
</span>{	
	<span class="hljs-keyword">if</span>(!(wc = <span class="hljs-keyword">new</span> WNDCLASSEX))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"  !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	wc-&gt;cbSize = <span class="hljs-keyword">sizeof</span>(WNDCLASSEX);<font></font>
	wc-&gt;style = CS_HREDRAW | CS_VREDRAW;<font></font>
	wc-&gt;lpfnWndProc = WndProc;<font></font>
	wc-&gt;cbClsExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;cbWndExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;hInstance = hInstance;<font></font>
	wc-&gt;hIcon = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
	wc-&gt;hCursor = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);<font></font>
	wc-&gt;hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<font></font>
	wc-&gt;lpszMenuName = <span class="hljs-literal">NULL</span>;<font></font>
	wc-&gt;lpszClassName = szClassName;<font></font>
	wc-&gt;hIconSm = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	<span class="hljs-keyword">if</span>(!RegisterClassEx(wc))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"     !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">delete</span> wc;<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	hMainWnd = CreateWindow(szClassName, TEXT(<span class="hljs-string">"A Hello1 Application"</span>), WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, <span class="hljs-number">0</span>, CW_USEDEFAULT, <span class="hljs-number">0</span>, (HWND)<span class="hljs-literal">NULL</span>, (HMENU)<span class="hljs-literal">NULL</span>, (HINSTANCE)hInstance, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
	<span class="hljs-keyword">if</span>(!hMainWnd)<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"   !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
	ShowWindow(hMainWnd, nCmdShow);<font></font>
	<span class="hljs-comment">//UpdateWindow(hMainWnd);</span><font></font>
<font></font>
	<span class="hljs-comment">//      </span>
	<span class="hljs-keyword">while</span>(GetMessage(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<font></font>
	{<font></font>
		TranslateMessage(&amp;msg);<font></font>
		DispatchMessage(&amp;msg);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//MessageBox(NULL, TEXT("Application is going to quit."), TEXT("Exit"), MB_OK);</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我已经做过很多次了，在本书的模型上显示了不同的窗口。</font><font style="vertical-align: inherit;">突然间，我想到：昨天我才刚读过C ++！</font><font style="vertical-align: inherit;">我可以编写自己的课程来显示此窗口！</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
说到做到：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;					<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该类的结构很简单：声明了几个构造函数（同时传递了主要参数和到更详细的WNDCLASSEX结构的链接），用于注册窗口类本身并创建窗口的CreateWnd函数（从构造函数中调用）以及一组执行操作的虚拟成员函数处理窗口回调过程中的每个Windows消息。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
类数据的成员也很少：窗口句柄hWnd;用于创建类的WNDCLASSEX结构；以及窗口的标题栏。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
窗口回调过程被声明为静态的，以避免将this指针隐式传递给类对象，从而违反了Windows接受的窗口过程的函数类型（签名）的约定（请记住，我们不会自己调用此函数，而是Windows，因为严格指定此函数的参数和返回类型）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">窗口过程和此指针</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从C ++可以知道：如果将成员函数定义为静态，则必须将指向类对象的指针显式传递给它。但是，我们不能将指向类对象的指针传递给静态窗口过程，因为此函数的格式不允许这种传输。在这方面，出现了一个基本问题：如果WindowClass类有多个对象，那么唯一的静态窗口过程如何知道消息接收到哪个特定的类对象？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
只有一种出路：您需要以一种或另一种方式建立此连接。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows通过其HWND hWnd句柄识别窗口。可以通过指向该窗口的指针来标识与该窗口相对应的类对象。因此，有必要建立到WindowClass对象的连接hWnd &lt;-&gt;指针。例如，同时属于类成员的窗口过程可以具有指向某些静态数据结构的链接或指针，该链接或指针可以为每个窗口在hWnd和对象指针之间建立连接，并在每次创建该类的对象时进行更新。数据结构必须是静态的，这样，首先，可以在没有任何类对象的指针的情况下从静态窗口过程中访问它；其次，它对于该类的所有对象应该是唯一的（从逻辑上讲，其目的是遵循此目的） ），第三，因此它仍然绑定到具有适当访问级别的类，而不是某个外部全局变量。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，在弄清楚如何描述这种结构以及为什么需要它之后，仍然需要找出这种结构。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以声明两个动态数组：一个用于HWND窗口句柄，另一个用于指向WindowClass对象的指针。但是，这不是最佳解决方案：不清楚如何选择阵列的大小，使用Windows的方案如何，如果阵列的大小选择不正确，阵列是否会变成几乎为空，这将导致内存溢出。或者，相反，当创建窗口时，其体积已用尽，有必要增加其尺寸等。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下一个更好的（甚至我会说是理想的）解决方案是列表（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">list！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）列表是一种动态数据结构，由成对连接的一组节点组成。每个节点（在双向链接列表的情况下）都具有指向列表的上一个和下一个节点的指针以及其他存储的数据。在我们的情况下，每个窗口节点对应于每个窗口，有用的数据是窗口句柄和WindowClass类对象的指针。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，每次创建新窗口时，都会创建一个新的列表节点并将其添加到其末尾（成为最后一个）。关闭时，该节点将被删除，并且前一个节点和下一个节点的指针会相互调整以替换远程节点。在这种情况下，没有内存溢出-创建的节点与创建的窗口数量一样多，并且在关闭窗口的同时删除它们。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，还应该将新的静态成员添加到WindowClass类中：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> List wndList;	<span class="hljs-comment">// ,    </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并声明其特权以使其能够访问WindowClass成员：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">friend</span> List;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（我现在不会在此给出列表类和节点类的定义，以及它们的功能，因为这并不直接适用于WindowClass类，并且该类的实现逻辑是已知的，而且是微不足道的。）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，当有新消息到达时，窗口过程将以防万一。属于它处理的编号，根据从Windows传递给它的窗口描述符hWnd，它访问该列表，根据指定的hWnd在其中搜索一个节点，找到后，获取指向WindowClass类对象的所需指针。然后，通过指针，它调用与正在处理的消息相对应的虚函数：对于被覆盖的类，具有相同名称的虚函数可以执行其他操作。</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowClass::WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{
	<span class="hljs-comment">// 	</span>
	ListElement * pListElem = <span class="hljs-literal">nullptr</span>;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span> (uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		{<font></font>
			<span class="hljs-comment">//lParam      CREATESTRUCT,         WindowClass,  </span>
			<span class="hljs-comment">// (.  WindowClass::CreateWnd)</span>
			CREATESTRUCT *cs = <span class="hljs-keyword">reinterpret_cast</span>&lt;CREATESTRUCT *&gt;(lParam);<font></font>
			WindowClass *p_wndClass = <span class="hljs-keyword">reinterpret_cast</span>&lt;WindowClass *&gt;(cs-&gt;lpCreateParams);<font></font>
			p_wndClass-&gt;hWnd = hWnd;		<span class="hljs-comment">// hWnd   ,    </span>
			<span class="hljs-comment">//    </span><font></font>
			pListElem = wndList.add(p_wndClass);<font></font>
			<span class="hljs-keyword">if</span> (pListElem)<font></font>
				pListElem-&gt;p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//  ,   </span><font></font>
		}<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)	<font></font>
			pListElem-&gt;p_wndClass-&gt;OnPaint(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnClose(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnDestroy(hWnd);  <span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里有一个微妙的地方。它涉及类的初始化和WM_CREATE消息的处理。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用CreateWindow函数创建窗口时，在调用该窗口时，尚不知道hWnd窗口句柄：该窗口尚未创建！因此，为了能够调用虚拟OnCreate，您需要知道指向类对象的指针。这是通过lParam指针将this指针从WindowClass :: CreateWnd函数传递到CreateWindow函数的冒险的。在处理WM_CREATE时，窗口过程从参数接收此指针，并在其帮助下初始化对象内的hWnd成员，然后使用指向类对象的指针为该窗口创建新的列表节点。然后，它通过指针调用虚拟OnCreate。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于其余消息，执行上述逻辑：通过从Windows传递的当前窗口句柄搜索列表节点，然后通过指针从列表节点调用所需的虚函数。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
编译完程序并确保一切正常后，我</font><font style="vertical-align: inherit;">从所做的工作中</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">感到自己的强大</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后开始进一步阅读。</font><font style="vertical-align: inherit;">在下一页上，显示了更改窗口属性的功能：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">DWORD <span class="hljs-title">SetClassLong</span><span class="hljs-params">(HWND hWnd, <span class="hljs-keyword">int</span> nIndex, LONG dwNewLong)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我立即决定在旧窗口的基础上创建一个新窗口：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass		<span class="hljs-comment">//         </span><font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
派生类与基类有所不同，它通过添加静态窗口计数器以及更改OnCreate，OnPaint和OnDestroy：OnCreate函数更改窗口的背景色，OnPaint显示不同的消息，而OnDestroy减小静态窗口计数器。</font><font style="vertical-align: inherit;">一切都非常简单明了。</font><font style="vertical-align: inherit;">组装并发射。</font><font style="vertical-align: inherit;">消息文本已经变得不同…… </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是窗口的颜色没有改变。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虚拟构造函数</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，我意识到我已经踏上了薄冰。</font><font style="vertical-align: inherit;">并非所有细微差别都在主要书籍的基本材料中进行了描述。</font><font style="vertical-align: inherit;">其中之一是虚拟构造函数。</font><font style="vertical-align: inherit;">我认为从构造函数中调用派生类的虚函数与程序中的其他地方完全相同。</font><font style="vertical-align: inherit;">事实证明，这无法完成。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
问题在于从构造函数调用的虚拟函数被称为非虚拟函数：仅创建基类对象，然后才创建基类对象，直到最后，还没有创建派生对象，并且还没有生成虚函数表。在我们的例子中，我们得到了链：派生构造函数-&gt;基本构造函数-&gt; CreateWnd-&gt; CreateWindow-&gt;窗口过程-&gt; OnCreate，也就是说，实际上是从构造函数调用OnCreate的。尚未创建派生对象，因此，基类将调用OnCreate！事实证明，它在派生中的重新定义是没有意义的！该怎么办？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从C ++可以知道，任何被覆盖的函数都可以通过其全名来调用：class_name :: function_name。类名不仅是一个名称：实际上，它可以标识对象的类型。从C ++还知道，可以通过将类（和函数）的类型作为参数传递来将其作为模板（模板）。因此，如果您制作窗口过程函数模板并以某种方式将派生类的类型传递给它，则可以直接在</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">的构造函数中调用所需的重写函数</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
停止停止停止！你不能做同样的事情！派生类尚未创建，其数据尚未初始化：您将在此处调用哪些函数？</font></font><br>
<s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果不能，但确实希望，那么可以。</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，我的目标并不是完全吸引派生阶层。</font><font style="vertical-align: inherit;">我打算调用一个完全</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三方的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> WinAPI函数，该函数与该类无关。</font><font style="vertical-align: inherit;">“但是这可以用完全不同的方式来完成，而且容易得多！” </font><font style="vertical-align: inherit;">- 你说。</font><font style="vertical-align: inherit;">是。</font><font style="vertical-align: inherit;">能够。</font><font style="vertical-align: inherit;">我将在文章末尾对此进行撰写。</font><font style="vertical-align: inherit;">但是在那一刻，我把所有这些都抛在了一边，只专注于问题的纯技术方面：但是，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从原则</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上讲，仍然可以</font><b><font style="vertical-align: inherit;">在</font></b><font style="vertical-align: inherit;">基类的构造函数中从派生类中调用某些东西吗？</font><font style="vertical-align: inherit;">如果您愿意的话，这纯粹是一种体育兴趣。</font><font style="vertical-align: inherit;">当时我还没有考虑任何实际方面。</font><font style="vertical-align: inherit;">这是一项艰巨的任务，我想知道是否可以解决它。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">窗口模板类-方法1</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，困难在于：如何将派生类的类型传递给窗口过程？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我不想立即将WindowClass的整个基类作为模板类：对于每个派生类，将生成其自己的基类。另外，由于WindowClass将成为模板，因此列表节点和列表本身也都必须成为模板：它们具有指向类对象的指针，并且要使用这些指针，他们必须知道其类型，即WindowClass以及将使用其参数化的对象。在定义列表类和节点类时，这是未知的；因此，此类型也必须作为参数（从WindowClass）传递。因此，将为每个派生类创建与</font><b><i><font style="vertical-align: inherit;">该派生类</font></i></b><font style="vertical-align: inherit;">相对应的自己的列表</font></font><b><i><font style="vertical-align: inherit;"></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（只有他）！现在，您不能将指向与不同派生对应的基类的指针放在一个数组中：它们具有不同的类型。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我开始寻找一种在不参数化整个类的情况下传递派生类类型的方法。类型只能通过构造函数传递给基类：这是创建对象时唯一访问的函数。因此，它应该是样板。但是，事实证明，她显然无法指定模板参数：看起来就像将参数传递给模板类本身，而不是传递给其构造函数。因此，只能从传递给构造函数的参数中推断类型。但是我不想添加一个特殊的构造函数参数，该参数仅用于类型推断：使用纯实用程序参数将参数列表弄乱。例如，如果用户忘记了转移，通过至少琐碎的（DerivedClass *）nullptr？这还不可怕-编译器将显示一条错误消息，指出无法实例化该类。更糟糕的是，如果用户创建了一个类层次结构并传递了指向错误的派生类的指针：从编译的角度来看，一切都将是正确的，但是，我们将得到一个运行不正确的程序，并带有一个无法理解的错误。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
简而言之，这种设计计算错误就是一种解决方案。</font><font style="vertical-align: inherit;">因此，正确实例化的责任甚至不移交给派生类的创建者，而是移交给使用它的人！</font><font style="vertical-align: inherit;">他既不是梦想，也不是关于这种细微差别的精神，并且真诚地不了解错误的出处。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最终，我还是放弃了，但仍然决定不更改构造函数的参数来对WindowClass本身以及相关的列表和列表节点类进行参数化。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WindowClass模板类：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">struct</span> <span class="hljs-title">ListElement</span>				// 
{</span>
	<span class="hljs-comment">// </span>
	HWND hWnd;					<span class="hljs-comment">//  Windows</span>
	WindowClass&lt;WndCls&gt; *p_wndClass;	<span class="hljs-comment">//    WindowClass</span><font></font>
<font></font>
	ListElement *pNext;			<span class="hljs-comment">//    </span>
	ListElement *pPrev;			<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-keyword">using</span> WndProcCallback = LRESULT (*)(HWND, UINT, WPARAM, LPARAM);		<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List&lt;WndCls&gt; wndList;					<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//	</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T, <span class="hljs-keyword">typename</span> </span>= T::OnCreate&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//! .  FirstWin32CPP_DerivedTemplate2</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span><font></font>
		T::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//  OnCreate         </span>
	</span>{<font></font>
		p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List&lt;WndCls&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
	<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
派生类：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WindowClassDerived&amp;);		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
窗口过程是模板类的模板成员，并且可以访问派生类的传递类型，因此调用派生类的OnCreate。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们自然而然地来到了CRTP模板。在这里，结果本身。直到很久以后，我才发现该设计是带有相应名称的知名模板。但是后来我不知道这一点，在我看来，我是第一次收到它。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我马上意识到这只是解决方案的一半。</font><font style="vertical-align: inherit;">我可以轻松地基于此派生类创建另一个类。</font><font style="vertical-align: inherit;">就是这样：它不是样板，不再接受任何参数。</font><font style="vertical-align: inherit;">所以我想到了将第二个派生类通过第一个派生类传递给基类的想法。</font><font style="vertical-align: inherit;">（我脚下的薄冰开始破裂……我已经去了无可挽回的地方。）但是，如果我做一次，我可以做很多我想做的事：即使我有十个派生类，我也可以连续学习第十个（最后一个）沿链传递到基数，它会在此处调用我需要的最后一个导数的功能（一般来说，如果需要的话，是任何中间一个）。</font><font style="vertical-align: inherit;">任务很明确。</font><font style="vertical-align: inherit;">剩下的就是要做。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数化窗口类-方法2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第二次运行中，我为自己设置了三个任务：</font></font><br>
<ul>
<li>-     ;</li>
<li>   ;</li>
<li>   ,   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，为了符合这些要求，您仍然必须为设计者制作一个模板，并为其添加一个特殊的参数。但是，这意味着违反了另一个要求。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里有什么解决方案？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以将原始WindowClass基类分为两个部分：WindowClass本身（现在将其称为WindowClassBase），它是一个不可动摇的基础，以及对它的派生类的补充（可以称为相同的原始WindowClass名称）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
互补类负责OnCreate的实现，此外，它可以作为一个整体进行参数化。并且他在他的构造函数中会将通过特殊参数传递给他的类型传递给WindowClassBase类的构造函数。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
无论如何，现在相对于源在WindowClassBase中，您必须进行一些更改。首先，除了实际从中删除OnCreate之外，您还必须向该类的指针类添加一个指针成员（并在将来对其进行派生），以及通过该指针调用OnCreate的调用函数：我们无法将指针指向基类，因为OnCreate不再在其中，并且互补的类和从中继承的类的OnCreate最好通过指向所需类的正确指针来调用它，而不是尝试使用基类的this指针进行调用。最终，不仅需要使用WindowClassBase构造函数的特殊参数进行类型推断，而且还需要保存并通过OnCreate调用必要的类。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不幸的是，必须将此指针的类型设为空：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该类不是模板，您不能告诉编译器创建类型未知的指针；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">许多派生类都是从基类继承的，它们都有不同的类型-我应该使用哪种类型的指针？</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，我只是用C样式声明了它：在任何奇怪的情况下，请使用指向void的指针。</font><font style="vertical-align: inherit;">指针在物理上存储为无类型，但是在调用时，OnCreate被强制转换为被调用类的类型。</font><font style="vertical-align: inherit;">这是通过属于WindowClassBase的特殊模板调用函数完成的，该函数的参数类型在调用时是已知的：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
</span>{
	<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span>
	<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
		(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（最初，std :: true_type或std :: false_type被用作第二个参数来选择所需的选项以覆盖该函数。使用SFINAE方法，在编译阶段确定WndCls类是否具有OnCreate成员函数。如果有，则调用该函数的上述版本。如果不是，则以以下形式调用OnCreate：</font></font><br>
<pre><code class="cpp hljs">(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;OnCreate(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
随后，事实证明SFINAE并不是必须的：补充WindowClassBase的类无论如何都具有OnCreate成员函数，因此，即使传递的WndCls参数类中未定义OnCreate，它也位于相对于其的基类之一中，并且在所有情况下检查都为true。如果奇迹般地改变了补全类，从而从中删除了OnCreate，并且它也不在其所有派生类中都存在，那么以第二种方式调用它就没有意义：这样的代码将不会被编译。因此，最后，这里给出了上述选项。）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在WindowClassBase中接受和使用基类类型的逻辑非常简单：该类型是从指向派生类的对象的指针派生的，该派生类的对象传递给WindowClassBase构造函数，此指针存储在此构造函数中，并且该指针传递给模板窗口过程，并从中访问上述LaunchOnCreate。 。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，WindowClassBase类现在将如下所示：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassBase</span>				//  <span class="hljs-title">Windows</span>
{</span>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span>
	<span class="hljs-keyword">void</span> *p_drvWndCls;								<span class="hljs-comment">//   ,    (..  -  </span>
													<span class="hljs-comment">//,   ( )   , ..   void</span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls</span>
		<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
			(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">friend</span> List;
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">friend</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//     </span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassBase(WindowClassBase&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassBase();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好，这是最短的构造函数的代码：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase::WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle)</span>
</span>{
	<span class="hljs-comment">// ,   ,   wc</span>
	<span class="hljs-comment">// : p_wndClass -    ,        , wc -    </span>
	<span class="hljs-comment">//    Windows, szWndTitle -   </span><font></font>
<font></font>
	WindowClassBase::wc = wc;<font></font>
	WindowClassBase::wc.lpfnWndProc = WndProc&lt;WndCls&gt;;<font></font>
	WindowClassBase::szWndTitle = szWndTitle;<font></font>
<font></font>
	p_drvWndCls = p_wndClass;		<span class="hljs-comment">//    ,   OnCreate()      WM_CREATE</span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	CreateWnd(WindowClassBase::wc, <span class="hljs-literal">false</span>, szWndTitle);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在窗口过程中，对LaunchOnCreate的调用如下：</font></font><br>
<pre><code class="cpp hljs">p_wndClass-&gt;LaunchOnCreate&lt;WndCls&gt;(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他决定从外部类中删除窗口过程本身，并在WindowClassBase类中声明它的特权。也许这没有多大意义：在类的外部还是内部，它有什么区别，在哪里产生实例化？代码段是一个！我承认，尽管从相同封装的角度来看，也许您仍然应该将其静态保留在类中。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定义互补类仍然是：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase			<span class="hljs-comment">//,  WindowClassBase    </span><font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该类具有一个与拆分前的原始WindowClass相同的构造函数，即没有特殊参数，并且通过传递this指针访问WindowClassBase构造函数时会在内部生成此特殊参数。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种形式的WindowClass几乎等同于原始WindowClass。</font><font style="vertical-align: inherit;">因此，它不支持使用OnCreate覆盖的继承。</font><font style="vertical-align: inherit;">但是，这是支持继承的起点（如下所示）。</font><font style="vertical-align: inherit;">以这种形式：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基类WindowClassBase本身不是通用的，这意味着它将是所有派生类的唯一类，无论它们是什么。</font><font style="vertical-align: inherit;">确保所有其他Windows消息均得到正确处理的列表也是唯一的列表；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClass构造函数没有额外的特殊参数。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，三个要求中的两个都得到了满足。</font><font style="vertical-align: inherit;">仍然需要处理后者：继承。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassBase中的派生类类型链接，控件类型</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，当WindowClass的初始化逻辑不适合我们时，我们将考虑一次性继承，并且我们想通过创建派生类来更改它（至少现在是这样）。</font><font style="vertical-align: inherit;">为了确保这一点，需要在WindowClass中进行哪些更改？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
互补类的一个新变种成为样板。</font><font style="vertical-align: inherit;">这并不可怕，因为它实际上不包含任何数据，而仅包含OnCreate函数和构造函数：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此类采用DerWndCls类型的参数，并将此指针转换为它，然后将其传递给WindowClassBase。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意static_cast。这很重要，因为我的转换最初是用C风格编写的，如下所示：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在将其翻译为static_cast后，一半的代码（请参见下文）未编译。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这也是一个棘手的问题：转换是在编译阶段执行的，但是此类本身具有OnCreate函数，并且在转换之后，可以使用DerWndCls来调用DerWndCls类的OnCreate。</font><font style="vertical-align: inherit;">这与WindowClassBase内部上述转换情况不同。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，您可以创建一个特定的类WindowClassDerived，在其中重写OnCreate并使用上述WindowClassTemplate对其进行实例化，再次实现与本文开头所述相同的原始奇怪重复模板：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后将根据需要在WindowClassBase内部调用此WindowClassDerived的OnCreate！</font></font><br>
<pre><code class="cpp hljs">WindowClassDerived::WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle) : WindowClassTemplate(hInstance, szClassName, szWndTitle)<font></font>
{<font></font>
	usiWndNum++;		<span class="hljs-comment">//    </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但这是一次继承。</font><font style="vertical-align: inherit;">在多重继承的情况下，您应该声明一个新模板，而不是WindowClassDerived，从而可能使该类在层次结构中处于更高的级别，并将其传递给WindowClassTemplate。</font><font style="vertical-align: inherit;">我特别强调两个关键点：</font></font><br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">潜在地将</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类托管在层次结构中。</font><font style="vertical-align: inherit;">这意味着它可能不接受任何类，即它本身是层次结构中最顶层的类，因此可以从中创建对象。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传输</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数WindowClassTemplate。</font><font style="vertical-align: inherit;">这意味着必须将接受的模板参数通过整个继承链从一个类传递到另一个类，直到在WindowClassTemplate的最底层，再从那里传递到WindowClassBase。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也就是说，一方面，该类必须是模板，并以某个类作为参数。另一方面，它必须监视这种情况：它本身是一个有限的类（在实例化时），并通过自身而不是通过传递的类型实例化基类。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有了所有这些，我希望编译器自动完成它：基于已经创建的类定义新类将不需要对后者进行任何修改-这样就失去了继承多态性的全部本质。那就是：我创建了一个当前位于层次结构顶部的</font><font style="vertical-align: inherit;">类</font><font style="vertical-align: inherit;">，但是</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也许</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会基于此类创建一个新类，该类将替换当前类而不更改其定义。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如何实现此功能？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了解决自动化和智能决策的问题，模板的默认参数会提示自己：如果正在创建的当前类是顶级类，并且未将template参数传递给它，那么我们必须为其分配此参数。这是使用默认参数完成的。然后出现以下问题：如何选择它，以及如何将其与显式传递的参数的情况相关联；如果不传递参数，则如何传递自身？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不幸的是，您不能将自己定义的类编写为默认参数。编译器将不会错过以下形式的代码：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">WindowClassDerived</span>&lt;&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他报告说，递归类型依赖关系太复杂了。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们走到另一边。</font><font style="vertical-align: inherit;">让我们介绍一个虚拟的类，该类不执行任何功能，也不存储任何内容，仅扮演伪插件的角色，并向编译器发出信号，在其出现的情况下“从上方”不进行任何传输：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};	<span class="hljs-comment">//-,     </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并在默认参数中，用以下方法代替我们自己：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用此选项时，在具有默认参数的情况下，此类将传递给WindowClassTemplate。</font><font style="vertical-align: inherit;">thisclass类没有OnCreate成员函数，因此该选项根本无法编译。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，我们尝试引入第二个辅助控制参数，在此基础上，我们将确定要传递的类型。</font><font style="vertical-align: inherit;">为此，当然，您需要更改WindowClassTemplate，例如，如下所示：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassControlBaseTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//  ControlType == thisclass,      DerWndCls,    ,   WindowClassBase</span>
	<span class="hljs-comment">//  ControlType != thisclass,    ControlType,        ( </span>
	<span class="hljs-comment">//    ControlType     )</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;ControlType, thisclass&gt;::value, DerWndCls, ControlType&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassControlBaseTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassControlBaseTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不是一种类型传输给它，而是两种。基于这两种类型的组合，使用&lt;type_traits&gt;工具确定最终类型：std :: conditional_t和std :: is_same。正是这种类型传递给WindowClassBase。注释中描述了选择逻辑：如果将此类传递给ControlType，则我们选择DerWndCls，否则选择ControlType本身。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们构建一个在继承时使用它的模板：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsDerivedTemplateClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassControlBaseTemplate&lt;WndClsDerivedTemplateClass&lt;DerWndCls&gt;, ControlType&gt;		<span class="hljs-comment">//      </span><font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WndClsDerivedTemplateClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WndClsDerivedTemplateClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WndClsDerivedTemplateClass(WndClsDerivedTemplateClass&amp;);	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WndClsDerivedTemplateClass() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
默认情况下，第一个参数是通过thisclass初始化的，ControlType是根据DerWndCls本身计算的：如果DerWndCls = thisclass，则ControlType：= thisclass，否则ControlType：= DerWndCls（特别指定的Pascal样式分配以区别于比较）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，由DerWndCls参数化的WndClsDerivedTemplateClass类本身将与所计算的控件类型（在编译阶段）一起传递。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果创建此类的对象，即WndClsDerivedTemplateClass本身是层次结构的顶部，则DerWndCls = ControlType = thisclass，然后&lt;WndClsDerivedTemplateClass，thisclass&gt;通过。 WndClsDerivedTemplateClass由虚拟对象参数化的事实并不重要-这种类型以及实际上传递的所有DerWndCls都不会以任何方式在类内部使用：不会从该对象创建任何对象，也不会通过该对象调用任何函数。因此，形式上的WndClsDerivedTemplateClass可以用任何字面量实例化-参数类型仅用于沿继承线进一步传递。但是在这里，传递了WndClsDerivedTemplateClass &lt;thisclass或任何其他类型&gt;而不是DerWndCls，这很重要：WndClsDerivedTemplateClass具有一个OnCreate函数，在WindowClassBase内部将被调用。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用此选项，该类将代替ControlType进入WindowClassControlBaseTemplate，最终类型显示为DerWndCls = WndClsDerivedTemplateClass，该类具有所需的OnCreate函数。这就是我们所需要的。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，考虑基于WindowClassControlBaseTemplate构建新类时的选项（进一步继承）：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，在WndClsDerivedTemplateClass中，此类以外的东西代替了DerWndCls，而看到这种差异的ControlType承担了传递给DerWndCls的值。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后在WindowClassControlBaseTemplate中使用以下参数化选项：&lt;WndClsDerivedTemplateClass &lt;WindowClassDerivedTemplateNext&gt;，WindowClassDerivedTemplateNext&gt;。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
反过来，在WindowClassControlBaseTemplate中，由于ControlType！= Thisclass，所以使用ControlType本身，它等于WindowClassDerivedTemplateNext，后者是选择OnCreate的正确类。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
乍一看，采用这种方案，一切似乎都很好。但是事实并非如此。我们基于后者构建另一个类：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedTemplateNext&lt;WindowClassDerivedTemplateNext2&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在WindowClassDerivedTemplateNext中，WindowClassDerivedTemplateNext2将替换DerWndCls。 ControlType也作为WindowClassDerivedTemplateNext2输出。然后，将WindowClassDerivedTemplateNext </font><font style="vertical-align: inherit;">&lt;WindowClassDerivedTemplateNext2&gt; </font><font style="vertical-align: inherit;">传递给</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WndClsDerivedTemplateClass</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且ControlType将在其中显示相同的WindowClassDerivedTemplateNext &lt;WindowClassDerivedTemplateNext2&gt;。接下来，将相同的值传输到WindowClassControlBaseTemplate，并在那里代替正确的WindowClassDerivedTemplateNext2 &lt;WindowClassDerivedTemplateNext&gt;，使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;WindowClassDerivedTemplateNextTerplateDiveTerplateDiveTlassDimeTextDementer </font><font style="vertical-align: inherit;">来</font><b><font style="vertical-align: inherit;">调用</font></b><font style="vertical-align: inherit;"> WindowClass函数。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我提醒您，使用这种继承和传递参数的方案，</font><font style="vertical-align: inherit;">结果是进入WindowClassControlBaseTemplate </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类</font><b><font style="vertical-align: inherit;">本身</font></b><font style="vertical-align: inherit;">的类型</font><font style="vertical-align: inherit;">很重要，而不是对其进行参数设置的类型。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，为了正确显示要为其调用OnCreate的类型，您需要更改WindowClassDerivedTemplateNext类的定义：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，然后在WndClsDerivedTemplateClass中，等于WindowClassDerivedTemplateNext2的正确值将被传递给ControlType，而不是在那里显示错误的值。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们正在构建的最后一个类不应传递ControlType，允许最接近的基类独立输出它，并且该基类和所有基础基类必须显式传递ControlType，从而禁止将其自动输出为错误的值。这种方法意味着</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了最接近的基类</font><b><font style="vertical-align: inherit;">的</font></b><font style="vertical-align: inherit;">定义，只有当我们有可用的源代码或我们自己构建源代码时才有可能。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们忘记这样做并违反了此规则，则在使用static_cast时，会出现编译错误，并且如果在WindowClassControlBaseTemplate内转换C风格的指针，则会得到一个</font><font style="vertical-align: inherit;">工作</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不正确的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序。例如，如果我们尝试为一个类创建一个对象</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
则编译器将给出一个错误：由于该类型不正确且无法为其进行转换，因此它将无法在WindowClassControlBaseTemplate中转换指针类型（因为我们将创建WindowClassDerivedTemplateNext类的对象，因此我们假定WindowClassDerivedTemplateNext类本身位于顶部层次结构，在这种情况下，如上所示，不应传递ControlType。没有static_cast，代码将编译并仅调用错误类的OnCreate。但是，删除ControlType传输会使程序重新编译。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最终，所有这些都太复杂，不可靠，并且要求提供所有类的源代码。</font><font style="vertical-align: inherit;">另外，我们只能创建最后一个派生类的对象，并且由于ControlType的传输而不能创建其基类之一（或者如果以C样式传递指针，则可以，但是这些对象将被错误地初始化）。</font><font style="vertical-align: inherit;">我们需要一个更简单，更可靠的解决方案。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可变模板</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，上述模板继承的变体以及将创建的对象的类型传递给WindowClassBase类（在其中创建窗口和OnCreate调用）的类具有严重的缺陷。我们需要其他更可靠，更有效的选择。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 11引入了一种新型的模板：具有可变数量的参数的模板或可变模板。它的参数是一系列以前未知长度的类型。我决定采用另一种方法，而不是在上一个示例中使用控件类型进行危险的操作：避免层次结构中的中间类通过不正确的参数设置替换层次结构中的父类的情况（在上面的示例中是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;WindowClassDerivedTemplateNext2&gt;），通常可以通过将这些类按顺序依次放在一起来解决这种类型的参数化问题。例如，在模板参数中具有三个连续继承的情况下，最终将形成以下列表：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&lt;WndCls3 &lt;&gt;，WndCls2 &lt;&gt;，WndCls1 &lt;&gt;&gt; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更准确地处理此列表的最后一个元素（取决于您的构成方式），您可以在层次结构中提取所需的类并使用它。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，您应该编写一个新的变量模板类，而不是前面所述的WindowClassTemplate和WindowClassControlBaseTemplate模板，这些模板最接近根WindowClassBase并构成所有其他继承的基础。在最简单的版本中，它将是这样的：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,      </span>
<span class="hljs-keyword">template</span>&lt;class... Classes&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>;</span>		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-comment">//,          </span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span>... <span class="hljs-title">OtherWindowClasses</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>&lt;DerWndCls, OtherWindowClasses...&gt; :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//      :    - DerWndCls</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = DerWndCls;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadicTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadicTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，声明没有主体的类模板的一般描述。然后，确定他的专长，其中将第一种与其他类型分开。是我们感兴趣的他。当在层次结构链中向下移动到WindowClassBase时，每个后续类都将自身</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">置于</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数列表</font><b><font style="vertical-align: inherit;">的末尾</font></b><font style="vertical-align: inherit;">时，情况就是这样</font><font style="vertical-align: inherit;">。然后，我们需要的课程将在开始时，将其与其余部分分开非常简单。您可以做不同的事情：每个新类都将自己</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">放在开头</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模板选项列表。然后，层次结构顶部的类将是列表中的最后一个类，并且从那里提取它要困难得多。在这种情况下，这两种方法是完全相同的，但是第一种方法更容易实现（包括在编译过程中-您不必通过提取列表中的最后一个元素来处理整个列表），而上面给出的正是他的方法。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从列表中检索第一个元素，它是层次结构中的最高类，并传递给WindowClassBase。如果为其定义了OnCreate，它将被调用。否则，将相对于其调用最接近的基类的OnCreate。如果变量参数列表为空（我们正在尝试从WindowClassVariadicTemplate创建对象），则编译将失败，要求参数列表中至少包含一种类型。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基于WindowClassVariadicTemplate的第一类将是这样的：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic1</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadicTemplate&lt;PrevWndClasses..., WindowClassVariadic1&lt;&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadic1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(hInstance, szClassName, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadic1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(wc, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	WindowClassVariadic1(WindowClassVariadic1&amp; wcObj) : WindowClassVariadicTemplate(wcObj)			<span class="hljs-comment">// </span><font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassVariadic1() <span class="hljs-keyword">override</span>		<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);		<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_DESTROY   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此类接受了PrevWndClasses参数的未定义列表，然后将其进一步传递给基类，将其自身插入为空列表中的第一个元素。</font><font style="vertical-align: inherit;">由于此类WindowClassVariadic1本身是变量，因此WindowClassVariadic1 &lt;&gt;也将是变量，尽管没有参数，并且整个类序列实际上是一个变量模板，其每个元素也是一个变量模板。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下派生类是：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic2</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic1&lt;PrevWndClasses..., WindowClassVariadic2&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了更改派生名称和基名称之外，该类的形式与上一个完全相同。</font><font style="vertical-align: inherit;">下一个类是类似的：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic3</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic2&lt;PrevWndClasses..., WindowClassVariadic3&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是多态多重继承的含义：通过这样声明一个类，我们不仅保证创建这种类型的对象，而且还保证从该类型派生的所有其他类的所有对象，无论它们将来有多少。在这种情况下，将始终在WindowClassBase中调用正确的OnCreate。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，此变量模板是解决在创建完全满足所有先前设置的要求的窗口时调用OnCreate的问题的第一种工作方法。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
展望未来，最终找到了给定情况下的最佳方法，通过变量模板实现继承可以使您在WindowClassBase中实现更复杂的编译逻辑：可以访问发生继承的所有类型，您可以灵活地从中选择必要的类型。或条件，然后调用其中定义的成员函数。</font><font style="vertical-align: inherit;">但这仍然是一个稍微不同的情况。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始化类</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于不了解static_cast对派生类型的反应，我继续寻找其他方法来实现将层次结构的顶点类转移到WindowClassBase。</font><font style="vertical-align: inherit;">在某些时候，我考虑过将OnCreate实现带到专门为其创建的单独的类中：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassInit1</span>
{</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该类参数化另一个类，该类实现虚拟功能的所有其他替代。</font><font style="vertical-align: inherit;">它从已经描述的WindowClassTemplate派生而来：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsInit</span> = <span class="hljs-title">WindowClassInit1</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedI1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WndClsInit&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过这种方式：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类继承对于虚拟函数照常发生；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据继承链，只有为实现OnCreate的实现而专门定义的初始化类才在一个类之间转移。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果此类位于层次结构的顶部，则WndClsInit参数将等于WindowClassInit1-为该类定义的初始化类，并将沿层次结构链进一步传递它。如果此类在链中处于中间位置，则它将仅接受传递给它的类并将其继续传递。然后，该选项与之前的选项相比具有优势，因为模板不会自行传输，而是会传输一些第三方类，这种类的实现（看起来）要容易得多。这种形式的模板也适用，无需更改即可用于整个继承链的实现：仅类名会更改。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，与C样式转换不同，static_cast在WindowClassTemplate内部不会丢失这种继承形式：将其从（WindowClassTemplate *）传递给（WindowClassInit1 *）时，它根本无法转换。</font><font style="vertical-align: inherit;">这是合乎逻辑的：WindowClassInit1实际上是一个无关的类，只是作为一种类型传递给了这一点，它与WindowClassTemplate以及它的整个派生链没有任何关系，因此指针转换到它是不可接受的。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassBase中的派生类类型链接，条件转移</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，在这种情况下，找到了最好的方法，即通过整个继承链将派生类的类型转移到根基础WindowClassBase，从而避免了以前的缺点，同时比变量模板更简单。</font><font style="vertical-align: inherit;">基于WindowClassTemplate定义以下模板类：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassDerivedAlternative1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerivedAlternative1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerivedAlternative1() <span class="hljs-keyword">override</span>	<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);	<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>			<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>	<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{
		<span class="hljs-comment">//  WM_PAINT   </span><font></font>
		HDC hDC;<font></font>
		PAINTSTRUCT ps;<font></font>
		RECT rect;<font></font>
<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"       ( )."</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此类接受DerWndCls作为参数，默认情况下等于该类。</font><font style="vertical-align: inherit;">在传输过程中，将DerWndCls与该类进行比较：在相等的情况下（默认值，即给定的类位于层次结构的顶部），它将通过一个空参数列表进行传递。</font><font style="vertical-align: inherit;">否则，将继续接收到的DerWndCls。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为这种解决方案在所有方面都是这种情况下最好的：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整个继承链的单一类定义形式；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">沿整个继承链进行类传递的简单透明的逻辑；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于变量模板而没有开销（在这种情况下，例如在不需要时）。</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可怕的报应</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是什么意思呢？</font><font style="vertical-align: inherit;">这意味着，如果要使用这种非常规的继承形式，则必须以严格定义的方式对所有类进行形式化，以便它们允许您自己转移可能的新派生类。</font><font style="vertical-align: inherit;">这是一个非常简单的要求，并且，如果您愿意，则很容易遵循。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是还有另一个更重要的问题：类型和指针之间的关系。</font><font style="vertical-align: inherit;">聪明的人写道：不要在构造函数中玩这些东西，并且要违背语言的原理和编译器的逻辑。</font><font style="vertical-align: inherit;">但是我还是没有服从。</font><font style="vertical-align: inherit;">现在是自然报应。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们有4个类别：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
…<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative2&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	…<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative3</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative2&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative3&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	…<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative4</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative3&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative4&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	…<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正如我上面所写，它们的具体内容和工作逻辑完全不重要。</font><font style="vertical-align: inherit;">唯一重要的是在类定义的标题中。</font><font style="vertical-align: inherit;">基于这些类，我们创建4个对象：</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">WindowClassDerivedAlternative1&lt;&gt; <span class="hljs-title">w1</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative2&lt;&gt; <span class="hljs-title">w2</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative3&lt;&gt; <span class="hljs-title">w3</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative4&lt;&gt; <span class="hljs-title">w4</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>))</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们使用默认参数扩展隐藏在方括号内的类型的定义。 w1类型是WindowClassDerivedAlternative1。类型w2为WindowClassDerivedAlternative2，其基类为WindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative2&gt;。 w3类型是WindowClassDerivedAlternative3，其基类是WindowClassDerivedAlternative2 &lt;WindowClassDerivedAlternative3&gt;，其基类是WindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative3&gt;。同样，对于第四个对象。看下图：</font></font><br>
<img src="https://habrastorage.org/webt/bu/b5/nn/bub5nnsttowpw1lhstypwm-3vfc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过在以此方式定义的某个基类的基础上创建每个新的派生类，您不仅可以定义一个新类，而且还可以重新定义其基类的整个链。它将平行于其自己的基类的链。您的类将具有自己的基类，尽管所有这些类的生成代码都是相同的，但它们都不能够导致任何原始基类！似乎是真实的幻想，但实际上是！这意味着操纵继承的类和指针的所有常规方法将不起作用！在这种特定的体系结构中，只有基本的WindowClassBase可以保存这种情况，否则也将无法从基本类（例如，基于WindowClassTemplate）创建数组，因为所有这些类都有不同的类型。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，该形式的众所周知的和易于理解的定义是：</font></font><br>
<pre><code class="cpp hljs">WindowClassDerivedAlternative1&lt;&gt; *p2 = &amp;w2;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...将停止编译，因为尽管半小时前您自己编写了一个从WindowClassDerivedAlternative1 &lt;&gt;类派生并基于w2对象创建的类，但您正试图创建与w2对象的类型不兼容的类型指针。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当习惯法停止工作时，可能会引起震惊。</font><font style="vertical-align: inherit;">有了这些，实际上没有脏的编译器hack，强制类型转换和其他真正不好的事情。</font><font style="vertical-align: inherit;">一切都非常干净合法：模板，默认参数和类型库工具。</font><font style="vertical-align: inherit;">只有熟悉的代码编写方法才能停止工作。</font><font style="vertical-align: inherit;">在实际项目中使用此功能意味着要声明一个危险区域，只有具有适当保护措施的合格专业人员才能进入该区域。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码实验</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了使感兴趣的每个人都更容易进行实验并节省键入时间，我在GitHub上发布了作为本文基础的所有项目：</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ECRTP</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
只需依次选择一个项目作为开始的项目，否则您将淹没在五彩缤纷的窗户中。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“如果所有这些都是开玩笑的话，那么，考虑到付出的努力，它看起来太严肃和自然了。</font><font style="vertical-align: inherit;">如果不是开玩笑，那么任何正常的开发人员都不会真正使用类似的方法。</font><font style="vertical-align: inherit;">而且无论如何，伙计，你会不会胡说八道，不去做些能</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">赚钱的</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事情</font><s><font style="vertical-align: inherit;">，这</font></s><font style="vertical-align: inherit;">很有用。” </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您是这样的话，那您就是对的。</font><font style="vertical-align: inherit;">在本文中，我刚刚展示了C ++ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这些结构的实际应用问题仍然存在。通常，这更可能适用于广义和元编程。您可能根本不需要创建这些类的任何对象，但是出于某些原因，可能需要类本身。是的，您永远不会知道在此基础上可以提出什么有用的解决方案……使用了原始的CRTP！而且它甚至没有在任何地方使用，而是在标准库中使用！谁不相信或不记得，google std :: en_shared_from_this。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
返回带有Windows的原始任务...尤其是现在，</font><font style="vertical-align: inherit;">三年后</font><font style="vertical-align: inherit;">清醒</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而没有草丛的</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回望...即使我们抛弃了我已经接触过一百万遍的平庸话题这一事实，对于任何人来说，长期以来它都没有兴趣，因为</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上男生</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">普通人有</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MFC</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qt，我只是确保将某些功能对象传递给window类。</font><font style="vertical-align: inherit;">确保它在继承链中的转移并不难，但是它将简单，清晰，无失真地完成所有工作，并且您将获得一个完全正常的可预测类，没有任何副作用，您可以陪伴并发展到任何人。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文中发生的事情只是一个有趣的重要任务，我仍然设法解决了。</font><font style="vertical-align: inherit;">我希望这对您也很有趣。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN507114/index.html">Ode Excel：34年的魔法</a></li>
<li><a href="../zh-CN507116/index.html">“ Udalenka”。昨天办公室开发人员的笔记。第2部分</a></li>
<li><a href="../zh-CN507124/index.html">PDB不仅是宝贵的皮草</a></li>
<li><a href="../zh-CN507132/index.html">弗拉基米尔·基托夫（Vladimir Kitov）：“无法理解开创性科学家如何预见1950年代的通用计算机化！”</a></li>
<li><a href="../zh-CN507138/index.html">21世纪地质学作为地球数据科学</a></li>
<li><a href="../zh-CN507148/index.html">使用Node.js发送魔术链接</a></li>
<li><a href="../zh-CN507150/index.html">我们用JavaScript绘制干涉图</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>