<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💠 👨🏽‍🚒 👶🏽 Lineare Multithread-Liste: Elementexistenzproblem, Produktivitätsverbesserung und STL-Beziehung 🤰🏽 🐆 👩🏻‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, liebe Besucher von Habr! 
 
 Dieser Artikel konzentriert sich auf eine verknüpfte Liste, Multithreading und C ++. Ich stelle sofort fest, dass ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Lineare Multithread-Liste: Elementexistenzproblem, Produktivitätsverbesserung und STL-Beziehung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506716/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo, liebe Besucher von Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel konzentriert sich auf eine verknüpfte Liste, Multithreading und C ++. Ich stelle sofort fest, dass es jede Möglichkeit gab, diese Arbeit ins Regal zu stellen und in einer kleinen Anzahl persönlicher Projekte zu verwenden. Stattdessen habe ich mich immer noch entschlossen, es vor Gericht zu stellen - plötzlich scheint es jemandem wirklich nützlich oder interessant zu sein. Wenn sich herausstellt, dass es jemandem bereits gelungen ist, so etwas zu tun, geben Sie mir diese Materialien bitte. Unabhängig davon, wie ich versucht habe, zu diesem Thema zu googeln, waren alle Versuche erfolglos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich stelle auch fest, dass es nicht um die klassische verknüpfte Liste geht, sondern um mein kreatives Überdenken der Verwendung dieser Datenstruktur in einer Multithread-Umgebung. Ich dachte über ein Szenario eines ungeordneten intensiven Zugriffs auf Multithread-Listen nach. Dies bedeutet, dass jeder Thread jederzeit, unabhängig von anderen, auf die Liste zugreifen und die erforderlichen Vorgänge ausführen kann. Wenn er nur Elemente hinzufügt oder ändert, ist das nicht so schlimm. Wenn er auch die Elemente entfernt, können verschiedene interessante Merkmale auftreten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Projekt, an dem ich als Hobby und Selbstentwicklung beteiligt war, dauerte aus mehreren Gründen sehr lange. </font><font style="vertical-align: inherit;">Während ich daran arbeitete, studierte ich außerdem intensiv: Das Projekt begann ohne das Wissen und Verständnis von STL und wurde entsprechend entworfen, wobei nur die internen Mittel der C ++ - Sprache selbst verwendet wurden. </font><font style="vertical-align: inherit;">Dann habe ich es jedoch sehr ernsthaft unter Berücksichtigung von STL und sogar unter STL modifiziert. </font><font style="vertical-align: inherit;">Was ich daraus gemacht habe, beurteilen Sie, liebe Leser.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das hier beschriebene Material vollständig zu verstehen, müssen Sie die folgenden Bücher lesen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexandrescu A. - "Modernes Design in C ++".</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richter D., Nazar K. - „Windows über C / C ++, Visual C ++ Programmierung“.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josattis N. - “C ++ Standard Library. </font><font style="vertical-align: inherit;">Referenzhandbuch. </font><font style="vertical-align: inherit;">Second Edition ”oder ein ähnliches Buch über STL.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeilenliste</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine lineare Liste ist eine bekannte Datenstruktur, die seit der Zeit der C-Sprache und früher verwendet wurde. Sein Element ist ein bestimmtes Objekt im Speicher, das Verbindungen zu einem oder zwei benachbarten ähnlichen Elementen hat - hier ein Beispiel für eine doppelt verknüpfte Liste:</font></font><br>
<br>
<pre><code class="plaintext hljs">struct ListItem<font></font>
{<font></font>
    &lt;…   …&gt;<font></font>
    List *pNext;<font></font>
    List *pPrev;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dementsprechend ist die Liste selbst ein bestimmtes (Unter-) Programm, das Manipulationen mit diesen Elementen durchführt. </font><font style="vertical-align: inherit;">In der Regel ist ein Zeiger auf den Anfang und optional auf das Ende der Liste bekannt: Dies reicht aus, um vom ersten Element an alle seine Elemente bis zum Ende durchzugehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich beschreibe ich bereits gut studierte und bekannte Informationen: Es war ein Bildungsprogramm für diejenigen, die überhaupt nicht auf dem neuesten Stand waren. </font><font style="vertical-align: inherit;">Für Details können Sie sich beispielsweise hier wenden: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lineare Liste (Wikipedia)</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Die STL-Bibliothek verfügt über einen so wunderbaren Container std :: list (doppelt verknüpfte Liste) sowie über die Twin-std :: forward_list (einfach verknüpfte Liste). </font><font style="vertical-align: inherit;">Das heißt, wenn Sie nicht daran interessiert sind, wie die Liste organisiert ist und funktioniert, und Sie sie nur für Ihre Aufgaben verwenden möchten, sind die vorgeschlagenen Container Ihre Option.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber es gibt eine Sache, aber ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multithreading-Probleme</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wiederhole, als ich anfing, dieses Thema zu analysieren, wollte ich alles tun und mich nur auf interne C ++ - Tools ohne STL-Unterstützung verlassen. </font><font style="vertical-align: inherit;">Der Wert dessen, was passieren würde, wäre niedriger, wenn ich mich noch dazu entschließen würde, hier darüber zu sprechen. </font><font style="vertical-align: inherit;">Andererseits war ich völlig frei von jeglichen Konzepten oder Einschränkungen der Bibliothek und war daher an nichts gebunden und suchte nach offenen und unabhängigen Ansätzen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuvor war in der fernen Vergangenheit die überwiegende Mehrheit der Computer Single-Core- und Single-Prozessor-Computer. Die lineare Liste war eine relativ einfache und transparente Datenstruktur, und die Arbeit damit verursachte keine besonderen Schwierigkeiten. Jetzt sind sogar Smartphones zu Multi-Core-Smartphones geworden. Unter Multithreading-Bedingungen ist selbst eine so einfache Struktur wie eine verknüpfte Liste sehr kompliziert. Das Sicherstellen des korrekten Betriebs im Multithread-Modus erschwert im Allgemeinen jedes Programm erheblich. Dies ist eine bekannte Tatsache.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen Sie ein abstraktes Szenario intensiver Arbeit mit einer Liste verschiedener Threads: Jeder von ihnen kann zu einem völlig beliebigen Zeitpunkt Elemente hinzufügen, löschen, ändern usw. Einerseits sollte die Arbeit mit der Liste in diesem Fall zunächst sicher sein: Wenn Datenverletzungen und undefiniertes Verhalten des Programms vorliegen, ist dies eine völlig unangemessene Lösung. Andererseits würde ich sehr gerne so schnell wie möglich mit ihm arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das erste Problem zu lösen, muss die Liste natürlich irgendwie blockiert und der Zugriff darauf synchronisiert werden. Das zweite Problem - die Leistung - wird vorerst verschoben.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel wird nur das Blockieren der gesamten Liste durch einen Stream für den exklusiven Zugriff des Streams darauf berücksichtigt. Andere Optionen schienen beispielsweise aus folgenden Gründen zweifelhaft. Angenommen, wir haben eine doppelt verknüpfte Liste und haben beschlossen, das Element daraus zu entfernen. Dazu müssen Sie den Knoten selbst sowie den vorherigen und den nächsten blockieren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Moment, vor dem Start der Operation, löscht ein anderer Thread nur beispielsweise den vorherigen Knoten. Wir blockieren das Löschen und warten nicht mehr auf die Freigabe des vorherigen Knotens, der von einem anderen Thread blockiert wurde. Und er ist blockiert, wenn er auf den nächsten wartet, d. H. unser gelöschter Knoten. Das war's, es ist eine Sackgasse. Diese Methode ist also nicht zuverlässig.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihre Threads keine Zeiger (oder Iteratoren) auf bestimmte Knoten speichern, wird die Aufgabe extrem vereinfacht. Tatsächlich können Sie nur mit STL-Tools arbeiten. Der Stream blockiert die Liste, verweist auf ein Element in ihm (z. B. von Anfang an, von Ende oder durch Suchen nach bestimmten Kriterien), verarbeitet oder entfernt dieses Element, fügt neue hinzu, ohne Links zu diesen zu speichern. und vervollständigt dann die Liste. All dies - ausschließlich den Zugriff auf die Liste in einem Thread blockieren und sie für die Dauer der erforderlichen Vorgänge besitzen. In diesem Fall ist es vollkommen logisch, die Sperrfunktionen std :: list und library zu verwenden. Bei alledem sollte beachtet werden, dass während Ihr Thread alle erforderlichen Arbeiten ausführt, andere Threads aufhören zu warten, d. H. Die Arbeit mit der Liste wird im Single-Thread-Modus ausgeführt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe ein anderes, komplexeres Szenario in Betracht gezogen, in dem ein Thread einen Zeiger oder Iterator auf das benötigte Element speichert. </font><font style="vertical-align: inherit;">Beispielsweise arbeitet Ihr Programm an einigen komplexen Berechnungen, indem es die Anfangsdaten aus dem Listenelement entnimmt und nach der Verarbeitung seinen Wert aktualisiert und dort die Berechnungsergebnisse hinzufügt. </font><font style="vertical-align: inherit;">Andere Threads haben jedoch auch Zugriff auf dieselbe Liste. </font><font style="vertical-align: inherit;">Ich habe keine Annahmen über die Art der Anwendung getroffen: Ein anderer Thread kann dieses Element aus irgendeinem Grund leicht löschen. </font><font style="vertical-align: inherit;">Oder verschieben Sie es an einen anderen Ort. </font><font style="vertical-align: inherit;">Das Arbeiten mit einer Liste wird daher nicht nur aus den üblichen Gründen des Multithreading und der Synchronisation problematisch.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem der Existenz eines Elements</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist der grundlegende Unterschied zwischen einer Liste und beispielsweise einem Array? In einer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verteilten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anordnung von Listenelementen. Alle Elemente des Arrays befinden sich in einem einzigen Speicherbereich. Selbst wenn Sie einen Zeiger auf einige seiner Elemente speichern, sind Sie sicher, dass der Zugriff auf seine Adresse korrekt ist (natürlich, wenn das Array nicht mit einer Erweiterung seiner Größe an einen anderen Speicherort verschoben wurde). Wenn der gewünschte Artikel gelöscht oder in einen anderen Thread verschoben wird, gehen Sie einfach zur vorherigen Adresse, verstehen aus irgendeinem Grund, dass der benötigte Artikel nicht hier ist, und versuchen Sie dann, danach zu suchen usw. Natürlich muss das Programm eine solche Gelegenheit im Voraus unterstützen. In jedem Fall bleibt der Betrieb jedoch korrekt, solange Sie sich in den richtigen Speichergrenzen befinden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine völlig andere Situation besteht im Fall einer Liste (sowie im Fall eines Baums, eines Graphen - einer beliebigen Datenstruktur mit verteilten Elementen). Wenn ein Element gemäß Ihrem Zeiger in einem anderen Thread gelöscht wurde, wissen Sie nicht einmal davon. Wenn Sie versuchen, auf seine Adresse zuzugreifen, erhalten Sie (bestenfalls) eine Zugriffsverletzung. Selbst wenn es nicht tatsächlich aus dem Speicher gelöscht wird (z. B. wenn intelligente Zeiger verwendet werden), wird es aus der Liste gelöscht, d. H. wird nicht Teil davon sein. Sie werden auch davon nichts wissen. Die korrekte Arbeit mit der Liste ist fehlerhaft. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gleichzeitig schafft die intensive Multithread-Arbeit mit der Liste absolut fantastische Szenarien. Sie können sogar sicher sein, dass mit Ihrem Element und einem Zeiger darauf alles in Ordnung ist - bis Sie auf eine Listenfunktion zugreifen, um damit zu arbeiten.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiel. Es sei ein Teil der Liste vorhanden, und ein Zeiger auf den Knoten, den wir als (#) bezeichnen, wird auf eine Funktionslistenmethode übertragen, während die damit verbundenen Knoten durch relative Zahlen relativ dazu gekennzeichnet werden. Zum Zeitpunkt des Aufrufs der Funktion ist bekannt, dass dieses Element vorhanden ist und der Zeiger darauf korrekt ist, dh der Status der Liste in diesem Bereich lautet: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie nun den Knoten (#) als Parameter an eine Listenfunktion übergeben werden. Diese Funktion wird wie gewohnt blockiert, während auf den Zugriff gewartet wird. Während sie wartete, arbeiteten drei Threads vor ihr und löschten den Knoten (#) zusammen mit den benachbarten, so dass es passierte: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yx/cx/x8/yxcxx8a21cbn2zlzko2uxgfzsb8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann fügten weitere 5 Threads 5 weitere Elemente in die Liste ein, beginnend mit (-2). Wir bezeichnen die neuen Elemente als (nN), wobei N die relative Zahl unter den fünf ist, beginnend bei Null:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann wird endlich unser Stream aufgerufen, der mit (#) aufgerufen wurde. Die Frage ist: Was soll er in diesem Fall tun, nachdem (#) schon lange weg ist? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antwort: Es hängt alles von der Operation sowie vom Szenario für die Verwendung der Liste ab. Da wir jedoch den allgemeinsten Fall ohne Einschränkungen betrachten, können einige allgemeine Annahmen getroffen werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn es sich um einen Löschvorgang handelt, reicht es aus, einfach zu überprüfen, ob das angegebene Element in der Liste vorhanden ist. Wenn nicht, wurde es bereits gelöscht und es muss nichts weiter getan werden. Wenn ja, dann löschen. Ähnliches gilt für das Lesen / Ändern des Inhalts des Knotens: Wenn der Knoten gelöscht wird, gibt es bereits nichts zu lesen / ändern. Die größten Probleme treten jedoch beim Einfügen eines neuen Knotens sowie beim Wechseln zum nächsten / vorherigen auf. Einerseits ist der angegebene Knoten nicht mehr vorhanden, und ein Fehler kann zurückgegeben werden. Andererseits muss der Knoten eingefügt werden, und eine solche Situation kann jederzeit auftreten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die Priorität (für den allgemeinen Fall) immer noch Sicherheit und Zuverlässigkeit und erst dann Geschwindigkeit ist, müssen Sie natürlich, wenn der Thread endlich die Betriebszeit innerhalb der Funktion erreicht hat, feststellen, ob ein Element in der Liste vorhanden ist: Existiert es überhaupt dort oder nicht bereits? Dies löst ein Problem: Zumindest werden wir nicht die gesamte Liste stören, wenn dort kein angeforderter Knoten vorhanden ist, und wir werden diesbezüglich Speicherzugriffsfehler vermeiden. Das Problem des Einfügens und der Übergänge wird jedoch nicht gelöst: Es ist nicht klar, wo ein neuer Knoten eingefügt und von einem bereits gelöschten Knoten gewechselt werden soll.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Lösung des Problems der Existenz des Elements wird nachstehend ausführlich erörtert. </font><font style="vertical-align: inherit;">Die Frage, was zu tun ist, wenn wir feststellen, dass das Element nicht mehr vorhanden ist, aber wirklich benötigt wird, geht über den Rahmen dieses Artikels hinaus, da es vollständig vom Algorithmus der Arbeit mit dem Listenprogramm abhängt. </font><font style="vertical-align: inherit;">Natürlich sollte es solche Szenarien und entsprechende Reaktionen darauf enthalten: Wenn beispielsweise kein Element vorhanden ist, gehen Sie zum Anfang der Liste oder führen Sie eine andere Operation aus. </font><font style="vertical-align: inherit;">Die Hauptsache, die in dieser Situation sichergestellt werden muss, ist der korrekte und sichere Betrieb der Liste sowie die Benachrichtigung über solche Situationen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direkte Artikelsuche</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der einfachste und einfachste Ansatz besteht darin, das Vorhandensein eines Elements in der Liste zu überprüfen, indem Sie es nacheinander auf der Suche nach einem bestimmten Element durchlaufen. Jene. Ich suche nur nach dem gegebenen Element. Wenn er auf der Liste steht, arbeiten wir mit ihm zusammen. Wenn nicht, beenden wir je nach Funktion mit Erfolg oder Misserfolg und lassen das aufrufende Programm entscheiden, was in dieser Situation zu tun ist. Die Hauptsache ist, dass die Arbeit mit der Liste auf jeden Fall korrekt ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Methode ist sicher und voll funktionsfähig, führt jedoch insbesondere bei großen Listen zu einem katastrophalen Leistungsabfall. Tatsächlich stellt sich heraus, dass die Arbeit mit der Liste Single-Threaded ist: Die Liste ist für die Dauer der Suche nach einem bestimmten Element in der Liste blockiert, und andere Threads können nicht darauf zugreifen. Zweitens steigen die Gemeinkosten stark an - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jeweils</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operationen mit der Liste müssen prüfen, ob zum Zeitpunkt der Operation ein Element erforderlich ist, und ein großer Teil der Zeit wird nicht für nützliche Arbeiten aufgewendet, sondern für die Überprüfung des Vorhandenseins eines Elements. </font><font style="vertical-align: inherit;">Trotzdem ist dieser einfache, unkomplizierte Ansatz gut geeignet für Listen mit geringem Volumen und nicht zu intensiven Operationen damit sowie als erste Annäherung an die Lösung des Problems der Existenz eines Elements. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber was ist, wenn wir eine Liste mit einer großen Anzahl von Elementen haben und sehr intensiv damit arbeiten: Fügen viele Threads ständig Elemente hinzu, ändern und löschen sie? </font><font style="vertical-align: inherit;">Gibt es eine Möglichkeit, es irgendwie zu beschleunigen?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicher oder Leistung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist bekannt, dass eine Erhöhung des vom Programm verwendeten Speichers die Geschwindigkeit des Programms erhöhen kann. Beispielsweise nutzt ein Programm die Ergebnisse einiger Berechnungen in hohem Maße. Anstatt sie erneut auszuführen, können Sie alles im Voraus berechnen und ihre Ergebnisse in einer Tabelle oder einem Array speichern. Dann greift das Programm einfach auf die gewünschte Zelle in der Tabelle zu und erhält sofort den gewünschten Wert, was seine Arbeit erheblich beschleunigt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diesen Ansatz habe ich im Fall der Liste verwendet. Erstellen Sie eine Bitmap. Wir fügen den Serviceinformationen jedes seiner Elemente zusätzlich zum obligatorischen Zeiger auf das nächste und optional das vorherige Element zwei weitere neue Felder hinzu: Das erste ist die eindeutige Nummer in dieser Liste und das zweite ist ein Zeiger auf die Liste selbst. Wenn nun ein Element erstellt wird, wird ihm eine eindeutige Nummer zugewiesen und die Einheit in der Bitmap auf den entsprechenden Index gesetzt. Wenn ein Element gelöscht wird, wird dieses Bit zurückgesetzt. Die Anzahl der erstellten Elemente nimmt jedes Mal stetig zu, wenn ein neues Element erstellt wird - bereits verwendete Null-Bits werden nicht wiederverwendet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn es nun erforderlich ist, das Vorhandensein eines bestimmten Elements zu überprüfen, anstatt es linear in der gesamten Liste zu durchsuchen, wird einfach über den Index dieses Elements auf eine Bitmap zugegriffen, und die Tatsache seines Vorhandenseins wird sofort und für eine konstante Zeit unabhängig von der Größe der Liste festgestellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Methode ermöglicht es Ihnen, maximale Leistung zu erzielen, hat jedoch ihre schwerwiegenden Nachteile. Zunächst müssen Sie Speicher für das gesamte Array auf einmal zuweisen, von dem ein Teil der Bits während des Programms möglicherweise überhaupt nicht benötigt wird. Dieser Speicher kann jedoch für andere Anforderungen verwendet werden. Dieses Problem und eine Möglichkeit, Speicherüberschreitungen auszugleichen, werden nachstehend erläutert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite Nachteil ist schwerwiegender und interessanter: Jedes neue Listenelement wird durch eine monoton ansteigende Zahl erstellt. Dies bedeutet, dass früher oder später die freien Bits des Arrays erschöpft sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An diesem Punkt müssen Sie leider anhalten, die Liste blockieren und mit dem Servieren beginnen. Jene. Komprimieren Sie die Bits dieses Arrays, indem Sie alle Nullbits aus zuvor gelöschten Listenelementen entfernen, wobei nur die Bits für die derzeit tatsächlich vorhandenen Elemente übrig bleiben, und verschieben Sie alle diese Bits an den Anfang des Arrays. Wir müssen die gesamte Liste erneut durchgehen und im Single-Thread-Modus alle Indizes für jedes Element neu schreiben. Der offensichtliche Vorteil gegenüber dem vorherigen Ansatz besteht darin, dass in diesem Fall nur </font><b><font style="vertical-align: inherit;">einer durchgeführt</font></b><font style="vertical-align: inherit;"> wird.</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeiten über einen langen Zeitraum. </font><font style="vertical-align: inherit;">Außerdem kann die Liste im extrem schnellen Modus wie zuvor weiterarbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich meine ich nicht, dass die Knoten nur zur Liste hinzugefügt wurden, weil </font><font style="vertical-align: inherit;">In diesem Fall sind alle Bits des Arrays einzeln. </font><font style="vertical-align: inherit;">Ich denke an ein Szenario, in dem Elemente intensiv und willkürlich gelöscht und hinzugefügt werden. </font><font style="vertical-align: inherit;">Jene. </font><font style="vertical-align: inherit;">Die Gesamtzahl der Listenelemente seit Beginn ihrer Arbeit kann sich geringfügig ändern. </font><font style="vertical-align: inherit;">Natürlich hängt die Frage der Auswahl der Größe des Arrays von der Art des Programms ab. </font><font style="vertical-align: inherit;">Sie können auch jederzeit ein neues Array mit einem größeren Volume erstellen, wenn die Größe des aktuellen Volumes nicht ausreicht.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden von Nullbits aus zuvor gelöschten Elementen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können dies auch auf andere Weise tun: Suchen Sie beim Erstellen eines Elements nach dem ersten Nullbit am Anfang der Bitmap. Dies optimiert den Speicherverbrauch, führt jedoch zu einem Leistungsabfall: Jedes Mal, wenn Sie ein neues Element erstellen, müssen Sie zusätzliche Arbeit leisten - durchsuchen Sie das Array nach einem freien Bit. Im Vergleich zur Überprüfung des Vorhandenseins eines Elements durch direktes Anzeigen der Liste ist der Gewinn jedoch offensichtlich: Wir werden uns das </font><b><font style="vertical-align: inherit;">Array</font></b><font style="vertical-align: inherit;"> ansehen</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benachbarte Elemente, und jedes Element eines solchen Arrays enthält viele Bits, d.h. </font><font style="vertical-align: inherit;">Wir verarbeiten viele Listenknoten gleichzeitig (64 Bit für moderne Systeme oder sogar 128/256/512 bei Verwendung von SSE / AVX). </font><font style="vertical-align: inherit;">Wir suchen nach dem ersten Wort, das nicht mit allen Einheitsbits gleich dem Wort ist, dann suchen wir nach dem ersten Nullbit in diesem Wort. </font><font style="vertical-align: inherit;">Tatsächlich hat diese Methode eine mittlere Geschwindigkeit zwischen der vorherigen und der direkten Betrachtungsmethode.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherverbrauchsoptimierung für nicht belegte Array-Bits</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir gehen von einer langen und intensiven Arbeit mit der Liste aus und weisen ihr eine große Anzahl von Bits zu. Es kam jedoch vor, dass das Programm tatsächlich anders funktionierte: Es griff selten auf die Liste zu und führte andere Operationen aus, die ebenfalls Speicher benötigten. Infolgedessen erhalten wir in anderen Teilen des Programms ein fast unbenutztes Array von Bits mit großen Volumen- und Speicherproblemen. Bloße Unannehmlichkeiten! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soweit ich das beurteilen kann, löst Linux dieses Problem automatisch (obwohl erfahrene Linux-Entwickler es mir erlauben, es zu beheben, wenn dies der Fall ist). Sie weisen dem Array Speicher zu, aber tatsächlich </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">überträgt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das System diesen Speicher erst dann auf das Array, </font><font style="vertical-align: inherit;">wenn er wirklich benötigt wird. Es gibt eine Optimierung der Speichernutzung. Windows erlaubt dies nicht. Vielmehr erlaubt es, aber Sie müssen es selbst tun.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für diejenigen, die überhaupt nicht auf dem neuesten Stand sind, erkläre ich: Ihre Anwendung (genauer gesagt der entsprechende Prozess) weist dem System einen </font><font style="vertical-align: inherit;">großen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtuellen Adressraum zu</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - bis zu 8 TB für 64-Bit-Windows. Der physische Speicher im System kann viel geringer sein - derzeit 8 oder 16 GB für Massencomputer. Betriebssystem - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Displays</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adressen Ihres virtuellen Prozessraums an Adressen des physischen Speichers, und zwar auf transparente Weise ohne Ihre direkte Beteiligung. Natürlich ist der größte Teil des freien virtuellen Speichers eines Prozesses normalerweise nicht belegt. Wenn Sie Windows auffordern, Speicher auf herkömmliche Weise zuzuweisen, wird dieser Speicher gleichzeitig sowohl in Ihrem virtuellen Raum als auch im physischen Speicher zugewiesen. Wenn Sie eine Bitmap mit großem Volumen zuweisen, besteht die Gefahr, dass Sie sofort den gesamten verfügbaren Speicher Ihres Computers belegen, ohne zu gewährleisten, dass dieser Speicher überhaupt benötigt wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Man kann jedoch anders vorgehen: Markieren Sie einen großen Teil des Speichers im virtuellen Raum des Prozesses, übertragen Sie ihn jedoch nur dann physisch, wenn er wirklich benötigt wird. </font><font style="vertical-align: inherit;">Dies kann durch strukturelle Ausnahmebehandlung in Windows erfolgen. Einzelheiten finden Sie im Buch von Richter D., Nazar K. - „Windows über C / C ++, Visual C ++ - Programmierung“.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies wäre nur eine Idee und eine Theorie, wenn ich nicht alle diese Ideen in die Praxis umgesetzt hätte und nicht in Form eines einfachen experimentellen Programms: Ich habe es so sorgfältig wie möglich für die Produktion gemacht und beabsichtigt, es in meinen realen Projekten zu verwenden, daher brauchen Sie es in dieser Form und stell dir vor. </font><font style="vertical-align: inherit;">Ich dachte, es wäre unfair und zu egoistisch, das anzuwenden, was in meiner begrenzten Anzahl von Projekten getan wurde, wenn dies für einen breiten Kreis von Entwicklern nützlich oder zumindest nur interessant sein könnte. </font><font style="vertical-align: inherit;">Auf der anderen Seite bieten die Schöpfer der Boost-Bibliothek und anderer spezialisierter Bibliotheken ihre Arbeit jedem absolut kostenlos an. </font><font style="vertical-align: inherit;">Warum kann ich das nicht auch tun?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstraktion - eine Liste ohne Daten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe die Liste in zwei logische Ebenen unterteilt. Die erste Ebene ist eine Liste, von der jedes Element keine nützlichen Daten enthält, sondern nur Zusatzinformationen: Zeiger auf benachbarte Elemente und optional diese beiden zusätzlichen Felder, um die Überprüfung auf das Vorhandensein eines Elements in der Liste zu beschleunigen. Bereits auf dieser Ebene können jedoch alle grundlegenden Vorgänge für eine Liste ausgeführt werden: Hinzufügen und Löschen von Elementen, Aufteilen und Zusammenführen von Listen usw. Tatsächlich habe ich mich hauptsächlich auf diese Ebene konzentriert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite Ebene besteht darin, dem Listenelement tatsächliche Daten hinzuzufügen und der Liste neue Vorgänge hinzuzufügen, um mit diesen Daten zu arbeiten. All dies wird in C ++ durch Vererbung bereitgestellt. Aber die Details werden unten diskutiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine solche Aufteilung der Implementierung in zwei Ebenen war sinnvoll: Warum sollte die Verfügbarkeit bestimmter Daten berücksichtigt werden, wenn eine Reihe von Vorgängen völlig unabhängig von diesen Daten sind? Für bestimmte Listenelemente müssen Sie diese noch löschen und neue zur Liste hinzufügen sowie andere typische Vorgänge ausführen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich begann mit einem äußerst einfachen und unkomplizierten Konzept, das der C-Sprachkonstruktion am Anfang des Artikels entnommen wurde. Sowohl interne C- als auch C ++ - Zeiger werden sowohl innerhalb als auch außerhalb der Liste verwendet. Der einzige Unterschied bestand darin, dass das Hinzufügen von Daten, wie oben angegeben, auf einen späteren Zeitpunkt verschoben wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es soll ein Element der Liste ohne Daten geben, das nur einen Zeiger (oder Zeiger) auf die benachbarten Elemente enthält. Dann kann der entsprechende Code dafür wie folgt schematisch dargestellt werden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span>	<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListElement_OneLinked</span>			//   ( )
{</span>
	ListElement_OneLinked *pNext;	<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>		// 
{</span>
	<span class="hljs-comment">//</span><font></font>
<font></font>
        <span class="hljs-comment">//   </span>
	ListElement *pFirst = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span>
	ListElement *pLast = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span><font></font>
<font></font>
	SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//    </span><font></font>
<font></font>
	&lt;…m- () &gt;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Element für eine einfach verknüpfte Liste enthält in sich einen Zeiger auf das nächste Element und nichts weiter. Die Listenklasse wird durch den Typ dieses Elements parametrisiert, was bedeutet, dass dieser Typ beim Hinzufügen von Daten geändert wird. Es enthält Zeiger auf das erste und das letzte Element im Inneren. Da ich dieses Projekt ursprünglich nur für Windows ins Visier genommen habe, ist auch ein kritischer Abschnitt wie SRWLock enthalten, um die Liste zu blockieren. Als nächstes werden die Konstruktoren, der Destruktor sowie alle notwendigen Funktionen zum Arbeiten mit der Liste definiert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Implementierung enthält zwei Probleme gleichzeitig. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste ist der offene Zugriff auf den Inhalt der Dienstinformationen des Elements. Dies bedeutet, dass nach dem Zugriff auf einen Knoten, d.h. Mit einem Zeiger auf diesen Knoten können wir direkt auf das nächste oder vorherige Element verweisen.</font></font><br>
<br>
<i>       <b></b>.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist hauptsächlich deshalb nicht akzeptabel, weil dieser Übergang die Sperre umgeht und daher die Liste schützt. Angenommen, wir haben einen Zeiger auf ein pCurr-Element und haben den Wert im pNext-Zeiger wie folgt relativ zum nächsten Element gespeichert: pNext = pCurr-&gt; pNext. Danach führen wir eine längere Operation an diesem pCurr-Knoten durch. Gleichzeitig haben andere Threads die folgenden Listenelemente in Bezug auf pCurr entfernt. Nach Beendigung der Arbeit mit pCurr wechselt der aktuelle Thread mit dem im lokalen pNext gespeicherten alten Wert zum nächsten Element und erhält einen Zugriffsfehler oder ein undefiniertes Verhalten, da das Element an der lokalen pNext-Adresse nicht mehr vorhanden ist und Sie auf den aktualisierten Wert pCurr-&gt; pNext zugreifen müssen. wenn das aktuelle Element bei pCurr wiederumexistiert auch noch.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus diesem Beispiel können zwei Schlussfolgerungen gezogen werden, um diese Situation zu verhindern:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wechseln Sie von außerhalb der Liste zum nächsten / vorherigen Knoten und arbeiten Sie im Allgemeinen nur mit Listenelementen über die Funktionen (Methoden) der Listenklasse, die die Liste sperren und den Zugriff auf die Liste sicher machen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Greifen Sie unmittelbar vor dem Zugriff so schnell wie möglich auf die Elemente zu (z. B. erhalten Sie einen Zeiger auf das nächste Element pNext = list.GetNext (pCurr) nicht im Voraus, sondern unmittelbar bevor die Notwendigkeit zum nächsten Knoten angezeigt wird).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Schlussfolgerung aus dem ersten Absatz umzusetzen, sollte daher der Zugriff auf Zeiger auf benachbarte Elemente von außen verboten werden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement_OneLinked *pNext;		<span class="hljs-comment">//    	</span><font></font>
<font></font>
<span class="hljs-keyword">friend</span> List_OneLinked;    <span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite Problem ist etwas heikler. Um dies zu verstehen, sollte die Struktur der Klassen genauer beschrieben werden. Die Listenklasse ist als Vorlage definiert und funktioniert nicht mit Elementen vom Typ ListElement_OneLinked, sondern mit dem Typ ListElement, der als Vorlagenparameter übergeben wird. Dies geschieht, um neue Knoten mit Daten innerhalb der Klasse erstellen zu können. Dazu müssen Sie den genauen Typ des zu erstellenden Knotens kennen. Der genaue Typ des Listenknotens ist noch nicht bekannt: Er wird später zusammen mit den Daten ermittelt. Die Elementerstellungsfunktion reserviert Speicher dafür, initialisiert Zeiger und gibt dann einen Zeiger auf das erstellte Element in der aufrufenden Funktion zurück. In der aufrufenden Funktion der abgeleiteten Klasse können also andere Eigenschaften des Elements initialisiert werden, die für diese Klasse spezifisch sind und später definiert werden. Mit anderen Worten,Eine genaue Definition des Typs des Listenknotens bleibt für die Zukunft erhalten. Damit die Liste ordnungsgemäß funktioniert, ist es nur wichtig, dass ihre Elemente den pNext-Zeiger enthalten, der Rest spielt bisher keine Rolle.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der Grundlage von ListElement_OneLinked wird anschließend durch Vererbung eine neue Klasse für das Element mit bestimmten Daten erstellt und über den Vorlagenparameter an die List_OneLinked-Klasse übergeben. Gleichzeitig wird basierend auf List_OneLinked eine neue abgeleitete Klasse erstellt, die Operationen mit diesen neuen Daten weiter definiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst diese Option ist jedoch nicht ganz korrekt. In früheren Versionen der Listenklasse wurde mehrmals eine explizite Konvertierungsoperation vom Typ reinterpret_cast &lt;ListElement *&gt; (...) verwendet. Tatsache ist, dass die Vorlagenklasse mit dem ListElement-Vorlagenparametertyp arbeitet, der von ListElement_OneLinked / ListElement_TwoLinked abgeleitet ist. Und in Klassenfunktionen werden Variablen in Ausdrücken vom Typ erstellt: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ListElement * pNext = pCurr-&gt; pNext;</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und pCurr-&gt; pNext hier ist ein Zeiger auf ListElement_OneLinked / ListElement_TwoLinked als Mitglieder der Basisklassen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ausgabe: Deklarieren Sie entweder eine Variable, die den expliziten Basistyp ListElement_OneLinked / ListElement_TwoLinked angibt, oder wandeln Sie sie explizit in den abgeleiteten Typ um. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich ist sogar eine explizite Definition des Basistyps nicht korrekt, z. B. in der Funktion zum Löschen (Bereinigen) von Listen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   </span><font></font>
ListElement *pCurr = pFirst;<font></font>
ListElement *pNext = <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
{<font></font>
	pNext = <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr-&gt;pNext);
	<span class="hljs-keyword">delete</span> pCurr;<font></font>
	pCurr = pNext;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie den Zeigertyp ändern:</font></font><br>
<br>
<pre><code class="cpp hljs">ListElement_OneLinked *pCurr = pFirst;<font></font>
ListElement_OneLinked *pNext = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass sie von der Operation gelöscht werden</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> pCurr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nur die Basisteile jedes Knotens in der Liste, was falsch ist. </font><font style="vertical-align: inherit;">Optional muss der pCurr-Zeiger in seinen abgeleiteten Typ konvertiert werden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher kann man die explizite reinterpret_cast-Transformation mit einer solchen Klassenstruktur auf keinen Fall loswerden, was nicht die beste Lösung ist (genauer gesagt, was wirklich schlecht ist). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus diesem Grund wurde beschlossen, die Basisklasse für das Element zu ändern, um solche expliziten Transformationen zu vermeiden (für eine doppelt verknüpfte Liste - ähnlich):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement *pNext;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">friend</span> List_OneLinked&lt;ListElement&gt;;	<span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz gesagt kann dies wie folgt beschrieben werden: Das Grundelement der Liste enthält einen Zeiger auf ein anderes Element, aber der Typ dieses Zeigers ist noch nicht bekannt, da er vom Vorlagenparameter übergeben wird (eine genaue Definition dieses Typs bleibt für die Zukunft übrig). Mit anderen Worten: Zu diesem Zeitpunkt wurde der Typ des Listenknotens (d. H. Was er am Ende sein wird) noch nicht bestimmt, er wird später bestimmt. Aber jetzt behalten wir den Zeiger auf ein Element des zukünftigen, noch nicht bekannten Typs. Der resultierende Typ des Listenknotens wird hier als Vorlagenparameter übergeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt sind keine Konvertierungen mehr erforderlich, da überall Zeiger desselben ListElement-Typs verwendet werden - sowohl in der Listenklasse als auch in der Klasse für Knoten. Das ListElement hier und in der Listenklasse ist die letzte Klasse für das Element mit bestimmten Daten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass die Listenklasse nun von ihrem spezifischen Inhalt so abstrakt wie möglich geworden ist: Es ist nur bekannt, dass ihre Knoten Zeiger auf andere solche Knoten enthalten, und unter Verwendung dieser Informationen werden alle grundlegenden Operationen an der Listenklasse mit entsprechender Multithread-Sperre ausgeführt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem der Existenz eines Elements lösen - eine einfache Suche (Version 01.03.2018)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste Version war äußerst einfach und unkompliziert und ging nicht über das oben beschriebene Framework hinaus. </font><font style="vertical-align: inherit;">Es wurden interne C ++ - Zeiger verwendet, der Speicher für Elemente wurde mit der neuen Operation zugewiesen und mit delete gelöscht. Die Liste wurde in dem darin enthaltenen kritischen Abschnitt blockiert. </font><font style="vertical-align: inherit;">Ich wusste oder ahnte nichts über die Mittel der STL-Bibliothek und auch über die Ebene, auf der sie die Programmierung in C ++ bringen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bereits zu diesem Zeitpunkt stieß ich in der Praxis auf das Problem der Existenz eines zuvor beschriebenen Elements und stellte fest, dass das einfache Sperren der Liste nicht ausreicht. </font><font style="vertical-align: inherit;">Ich habe die Liste mit den entsprechenden Funktionen mit allen Vorsichtsmaßnahmen durchsucht, die Liste wurde korrekt blockiert, aber das Programm stürzte in verschiedenen Intervallen immer noch erfolgreich ab. </font><font style="vertical-align: inherit;">Damals fand ich heraus, dass das Vorhandensein eines Elements überprüft werden musste, was zu einer Änderung der Logik der Schlüsselfunktionen führte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie mich ein Beispiel für die Funktion des Hinzufügens eines Elements nach einem bestimmten geben:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">ListElement* <span class="hljs-title">AddAfter</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-title">throw</span> <span class="hljs-params">(FailElemCreation, Nullptr, NotPartOfList)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();			<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListExclusive();<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (!FindElement(pElem, <span class="hljs-literal">true</span>))<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
	}<font></font>
<font></font>
	ListElement *pCurr = <span class="hljs-keyword">new</span> ListElement;
	<span class="hljs-keyword">if</span> (!pCurr)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> FailElemCreation();		<span class="hljs-comment">//        </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (pFirst == <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		pFirst = pLast = pCurr;<font></font>
		pCurr-&gt;pNext = <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
	<span class="hljs-keyword">else</span><font></font>
	{<font></font>
		<span class="hljs-comment">//         </span><font></font>
		ListElement *pNext = pElem-&gt;pNext;<font></font>
		pElem-&gt;pNext = pCurr;<font></font>
		pCurr-&gt;pNext = pNext;<font></font>
		<span class="hljs-comment">//,     </span>
		<span class="hljs-keyword">if</span> (pElem == pLast)<font></font>
			pLast = pCurr;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListExclusive();<font></font>
<font></font>
	<span class="hljs-keyword">return</span> pCurr;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist ersichtlich, dass vor dem Erstellen eines neuen Elements durch Aufrufen der Funktion FindElement (...) überprüft wird, ob das angegebene Element in der Liste vorhanden ist:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FindElement</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-title">throw</span> <span class="hljs-params">(Nullptr)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();	<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span><font></font>
	ListElement *pCurr = pFirst;<font></font>
	<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (pCurr == pElem)<font></font>
		{<font></font>
			bResult = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">break</span>;<font></font>
		}<font></font>
		pCurr = pCurr-&gt;pNext;<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">return</span> bResult;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Komplikation von Multithread-Listenklassen - Strategieklassen (Version 18.02.2019, 11.27.2019)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Projekt richtete sich zunächst ausschließlich an Windows. Aber irgendwann dachte ich mir, warum nicht mehr Flexibilität hinzufügen? Warum nur Fenster? Immerhin wurde die Liste im Wesentlichen in reinem C ++ implementiert, unter Windows hatte sie nur eines: den kritischen Abschnitt von SRWLock. Zu diesem Zeitpunkt war ich bereits mit dem Konzept der Strategieklassen vertraut. Sie können dies ausführlich im Buch Alexandrescu A. - "Modernes Design in C ++" lesen. Es beschreibt viele ungewöhnliche und erstaunliche Dinge, die auch jetzt noch nützlich sein können, obwohl das Buch bereits 12 Jahre alt ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine davon sind die Klassen von Strategien. Klassen von Strategien sind in der Tat Änderungen im Verhalten einer Klasse durch Vorlagen, wie B. Straustrup in seinem berühmten Buch erwähnte. Nur im Buch Alexandrescu ist dieses Thema weit verbreitet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, Ihre Klasse führt eine bestimmte Aktion aus. </font><font style="vertical-align: inherit;">Sie können die Definition dieser Aktion außerhalb der Klasse übernehmen, basierend auf dieser Aktion eine separate Klasse erstellen und diese als Vorlagenparameter an Ihre Quellklasse übergeben. </font><font style="vertical-align: inherit;">Dies erschwert den Code, das Lesen und Verstehen, erhöht jedoch die Flexibilität Ihrer Klasse erheblich: Um diese bestimmte Aktion durch eine andere, ähnliche zu ersetzen, müssen Sie lediglich eine andere ähnliche Strategie schreiben und sie als Vorlagenparameter an Ihre Klasse übergeben. </font><font style="vertical-align: inherit;">Der Rest der Arbeit wird vom Compiler erledigt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strategie sperren</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich dies auf die beschriebene Liste angewendet hatte, nahm ich die Sperre durch SRWLock in eine separate Strategie und schrieb dann mehrere andere Strategien: durch den üblichen kritischen Abschnitt von Windows, durch C ++ STL-Mutexe usw. </font><font style="vertical-align: inherit;">Dann können rein Linux-spezifische Methoden hinzugefügt werden. </font><font style="vertical-align: inherit;">Somit ist die Klasse nicht nur für Windows geeignet, sondern ich kann sie immer sehr schnell und optimal für Windows neu konfigurieren, indem ich einfach die gewünschte Strategie spezifiziere.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//    SRWLock</span>
<span class="hljs-comment">//     SRWLock -   ,      (      </span>
<span class="hljs-comment">//   : ++11)</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLockingWin_SRWLock</span>			//    <span class="hljs-title">SRWLock</span>
{</span>
	<span class="hljs-keyword">mutable</span> SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//     SRWLock</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ThreadLockingWin_SRWLock(<span class="hljs-keyword">bool</span> bInitialize = <span class="hljs-literal">true</span>)<font></font>
	{<font></font>
		<span class="hljs-comment">//; bInitialize -  ,     </span>
		<span class="hljs-keyword">if</span>(bInitialize)<font></font>
			InitializeSRWLock(&amp;csSRW);		<span class="hljs-comment">//   SRWLock</span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>						<span class="hljs-comment">//  </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//  </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherstrategie</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diesen Punkt herum begann ich auch ernsthaft, STL zu studieren, und als eines der ersten Werkzeuge dieser Bibliothek lernte ich intelligente Zeiger kennen. </font><font style="vertical-align: inherit;">Und dann dachte ich: Warum kann ich meiner Liste keine Unterstützung für intelligente Zeiger hinzufügen? </font><font style="vertical-align: inherit;">Dann nahm ich den Zeigertyp heraus und erstellte und löschte die Daten des Listenelements in einer separaten Strategie:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        C/++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>   <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type[]&gt;   //   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type[size];
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>	  <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span> ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span>[] ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = Type * ;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;			<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = ptrType;		<span class="hljs-comment">//   </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-comment">// : Args - -     Type</span>
		<span class="hljs-comment">// :      Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//   ,       </span>
		<span class="hljs-comment">// : pObject -      , DeleterFunc -   -</span><font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pObject)<font></font>
		{<font></font>
			Deleter::Delete(pObject);		<span class="hljs-comment">//     </span>
			pObject = <span class="hljs-literal">nullptr</span>;<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> &amp;obj;<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine ähnliche Strategie für intelligente Zeiger:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        shared_ptr/weak_ptr ++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type&gt;(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type[]&gt;(size);
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;					<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;						<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;				<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = <span class="hljs-built_in">std</span>::weak_ptr&lt;Type&gt;;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      ;   -  ,    ,    </span>
		<span class="hljs-comment">// </span>
		Deleter::Delete(pObject);	<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;(&amp;obj);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Speicherstrategie verwendet drei Parameter: den Typ des Type-Objekts sowie einen Speicherzuweiser und -entferner. Basierend auf dem Objekttyp erstellt die Strategie einen Zeigertyp auf diesen Typ - je nach Strategie entweder Typ * oder std :: shared_ptr - und bietet auch die entsprechenden Funktionen zum Erstellen und Löschen des Objekts. Wenn wir standardmäßig von Verteilern und Löschern sprechen, erstellen diese Funktionen ein Objekt entweder über die neue Type-Operation oder über die Funktion std :: make_shared (...). All dies funktioniert aufgrund der Tatsache, dass die Zeiger-Dereferenzierung sowohl für den in C ++ integrierten Zeiger als auch für den intelligenten std :: shared_ptr gleich ist. Natürlich wird im Fall einer doppelt verknüpften Liste und intelligenter Zeiger std :: schwach_ptr für Zeiger auf das vorherige Element verwendet, um die unangenehme Funktion von Schleifenzeigern zu vermeiden.Zum Zeitpunkt der Kompilierung einer doppelt verknüpften Liste können Sie abhängig von der ausgewählten Speicherstrategie festlegen, wie diese dereferenziert werden soll (dies ist eine neue Funktion von C ++ 17):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  pPrev  weak_ptr,          shared_ptr    lock()</span>
<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, SmartSharedPointer&lt;ListElement&gt;&gt;)</span>		<span class="hljs-comment">//C++17: if constexpr</span>
	pFirst-&gt;pPrev.<span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>= <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">else</span>
	pFirst-&gt;pPrev = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit erstellt die Liste jetzt keine eigenen Elemente: Sie leitet den Aufruf an die entsprechende Strategie weiter.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikelverfügbarkeitsstrategie</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich habe ich eine Lösung für das Problem der Existenz eines Elements in einer separaten Strategie gefunden: Wenn die Liste das Vorhandensein einiger ihrer Elemente überprüfen muss, leitet sie den Aufruf einfach an die entsprechende Strategie weiter. Der allererste, unkomplizierte und ungeschickte Ansatz wurde zu einer DirectSearch-Direktsuchstrategie. Als nächstes entwickelte ich zwei weitere Strategien basierend auf den beiden zuvor beschriebenen Ansätzen mit einer Bitmap in der Reihenfolge ihrer Beschreibung: SearchByIndex_BitArray und SearchByIndex_BitArray2. Für Windows fügte er zwei weitere Strategien hinzu, um den Speicher während des Füllens schrittweise mit einer Bitmap zu </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
belegen </font><font style="vertical-align: inherit;">: </font><font style="vertical-align: inherit;">SearchByIndex_BitArray_MemoryOnRequestLocal und SearchByIndex_BitArray2_MemoryOnRequestLocal.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erwähnt, muss das Listenelement einen Index in einer Bitmap und einen Zeiger auf die Basisklasse der Liste enthalten (siehe unten), damit diese erweiterten Strategien funktionieren. </font><font style="vertical-align: inherit;">wurde wie folgt definiert:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//          </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked_CP</span>			//   ( )
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext;	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex;	<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt; *pList;		<span class="hljs-comment">//  - </span><font></font>
<font></font>
	<span class="hljs-comment">//          ;    ,   </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span><font></font>
<font></font>
	<span class="hljs-comment">//    "+" </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt; <span class="hljs-title">operator</span>+&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;(<span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;, <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;) <span class="hljs-title">noexcept</span>;</span>	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-comment">//        </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">DirectSearch</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray2</span>;</span>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Korrelation zwischen Speicherstrategien und Elementprüfstrategien</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei einer eingehenden Untersuchung stellte sich heraus, dass die Beziehung zwischen Speicherstrategien und Strategien zur Überprüfung des Vorhandenseins eines Elements eine Falle darstellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, Sie verwenden intelligente Zeiger als Speicherstrategie sowie eine Strategie, die eine Bitmap verwendet, um schnell nach einem Element in einer Liste zu suchen. Wenn Sie ein Element löschen, setzt die Speicherstrategie den Zeiger zurück. Dieses Element wird jedoch nicht tatsächlich aus dem Speicher gelöscht, da Sie in Ihrem aufrufenden Programm einen weiteren intelligenten Zeiger darauf haben. In Zukunft wenden Sie sich mit diesem Element an die Liste, und die Prüfung wird korrekt durchgeführt, wobei auf die Daten verwiesen wird - den Index in der Bitmap und den Zeiger auf die Liste. Ein Element wird tatsächlich nur dann aus dem Speicher gelöscht, wenn keine Verknüpfung mehr besteht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist bei Verwendung von integrierten C ++ - Zeigern nicht der Fall. In diesem Fall </font><font style="vertical-align: inherit;">löscht </font><font style="vertical-align: inherit;">die Speicherstrategie </font><font style="vertical-align: inherit;">dieses Element mithilfe des Löschvorgangs </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tatsächlich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus dem Speicher. In Zukunft verweisen Sie wie im vorherigen Fall mit diesem Element auf die Liste und versuchen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unter dieser Adresse </font><b><font style="vertical-align: inherit;">auf</font></b><font style="vertical-align: inherit;"> das Element </font><b><font style="vertical-align: inherit;">zuzugreifen</font></b><font style="vertical-align: inherit;"> , um den Index der Bitmap und einen Zeiger auf die Liste zu lesen. Dies ist jedoch nicht möglich: Ein Element wurde bereits aus dem Speicher gelöscht! Im besten Fall erhalten Sie eine Zugriffsverletzung, im schlimmsten, undefinierten Verhalten, wenn die C ++ - Bibliothek, die Laufzeitbibliothek oder nur das Betriebssystem dort einen völlig willkürlichen Wert schreibt, den die Liste berücksichtigt, und versucht, daraus das Vorhandensein eines Elements in der Liste festzustellen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich also heraus, dass die internen Zeiger nur mit der DirectSearch-Direktprüfstrategie kompatibel sind und intelligente Zeiger in diesem Fall nicht nur ihre inhärente Sicherheit, sondern auch eine Leistungssteigerung bieten: Nur mit ihrer Verwendung können Bit-Arrays verwendet werden, die die Arbeit der Liste in erheblich verbessern Multithread-Modus! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um Konsistenz zu gewährleisten und inkompatible Strategiekonfigurationen zu beseitigen, habe ich in jede Listenklasse die folgende Prüfung aufgenommen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,    ++ (Type *)          (DirectSearch)</span>
<span class="hljs-keyword">static_assert</span>(!(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, InternalPointer&lt;ListElement&gt;&gt; == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElement, <span class="hljs-literal">false</span>&gt;, DirectSearch&lt;ListElement, <span class="hljs-literal">false</span>&gt;&gt; == <span class="hljs-literal">false</span>), <span class="hljs-string">"Internal C++ pointer memory policy can be used only with DirectSearch policy."</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es vergleicht die an die Liste übergebenen Strategieklassen und stoppt die Kompilierung mit der entsprechenden Ausgabe der Fehlermeldung, wenn sie nicht kompatibel sind.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmen oder Fehlerrückgaben</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Listenfehlerbehandlung wurde zunächst nur durch Ausnahmen durchgeführt. </font><font style="vertical-align: inherit;">Aber irgendwie habe ich in einem Forum, an das ich mich nicht erinnere, gelesen, dass Ausnahmen das Programm verlangsamen, und für maximale Leistung sollten Sie die herkömmliche Fehlerrückgabe verwenden. </font><font style="vertical-align: inherit;">Dazu erstellte er zwei neue Klassen, die auf den ursprünglichen Klassen basierten, und schrieb sie nur neu, um Fehler zurückzugeben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basisklasse auflisten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Implementierung der oben genannten Strategien zur Überprüfung des Vorhandenseins von Elementen hat ein wichtiges Problem aufgedeckt. Wie wir uns erinnern, enthält das Listenelement neben der in dieser Liste eindeutigen Nummer auch einen Zeiger auf diese Liste: Schließlich können wir zwei oder mehr Listen im Programm haben, von denen jede ein eigenes Bit-Array von Flags für das Vorhandensein des Elements enthält. Wie kann sichergestellt werden, dass dieses Element zu dieser bestimmten Liste gehört und nicht zu einer anderen? Nur durch Speichern eines Zeigers auf die gesamte Liste in jedem Element. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem ist, dass wir jetzt durch Hinzufügen einer Vielzahl von Strategien zu unserer Listenklasse ihren </font><b><font style="vertical-align: inherit;">Typ</font></b><font style="vertical-align: inherit;"> erheblich kompliziert haben</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Angenommen, wir haben zwei verschiedene Listen mit demselben Elementtyp und denselben Speicherstrategien, jedoch mit unterschiedlichen Strategien zum Sperren und Überprüfen des Vorhandenseins von Elementen in diesen. Für den Compiler sind dies zwei verschiedene </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arten von</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Listen. Zeiger auf welchen Typ im Element gespeichert werden soll? Darüber hinaus weiß die Klasse für das Element nicht im Voraus, welche Strategie angewendet wird, sondern muss </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alle</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berücksichtigen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie auch daran, dass sich die Blockierungsstrategie, die Strategie zum Überprüfen des Vorhandenseins eines Elements und sogar die Konnektivität (einfach verbunden oder doppelt verbunden) der Liste nur auf das Verhalten der Liste selbst beziehen, sich jedoch in keiner Weise auf die darin </font><b><font style="vertical-align: inherit;">gespeicherten Daten</font></b><font style="vertical-align: inherit;"> beziehen</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber wir als Endbenutzer dieser Klasse interessieren uns für die Daten! </font><font style="vertical-align: inherit;">Auf der einen Seite haben wir mithilfe der Klassen von Strategien mehr Flexibilität für uns selbst geschaffen und auf der anderen Seite unser Leben kompliziert und Probleme hinzugefügt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ist es möglich, die Wölfe irgendwie voll und die Schafe sicher zu machen? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kann. </font><font style="vertical-align: inherit;">Sie können Zeiger auf Daten aus einer Klasse (d. H. Aus einem Typ) einer Liste ableiten. </font><font style="vertical-align: inherit;">Zusätzlich zu den beiden Organisationsebenen der oben angegebenen Liste erschien eine weitere - Null:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListBase</span>
{</span>
	<span class="hljs-keyword">using</span> ptrListElement = <span class="hljs-keyword">typename</span> ListElement::MemoryPolicy::ptrType;		<span class="hljs-comment">//             </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:<font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	ptrListElement pFirst{ <span class="hljs-literal">nullptr</span> };<font></font>
	ptrListElement pLast{ <span class="hljs-literal">nullptr</span> };<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, weil </font><font style="vertical-align: inherit;">Echte Klassen von Listen werden von ihr geerbt. Wenn wir unabhängig von ihrem realen Typ auf die Listendaten zugreifen möchten, sollten wir auf ihre Basisklasse ListBase verweisen. </font><font style="vertical-align: inherit;">Wir erhalten Zugriff auf den Anfang und das Ende der Liste und arbeiten dann mit den Daten, wie wir möchten. </font><font style="vertical-align: inherit;">Die spezifische Art der Liste sowie die Kombination der darin verwendeten Strategien spielen keine Rolle.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iteratoren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich war bereits in vollem Gange, arbeitete eng mit STL in einem realen Projekt zusammen (nicht meines :)) und studierte es weiterhin in Büchern. Ich machte auf die Sammlung für Schleifen aufmerksam. </font><font style="vertical-align: inherit;">Schließlich ist dieser Zyklus nicht nur Teil der STL, sondern bereits ein interner Bestandteil der Sprache. </font><font style="vertical-align: inherit;">Ich dachte, ich könnte es auch in meinem Projekt unterstützen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dazu müssen Sie Unterstützung für Iteratoren hinzufügen, von der spezifischen Arbeitsweise mit Zeigern abstrahieren und durch die Liste navigieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Iterator-Beispiel:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListIterator</span>		//    
{</span>
	ptrListElement pCurrElement{ <span class="hljs-literal">nullptr</span> };					<span class="hljs-comment">// ,    </span>
	<span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//  ,    </span>
	<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>;								<span class="hljs-comment">// ,     </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListIterator() {}<font></font>
	ListIterator(ptrListElement pElem, <span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>)
		<span class="hljs-keyword">noexcept</span> : pCurrElement(pElem), pList(pList), bProtected(bProtected) {}<font></font>
	ListIterator(<span class="hljs-keyword">const</span> ListIterator&amp; li) <span class="hljs-keyword">noexcept</span> : pCurrElement(li.pCurrElement), pList(li.pList) {}<font></font>
<font></font>
	ptrListElement&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		ptrListElement&amp; pli = pCurrElement;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> pli;<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement != <span class="hljs-literal">nullptr</span>; }
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ptrListElement</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement; }<font></font>
<font></font>
	<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>++()		<span class="hljs-comment">// : ++it</span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
	}<font></font>
<font></font>
	ListIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span>								<span class="hljs-comment">// : it++</span><font></font>
	{<font></font>
		ListIterator itPrev = *<span class="hljs-keyword">this</span>;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> itPrev;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = (pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">if</span> (pList == <span class="hljs-literal">nullptr</span> || li.pList == <span class="hljs-literal">nullptr</span>)<font></font>
			bResult = !(pCurrElement == li.pCurrElement);<font></font>
		<span class="hljs-keyword">else</span><font></font>
			bResult = !(pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
};<font></font>
 ,       <span class="hljs-keyword">for</span>  ,       begin()  end():<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">begin</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">if</span>(!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span>
	<span class="hljs-function">ListIterator <span class="hljs-title">lit</span><span class="hljs-params">(ListBase&lt;ListElement&gt;::pFirst, <span class="hljs-keyword">this</span>)</span></span>;
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">return</span> lit;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">return</span> ListIterator();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ist es möglich geworden, wie folgt zu schreiben:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> List = ListData&lt;List_TwoLinked&lt;ListElement, ThreadLockingWin_SRWLock, SearchByIndex_BitArray, <span class="hljs-literal">true</span>&gt;, <span class="hljs-literal">true</span>&gt;;<font></font>
List <span class="hljs-built_in">list</span>;
<span class="hljs-keyword">try</span><font></font>
{<font></font>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; leValue : <span class="hljs-built_in">list</span>)<font></font>
          _tprintf_s(TEXT(<span class="hljs-string">"%I64u\n"</span>), leValue-&gt;u64Value);<font></font>
}<font></font>
<span class="hljs-keyword">catch</span>(…)<font></font>
{<font></font>
      …<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
leValue hat einen Zeigertyp auf ein Listenelement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anfangs habe ich die Iteratorunterstützung nur in ausnahmeunterstützte Listen aufgenommen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Grund war einfach: Da der Code in der Schleife nicht verfügbar ist, ist es nicht möglich, Fehler korrekt zu behandeln. </font><font style="vertical-align: inherit;">Sie müssen nur noch die Ausnahmen behandeln, indem Sie die Schleife in einen try-Block einschließen. </font><font style="vertical-align: inherit;">Im Allgemeinen ist es keine gute Idee, die Liste so zu durchlaufen, wenn andere Threads intensiv damit arbeiten: Es ist besser, die Liste selbst zu blockieren und sie dann im Single-Thread-Modus ruhig durchzugehen. </font><font style="vertical-align: inherit;">Wenn Sie jedoch aus irgendeinem Grund genau das Gleiche wie im obigen Beispiel tun möchten, besteht jetzt die Möglichkeit dazu.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Verallgemeinerung der Strategie zur Überprüfung des Vorhandenseins eines Elements in einem beliebigen Container; </font><font style="vertical-align: inherit;">Iteratoren für Listen ohne Ausnahmen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eigentlich hatte ich ursprünglich geplant (und plane immer noch), nicht nur eine Multithread-Liste, sondern auch einen Baum zu erstellen. Für einige ihrer Bedürfnisse. Das Diagramm ist auch möglich, aber erstens brauchte ich es nicht, und zweitens ist das Diagramm eine komplizierte Sache mit sehr nicht trivialen Algorithmen, und ich wollte nicht ohne besondere Notwendigkeit darauf eingehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der ersten Version war die Strategie zum Überprüfen des Vorhandenseins eines Elements nur auf die Liste ausgerichtet, und ihre Funktionen akzeptierten einen Zeiger auf ein Element und einen Zeiger auf die Basisklasse der Liste (ListBase *). Anschließend dachte ich: Aber bei einem Baum muss man genau das Gleiche tun! Führen Sie eine separate, aber im Wesentlichen genau gleiche Strategie durch?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Lösung war einfach: Ignorieren Sie die Liste. </font><font style="vertical-align: inherit;">Dies bedeutete, dass die Eingabe nun nicht mehr von Zeigern auf Elemente, sondern von Iteratoren empfangen wurde. </font><font style="vertical-align: inherit;">Und Funktionen werden zu Boilerplate, um Zeiger auf einen Container eines geeigneten Typs zu akzeptieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also jetzt die ursprüngliche Funktion, zum Beispiel das Registrieren einer Liste in einer Bitmap</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RegisterList</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ListBase&lt;ListElement&gt;* <span class="hljs-keyword">const</span> pList, ptrListElement <span class="hljs-keyword">const</span> pStart, ptrListElement <span class="hljs-keyword">const</span> pEnd = <span class="hljs-literal">nullptr</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pList -   ,       , pStart -   ,</span>
	<span class="hljs-comment">//pEnd -   </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		ptrListElement pCurr = pStart;<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">while</span> (pCurr != pEnd &amp;&amp; pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
		{<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pList-&gt;pFirst);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pList = <span class="hljs-keyword">const_cast</span>&lt;ListBase&lt;ListElement&gt; *&gt;(pList);<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
			pCurr = pCurr-&gt;pNext;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In eine Containerregistrierungsfunktion umgewandelt:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Container, class Iterator&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterContainer</span><span class="hljs-params">(Container* <span class="hljs-keyword">const</span> pContainer, Iterator itStart, Iterator itEnd = Iterator{})</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pContainer -   ,       ; itStart -   </span>
	<span class="hljs-comment">//, itEnd -    </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = itStart; it != itEnd; ++it)<font></font>
		{<font></font>
			ptrElementType&amp; pCurr = *it;<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pContainer);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pContainer = pContainer;<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Übergang durch die Liste durch Zeiger wurde mithilfe von Iteratoren in einen Übergang durch einen abstrakten Container umgewandelt. </font><font style="vertical-align: inherit;">Jetzt reicht es aus, wenn der Baum seine Iteratoren implementiert, und seine Unterstützung für diese Strategien wird bereits bereitgestellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies erforderte die Rückgabe von Iteratoren an die Listen ohne Ausnahmen, machte sie jedoch von außen unzugänglich und nur für den internen Gebrauch bestimmt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenadapter</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich sehr intensiv mit STL gearbeitet sowie Schulungsprogramme aus Büchern geschrieben, gestartet und studiert hatte, machte ich auf die Einfachheit der Arbeit mit STL-Containern aufmerksam. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie beispielsweise den folgenden Code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = { <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : v)<font></font>
     i = <span class="hljs-number">1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich erstelle einen Vektor, indem ich ihm den Typ int übergebe, den ich brauche, und das war's! Der Container ist sofort einsatzbereit, wenn ich einige zusätzliche Parameter, die standardmäßig eingestellt sind, nicht ändern muss, was meistens nicht der Fall ist! Ausgehend von der dreistufigen Organisation der Liste müsste ich in jedem Fall zuerst eine neue Klasse für das Element erstellen und dann eine Klasse für die Liste mit Daten schreiben und Operationen implementieren, die für die endgültige Liste spezifisch sind. Stellen Sie sich vor, wie viel Arbeit! Und wenn Sie eine andere Liste für andere Daten erstellen müssen, müssen Sie dies erneut durchführen oder im Extremfall den vorherigen Code kopieren und geringfügig ändern. Dies ähnelt bereits der gleichen Aufregung mit der C-Sprache und der Windows-API, bei der Sie für jede elementare Aktion alle erforderlichen Daten für die Struktur eingeben und dann die gewünschte Funktion aufrufen müssen. Und entweder alles im Auge behaltenOder lesen Sie auch ständig MSDN und studieren Sie die Argumente jeder neuen Funktion! Routine und furchtbar unangenehm!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich suchte nach Möglichkeiten, um die Möglichkeit zu erhalten, meine Liste analog zu STL-Containern zu erstellen, damit ich nicht jedes Mal die gleiche Aufgabe erledigen musste: Erstellen Sie eine separate Klasse für jedes neue Element und dann eine separate Listenklasse für die Arbeit mit Elementen davon Art. </font><font style="vertical-align: inherit;">Es gab also einen Adapter für eine Liste mit Datendaten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Adapter für eine Liste mit Daten ist eine Klasse, in deren Vorlagenparametern Sie sofort den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gewünschten Datentyp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und nicht das Element übergeben. </font><font style="vertical-align: inherit;">Die Art des Elements, das ich das zusammengesetzte Typ des Elements genannt, auf der Grundlage dieser Daten , die </font><font style="vertical-align: inherit;">sie auf schafft </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seine eigene</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementCompound_OneLinked_CP</span>
{</span>
	ElementData ed;		<span class="hljs-comment">//</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> ListElement = ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;;
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... Args&gt; <span class="hljs-title">ListElementCompound_OneLinked_CP</span><span class="hljs-params">(Args... args)</span> : <span class="hljs-title">ed</span><span class="hljs-params">(args...)</span> </span>{}<font></font>
	ListElementCompound_OneLinked_CP(<span class="hljs-keyword">const</span> ElementData&amp; ed) : ed(ed) {}<font></font>
<font></font>
	ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ElementData</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex = <span class="hljs-number">0</span>;			<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt;* pContainer = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">//  - </span><font></font>
<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer erwähnenswerter Punkt ist der Zugriff auf die Daten des Artikels. </font><font style="vertical-align: inherit;">Der Elementtyp enthält die Operation "*":</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> ed;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, wenn es einen Zeiger auf das pElement-Element gibt, muss es zweimal dereferenziert werden, um auf die darin gespeicherten Daten zugreifen zu können:</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; li = **pCurrElement;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einmal - um auf ein Objekt vom Typ ListElementCompound_OneLinked mit seinem Zeiger zuzugreifen: ListElementCompound_OneLinked &amp; le = * pCurrElement, und ein zweites Mal - um über die Operation '*': ElementData &amp; li = * le auf Daten zuzugreifen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sieht sehr seltsam und untypisch aus, aber es wird davon ausgegangen, dass Sie nicht mit Zeigern arbeiten (dafür hatten Sie bereits eine vorgefertigte Erstversion), sondern mit Iteratoren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Nächstes geben Sie beim Erstellen einer Liste basierend auf dem Adapter die Strategien an, die Sie wie zuvor benötigen. </font><font style="vertical-align: inherit;">Basierend auf all Ihren Parametern erstellt der Adapter automatisch die erforderlichen Typen und übergibt sie an die interne Basisliste, von der er geerbt wird. </font><font style="vertical-align: inherit;">Allgemeine Klassendefinition:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span> = <span class="hljs-title">SmartSharedPointer</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span> = <span class="hljs-title">ThreadLocking_STDMutex</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span> = <span class="hljs-title">DirectSearch</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span> = <span class="hljs-title">true</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Spezialisierung für die Liste mit Ausnahmen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>&lt;ElementData, _MemoryPolicy, LockingPolicy, CheckingPresenceElementPolicy, true&gt; :</span> 
<span class="hljs-keyword">public</span> List_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;, DirectSearch&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;&gt;, ListElementCompound_OneLinked&lt;ElementData, _MemoryPolicy&gt;, ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;&gt;, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">true</span>&gt;<font></font>
{<font></font>
	…<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sieht sehr sperrig, mehrstöckig und hässlich aus. Ich weiß. Aber dann macht diese Definition automatisch alles, was benötigt wird, ohne die direkte Beteiligung des Programmierers, der sie verwenden wird. Mit Hilfe von std :: conditional_t ​​und std :: is_same_v wird die Strategie zur Überprüfung des Vorhandenseins eines von Ihnen eingereichten Elements mit direkten Suchstrategien verglichen und je nach Ergebnis der entsprechende Typ des Listenelements ausgewählt: mit einem Index in der Bitmap und einem Zeiger auf die Liste oder ohne . Dies spart Ihnen Speicherplatz aufgrund unnötiger zusätzlicher Daten in jedem Knoten, wenn Sie eine direkte Suchstrategie verwenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Innerhalb der Klasse werden nur spezifische Iteratoren implementiert sowie die analog zu STL erforderlichen Funktionen push_back () / push_front (), die Aufrufe an die Basis-Multithread-Liste umleiten. </font><font style="vertical-align: inherit;">Sie können später weitere Funktionen hinzufügen, sodass die Liste den STLs sehr ähnlich wird. </font><font style="vertical-align: inherit;">Gleichzeitig bietet es jedoch alle erforderlichen Schutzmaßnahmen und Optionen zur Steigerung der Produktivität in einer Multithread-Umgebung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Arbeit mit einem Datenadapter sah nun so aus. </font><font style="vertical-align: inherit;">Listenobjekte erstellen:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;<font></font>
List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie mit allen Standardstrategien und -parametern zufrieden sind, wird das Erstellen einer Liste sehr kurz:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>&gt; list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, gibt es äußerlich absolut keinen Unterschied zu STL, außer dass der Name der Listenklasse unterschiedlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können Sie mit ihm wie auf die alte Weise über die Funktionen der Basisklasse arbeiten:</font></font><br>
<br>
<pre><code class="cpp hljs">list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">2</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier werden Zahlen von 0 bis 3 nacheinander am Ende der Liste hinzugefügt. Um zu dem Argument zu gelangen, das beim Erstellen an den Konstruktor des erstellten Typs übergeben wird, müssen Sie die Werte der ersten drei Argumente explizit notieren.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> x = *list0.GetLast();			<span class="hljs-comment">//   ,   auto    ListElementCompound_TwoLinked_CP&lt;...&gt;</span>
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x = "</span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ja, es ist eine gewisse Unannehmlichkeit, den Typ explizit anzugeben. Dies ist jedoch eine Folge des Versuchs, über die vorherige Funktion für die Arbeit mit Zeigern erneut auf die Liste zuzugreifen. </font><font style="vertical-align: inherit;">Wenn Sie dem Adapter die Funktion back () hinzufügen, die einen Iterator zurückgibt, tritt beim Durcharbeiten kein solches Problem auf:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> x = *list0.back();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Anpassen der Iteratoren an die Anforderungen von STL:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   STL</span>
<span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;
<span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">const</span> ElementData;
<span class="hljs-keyword">using</span> difference_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">ptrdiff_t</span>;
<span class="hljs-keyword">using</span> pointer = <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> List::ptrListElement;
<span class="hljs-keyword">using</span> reference = <span class="hljs-keyword">const</span> ElementData&amp;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird möglich, die Liste in Bibliotheksalgorithmen zu verwenden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; dElem : list1)
	<span class="hljs-built_in">cout</span> &lt;&lt; i++ &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; dElem &lt;&lt; <span class="hljs-built_in">endl</span>;<font></font>
transform(list1.begin(), list1.end(), list1.begin(), [](<span class="hljs-keyword">double</span>&amp; dElem1)<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> dElem1 * dElem1;<font></font>
});<font></font>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(list1.cbegin(), list1.cend())</span></span>;<font></font>
…<font></font>
copy(v.begin(), v.end(), list1.begin());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich müssen Sie das Abfangen und Behandeln von Ausnahmen organisieren: Alle obigen Beispiele dienen zum Arbeiten in einem Thread, um die Kompatibilität mit STL zu testen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Verwendung von STL-Algorithmen macht einen interessanten Punkt möglich: Sie können mehrere Algorithmen gleichzeitig verwenden und sie in mehreren Threads parallel ausführen. Dies kann nicht mit herkömmlichen Mitteln (z. B. mit std :: list und Blockierungsmitteln) erfolgen, ohne Zugriff auf den internen Inhalt der Listenklasse zu haben. Es war nur möglich, die gesamte Liste für die Dauer des gesamten Algorithmus zu blockieren. Dies beschleunigt natürlich die Arbeit für den Thread, der den Algorithmus ausführt, macht jedoch die Liste für andere Threads unzugänglich. Wenn Sie jedoch dieselbe „dünne“ SRWLock-Sperre anwenden, können Sie mehrere Algorithmen gleichzeitig in der Liste ausführen, wenn diese Liste nicht geändert wird. Der erste zu schreibende Thread wartet jedoch auf den Abschluss des Lesevorgangs der Liste durch alle anderen Threads.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der vorgeschlagenen Listenoption können Sie die Arbeit damit flexibler organisieren. </font><font style="vertical-align: inherit;">Sie können beispielsweise die Arbeit mit der Liste so organisieren, dass nicht modifizierende Algorithmen in der ersten Hälfte der Liste von mehreren Threads gleichzeitig ausgeführt werden, während eine Reihe anderer Threads in der zweiten Hälfte der Liste etwas hinzufügen oder ändern können. </font><font style="vertical-align: inherit;">Die Tatsache, dass die Liste für die Dauer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Operation und nicht für den gesamten Algorithmus </font><font style="vertical-align: inherit;">blockiert ist </font><font style="vertical-align: inherit;">, ermöglicht das "Schreiben" von Schreiboperationen durch die Abfolge von Operationen zum Lesen der Liste, wodurch die Arbeit mit ihr flexibler, produktiver und effizienter wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kombinieren von zwei Varianten von Listenklassen mit und ohne Ausnahmeunterstützung zu einer mit einem booleschen Parameter</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anfangs waren die Listen nur mit Ausnahmen. </font><font style="vertical-align: inherit;">Dann habe ich neue hinzugefügt - keine Ausnahmen mit Fehlerrückgabe - und die alten mit dem Buchstaben "E" im Klassennamen umbenannt: List_OneLinked_E und List_TwoLinked_E. </font><font style="vertical-align: inherit;">Dies war erforderlich, um überall vier Deklarationen der Listenklasse anzugeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann entschied ich, dass es aus vielen Gründen unpraktisch war. </font><font style="vertical-align: inherit;">Warum brauchen wir zwei völlig unterschiedliche Klassen, wenn dies dieselbe Liste mit oder ohne Ausnahmeunterstützung ist? </font><font style="vertical-align: inherit;">Ich habe beide Listen jedes Typs zu einer einzigen Klasse mit einem zusätzlichen Booleschen Parameter kombiniert, und ihre spezifische Implementierung mit und ohne Ausnahmen sind zwei Spezialisierungen einer einzelnen Klasse für den angegebenen Booleschen Parameter.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenführungsvorgang für Vorlagenliste</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Vorlagenoperation zum Kombinieren von Listen funktionierte zuvor nur mit Listen desselben Typs. Es wurden entweder nur einfach verbundene Listen oder nur doppelt verbundene Listen kombiniert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie jedoch darüber nachdenken, spielt es keine Rolle, welche Art von Listen an der Operation beteiligt sind: einfach verbunden oder doppelt verbunden. Ihre Blockierungsstrategien sind ebenfalls unwichtig, wie sie prüfen, ob Elemente vorhanden sind und ob sie die Ausnahmebehandlung unterstützen oder nicht. All dies gilt nur für die Organisation der Liste, nicht jedoch für die darin enthaltenen Daten. Es ist wichtig, dass nur der Datentyp und die Speicherstrategie für die Elemente übereinstimmen. Dementsprechend akzeptiert die Eingabeoperation nach dem Kombinieren von Listen mit einem Booleschen Parameter in Bezug auf Ausnahmen Listen eines beliebigen Typs mit allen Varianten ihrer Parameter:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy1</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy2</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy1</span>,
<span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy2</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions1</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions2</span>,
<span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType1</span>, <span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType2</span>&gt;
<span class="hljs-title">auto</span> <span class="hljs-title">operator</span>+(<span class="hljs-title">ListType1</span>&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;&amp; <span class="hljs-title">list1</span>, <span class="hljs-title">ListType2</span>&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&amp; <span class="hljs-title">list2</span>) <span class="hljs-title">noexcept</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund des Listentyps wählt der Compiler nun abhängig von der Einstellung des externen Parameters ce_bGetMinLinksList eine Liste mit minimaler oder maximaler Konnektivität aus. Abhängig von dieser Lösung werden die entsprechenden Parameter verwendet:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMinLinksNumber = <span class="hljs-built_in">std</span>::min(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(), <font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMaxLinksNumber = <span class="hljs-built_in">std</span>::max(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(),<font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<font></font>
<span class="hljs-keyword">using</span> ListTypeResultMinLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResultMaxLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResult = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ce_bGetMinLinksList, ListTypeResultMinLinks, ListTypeResultMaxLinks&gt;;<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMinLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMaxLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResult = ce_bGetMinLinksList ? bExceptionsResultMinLinks : bExceptionsResultMaxLinks;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf den ausgewählten Parametern wird eine Ergebnisliste erstellt:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">ListTypeResult <span class="hljs-title">list</span><span class="hljs-params">(list1.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>) + list2.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>), <span class="hljs-literal">false</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann werden in dieser Liste die Zeiger auf den Anfang der ersten und das Ende der zweiten Liste gesetzt:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ,   (       ,   )</span>
<span class="hljs-keyword">if</span> (list1.GetFirst(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list1.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list1.GetLast(<span class="hljs-literal">true</span>))<font></font>
	list1.GetLast(<span class="hljs-literal">true</span>)-&gt;pNext = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list2.GetLast(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list2.GetLast(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list1.GetLast(<span class="hljs-literal">true</span>);<font></font>
<font></font>
<span class="hljs-comment">//       </span>
<span class="hljs-built_in">list</span>.CheckingPresenceElementPolicyResult::RegisterContainer(&amp;<span class="hljs-built_in">list</span>, <span class="hljs-keyword">typename</span> ListTypeResult::iterator{ <span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst, &amp;<span class="hljs-built_in">list</span> });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes werden die vorherigen Listen gelöscht und die Funktion beendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Schwachpunkt dieser Funktion ist das doppelte Sperren von Listen mit potenziellen Deadlocks:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// :  -   ;            std::lock(mutex1, mutex2)</span><font></font>
list1.LockListExclusive();<font></font>
list2.LockListExclusive();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können eine Funktion zum gleichzeitigen Sperren von zwei Listen in einer einzelnen atomaren Operation wie std :: lock (mutex1, mutex2) einführen. Nicht alle Sperrstrategien unterstützen jedoch das gleichzeitige Sperren von zwei Synchronisationsobjekten wie std :: lock (...). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus können zwei Listen unterschiedliche Sperrstrategien haben. </font><font style="vertical-align: inherit;">Die Lösung dieses Problems (falls überhaupt vorhanden) bleibt der Zukunft überlassen.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux-Kompilierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Kompilierung wurde über das ListDataAdapterTest-Projekt überprüft, das ursprünglich in reinem C ++ ohne Windows-spezifische Funktionen unter Linux Ubuntu 16.04 LTS, dem g ++ 8.2.0-Compiler, geschrieben wurde. Die meisten kleinen Nuancen waren leicht zu beheben, und das Projekt wurde erfolgreich kompiliert, und die Ausgabe des Programms stimmte mit der gleichen Ausgabe unter Windows überein. Dies ist jedoch der Fall, wenn Sie die Zeile zum Kombinieren von Listen mit der Operation "+" auskommentieren:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> list3 = list00 + list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie es so lassen, wie es ist, tritt bei der oben beschriebenen Operation "+" ein Kompilierungsfehler auf, als wäre es in der Klasse des zusammengesetzten Elements der Liste nicht als privilegiert deklariert worden. Ein ähnlicher Fehler tritt in der Strategieklasse für die direkte Überprüfung für das DirectSearch-Element auf. In Visual C ++ ist hier alles in Ordnung. Diese Fehler treten jedoch auf, wenn in der zusammengesetzten Elementklasse und in der Listenklasse die Deklaration der Operation zum Kombinieren von Listen und DirectSearch als privilegiert auskommentiert wird. Es scheint, dass g ++ diese Deklarationen einfach überspringt und sich über die privaten / geschützten Mitglieder der entsprechenden Klassen beschwert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(In g ++ Version 9 (Ubuntu 20.04) die gleichen Fehler.)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum Privilegienankündigungen übersprungen werden und wie man sie behebt, habe ich nicht verstanden. </font><font style="vertical-align: inherit;">Ich bin nicht gut in den Funktionen des GCC-Compilers. </font><font style="vertical-align: inherit;">Verließ diesen Moment auch für die Zukunft. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abgesehen von dieser Nuance gibt es keine weiteren schwerwiegenden Kompilierungsfehler.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschreibung der Header-Dateistruktur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Liebe Leserinnen und Leser, ich habe das vollwertige Projekt unter der LGPL 3.0-Lizenz auf GitHub veröffentlicht: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ListMT</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dies ist eine Lösung, die aus mehreren Testprojekten besteht. </font><font style="vertical-align: inherit;">Der Hauptcode einer Multithread-Liste befindet sich aufgrund ihrer Implementierung über Vorlagen in mehreren Header-Dateien:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List.h - die Basisklasse einer Liste ohne Daten, die alle grundlegenden Operationen mit einer Liste implementiert, die ohne Definition bestimmter Daten möglich ist, sowie ähnliche STL-Adapter für Daten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListE.h - Versionen der Liste mit Ausnahmeunterstützung.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListElement.h - Definition von Basisklassen für ein Listenelement.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListErrors.h - Definition von Codes und Fehlerklassen für Ausnahmen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusätzlich zu den aufgelisteten Hauptdateien sind auch folgende implementiert:</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MemoryPolicy.h - Strategien für die Arbeit mit dem Gedächtnis;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadLocking.h - Blockierungsstrategien.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SearchContainerElement.h - Strategien zum Überprüfen des Vorhandenseins eines Elements in der Liste, die abstrakt für jeden Container mit Iteratoren beschrieben werden.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zum endgültigen Projekt habe ich drei alte Versionen in den Ordner „Alte Versionen“ eingefügt, damit Sie kurz bewerten können, wie sich das Projekt während der Entwicklung geändert hat.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Hauptprojekt namens List ist ein Programm mit einer Schnittstelle für Windows, die über die Windows-API hardcore implementiert wird (ich weiß nicht, wie sonst). In diesem Programm wählen Sie den Listentyp (einfach verbunden oder doppelt verbunden) aus und geben auch die anfängliche Anzahl von Elementen und die gewünschte Anzahl von Threads an. Listenelemente enthalten einen einzelnen 64-Bit-Wert. Nach dem Erstellen einer Liste springt das Programm in jedem Thread in der Schleife vorwärts oder rückwärts durch die Liste zu einer zufälligen Anzahl von Elementen und fügt dann ein Element hinzu oder entfernt es. Diese Liste enthält keine wirklich nützliche Arbeit, und die gesamte Energie wird für die Erwärmung der Atmosphäre aufgewendet. Dies ist jedoch nicht erforderlich: Wir müssen nur die Funktionsfähigkeit und Leistung der Liste in einer intensiven Multithread-Umgebung bewerten.Das Maß für die Leistung ist die Anzahl der Iterationen des obigen Zyklus pro Sekunde, die von allen Threads ausgeführt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Liste wird erstellt, indem die entsprechenden Strategien im Programmcode angegeben und anschließend neu kompiliert werden. Alle Strategien für das Hauptprogramm sind im Hauptmodul ListMain.cpp angegeben, die Speicherstrategie ist in ListDataExample.h ausgewählt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen habe ich ein bisschen mit Experimenten experimentiert. Ich gebe ehrlich zu. Hauptsächlich, weil sich dort in einigen Fällen die Liste der Elemente erheblich ändert. Für die Reinheit des Experiments wäre es zur Messung der Leistung erforderlich, einen Test so durchzuführen, dass sich die Anzahl der Elemente im Durchschnitt während des Untersuchungszeitraums nicht oder nur unwesentlich ändert. Nur unter solchen Bedingungen wäre es fair, den Wert der Produktivität anhand des Durchschnittswerts zu bewerten. Wenn jemand interessiert ist, schlage ich vor, solche Experimente selbst zu organisieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe die anfängliche Organisation der Tests aus folgenden Gründen nicht korrigiert. </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuallererst war ich nur faul.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstens interessiert sich meiner Meinung nach niemand für die genauen quantitativen Leistungswerte</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit berechnetem Fehler</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Es ist wichtig, die Leistung und Leistung der Liste auf </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qualitativ hochwertige Weise</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu bewerten </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zweitens können Sie die Änderung der Leistung der Liste mit dem Wachstum ihres Volumens bewerten, was ebenfalls sehr wichtige und interessante Informationen sind. </font><font style="vertical-align: inherit;">Aus diesen Gründen habe ich die ursprünglichen Experimente nicht geändert. </font><font style="vertical-align: inherit;">Drittens wird für alle Varianten der Liste derselbe Testcode durchgeführt, wodurch sie in diesem Sinne denselben Bedingungen unterliegen: Die Tatsache, dass sie sich in diesem Fall unterschiedlich verhalten, ermöglicht es uns, die Qualität der Änderungen zu beurteilen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Leistungsmessung zu aktivieren, setzen Sie das Flag ce_bPerformanceMeasure im Modul ListMain.cpp auf true. </font><font style="vertical-align: inherit;">Das Programm erstellt eine Datei "PerformanceMeasure.txt" mit Paaren "Anzahl der Elemente - Anzahl der Zyklen / Sek.", Die durch ein ":" - Symbol getrennt sind.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse der Leistungsmessung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich habe ich nicht alle möglichen Konfigurationen der Liste getestet, da es viele davon gibt. </font><font style="vertical-align: inherit;">Ich habe mich nur auf die Schlüssel konzentriert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Tests wurden auf meine Bestellung des bereits veralteten, aber immer noch sehr peppigen Intel Core i7-3930K, DDR3-1333, 4-Kanal-Speichercontrollers durchgeführt. </font><font style="vertical-align: inherit;">Die Kompilierung wurde über Visual Studio 2019 für den Release x64-Modus, das Betriebssystem Windows 7 x64, durchgeführt. </font><font style="vertical-align: inherit;">Ich habe nicht mit der Anzahl der Threads gespielt, daher wurden in allen Tests immer die maximal 12 in diesem System verfügbaren Threads verwendet. </font><font style="vertical-align: inherit;">Mit Ausnahme des letzten Tests wurde immer eine Liste mit 10.000 zufällig ausgewählten Elementen erstellt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen der Speicherstrategie</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erwähnt, kann mit integrierten Zeigern nur eine direkte Suchstrategie verwendet werden, um das Vorhandensein eines Elements in der Liste zu überprüfen. Dementsprechend wird, damit der Vergleich korrekt ist, und für intelligente Zeiger nur diese Strategie in diesem Test angewendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Sperrstrategie wurde ein kritischer Abschnitt mit einer dünnen Sperre als der produktivste in Windows ausgewählt (siehe unten): ThreadLockingWin_SRWLock. Die Fehlerbehandlung erfolgt durch Rückgabe eines Fehlercodes, d. H. Option ohne Ausnahmen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fr/pu/f0/frpuf0zcgkd3dep1rbzgtpk3ciq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Grafik zeigt die Anzahl der Zyklen, die von allen Threads insgesamt pro Sekunde ausgeführt werden, abhängig von der Testdauer (in Sekunden). Offensichtlich ist die Leistung aufgrund der zufälligen Art der Threads, die auf die Liste zugreifen, inkonsistent.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pz/km/sw/pzkmsw49rqqqihzv-poyko_co-w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite Diagramm zeigt, wie sich die Anzahl der Listenelemente während des Tests ändert. Ich werde keine nachdenklichen Aussagen zu diesem Zeitplan machen, außer dem Offensichtlichen: Es ist klar, dass sie auf leicht unterschiedliche Weise funktionieren und die Konnektivität der Liste zusammen mit der Speicherstrategie einen Effekt hat. Eine doppelt verknüpfte Liste mit internen Zeigern ist die einzige, deren durchschnittliche Größe sich über die gesamte Testdauer unerwartet nicht ändert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durchschnittliche Produktivität (Zyklen / s) für den gemessenen Zeitraum:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ky/ux/kd/kyuxkd-1_uzoxhu65prxxyvfcfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zumindest kann argumentiert werden, dass die Listenoption mit intelligenten Zeigern langsamer ist als die Version mit integrierten Zeigern, was zu erwarten ist. </font><font style="vertical-align: inherit;">In beiden Fällen stellt sich irgendwie heraus, dass ein einzeln verbundener schneller ist als ein doppelt verbundener, was wiederum zeigt, dass sich im Multithread-Modus viele vertraute Dinge ändern können.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen auf Artikelverfügbarkeitsstrategien</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am interessantesten ist das Testen von Strategien zum Überprüfen des Vorhandenseins eines Elements. Als Speicherstrategie werden intelligente Zeiger aus den zuvor beschriebenen Gründen natürlich angezeigt. Der Rest ist der gleiche: Sperren mit ThreadLockingWin_SRWLock und Behandeln von Fehlern durch Zurückgeben eines Fehlercodes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ua/lp/ck/ualpckuzqwqhhsdq9o8oqtljtfa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können mit Sicherheit sagen, dass alle Strategien ungefähr gleich funktionieren. Dies ist verständlich: Wenn Sie in einer einfach verknüpften Liste das Element löschen, müssen Sie die Liste jedes Mal auf das Element überprüfen, das das zu löschende Element angibt. Dies macht alle Bemühungen zunichte, den Zugriff auf die Liste zu optimieren und die Überprüfung auf das Vorhandensein eines Elements zu beschleunigen. Daher ist eine einfach verknüpfte Liste nicht die beste Wahl für eine intensive ungeordnete Multithread-Arbeit damit.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde keine Grafik über die Anzahl der Elemente geben: Es gibt dort nichts Interessantes. Ich stelle nur fest, dass jetzt die Anzahl der Elemente in allen Listen zunimmt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine völlig andere Situation ergibt sich für eine doppelt verknüpfte Liste. Um die Grafiken schön aussehen zu lassen, habe ich sogar die Strategie der direkten Anzeige der DirectSearch-Liste davon ausgeschlossen, da sie durch die Ergebnisse deutlich vom Rest „abfällt“. Außerdem habe ich die maximale Anzahl von Elementen um das Vierfache erhöht, wodurch der Test gestoppt wird.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/th/hd/9x/thhd9xyuvi7avo9gmcscfra0tp0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens hat sich die Leistung beim Zugriff auf die Liste (sowie die Prozessorlast von 99-100%) dramatisch und erheblich erhöht! Zweitens haben zwei Strategien mit sequentiellem Füllen von Array-Bits ungefähr die gleiche Leistung, die sich während des Tests nicht ändert. Die Geschwindigkeit des zweiten Strategiepaars nimmt nichtlinear ab. Warum dies so ist, wird aus dem Diagramm für die Anzahl der Knoten in der Liste deutlich.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/ge/mi/bugemimboyskkxkygick6axhxls.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listen mit dem ersten Strategiepaar wachsen in der Anzahl der Elemente und linear. Das zweite Paar ergibt ein signifikant nichtlineares Wachstum, und je größer die Anzahl der Elemente in einer Liste ist, desto langsamer wächst es. Das ist da verständlich Mit einer Zunahme der Anzahl von Elementen beim Erstellen eines neuen Elements müssen Sie im Durchschnitt eine größere Anzahl von Bits des Arrays auf der Suche nach freien Elementen betrachten. Das erste Strategiepaar befasst sich nicht damit, sondern verwendet für jedes neue Element ein neues Bit. Somit hat eine Liste mit einer solchen Strategie eine maximale Zugriffsleistung und kommt der klassischen Liste am nächsten: Sowohl das Erstellen als auch das Löschen von Elementen wird in konstanter Zeit durchgeführt, unabhängig von der Anzahl der Elemente. Es bietet jedoch einige Garantien für Integrität und Sicherheit in einer Multithread-Umgebung, allerdings auf Kosten einer bestimmten Speichermenge.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Liste mit dem zweiten Strategiepaar ist natürlich deutlich langsamer. Es ist jedoch immer noch erheblich schneller als direkte Überprüfungsoptionen. Sie können es also wirklich als Zwischenprodukt in der Leistung empfehlen, aber optimaler in Bezug auf den Speicherverbrauch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich arbeiten Listen mit einer direkten Suchstrategie auch langsamer, wenn die Anzahl der darin enthaltenen Elemente zunimmt: Jedes Mal muss eine größere Anzahl von Elementen angezeigt werden. Es ist nur so, dass die Liste während des Tests nicht so stark wächst, dass sie trotz der chaotischen Leistungsschwankungen spürbar wird.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vw/ck/_p/vwck_pj1r6wmaxgowihhqbzltq8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gemittelte Leistungswerte zeigen, dass Strategien mit einer Bitmap während des sequentiellen Füllens die Produktivität des Zugriffs auf die Liste um etwa das 200-fache steigern konnten, d. H. </font><font style="vertical-align: inherit;">2 Größenordnungen im Vergleich zu direkten Suchstrategien. </font><font style="vertical-align: inherit;">Dies ist eine sehr radikale Veränderung. </font><font style="vertical-align: inherit;">Die Leistung von Optionen mit speicheroptimaler Bitfüllung ist, wie oben erwähnt, natürlich merklich langsamer, aber immer noch viel schneller als Optionen mit direkter Überprüfung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist auch erwähnenswert, dass die Verwendung eines Speicherübertragungsmechanismus bei Bedarf den Zugriff auf die Liste etwas verlangsamt. </font><font style="vertical-align: inherit;">Nicht zu kritisch, aber der Effekt ist vorhanden und spürbar, insbesondere - in der Variante mit dem sparsamen Einsatz von Speicher (gelbe Linie in den Grafiken).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen der Blockierungsstrategie</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun sehen, wie sich die Leistung der Liste ändert, wenn Sie verschiedene Sperrstrategien auswählen. </font><font style="vertical-align: inherit;">Ich habe drei Arten von Sperren verwendet: SRWLock-Thin-Sperre, regulärer kritischer Windows-Abschnitt und STL-Mutex. </font><font style="vertical-align: inherit;">Für die restlichen Einstellungen wurde die schnellste Version der Liste verwendet: Biconnected, Smart Pointers, die Strategie zum Überprüfen des Vorhandenseins eines Elements - SearchByIndex_BitArray, eine Variante ohne Ausnahmen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6a/jb/pz/6ajbpzqugu7mgtv9mtcim4y221w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie zu erwarten ist, erhöht ein „dünnes“ Schloss die Leistung um fast 25%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Arbeitsgeschwindigkeit mit dem kritischen Bereich von Windows und dem STL-Mutex ist ungefähr gleich.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6n/qz/wv/6nqzwvldymyqvb-rt1dgjgigwdm.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Auswirkungen von Ausnahmen auf die Leistung zu bewerten, habe ich drei Tests durchgeführt. </font><font style="vertical-align: inherit;">Die ersten beiden verwendeten eine doppelt verknüpfte Liste, intelligente Zeiger, eine Strategie zur Überprüfung der Anwesenheit von Elementen - SearchByIndex_BitArray - und einen kritischen Abschnitt von SRWLock. </font><font style="vertical-align: inherit;">Der gleiche Test wurde für den letzten Test verwendet, nur das Schloss wurde zum Vergleich durch den üblichen kritischen Abschnitt ersetzt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7_/at/9u/7_at9uiygpgn_mnrznps8yjwbp0.png"><br>
<br>
<img src="https://habrastorage.org/webt/pf/ac/e9/pface9frjlrsbtcbc9ryxnqv8we.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist ersichtlich, dass die Unterstützung von Ausnahmen die Arbeitsgeschwindigkeit erheblich verringern kann, insbesondere wenn Sie eine „gröbere“ Blockierungsoption verwenden. </font><font style="vertical-align: inherit;">Beachten Sie jedoch, dass in diesem Fall die Unterstützung für STL und für Schleifen in der Sammlung nicht verfügbar ist.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es war ein sehr umfangreiches Experiment für mich. Ich meine nicht die obigen Tests, sondern das ganze Projekt. Er hatte nicht erwartet, dass er so in die Länge gezogen würde. Trotzdem habe ich es komplett und in dem von mir geplanten Umfang durchgeführt. Am Ende ist dies natürlich immer noch nicht die endgültige Version, sondern nur ein funktionierender Prototyp, die Umsetzung der am Anfang des Artikels beschriebenen Ideen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus den Testergebnissen geht hervor, dass es sich unter Windows als die schnellste doppelt verknüpfte Liste mit intelligenten Zeigern herausstellte, eine Strategie zur Überprüfung des Vorhandenseins des SearchByIndex_BitArray-Elements, des kritischen Abschnitts von SRWLock und ohne Ausnahmen. In dieser Konfiguration bietet die Liste maximale Leistung bei intensivem chaotischem Zugriff aus verschiedenen Streams und das Verhalten ist der klassischen Liste mit Sicherheitsgarantien im Multithread-Modus am nächsten. Die Option mit einem sparsameren Speicherverbrauch ist ebenfalls sehr produktiv (im Vergleich zur direkten Überprüfung von DirectSearch), sie ist jedoch immer noch deutlich langsamer als die vorherige und ihre Leistung nimmt mit zunehmender Anzahl von Elementen ab.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie denken, dass ich hier für das werben werde, was für eine coole Sache ich getan habe und wie großartig es ist, sie zu verwenden, dann nein: Tatsächlich werde ich Sie zunächst entmutigen. </font><font style="vertical-align: inherit;">Tatsächlich:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überlegen Sie, ob es möglich ist, einen Container mit einer anderen Anordnung von Elementen zu verwenden: beispielsweise einem Array. </font><font style="vertical-align: inherit;">Es gibt keine Probleme wie eine Liste.</font></font></li>
<li>          ,      std::list    .            .    ,        ,          .      ,   <s>,     </s>.    , <s>    ,</s>       <s>,    </s>.</li>
<li> ,    .       :    ,  ,  ,    ,        . ,    –       ,      ,    .</li>
<li>                ,      .   ,       ,               .</li>
<li>   ,    ,     ,            .  ,             .              . ,    ,       ,   –     .    . ,   –          .     ,        ,    .           ,        .. ,          ,            , ,     ,          ,   :   .                       .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strategien mit der Übertragung von Speicher auf ein Bit-Array bei Bedarf nähern sich zumindest teilweise einer Multithread-Liste an die klassische an: Zumindest bis das Speicher-Array vollständig gefüllt ist, wird genau so viel benötigt, wie tatsächlich benötigt wird. </font><font style="vertical-align: inherit;">Dies führt jedoch zu einer Leistungsminderung.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Nachteile des Projekts:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zuvor erwähnte Möglichkeit der gegenseitigen Blockierung beim Betrieb von Kombinationslisten.</font></font></li>
<li>       ,    . ,     :   ,     RAII:          .       ,      ,   -  ,       .   ,     . ,   ,      - .</li>
<li>         ,    .     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hoffe das war interessant. Anfänger können nützlich sein, weil Alles wird von einfach bis komplex betrachtet. Ich bitte Fachleute zu sagen, inwieweit die hier beschriebenen Ideen Ihrer Meinung nach in der Praxis in realen Projekten anwendbar sind. Gab es in Ihrer Aktivität einen Fall, in dem Sie entsprechend der Bedeutung eine Liste oder einen Baum und keinen anderen Container benötigten, der jedoch aufgrund der hier beschriebenen Probleme zu einem Engpass in Ihrem Programm wurde? Oder Sie mussten das Programm stark ändern oder komplizieren. Wenn Sie dies schon einmal getroffen haben, wie haben Sie es dann gelöst?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Wesentlichen ist dieses Projekt natürlich nur die Verwirklichung meiner eigenen Sicht auf die Lösung dieses Problems. </font><font style="vertical-align: inherit;">Es ist wahrscheinlich, dass es eine bessere Option gibt. </font><font style="vertical-align: inherit;">Ich wiederhole von Anfang an den Gedanken, dass ich es ursprünglich für mich getan habe und nicht vorhatte, es öffentlich zu zeigen. </font><font style="vertical-align: inherit;">Trotzdem habe ich es aus den dort beschriebenen Gründen getan, daher werde ich mich über konstruktive Kritik freuen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bei einer sorgfältigen Überprüfung des Codes können Sie auf ein solches Design stoßen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  (        )</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};			<span class="hljs-comment">//-,       ,   ListElementData_OneLinked/ListElementData_TwoLinked</span><font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked1</span> :</span> <span class="hljs-keyword">public</span> ListElement_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked1&lt;&gt;, DerivedListElement&gt;, MemoryPolicy&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>;						<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked1(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : u64Value(u64Value) {}		<span class="hljs-comment">//</span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked2</span> :</span> <span class="hljs-keyword">public</span> ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">using</span> ListElementBase = ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;;<font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ucSomeData[<span class="hljs-number">1024</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">decltype</span>(ListElementBase::u64Value))];	<span class="hljs-comment">//     </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked2(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : ListElementBase(u64Value) {}		<span class="hljs-comment">//</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese schwarze Magie verdient einen separaten Artikel. </font><font style="vertical-align: inherit;">Dies ist zwar eine noch weniger praktische Sache als die hier beschriebene Multithread-Liste, hat aber ihre eigenen merkwürdigen Merkmale. </font><font style="vertical-align: inherit;">Wenn Sie daran interessiert sind, woher es kam und warum es erschien, und Sie möchten, dass ich später ausführlich darüber spreche, schreiben Sie in die Kommentare.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de506702/index.html">Die zuverlässigsten Festplatten nach Backblaze Q1 2020</a></li>
<li><a href="../de506704/index.html">Warum 2020 in PHP schreiben? Holivarim ist diesen Donnerstag ein interaktiver Podcast auf Youtube</a></li>
<li><a href="../de506706/index.html">Die Leistung von modernem Java beim Arbeiten mit großen Datenmengen, Teil 1</a></li>
<li><a href="../de506708/index.html">VPN / Mikrotik Zwei-Faktor-Authentifizierung - einfach und skalierbar</a></li>
<li><a href="../de506710/index.html">Verwalten Sie mehrere Adressbücher in der Open-Source-Edition der Zimbra Collaboration Suite</a></li>
<li><a href="../de506726/index.html">Erfahrung in der Verwendung der Rutoken-Technologie zur Registrierung und Autorisierung von Benutzern im System (Teil 2)</a></li>
<li><a href="../de506730/index.html">Schnauben oder Suricata. Teil 1: Wählen Sie ein kostenloses IDS / IPS, um das Unternehmensnetzwerk zu schützen</a></li>
<li><a href="../de506732/index.html">Organisationsweite Wiederverwendung von UI-Komponenten</a></li>
<li><a href="../de506734/index.html">Übergangsberechnungen in elektrischen Netzen</a></li>
<li><a href="../de506736/index.html">Wie viele Methoden sollte eine Klasse haben?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>