<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí† üë®üèΩ‚Äçüöí üë∂üèΩ Lineare Multithread-Liste: Elementexistenzproblem, Produktivit√§tsverbesserung und STL-Beziehung ü§∞üèΩ üêÜ üë©üèª‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, liebe Besucher von Habr! 
 
 Dieser Artikel konzentriert sich auf eine verkn√ºpfte Liste, Multithreading und C ++. Ich stelle sofort fest, dass ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Lineare Multithread-Liste: Elementexistenzproblem, Produktivit√§tsverbesserung und STL-Beziehung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506716/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo, liebe Besucher von Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel konzentriert sich auf eine verkn√ºpfte Liste, Multithreading und C ++. Ich stelle sofort fest, dass es jede M√∂glichkeit gab, diese Arbeit ins Regal zu stellen und in einer kleinen Anzahl pers√∂nlicher Projekte zu verwenden. Stattdessen habe ich mich immer noch entschlossen, es vor Gericht zu stellen - pl√∂tzlich scheint es jemandem wirklich n√ºtzlich oder interessant zu sein. Wenn sich herausstellt, dass es jemandem bereits gelungen ist, so etwas zu tun, geben Sie mir diese Materialien bitte. Unabh√§ngig davon, wie ich versucht habe, zu diesem Thema zu googeln, waren alle Versuche erfolglos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich stelle auch fest, dass es nicht um die klassische verkn√ºpfte Liste geht, sondern um mein kreatives √úberdenken der Verwendung dieser Datenstruktur in einer Multithread-Umgebung. Ich dachte √ºber ein Szenario eines ungeordneten intensiven Zugriffs auf Multithread-Listen nach. Dies bedeutet, dass jeder Thread jederzeit, unabh√§ngig von anderen, auf die Liste zugreifen und die erforderlichen Vorg√§nge ausf√ºhren kann. Wenn er nur Elemente hinzuf√ºgt oder √§ndert, ist das nicht so schlimm. Wenn er auch die Elemente entfernt, k√∂nnen verschiedene interessante Merkmale auftreten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Projekt, an dem ich als Hobby und Selbstentwicklung beteiligt war, dauerte aus mehreren Gr√ºnden sehr lange. </font><font style="vertical-align: inherit;">W√§hrend ich daran arbeitete, studierte ich au√üerdem intensiv: Das Projekt begann ohne das Wissen und Verst√§ndnis von STL und wurde entsprechend entworfen, wobei nur die internen Mittel der C ++ - Sprache selbst verwendet wurden. </font><font style="vertical-align: inherit;">Dann habe ich es jedoch sehr ernsthaft unter Ber√ºcksichtigung von STL und sogar unter STL modifiziert. </font><font style="vertical-align: inherit;">Was ich daraus gemacht habe, beurteilen Sie, liebe Leser.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das hier beschriebene Material vollst√§ndig zu verstehen, m√ºssen Sie die folgenden B√ºcher lesen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexandrescu A. - "Modernes Design in C ++".</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richter D., Nazar K. - ‚ÄûWindows √ºber C / C ++, Visual C ++ Programmierung‚Äú.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josattis N. - ‚ÄúC ++ Standard Library. </font><font style="vertical-align: inherit;">Referenzhandbuch. </font><font style="vertical-align: inherit;">Second Edition ‚Äùoder ein √§hnliches Buch √ºber STL.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeilenliste</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine lineare Liste ist eine bekannte Datenstruktur, die seit der Zeit der C-Sprache und fr√ºher verwendet wurde. Sein Element ist ein bestimmtes Objekt im Speicher, das Verbindungen zu einem oder zwei benachbarten √§hnlichen Elementen hat - hier ein Beispiel f√ºr eine doppelt verkn√ºpfte Liste:</font></font><br>
<br>
<pre><code class="plaintext hljs">struct ListItem<font></font>
{<font></font>
    &lt;‚Ä¶   ‚Ä¶&gt;<font></font>
    List *pNext;<font></font>
    List *pPrev;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dementsprechend ist die Liste selbst ein bestimmtes (Unter-) Programm, das Manipulationen mit diesen Elementen durchf√ºhrt. </font><font style="vertical-align: inherit;">In der Regel ist ein Zeiger auf den Anfang und optional auf das Ende der Liste bekannt: Dies reicht aus, um vom ersten Element an alle seine Elemente bis zum Ende durchzugehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich beschreibe ich bereits gut studierte und bekannte Informationen: Es war ein Bildungsprogramm f√ºr diejenigen, die √ºberhaupt nicht auf dem neuesten Stand waren. </font><font style="vertical-align: inherit;">F√ºr Details k√∂nnen Sie sich beispielsweise hier wenden: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lineare Liste (Wikipedia)</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Die STL-Bibliothek verf√ºgt √ºber einen so wunderbaren Container std :: list (doppelt verkn√ºpfte Liste) sowie √ºber die Twin-std :: forward_list (einfach verkn√ºpfte Liste). </font><font style="vertical-align: inherit;">Das hei√üt, wenn Sie nicht daran interessiert sind, wie die Liste organisiert ist und funktioniert, und Sie sie nur f√ºr Ihre Aufgaben verwenden m√∂chten, sind die vorgeschlagenen Container Ihre Option.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber es gibt eine Sache, aber ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multithreading-Probleme</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wiederhole, als ich anfing, dieses Thema zu analysieren, wollte ich alles tun und mich nur auf interne C ++ - Tools ohne STL-Unterst√ºtzung verlassen. </font><font style="vertical-align: inherit;">Der Wert dessen, was passieren w√ºrde, w√§re niedriger, wenn ich mich noch dazu entschlie√üen w√ºrde, hier dar√ºber zu sprechen. </font><font style="vertical-align: inherit;">Andererseits war ich v√∂llig frei von jeglichen Konzepten oder Einschr√§nkungen der Bibliothek und war daher an nichts gebunden und suchte nach offenen und unabh√§ngigen Ans√§tzen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuvor war in der fernen Vergangenheit die √ºberwiegende Mehrheit der Computer Single-Core- und Single-Prozessor-Computer. Die lineare Liste war eine relativ einfache und transparente Datenstruktur, und die Arbeit damit verursachte keine besonderen Schwierigkeiten. Jetzt sind sogar Smartphones zu Multi-Core-Smartphones geworden. Unter Multithreading-Bedingungen ist selbst eine so einfache Struktur wie eine verkn√ºpfte Liste sehr kompliziert. Das Sicherstellen des korrekten Betriebs im Multithread-Modus erschwert im Allgemeinen jedes Programm erheblich. Dies ist eine bekannte Tatsache.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen Sie ein abstraktes Szenario intensiver Arbeit mit einer Liste verschiedener Threads: Jeder von ihnen kann zu einem v√∂llig beliebigen Zeitpunkt Elemente hinzuf√ºgen, l√∂schen, √§ndern usw. Einerseits sollte die Arbeit mit der Liste in diesem Fall zun√§chst sicher sein: Wenn Datenverletzungen und undefiniertes Verhalten des Programms vorliegen, ist dies eine v√∂llig unangemessene L√∂sung. Andererseits w√ºrde ich sehr gerne so schnell wie m√∂glich mit ihm arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das erste Problem zu l√∂sen, muss die Liste nat√ºrlich irgendwie blockiert und der Zugriff darauf synchronisiert werden. Das zweite Problem - die Leistung - wird vorerst verschoben.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel wird nur das Blockieren der gesamten Liste durch einen Stream f√ºr den exklusiven Zugriff des Streams darauf ber√ºcksichtigt. Andere Optionen schienen beispielsweise aus folgenden Gr√ºnden zweifelhaft. Angenommen, wir haben eine doppelt verkn√ºpfte Liste und haben beschlossen, das Element daraus zu entfernen. Dazu m√ºssen Sie den Knoten selbst sowie den vorherigen und den n√§chsten blockieren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Moment, vor dem Start der Operation, l√∂scht ein anderer Thread nur beispielsweise den vorherigen Knoten. Wir blockieren das L√∂schen und warten nicht mehr auf die Freigabe des vorherigen Knotens, der von einem anderen Thread blockiert wurde. Und er ist blockiert, wenn er auf den n√§chsten wartet, d. H. unser gel√∂schter Knoten. Das war's, es ist eine Sackgasse. Diese Methode ist also nicht zuverl√§ssig.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihre Threads keine Zeiger (oder Iteratoren) auf bestimmte Knoten speichern, wird die Aufgabe extrem vereinfacht. Tats√§chlich k√∂nnen Sie nur mit STL-Tools arbeiten. Der Stream blockiert die Liste, verweist auf ein Element in ihm (z. B. von Anfang an, von Ende oder durch Suchen nach bestimmten Kriterien), verarbeitet oder entfernt dieses Element, f√ºgt neue hinzu, ohne Links zu diesen zu speichern. und vervollst√§ndigt dann die Liste. All dies - ausschlie√ülich den Zugriff auf die Liste in einem Thread blockieren und sie f√ºr die Dauer der erforderlichen Vorg√§nge besitzen. In diesem Fall ist es vollkommen logisch, die Sperrfunktionen std :: list und library zu verwenden. Bei alledem sollte beachtet werden, dass w√§hrend Ihr Thread alle erforderlichen Arbeiten ausf√ºhrt, andere Threads aufh√∂ren zu warten, d. H. Die Arbeit mit der Liste wird im Single-Thread-Modus ausgef√ºhrt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe ein anderes, komplexeres Szenario in Betracht gezogen, in dem ein Thread einen Zeiger oder Iterator auf das ben√∂tigte Element speichert. </font><font style="vertical-align: inherit;">Beispielsweise arbeitet Ihr Programm an einigen komplexen Berechnungen, indem es die Anfangsdaten aus dem Listenelement entnimmt und nach der Verarbeitung seinen Wert aktualisiert und dort die Berechnungsergebnisse hinzuf√ºgt. </font><font style="vertical-align: inherit;">Andere Threads haben jedoch auch Zugriff auf dieselbe Liste. </font><font style="vertical-align: inherit;">Ich habe keine Annahmen √ºber die Art der Anwendung getroffen: Ein anderer Thread kann dieses Element aus irgendeinem Grund leicht l√∂schen. </font><font style="vertical-align: inherit;">Oder verschieben Sie es an einen anderen Ort. </font><font style="vertical-align: inherit;">Das Arbeiten mit einer Liste wird daher nicht nur aus den √ºblichen Gr√ºnden des Multithreading und der Synchronisation problematisch.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem der Existenz eines Elements</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist der grundlegende Unterschied zwischen einer Liste und beispielsweise einem Array? In einer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verteilten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anordnung von Listenelementen. Alle Elemente des Arrays befinden sich in einem einzigen Speicherbereich. Selbst wenn Sie einen Zeiger auf einige seiner Elemente speichern, sind Sie sicher, dass der Zugriff auf seine Adresse korrekt ist (nat√ºrlich, wenn das Array nicht mit einer Erweiterung seiner Gr√∂√üe an einen anderen Speicherort verschoben wurde). Wenn der gew√ºnschte Artikel gel√∂scht oder in einen anderen Thread verschoben wird, gehen Sie einfach zur vorherigen Adresse, verstehen aus irgendeinem Grund, dass der ben√∂tigte Artikel nicht hier ist, und versuchen Sie dann, danach zu suchen usw. Nat√ºrlich muss das Programm eine solche Gelegenheit im Voraus unterst√ºtzen. In jedem Fall bleibt der Betrieb jedoch korrekt, solange Sie sich in den richtigen Speichergrenzen befinden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine v√∂llig andere Situation besteht im Fall einer Liste (sowie im Fall eines Baums, eines Graphen - einer beliebigen Datenstruktur mit verteilten Elementen). Wenn ein Element gem√§√ü Ihrem Zeiger in einem anderen Thread gel√∂scht wurde, wissen Sie nicht einmal davon. Wenn Sie versuchen, auf seine Adresse zuzugreifen, erhalten Sie (bestenfalls) eine Zugriffsverletzung. Selbst wenn es nicht tats√§chlich aus dem Speicher gel√∂scht wird (z. B. wenn intelligente Zeiger verwendet werden), wird es aus der Liste gel√∂scht, d. H. wird nicht Teil davon sein. Sie werden auch davon nichts wissen. Die korrekte Arbeit mit der Liste ist fehlerhaft. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gleichzeitig schafft die intensive Multithread-Arbeit mit der Liste absolut fantastische Szenarien. Sie k√∂nnen sogar sicher sein, dass mit Ihrem Element und einem Zeiger darauf alles in Ordnung ist - bis Sie auf eine Listenfunktion zugreifen, um damit zu arbeiten.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispiel. Es sei ein Teil der Liste vorhanden, und ein Zeiger auf den Knoten, den wir als (#) bezeichnen, wird auf eine Funktionslistenmethode √ºbertragen, w√§hrend die damit verbundenen Knoten durch relative Zahlen relativ dazu gekennzeichnet werden. Zum Zeitpunkt des Aufrufs der Funktion ist bekannt, dass dieses Element vorhanden ist und der Zeiger darauf korrekt ist, dh der Status der Liste in diesem Bereich lautet: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie nun den Knoten (#) als Parameter an eine Listenfunktion √ºbergeben werden. Diese Funktion wird wie gewohnt blockiert, w√§hrend auf den Zugriff gewartet wird. W√§hrend sie wartete, arbeiteten drei Threads vor ihr und l√∂schten den Knoten (#) zusammen mit den benachbarten, so dass es passierte: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yx/cx/x8/yxcxx8a21cbn2zlzko2uxgfzsb8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann f√ºgten weitere 5 Threads 5 weitere Elemente in die Liste ein, beginnend mit (-2). Wir bezeichnen die neuen Elemente als (nN), wobei N die relative Zahl unter den f√ºnf ist, beginnend bei Null:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pa/bj/s0/pabjs0rdzj9iz8irruceokozdbc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann wird endlich unser Stream aufgerufen, der mit (#) aufgerufen wurde. Die Frage ist: Was soll er in diesem Fall tun, nachdem (#) schon lange weg ist? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antwort: Es h√§ngt alles von der Operation sowie vom Szenario f√ºr die Verwendung der Liste ab. Da wir jedoch den allgemeinsten Fall ohne Einschr√§nkungen betrachten, k√∂nnen einige allgemeine Annahmen getroffen werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn es sich um einen L√∂schvorgang handelt, reicht es aus, einfach zu √ºberpr√ºfen, ob das angegebene Element in der Liste vorhanden ist. Wenn nicht, wurde es bereits gel√∂scht und es muss nichts weiter getan werden. Wenn ja, dann l√∂schen. √Ñhnliches gilt f√ºr das Lesen / √Ñndern des Inhalts des Knotens: Wenn der Knoten gel√∂scht wird, gibt es bereits nichts zu lesen / √§ndern. Die gr√∂√üten Probleme treten jedoch beim Einf√ºgen eines neuen Knotens sowie beim Wechseln zum n√§chsten / vorherigen auf. Einerseits ist der angegebene Knoten nicht mehr vorhanden, und ein Fehler kann zur√ºckgegeben werden. Andererseits muss der Knoten eingef√ºgt werden, und eine solche Situation kann jederzeit auftreten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die Priorit√§t (f√ºr den allgemeinen Fall) immer noch Sicherheit und Zuverl√§ssigkeit und erst dann Geschwindigkeit ist, m√ºssen Sie nat√ºrlich, wenn der Thread endlich die Betriebszeit innerhalb der Funktion erreicht hat, feststellen, ob ein Element in der Liste vorhanden ist: Existiert es √ºberhaupt dort oder nicht bereits? Dies l√∂st ein Problem: Zumindest werden wir nicht die gesamte Liste st√∂ren, wenn dort kein angeforderter Knoten vorhanden ist, und wir werden diesbez√ºglich Speicherzugriffsfehler vermeiden. Das Problem des Einf√ºgens und der √úberg√§nge wird jedoch nicht gel√∂st: Es ist nicht klar, wo ein neuer Knoten eingef√ºgt und von einem bereits gel√∂schten Knoten gewechselt werden soll.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die L√∂sung des Problems der Existenz des Elements wird nachstehend ausf√ºhrlich er√∂rtert. </font><font style="vertical-align: inherit;">Die Frage, was zu tun ist, wenn wir feststellen, dass das Element nicht mehr vorhanden ist, aber wirklich ben√∂tigt wird, geht √ºber den Rahmen dieses Artikels hinaus, da es vollst√§ndig vom Algorithmus der Arbeit mit dem Listenprogramm abh√§ngt. </font><font style="vertical-align: inherit;">Nat√ºrlich sollte es solche Szenarien und entsprechende Reaktionen darauf enthalten: Wenn beispielsweise kein Element vorhanden ist, gehen Sie zum Anfang der Liste oder f√ºhren Sie eine andere Operation aus. </font><font style="vertical-align: inherit;">Die Hauptsache, die in dieser Situation sichergestellt werden muss, ist der korrekte und sichere Betrieb der Liste sowie die Benachrichtigung √ºber solche Situationen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direkte Artikelsuche</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der einfachste und einfachste Ansatz besteht darin, das Vorhandensein eines Elements in der Liste zu √ºberpr√ºfen, indem Sie es nacheinander auf der Suche nach einem bestimmten Element durchlaufen. Jene. Ich suche nur nach dem gegebenen Element. Wenn er auf der Liste steht, arbeiten wir mit ihm zusammen. Wenn nicht, beenden wir je nach Funktion mit Erfolg oder Misserfolg und lassen das aufrufende Programm entscheiden, was in dieser Situation zu tun ist. Die Hauptsache ist, dass die Arbeit mit der Liste auf jeden Fall korrekt ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Methode ist sicher und voll funktionsf√§hig, f√ºhrt jedoch insbesondere bei gro√üen Listen zu einem katastrophalen Leistungsabfall. Tats√§chlich stellt sich heraus, dass die Arbeit mit der Liste Single-Threaded ist: Die Liste ist f√ºr die Dauer der Suche nach einem bestimmten Element in der Liste blockiert, und andere Threads k√∂nnen nicht darauf zugreifen. Zweitens steigen die Gemeinkosten stark an - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jeweils</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operationen mit der Liste m√ºssen pr√ºfen, ob zum Zeitpunkt der Operation ein Element erforderlich ist, und ein gro√üer Teil der Zeit wird nicht f√ºr n√ºtzliche Arbeiten aufgewendet, sondern f√ºr die √úberpr√ºfung des Vorhandenseins eines Elements. </font><font style="vertical-align: inherit;">Trotzdem ist dieser einfache, unkomplizierte Ansatz gut geeignet f√ºr Listen mit geringem Volumen und nicht zu intensiven Operationen damit sowie als erste Ann√§herung an die L√∂sung des Problems der Existenz eines Elements. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber was ist, wenn wir eine Liste mit einer gro√üen Anzahl von Elementen haben und sehr intensiv damit arbeiten: F√ºgen viele Threads st√§ndig Elemente hinzu, √§ndern und l√∂schen sie? </font><font style="vertical-align: inherit;">Gibt es eine M√∂glichkeit, es irgendwie zu beschleunigen?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicher oder Leistung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist bekannt, dass eine Erh√∂hung des vom Programm verwendeten Speichers die Geschwindigkeit des Programms erh√∂hen kann. Beispielsweise nutzt ein Programm die Ergebnisse einiger Berechnungen in hohem Ma√üe. Anstatt sie erneut auszuf√ºhren, k√∂nnen Sie alles im Voraus berechnen und ihre Ergebnisse in einer Tabelle oder einem Array speichern. Dann greift das Programm einfach auf die gew√ºnschte Zelle in der Tabelle zu und erh√§lt sofort den gew√ºnschten Wert, was seine Arbeit erheblich beschleunigt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diesen Ansatz habe ich im Fall der Liste verwendet. Erstellen Sie eine Bitmap. Wir f√ºgen den Serviceinformationen jedes seiner Elemente zus√§tzlich zum obligatorischen Zeiger auf das n√§chste und optional das vorherige Element zwei weitere neue Felder hinzu: Das erste ist die eindeutige Nummer in dieser Liste und das zweite ist ein Zeiger auf die Liste selbst. Wenn nun ein Element erstellt wird, wird ihm eine eindeutige Nummer zugewiesen und die Einheit in der Bitmap auf den entsprechenden Index gesetzt. Wenn ein Element gel√∂scht wird, wird dieses Bit zur√ºckgesetzt. Die Anzahl der erstellten Elemente nimmt jedes Mal stetig zu, wenn ein neues Element erstellt wird - bereits verwendete Null-Bits werden nicht wiederverwendet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn es nun erforderlich ist, das Vorhandensein eines bestimmten Elements zu √ºberpr√ºfen, anstatt es linear in der gesamten Liste zu durchsuchen, wird einfach √ºber den Index dieses Elements auf eine Bitmap zugegriffen, und die Tatsache seines Vorhandenseins wird sofort und f√ºr eine konstante Zeit unabh√§ngig von der Gr√∂√üe der Liste festgestellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Methode erm√∂glicht es Ihnen, maximale Leistung zu erzielen, hat jedoch ihre schwerwiegenden Nachteile. Zun√§chst m√ºssen Sie Speicher f√ºr das gesamte Array auf einmal zuweisen, von dem ein Teil der Bits w√§hrend des Programms m√∂glicherweise √ºberhaupt nicht ben√∂tigt wird. Dieser Speicher kann jedoch f√ºr andere Anforderungen verwendet werden. Dieses Problem und eine M√∂glichkeit, Speicher√ºberschreitungen auszugleichen, werden nachstehend erl√§utert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite Nachteil ist schwerwiegender und interessanter: Jedes neue Listenelement wird durch eine monoton ansteigende Zahl erstellt. Dies bedeutet, dass fr√ºher oder sp√§ter die freien Bits des Arrays ersch√∂pft sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An diesem Punkt m√ºssen Sie leider anhalten, die Liste blockieren und mit dem Servieren beginnen. Jene. Komprimieren Sie die Bits dieses Arrays, indem Sie alle Nullbits aus zuvor gel√∂schten Listenelementen entfernen, wobei nur die Bits f√ºr die derzeit tats√§chlich vorhandenen Elemente √ºbrig bleiben, und verschieben Sie alle diese Bits an den Anfang des Arrays. Wir m√ºssen die gesamte Liste erneut durchgehen und im Single-Thread-Modus alle Indizes f√ºr jedes Element neu schreiben. Der offensichtliche Vorteil gegen√ºber dem vorherigen Ansatz besteht darin, dass in diesem Fall nur </font><b><font style="vertical-align: inherit;">einer durchgef√ºhrt</font></b><font style="vertical-align: inherit;"> wird.</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeiten √ºber einen langen Zeitraum. </font><font style="vertical-align: inherit;">Au√üerdem kann die Liste im extrem schnellen Modus wie zuvor weiterarbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nat√ºrlich meine ich nicht, dass die Knoten nur zur Liste hinzugef√ºgt wurden, weil </font><font style="vertical-align: inherit;">In diesem Fall sind alle Bits des Arrays einzeln. </font><font style="vertical-align: inherit;">Ich denke an ein Szenario, in dem Elemente intensiv und willk√ºrlich gel√∂scht und hinzugef√ºgt werden. </font><font style="vertical-align: inherit;">Jene. </font><font style="vertical-align: inherit;">Die Gesamtzahl der Listenelemente seit Beginn ihrer Arbeit kann sich geringf√ºgig √§ndern. </font><font style="vertical-align: inherit;">Nat√ºrlich h√§ngt die Frage der Auswahl der Gr√∂√üe des Arrays von der Art des Programms ab. </font><font style="vertical-align: inherit;">Sie k√∂nnen auch jederzeit ein neues Array mit einem gr√∂√üeren Volume erstellen, wenn die Gr√∂√üe des aktuellen Volumes nicht ausreicht.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden von Nullbits aus zuvor gel√∂schten Elementen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen dies auch auf andere Weise tun: Suchen Sie beim Erstellen eines Elements nach dem ersten Nullbit am Anfang der Bitmap. Dies optimiert den Speicherverbrauch, f√ºhrt jedoch zu einem Leistungsabfall: Jedes Mal, wenn Sie ein neues Element erstellen, m√ºssen Sie zus√§tzliche Arbeit leisten - durchsuchen Sie das Array nach einem freien Bit. Im Vergleich zur √úberpr√ºfung des Vorhandenseins eines Elements durch direktes Anzeigen der Liste ist der Gewinn jedoch offensichtlich: Wir werden uns das </font><b><font style="vertical-align: inherit;">Array</font></b><font style="vertical-align: inherit;"> ansehen</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benachbarte Elemente, und jedes Element eines solchen Arrays enth√§lt viele Bits, d.h. </font><font style="vertical-align: inherit;">Wir verarbeiten viele Listenknoten gleichzeitig (64 Bit f√ºr moderne Systeme oder sogar 128/256/512 bei Verwendung von SSE / AVX). </font><font style="vertical-align: inherit;">Wir suchen nach dem ersten Wort, das nicht mit allen Einheitsbits gleich dem Wort ist, dann suchen wir nach dem ersten Nullbit in diesem Wort. </font><font style="vertical-align: inherit;">Tats√§chlich hat diese Methode eine mittlere Geschwindigkeit zwischen der vorherigen und der direkten Betrachtungsmethode.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherverbrauchsoptimierung f√ºr nicht belegte Array-Bits</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir gehen von einer langen und intensiven Arbeit mit der Liste aus und weisen ihr eine gro√üe Anzahl von Bits zu. Es kam jedoch vor, dass das Programm tats√§chlich anders funktionierte: Es griff selten auf die Liste zu und f√ºhrte andere Operationen aus, die ebenfalls Speicher ben√∂tigten. Infolgedessen erhalten wir in anderen Teilen des Programms ein fast unbenutztes Array von Bits mit gro√üen Volumen- und Speicherproblemen. Blo√üe Unannehmlichkeiten! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soweit ich das beurteilen kann, l√∂st Linux dieses Problem automatisch (obwohl erfahrene Linux-Entwickler es mir erlauben, es zu beheben, wenn dies der Fall ist). Sie weisen dem Array Speicher zu, aber tats√§chlich </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºbertr√§gt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das System diesen Speicher erst dann auf das Array, </font><font style="vertical-align: inherit;">wenn er wirklich ben√∂tigt wird. Es gibt eine Optimierung der Speichernutzung. Windows erlaubt dies nicht. Vielmehr erlaubt es, aber Sie m√ºssen es selbst tun.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr diejenigen, die √ºberhaupt nicht auf dem neuesten Stand sind, erkl√§re ich: Ihre Anwendung (genauer gesagt der entsprechende Prozess) weist dem System einen </font><font style="vertical-align: inherit;">gro√üen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtuellen Adressraum zu</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - bis zu 8 TB f√ºr 64-Bit-Windows. Der physische Speicher im System kann viel geringer sein - derzeit 8 oder 16 GB f√ºr Massencomputer. Betriebssystem - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Displays</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adressen Ihres virtuellen Prozessraums an Adressen des physischen Speichers, und zwar auf transparente Weise ohne Ihre direkte Beteiligung. Nat√ºrlich ist der gr√∂√üte Teil des freien virtuellen Speichers eines Prozesses normalerweise nicht belegt. Wenn Sie Windows auffordern, Speicher auf herk√∂mmliche Weise zuzuweisen, wird dieser Speicher gleichzeitig sowohl in Ihrem virtuellen Raum als auch im physischen Speicher zugewiesen. Wenn Sie eine Bitmap mit gro√üem Volumen zuweisen, besteht die Gefahr, dass Sie sofort den gesamten verf√ºgbaren Speicher Ihres Computers belegen, ohne zu gew√§hrleisten, dass dieser Speicher √ºberhaupt ben√∂tigt wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Man kann jedoch anders vorgehen: Markieren Sie einen gro√üen Teil des Speichers im virtuellen Raum des Prozesses, √ºbertragen Sie ihn jedoch nur dann physisch, wenn er wirklich ben√∂tigt wird. </font><font style="vertical-align: inherit;">Dies kann durch strukturelle Ausnahmebehandlung in Windows erfolgen. Einzelheiten finden Sie im Buch von Richter D., Nazar K. - ‚ÄûWindows √ºber C / C ++, Visual C ++ - Programmierung‚Äú.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies w√§re nur eine Idee und eine Theorie, wenn ich nicht alle diese Ideen in die Praxis umgesetzt h√§tte und nicht in Form eines einfachen experimentellen Programms: Ich habe es so sorgf√§ltig wie m√∂glich f√ºr die Produktion gemacht und beabsichtigt, es in meinen realen Projekten zu verwenden, daher brauchen Sie es in dieser Form und stell dir vor. </font><font style="vertical-align: inherit;">Ich dachte, es w√§re unfair und zu egoistisch, das anzuwenden, was in meiner begrenzten Anzahl von Projekten getan wurde, wenn dies f√ºr einen breiten Kreis von Entwicklern n√ºtzlich oder zumindest nur interessant sein k√∂nnte. </font><font style="vertical-align: inherit;">Auf der anderen Seite bieten die Sch√∂pfer der Boost-Bibliothek und anderer spezialisierter Bibliotheken ihre Arbeit jedem absolut kostenlos an. </font><font style="vertical-align: inherit;">Warum kann ich das nicht auch tun?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstraktion - eine Liste ohne Daten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe die Liste in zwei logische Ebenen unterteilt. Die erste Ebene ist eine Liste, von der jedes Element keine n√ºtzlichen Daten enth√§lt, sondern nur Zusatzinformationen: Zeiger auf benachbarte Elemente und optional diese beiden zus√§tzlichen Felder, um die √úberpr√ºfung auf das Vorhandensein eines Elements in der Liste zu beschleunigen. Bereits auf dieser Ebene k√∂nnen jedoch alle grundlegenden Vorg√§nge f√ºr eine Liste ausgef√ºhrt werden: Hinzuf√ºgen und L√∂schen von Elementen, Aufteilen und Zusammenf√ºhren von Listen usw. Tats√§chlich habe ich mich haupts√§chlich auf diese Ebene konzentriert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite Ebene besteht darin, dem Listenelement tats√§chliche Daten hinzuzuf√ºgen und der Liste neue Vorg√§nge hinzuzuf√ºgen, um mit diesen Daten zu arbeiten. All dies wird in C ++ durch Vererbung bereitgestellt. Aber die Details werden unten diskutiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine solche Aufteilung der Implementierung in zwei Ebenen war sinnvoll: Warum sollte die Verf√ºgbarkeit bestimmter Daten ber√ºcksichtigt werden, wenn eine Reihe von Vorg√§ngen v√∂llig unabh√§ngig von diesen Daten sind? F√ºr bestimmte Listenelemente m√ºssen Sie diese noch l√∂schen und neue zur Liste hinzuf√ºgen sowie andere typische Vorg√§nge ausf√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich begann mit einem √§u√üerst einfachen und unkomplizierten Konzept, das der C-Sprachkonstruktion am Anfang des Artikels entnommen wurde. Sowohl interne C- als auch C ++ - Zeiger werden sowohl innerhalb als auch au√üerhalb der Liste verwendet. Der einzige Unterschied bestand darin, dass das Hinzuf√ºgen von Daten, wie oben angegeben, auf einen sp√§teren Zeitpunkt verschoben wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es soll ein Element der Liste ohne Daten geben, das nur einen Zeiger (oder Zeiger) auf die benachbarten Elemente enth√§lt. Dann kann der entsprechende Code daf√ºr wie folgt schematisch dargestellt werden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span>	<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListElement_OneLinked</span>			//   ( )
{</span>
	ListElement_OneLinked *pNext;	<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>		// 
{</span>
	<span class="hljs-comment">//</span><font></font>
<font></font>
        <span class="hljs-comment">//   </span>
	ListElement *pFirst = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span>
	ListElement *pLast = <span class="hljs-literal">nullptr</span>;			<span class="hljs-comment">//   </span><font></font>
<font></font>
	SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//    </span><font></font>
<font></font>
	&lt;‚Ä¶m- () &gt;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Element f√ºr eine einfach verkn√ºpfte Liste enth√§lt in sich einen Zeiger auf das n√§chste Element und nichts weiter. Die Listenklasse wird durch den Typ dieses Elements parametrisiert, was bedeutet, dass dieser Typ beim Hinzuf√ºgen von Daten ge√§ndert wird. Es enth√§lt Zeiger auf das erste und das letzte Element im Inneren. Da ich dieses Projekt urspr√ºnglich nur f√ºr Windows ins Visier genommen habe, ist auch ein kritischer Abschnitt wie SRWLock enthalten, um die Liste zu blockieren. Als n√§chstes werden die Konstruktoren, der Destruktor sowie alle notwendigen Funktionen zum Arbeiten mit der Liste definiert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Implementierung enth√§lt zwei Probleme gleichzeitig. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste ist der offene Zugriff auf den Inhalt der Dienstinformationen des Elements. Dies bedeutet, dass nach dem Zugriff auf einen Knoten, d.h. Mit einem Zeiger auf diesen Knoten k√∂nnen wir direkt auf das n√§chste oder vorherige Element verweisen.</font></font><br>
<br>
<i>       <b></b>.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist haupts√§chlich deshalb nicht akzeptabel, weil dieser √úbergang die Sperre umgeht und daher die Liste sch√ºtzt. Angenommen, wir haben einen Zeiger auf ein pCurr-Element und haben den Wert im pNext-Zeiger wie folgt relativ zum n√§chsten Element gespeichert: pNext = pCurr-&gt; pNext. Danach f√ºhren wir eine l√§ngere Operation an diesem pCurr-Knoten durch. Gleichzeitig haben andere Threads die folgenden Listenelemente in Bezug auf pCurr entfernt. Nach Beendigung der Arbeit mit pCurr wechselt der aktuelle Thread mit dem im lokalen pNext gespeicherten alten Wert zum n√§chsten Element und erh√§lt einen Zugriffsfehler oder ein undefiniertes Verhalten, da das Element an der lokalen pNext-Adresse nicht mehr vorhanden ist und Sie auf den aktualisierten Wert pCurr-&gt; pNext zugreifen m√ºssen. wenn das aktuelle Element bei pCurr wiederumexistiert auch noch.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus diesem Beispiel k√∂nnen zwei Schlussfolgerungen gezogen werden, um diese Situation zu verhindern:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wechseln Sie von au√üerhalb der Liste zum n√§chsten / vorherigen Knoten und arbeiten Sie im Allgemeinen nur mit Listenelementen √ºber die Funktionen (Methoden) der Listenklasse, die die Liste sperren und den Zugriff auf die Liste sicher machen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Greifen Sie unmittelbar vor dem Zugriff so schnell wie m√∂glich auf die Elemente zu (z. B. erhalten Sie einen Zeiger auf das n√§chste Element pNext = list.GetNext (pCurr) nicht im Voraus, sondern unmittelbar bevor die Notwendigkeit zum n√§chsten Knoten angezeigt wird).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Schlussfolgerung aus dem ersten Absatz umzusetzen, sollte daher der Zugriff auf Zeiger auf benachbarte Elemente von au√üen verboten werden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement_OneLinked *pNext;		<span class="hljs-comment">//    	</span><font></font>
<font></font>
<span class="hljs-keyword">friend</span> List_OneLinked;    <span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite Problem ist etwas heikler. Um dies zu verstehen, sollte die Struktur der Klassen genauer beschrieben werden. Die Listenklasse ist als Vorlage definiert und funktioniert nicht mit Elementen vom Typ ListElement_OneLinked, sondern mit dem Typ ListElement, der als Vorlagenparameter √ºbergeben wird. Dies geschieht, um neue Knoten mit Daten innerhalb der Klasse erstellen zu k√∂nnen. Dazu m√ºssen Sie den genauen Typ des zu erstellenden Knotens kennen. Der genaue Typ des Listenknotens ist noch nicht bekannt: Er wird sp√§ter zusammen mit den Daten ermittelt. Die Elementerstellungsfunktion reserviert Speicher daf√ºr, initialisiert Zeiger und gibt dann einen Zeiger auf das erstellte Element in der aufrufenden Funktion zur√ºck. In der aufrufenden Funktion der abgeleiteten Klasse k√∂nnen also andere Eigenschaften des Elements initialisiert werden, die f√ºr diese Klasse spezifisch sind und sp√§ter definiert werden. Mit anderen Worten,Eine genaue Definition des Typs des Listenknotens bleibt f√ºr die Zukunft erhalten. Damit die Liste ordnungsgem√§√ü funktioniert, ist es nur wichtig, dass ihre Elemente den pNext-Zeiger enthalten, der Rest spielt bisher keine Rolle.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der Grundlage von ListElement_OneLinked wird anschlie√üend durch Vererbung eine neue Klasse f√ºr das Element mit bestimmten Daten erstellt und √ºber den Vorlagenparameter an die List_OneLinked-Klasse √ºbergeben. Gleichzeitig wird basierend auf List_OneLinked eine neue abgeleitete Klasse erstellt, die Operationen mit diesen neuen Daten weiter definiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst diese Option ist jedoch nicht ganz korrekt. In fr√ºheren Versionen der Listenklasse wurde mehrmals eine explizite Konvertierungsoperation vom Typ reinterpret_cast &lt;ListElement *&gt; (...) verwendet. Tatsache ist, dass die Vorlagenklasse mit dem ListElement-Vorlagenparametertyp arbeitet, der von ListElement_OneLinked / ListElement_TwoLinked abgeleitet ist. Und in Klassenfunktionen werden Variablen in Ausdr√ºcken vom Typ erstellt: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ListElement * pNext = pCurr-&gt; pNext;</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und pCurr-&gt; pNext hier ist ein Zeiger auf ListElement_OneLinked / ListElement_TwoLinked als Mitglieder der Basisklassen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ausgabe: Deklarieren Sie entweder eine Variable, die den expliziten Basistyp ListElement_OneLinked / ListElement_TwoLinked angibt, oder wandeln Sie sie explizit in den abgeleiteten Typ um. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich ist sogar eine explizite Definition des Basistyps nicht korrekt, z. B. in der Funktion zum L√∂schen (Bereinigen) von Listen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   </span><font></font>
ListElement *pCurr = pFirst;<font></font>
ListElement *pNext = <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
{<font></font>
	pNext = <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr-&gt;pNext);
	<span class="hljs-keyword">delete</span> pCurr;<font></font>
	pCurr = pNext;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie den Zeigertyp √§ndern:</font></font><br>
<br>
<pre><code class="cpp hljs">ListElement_OneLinked *pCurr = pFirst;<font></font>
ListElement_OneLinked *pNext = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass sie von der Operation gel√∂scht werden</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> pCurr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nur die Basisteile jedes Knotens in der Liste, was falsch ist. </font><font style="vertical-align: inherit;">Optional muss der pCurr-Zeiger in seinen abgeleiteten Typ konvertiert werden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;ListElement *&gt;(pCurr);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher kann man die explizite reinterpret_cast-Transformation mit einer solchen Klassenstruktur auf keinen Fall loswerden, was nicht die beste L√∂sung ist (genauer gesagt, was wirklich schlecht ist). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus diesem Grund wurde beschlossen, die Basisklasse f√ºr das Element zu √§ndern, um solche expliziten Transformationen zu vermeiden (f√ºr eine doppelt verkn√ºpfte Liste - √§hnlich):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked</span>	//   ( )
{</span>
	ListElement *pNext;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">friend</span> List_OneLinked&lt;ListElement&gt;;	<span class="hljs-comment">//         	</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz gesagt kann dies wie folgt beschrieben werden: Das Grundelement der Liste enth√§lt einen Zeiger auf ein anderes Element, aber der Typ dieses Zeigers ist noch nicht bekannt, da er vom Vorlagenparameter √ºbergeben wird (eine genaue Definition dieses Typs bleibt f√ºr die Zukunft √ºbrig). Mit anderen Worten: Zu diesem Zeitpunkt wurde der Typ des Listenknotens (d. H. Was er am Ende sein wird) noch nicht bestimmt, er wird sp√§ter bestimmt. Aber jetzt behalten wir den Zeiger auf ein Element des zuk√ºnftigen, noch nicht bekannten Typs. Der resultierende Typ des Listenknotens wird hier als Vorlagenparameter √ºbergeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt sind keine Konvertierungen mehr erforderlich, da √ºberall Zeiger desselben ListElement-Typs verwendet werden - sowohl in der Listenklasse als auch in der Klasse f√ºr Knoten. Das ListElement hier und in der Listenklasse ist die letzte Klasse f√ºr das Element mit bestimmten Daten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass die Listenklasse nun von ihrem spezifischen Inhalt so abstrakt wie m√∂glich geworden ist: Es ist nur bekannt, dass ihre Knoten Zeiger auf andere solche Knoten enthalten, und unter Verwendung dieser Informationen werden alle grundlegenden Operationen an der Listenklasse mit entsprechender Multithread-Sperre ausgef√ºhrt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem der Existenz eines Elements l√∂sen - eine einfache Suche (Version 01.03.2018)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste Version war √§u√üerst einfach und unkompliziert und ging nicht √ºber das oben beschriebene Framework hinaus. </font><font style="vertical-align: inherit;">Es wurden interne C ++ - Zeiger verwendet, der Speicher f√ºr Elemente wurde mit der neuen Operation zugewiesen und mit delete gel√∂scht. Die Liste wurde in dem darin enthaltenen kritischen Abschnitt blockiert. </font><font style="vertical-align: inherit;">Ich wusste oder ahnte nichts √ºber die Mittel der STL-Bibliothek und auch √ºber die Ebene, auf der sie die Programmierung in C ++ bringen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bereits zu diesem Zeitpunkt stie√ü ich in der Praxis auf das Problem der Existenz eines zuvor beschriebenen Elements und stellte fest, dass das einfache Sperren der Liste nicht ausreicht. </font><font style="vertical-align: inherit;">Ich habe die Liste mit den entsprechenden Funktionen mit allen Vorsichtsma√ünahmen durchsucht, die Liste wurde korrekt blockiert, aber das Programm st√ºrzte in verschiedenen Intervallen immer noch erfolgreich ab. </font><font style="vertical-align: inherit;">Damals fand ich heraus, dass das Vorhandensein eines Elements √ºberpr√ºft werden musste, was zu einer √Ñnderung der Logik der Schl√ºsselfunktionen f√ºhrte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie mich ein Beispiel f√ºr die Funktion des Hinzuf√ºgens eines Elements nach einem bestimmten geben:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">ListElement* <span class="hljs-title">AddAfter</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-title">throw</span> <span class="hljs-params">(FailElemCreation, Nullptr, NotPartOfList)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();			<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListExclusive();<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (!FindElement(pElem, <span class="hljs-literal">true</span>))<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
	}<font></font>
<font></font>
	ListElement *pCurr = <span class="hljs-keyword">new</span> ListElement;
	<span class="hljs-keyword">if</span> (!pCurr)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			UnlockListExclusive();<font></font>
		<span class="hljs-keyword">throw</span> FailElemCreation();		<span class="hljs-comment">//        </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//,      </span>
	<span class="hljs-keyword">if</span> (pFirst == <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		pFirst = pLast = pCurr;<font></font>
		pCurr-&gt;pNext = <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
	<span class="hljs-keyword">else</span><font></font>
	{<font></font>
		<span class="hljs-comment">//         </span><font></font>
		ListElement *pNext = pElem-&gt;pNext;<font></font>
		pElem-&gt;pNext = pCurr;<font></font>
		pCurr-&gt;pNext = pNext;<font></font>
		<span class="hljs-comment">//,     </span>
		<span class="hljs-keyword">if</span> (pElem == pLast)<font></font>
			pLast = pCurr;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListExclusive();<font></font>
<font></font>
	<span class="hljs-keyword">return</span> pCurr;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist ersichtlich, dass vor dem Erstellen eines neuen Elements durch Aufrufen der Funktion FindElement (...) √ºberpr√ºft wird, ob das angegebene Element in der Liste vorhanden ist:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FindElement</span><span class="hljs-params">(ListElement* <span class="hljs-keyword">const</span> pElem, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-title">throw</span> <span class="hljs-params">(Nullptr)</span>
</span>{	
	<span class="hljs-keyword">if</span> (!pElem)
		<span class="hljs-keyword">throw</span> Nullptr();	<span class="hljs-comment">//     ( )</span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span><font></font>
	ListElement *pCurr = pFirst;<font></font>
	<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">while</span> (pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (pCurr == pElem)<font></font>
		{<font></font>
			bResult = <span class="hljs-literal">true</span>;
			<span class="hljs-keyword">break</span>;<font></font>
		}<font></font>
		pCurr = pCurr-&gt;pNext;<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">return</span> bResult;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Komplikation von Multithread-Listenklassen - Strategieklassen (Version 18.02.2019, 11.27.2019)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Projekt richtete sich zun√§chst ausschlie√ülich an Windows. Aber irgendwann dachte ich mir, warum nicht mehr Flexibilit√§t hinzuf√ºgen? Warum nur Fenster? Immerhin wurde die Liste im Wesentlichen in reinem C ++ implementiert, unter Windows hatte sie nur eines: den kritischen Abschnitt von SRWLock. Zu diesem Zeitpunkt war ich bereits mit dem Konzept der Strategieklassen vertraut. Sie k√∂nnen dies ausf√ºhrlich im Buch Alexandrescu A. - "Modernes Design in C ++" lesen. Es beschreibt viele ungew√∂hnliche und erstaunliche Dinge, die auch jetzt noch n√ºtzlich sein k√∂nnen, obwohl das Buch bereits 12 Jahre alt ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine davon sind die Klassen von Strategien. Klassen von Strategien sind in der Tat √Ñnderungen im Verhalten einer Klasse durch Vorlagen, wie B. Straustrup in seinem ber√ºhmten Buch erw√§hnte. Nur im Buch Alexandrescu ist dieses Thema weit verbreitet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, Ihre Klasse f√ºhrt eine bestimmte Aktion aus. </font><font style="vertical-align: inherit;">Sie k√∂nnen die Definition dieser Aktion au√üerhalb der Klasse √ºbernehmen, basierend auf dieser Aktion eine separate Klasse erstellen und diese als Vorlagenparameter an Ihre Quellklasse √ºbergeben. </font><font style="vertical-align: inherit;">Dies erschwert den Code, das Lesen und Verstehen, erh√∂ht jedoch die Flexibilit√§t Ihrer Klasse erheblich: Um diese bestimmte Aktion durch eine andere, √§hnliche zu ersetzen, m√ºssen Sie lediglich eine andere √§hnliche Strategie schreiben und sie als Vorlagenparameter an Ihre Klasse √ºbergeben. </font><font style="vertical-align: inherit;">Der Rest der Arbeit wird vom Compiler erledigt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strategie sperren</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich dies auf die beschriebene Liste angewendet hatte, nahm ich die Sperre durch SRWLock in eine separate Strategie und schrieb dann mehrere andere Strategien: durch den √ºblichen kritischen Abschnitt von Windows, durch C ++ STL-Mutexe usw. </font><font style="vertical-align: inherit;">Dann k√∂nnen rein Linux-spezifische Methoden hinzugef√ºgt werden. </font><font style="vertical-align: inherit;">Somit ist die Klasse nicht nur f√ºr Windows geeignet, sondern ich kann sie immer sehr schnell und optimal f√ºr Windows neu konfigurieren, indem ich einfach die gew√ºnschte Strategie spezifiziere.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//    SRWLock</span>
<span class="hljs-comment">//     SRWLock -   ,      (      </span>
<span class="hljs-comment">//   : ++11)</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLockingWin_SRWLock</span>			//    <span class="hljs-title">SRWLock</span>
{</span>
	<span class="hljs-keyword">mutable</span> SRWLOCK csSRW = { <span class="hljs-number">0</span> };	<span class="hljs-comment">//     SRWLock</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ThreadLockingWin_SRWLock(<span class="hljs-keyword">bool</span> bInitialize = <span class="hljs-literal">true</span>)<font></font>
	{<font></font>
		<span class="hljs-comment">//; bInitialize -  ,     </span>
		<span class="hljs-keyword">if</span>(bInitialize)<font></font>
			InitializeSRWLock(&amp;csSRW);		<span class="hljs-comment">//   SRWLock</span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockExclusive</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		AcquireSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UnlockShared</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>				<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ReleaseSRWLockShared(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Lock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>						<span class="hljs-comment">//  </span>
	</span>{<font></font>
		AcquireSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Unlock</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//  </span>
	</span>{<font></font>
		ReleaseSRWLockExclusive(&amp;csSRW);<font></font>
	}<font></font>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherstrategie</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diesen Punkt herum begann ich auch ernsthaft, STL zu studieren, und als eines der ersten Werkzeuge dieser Bibliothek lernte ich intelligente Zeiger kennen. </font><font style="vertical-align: inherit;">Und dann dachte ich: Warum kann ich meiner Liste keine Unterst√ºtzung f√ºr intelligente Zeiger hinzuf√ºgen? </font><font style="vertical-align: inherit;">Dann nahm ich den Zeigertyp heraus und erstellte und l√∂schte die Daten des Listenelements in einer separaten Strategie:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        C/++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>   <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type[]&gt;   //   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> Type* <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Type[size];
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>	  <span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span> ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Type* ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(Type *ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span>(ptr)
			<span class="hljs-keyword">delete</span>[] ptr;		<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_InternalPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_InternalPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">InternalPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = Type * ;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;		<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;			<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = ptrType;		<span class="hljs-comment">//   </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-comment">// : Args - -     Type</span>
		<span class="hljs-comment">// :      Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//   ,       </span>
		<span class="hljs-comment">// : pObject -      , DeleterFunc -   -</span><font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pObject)<font></font>
		{<font></font>
			Deleter::Delete(pObject);		<span class="hljs-comment">//     </span>
			pObject = <span class="hljs-literal">nullptr</span>;<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> &amp;obj;<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine √§hnliche Strategie f√ºr intelligente Zeiger:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//        shared_ptr/weak_ptr ++</span><font></font>
<font></font>
<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>			<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type&gt;(Args...);<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt; <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{
		<span class="hljs-keyword">if</span> (size != <span class="hljs-number">0</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;Type[]&gt;(size);
		<span class="hljs-keyword">else</span>
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type[]&gt;	//   
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;* ptr)</span> <span class="hljs-keyword">noexcept</span>		<span class="hljs-comment">// ,         unique_ptr</span>
	</span>{<font></font>
		Delete(*ptr);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;&amp; ptr)</span> <span class="hljs-keyword">noexcept</span>	<span class="hljs-comment">//    </span>
	</span>{<font></font>
		ptr = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">// ,     ,    </span><font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// ,    ,    Type </span>
<span class="hljs-comment">//Deleter  Allocator -         Type</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Deleter</span> = <span class="hljs-title">DefaultDeleter_SmartSharedPointer</span>&lt;Type&gt;, <span class="hljs-title">class</span> _<span class="hljs-title">Allocator</span> = <span class="hljs-title">DefaultAllocator_SmartSharedPointer</span>&lt;Type&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">SmartSharedPointer</span>
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> ptrType = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;;			<span class="hljs-comment">//    </span>
	<span class="hljs-keyword">using</span> Allocator = _Allocator;					<span class="hljs-comment">// </span>
	<span class="hljs-keyword">using</span> Deleter = _Deleter;						<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-keyword">using</span> shared_ptrType = ptrType;				<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">using</span> weak_ptrType = <span class="hljs-built_in">std</span>::weak_ptr&lt;Type&gt;;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-comment">//</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... ArgTypes&gt; <span class="hljs-keyword">static</span> ptrType <span class="hljs-title">Create</span><span class="hljs-params">(ArgTypes... Args)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//       </span>
		<span class="hljs-keyword">return</span> Allocator::Create(Args...);	<span class="hljs-comment">//      </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(ptrType&amp; pObject)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      ;   -  ,    ,    </span>
		<span class="hljs-comment">// </span>
		Deleter::Delete(pObject);	<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">static</span> ptrType <span class="hljs-title">MakePointer</span><span class="hljs-params">(Type&amp; obj)</span> <span class="hljs-keyword">noexcept</span>
	</span>{
		<span class="hljs-comment">//      </span>
		<span class="hljs-comment">// :     Type</span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Type&gt;(&amp;obj);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Speicherstrategie verwendet drei Parameter: den Typ des Type-Objekts sowie einen Speicherzuweiser und -entferner. Basierend auf dem Objekttyp erstellt die Strategie einen Zeigertyp auf diesen Typ - je nach Strategie entweder Typ * oder std :: shared_ptr - und bietet auch die entsprechenden Funktionen zum Erstellen und L√∂schen des Objekts. Wenn wir standardm√§√üig von Verteilern und L√∂schern sprechen, erstellen diese Funktionen ein Objekt entweder √ºber die neue Type-Operation oder √ºber die Funktion std :: make_shared (...). All dies funktioniert aufgrund der Tatsache, dass die Zeiger-Dereferenzierung sowohl f√ºr den in C ++ integrierten Zeiger als auch f√ºr den intelligenten std :: shared_ptr gleich ist. Nat√ºrlich wird im Fall einer doppelt verkn√ºpften Liste und intelligenter Zeiger std :: schwach_ptr f√ºr Zeiger auf das vorherige Element verwendet, um die unangenehme Funktion von Schleifenzeigern zu vermeiden.Zum Zeitpunkt der Kompilierung einer doppelt verkn√ºpften Liste k√∂nnen Sie abh√§ngig von der ausgew√§hlten Speicherstrategie festlegen, wie diese dereferenziert werden soll (dies ist eine neue Funktion von C ++ 17):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  pPrev  weak_ptr,          shared_ptr    lock()</span>
<span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, SmartSharedPointer&lt;ListElement&gt;&gt;)</span>		<span class="hljs-comment">//C++17: if constexpr</span>
	pFirst-&gt;pPrev.<span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>= <span class="hljs-literal">nullptr</span>;
<span class="hljs-keyword">else</span>
	pFirst-&gt;pPrev = <span class="hljs-literal">nullptr</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit erstellt die Liste jetzt keine eigenen Elemente: Sie leitet den Aufruf an die entsprechende Strategie weiter.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikelverf√ºgbarkeitsstrategie</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nat√ºrlich habe ich eine L√∂sung f√ºr das Problem der Existenz eines Elements in einer separaten Strategie gefunden: Wenn die Liste das Vorhandensein einiger ihrer Elemente √ºberpr√ºfen muss, leitet sie den Aufruf einfach an die entsprechende Strategie weiter. Der allererste, unkomplizierte und ungeschickte Ansatz wurde zu einer DirectSearch-Direktsuchstrategie. Als n√§chstes entwickelte ich zwei weitere Strategien basierend auf den beiden zuvor beschriebenen Ans√§tzen mit einer Bitmap in der Reihenfolge ihrer Beschreibung: SearchByIndex_BitArray und SearchByIndex_BitArray2. F√ºr Windows f√ºgte er zwei weitere Strategien hinzu, um den Speicher w√§hrend des F√ºllens schrittweise mit einer Bitmap zu </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
belegen </font><font style="vertical-align: inherit;">: </font><font style="vertical-align: inherit;">SearchByIndex_BitArray_MemoryOnRequestLocal und SearchByIndex_BitArray2_MemoryOnRequestLocal.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erw√§hnt, muss das Listenelement einen Index in einer Bitmap und einen Zeiger auf die Basisklasse der Liste enthalten (siehe unten), damit diese erweiterten Strategien funktionieren. </font><font style="vertical-align: inherit;">wurde wie folgt definiert:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//          </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElement_OneLinked_CP</span>			//   ( )
{</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext;	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex;	<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt; *pList;		<span class="hljs-comment">//  - </span><font></font>
<font></font>
	<span class="hljs-comment">//          ;    ,   </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked</span>;</span><font></font>
<font></font>
	<span class="hljs-comment">//    "+" </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt; <span class="hljs-title">operator</span>+&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;(<span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;, <span class="hljs-title">List_OneLinked</span>&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy&gt;&amp;) <span class="hljs-title">noexcept</span>;</span>	<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-comment">//        </span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">DirectSearch</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray</span>;</span>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">SearchByIndex_BitArray2</span>;</span>
};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Korrelation zwischen Speicherstrategien und Elementpr√ºfstrategien</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei einer eingehenden Untersuchung stellte sich heraus, dass die Beziehung zwischen Speicherstrategien und Strategien zur √úberpr√ºfung des Vorhandenseins eines Elements eine Falle darstellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, Sie verwenden intelligente Zeiger als Speicherstrategie sowie eine Strategie, die eine Bitmap verwendet, um schnell nach einem Element in einer Liste zu suchen. Wenn Sie ein Element l√∂schen, setzt die Speicherstrategie den Zeiger zur√ºck. Dieses Element wird jedoch nicht tats√§chlich aus dem Speicher gel√∂scht, da Sie in Ihrem aufrufenden Programm einen weiteren intelligenten Zeiger darauf haben. In Zukunft wenden Sie sich mit diesem Element an die Liste, und die Pr√ºfung wird korrekt durchgef√ºhrt, wobei auf die Daten verwiesen wird - den Index in der Bitmap und den Zeiger auf die Liste. Ein Element wird tats√§chlich nur dann aus dem Speicher gel√∂scht, wenn keine Verkn√ºpfung mehr besteht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist bei Verwendung von integrierten C ++ - Zeigern nicht der Fall. In diesem Fall </font><font style="vertical-align: inherit;">l√∂scht </font><font style="vertical-align: inherit;">die Speicherstrategie </font><font style="vertical-align: inherit;">dieses Element mithilfe des L√∂schvorgangs </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tats√§chlich</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus dem Speicher. In Zukunft verweisen Sie wie im vorherigen Fall mit diesem Element auf die Liste und versuchen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unter dieser Adresse </font><b><font style="vertical-align: inherit;">auf</font></b><font style="vertical-align: inherit;"> das Element </font><b><font style="vertical-align: inherit;">zuzugreifen</font></b><font style="vertical-align: inherit;"> , um den Index der Bitmap und einen Zeiger auf die Liste zu lesen. Dies ist jedoch nicht m√∂glich: Ein Element wurde bereits aus dem Speicher gel√∂scht! Im besten Fall erhalten Sie eine Zugriffsverletzung, im schlimmsten, undefinierten Verhalten, wenn die C ++ - Bibliothek, die Laufzeitbibliothek oder nur das Betriebssystem dort einen v√∂llig willk√ºrlichen Wert schreibt, den die Liste ber√ºcksichtigt, und versucht, daraus das Vorhandensein eines Elements in der Liste festzustellen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich also heraus, dass die internen Zeiger nur mit der DirectSearch-Direktpr√ºfstrategie kompatibel sind und intelligente Zeiger in diesem Fall nicht nur ihre inh√§rente Sicherheit, sondern auch eine Leistungssteigerung bieten: Nur mit ihrer Verwendung k√∂nnen Bit-Arrays verwendet werden, die die Arbeit der Liste in erheblich verbessern Multithread-Modus! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um Konsistenz zu gew√§hrleisten und inkompatible Strategiekonfigurationen zu beseitigen, habe ich in jede Listenklasse die folgende Pr√ºfung aufgenommen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,    ++ (Type *)          (DirectSearch)</span>
<span class="hljs-keyword">static_assert</span>(!(<span class="hljs-built_in">std</span>::is_same_v&lt;<span class="hljs-keyword">typename</span> ListElement::MemoryPolicy, InternalPointer&lt;ListElement&gt;&gt; == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElement, <span class="hljs-literal">false</span>&gt;, DirectSearch&lt;ListElement, <span class="hljs-literal">false</span>&gt;&gt; == <span class="hljs-literal">false</span>), <span class="hljs-string">"Internal C++ pointer memory policy can be used only with DirectSearch policy."</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es vergleicht die an die Liste √ºbergebenen Strategieklassen und stoppt die Kompilierung mit der entsprechenden Ausgabe der Fehlermeldung, wenn sie nicht kompatibel sind.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmen oder Fehlerr√ºckgaben</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Listenfehlerbehandlung wurde zun√§chst nur durch Ausnahmen durchgef√ºhrt. </font><font style="vertical-align: inherit;">Aber irgendwie habe ich in einem Forum, an das ich mich nicht erinnere, gelesen, dass Ausnahmen das Programm verlangsamen, und f√ºr maximale Leistung sollten Sie die herk√∂mmliche Fehlerr√ºckgabe verwenden. </font><font style="vertical-align: inherit;">Dazu erstellte er zwei neue Klassen, die auf den urspr√ºnglichen Klassen basierten, und schrieb sie nur neu, um Fehler zur√ºckzugeben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basisklasse auflisten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Implementierung der oben genannten Strategien zur √úberpr√ºfung des Vorhandenseins von Elementen hat ein wichtiges Problem aufgedeckt. Wie wir uns erinnern, enth√§lt das Listenelement neben der in dieser Liste eindeutigen Nummer auch einen Zeiger auf diese Liste: Schlie√ülich k√∂nnen wir zwei oder mehr Listen im Programm haben, von denen jede ein eigenes Bit-Array von Flags f√ºr das Vorhandensein des Elements enth√§lt. Wie kann sichergestellt werden, dass dieses Element zu dieser bestimmten Liste geh√∂rt und nicht zu einer anderen? Nur durch Speichern eines Zeigers auf die gesamte Liste in jedem Element. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem ist, dass wir jetzt durch Hinzuf√ºgen einer Vielzahl von Strategien zu unserer Listenklasse ihren </font><b><font style="vertical-align: inherit;">Typ</font></b><font style="vertical-align: inherit;"> erheblich kompliziert haben</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Angenommen, wir haben zwei verschiedene Listen mit demselben Elementtyp und denselben Speicherstrategien, jedoch mit unterschiedlichen Strategien zum Sperren und √úberpr√ºfen des Vorhandenseins von Elementen in diesen. F√ºr den Compiler sind dies zwei verschiedene </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arten von</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Listen. Zeiger auf welchen Typ im Element gespeichert werden soll? Dar√ºber hinaus wei√ü die Klasse f√ºr das Element nicht im Voraus, welche Strategie angewendet wird, sondern muss </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alle</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ber√ºcksichtigen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie auch daran, dass sich die Blockierungsstrategie, die Strategie zum √úberpr√ºfen des Vorhandenseins eines Elements und sogar die Konnektivit√§t (einfach verbunden oder doppelt verbunden) der Liste nur auf das Verhalten der Liste selbst beziehen, sich jedoch in keiner Weise auf die darin </font><b><font style="vertical-align: inherit;">gespeicherten Daten</font></b><font style="vertical-align: inherit;"> beziehen</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber wir als Endbenutzer dieser Klasse interessieren uns f√ºr die Daten! </font><font style="vertical-align: inherit;">Auf der einen Seite haben wir mithilfe der Klassen von Strategien mehr Flexibilit√§t f√ºr uns selbst geschaffen und auf der anderen Seite unser Leben kompliziert und Probleme hinzugef√ºgt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ist es m√∂glich, die W√∂lfe irgendwie voll und die Schafe sicher zu machen? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kann. </font><font style="vertical-align: inherit;">Sie k√∂nnen Zeiger auf Daten aus einer Klasse (d. H. Aus einem Typ) einer Liste ableiten. </font><font style="vertical-align: inherit;">Zus√§tzlich zu den beiden Organisationsebenen der oben angegebenen Liste erschien eine weitere - Null:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListBase</span>
{</span>
	<span class="hljs-keyword">using</span> ptrListElement = <span class="hljs-keyword">typename</span> ListElement::MemoryPolicy::ptrType;		<span class="hljs-comment">//             </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:<font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	ptrListElement pFirst{ <span class="hljs-literal">nullptr</span> };<font></font>
	ptrListElement pLast{ <span class="hljs-literal">nullptr</span> };<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, weil </font><font style="vertical-align: inherit;">Echte Klassen von Listen werden von ihr geerbt. Wenn wir unabh√§ngig von ihrem realen Typ auf die Listendaten zugreifen m√∂chten, sollten wir auf ihre Basisklasse ListBase verweisen. </font><font style="vertical-align: inherit;">Wir erhalten Zugriff auf den Anfang und das Ende der Liste und arbeiten dann mit den Daten, wie wir m√∂chten. </font><font style="vertical-align: inherit;">Die spezifische Art der Liste sowie die Kombination der darin verwendeten Strategien spielen keine Rolle.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iteratoren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich war bereits in vollem Gange, arbeitete eng mit STL in einem realen Projekt zusammen (nicht meines :)) und studierte es weiterhin in B√ºchern. Ich machte auf die Sammlung f√ºr Schleifen aufmerksam. </font><font style="vertical-align: inherit;">Schlie√ülich ist dieser Zyklus nicht nur Teil der STL, sondern bereits ein interner Bestandteil der Sprache. </font><font style="vertical-align: inherit;">Ich dachte, ich k√∂nnte es auch in meinem Projekt unterst√ºtzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dazu m√ºssen Sie Unterst√ºtzung f√ºr Iteratoren hinzuf√ºgen, von der spezifischen Arbeitsweise mit Zeigern abstrahieren und durch die Liste navigieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Iterator-Beispiel:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListIterator</span>		//    
{</span>
	ptrListElement pCurrElement{ <span class="hljs-literal">nullptr</span> };					<span class="hljs-comment">// ,    </span>
	<span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//  ,    </span>
	<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>;								<span class="hljs-comment">// ,     </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListIterator() {}<font></font>
	ListIterator(ptrListElement pElem, <span class="hljs-keyword">const</span> List_OneLinked&lt;ListElement, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">false</span>&gt;* pList, <span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">true</span>)
		<span class="hljs-keyword">noexcept</span> : pCurrElement(pElem), pList(pList), bProtected(bProtected) {}<font></font>
	ListIterator(<span class="hljs-keyword">const</span> ListIterator&amp; li) <span class="hljs-keyword">noexcept</span> : pCurrElement(li.pCurrElement), pList(li.pList) {}<font></font>
<font></font>
	ptrListElement&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		ptrListElement&amp; pli = pCurrElement;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> pli;<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement != <span class="hljs-literal">nullptr</span>; }
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ptrListElement</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{ <span class="hljs-keyword">return</span> pCurrElement; }<font></font>
<font></font>
	<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>++()		<span class="hljs-comment">// : ++it</span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
	}<font></font>
<font></font>
	ListIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span>								<span class="hljs-comment">// : it++</span><font></font>
	{<font></font>
		ListIterator itPrev = *<span class="hljs-keyword">this</span>;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		{<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span> (!pList-&gt;FindElement(pCurrElement, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">true</span>))<font></font>
			{<font></font>
				<span class="hljs-keyword">if</span> (!bProtected)<font></font>
					pList-&gt;UnlockListShared();<font></font>
				<span class="hljs-keyword">throw</span> ListErrors::NotPartOfList();	<span class="hljs-comment">//  -      </span><font></font>
			}<font></font>
		}<font></font>
		pCurrElement = pCurrElement-&gt;pNext;<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span><font></font>
<font></font>
		<span class="hljs-keyword">return</span> itPrev;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = (pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> ListIterator li)<font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;LockListShared();		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">bool</span> bResult = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">if</span> (pList == <span class="hljs-literal">nullptr</span> || li.pList == <span class="hljs-literal">nullptr</span>)<font></font>
			bResult = !(pCurrElement == li.pCurrElement);<font></font>
		<span class="hljs-keyword">else</span><font></font>
			bResult = !(pCurrElement == li.pCurrElement &amp;&amp; pList == li.pList);<font></font>
		<span class="hljs-keyword">if</span> (!bProtected)<font></font>
			pList-&gt;UnlockListShared();		<span class="hljs-comment">//   </span>
		<span class="hljs-keyword">return</span> bResult;<font></font>
	}<font></font>
};<font></font>
 ,       <span class="hljs-keyword">for</span>  ,       begin()  end():<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">begin</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> bProtected = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">if</span>(!bProtected)<font></font>
		LockListShared();		<span class="hljs-comment">//    </span>
	<span class="hljs-function">ListIterator <span class="hljs-title">lit</span><span class="hljs-params">(ListBase&lt;ListElement&gt;::pFirst, <span class="hljs-keyword">this</span>)</span></span>;
	<span class="hljs-keyword">if</span> (!bProtected)<font></font>
		UnlockListShared();		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">return</span> lit;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">ListIterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-keyword">return</span> ListIterator();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ist es m√∂glich geworden, wie folgt zu schreiben:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> List = ListData&lt;List_TwoLinked&lt;ListElement, ThreadLockingWin_SRWLock, SearchByIndex_BitArray, <span class="hljs-literal">true</span>&gt;, <span class="hljs-literal">true</span>&gt;;<font></font>
List <span class="hljs-built_in">list</span>;
<span class="hljs-keyword">try</span><font></font>
{<font></font>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; leValue : <span class="hljs-built_in">list</span>)<font></font>
          _tprintf_s(TEXT(<span class="hljs-string">"%I64u\n"</span>), leValue-&gt;u64Value);<font></font>
}<font></font>
<span class="hljs-keyword">catch</span>(‚Ä¶)<font></font>
{<font></font>
      ‚Ä¶<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
leValue hat einen Zeigertyp auf ein Listenelement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anfangs habe ich die Iteratorunterst√ºtzung nur in ausnahmeunterst√ºtzte Listen aufgenommen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Grund war einfach: Da der Code in der Schleife nicht verf√ºgbar ist, ist es nicht m√∂glich, Fehler korrekt zu behandeln. </font><font style="vertical-align: inherit;">Sie m√ºssen nur noch die Ausnahmen behandeln, indem Sie die Schleife in einen try-Block einschlie√üen. </font><font style="vertical-align: inherit;">Im Allgemeinen ist es keine gute Idee, die Liste so zu durchlaufen, wenn andere Threads intensiv damit arbeiten: Es ist besser, die Liste selbst zu blockieren und sie dann im Single-Thread-Modus ruhig durchzugehen. </font><font style="vertical-align: inherit;">Wenn Sie jedoch aus irgendeinem Grund genau das Gleiche wie im obigen Beispiel tun m√∂chten, besteht jetzt die M√∂glichkeit dazu.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Verallgemeinerung der Strategie zur √úberpr√ºfung des Vorhandenseins eines Elements in einem beliebigen Container; </font><font style="vertical-align: inherit;">Iteratoren f√ºr Listen ohne Ausnahmen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eigentlich hatte ich urspr√ºnglich geplant (und plane immer noch), nicht nur eine Multithread-Liste, sondern auch einen Baum zu erstellen. F√ºr einige ihrer Bed√ºrfnisse. Das Diagramm ist auch m√∂glich, aber erstens brauchte ich es nicht, und zweitens ist das Diagramm eine komplizierte Sache mit sehr nicht trivialen Algorithmen, und ich wollte nicht ohne besondere Notwendigkeit darauf eingehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der ersten Version war die Strategie zum √úberpr√ºfen des Vorhandenseins eines Elements nur auf die Liste ausgerichtet, und ihre Funktionen akzeptierten einen Zeiger auf ein Element und einen Zeiger auf die Basisklasse der Liste (ListBase *). Anschlie√üend dachte ich: Aber bei einem Baum muss man genau das Gleiche tun! F√ºhren Sie eine separate, aber im Wesentlichen genau gleiche Strategie durch?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die L√∂sung war einfach: Ignorieren Sie die Liste. </font><font style="vertical-align: inherit;">Dies bedeutete, dass die Eingabe nun nicht mehr von Zeigern auf Elemente, sondern von Iteratoren empfangen wurde. </font><font style="vertical-align: inherit;">Und Funktionen werden zu Boilerplate, um Zeiger auf einen Container eines geeigneten Typs zu akzeptieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also jetzt die urspr√ºngliche Funktion, zum Beispiel das Registrieren einer Liste in einer Bitmap</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RegisterList</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ListBase&lt;ListElement&gt;* <span class="hljs-keyword">const</span> pList, ptrListElement <span class="hljs-keyword">const</span> pStart, ptrListElement <span class="hljs-keyword">const</span> pEnd = <span class="hljs-literal">nullptr</span>)</span> <span class="hljs-keyword">noexcept</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pList -   ,       , pStart -   ,</span>
	<span class="hljs-comment">//pEnd -   </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		ptrListElement pCurr = pStart;<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">while</span> (pCurr != pEnd &amp;&amp; pCurr != <span class="hljs-literal">nullptr</span>)<font></font>
		{<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pList-&gt;pFirst);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pList = <span class="hljs-keyword">const_cast</span>&lt;ListBase&lt;ListElement&gt; *&gt;(pList);<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
			pCurr = pCurr-&gt;pNext;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In eine Containerregistrierungsfunktion umgewandelt:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Container, class Iterator&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterContainer</span><span class="hljs-params">(Container* <span class="hljs-keyword">const</span> pContainer, Iterator itStart, Iterator itEnd = Iterator{})</span>
</span>{
	<span class="hljs-comment">//  ,   </span>
	<span class="hljs-comment">// : pContainer -   ,       ; itStart -   </span>
	<span class="hljs-comment">//, itEnd -    </span><font></font>
<font></font>
	<span class="hljs-keyword">if</span> (pElementPresentFlags)<font></font>
	{<font></font>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullQWordIdx = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullBitIndex = <span class="hljs-number">0</span>;	<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = itStart; it != itEnd; ++it)<font></font>
		{<font></font>
			ptrElementType&amp; pCurr = *it;<font></font>
			<span class="hljs-keyword">if</span> (ullCurrentElementIndex == ullNumElementsMax)<font></font>
				UpdateFlagsArray(pContainer);<font></font>
<font></font>
			pCurr-&gt;ullElementIndex = ullCurrentElementIndex;<font></font>
			pCurr-&gt;pContainer = pContainer;<font></font>
<font></font>
			ullQWordIdx = ullCurrentElementIndex / ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			ullBitIndex = ullCurrentElementIndex % ce_ullNumBitsInWord;	<span class="hljs-comment">//    </span>
			pElementPresentFlags[ullQWordIdx] |= <span class="hljs-number">1U</span>LL &lt;&lt; ullBitIndex;	<span class="hljs-comment">// </span><font></font>
			ullCurrentElementIndex++;<font></font>
<font></font>
			ullNumElements++;<font></font>
		}<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der √úbergang durch die Liste durch Zeiger wurde mithilfe von Iteratoren in einen √úbergang durch einen abstrakten Container umgewandelt. </font><font style="vertical-align: inherit;">Jetzt reicht es aus, wenn der Baum seine Iteratoren implementiert, und seine Unterst√ºtzung f√ºr diese Strategien wird bereits bereitgestellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies erforderte die R√ºckgabe von Iteratoren an die Listen ohne Ausnahmen, machte sie jedoch von au√üen unzug√§nglich und nur f√ºr den internen Gebrauch bestimmt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenadapter</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich sehr intensiv mit STL gearbeitet sowie Schulungsprogramme aus B√ºchern geschrieben, gestartet und studiert hatte, machte ich auf die Einfachheit der Arbeit mit STL-Containern aufmerksam. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie beispielsweise den folgenden Code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = { <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : v)<font></font>
     i = <span class="hljs-number">1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich erstelle einen Vektor, indem ich ihm den Typ int √ºbergebe, den ich brauche, und das war's! Der Container ist sofort einsatzbereit, wenn ich einige zus√§tzliche Parameter, die standardm√§√üig eingestellt sind, nicht √§ndern muss, was meistens nicht der Fall ist! Ausgehend von der dreistufigen Organisation der Liste m√ºsste ich in jedem Fall zuerst eine neue Klasse f√ºr das Element erstellen und dann eine Klasse f√ºr die Liste mit Daten schreiben und Operationen implementieren, die f√ºr die endg√ºltige Liste spezifisch sind. Stellen Sie sich vor, wie viel Arbeit! Und wenn Sie eine andere Liste f√ºr andere Daten erstellen m√ºssen, m√ºssen Sie dies erneut durchf√ºhren oder im Extremfall den vorherigen Code kopieren und geringf√ºgig √§ndern. Dies √§hnelt bereits der gleichen Aufregung mit der C-Sprache und der Windows-API, bei der Sie f√ºr jede elementare Aktion alle erforderlichen Daten f√ºr die Struktur eingeben und dann die gew√ºnschte Funktion aufrufen m√ºssen. Und entweder alles im Auge behaltenOder lesen Sie auch st√§ndig MSDN und studieren Sie die Argumente jeder neuen Funktion! Routine und furchtbar unangenehm!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich suchte nach M√∂glichkeiten, um die M√∂glichkeit zu erhalten, meine Liste analog zu STL-Containern zu erstellen, damit ich nicht jedes Mal die gleiche Aufgabe erledigen musste: Erstellen Sie eine separate Klasse f√ºr jedes neue Element und dann eine separate Listenklasse f√ºr die Arbeit mit Elementen davon Art. </font><font style="vertical-align: inherit;">Es gab also einen Adapter f√ºr eine Liste mit Datendaten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Adapter f√ºr eine Liste mit Daten ist eine Klasse, in deren Vorlagenparametern Sie sofort den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gew√ºnschten Datentyp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und nicht das Element √ºbergeben. </font><font style="vertical-align: inherit;">Die Art des Elements, das ich das zusammengesetzte Typ des Elements genannt, auf der Grundlage dieser Daten , die </font><font style="vertical-align: inherit;">sie auf schafft </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seine eigene</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementCompound_OneLinked_CP</span>
{</span>
	ElementData ed;		<span class="hljs-comment">//</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	<span class="hljs-keyword">using</span> ListElement = ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;;
	<span class="hljs-keyword">using</span> MemoryPolicy = _MemoryPolicy&lt;ListElement&gt;;	<span class="hljs-comment">//        </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class... Args&gt; <span class="hljs-title">ListElementCompound_OneLinked_CP</span><span class="hljs-params">(Args... args)</span> : <span class="hljs-title">ed</span><span class="hljs-params">(args...)</span> </span>{}<font></font>
	ListElementCompound_OneLinked_CP(<span class="hljs-keyword">const</span> ElementData&amp; ed) : ed(ed) {}<font></font>
<font></font>
	ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
	{<font></font>
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">ElementData</span><span class="hljs-params">()</span>
	</span>{
		<span class="hljs-keyword">return</span> ed;<font></font>
	}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
<font></font>
	<span class="hljs-keyword">typename</span> MemoryPolicy::ptrType pNext = <span class="hljs-literal">nullptr</span>;		<span class="hljs-comment">//    </span><font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ullElementIndex = <span class="hljs-number">0</span>;			<span class="hljs-comment">//      </span>
	ListBase&lt;ListElement&gt;* pContainer = <span class="hljs-literal">nullptr</span>;	<span class="hljs-comment">//  - </span><font></font>
<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer erw√§hnenswerter Punkt ist der Zugriff auf die Daten des Artikels. </font><font style="vertical-align: inherit;">Der Elementtyp enth√§lt die Operation "*":</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; <span class="hljs-keyword">operator</span>*()<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> ed;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das hei√üt, wenn es einen Zeiger auf das pElement-Element gibt, muss es zweimal dereferenziert werden, um auf die darin gespeicherten Daten zugreifen zu k√∂nnen:</font></font><br>
<br>
<pre><code class="cpp hljs">ElementData&amp; li = **pCurrElement;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einmal - um auf ein Objekt vom Typ ListElementCompound_OneLinked mit seinem Zeiger zuzugreifen: ListElementCompound_OneLinked &amp; le = * pCurrElement, und ein zweites Mal - um √ºber die Operation '*': ElementData &amp; li = * le auf Daten zuzugreifen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sieht sehr seltsam und untypisch aus, aber es wird davon ausgegangen, dass Sie nicht mit Zeigern arbeiten (daf√ºr hatten Sie bereits eine vorgefertigte Erstversion), sondern mit Iteratoren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als N√§chstes geben Sie beim Erstellen einer Liste basierend auf dem Adapter die Strategien an, die Sie wie zuvor ben√∂tigen. </font><font style="vertical-align: inherit;">Basierend auf all Ihren Parametern erstellt der Adapter automatisch die erforderlichen Typen und √ºbergibt sie an die interne Basisliste, von der er geerbt wird. </font><font style="vertical-align: inherit;">Allgemeine Klassendefinition:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span> = <span class="hljs-title">SmartSharedPointer</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span> = <span class="hljs-title">ThreadLocking_STDMutex</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span> = <span class="hljs-title">DirectSearch</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span> = <span class="hljs-title">true</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Spezialisierung f√ºr die Liste mit Ausnahmen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementData</span>, <span class="hljs-title">template</span>&lt;class&gt; <span class="hljs-title">class</span> _<span class="hljs-title">MemoryPolicy</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">List_OneLinked_DataAdapter</span>&lt;ElementData, _MemoryPolicy, LockingPolicy, CheckingPresenceElementPolicy, true&gt; :</span> 
<span class="hljs-keyword">public</span> List_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same_v&lt;CheckingPresenceElementPolicy&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;, DirectSearch&lt;ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;, <span class="hljs-literal">true</span>&gt;&gt;, ListElementCompound_OneLinked&lt;ElementData, _MemoryPolicy&gt;, ListElementCompound_OneLinked_CP&lt;ElementData, _MemoryPolicy&gt;&gt;, LockingPolicy, CheckingPresenceElementPolicy, <span class="hljs-literal">true</span>&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sieht sehr sperrig, mehrst√∂ckig und h√§sslich aus. Ich wei√ü. Aber dann macht diese Definition automatisch alles, was ben√∂tigt wird, ohne die direkte Beteiligung des Programmierers, der sie verwenden wird. Mit Hilfe von std :: conditional_t ‚Äã‚Äãund std :: is_same_v wird die Strategie zur √úberpr√ºfung des Vorhandenseins eines von Ihnen eingereichten Elements mit direkten Suchstrategien verglichen und je nach Ergebnis der entsprechende Typ des Listenelements ausgew√§hlt: mit einem Index in der Bitmap und einem Zeiger auf die Liste oder ohne . Dies spart Ihnen Speicherplatz aufgrund unn√∂tiger zus√§tzlicher Daten in jedem Knoten, wenn Sie eine direkte Suchstrategie verwenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Innerhalb der Klasse werden nur spezifische Iteratoren implementiert sowie die analog zu STL erforderlichen Funktionen push_back () / push_front (), die Aufrufe an die Basis-Multithread-Liste umleiten. </font><font style="vertical-align: inherit;">Sie k√∂nnen sp√§ter weitere Funktionen hinzuf√ºgen, sodass die Liste den STLs sehr √§hnlich wird. </font><font style="vertical-align: inherit;">Gleichzeitig bietet es jedoch alle erforderlichen Schutzma√ünahmen und Optionen zur Steigerung der Produktivit√§t in einer Multithread-Umgebung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Arbeit mit einem Datenadapter sah nun so aus. </font><font style="vertical-align: inherit;">Listenobjekte erstellen:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;<font></font>
List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>, SmartSharedPointer, ThreadLockingWin_SRWLock, DirectSearch, <span class="hljs-literal">false</span>&gt; list00;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie mit allen Standardstrategien und -parametern zufrieden sind, wird das Erstellen einer Liste sehr kurz:</font></font><br>
<br>
<pre><code class="cpp hljs">List_TwoLinked_DataAdapter&lt;<span class="hljs-keyword">double</span>&gt; list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, gibt es √§u√üerlich absolut keinen Unterschied zu STL, au√üer dass der Name der Listenklasse unterschiedlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt k√∂nnen Sie mit ihm wie auf die alte Weise √ºber die Funktionen der Basisklasse arbeiten:</font></font><br>
<br>
<pre><code class="cpp hljs">list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">2</span>);<font></font>
list0.AddLast(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">3</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier werden Zahlen von 0 bis 3 nacheinander am Ende der Liste hinzugef√ºgt. Um zu dem Argument zu gelangen, das beim Erstellen an den Konstruktor des erstellten Typs √ºbergeben wird, m√ºssen Sie die Werte der ersten drei Argumente explizit notieren.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> x = *list0.GetLast();			<span class="hljs-comment">//   ,   auto    ListElementCompound_TwoLinked_CP&lt;...&gt;</span>
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"x = "</span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in">endl</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ja, es ist eine gewisse Unannehmlichkeit, den Typ explizit anzugeben. Dies ist jedoch eine Folge des Versuchs, √ºber die vorherige Funktion f√ºr die Arbeit mit Zeigern erneut auf die Liste zuzugreifen. </font><font style="vertical-align: inherit;">Wenn Sie dem Adapter die Funktion back () hinzuf√ºgen, die einen Iterator zur√ºckgibt, tritt beim Durcharbeiten kein solches Problem auf:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> x = *list0.back();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Anpassen der Iteratoren an die Anforderungen von STL:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   STL</span>
<span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;
<span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">const</span> ElementData;
<span class="hljs-keyword">using</span> difference_type = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">ptrdiff_t</span>;
<span class="hljs-keyword">using</span> pointer = <span class="hljs-keyword">const</span> <span class="hljs-keyword">typename</span> List::ptrListElement;
<span class="hljs-keyword">using</span> reference = <span class="hljs-keyword">const</span> ElementData&amp;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird m√∂glich, die Liste in Bibliotheksalgorithmen zu verwenden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; dElem : list1)
	<span class="hljs-built_in">cout</span> &lt;&lt; i++ &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; dElem &lt;&lt; <span class="hljs-built_in">endl</span>;<font></font>
transform(list1.begin(), list1.end(), list1.begin(), [](<span class="hljs-keyword">double</span>&amp; dElem1)<font></font>
{<font></font>
	<span class="hljs-keyword">return</span> dElem1 * dElem1;<font></font>
});<font></font>
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(list1.cbegin(), list1.cend())</span></span>;<font></font>
‚Ä¶<font></font>
copy(v.begin(), v.end(), list1.begin());</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nat√ºrlich m√ºssen Sie das Abfangen und Behandeln von Ausnahmen organisieren: Alle obigen Beispiele dienen zum Arbeiten in einem Thread, um die Kompatibilit√§t mit STL zu testen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Verwendung von STL-Algorithmen macht einen interessanten Punkt m√∂glich: Sie k√∂nnen mehrere Algorithmen gleichzeitig verwenden und sie in mehreren Threads parallel ausf√ºhren. Dies kann nicht mit herk√∂mmlichen Mitteln (z. B. mit std :: list und Blockierungsmitteln) erfolgen, ohne Zugriff auf den internen Inhalt der Listenklasse zu haben. Es war nur m√∂glich, die gesamte Liste f√ºr die Dauer des gesamten Algorithmus zu blockieren. Dies beschleunigt nat√ºrlich die Arbeit f√ºr den Thread, der den Algorithmus ausf√ºhrt, macht jedoch die Liste f√ºr andere Threads unzug√§nglich. Wenn Sie jedoch dieselbe ‚Äûd√ºnne‚Äú SRWLock-Sperre anwenden, k√∂nnen Sie mehrere Algorithmen gleichzeitig in der Liste ausf√ºhren, wenn diese Liste nicht ge√§ndert wird. Der erste zu schreibende Thread wartet jedoch auf den Abschluss des Lesevorgangs der Liste durch alle anderen Threads.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der vorgeschlagenen Listenoption k√∂nnen Sie die Arbeit damit flexibler organisieren. </font><font style="vertical-align: inherit;">Sie k√∂nnen beispielsweise die Arbeit mit der Liste so organisieren, dass nicht modifizierende Algorithmen in der ersten H√§lfte der Liste von mehreren Threads gleichzeitig ausgef√ºhrt werden, w√§hrend eine Reihe anderer Threads in der zweiten H√§lfte der Liste etwas hinzuf√ºgen oder √§ndern k√∂nnen. </font><font style="vertical-align: inherit;">Die Tatsache, dass die Liste f√ºr die Dauer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Operation und nicht f√ºr den gesamten Algorithmus </font><font style="vertical-align: inherit;">blockiert ist </font><font style="vertical-align: inherit;">, erm√∂glicht das "Schreiben" von Schreiboperationen durch die Abfolge von Operationen zum Lesen der Liste, wodurch die Arbeit mit ihr flexibler, produktiver und effizienter wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kombinieren von zwei Varianten von Listenklassen mit und ohne Ausnahmeunterst√ºtzung zu einer mit einem booleschen Parameter</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anfangs waren die Listen nur mit Ausnahmen. </font><font style="vertical-align: inherit;">Dann habe ich neue hinzugef√ºgt - keine Ausnahmen mit Fehlerr√ºckgabe - und die alten mit dem Buchstaben "E" im Klassennamen umbenannt: List_OneLinked_E und List_TwoLinked_E. </font><font style="vertical-align: inherit;">Dies war erforderlich, um √ºberall vier Deklarationen der Listenklasse anzugeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann entschied ich, dass es aus vielen Gr√ºnden unpraktisch war. </font><font style="vertical-align: inherit;">Warum brauchen wir zwei v√∂llig unterschiedliche Klassen, wenn dies dieselbe Liste mit oder ohne Ausnahmeunterst√ºtzung ist? </font><font style="vertical-align: inherit;">Ich habe beide Listen jedes Typs zu einer einzigen Klasse mit einem zus√§tzlichen Booleschen Parameter kombiniert, und ihre spezifische Implementierung mit und ohne Ausnahmen sind zwei Spezialisierungen einer einzelnen Klasse f√ºr den angegebenen Booleschen Parameter.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenf√ºhrungsvorgang f√ºr Vorlagenliste</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Vorlagenoperation zum Kombinieren von Listen funktionierte zuvor nur mit Listen desselben Typs. Es wurden entweder nur einfach verbundene Listen oder nur doppelt verbundene Listen kombiniert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie jedoch dar√ºber nachdenken, spielt es keine Rolle, welche Art von Listen an der Operation beteiligt sind: einfach verbunden oder doppelt verbunden. Ihre Blockierungsstrategien sind ebenfalls unwichtig, wie sie pr√ºfen, ob Elemente vorhanden sind und ob sie die Ausnahmebehandlung unterst√ºtzen oder nicht. All dies gilt nur f√ºr die Organisation der Liste, nicht jedoch f√ºr die darin enthaltenen Daten. Es ist wichtig, dass nur der Datentyp und die Speicherstrategie f√ºr die Elemente √ºbereinstimmen. Dementsprechend akzeptiert die Eingabeoperation nach dem Kombinieren von Listen mit einem Booleschen Parameter in Bezug auf Ausnahmen Listen eines beliebigen Typs mit allen Varianten ihrer Parameter:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListElement</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy1</span>, <span class="hljs-title">class</span> <span class="hljs-title">LockingPolicy2</span>, <span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy1</span>,
<span class="hljs-title">template</span>&lt;class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">CheckingPresenceElementPolicy2</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions1</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions2</span>,
<span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType1</span>, <span class="hljs-title">template</span>&lt;class, class, template&lt;class, bool&gt; class, bool&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListType2</span>&gt;
<span class="hljs-title">auto</span> <span class="hljs-title">operator</span>+(<span class="hljs-title">ListType1</span>&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;&amp; <span class="hljs-title">list1</span>, <span class="hljs-title">ListType2</span>&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&amp; <span class="hljs-title">list2</span>) <span class="hljs-title">noexcept</span>;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund des Listentyps w√§hlt der Compiler nun abh√§ngig von der Einstellung des externen Parameters ce_bGetMinLinksList eine Liste mit minimaler oder maximaler Konnektivit√§t aus. Abh√§ngig von dieser L√∂sung werden die entsprechenden Parameter verwendet:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMinLinksNumber = <span class="hljs-built_in">std</span>::min(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(), <font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ce_uiMaxLinksNumber = <span class="hljs-built_in">std</span>::max(ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber(),<font></font>
ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;::GetLinksNumber());<font></font>
<font></font>
<span class="hljs-keyword">using</span> ListTypeResultMinLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResultMaxLinks = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber, ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;, ListType2&lt;ListElement, LockingPolicy2, CheckingPresenceElementPolicy2, bExceptions2&gt;&gt;;
<span class="hljs-keyword">using</span> ListTypeResult = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;ce_bGetMinLinksList, ListTypeResultMinLinks, ListTypeResultMaxLinks&gt;;<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMinLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMinLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResultMaxLinks = ListType1&lt;ListElement, LockingPolicy1, CheckingPresenceElementPolicy1, bExceptions1&gt;::GetLinksNumber() == ce_uiMaxLinksNumber ? bExceptions1 : bExceptions2;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> bExceptionsResult = ce_bGetMinLinksList ? bExceptionsResultMinLinks : bExceptionsResultMaxLinks;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf den ausgew√§hlten Parametern wird eine Ergebnisliste erstellt:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">ListTypeResult <span class="hljs-title">list</span><span class="hljs-params">(list1.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>) + list2.GetNumElementsMax_SearchElementPolicy(<span class="hljs-literal">true</span>), <span class="hljs-literal">false</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann werden in dieser Liste die Zeiger auf den Anfang der ersten und das Ende der zweiten Liste gesetzt:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// ,   (       ,   )</span>
<span class="hljs-keyword">if</span> (list1.GetFirst(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list1.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list1.GetLast(<span class="hljs-literal">true</span>))<font></font>
	list1.GetLast(<span class="hljs-literal">true</span>)-&gt;pNext = list2.GetFirst(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">if</span> (list2.GetLast(<span class="hljs-literal">true</span>))
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list2.GetLast(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">else</span>
	<span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pLast = list1.GetLast(<span class="hljs-literal">true</span>);<font></font>
<font></font>
<span class="hljs-comment">//       </span>
<span class="hljs-built_in">list</span>.CheckingPresenceElementPolicyResult::RegisterContainer(&amp;<span class="hljs-built_in">list</span>, <span class="hljs-keyword">typename</span> ListTypeResult::iterator{ <span class="hljs-built_in">list</span>.ListBase&lt;ListElement&gt;::pFirst, &amp;<span class="hljs-built_in">list</span> });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als n√§chstes werden die vorherigen Listen gel√∂scht und die Funktion beendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Schwachpunkt dieser Funktion ist das doppelte Sperren von Listen mit potenziellen Deadlocks:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// :  -   ;            std::lock(mutex1, mutex2)</span><font></font>
list1.LockListExclusive();<font></font>
list2.LockListExclusive();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen eine Funktion zum gleichzeitigen Sperren von zwei Listen in einer einzelnen atomaren Operation wie std :: lock (mutex1, mutex2) einf√ºhren. Nicht alle Sperrstrategien unterst√ºtzen jedoch das gleichzeitige Sperren von zwei Synchronisationsobjekten wie std :: lock (...). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus k√∂nnen zwei Listen unterschiedliche Sperrstrategien haben. </font><font style="vertical-align: inherit;">Die L√∂sung dieses Problems (falls √ºberhaupt vorhanden) bleibt der Zukunft √ºberlassen.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux-Kompilierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Kompilierung wurde √ºber das ListDataAdapterTest-Projekt √ºberpr√ºft, das urspr√ºnglich in reinem C ++ ohne Windows-spezifische Funktionen unter Linux Ubuntu 16.04 LTS, dem g ++ 8.2.0-Compiler, geschrieben wurde. Die meisten kleinen Nuancen waren leicht zu beheben, und das Projekt wurde erfolgreich kompiliert, und die Ausgabe des Programms stimmte mit der gleichen Ausgabe unter Windows √ºberein. Dies ist jedoch der Fall, wenn Sie die Zeile zum Kombinieren von Listen mit der Operation "+" auskommentieren:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">auto</span> list3 = list00 + list1;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie es so lassen, wie es ist, tritt bei der oben beschriebenen Operation "+" ein Kompilierungsfehler auf, als w√§re es in der Klasse des zusammengesetzten Elements der Liste nicht als privilegiert deklariert worden. Ein √§hnlicher Fehler tritt in der Strategieklasse f√ºr die direkte √úberpr√ºfung f√ºr das DirectSearch-Element auf. In Visual C ++ ist hier alles in Ordnung. Diese Fehler treten jedoch auf, wenn in der zusammengesetzten Elementklasse und in der Listenklasse die Deklaration der Operation zum Kombinieren von Listen und DirectSearch als privilegiert auskommentiert wird. Es scheint, dass g ++ diese Deklarationen einfach √ºberspringt und sich √ºber die privaten / gesch√ºtzten Mitglieder der entsprechenden Klassen beschwert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(In g ++ Version 9 (Ubuntu 20.04) die gleichen Fehler.)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum Privilegienank√ºndigungen √ºbersprungen werden und wie man sie behebt, habe ich nicht verstanden. </font><font style="vertical-align: inherit;">Ich bin nicht gut in den Funktionen des GCC-Compilers. </font><font style="vertical-align: inherit;">Verlie√ü diesen Moment auch f√ºr die Zukunft. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abgesehen von dieser Nuance gibt es keine weiteren schwerwiegenden Kompilierungsfehler.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschreibung der Header-Dateistruktur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Liebe Leserinnen und Leser, ich habe das vollwertige Projekt unter der LGPL 3.0-Lizenz auf GitHub ver√∂ffentlicht: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ListMT</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dies ist eine L√∂sung, die aus mehreren Testprojekten besteht. </font><font style="vertical-align: inherit;">Der Hauptcode einer Multithread-Liste befindet sich aufgrund ihrer Implementierung √ºber Vorlagen in mehreren Header-Dateien:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List.h - die Basisklasse einer Liste ohne Daten, die alle grundlegenden Operationen mit einer Liste implementiert, die ohne Definition bestimmter Daten m√∂glich ist, sowie √§hnliche STL-Adapter f√ºr Daten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListE.h - Versionen der Liste mit Ausnahmeunterst√ºtzung.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListElement.h - Definition von Basisklassen f√ºr ein Listenelement.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ListErrors.h - Definition von Codes und Fehlerklassen f√ºr Ausnahmen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zus√§tzlich zu den aufgelisteten Hauptdateien sind auch folgende implementiert:</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MemoryPolicy.h - Strategien f√ºr die Arbeit mit dem Ged√§chtnis;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadLocking.h - Blockierungsstrategien.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SearchContainerElement.h - Strategien zum √úberpr√ºfen des Vorhandenseins eines Elements in der Liste, die abstrakt f√ºr jeden Container mit Iteratoren beschrieben werden.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zus√§tzlich zum endg√ºltigen Projekt habe ich drei alte Versionen in den Ordner ‚ÄûAlte Versionen‚Äú eingef√ºgt, damit Sie kurz bewerten k√∂nnen, wie sich das Projekt w√§hrend der Entwicklung ge√§ndert hat.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Hauptprojekt namens List ist ein Programm mit einer Schnittstelle f√ºr Windows, die √ºber die Windows-API hardcore implementiert wird (ich wei√ü nicht, wie sonst). In diesem Programm w√§hlen Sie den Listentyp (einfach verbunden oder doppelt verbunden) aus und geben auch die anf√§ngliche Anzahl von Elementen und die gew√ºnschte Anzahl von Threads an. Listenelemente enthalten einen einzelnen 64-Bit-Wert. Nach dem Erstellen einer Liste springt das Programm in jedem Thread in der Schleife vorw√§rts oder r√ºckw√§rts durch die Liste zu einer zuf√§lligen Anzahl von Elementen und f√ºgt dann ein Element hinzu oder entfernt es. Diese Liste enth√§lt keine wirklich n√ºtzliche Arbeit, und die gesamte Energie wird f√ºr die Erw√§rmung der Atmosph√§re aufgewendet. Dies ist jedoch nicht erforderlich: Wir m√ºssen nur die Funktionsf√§higkeit und Leistung der Liste in einer intensiven Multithread-Umgebung bewerten.Das Ma√ü f√ºr die Leistung ist die Anzahl der Iterationen des obigen Zyklus pro Sekunde, die von allen Threads ausgef√ºhrt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Liste wird erstellt, indem die entsprechenden Strategien im Programmcode angegeben und anschlie√üend neu kompiliert werden. Alle Strategien f√ºr das Hauptprogramm sind im Hauptmodul ListMain.cpp angegeben, die Speicherstrategie ist in ListDataExample.h ausgew√§hlt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen habe ich ein bisschen mit Experimenten experimentiert. Ich gebe ehrlich zu. Haupts√§chlich, weil sich dort in einigen F√§llen die Liste der Elemente erheblich √§ndert. F√ºr die Reinheit des Experiments w√§re es zur Messung der Leistung erforderlich, einen Test so durchzuf√ºhren, dass sich die Anzahl der Elemente im Durchschnitt w√§hrend des Untersuchungszeitraums nicht oder nur unwesentlich √§ndert. Nur unter solchen Bedingungen w√§re es fair, den Wert der Produktivit√§t anhand des Durchschnittswerts zu bewerten. Wenn jemand interessiert ist, schlage ich vor, solche Experimente selbst zu organisieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe die anf√§ngliche Organisation der Tests aus folgenden Gr√ºnden nicht korrigiert. </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuallererst war ich nur faul.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstens interessiert sich meiner Meinung nach niemand f√ºr die genauen quantitativen Leistungswerte</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit berechnetem Fehler</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Es ist wichtig, die Leistung und Leistung der Liste auf </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qualitativ hochwertige Weise</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu bewerten </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zweitens k√∂nnen Sie die √Ñnderung der Leistung der Liste mit dem Wachstum ihres Volumens bewerten, was ebenfalls sehr wichtige und interessante Informationen sind. </font><font style="vertical-align: inherit;">Aus diesen Gr√ºnden habe ich die urspr√ºnglichen Experimente nicht ge√§ndert. </font><font style="vertical-align: inherit;">Drittens wird f√ºr alle Varianten der Liste derselbe Testcode durchgef√ºhrt, wodurch sie in diesem Sinne denselben Bedingungen unterliegen: Die Tatsache, dass sie sich in diesem Fall unterschiedlich verhalten, erm√∂glicht es uns, die Qualit√§t der √Ñnderungen zu beurteilen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Leistungsmessung zu aktivieren, setzen Sie das Flag ce_bPerformanceMeasure im Modul ListMain.cpp auf true. </font><font style="vertical-align: inherit;">Das Programm erstellt eine Datei "PerformanceMeasure.txt" mit Paaren "Anzahl der Elemente - Anzahl der Zyklen / Sek.", Die durch ein ":" - Symbol getrennt sind.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse der Leistungsmessung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nat√ºrlich habe ich nicht alle m√∂glichen Konfigurationen der Liste getestet, da es viele davon gibt. </font><font style="vertical-align: inherit;">Ich habe mich nur auf die Schl√ºssel konzentriert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Tests wurden auf meine Bestellung des bereits veralteten, aber immer noch sehr peppigen Intel Core i7-3930K, DDR3-1333, 4-Kanal-Speichercontrollers durchgef√ºhrt. </font><font style="vertical-align: inherit;">Die Kompilierung wurde √ºber Visual Studio 2019 f√ºr den Release x64-Modus, das Betriebssystem Windows 7 x64, durchgef√ºhrt. </font><font style="vertical-align: inherit;">Ich habe nicht mit der Anzahl der Threads gespielt, daher wurden in allen Tests immer die maximal 12 in diesem System verf√ºgbaren Threads verwendet. </font><font style="vertical-align: inherit;">Mit Ausnahme des letzten Tests wurde immer eine Liste mit 10.000 zuf√§llig ausgew√§hlten Elementen erstellt.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen der Speicherstrategie</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erw√§hnt, kann mit integrierten Zeigern nur eine direkte Suchstrategie verwendet werden, um das Vorhandensein eines Elements in der Liste zu √ºberpr√ºfen. Dementsprechend wird, damit der Vergleich korrekt ist, und f√ºr intelligente Zeiger nur diese Strategie in diesem Test angewendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Sperrstrategie wurde ein kritischer Abschnitt mit einer d√ºnnen Sperre als der produktivste in Windows ausgew√§hlt (siehe unten): ThreadLockingWin_SRWLock. Die Fehlerbehandlung erfolgt durch R√ºckgabe eines Fehlercodes, d. H. Option ohne Ausnahmen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fr/pu/f0/frpuf0zcgkd3dep1rbzgtpk3ciq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Grafik zeigt die Anzahl der Zyklen, die von allen Threads insgesamt pro Sekunde ausgef√ºhrt werden, abh√§ngig von der Testdauer (in Sekunden). Offensichtlich ist die Leistung aufgrund der zuf√§lligen Art der Threads, die auf die Liste zugreifen, inkonsistent.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pz/km/sw/pzkmsw49rqqqihzv-poyko_co-w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite Diagramm zeigt, wie sich die Anzahl der Listenelemente w√§hrend des Tests √§ndert. Ich werde keine nachdenklichen Aussagen zu diesem Zeitplan machen, au√üer dem Offensichtlichen: Es ist klar, dass sie auf leicht unterschiedliche Weise funktionieren und die Konnektivit√§t der Liste zusammen mit der Speicherstrategie einen Effekt hat. Eine doppelt verkn√ºpfte Liste mit internen Zeigern ist die einzige, deren durchschnittliche Gr√∂√üe sich √ºber die gesamte Testdauer unerwartet nicht √§ndert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durchschnittliche Produktivit√§t (Zyklen / s) f√ºr den gemessenen Zeitraum:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ky/ux/kd/kyuxkd-1_uzoxhu65prxxyvfcfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zumindest kann argumentiert werden, dass die Listenoption mit intelligenten Zeigern langsamer ist als die Version mit integrierten Zeigern, was zu erwarten ist. </font><font style="vertical-align: inherit;">In beiden F√§llen stellt sich irgendwie heraus, dass ein einzeln verbundener schneller ist als ein doppelt verbundener, was wiederum zeigt, dass sich im Multithread-Modus viele vertraute Dinge √§ndern k√∂nnen.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen auf Artikelverf√ºgbarkeitsstrategien</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am interessantesten ist das Testen von Strategien zum √úberpr√ºfen des Vorhandenseins eines Elements. Als Speicherstrategie werden intelligente Zeiger aus den zuvor beschriebenen Gr√ºnden nat√ºrlich angezeigt. Der Rest ist der gleiche: Sperren mit ThreadLockingWin_SRWLock und Behandeln von Fehlern durch Zur√ºckgeben eines Fehlercodes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ua/lp/ck/ualpckuzqwqhhsdq9o8oqtljtfa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen mit Sicherheit sagen, dass alle Strategien ungef√§hr gleich funktionieren. Dies ist verst√§ndlich: Wenn Sie in einer einfach verkn√ºpften Liste das Element l√∂schen, m√ºssen Sie die Liste jedes Mal auf das Element √ºberpr√ºfen, das das zu l√∂schende Element angibt. Dies macht alle Bem√ºhungen zunichte, den Zugriff auf die Liste zu optimieren und die √úberpr√ºfung auf das Vorhandensein eines Elements zu beschleunigen. Daher ist eine einfach verkn√ºpfte Liste nicht die beste Wahl f√ºr eine intensive ungeordnete Multithread-Arbeit damit.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde keine Grafik √ºber die Anzahl der Elemente geben: Es gibt dort nichts Interessantes. Ich stelle nur fest, dass jetzt die Anzahl der Elemente in allen Listen zunimmt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine v√∂llig andere Situation ergibt sich f√ºr eine doppelt verkn√ºpfte Liste. Um die Grafiken sch√∂n aussehen zu lassen, habe ich sogar die Strategie der direkten Anzeige der DirectSearch-Liste davon ausgeschlossen, da sie durch die Ergebnisse deutlich vom Rest ‚Äûabf√§llt‚Äú. Au√üerdem habe ich die maximale Anzahl von Elementen um das Vierfache erh√∂ht, wodurch der Test gestoppt wird.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/th/hd/9x/thhd9xyuvi7avo9gmcscfra0tp0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens hat sich die Leistung beim Zugriff auf die Liste (sowie die Prozessorlast von 99-100%) dramatisch und erheblich erh√∂ht! Zweitens haben zwei Strategien mit sequentiellem F√ºllen von Array-Bits ungef√§hr die gleiche Leistung, die sich w√§hrend des Tests nicht √§ndert. Die Geschwindigkeit des zweiten Strategiepaars nimmt nichtlinear ab. Warum dies so ist, wird aus dem Diagramm f√ºr die Anzahl der Knoten in der Liste deutlich.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/ge/mi/bugemimboyskkxkygick6axhxls.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listen mit dem ersten Strategiepaar wachsen in der Anzahl der Elemente und linear. Das zweite Paar ergibt ein signifikant nichtlineares Wachstum, und je gr√∂√üer die Anzahl der Elemente in einer Liste ist, desto langsamer w√§chst es. Das ist da verst√§ndlich Mit einer Zunahme der Anzahl von Elementen beim Erstellen eines neuen Elements m√ºssen Sie im Durchschnitt eine gr√∂√üere Anzahl von Bits des Arrays auf der Suche nach freien Elementen betrachten. Das erste Strategiepaar befasst sich nicht damit, sondern verwendet f√ºr jedes neue Element ein neues Bit. Somit hat eine Liste mit einer solchen Strategie eine maximale Zugriffsleistung und kommt der klassischen Liste am n√§chsten: Sowohl das Erstellen als auch das L√∂schen von Elementen wird in konstanter Zeit durchgef√ºhrt, unabh√§ngig von der Anzahl der Elemente. Es bietet jedoch einige Garantien f√ºr Integrit√§t und Sicherheit in einer Multithread-Umgebung, allerdings auf Kosten einer bestimmten Speichermenge.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Liste mit dem zweiten Strategiepaar ist nat√ºrlich deutlich langsamer. Es ist jedoch immer noch erheblich schneller als direkte √úberpr√ºfungsoptionen. Sie k√∂nnen es also wirklich als Zwischenprodukt in der Leistung empfehlen, aber optimaler in Bezug auf den Speicherverbrauch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich arbeiten Listen mit einer direkten Suchstrategie auch langsamer, wenn die Anzahl der darin enthaltenen Elemente zunimmt: Jedes Mal muss eine gr√∂√üere Anzahl von Elementen angezeigt werden. Es ist nur so, dass die Liste w√§hrend des Tests nicht so stark w√§chst, dass sie trotz der chaotischen Leistungsschwankungen sp√ºrbar wird.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vw/ck/_p/vwck_pj1r6wmaxgowihhqbzltq8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gemittelte Leistungswerte zeigen, dass Strategien mit einer Bitmap w√§hrend des sequentiellen F√ºllens die Produktivit√§t des Zugriffs auf die Liste um etwa das 200-fache steigern konnten, d. H. </font><font style="vertical-align: inherit;">2 Gr√∂√üenordnungen im Vergleich zu direkten Suchstrategien. </font><font style="vertical-align: inherit;">Dies ist eine sehr radikale Ver√§nderung. </font><font style="vertical-align: inherit;">Die Leistung von Optionen mit speicheroptimaler Bitf√ºllung ist, wie oben erw√§hnt, nat√ºrlich merklich langsamer, aber immer noch viel schneller als Optionen mit direkter √úberpr√ºfung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist auch erw√§hnenswert, dass die Verwendung eines Speicher√ºbertragungsmechanismus bei Bedarf den Zugriff auf die Liste etwas verlangsamt. </font><font style="vertical-align: inherit;">Nicht zu kritisch, aber der Effekt ist vorhanden und sp√ºrbar, insbesondere - in der Variante mit dem sparsamen Einsatz von Speicher (gelbe Linie in den Grafiken).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen der Blockierungsstrategie</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun sehen, wie sich die Leistung der Liste √§ndert, wenn Sie verschiedene Sperrstrategien ausw√§hlen. </font><font style="vertical-align: inherit;">Ich habe drei Arten von Sperren verwendet: SRWLock-Thin-Sperre, regul√§rer kritischer Windows-Abschnitt und STL-Mutex. </font><font style="vertical-align: inherit;">F√ºr die restlichen Einstellungen wurde die schnellste Version der Liste verwendet: Biconnected, Smart Pointers, die Strategie zum √úberpr√ºfen des Vorhandenseins eines Elements - SearchByIndex_BitArray, eine Variante ohne Ausnahmen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6a/jb/pz/6ajbpzqugu7mgtv9mtcim4y221w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie zu erwarten ist, erh√∂ht ein ‚Äûd√ºnnes‚Äú Schloss die Leistung um fast 25%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Arbeitsgeschwindigkeit mit dem kritischen Bereich von Windows und dem STL-Mutex ist ungef√§hr gleich.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6n/qz/wv/6nqzwvldymyqvb-rt1dgjgigwdm.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Auswirkungen von Ausnahmen auf die Leistung zu bewerten, habe ich drei Tests durchgef√ºhrt. </font><font style="vertical-align: inherit;">Die ersten beiden verwendeten eine doppelt verkn√ºpfte Liste, intelligente Zeiger, eine Strategie zur √úberpr√ºfung der Anwesenheit von Elementen - SearchByIndex_BitArray - und einen kritischen Abschnitt von SRWLock. </font><font style="vertical-align: inherit;">Der gleiche Test wurde f√ºr den letzten Test verwendet, nur das Schloss wurde zum Vergleich durch den √ºblichen kritischen Abschnitt ersetzt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7_/at/9u/7_at9uiygpgn_mnrznps8yjwbp0.png"><br>
<br>
<img src="https://habrastorage.org/webt/pf/ac/e9/pface9frjlrsbtcbc9ryxnqv8we.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist ersichtlich, dass die Unterst√ºtzung von Ausnahmen die Arbeitsgeschwindigkeit erheblich verringern kann, insbesondere wenn Sie eine ‚Äûgr√∂bere‚Äú Blockierungsoption verwenden. </font><font style="vertical-align: inherit;">Beachten Sie jedoch, dass in diesem Fall die Unterst√ºtzung f√ºr STL und f√ºr Schleifen in der Sammlung nicht verf√ºgbar ist.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es war ein sehr umfangreiches Experiment f√ºr mich. Ich meine nicht die obigen Tests, sondern das ganze Projekt. Er hatte nicht erwartet, dass er so in die L√§nge gezogen w√ºrde. Trotzdem habe ich es komplett und in dem von mir geplanten Umfang durchgef√ºhrt. Am Ende ist dies nat√ºrlich immer noch nicht die endg√ºltige Version, sondern nur ein funktionierender Prototyp, die Umsetzung der am Anfang des Artikels beschriebenen Ideen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus den Testergebnissen geht hervor, dass es sich unter Windows als die schnellste doppelt verkn√ºpfte Liste mit intelligenten Zeigern herausstellte, eine Strategie zur √úberpr√ºfung des Vorhandenseins des SearchByIndex_BitArray-Elements, des kritischen Abschnitts von SRWLock und ohne Ausnahmen. In dieser Konfiguration bietet die Liste maximale Leistung bei intensivem chaotischem Zugriff aus verschiedenen Streams und das Verhalten ist der klassischen Liste mit Sicherheitsgarantien im Multithread-Modus am n√§chsten. Die Option mit einem sparsameren Speicherverbrauch ist ebenfalls sehr produktiv (im Vergleich zur direkten √úberpr√ºfung von DirectSearch), sie ist jedoch immer noch deutlich langsamer als die vorherige und ihre Leistung nimmt mit zunehmender Anzahl von Elementen ab.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie denken, dass ich hier f√ºr das werben werde, was f√ºr eine coole Sache ich getan habe und wie gro√üartig es ist, sie zu verwenden, dann nein: Tats√§chlich werde ich Sie zun√§chst entmutigen. </font><font style="vertical-align: inherit;">Tats√§chlich:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberlegen Sie, ob es m√∂glich ist, einen Container mit einer anderen Anordnung von Elementen zu verwenden: beispielsweise einem Array. </font><font style="vertical-align: inherit;">Es gibt keine Probleme wie eine Liste.</font></font></li>
<li>          ,      std::list    .            .    ,        ,          .      ,   <s>,     </s>.    , <s>    ,</s>       <s>,    </s>.</li>
<li> ,    .       :    ,  ,  ,    ,        . ,    ‚Äì       ,      ,    .</li>
<li>                ,      .   ,       ,               .</li>
<li>   ,    ,     ,            .  ,             .              . ,    ,       ,   ‚Äì     .    . ,   ‚Äì          .     ,        ,    .           ,        .. ,          ,            , ,     ,          ,   :   .                       .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strategien mit der √úbertragung von Speicher auf ein Bit-Array bei Bedarf n√§hern sich zumindest teilweise einer Multithread-Liste an die klassische an: Zumindest bis das Speicher-Array vollst√§ndig gef√ºllt ist, wird genau so viel ben√∂tigt, wie tats√§chlich ben√∂tigt wird. </font><font style="vertical-align: inherit;">Dies f√ºhrt jedoch zu einer Leistungsminderung.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Nachteile des Projekts:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zuvor erw√§hnte M√∂glichkeit der gegenseitigen Blockierung beim Betrieb von Kombinationslisten.</font></font></li>
<li>       ,    . ,     :   ,     RAII:          .       ,      ,   -  ,       .   ,     . ,   ,      - .</li>
<li>         ,    .     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hoffe das war interessant. Anf√§nger k√∂nnen n√ºtzlich sein, weil Alles wird von einfach bis komplex betrachtet. Ich bitte Fachleute zu sagen, inwieweit die hier beschriebenen Ideen Ihrer Meinung nach in der Praxis in realen Projekten anwendbar sind. Gab es in Ihrer Aktivit√§t einen Fall, in dem Sie entsprechend der Bedeutung eine Liste oder einen Baum und keinen anderen Container ben√∂tigten, der jedoch aufgrund der hier beschriebenen Probleme zu einem Engpass in Ihrem Programm wurde? Oder Sie mussten das Programm stark √§ndern oder komplizieren. Wenn Sie dies schon einmal getroffen haben, wie haben Sie es dann gel√∂st?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Wesentlichen ist dieses Projekt nat√ºrlich nur die Verwirklichung meiner eigenen Sicht auf die L√∂sung dieses Problems. </font><font style="vertical-align: inherit;">Es ist wahrscheinlich, dass es eine bessere Option gibt. </font><font style="vertical-align: inherit;">Ich wiederhole von Anfang an den Gedanken, dass ich es urspr√ºnglich f√ºr mich getan habe und nicht vorhatte, es √∂ffentlich zu zeigen. </font><font style="vertical-align: inherit;">Trotzdem habe ich es aus den dort beschriebenen Gr√ºnden getan, daher werde ich mich √ºber konstruktive Kritik freuen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bei einer sorgf√§ltigen √úberpr√ºfung des Codes k√∂nnen Sie auf ein solches Design sto√üen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  (        )</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};			<span class="hljs-comment">//-,       ,   ListElementData_OneLinked/ListElementData_TwoLinked</span><font></font>
<font></font>
<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked1</span> :</span> <span class="hljs-keyword">public</span> ListElement_OneLinked&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked1&lt;&gt;, DerivedListElement&gt;, MemoryPolicy&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>;						<span class="hljs-comment">//  </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked1(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : u64Value(u64Value) {}		<span class="hljs-comment">//</span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedListElement</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">ListElementData_OneLinked2</span> :</span> <span class="hljs-keyword">public</span> ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">using</span> ListElementBase = ListElementData_OneLinked1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerivedListElement, thisclass&gt;::value, ListElementData_OneLinked2&lt;&gt;, DerivedListElement&gt;&gt;;<font></font>
<font></font>
	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ucSomeData[<span class="hljs-number">1024</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">decltype</span>(ListElementBase::u64Value))];	<span class="hljs-comment">//     </span><font></font>
<font></font>
	<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>, <span class="hljs-title">bool</span> <span class="hljs-title">bExceptions</span>&gt; <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">ListData</span>;</span>			<span class="hljs-comment">//           </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
	ListElementData_OneLinked2(<span class="hljs-keyword">unsigned</span> __int64 u64Value = <span class="hljs-number">0</span>) : ListElementBase(u64Value) {}		<span class="hljs-comment">//</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese schwarze Magie verdient einen separaten Artikel. </font><font style="vertical-align: inherit;">Dies ist zwar eine noch weniger praktische Sache als die hier beschriebene Multithread-Liste, hat aber ihre eigenen merkw√ºrdigen Merkmale. </font><font style="vertical-align: inherit;">Wenn Sie daran interessiert sind, woher es kam und warum es erschien, und Sie m√∂chten, dass ich sp√§ter ausf√ºhrlich dar√ºber spreche, schreiben Sie in die Kommentare.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de506702/index.html">Die zuverl√§ssigsten Festplatten nach Backblaze Q1 2020</a></li>
<li><a href="../de506704/index.html">Warum 2020 in PHP schreiben? Holivarim ist diesen Donnerstag ein interaktiver Podcast auf Youtube</a></li>
<li><a href="../de506706/index.html">Die Leistung von modernem Java beim Arbeiten mit gro√üen Datenmengen, Teil 1</a></li>
<li><a href="../de506708/index.html">VPN / Mikrotik Zwei-Faktor-Authentifizierung - einfach und skalierbar</a></li>
<li><a href="../de506710/index.html">Verwalten Sie mehrere Adressb√ºcher in der Open-Source-Edition der Zimbra Collaboration Suite</a></li>
<li><a href="../de506726/index.html">Erfahrung in der Verwendung der Rutoken-Technologie zur Registrierung und Autorisierung von Benutzern im System (Teil 2)</a></li>
<li><a href="../de506730/index.html">Schnauben oder Suricata. Teil 1: W√§hlen Sie ein kostenloses IDS / IPS, um das Unternehmensnetzwerk zu sch√ºtzen</a></li>
<li><a href="../de506732/index.html">Organisationsweite Wiederverwendung von UI-Komponenten</a></li>
<li><a href="../de506734/index.html">√úbergangsberechnungen in elektrischen Netzen</a></li>
<li><a href="../de506736/index.html">Wie viele Methoden sollte eine Klasse haben?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>