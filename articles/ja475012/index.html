<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍💼 🎭 👊🏼 iOS A / Bのブラウザのテストがどのように改善されたか。Yandexレポート 🕵🏻 🎼 👂🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="少し前まで、検索でのA / Bの実験がどのように配置されているかを見てきました。YandexのiOSバージョンの開発チームの責任者。ブラウザーAndrey Sikerinsav42前回の会議で、CocoaHeads RussiaはA / Bテストインフラストラクチャについても、そのプロジェクトでのみ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>iOS A / Bのブラウザのテストがどのように改善されたか。Yandexレポート</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/475012/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少し前まで、</font><font style="vertical-align: inherit;">検索でのA / Bの実験がどのように配置されているか</font><font style="vertical-align: inherit;">を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見てき</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました。</font><font style="vertical-align: inherit;">YandexのiOSバージョンの開発チームの責任者。ブラウザーAndrey Sikerin</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sav42</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前回の会議で、CocoaHeads RussiaはA / Bテストインフラストラクチャについても、そのプロジェクトでのみ話しました。</font><font style="vertical-align: inherit;">
-こんにちは、私の名前はAndrey Sikerinです。iOS用のYandex.Browserを開発しています。 iOSのブラウザー実験プラットフォームとは何か、それを使用する方法を学び、そのより高度な機能をサポートする方法、実験システムを使用して展開された機能を診断およびデバッグする方法、およびエントロピーのソースと場所コインが収納されています。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/mt/lf/6w/mtlf6wbmilwjyws6-tcfxwcxc9e.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは始めましょう。 Browser for iOSでは、機能を一度にユーザーに提供することはありません。最初に、A / Bテストを実施し、製品と技術のメトリックを分析して、ロール機能がユーザーにどのように影響するかを理解します。これには分析を使用します。私たちの分析は次のようになり</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ps/gz/d5/psgzd5dlv3rhmm6unpbug4un-lm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。ここに約85のメトリックがあります。複数のユーザーグループを比較します。これにより、指標（たとえば、製品をユーザーを維持する能力（保持）など）が増加し、スライド上にない他の人を浪費しないと仮定します。これは、ユーザーがこの機能を気に入っており、大規模なユーザーグループに参加できることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それにもかかわらず、私たちが何かを浪費する場合、私たちはその理由を理解しています。仮説を立て、確認します。技術的な指標を描く場合、これはブロッカーです。それらを修正して、実験を再実行します。そして、すべてをペイントするまで。したがって、この機能を展開しますが、これは回帰の原因ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが使用したオリジナルの実験システムについて話しましょう。彼女はすでにかなり発達していた。次に、私たちに合わなかったものをお話しします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wo/e3/dg/woe3dgxmiljvkz0_dcescx4nfni.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、Chromium実験システムに基づいており、iOSでは完全にはサポートされていませんでした。第2に、当初はさまざまなユーザーグループに機能を展開でき、デバイスの要件を設定できるフィルターシステムがありました。つまり、機能を利用できるアプリケーションのバージョン、デバイスのロケールです。ロシア語のロケールのみをテストしたいとします。この機能が利用できるiOSのバージョン、またはこの実験が有効になる日付（たとえば、ある日まで実験を実施したい場合）。全体的にタグが多くてとても便利でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実験システム自体は、実験の構成の説明を含むファイルで構成されています。つまり、1つの実験では、一度に複数の構成が可能です。このファイルはテキストファイルで、protobufにコンパイルされ、サーバー上に配置されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各構成はグループで構成されています。実験があり、いくつかの構成があり、それぞれにいくつかのグループがあります。コード内の機能は、アクティブ構成のアクティブグループの名前に関連付けられています。十分に複雑に思えるかもしれませんが、ここでそれについて詳しく説明します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3w/9z/-2/3w9z-2hyctbs4d7omfr7vnfk5gg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
技術的にはどのように機能しますか？すべての構成の説明を含むファイルがサーバーにアップロードされます。起動時に、ブラウザからサーバーからダウンロードされ、ディスクに保存されます。次に開始するとき、このファイルはアプリケーション初期化チェーンの最初にデコードされます。そして、ユニークな実験ごとに、アクティブになる構成が1つ見つかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで指定および説明されている条件に適した構成がアクティブになる可能性があります。指定された条件に一致するアクティブな構成が複数ある場合は、ファイルの上位にある構成がアクティブ化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、アクティブ構成では、コインが投げられます。コインはローカルで投げられ、このコインに応じて、後で説明する特定の方法で、実験のアクティブなグループが選択されます。そして、コードに添付されているのは、実験のアクティブなグループの名前であり、機能が使用可能かどうかを確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシステムの重要な特徴は、それ自体では何も保存しないことです。つまり、ディスク上にストレージがありません。起動するたびに、ファイルを取得して計算を開始し、アクティブな構成を見つけます。構成に従って、コインに従って、アクティブなグループを見つけます。この実験の実験システムでは、このグループが選択されています。つまり、すべてが計算され、何も保存されません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/r8/my/bl/r8myblurmzrhxkbyzss_weye0cu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、実験の説明を含むファイルをお見せしましょう。ブラウザーにはそのような機能があります-トランスレーター。彼女は実験に出かけた。ファイルはスタディブロックで始まります。実験の構成はこのブロックから始まります。実験はトランスレータと呼ばれます。この名前のスタディブロックがいくつか存在する可能性があります。そして、研究ブロック内には、異なる名前が割り当てられた多くの実験ブロックがあります。この場合、実験グループが有効になっています。そして、実際には、この構成がアクティブになることができる条件、つまりその基準を説明するフィルターブロックがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここには、channelとya_min_versionの2つのタグがあります。チャネルはアセンブリビューを意味します。ここではベータが示されています。つまり、ファイル内のこの構成は、TestFlightに送信するアセンブリに対してのみアクティブになる可能性があります。 App Storeビルドの場合、チャネル基準によるこの構成はアクティブにできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ya_min_versionは、最小バージョンのアプリケーション19.3.4.43で、この構成がアクティブになる可能性があることを意味します。実際、このバージョンのアプリケーションでは、機能はすでに有効にできるような形式になっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、トランスレータ実験構成グループの最も簡単な説明です。ファイルには、このような学習ブロックが多数含まれている場合があります。フィルターブロックのタグを使用して、さまざまな基準で、さまざまなチャネル、内部アセンブリ、ベータアセンブリにタグを設定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、有効化と呼ばれる1つの実験グループで、確率重みタグ、実験グループの重みがあります。これは、コインがポップアップしたときにアクティブグループを決定するために使用される負でない整数です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スライドのこの構成がアクティブになったとしましょう。つまり、私たちは実際にアプリケーションをパブリックベータ版でインストールし、バージョン19.3.4.43以降を持っています。コインはどのように投げられますか？コインは、0から1までローカルで生成される乱数です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、次回の起動時に同じグループに分類され、ディスクに保存されます。今のところ、これを検討します。次に、保存されていないことを確認する方法を説明します。コインは捨てられます。 0.5がスローされたとします。このコインは、ゼロから実験グループの合計までのセグメントでスケーリングされます。この場合、1つの有効なグループがあり、その重みは1000です。つまり、すべてのグループの合計は1000になります。「0.5」は500にスケーリングされます。したがって、すべての実験グループは、間隔をゼロから実験およびギャップの量に分割します。そして、グループは、コインのスケーリングされた値が示す間隔でアクティブになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード内のアクティブな実験グループの名前を尋ねて、アクセシビリティを判断できます。この機能を有効にする必要があるかどうか。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fd/lf/9a/fdlf9awbwgics2ykijdsvecl6wc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、本番環境で使用するより複雑な実験構成について見ていきます。まず、機能を100％展開するのは愚かであることは明らかです。これは、ベータ版または内部アセンブリにのみ使用します。生産には、以下のメカニズムを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーを3つのグループに分けます-古いユーザー、実験をしていないユーザー、新しいユーザー。つまり、次のことを意味します。古いユーザーとは、私たちのアプリケーションを既に使用し、古いバージョンの上に機能を備えたアプリケーションをインストールしたユーザーです。つまり、彼らはすでにそれを使用しており、機能がなく、すべてに慣れ、ある種の実験、新しい機能があるアプリケーションを突然更新しました。次に-実験のないユーザーと新しいユーザー。新しいものは、アプリケーションをきれいにするものです。つまり、彼らはYandex.Browserを使用したことがなく、突然それを使用することに決め、アプリケーションをインストールしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このパーティションをどのようにして実現しますか？フィルターブロックのmin_install_dateタグとmax_install_dateタグに条件を設定します。 Xが2019年3月14日であるとします-これは、機能ビルドのリリース日です。その後、古いユーザーのmax_install_dateは、機能付きのアセンブリのリリース前のX-21日になります。アプリケーションにそのようなインストール日がある場合、最初の起動がリリース前であった可能性が高いです。そしてリリース前には、機能のないバージョンがありました。そして、条件付きで機能を備えたバージョンを現在持っている場合、それは彼がアップデートの助けを借りてアプリケーションを受け取ったことを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、新規ユーザーの場合は、min_install_dateを設定します。 Xプラス数日として公開します。つまり、そのようなインストール日がある場合、つまり、機能付きバージョンのリリース日後に最初の起動を行った場合、クリーンインストールが行われました。彼は現在、機能付きのバージョンを持っていますが、インストール日は機能付きのこのバージョンよりも後です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このように、私たちはユーザーを実験的なものと新しいものなしに古いものに分けます。これは、古いユーザーの動作と新しいユーザーの動作が異なるためです。したがって、たとえば、古いユーザーのグループで塗りつぶすのではなく、新しいユーザーのグループで塗りつぶすことができます。その逆も可能です。質量全体で実験を行うと、これが表示されない場合があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qz/vg/ux/qzvguxtl01veibba0vc9yi-afp0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この実験を見てみましょう。次の実験構成が表示されます-App Storeの翻訳者、新規ユーザー。ブロック調査、名前翻訳者、グループenabled_new。接頭辞newは、新しい多くのユーザーの構成を説明することを意味します。ウェイト500（すべてのウェイトの合計が1000の場合、このセットのパワーは50％です）。 Control_new、重み500、これは2番目のグループです。そして、最も興味深いのは、STABLEチャネルのフィルター、つまり、生産用に組み立てられたアセンブリーのフィルターです。機能が登場したバージョン：19.4.1。そして、これがmin_install_dateタグです。ここでは、Unix時間形式で、2019年4月18日に暗号化されます。これは、バージョン19.4.1のリリースから数日です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここには、新しいプレフィックスのほかに1つの部分があり、有効化および制御されます。これはコントロールプレフィックスです。偶然ではありません。また、ユーザーを新旧に分けているという事実に加えて、実験内のユーザーをいくつかのグループに分けています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ye/e2/p-/yee2p-2fopmazkwdzzqbpbkjcv8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーの最初の部分はコントロールグループで、コントロールプレフィックスが付いています。その中に機能はありません。彼女にはXの重みがあり、通常は有効と呼ばれる機能グループもあります。 Xの重みもあり、これは重要です。そこで機能がオンになります。そして、1から2Xの重みを持つデフォルトグループがあります（1000は同じ構成内のすべてのグループの合計重みの値であり、これはデフォルトで受け入れられます）。デフォルトのグループにも機能は含まれていません。コントロールと機能に分割した後も残っているユーザーを保存するだけです。必要に応じて、そこから実験を再実行することもできます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3v/wl/7t/3vwl7tb4qbuzlnz3ifiqgc-oi8c.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、古いユーザーの構成を見てみましょう。ここに機能とコントロールグループが表示されます。 enabled_old-注目。 control_old、-コントロール、10％。 default_old-デフォルト、80％。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Noteフィルター、ya_min_version 19.4.1、max_install_date 2019年3月28日。これはリリース日より前の日付です。したがって、これは、更新後にバージョン19.4.1を受け取ったユーザーのリストを含む構成です。彼らはアプリケーションを使用し、現在は新しいバージョンを使用しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能グループと制御グループが必要なのはなぜですか？最初のスライドで示した分析では、コントロールグループと機能グループを比較しています。製品のメトリックを比較できるように、それらは同等の能力でなければなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、新旧のさまざまなユーザーグループの分析で、コントロールグループと機能グループを比較します。すべてに色を付ける場合は、フィーチャーを100％ロールします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vq/55/w-/vq55w-koel8iwsw1fhpq-wmsc4o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード開発者はこのシステムをどのように使用しますか？彼は機能グループの名前、機能を有効にする必要がある日付を知っており、アクセスレイヤーを書き込みます。これは疑似コードであり、実験の名前でアクティブグループを要求します。そうではないかもしれません。実際には、すべての構成がデバイスに適しているとは限りません。その後、空の文字列が返されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、アクティブなグループの名前が表示されている場合は、その機能を有効にする必要があります。それ以外の場合は無効にします。さらに、この関数はブラウザーコードの機能を含むコードで既に使用されています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yk/l4/81/ykl481l0evttlhjq9kekm2myjg8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、私たちはこの実験システムを数年間使用していました。すべてが順調でしたが、いくつかの欠点が明らかになりました。このアプローチの最初の欠点は、コードを修正しないと新しい実験グループを追加できないことです。つまり、機能の実験の名前が変更される可能性が低い場合は、さらにいくつかのグループを追加すると、簡単に変更できます。ただし、事前に予測していないため、機能のアクセシビリティコードはそのようなグループを認識していません。したがって、このバージョンを試してみるには、バージョンをローリングする必要があるという問題があります。つまり、コードを変更して、再構築してApp Storeに投稿する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、実験を開始した後、機能の一部を展開したり、機能を分割することはできません。つまり、一部の機能を展開できると突然決めて、一部がまだ実験に残っている場合、これを行うことはできません。事前に考えて、この機能を2つに分割し、実験でそれらを個別に受け入れる必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目に、機能を構成したり、構成を比較したりすることはできません。たとえば、Translatorには、Translator APIへのタイ​​ムアウト時間というパラメーターがあります。つまり、数ミリ秒で翻訳できなかった場合は、エラーが発生し、運が悪かったと言います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実験でこのタイムアウトを設定することは不可能です。グループを修正する必要があるため、すぐに事前に次のグループを事前に用意しておきます。パラメーター名がエンコードされたenabled_with_300_ms、enabled_with_600_msです。ただし、パラメータを数値的に設定することは、どういうわけか不可能です。これまでに考えたことがない場合は、いくつかの構成を比較することはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第4に、アナリストと開発者は事前にグループ名について合意する必要があります。つまり、開発者が機能の開発を開始するには、通常、実際にはこの機能の可用性ポリシーから始めます。そして、彼は機能グループの名前を知る必要があります。このため、アナリストは実験のメカニズムを説明する必要があります-ユーザーを新旧に分けるか、すべてのユーザーを分けずに同じグループに入れます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または逆の実験かもしれません。たとえば、機能が有効になっているとすぐに考えることができますが、無効にすることができます。機能の準備ができていないため、これはアナリストにとってあまり興味深いことではありません。準備ができたら、実験の仕組みを決定します。しかし、開発者は事前にグループの名前と実験のメカニズムを必要とします。そうしないと、開発者は常にコードを変更する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
相談し、我慢すれば十分だと判断しました。そこで、Make Experiments Great Againプロジェクトが誕生しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/03/cl/st/03clstd2ijsstadv_r9gzi5t8na.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロジェクトの重要なアイデアは次のとおりです。以前にコード、コード、アナリストから渡されたアクティブグループの名前に関連付けられていた場合は、2つのエンティティを追加しました。この機能（Feature）および機能パラメーター（FeatureParam）。したがって、プログラマーは機能と機能パラメーターを個別に発明し、それらの識別子を選択し、それらのデフォルト値を選択し、それらの機能の可用性をプログラミングします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、彼はこれらの識別子をアナリストに渡し、アナリストは実験のメカニズムを検討して、feature_associationタグを使用して実験グループで特別な方法でそれらを指定します。このグループがアクティブになった場合は、そのような識別子を使用して機能を有効または無効にし、そのような識別子を使用してパラメータを設定してください。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/an/wb/nh/anwbnhocjsbjbjobwovagyrid9a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実験構成ファイルではどのように見えますか？ここでは実験グループを見ています。名前を有効にすると、オプションのfeature_associationタグがこのenable_featureまたはdisable_featureコマンドタグに追加され、識別子が追加されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
paramブロックもあり、そのいくつかが存在する可能性があります。ここにも名前があります-タイムアウト、そして設定する必要がある値が追加されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m9/xs/o9/m9xso9hf6xqczqxprt35ooabuuo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはコードからどのように見えますか？プログラマーは、FeatureクラスとFeatureParamクラスのエンティティを宣言します。そして、これらのプリミティブからフィーチャアクセスレイヤーに値を書き込みます。次に、この識別子をアナリストに渡します。構成ファイル内で、feature_associationタグを使用して、実験グループのブロックに識別子を設定します。実験グループがアクティブになるとすぐに、コード内のこれらの識別子を持つ機能とパラメーターの値がファイルから設定されます。グループにパラメーターと機能がない場合は、コードから示されるデフォルト値が使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは私たちに与えたように見えるでしょうか？まず、新しいグループを追加するとき、データアクセスレイヤーは新しいグループが実験システムに追加されても変更されない識別子で動作するため、アナリストはコードに新しい機能グループを追加するようプログラマーに依頼する必要がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、プログラマーが機能と機能パラメーターのこれらの識別子を思いついたときと、アナリストが実験のメカニズムを開発したときを投稿しました。アナリストは、機能の準備ができると開発を行い、プログラマーが最初にコードを書くときにこれらの識別子を思い付きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、機能を分割することもできます。実際、Translatorを含むTranslatorと呼ばれる機能があるとします。また、TranslateServiceAPITimeoutの機能があり、Translator APIにカスタムタイムアウトを設定できる追加機能が含まれています。したがって、2つのグループの実験を実行できます。どちらの場合も、トランスレーターがオンになっていますが、同時に300ミリ秒または600のどちらの値が良いかを比較しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、機能をサブ機能に分割し、サブ機能の一部を異なるグループの実験に含めることができます。そして比較してください。また、新しい機能パラメーターエンティティ（FeatureParam）により、同じ機能を異なるパラメーターで構成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはすべての問題を解決し、勝利を祝ったように思えます。しかし、いいえ、彼らは私たちのために来ました。他の開発者、アナリスト、マネージャーではありません。テストがやって来ました。テストの問題は何でしたか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mg/rm/lo/mgrmlowngyxubfoplbyznpipbzw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
発生した最初の問題：Force FeatureとFeatureParamを強制することはできません。このシステムでは、FeatureとFeatureParamはサーバーから設定されます。したがって、サーバーからFeatureとFeatureParamを設定するには、少なくとも内部アセンブリについて、テストで構成ファイルをロールバックする必要があります。彼らはその方法を知りません。または、新しいユーザー、古いユーザーのグループに正直に言うと、これも非常に困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、FeatureとFeatureParamの値を確認できません。機能の値は間接的に確認できます。つまり、「翻訳者」が表示されます。これは、機能がおそらく有効になっていることを意味します。しかし、Translator APIのタイムアウトが300または600ミリ秒であったかどうかをどのように判断すればよいのか、FeatureParamの値を確認するのは困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして第三の問題。私は最初の段落で彼女について話しました。テスターが何かを変更するには、テスト構成を含む変更されたファイルを本番環境でロールアウトする必要があります。内部アセンブリとパブリックベータ用のフィルターを含む構成が構成ファイルに追加された場合でも、このファイルはサーバーの運用環境にロールアウトする必要があります。また、本番環境での展開には、容量の大きいプロセスによって定義される特定の要件があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、事前にリリースされていない機能をテスターがテストすることが難しくなりました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oc/yd/vz/ocydvzgrfulntvkzp6mjzn0xo00.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題をどのように解決しましたか？まず、ポイントと対策をご紹介し、それぞれについて詳しくご説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、新しいサービスを使用して、構成を含むファイルをアップロードし、このファイルのソーススプーフィングをセットアップしました。つまり、構成記述ファイルをダウンロードするためにブラウザーが移動するURLの置換です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つ目：ブラウザー上：//バージョンサービスのページで、もう1つのパラメーターshow-variations-cmdをサポートしました。第三に、外部の実験システムを補完する補助的なチートURLのシステムを開発しました。そして4つ目は、診断画面の開発を開始したことです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hn/0m/53/hn0m53nhab5kfgvuizq8rbupu9e.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のポイントについて話しましょう。構成を含むファイルをアップロードするための新しいサービスは、本番環境で実験的な構成を含むファイルをダウンロードすることでした。次に、テスターはそれをprotoファイルからテキストファイルにデコードして戻し、その後、独自の設計で必要な新しいスタディブロックを使用して構成を完了します。多分単純化されたフィルターで。そして、テストに必要なFeature＆FeatureParam値を設定します。彼は実験の構成とともにこのファイルを参照し、アプリケーションがこの構成に入ることが確実にわかっています。グループは1つだけです。つまり、Feature＆FeatureParamは指定されたものと等しくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、このテキストファイルを新しいサービスにアップロードします。そして、サービスはそれをprotoファイルにコンパイルし、リンクを発行します。彼は診断画面でこのリンクを示します。内部アセンブリの場合、その1つの下に診断画面があります。彼は、デフォルトではなく、彼のリンクを使用する必要があることを示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ym/xb/bn/ymxbbnjm-uui2q2lvi3c5c77es0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
二つ目。 Feature＆FeatureParamの値を表示する方法は？ここでは、サービスページを生成するChromiumメカニズムをサポートしています。 Chromiumは、ブラウザーに追加のブロックを生成します。// show-variations-cmdパラメーターを指定した場合は、バージョンページ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このブロックは、一見するとアブラカダブラのように見える、enabled-features、force-fieldtrials、force-fieldtrials-paramsの3つのキーで構成されています。しかし、あなたが見れば、それは理にかなっています。これは何を意味するのでしょうか？これは、まるでコマンドラインからブラウザを起動したかのように、実験システム全体の内容を意味します。ここでは、Feature1は、trial1と呼ばれる実験によってアクティブ化されると述べています。 Feature2は、trial2と呼ばれる実験によってアクティブ化されます。 Feature3はそのようにアクティブ化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実験trial1にはアクティブグループgroup1があります。実験trial2にはアクティブなグループ2があります。最後のforce-fieldtrials-paramsパラメータは、trial1という名前の実験がgroup1に該当する場合、パラメータp1をv1に、p2をv2に設定する必要があることを意味します。そして、trial2がグループgroup2に該当する場合、パラメーターp3をv3に、p4をv4に設定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
混乱するかもしれませんが、このコードを再利用しました。つまり、これは、iOSでサポートしたChromiumからサービスページを生成するための標準的なメカニズムです。つまり、独自のメカニズムを作成するためにコードベースを再利用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を試してみましょう。キー--force-fieldtrials = lator / enabled_new /を使用した実験トランスレーターは、実験トランスレーターのグループenabled_newを設定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、キー--force-fieldtrial-params == translator.enablew_new：timeout / 5000が続きます。突然、トランスレーターの実験がenabled_newグループに分類され、最初のキーに含まれることがわかり、実験トランスレーターのenabled_newグループに分類されます。タイムアウトパラメータの値を5,000ミリ秒に設定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後のフラグ--enabled-features = TranslateServiceAPITimeout &lt;translatorは、トランスレーター実験のトランスレーター実験のあるグループが突然アクティブになった場合、TranslateServiceAPITimeout機能を有効にしてくださいと言います。つまり、そのようなフォーマットを読み取ることができるため、実験システムの内容全体、選択されたグループ、このグループに含まれた機能、および設定されたパラメーターを確認できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bm/zp/g9/bmzpg98e_vac84schjjl-puzbr8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、チートURLシステムも開発しました。もちろん、実験の構成を含むファイルを取得し、それをデコードし、特定のグループで補足し、サーバーに配置してこのリンクを設定できるのは素晴らしいことです。しかし、それは十分に長いです。そして、最初はこれで暮らしました。しかし、ある時点で、リンクをサポートしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カスタムスキームyandexbrowser：//（Yandex.Browser）とのリンクを開発しました。これは、スライドに表示される次の形式でした。つまり、彼女には4つのパートがありました。最初の部分はmy_pet_experiment = group_nameです。 2番目の部分はenable-features =パラメーターであり、有効にする機能のリストがリストされ、次にdisable-features =パラメーターで、オフにする機能のリストがリストされます。そして、パラメータだけが＆を通過します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような補助リンク（チートURL）を実行すると、実験システムにオーバーヘッド情報が追加されます。このサービス情報は、実験の構成を含むダウンロードされたファイルに加えて、毎回送信されます。また、スライドに表示されているテンプレートのリンクで指定されている情報から、実験の構成が生成されます。これは、最初のファイルにあります。ただし、フィルターブロックは含まれないため、実験my_pet_experimentは、リンクで指定したグループに分類されることが保証されています。このグループの確率は1000になり、リンクで指定したfeature_associationと、設定したパラメーターが含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、テストが容易になりました。テスターはリンクを取得し、それを形成し、アプリケーションで実行します。そして、彼は今や正しい名前の実験になることを確信しています-この場合my_pet_experiment-彼が望むような設定された値が確実にあるでしょう。このスタディブロックが最も高いため、実験システムがファイルをダウンロードしたかどうか、どのファイルをダウンロードしたかは関係ありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v_/t3/xs/v_t3xsak7jrgmjropgdwkv_kif0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
選択したグループの実験値の画面を表示するデバッグ画面も作成します。さらに進むと、機能とパラメーターの値が表示されます。さらに、新しい値をオーバーロードまたは設定できます。リストされた対策はテストを促進し、問題を解決し、テストを新しいレベルに引き上げました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、コインの保管場所とエントロピーの原因について説明します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ho/nb/fd/honbfdatu0gisjpd6hnzxecmjeo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
覚えていると思いますが、このコインは0から1までの乱数で、アクティブ構成での実験のアクティブグループを決定するために捨てられます。次回アプリケーションを起動するときに別の実験グループを選択しないように、ディスクに保存する必要があります。つまり、条件が変更されておらず、次回アプリケーションを起動する場合は、同じ構成の同じグループに分類する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、ディスクにコインを保存することは冗長で危険に思えるかもしれません。コインの生成は最初から同じでなければなりません。乱数ジェネレータを使用する場合、これをどのように保証するのですか？また、ユーザーをグループに均等に分散する必要もあります。これにより、通常、オプションが切断されます。これらの3つの基準をすべて提供して、コインを保管しない方法は？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可能です。</font><font style="vertical-align: inherit;">次のトリックが使用されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/l9/cv/8p/l9cv8p75nc-jsr__fufhnb47txe.jpeg"><br>
<h5><sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スライドからリンク</font></font></a></sub></sup></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ランダムな文字列、いわゆるエントロピーのソースが生成されます。</font><font style="vertical-align: inherit;">ブラウザの各アプリケーションは、たとえばUUIDを格納します。つまり、アプリケーション識別子が生成され、ディスクに保存されます。</font><font style="vertical-align: inherit;">このランダムな文字列は、実験の名前と組み合わされます。</font><font style="vertical-align: inherit;">その後、ハッシュは0から1の値に変換されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこれが機能するのですか？この数はランダムですか？はい、ランダムに生成されたコンポーネントがUUIDとして存在するため、すべてのデバイスでこの数はランダムになります。同じデバイスでも実験ごとに異なりますか？はい、そうです。なぜなら、エントロピーのソースと実験の名前を組み合わせるからです。また、実験の名前は実験ごとに異なります。均等に分配されますか？正しいハッシュと、すでに生成されたハッシュから0から1の実数への正しい変換を使用すれば、使用されます。これを行う方法は</font><font style="vertical-align: inherit;">、GoogleによるAn Efficient Low-Entropy Providerと呼ばれる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示されてい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、実験システムのディスクに格納できる値はUUIDの1つだけであり、すでにアルゴリズムに従って、均等に分配されるコインを生成できます。</font><font style="vertical-align: inherit;">同じアルゴリズムが、たとえば、Chromiumシステム自体によって使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの意見では、どの実験システムを使用する必要がありますか？</font><font style="vertical-align: inherit;">その基準は何ですか？</font><font style="vertical-align: inherit;">彼女は：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算済み：選択したグループ、それらのパラメーター値、その他に関する情報をディスクに保存しません。</font><font style="vertical-align: inherit;">再計算は各開始時に行われる必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成可能。</font><font style="vertical-align: inherit;">ユーザーをグループに分け、実験を実行できる条件を設定すると、システムはこれらの構成を互いに比較します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト可能。</font><font style="vertical-align: inherit;">必要なグループ、機能、パラメーター、またはその他のエンティティの値を再定義できるメカニズムが必要です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析とプログラミングに異なるプリミティブが使用されるもの。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拡張可能。</font><font style="vertical-align: inherit;">どのように機能するかを確認し、ニーズに合わせることができるはずです（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chromiumバリエーションサービスを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照</font><font style="vertical-align: inherit;">）。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex.Browser for iOSで拡張しているChromiumシステムには、このような基準があります。</font><font style="vertical-align: inherit;">実験を実施して分析し、アプリケーションを改善してください。</font><font style="vertical-align: inherit;">感謝。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja475002/index.html">仕事はオオカミではありません、パート2。ボスを渡し、保護観察で生き残る</a></li>
<li><a href="../ja475004/index.html">さまざまな資格の開発者は、2019年の前半にどれくらい稼いだか</a></li>
<li><a href="../ja475006/index.html">28時間でプロトタイプドキュメント比較サービスを作成し、ハッカソンを獲得する方法</a></li>
<li><a href="../ja475008/index.html">プレイボーイインタビュー：スティーブジョブズ、パート3</a></li>
<li><a href="../ja475010/index.html">テレグラムボット-イベントプランニングアシスタント</a></li>
<li><a href="../ja475016/index.html">11月22日、RedmadrobotでのQA mitap</a></li>
<li><a href="../ja475018/index.html">列の変更Radiotehnika S-30</a></li>
<li><a href="../ja475020/index.html">現代のテクノロジーが徐々に火の塔に取って代わる方法</a></li>
<li><a href="../ja475022/index.html">建築統合失調症Facebook天秤座</a></li>
<li><a href="../ja475024/index.html">ランニングは、よりリモートな人にとって理想的なスポーツです。パート1：100 kmの最初のレースへの道</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>