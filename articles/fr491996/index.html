<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😂 🧟 👵🏼 En savoir plus sur Coroutines en C ++ 🤶🏿 🥜 👩🏻‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour chers collègues. 
 
 Dans le cadre du développement du thème C ++ 20, nous sommes tombés à un moment sur un article assez ancien (septembre 20...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>En savoir plus sur Coroutines en C ++</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/491996/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour chers collègues. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cadre du développement du thème C ++ 20, nous sommes tombés à un moment sur un article assez ancien (septembre 2018) du journal de bord de Yandex, qui s'appelle « </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se préparer pour C ++ 20. Coroutines TS avec un exemple réel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ». Il se termine par le vote très expressif suivant: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/a-/m4/xn/a-m4xn5j3yjfy-yl2et7aeek7sc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
«Pourquoi pas», nous avons décidé et traduit un article de David Pilarski sous le titre «Coroutines introduction». L'article a été publié il y a un peu plus d'un an, mais j'espère que vous le trouverez de toute façon très intéressant.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors c'est arrivé. Après beaucoup de doutes, de controverses et de préparation de cette fonctionnalité, le WG21 est parvenu à une opinion commune sur ce à quoi les coroutines devraient ressembler en C ++ - et il est très probable qu'elles seront incluses en C ++ 20. Étant donné qu'il s'agit d'une fonctionnalité majeure, je pense qu'il est temps de la préparer et de l'étudier déjà maintenant (comme vous vous en souvenez, il y a encore plus de modules, de concepts, de gammes à apprendre ...) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beaucoup s'opposent encore à la coroutine. Souvent, ils se plaignent de la complexité de leur développement, de nombreux points de personnalisation et, éventuellement, de performances sous-optimales en raison, éventuellement, d'une allocation sous-optimisée de la mémoire dynamique (peut-être;)).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parallèlement au développement de spécifications techniques (TS) approuvées (officiellement publiées), même des tentatives ont été faites pour développer en parallèle un autre mécanisme de la corutine. </font><font style="vertical-align: inherit;">Nous parlerons ici des coroutines décrites dans TS ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spécifications techniques</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Une approche alternative, à son tour, appartient à Google. </font><font style="vertical-align: inherit;">En conséquence, il s'est avéré que l'approche de Google souffre de nombreux problèmes, dont la solution nécessite souvent d'étranges fonctionnalités supplémentaires de C ++. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au final, il a été décidé d'adopter une version de Corutin développée par Microsoft (sponsorisée par TS). </font><font style="vertical-align: inherit;">C'est à propos de ces coroutines qui seront discutées dans cet article. </font><font style="vertical-align: inherit;">Commençons donc par la question de ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que sont les coroutines?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les coroutines existent déjà dans de nombreux langages de programmation, par exemple en Python ou C #. </font><font style="vertical-align: inherit;">Les coroutines sont une autre façon de créer du code asynchrone. </font><font style="vertical-align: inherit;">En quoi ils diffèrent des flux, pourquoi les coroutines doivent être implémentées en tant que fonctionnalité de langage dédié et, enfin, quelle est leur utilisation sera expliquée dans cette section. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un grave malentendu concernant ce que sont les coroutines. </font><font style="vertical-align: inherit;">Selon l'environnement dans lequel ils sont utilisés, ils peuvent être appelés:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutines sans pile</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Empiler les coroutines</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruisseaux verts</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les fibres</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gorutins</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La bonne nouvelle: les corutines empilées, les ruisseaux verts, les fibres et les gorutines sont une seule et même chose (mais ils sont parfois utilisés de différentes manières). Nous en parlerons plus loin dans cet article et nous les appellerons fibres ou empiler coroutines. Mais la coroutine sans pile possède certaines fonctionnalités qui doivent être discutées séparément. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour comprendre les coroutines, y compris au niveau intuitif, apprenons brièvement les fonctions et (disons-le ainsi) «leur API». La façon standard de travailler avec eux est d'appeler et d'attendre la fin:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>{
     <span class="hljs-keyword">return</span>; <span class="hljs-comment">//     </span><font></font>
}	<font></font>
foo(); <span class="hljs-comment">//   / </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir appelé la fonction, il est déjà impossible de faire une pause ou de reprendre son travail. Vous ne pouvez effectuer que deux opérations sur les fonctions: </font></font><code>start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lorsque la fonction est lancée, vous devez attendre qu'elle soit terminée. Si la fonction est appelée à nouveau, son exécution se poursuivra dès le début. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec les coroutines, la situation est différente. Vous pouvez non seulement les démarrer et les arrêter, mais également les suspendre et les reprendre. Ils sont toujours différents des flux principaux, car les coroutines elles-mêmes ne sont pas évincées (d'un autre côté, les coroutines se réfèrent généralement au flux et le flux est évincé). Pour comprendre cela, considérons un générateur défini en Python. Qu'une telle chose soit appelée générateur en Python, en C ++ ce serait appelé coroutine. Un exemple est tiré de ce </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_nums</span>():</span>
     num = <span class="hljs-number">0</span>
     <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
          <span class="hljs-keyword">yield</span> num<font></font>
          num = num + <span class="hljs-number">1</span>	<font></font>
<font></font>
nums = generate_nums()<font></font>
	<font></font>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<font></font>
     print(x)<font></font>
	<font></font>
     <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">9</span>:
          <span class="hljs-keyword">break</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici comment ce code fonctionne: un appel de fonction </font></font><code>generate_nums</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conduit à la création d'un objet coroutine. </font><font style="vertical-align: inherit;">À chaque étape de l'énumération d'un objet coroutine, la coroutine elle-même reprend le travail et ne l'interrompt qu'après un mot clé </font></font><code>yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le code; </font><font style="vertical-align: inherit;">puis l'entier suivant de la séquence est retourné (la boucle for est du sucre syntaxique pour appeler une fonction </font></font><code>next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui reprend coroutine). </font><font style="vertical-align: inherit;">Le code termine la boucle en rencontrant une instruction break. </font><font style="vertical-align: inherit;">Dans ce cas, la corutine ne se termine jamais, mais il est facile d'imaginer une situation dans laquelle la corutine atteint la fin et se termine. </font><font style="vertical-align: inherit;">Comme on peut le </font><font style="vertical-align: inherit;">voir, à une opération applicable korutine </font></font><code>start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>suspend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>resume</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et enfin,</font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">[Remarque: C ++ fournit également des opérations de création et de destruction, mais elles ne sont pas importantes dans le contexte d'une compréhension intuitive de coroutine].</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutines comme bibliothèque</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, maintenant, il est à peu près clair ce que sont les coroutines. </font><font style="vertical-align: inherit;">Vous savez peut-être qu'il existe des bibliothèques pour créer des objets en fibre. </font><font style="vertical-align: inherit;">La question est, pourquoi avons-nous besoin de coroutines sous la forme d'une fonctionnalité de langage dédiée, et pas seulement d'une bibliothèque qui fonctionnerait avec des coroutines. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous essayons de répondre à cette question et de démontrer la différence entre les coroutines empilées et sans pile. </font><font style="vertical-align: inherit;">Cette différence est essentielle pour comprendre la corutine comme faisant partie du langage.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Empiler les coroutines</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons d'abord ce que sont les coroutines de pile, comment elles fonctionnent et pourquoi elles peuvent être implémentées en tant que bibliothèque. </font><font style="vertical-align: inherit;">Les expliquer est relativement simple, car ils ressemblent à des flux en termes de conception. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La corutine de fibre ou de pile a une pile distincte qui peut être utilisée pour gérer les appels de fonction. </font><font style="vertical-align: inherit;">Afin de comprendre exactement comment fonctionnent les coroutines de ce type, nous considérons brièvement les cadres de fonction et les appels de fonction d'un point de vue de bas niveau. </font><font style="vertical-align: inherit;">Mais d'abord, parlons des propriétés des fibres.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ils ont leur propre pile,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La durée de vie des fibres ne dépend pas du code qui les appelle (généralement elles ont un ordonnanceur défini par l'utilisateur),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les fibres peuvent être détachées d'un fil et attachées à un autre,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planification coopérative (la fibre doit décider de passer à une autre fibre / ordonnanceur),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne peut pas fonctionner simultanément dans le même thread.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les effets suivants résultent des propriétés ci-dessus:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le changement de contexte des fibres doit être effectué par l'utilisateur des fibres, et non par l'OS (en outre, l'OS peut libérer la fibre, libérant le fil dans lequel il fonctionne),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'y a pas de véritable course aux données entre les deux fibres, car à tout moment une seule d'entre elles peut être active,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le concepteur de fibres doit être en mesure de choisir le bon endroit et l'heure, où et quand il convient de restituer la puissance de calcul à un ordonnanceur ou à un appelant éventuel.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les opérations d'entrée / sortie dans la fibre doivent être asynchrones, afin que d'autres fibres puissent effectuer leurs tâches sans se bloquer.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinons maintenant de plus près le fonctionnement des fibres et expliquons d'abord comment la pile participe aux appels de fonction. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, la pile est un bloc de mémoire continu nécessaire pour stocker des variables locales et des arguments de fonction. Mais, plus important encore, après chaque appel de fonction (à quelques exceptions près), des informations supplémentaires sont insérées dans la pile qui indiquent à la fonction appelée comment retourner à l'appelant et restaurer les registres du processeur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certains de ces registres ont des affectations spéciales et lors de l'appel de fonctions, ils sont stockés sur la pile. Ce sont les registres (dans le cas de l'architecture ARM): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SP - pointeur de pile </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LR - registre de communication </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PC - </font><b><font style="vertical-align: inherit;">pointeur de pile de</font></b><font style="vertical-align: inherit;"> compteur de programme</font></font><br>
<br>
<b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(SP) est un registre qui contient l'adresse du début de la pile liée à l'appel de fonction en cours. Grâce à la valeur existante, vous pouvez facilement vous référer aux arguments et aux variables locales stockés sur la pile. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le registre de communication</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (LR) est très important lors de l'appel de fonctions. Il stocke l'adresse de retour (l'adresse de l'appelant), où le code sera exécuté une fois l'exécution de la fonction en cours terminée. Lorsque la fonction est appelée, le PC est enregistré dans LR. Lorsque la fonction revient, le PC est restauré à l'aide de LR. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le compteur de programme</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (PC) est l'adresse de l'instruction en cours d'exécution. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque fois qu'une fonction est appelée, la liste des liens est enregistrée, afin que la fonction sache où le programme doit retourner une fois terminé.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/r2/yk/njr2ykw0o6hrsww5-uq3ybjjddg.png"><br>
 <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le comportement des registres PC et LR lors de l'appel et du retour d'une fonction</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Lors de l'exécution d'une coroutine de pile, les fonctions appelées utilisent la pile précédemment allouée pour stocker ses arguments et ses variables locales. </font><font style="vertical-align: inherit;">Étant donné que toutes les informations sur chaque fonction appelée dans la corutine de pile sont stockées sur la pile, la fibre peut suspendre toute fonction au sein de cette corutine. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/r2/yk/njr2ykw0o6hrsww5-uq3ybjjddg.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons ce qui se passe sur cette image. </font><font style="vertical-align: inherit;">Tout d'abord, chaque fibre et chaque fil a sa propre pile distincte. </font><font style="vertical-align: inherit;">La couleur verte indique les numéros de série indiquant la séquence d'actions.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un appel de fonction régulier à l'intérieur d'un thread. </font><font style="vertical-align: inherit;">La mémoire est allouée sur la pile.</font></font></li>
<li><b>   </b>.      .     ,      .    .       ,              . </li>
<li>  .</li>
<li><b> </b>.       .</li>
<li>    .</li>
<li>    .</li>
<li><b> </b>.    ,    , ,      .</li>
<li>    .</li>
<li>    .</li>
<li><b> </b> –     ,     . </li>
<li>        ,      .</li>
<li>    .      . </li>
<li>       .    :   ,    . ,          (  ) .</li>
<li>  ,   .</li>
<li>  .</li>
<li><b> </b>.   .     .    ,      .</li>
<li>     .</li>
<li>      , ,     .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque vous travaillez avec des coroutines de pile, il n'est pas nécessaire de disposer d'une fonction de langue dédiée qui garantirait leur utilisation. </font><font style="vertical-align: inherit;">L'intégralité du korutiny de la pile doit être implémentée à l'aide de bibliothèques, et il existe déjà des bibliothèques conçues spécifiquement à cet effet: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swtch.com/libtask </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code.google.com/archive/p/libconcurrency </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.boost.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boost.Fiber </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.boost.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the Boost .Coroutine </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De toutes ces bibliothèques, seul Boost est C ++, et tous les autres sont C. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour une description détaillée du fonctionnement de ces bibliothèques, </font><font style="vertical-align: inherit;">voir la </font><font style="vertical-align: inherit;">documentation. </font><font style="vertical-align: inherit;">Mais, en général, toutes ces bibliothèques vous permettent de créer une pile distincte pour la fibre et offrent la possibilité de reprendre la coroutine (à l'initiative de l'appelant) et de la mettre en pause (de l'intérieur).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenons un exemple </font></font><code>Boost.Fiber</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><font></font>
	<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/intrusive_ptr.hpp&gt;</span></span><font></font>
	<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/fiber/all.hpp&gt;</span></span><font></font>
	<font></font>
<span class="hljs-function"><span class="hljs-keyword">inline</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">fn</span><span class="hljs-params">( <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-keyword">const</span>&amp; str, <span class="hljs-keyword">int</span> n)</span> </span>{
     <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; str &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
               boost::this_fiber::yield();<font></font>
     }<font></font>
}<font></font>
	<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
     <span class="hljs-keyword">try</span> {<font></font>
          boost::<span class="hljs-function">fibers::fiber <span class="hljs-title">f1</span><span class="hljs-params">( fn, <span class="hljs-string">"abc"</span>, <span class="hljs-number">5</span>)</span></span>;
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"f1 : "</span> &lt;&lt; f1.get_id() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
          f1.join();<font></font>
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"done."</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
	<font></font>
          <span class="hljs-keyword">return</span> EXIT_SUCCESS;<font></font>
     } <span class="hljs-keyword">catch</span> ( <span class="hljs-built_in">std</span>::exception <span class="hljs-keyword">const</span>&amp; e) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"exception: "</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
     } <span class="hljs-keyword">catch</span> (...) {
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"unhandled exception"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<font></font>
     }<font></font>
     <span class="hljs-keyword">return</span> EXIT_FAILURE;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cas de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boost.Fiber</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , la bibliothèque a un planificateur intégré pour coroutine. </font><font style="vertical-align: inherit;">Toutes les fibres passent dans le même fil. </font><font style="vertical-align: inherit;">Comme la planification de la corutine est coopérative, la fibre doit d'abord décider quand rendre le contrôle au programmateur. </font><font style="vertical-align: inherit;">Dans cet exemple, cela se produit lorsque la fonction yield est appelée, ce qui interrompt la coroutine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisqu'il n'y a pas d'autre fibre, le planificateur de fibres décide toujours de reprendre la coroutine.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutines sans pile</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les coroutines sans pile diffèrent légèrement en propriétés de celles en pile. </font><font style="vertical-align: inherit;">Cependant, ils ont les mêmes caractéristiques de base, car les coroutines non empilées peuvent également être démarrées, et après leur suspension peut être reprise. </font><font style="vertical-align: inherit;">Des coroutines de ce type que nous trouverons probablement en C ++ 20. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous parlons des propriétés similaires de la corutine - les coroutines peuvent:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corutin est étroitement liée à son appelant: lorsqu'une coroutine est appelée, l'exécution lui est transférée et le résultat de la coroutine est retransféré à l'appelant.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La durée de vie d'une pile de corutine est égale à la durée de vie de sa pile. </font><font style="vertical-align: inherit;">La durée de vie d'une coroutine sans pile est égale à la durée de vie de son objet.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, dans le cas de coroutines sans pile, il n'est pas nécessaire d'allouer une pile entière. Ils consomment beaucoup moins de mémoire que ceux de la pile, mais cela est précisément dû à certaines de leurs limitations. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour commencer, s'ils n'allouent pas de mémoire à la pile, comment fonctionnent-ils? Où, dans leur cas, toutes les données doivent être stockées sur la pile lorsque vous travaillez avec des coroutines de pile. Réponse: sur la pile de l'appelant.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le secret des coroutines sans pile est qu'elles ne peuvent se suspendre qu'à la fonction la plus élevée. Pour toutes les autres fonctions, leurs données sont situées sur la pile du côté appelé, donc toutes les fonctions appelées à partir de la corutine doivent être terminées avant que le travail de la corutine ne soit suspendu. Toutes les données nécessaires à la coroutine pour maintenir son état sont allouées dynamiquement sur le tas. Cela nécessite généralement quelques variables et arguments locaux, qui sont beaucoup plus compacts qu'une pile entière qui devrait être allouée à l'avance. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetez un œil au fonctionnement des corutines </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ow/vc/nw/owvcnwldgczpxdmjorsjlrh3yvm.png"><br>
 <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sans pile</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, il n'y a maintenant qu'une seule pile - c'est la pile principale du thread. </font><font style="vertical-align: inherit;">Examinons pas à pas ce qui est montré dans cette image (le cadre d'activation de la coroutine est ici bicolore - le noir montre ce qui est stocké sur la pile et le bleu - ce qui est stocké sur le tas).</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un appel de fonction régulier dont la trame est stockée sur la pile</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction crée une coroutine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Autrement dit, il lui alloue une trame d'activation quelque part sur le tas.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appel de fonction normale.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appelez Corutin</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Le corps de Corutin se démarque dans une pile régulière. </font><font style="vertical-align: inherit;">Le programme est exécuté de la même manière que dans le cas d'une fonction régulière.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un appel de fonction régulier de coroutine. </font><font style="vertical-align: inherit;">Encore une fois, tout se passe toujours sur la pile [Remarque: vous ne pouvez pas suspendre la coroutine à partir de ce point, car ce n'est pas la fonction la plus élevée de la coroutine]</font></font></li>
<li>       [:     .]</li>
<li>  –  ,        ,     .</li>
<li>  </li>
<li><b>  </b> –      ,        +     .</li>
<li>     5.</li>
<li>     6.</li>
<li><b> </b>.        .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, il est évident que dans le deuxième cas, il est nécessaire de se souvenir de beaucoup moins de données pour toutes les opérations de suspension et de reprise du travail de coroutine, cependant, la coroutine peut reprendre et suspendre uniquement elle-même, et uniquement à partir de la fonction la plus élevée. Tous les appels de fonction et la coroutine se déroulent de la même manière, cependant, entre les appels, il est nécessaire d'enregistrer des données supplémentaires, et la fonction doit être capable de sauter au point de suspension et de restaurer l'état des variables locales. Il n'y a pas d'autres différences entre le cadre coroutine et le cadre fonction.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La corutine peut également provoquer d'autres coroutines (non représentées dans cet exemple). </font><font style="vertical-align: inherit;">Dans le cas de coroutines sans pile, chaque appel entraîne l'allocation d'un nouvel espace pour de nouvelles données de coroutine (avec un appel répété de coroutine, la mémoire dynamique peut également être allouée plusieurs fois). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La raison pour laquelle les coroutines doivent fournir une fonctionnalité de langage dédiée est que le compilateur doit décider quelles variables décrivent l'état de la coroutine et créer du code stéréotypé pour passer aux points de suspension.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation pratique de la corutine</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les coroutines en C ++ peuvent être utilisées de la même manière que dans d'autres langages. </font><font style="vertical-align: inherit;">Coroutines simplifiera l'orthographe:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">générateurs</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code d'entrée / sortie asynchrone </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">informatique paresseuse</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">applications pilotées par les événements</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sommaire</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'espère qu'en lisant cet article vous découvrirez:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pourquoi en C ++ vous devez implémenter des coroutines en tant que fonctionnalité de langage dédiée</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle est la différence entre les coroutines empilées et sans pile?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pourquoi les coroutines sont nécessaires</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr491986/index.html">RemoteLoRa - Plus que ON / OFF</a></li>
<li><a href="../fr491988/index.html">Quoi de neuf dans Red Hat OpenShift 4.2 et 4.3?</a></li>
<li><a href="../fr491990/index.html">Travailler avec la puce chinoise ADC Hx711 (conclusion)</a></li>
<li><a href="../fr491992/index.html">Développement des analystes</a></li>
<li><a href="../fr491994/index.html">Migration de Cocoapods vers Swift Package Manager</a></li>
<li><a href="../fr492000/index.html">Produit très premier. Burnout</a></li>
<li><a href="../fr492002/index.html">Ailes absorbant la lumière: le secret des papillons super noirs</a></li>
<li><a href="../fr492004/index.html">Comment passer d'un programmeur à un manager («Je veux être la maîtresse de la mer»)</a></li>
<li><a href="../fr492006/index.html">La puissance de PWA: un système de vidéosurveillance avec un code JS de réseau neuronal de 300 lignes</a></li>
<li><a href="../fr492008/index.html">Résultats de la recherche sur la motivation informatique: les développeurs sont-ils satisfaits de leur travail?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>