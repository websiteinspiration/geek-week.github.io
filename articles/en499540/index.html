<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçü§ù‚Äçüë©üèª üë®üèø‚Äçüç≥ üïé How 3D game rendering works: texturing and texture filtering ‚òÆÔ∏è üöµüèæ üëÜüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the third article on rendering in 3D games, we will find out what happens to the 3D world after processing vertex processing and rasterizing the sc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>How 3D game rendering works: texturing and texture filtering</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499540/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a4/fee/0c7/2a4fee0c701c2b2200faf2b8c6929832.jpg" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the third article on rendering in 3D games, we will find out what happens to the 3D world after processing vertex processing and rasterizing the scene. </font><font style="vertical-align: inherit;">Texturing is one of the most important stages of rendering, despite the fact that it only calculates and changes the colors of a two-dimensional grid of multi-colored blocks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Most of the visual effects in modern games boil down to deliberate use of textures - without them, games would seem boring and lifeless. </font><font style="vertical-align: inherit;">So let's see how it all works! </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 1: vertex processing </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 2: rasterization and ray tracing</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start with a simple</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can take any three-dimensional best-selling games released over the past year, and say with confidence that they all have something in common: they use </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">texture maps</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (or just </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">textures</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). This is such a common term that when thinking about textures, most people present the same picture: a simple flat square or rectangle containing an image of a surface (grass, stone, metal, fabric, face, etc.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But when used and combined using complex calculations, such simple images in a 3D scene can create amazingly realistic images. To understand how this is possible, let's turn them off completely and see how the objects of the 3D world without textures will look.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As we saw from previous articles, the 3D world is made up of vertices ‚Äî simple shapes that move and then colorize. They are then used to create primitives, which in turn are compressed into a two-dimensional grid of pixels. Since we will not use textures, we need to colorize these pixels. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the methods that can be applied is called </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flat shading</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : the color of the first vertex of the primitive is taken, and then this color is applied to all the pixels covered by the figure in the raster. It looks something like this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/f5c/61b/a0bf5c61be539c776d00fa1b11177ced.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviously, the kettle looks unrealistic, and not least because of irregular surface colors. Colors jump from one level to another, there are no smooth transitions. One solution to the problem could be to use </font></font><em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gouraud shading</font></font></a></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this process, the colors of the vertices are taken, after which the color change along the surface of the triangle is calculated. For this, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linear interpolation is used</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It sounds complicated, but in reality this means that if, for example, one side of the primitive has a color of 0.2 red and the other 0.8 red, then the middle of the figure will have a color in the middle between 0.2 and 0.8 (i.e. 0.5).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This process is simple enough, and this is its main advantage, because simplicity means speed. Many older 3D games used this technique because the computing equipment was limited in its capabilities.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/128/447/3c8/1284473c8e1e2ce7d32dbf2202065afe.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barrett and Cloud in all the grandeur of the Gouraud shading (Final Fantasy VII, 1997)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
But even such a solution has problems - if the light falls right in the middle of the triangle, then its corners (and vertices) may not convey this property. </font><font style="vertical-align: inherit;">This means that the glare created by light can be completely lost. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although Gouraud's flat shading and shading have taken their rightful place in the rendering tools, the examples shown above are clear candidates for texture enhancement. </font><font style="vertical-align: inherit;">And in order to understand well what happens when the texture is superimposed on the surface, we will go back in time ... already in 1996.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game and GPU history in brief</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
About 23 years ago, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">id Software</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> released Quake, and it became a major milestone. </font><font style="vertical-align: inherit;">Although this was not the first game to use 3D polygons and textures to render environments, it was definitely one of the first to use them effectively. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But she did something else too - she showed what can be done using OpenGL (this graphics API was in the first version state then), and also helped a lot the first generation of graphics cards like </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendition Verite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3Dfx Voodoo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a86/9a9/667/a869a966718cfc8ddf4b6d7618b2fdbf.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lighting peaks and simple textures. </font><font style="vertical-align: inherit;">Clean 1996, clean Quake. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
By modern standards, Voodoo was extremely simple: no 2D graphics support, no vertex processing, only the simplest pixel processing. </font><font style="vertical-align: inherit;">However, she was beautiful:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66c/509/911/66c5099113c9b08098b73ce31436ecb8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VGA Museum</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
She had a whole chip (TMU) to get a pixel from a texture and another chip (FBI) for later mixing it with a raster pixel. The map could carry out a couple of additional processes, for example, the implementation of fog or transparency effects, but this, in essence, its capabilities ended. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we look at the architecture underlying the structure and operation of the graphics card, we will see how these processes work.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/c83/ee4/064c83ee4f63da2be0d5a968c33df0d5.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3Dfx specification. Source: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falconfly Central</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
The FBI chip received two color values ‚Äã‚Äãand mixed them; one of them could be a value from a texture. The mixing process is mathematically quite simple, but varies slightly depending on what is mixed and which API is used to execute the instructions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you look at what </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direct3D offers us</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with regard to functions and mixing operations, we will see that each pixel is first multiplied by a number from 0.0 to 1.0. This determines how much the color of the pixel will affect the finished result. Then two changed pixel colors are added, subtracted or multiplied; in some functions, a logical operation is performed in which, for example, the brightest pixel is always selected.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/c8b/c8a/aa1c8bc8a2e35a1867c5f6028d958fa8.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taking Initiative tech blog</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
The image above shows how this works in practice; notice that the pixel </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alpha</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> value is used as a coefficient for the left </font><font style="vertical-align: inherit;">pixel. This number indicates the amount of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transparency of the</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At other stages, the fog value is applied (it is taken from the table created by the programmer, and then the same mixing calculations are performed); performing checks and changes in visibility and transparency; at the end, the color of the pixel is written to the memory of the graphics card.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why do you need this excursion into history? </font><font style="vertical-align: inherit;">Well, despite the relative simplicity of the design (especially compared to modern monsters), this process describes the fundamental principles of texturing: we take the values ‚Äã‚Äãof the colors and mix them so that the models and environments look as they should in a particular situation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modern games do the same thing, the only difference is the number of textures used and the complexity of the mixing calculations. </font><font style="vertical-align: inherit;">Together, they simulate the visual effects found in films, or the interaction of lighting with different materials and surfaces.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texturing Basics</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For us, a texture is a flat 2D image superimposed on the polygons that make up the 3D structure in the frame. However, for a computer, this is just a small block of memory in the form of a 2D array. Each element of the array denotes the color value of one of the pixels in the texture image (commonly called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">texels</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - texture pixels). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each vertex of the polygon has a set of two coordinates (usually denoted as </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), telling the computer which pixel of the texture is associated with it. The vertex itself has a set of three coordinates ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x, y, z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), and the process of linking texels to the vertices is called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">texture mapping</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To see how this happens, let's turn to the tool that we have already used several times in this series of articles - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Real Time Rendering WebGL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . For now, we also discard the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordinate of the </font><font style="vertical-align: inherit;">vertices and consider everything on a flat plane.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/d20/fbb/8e1d20fbb308d78a19a2e54d5da96900.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From left to right: the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordinates of the </font><font style="vertical-align: inherit;">texture, tied directly to the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x, y</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordinates of the </font><font style="vertical-align: inherit;">corner vertices. In the second image, the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordinates are increased at the top vertices </font><font style="vertical-align: inherit;">, but since the texture is still attached to them, it stretches vertically. The texture has already been changed in the right image: the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> values </font><font style="vertical-align: inherit;">have increased, but as a result, the texture has been compressed and then repeated.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
This happened because, despite the fact that, in fact, the texture has become higher due to the increased value of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , it should still fit in the primitive - in fact, the texture partially repeated. This is one way to implement the effect that is often found in 3D games: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repeating textures</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Examples of this effect can be seen in scenes with stony or grassy landscapes, as well as with brick walls. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's change the scene so that there are more primitives, and again return the depth of the scene. The classic landscape view is shown below, but now the box texture is copied and repeated for all primitives.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/9e1/0cb/a9e9e10cb533b78330f90fd7eaea3891.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The box texture in its original gif format has a size of 66 KB and a resolution of 256 x 256 pixels. The initial resolution of the part of the frame covered by the box textures is 1900 x 680, that is, from the point of view of the pixel ‚Äúarea‚Äù, such an area should display only 20 box textures. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But it‚Äôs obvious that we see much more than twenty boxes, and this means that the texture of the box in the distance should be </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">much</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> smaller than 256 x 256 pixels. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indeed</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , they underwent a process called </font><em><font style="vertical-align: inherit;">‚Äútexture minification‚Äù</font></em><font style="vertical-align: inherit;"> (yes, such a word exists in English!). Now, let‚Äôs repeat, but this time bring the camera closer to one of the drawers.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/404/c02/f70/404c02f70291916245ec931642c79860.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Do not forget that the texture has a size of only 256 x 256 pixels, but here we see a texture that is larger than half the image with a width of 1900 pixels. </font><font style="vertical-align: inherit;">This texture was subjected to a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äútexture magnification‚Äù</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operation </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These two texture processes constantly occur in 3D games, because when the camera moves around the scene, the models approach or move away, and all the textures applied to the primitives must scale together with the polygons. </font><font style="vertical-align: inherit;">From the point of view of mathematics, this is a small problem, in fact, even the simplest integrated graphics chips can easily do such a job. </font><font style="vertical-align: inherit;">However, reducing and enlarging textures are new challenges that need to be addressed in some way.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mini-copies of textures appear on the scene</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first problem to solve for textures is the distance. If we return to the first image with a landscape of boxes, then the boxes located near the horizon in fact have a size of only a few pixels. Therefore, trying to compress an image of 256 x 256 pixels in such a tiny space is pointless for two reasons. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Firstly, the smaller texture takes up less memory of the graphics card, which is convenient, because you can try to fit it into a smaller cache. This means that it is less likely to be deleted from the cache, that is, repeated use of this texture will provide increased performance, because the data will be in close memory. For the second reason, we will return soon, because it is associated with the same problem that arises in textures close to the camera.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The standard solution to the problem of the need to compress large textures into small primitives is to use </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mip-textures (mipmaps)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . These are downsized versions of the original texture; they can be generated by the engine itself (using the appropriate API commands) or pre-created by game designers. Each subsequent level of mip texture has a half size compared to the previous one. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, for the box texture, the dimensions will be: 256 x 256 ‚Üí 128 x 128 ‚Üí 64 x 64 ‚Üí 32 x 32 ‚Üí 16 x 16 ‚Üí 8 x 8 ‚Üí 4 x 4 ‚Üí 2 x 2 ‚Üí 1 x 1.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/074/973/1ea/0749731eae53d112d545c0297ac14584.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All mip textures are packaged together, so the texture has the same file name, but becomes larger in size. The texture is packed in such a way that the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordinates </font><font style="vertical-align: inherit;">not only determine which texel is superimposed on the pixel in the frame, but also with which mip texture. Then the programmers write a renderer, based on the value of the pixel depth of the frame, which determines which mip texture to use. For example, if the value is very high, then the pixel is far away, which means you can use a small mip texture.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Attentive readers could notice the lack of mip-textures - they have to pay for them by increasing the size of the textures. The original texture of the box was 256 x 256 pixels, but as you can see in the image above, the texture with mip textures now has a size of 384 x 256. Yes, it has a lot of empty space, but no matter how we pack smaller textures, in general the size of the texture on one side will increase by at least 50%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But this is true only for previously created mip-textures; if the game engine is programmed to generate them correctly, the increase is no more than 33% of the original texture size. Therefore, due to a small increase in the amount of memory for storing mip-textures, we get a gain in performance and visual quality.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Below is a comparison of images with mip textures disabled / enabled:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e96/b67/e71/e96b67e71c3f41aed3ce09ed728f98ea.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the left side of the image, the textures of the boxes were used ‚Äúas is‚Äù, which led to the appearance of granularity and the so-called </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moire</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the distance. </font><font style="vertical-align: inherit;">On the right, the use of mip-textures allowed for smoother transitions, and on the horizon the texture of the box is blurred into a uniform color. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, who wants blurry textures to spoil the backgrounds of their favorite game?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bilinear, trilinear, anisotropic - all this is for me a Chinese letter</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The process of selecting a pixel from a texture to overlay it on a pixel in a frame is called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sampling textures</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and in an ideal world there would be a texture that ideally matches the primitive for which it is designed, regardless of size, position, direction, and so on. </font><font style="vertical-align: inherit;">In other words, sampling the texture would be a simple one-to-one texel pixel mapping. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But since this is not so, there are several factors to consider when sampling textures:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Has the texture been reduced or enlarged?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is the texture a source or mip texture?</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At what angle is the texture displayed?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's analyze them in order. The first factor is quite obvious: if the texture has been increased, then in the primitive there will be more texels covering the pixel in the primitive than required; when decreasing, the opposite is true - each texel should now cover several pixels. And that is a problem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second factor does not cause problems, because mip-textures are used to bypass the problem of sampling the textures of far-off primitives, so the only task is to display the textures at an angle. And yes, this is also a problem. Why? Because all textures are images generated for viewing ‚Äústrictly in front‚Äù. Speaking in mathematical language, the normal surface texture matches the surface nominal on which the texture is currently displayed.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Therefore, if the texels are too few or too many, or they are located at an angle, then an additional process called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äútexture filtering‚Äù</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is required </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If this process is not used, then we get this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/792/a12/552/792a125529b7f3baa79c072fdf42acba.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we replaced the texture of the box with a texture with the letter R, to more clearly show what mess the image turns into without filtering textures! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Graphic APIs such as Direct3D, OpenGL, and Vulkan provide the same set of filtering types, but use different names for them. </font><font style="vertical-align: inherit;">In fact, they all boil down to the following:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Near Point Sampling</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linear texture filtering</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anisotropic texture filtering</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sampling the nearest point sampling is</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> not a filter, because with it only the nearest texel of the texture pixel required is sampled (for example, copied from memory), and then it is mixed with the original color of the pixel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here linear filtering comes to our aid. The required </font><font style="vertical-align: inherit;">texel </font><font style="vertical-align: inherit;">coordinates </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are transferred to the sampling equipment, but instead of taking the texel closest to these coordinates, the sampler takes </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">four</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texels. These are texels located above, below, to the left and to the right of the texel that is selected by sampling the nearest points. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These four texels are then mixed using a formula with weights. In Vulkan, for example, the formula looks like this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/9bb/63c/57b9bb63cc81fa5721b007717f6b200a.png"></div><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> denotes the texel color, where </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the result of filtration, and 1-4 is the color of four sampled texels. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alpha</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beta</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> values </font><font style="vertical-align: inherit;">are taken depending on how far the point with coordinates </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u, v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is from the middle of the texture. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortunately for those involved with 3D graphics, this happens automatically in the graphics chip. In fact, this is exactly what the 3dfx Voodoo card TMU chip did: it sampled four texels and then mixed them together. In Direct3D, this process has a strange name </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for bilinear filtering.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">but since the days of Quake and the TMU chip, graphics cards have already learned how to perform bilinear filtering in just one clock cycle (of course, if the texture is already located in the nearest memory). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linear filtering can be used together with mip-textures, and if you want to complicate the filtering, you can take four texels from the texture, and then four more from the next level of mip-texture, mixing them all. And what is it called in Direct3D? </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trilinear</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> filtering. Where did the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúthree‚Äù</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> come from in this process </font><font style="vertical-align: inherit;">? So we don‚Äôt know ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The last filtering method worth mentioning is </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anisotropic</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In fact, it is an improvement in the process performed by bilinear or trilinear filtering. Initially, it calculates</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the degree of anisotropy of</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the primitive surface (and this is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a surprisingly complex process</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - this value increases the change in the aspect ratio of the primitive due to its orientation:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/247/dfe/e60/247dfee60846988a5e94a1020d9ecef6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The figure above shows the same square primitive with equal side lengths; but gradually turning, it turns into a rectangle, and its width changes more than its height. Therefore, the primitive on the right has a greater degree of anisotropy than on the left (and in the case of a square, the degree is zero). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Many modern 3D games allow you to turn on anisotropic filtering and then change its level (from 1x to 16x), but what does it really change? This parameter controls the maximum number of additional texel samples that are taken in each initial linear sample. Suppose an anisotropic bilinear filtering of 8x is turned on in the game. This means that instead of four texel values, it will get 32 ‚Äã‚Äãvalues. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The difference when using anisotropic filtering is clearly noticeable:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/302/372/df7302372c6dc0d34730ba572f695063.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Just go up to the image above and compare the sampling of the nearest points with a maximum 16x anisotropic trilinear filtering. Amazingly smooth! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But for this smooth beauty of textures you have to pay with performance: at maximum settings, anisotropic trilinear filtering will receive 128 samples from the texture for each pixel of the rendering. Even with the very best modern GPUs this cannot be achieved in one clock cycle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you take, for example, AMD </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Radeon RX 5700 XT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then each of the texturing blocks inside the processor can use up to 32 texel addresses in one clock cycle, and then in the next clock cycle load 32 texel values ‚Äã‚Äãfrom memory (each of which has a size of 32 bits), and then mix four of them in one more tact. That is, to mix 128 texel samples into one requires at least 16 clock cycles.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/abf/cf4/fa4abfcf4411b6cc2622c8e77986ab3c.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU AMD RDNA Radeon RX 5700 with 7-nanometer process technology</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
If the clock speed of the 5700 XT is 1605 MHz, then sixteen cycles take only 10 </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nanoseconds</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Performing these cycles for each pixel in a 4K frame using just </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texture unit will take only 70 milliseconds. Great, it looks like performance is not a big deal! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Even in 1996, 3Dfx Voodoo and similar cards quickly coped with textures. At most they could give out 1 texel with bilinear filtering per cycle, and with a TMU chip frequency of 50 MHz, this meant that 50 million texels could be processed per second. A game running at 800 x 600 and 30 fps only requires 14 million texels with bilinear filtering per second.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, this is true only under the assumption that all textures are in the nearest memory and only one texel corresponds to each pixel. </font><font style="vertical-align: inherit;">Twenty years ago, the idea of ‚Äã‚Äãthe need to overlay several textures on a primitive was completely alien, but today it is a standard. </font><font style="vertical-align: inherit;">Let's see why this all changes.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add lighting</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To understand why texturing has become so important, take a look at this scene from Quake:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/dcf/ee4/bdadcfee4354ea561b9239e1ca5a143b.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a dark image, because darkness was the atmosphere of the game, but we see that the darkness is not the same everywhere - some fragments of walls and floors are lighter than others, which creates a feeling of lightness in these areas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The primitives that make up the walls and the floor are superimposed with the same textures, but there is another texture called the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúlight map‚Äù</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mixed with the values ‚Äã‚Äãof the texels before they are applied to the frame pixels. In Quake times, lighting maps were calculated in advance and created by the game engine. They were used to generate static and dynamic lighting levels.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The advantage of their use is that complex lighting calculations were performed with textures rather than vertices, which greatly improved the appearance of the scene at the expense of low speed costs. Obviously, the image is imperfect: on the floor it is noticeable that the border between the illuminated areas and shadows is very sharp. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In many ways, a lightmap is just another texture (don't forget that they are all regular 2D datasets), so this scene is one of the first examples of using </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">multitexturing</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. As the name implies, this is a process in which two or more textures are superimposed on a primitive. The use of lighting maps in Quake has become a way to overcome the limitations of Gouraud shading, but in the process of increasing the range of capabilities of graphic cards, the methods of applying multitexturing have also expanded. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3Dfx Voodoo, like many other cards of that era, was limited in the amount of operations that it could perform in a single </font><font style="vertical-align: inherit;">rendering </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pass</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In fact, a pass is a complete rendering cycle: from processing vertices to rasterizing the frame, and then changing the pixels and writing them to the finished frame buffer. Twenty years ago, games almost always used one-pass rendering.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a55/0b6/bc9/a550b6bc98c07f1c90276e1aa3721819.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nvidia GeForce 2 Ultra, around the end of 2000. Image: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikimedia</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
This happened because the second vertex processing just for applying additional textures was too costly in terms of performance. After Voodoo, we had to wait a couple of years when the ATI Radeon and Nvidia GeForce 2 graphics cards appeared, capable of multitexturing in one pass. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These GPUs had several texture units in the pixel processing area (that is, in the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pipeline</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), so getting a texel with bilinear filtering from two separate textures became the simplest task. This further increased the popularity of lighting maps and allowed games to make them fully dynamic, changing lighting values ‚Äã‚Äãdepending on the conditions of the gaming environment.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But with a few textures, much more could be done, so let's explore their capabilities.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To change the height is normal</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this series of articles about 3D rendering, we did not talk about how the role of the GPU affects the entire process (we will talk about this, but not now!). But if you go back to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">part 1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and read about the whole complex process of processing vertices, you might think that this is the most difficult part of all the work that the GPU must do. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a long time it was, and game programmers did everything possible to reduce this load. They had to go to all kinds of tricks to ensure the same image quality as when using multiple vertices, but do not process them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Most of these tricks used textures called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">height maps</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normal maps.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">These two concepts are connected by the fact that the latter can be created from the former, but for now, let's only look at a technique called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúbump mapping‚Äù</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/db2/5b6/1e3db25b6ecefc0dd3f75c84f767800c.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Images created in a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demo rendering by Emil Persson</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Embossed texturing is disabled / enabled. Embossed texturing</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
uses a 2D array called a ‚Äúheight map‚Äù that looks like a strange version of the original texture. </font><font style="vertical-align: inherit;">For example, the image above shows a realistic brick texture overlaid on two flat surfaces. </font><font style="vertical-align: inherit;">The texture and its height map look like this:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/87f/221/7a187f2215bcf0723bd4d4f820350858.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The colors of the height map indicate the normals of the surface of the bricks (we talked about the normals in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">part 1 of a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> series of articles). When the rendering process reaches the stage of applying the brick texture to the surface, a series of calculations are performed to change the color of the brick texture based on its normals. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result of this, the bricks themselves look more three-dimensional, despite the fact that they continue to remain completely flat. If you look closely, especially at the edges of the bricks, you can see the limitations of this technique: the texture looks slightly distorted. But this is a quick trick that allows you to add more surface detail, so embossed texturing is very popular.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A normal map is similar to a height map, only the texture colors are the normals themselves. In other words, calculations to convert the height map to normal are not required. You can ask a question: how can colors describe a vector in space? The answer is simple: each texel has a set of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r, g, b</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> values </font><font style="vertical-align: inherit;">(red, green, blue) and these values ‚Äã‚Äãdirectly correspond to the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x, y, z</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> values </font><font style="vertical-align: inherit;">of the normal vector.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1f/105/c3b/c1f105c3b93c455ba7661489770172c9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The left diagram shows the change in the direction of the normals on an uneven surface. To describe the same normals with a flat texture (middle outline), we assign them colors. In this case, we used the values </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r, g, b</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (0.255.0) for the vector directed straight up, and then increased the value of red for tilt to the left, and blue for tilt to the right. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keep in mind that this color does not mix with the original pixel, it simply tells the processor in which direction the normal indicates so that it can correctly calculate the angles between the camera, light sources and the textured surface.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The advantages of embossed texturing and normal maps are fully apparent when dynamic lighting is used in the scene, and when the rendering process calculates the effect of the lighting change pixel by pixel, and not for each vertex. Today, modern games use a set of textures to improve the quality of this trick.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ef/d59/660/3efd596604528593b16923297f10f044.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ryan Benno</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Surprisingly, this realistic-looking wall is just a flat surface, the details of bricks and masonry cement are not made using millions of polygons. Instead, just five textures and the thoughtful use of calculations are enough. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A height map was used to generate shadow casting with bricks, and a normal map was used to simulate all minor surface changes. The roughness texture was used to change the way light is reflected from various elements of the wall (for example, smooth brick reflects light more evenly than rough cement).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The last card, named in the AO image, creates a part of the process called ambient occlusion: we will examine this technique in more detail in the following articles, but for now let's say that it helps to increase the realism of shadows.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture mapping is a critical process.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Texturing is absolutely essential when developing games. Take, for example, the 2019 game </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kingdom Come: Deliverance</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a first-person RPG set in Bohemia in the 15th century. Designers sought to create the most realistic world of that period. And to immerse the player in life that was hundreds of years ago, it is best to implement a historically accurate landscape, buildings, clothes, hairstyles, everyday items, and much more. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each texture in this image from the game was manually created by artists, and also thanks to a rendering engine controlled by programmers. Some of them are small, with simple details, and therefore are slightly filtered or processed with other textures (for example, chicken wings).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2e/7d0/24a/e2e7d024ad0c700d26390940caf339ed.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Others have high resolution and many small details; </font><font style="vertical-align: inherit;">they undergo anisotropic filtering and mixing with normal maps and other textures - just look at the person‚Äôs face in the foreground. </font><font style="vertical-align: inherit;">The difference in the texturing requirements of each scene object is taken into account by programmers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All this happens today in many games, because players expect ever higher levels of detail and realism. </font><font style="vertical-align: inherit;">Textures are becoming larger, and more and more of them are superimposed on the surface, but the process of sampling texels and superimposing them on pixels essentially remains the same as in the days of Quake. </font><font style="vertical-align: inherit;">The best technologies never die, no matter how old they are!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en499524/index.html">Quarkus: application upgrades using the helloworld example from JBoss EAP Quickstart</a></li>
<li><a href="../en499528/index.html">A ‚Äústunning‚Äù mathematical bridge that extends beyond Fermat‚Äôs Great Theorem</a></li>
<li><a href="../en499532/index.html">Words in numbers: free blog analytics habravebinary with Yandex.Metrica</a></li>
<li><a href="../en499534/index.html">Python backend service development guide</a></li>
<li><a href="../en499536/index.html">Growbox as a method of knowing oneself</a></li>
<li><a href="../en499542/index.html">Top Fakapov Cyan</a></li>
<li><a href="../en499544/index.html">Learn neural networks in Google Sheets</a></li>
<li><a href="../en499546/index.html">Firmware development for an analog video camera EVR-Y2022F</a></li>
<li><a href="../en499548/index.html">Mask - caring for others or an illusion of security?</a></li>
<li><a href="../en499550/index.html">Ecosystem Low-Code Solutions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>