<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëçüèæ üßëüèø‚Äçü§ù‚ÄçüßëüèΩ üà¥ How to climb a tree ü§∏üèΩ ‚è¨ üë∏üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="More precisely, how to get down from it. But first things first. This article is a little out of the usual article format from PVS-Studio. We often wr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>How to climb a tree</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/502518/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/qf/qz/ys/qfqzys_fndtbks6hb68atbrnyrq.png" alt="Picture 2"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
More precisely, how to get down from it. </font><font style="vertical-align: inherit;">But first things first. </font><font style="vertical-align: inherit;">This article is a little out of the usual article format from PVS-Studio. </font><font style="vertical-align: inherit;">We often write about checking other projects, but almost never open the door to our inner kitchen. </font><font style="vertical-align: inherit;">It's time to fix it and talk about how the analyzer is built from the inside. </font><font style="vertical-align: inherit;">More precisely, about the most important of its parts - the syntax tree. </font><font style="vertical-align: inherit;">The article will focus on the part of PVS-Studio that relates to the C and C ++ languages.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First things first</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The syntax tree is the central part of any compiler. One way or another, the code needs to be presented in a form convenient for program processing, and it just so happens that the tree structure is best suited for this. I will not go into theory here - suffice it to say that the tree very well reflects the hierarchy of expressions and blocks in the code, and at the same time contains only the data necessary for work.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What does the compiler have to do with the static analyzer? The fact is that these two tools have a lot in common. At the initial stage of parsing the code, they do the same job. First, the code is divided into a stream of tokens, which is fed to the parser. Then, in the process of syntactic and semantic analysis, tokens are organized into a tree, which is sent further along the pipeline. At this stage, compilers can perform intermediate optimizations before generating binary code, static analyzers begin bypassing nodes and launching various checks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the PVS-Studio analyzer with a tree built, several things happen:</font></font><br>
<br>
<ul>
<li>    .    , , ,     <i>using </i>  <i>typedef</i>,   . ,  .         ;</li>
<li>     .  ,          ;</li>
<li>   ,      ,    ,      ;</li>
<li>  .        (      ).          . ,         <i>nullptr</i>    ,    ,         .       ;</li>
<li>  .      ,      .        ,    .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you are interested in the details of how the analysis works, I recommend reading the article ‚Äú </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Technologies Used in the PVS-Studio Code Analyzer for Finding Errors and Potential Vulnerabilities</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù. </font><font style="vertical-align: inherit;">Some points from the list are examined there in detail. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will look in more detail what happens to the tree inside the analyzer, and how it looks at all. </font><font style="vertical-align: inherit;">With a brief introduction over, it‚Äôs time to get to the bottom of the matter.</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/si/xk/o4/sixko4j1_uucanebxzup6slqpf8.png" alt="Picture 1"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How it works</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Historically, PVS-Studio uses a binary tree to represent code. This classic data structure is familiar to everyone - we have a node that generally refers to two children. Nodes that are not supposed to have descendants, I will call terminals, all others - non-terminals. A nonterminal may in some cases not have child nodes, but its key difference from the terminal is that descendants are fundamentally allowed for it. Terminal nodes (or leaves) lack the ability to refer to something other than the parent.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The structure used in PVS-Studio is slightly different from the classical binary tree - this is necessary for convenience. </font><font style="vertical-align: inherit;">Terminal nodes usually correspond to keywords, variable names, literals, and so on. </font><font style="vertical-align: inherit;">Non-terminals - various types of expressions, blocks of code, lists, and the like, the constituent elements of a tree </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From the point of view of compilers, everything is pretty standard here, I advise everyone interested in the classics of the genre - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Dragon Book</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We are moving on. </font><font style="vertical-align: inherit;">Let's look at a simple code example and how the analyzer sees it. </font><font style="vertical-align: inherit;">Further there will be many pictures from our internal tree visualization utility. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Actually, an example:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span>
</span>{
  <span class="hljs-keyword">return</span> a + b;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This simple function after processing by the parser will look like this (non-terminal nodes are highlighted in yellow):</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/eo/nj/od/eonjodrufyrv6p3w2riiysnfnpo.png" alt="Picture 6"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This view has its pros and cons, and the latter, in my opinion, a little more. But let's look at the tree. Immediately make a reservation that it is somewhat redundant, for example, because it contains punctuation and parentheses. From the point of view of compilation, this is superfluous garbage, but such information is sometimes needed by the analyzer for some diagnostic rules. In other words, the analyzer does not work with the abstract syntax tree (AST), but with </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the parse tree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (DT). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The tree grows from left to right and from top to bottom. Left child nodes always contain something meaningful, such as declarators. If you look to the right, we will see intermediate non-terminals marked with the word </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NonLeaf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">They are needed only so that the tree retains its structure. </font><font style="vertical-align: inherit;">For the needs of analysis, such nodes do not carry any information load. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
While we will be interested in the left part of the tree. </font><font style="vertical-align: inherit;">Here it is in a larger closeup:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/vf/gm/ku/vfgmku_i7oq4oakzu_2gnowmfk8.png" alt="Picture 10"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This ad features. </font><font style="vertical-align: inherit;">The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeDeclarator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parent node </font><font style="vertical-align: inherit;">is an object through which you can access nodes with the name of the function and its parameters. </font><font style="vertical-align: inherit;">It also stores the encoded signature for the type system. </font><font style="vertical-align: inherit;">It seems to me that this picture is pretty visual, and it‚Äôs pretty easy to compare the elements of the tree with the code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Looks easy, right? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For clarity, let's take a simpler example. </font><font style="vertical-align: inherit;">Imagine that we have code that calls our function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">f(<span class="hljs-number">42</span>, <span class="hljs-number">23</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A function call in the tree will look like this:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/mf/jx/r2/mfjxr27uqexjmd3olssajdys7lw.png" alt="Picture 12"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The structure is very similar, only here we see a function call instead of its declaration. Now suppose we wanted to go through all the arguments and do something with each of them. This is a real task that is often found in analyzer code. It is clear that everything is not limited to arguments, and different types of nodes have to be sorted, but now we will consider this specific example. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose we only have a pointer to the parent </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FUNCALL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> node </font><font style="vertical-align: inherit;">. From any non-terminal, we can get the left and right child nodes. The type of each of them is known. We know the structure of the tree, so that we can immediately reach the node under which the list of arguments lies - this is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NonLeaf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , from which the terminal grows in the picture </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">42</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We don‚Äôt know the number of arguments in advance, and there are commas in the list that in this case are absolutely not of interest to us. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How will we do this? </font><font style="vertical-align: inherit;">Read on.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bicycle factory</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It would seem that iterating through a tree is quite simple. You just need to write a function that will do this, and use it everywhere. It is possible to pass it a lambda as an argument to handle each element. It really would be so, if not for a couple of nuances. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Firstly, going around a tree every time has to be a little different. The logic of processing each node is different, as well as the logic of working with the entire list. Say, in one case, we want to go through the list arguments and pass each of them to a certain function for processing. In another, we want to select and return one argument that meets some requirements. Or filter the list and discard any uninteresting elements from it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secondly, sometimes you need to know the index of the current element. </font><font style="vertical-align: inherit;">For example, we want to process only the first two arguments and stop. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Third, let's digress from the function example. </font><font style="vertical-align: inherit;">Say we have code like this:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span>
</span>{
  <span class="hljs-keyword">int</span> c = a + b;<font></font>
  c *= <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">42</span>) <span class="hljs-keyword">return</span> c;
  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This code is dumb, I know, but let's concentrate now on how the tree looks. </font><font style="vertical-align: inherit;">We have already seen a function declaration, here we need its body:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/f0/q6/hs/f0q6hsldd42blwuenxmv2t6vl7o.png" alt="Picture 4"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This case is like a list of arguments, but you may notice some difference. </font><font style="vertical-align: inherit;">Take another look at the picture from the previous section. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Have you noticed? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's right, there are no commas in this list, which means that you can process it in a row and not worry about skipping separators. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In total, we have at least two cases:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separated list.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The complete list.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's see how this all happens in the analyzer code. Here is an example of traversing a list of arguments. This is a simplified version of one of the functions in the translator.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessArguments</span><span class="hljs-params">(Ptree* arglist)</span>
</span>{
  <span class="hljs-keyword">if</span> (!arglist) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  Ptree* args = Second(arglist);<font></font>
  <span class="hljs-keyword">while</span> (args)<font></font>
  {<font></font>
    Ptree* p = args-&gt;Car();<font></font>
    <span class="hljs-keyword">if</span> (!Eq(p, <span class="hljs-string">','</span>))<font></font>
    {<font></font>
      ProcessArg(p);<font></font>
    }<font></font>
<font></font>
    args = args-&gt;Cdr();<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If I were paid a dollar every time I see a similar code, I would already get rich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's see what happens here. I must say right away that this is very old code written long before even C ++ 11, not to mention more modern standards. We can say that I specifically looked for a fragment of the times of ancient civilizations. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, firstly, this function accepts a list of arguments in parentheses as input. Something like this: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(42, 23) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Second</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">is called here to get the contents of the brackets. All she does is move once to the right and then once to the left through the binary tree. Next, the loop sequentially gets the elements: 42, then a comma, then 23, and in the next step, the </font><i><font style="vertical-align: inherit;">args</font></i><font style="vertical-align: inherit;"> pointer</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">becomes zero because we get to the end of the branch. The loop, of course, skips uninteresting commas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Similar functions with slightly changed logic can be found in many places, especially in the old code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another example. How do I know if there is a call to a certain function in a certain block of code? Like that:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsFunctionCalled</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* body, <span class="hljs-built_in">std</span>::string_view name)</span>
</span>{
  <span class="hljs-keyword">if</span> (!arglist) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  <span class="hljs-keyword">const</span> Ptree* statements = body;
  <span class="hljs-keyword">while</span> (statements)<font></font>
  {<font></font>
    <span class="hljs-keyword">const</span> Ptree* cur = statements-&gt;Car();
    <span class="hljs-keyword">if</span> (IsA(cur, ntExprStatement) &amp;&amp; IsA(cur-&gt;Car(), ntFuncallExpr))<font></font>
    {<font></font>
      <span class="hljs-keyword">const</span> Ptree* funcName = First(cur-&gt;Car());
      <span class="hljs-keyword">if</span> (Eq(funcName, name))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
<font></font>
    statements = statements-&gt;Cdr();<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note. </font><font style="vertical-align: inherit;">An attentive reader may notice. </font><font style="vertical-align: inherit;">How old is he? </font><font style="vertical-align: inherit;">There </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: string_view</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sticks out. </font><font style="vertical-align: inherit;">Everything is simple, even the oldest code is gradually refactored and gradually nothing of the kind will remain. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It would be nice to use something more elegant here, right? </font><font style="vertical-align: inherit;">Well, for example, the standard </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_if</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algorithm </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">What is the algorithm there, even a normal range-based for would greatly improve readability and facilitate the support of such code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's try to achieve this.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Put the tree in the box</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our goal is to make the tree behave like an STL container. </font><font style="vertical-align: inherit;">Moreover, we should not care about the internal structure of the lists, we want to uniformly iterate over the nodes, for example, like this:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoSomethingWithTree</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* tree)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cur : someTreeContainer)<font></font>
  {<font></font>
    ....<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, here we have a certain entity called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">someTreeContainer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which we do not know about yet. </font><font style="vertical-align: inherit;">Such a container should have at least </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">begin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">end</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> methods </font><font style="vertical-align: inherit;">that return iterators. </font><font style="vertical-align: inherit;">Speaking of iterators, they should also behave like standard ones. </font><font style="vertical-align: inherit;">Let's start with them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the simplest case, the iterator looks like this:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t,
          <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt;&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeIterator</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> value_type = Node_t;
  <span class="hljs-keyword">using</span> dereference_type = value_type;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer   = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
    <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  ....<font></font>
<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    m_node = Rest(m_node);<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;dereference_type&gt;(First(m_node));<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order not to clutter up the code, I removed some details. </font><font style="vertical-align: inherit;">The key points here are dereferencing and increment. </font><font style="vertical-align: inherit;">The template is needed so that the iterator can work with both constant and non-constant data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we will write the container in which we will place the tree node. </font><font style="vertical-align: inherit;">Here is the simplest option:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeContainer</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = PtreeIterator&lt;Node_t&gt;;
  <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> Iterator::dereference_type;
  <span class="hljs-keyword">using</span> size_type  = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">typename</span> Iterator::difference_type;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeContainer(Node_t* nodes) :<font></font>
    m_nodes{ nodes }<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (IsLeaf(m_nodes))<font></font>
    {<font></font>
      m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  ....<font></font>
<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> begin() == end();<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We are done, we can disperse, thanks for your attention. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No, wait a moment. </font><font style="vertical-align: inherit;">It can't be that simple, right? </font><font style="vertical-align: inherit;">Let's go back to our two list options - with and without delimiters. </font><font style="vertical-align: inherit;">Here, when incrementing, we simply take the right node of the tree, so this does not solve the problem. </font><font style="vertical-align: inherit;">We still need to skip commas if we want to work only with data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Not a problem, we just add an additional template parameter to the iterator. </font><font style="vertical-align: inherit;">Let's say like this:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeIteratorTag</span> :</span> <span class="hljs-keyword">uint8_t</span><font></font>
{<font></font>
  Statement,<font></font>
  List<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, PtreeIteratorTag tag,
  <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt; = <span class="hljs-number">0</span>&gt;<font></font>
class PtreeIterator { .... };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How will this help us? </font><font style="vertical-align: inherit;">Elementary. </font><font style="vertical-align: inherit;">We will check this parameter in increments and behave accordingly. </font><font style="vertical-align: inherit;">Fortunately, in C ++ 17 we can solve this at the compilation stage using the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if constexpr construct</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">PtreeIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
{<font></font>
  <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
  </span>{<font></font>
    m_node = Rest(m_node);<font></font>
  }<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
    m_node = RestRest(m_node);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's better, now we can choose an iterator to fit our needs. </font><font style="vertical-align: inherit;">What to do with containers? </font><font style="vertical-align: inherit;">You can, for example, like this:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, PtreeIteratorTag tag&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeContainer</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = PtreeIterator&lt;Node_t, tag&gt;;<font></font>
  ....<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, are we definitely done? </font><font style="vertical-align: inherit;">In fact, not really.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But that's not all</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at this code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(Ptree* argList, Ptree* enumPtree)</span>
</span>{
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">ptrdiff_t</span> argListLen = Length(argList);
  <span class="hljs-keyword">if</span> (argListLen &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">ptrdiff_t</span> i = <span class="hljs-number">0</span>; i &lt; argListLen; ++i)<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<font></font>
    Ptree* elem;<font></font>
<font></font>
    <span class="hljs-keyword">const</span> EGetEnumElement r = GetEnumElementInfo(enumPtree, i, elem, name);<font></font>
    ....<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I really don‚Äôt like much in this code, starting from the loop with the counter, and ending with the fact that the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetEnumElementInfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">looks very suspicious. </font><font style="vertical-align: inherit;">Now it remains a black box for us, but we can assume that it takes out the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> element </font><font style="vertical-align: inherit;">by index and returns its name and node in the tree through the output parameters. </font><font style="vertical-align: inherit;">The return value is also a bit strange. </font><font style="vertical-align: inherit;">Let's get rid of it altogether - an ideal job for our list iterator:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem : PtreeContainer&lt;<span class="hljs-keyword">const</span> Ptree, PtreeIteratorTag::List&gt;(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Not bad. </font><font style="vertical-align: inherit;">Only this code does not compile. </font><font style="vertical-align: inherit;">Why? </font><font style="vertical-align: inherit;">Because the index we removed was used in the body of the loop below the call to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetEnumElementInfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">I will not say here exactly how it was used, because it is not important now. </font><font style="vertical-align: inherit;">Suffice it to say that an index is needed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, let's add a variable and mess up our beautiful code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem : PtreeContainer&lt;<span class="hljs-keyword">const</span> Ptree, PtreeIteratorTag::List&gt;(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
    UseIndexSomehow(i++);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Still a working option, but I personally react to something like this:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ov/11/ie/ov11ieyylfaa2qjppdyjjo-yljy.png" alt="Picture 7"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, let's try to solve this problem. </font><font style="vertical-align: inherit;">We need something that can count elements automatically. </font><font style="vertical-align: inherit;">Add an iterator with a counter. </font><font style="vertical-align: inherit;">I again skipped the extra details for brevity:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, PtreeIteratorTag tag,
  <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt;&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeCountingIterator</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> value_type = Node_t;
  <span class="hljs-keyword">using</span> dereference_type = <span class="hljs-built_in">std</span>::pair&lt;value_type, size_type&gt;;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeCountingIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  ....<font></font>
<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
    </span>{<font></font>
      m_node = Rest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
      m_node = RestRest(m_node);<font></font>
    }<font></font>
<font></font>
    ++m_counter;<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> { <span class="hljs-keyword">static_cast</span>&lt;value_type&gt;(First(m_node)), counter() };<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
  size_type m_counter = <span class="hljs-number">0</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we can write such code, right?</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [elem, i] :<font></font>
            PtreeCountedContainer&lt;<span class="hljs-keyword">const</span> Ptree, PtreeIteratorTag::List&gt;(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
    UseIndexSomehow(i);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, we really can, but there is one problem. </font><font style="vertical-align: inherit;">If you look at this code, you may notice that we introduced another entity - something named </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeCountedContainer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It seems that the situation is getting complicated. </font><font style="vertical-align: inherit;">I really do not want to juggle with different types of containers, and given that they are the same inside, the hand itself reaches for Occam's razor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We'll have to use an iterator as a template parameter for the container, but more on that later.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zoo types</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Distract from counters and varieties of iterators for a minute. </font><font style="vertical-align: inherit;">In pursuit of a universal bypass of nodes, we forgot about the most important thing - the tree itself. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Take a look at this code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> a, b, c = <span class="hljs-number">0</span>, d;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What we see in the tree:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/mi/cq/sh/micqshmftdnb7xstjo71sng02s4.png" alt="Picture 13"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's now iterate over the list of declarators, but first I will tell you something else about the tree. </font><font style="vertical-align: inherit;">All the time before that, we were dealing with a pointer to the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ptree</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is the base class from which all other types of nodes are inherited. </font><font style="vertical-align: inherit;">Through their interfaces we can get additional information. </font><font style="vertical-align: inherit;">In particular, the topmost node in the picture can return to us the list of declarators without using utility functions like </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Second</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Also, we do not need low-level methods </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Car</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cdr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (hello to fans of the Lisp language). </font><font style="vertical-align: inherit;">This is very good, since in diagnostics we can ignore the implementation of the tree. </font><font style="vertical-align: inherit;">I think everyone agrees that current abstractions are very bad.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is how the bypass of all declarators looks like:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDecl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclarator* decl)</span> </span>{ .... }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDeclarators</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclaration* declaration)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> decl : declaration-&gt;GetDeclarators())<font></font>
  {<font></font>
    ProcessDecl(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> PtreeDeclarator*&gt;(decl));<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetDeclarators</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">returns an </font><i><font style="vertical-align: inherit;">iterable</font></i><font style="vertical-align: inherit;"> container. </font><font style="vertical-align: inherit;">Its type in this case is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeContainer &lt;const Ptree, PtreeIteratorTag :: List&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With this code, everything would be fine if not for the cast. </font><font style="vertical-align: inherit;">The fact is that the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessDecl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">wants a pointer to a class derived from </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ptree</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but our iterators do not know anything about it. </font><font style="vertical-align: inherit;">I would like to get rid of the need to convert types manually. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It seems that it's time to change the iterator again and add the ability to cast.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t, PtreeIteratorTag tag,
  <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt;&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeIterator</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> value_type = Deref_t;
  <span class="hljs-keyword">using</span> dereference_type = value_type;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order not to write all these template arguments manually each time, we add a few aliases for all occasions:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's better. </font><font style="vertical-align: inherit;">Now, if we do not need castes, we can specify only the first template argument, and we can also not clog our heads with the value of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tag</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parameter </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But what to do with containers? </font><font style="vertical-align: inherit;">Let me remind you that we want to have only one universal class that is suitable for any iterator. </font><font style="vertical-align: inherit;">Now it‚Äôs indecently many different combinations, and we need simplicity. </font><font style="vertical-align: inherit;">Something like this:</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/xc/nv/ik/xcnvik7rkulnyybu6jngdpcrv4w.png" alt="Picture 39"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, we want a single container class to be able to support all types of our iterators and be able to tell them which type to return when dereferencing. </font><font style="vertical-align: inherit;">Then, in the code, we simply create the container we need and start working with it without thinking about which iterators we need. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will examine this question in the next section.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pattern magic</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So here is what we need:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One container that can work universally with any iterator.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An iterator, which, depending on the list of nodes, can work both with each element, and through one.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same iterator, but with a counter.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both iterators should be able to cast when dereferencing, if the type is additionally specified.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First of all, we need to somehow bind the container type to the iterator type through template parameters. </font><font style="vertical-align: inherit;">Here's what happened:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">typename</span> FwdIt,
          <span class="hljs-keyword">typename</span> Node_t,
          <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;<font></font>
class PtreeContainer<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = FwdIt&lt;Node_t, Deref_t&gt;;
  <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> Iterator::dereference_type;
  <span class="hljs-keyword">using</span> size_type  = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> difference_type = <span class="hljs-keyword">typename</span> Iterator::difference_type;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeContainer(Node_t* nodes) :<font></font>
    m_nodes{ nodes }<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (IsLeaf(m_nodes))<font></font>
    {<font></font>
      m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  ....<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> begin() == end();<font></font>
  }<font></font>
  ....<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also, you can add more methods to the container. </font><font style="vertical-align: inherit;">For example, this is how we can find out the number of elements:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">difference_type <span class="hljs-title">count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::distance(begin(), end());<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Or here is the indexing operator:</font></font><br>
<br>
<pre><code class="cpp hljs">value_type <span class="hljs-keyword">operator</span>[](size_type index) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
{<font></font>
  size_type i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin(); it != end(); ++it)<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (i++ == index)<font></font>
    {<font></font>
      <span class="hljs-keyword">return</span> *it;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> value_type{};<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is clear that you need to handle such methods carefully because of their linear complexity, but sometimes they are useful. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For ease of use, add aliases:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementList =<font></font>
PtreeContainer&lt;PtreeStatementIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeItemList =<font></font>
PtreeContainer&lt;PtreeListIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedStatementList =<font></font>
PtreeContainer&lt;PtreeStatementCountingIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedItemList =<font></font>
PtreeContainer&lt;PtreeListCountingIterator, Node_t, Deref_t&gt;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we can create containers easily. </font><font style="vertical-align: inherit;">Say, in the already mentioned </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeDeclaration</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><i><font style="vertical-align: inherit;">,</font></i><font style="vertical-align: inherit;"> we want to get a </font><font style="vertical-align: inherit;">container </font><font style="vertical-align: inherit;">from the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetDeclarators</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">, the iterator of which skips separators, while there is no counter in it, and when dereferenced, it returns a value of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeDeclarator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> type </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Here is the declaration of such a container:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> DeclList =<font></font>
      Iterators::PtreeItemList&lt;Ptree, PtreeDeclarator*&gt;;<font></font>
<span class="hljs-keyword">using</span> ConstDeclList =<font></font>
      Iterators::PtreeItemList&lt;<span class="hljs-keyword">const</span> Ptree, <span class="hljs-keyword">const</span> PtreeDeclarator*&gt;;<font></font>
             :<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDecl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclarator* decl)</span> </span>{ .... }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDeclarators</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclaration* declaration)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> decl : declaration-&gt;GetDeclarators())<font></font>
  {<font></font>
    ProcessDecl(decl);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And finally, since type inference for aliases will appear only in C ++ 20, in order to more conveniently create containers in the code, we added such functions:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeStatementList&lt;Node_t&gt; <span class="hljs-title">MakeStatementList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeItemList&lt;Node_t&gt; <span class="hljs-title">MakeItemList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeCountedStatementList&lt;Node_t&gt; <span class="hljs-title">MakeCountedStatementList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeCountedItemList&lt;Node_t&gt; <span class="hljs-title">MakeCountedItemList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recall the function that worked with </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Now we can write it like this:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [elem, i] : MakeCountedItemList(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
    UseIndexSomehow(i);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compare with the original version, it seems to me, it has become better:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(Ptree* argList, Ptree* enumPtree)</span>
</span>{
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">ptrdiff_t</span> argListLen = Length(argList);
  <span class="hljs-keyword">if</span> (argListLen &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">ptrdiff_t</span> i = <span class="hljs-number">0</span>; i &lt; argListLen; ++i)<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<font></font>
    Ptree* elem;<font></font>
<font></font>
    <span class="hljs-keyword">const</span> EGetEnumElement r = GetEnumElementInfo(enumPtree, i, elem, name);<font></font>
    ....<font></font>
    UseIndexSomehow(i);<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's all, folks</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's all for me, thank you for your attention. </font><font style="vertical-align: inherit;">I hope you found out something interesting or even useful. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
According to the content of the article, it may seem that I am scolding the code of our analyzer and want to say that everything is bad there. </font><font style="vertical-align: inherit;">This is not true. </font><font style="vertical-align: inherit;">Like any project with a history, our analyzer is full of geological deposits that have remained from past eras. </font><font style="vertical-align: inherit;">Consider that we have just excavated, removed artifacts from the ancient civilization from under the ground and carried out the restoration to make them look good on the shelf.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P.S</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There will be a lot of code here. </font><font style="vertical-align: inherit;">I doubted whether to include the implementation of iterators here or not, and in the end I decided to include so as not to leave anything behind the scenes. </font><font style="vertical-align: inherit;">If you are not interested in reading the code, here I will say goodbye to you. </font><font style="vertical-align: inherit;">The rest I wish you a pleasant time with templates.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code</font></font></b>
                        <div class="spoiler_text"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regular iterator</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t, PtreeIteratorTag tag,
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt; = <span class="hljs-number">0</span>&gt;<font></font>
class PtreeIterator<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> value_type = Deref_t;
  <span class="hljs-keyword">using</span> dereference_type = value_type;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  PtreeIterator() = <span class="hljs-keyword">delete</span>;<font></font>
  PtreeIterator(<span class="hljs-keyword">const</span> PtreeIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> PtreeIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeIterator(PtreeIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>=(PtreeIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> PtreeIterator &amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> m_node == other.m_node;<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> PtreeIterator &amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<font></font>
  }<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
    </span>{<font></font>
      m_node = Rest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
      m_node = RestRest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
  PtreeIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> tmp = *<span class="hljs-keyword">this</span>;<font></font>
    ++(*<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> tmp;<font></font>
  }<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;dereference_type&gt;(First(m_node));<font></font>
  }<font></font>
  pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> &amp;(**<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">Node_t* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_node;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator with counter</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t, PtreeIteratorTag tag,
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt; = <span class="hljs-number">0</span>&gt;<font></font>
class PtreeCountingIterator<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> value_type = Deref_t;
  <span class="hljs-keyword">using</span> dereference_type = <span class="hljs-built_in">std</span>::pair&lt;value_type, size_type&gt;;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
 <span class="hljs-keyword">public</span>:<font></font>
  PtreeCountingIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  PtreeCountingIterator() = <span class="hljs-keyword">delete</span>;<font></font>
  PtreeCountingIterator(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeCountingIterator(PtreeCountingIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>=(PtreeCountingIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> m_node == other.m_node;<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<font></font>
  }<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
    </span>{<font></font>
      m_node = Rest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
      m_node = RestRest(m_node);<font></font>
    }<font></font>
<font></font>
    ++m_counter;<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
  PtreeCountingIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> tmp = *<span class="hljs-keyword">this</span>;<font></font>
    ++(*<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> tmp;<font></font>
  }<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> { <span class="hljs-keyword">static_cast</span>&lt;value_type&gt;(First(m_node)), counter() };<font></font>
  }<font></font>
  value_type <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> (**<span class="hljs-keyword">this</span>).first;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">size_type <span class="hljs-title">counter</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_counter;<font></font>
  }<font></font>
  <span class="hljs-function">Node_t* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_node;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
  size_type m_counter = <span class="hljs-number">0</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generic container</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">typename</span> FwdIt,
          <span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;<font></font>
class PtreeContainer<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = FwdIt&lt;Node_t, Deref_t&gt;;
  <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> Iterator::dereference_type;
  <span class="hljs-keyword">using</span> size_type  = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> difference_type = <span class="hljs-keyword">typename</span> Iterator::difference_type;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeContainer(Node_t* nodes) :<font></font>
    m_nodes{ nodes }<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (IsLeaf(m_nodes))<font></font>
    {<font></font>
      m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  PtreeContainer() = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer(<span class="hljs-keyword">const</span> PtreeContainer&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> PtreeContainer&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer(PtreeContainer&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer&amp; <span class="hljs-keyword">operator</span>=(PtreeContainer&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">nullptr_t</span>) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> empty();<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">nullptr_t</span>) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == <span class="hljs-literal">nullptr</span>);<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(Node_t* node) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> get() == node;<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(Node_t* node) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == node);<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(PtreeContainer other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> get() == other.get();<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(PtreeContainer other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<font></font>
  }<font></font>
  value_type <span class="hljs-keyword">operator</span>[](size_type index) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    size_type i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin(); it != end(); ++it)<font></font>
    {<font></font>
      <span class="hljs-keyword">if</span> (i++ == index)<font></font>
      {<font></font>
        <span class="hljs-keyword">return</span> *it;<font></font>
      }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> value_type{};<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> begin() == end();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">value_type <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>)[<span class="hljs-number">0</span>];<font></font>
  }<font></font>
  <span class="hljs-function">value_type <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{<font></font>
    value_type last{};<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cur : *<span class="hljs-keyword">this</span>)<font></font>
    {<font></font>
      last = cur;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> last;<font></font>
  }<font></font>
  <span class="hljs-function">Node_t* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">difference_type <span class="hljs-title">count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::distance(begin(), end());<font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">has_at_least</span><span class="hljs-params">(size_type n)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{<font></font>
    size_type counter = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin(); it != end(); ++it)<font></font>
    {<font></font>
      <span class="hljs-keyword">if</span> (++counter == n)<font></font>
      {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementList =<font></font>
PtreeContainer&lt;PtreeStatementIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeItemList =<font></font>
PtreeContainer&lt;PtreeListIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedStatementList =<font></font>
PtreeContainer&lt;PtreeStatementCountingIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedItemList =<font></font>
PtreeContainer&lt;PtreeListCountingIterator, Node_t, Deref_t&gt;;</code></pre><br>
</div>
                    </div><br>
<p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="></a></p><div style="text-align:center;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png"></a></div><p></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you want to share this article with an English-speaking audience, then please use the link to the translation: Yuri Minaev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to climb a tree</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en502500/index.html">The evolution of a passport scanner: from plywood crafts to real business</a></li>
<li><a href="../en502504/index.html">Surround the user digit</a></li>
<li><a href="../en502508/index.html">Trolley Robot 2.0. Part 2. Management in rviz and without. Elements of beauty in rviz</a></li>
<li><a href="../en502510/index.html">What to save in the cloud</a></li>
<li><a href="../en502512/index.html">Results of the contest of sofa experts: the rules of scientific poking</a></li>
<li><a href="../en502520/index.html">Video reports of mitap reports on product analytics</a></li>
<li><a href="../en502522/index.html">We open the galvanic isolation chip with a tiny transformer inside</a></li>
<li><a href="../en502554/index.html">Middle information technology as a way out of crisis</a></li>
<li><a href="../en502556/index.html">Microsoft Build 2020 conference - completely online today (look directly at Habr√©)</a></li>
<li><a href="../en502558/index.html">How I Collected Wheel Physics at Unigine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>