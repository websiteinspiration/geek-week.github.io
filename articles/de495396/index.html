<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔇 🍤 🔬 Erster Eindruck von Konzepten 🚽 👨🏻‍🏭 👣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe mich für die neuen C ++ 20-Feature-Konzepte entschieden. 
 
 Konzepte (oder Konzepte , wie das russischsprachige Wiki schreibt) sind eine seh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Erster Eindruck von Konzepten</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495396/"><img src="https://habrastorage.org/webt/qd/ja/kc/qdjakcxd4173w_juzv5fx3bf0_o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe mich für die neuen C ++ 20-Feature-Konzepte entschieden. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konzepte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (oder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konzepte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wie das russischsprachige Wiki schreibt) sind eine sehr interessante und nützliche Funktion, die seit langem fehlt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Wesentlichen werden Vorlagenargumente eingegeben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Hauptproblem von Vorlagen vor C ++ 20 besteht darin, dass Sie alles in ihnen ersetzen können, einschließlich etwas, für das sie überhaupt nicht entwickelt wurden. Das heißt, das Vorlagensystem war vollständig untypisiert. Infolgedessen traten unglaublich lange und völlig unlesbare Fehlermeldungen auf, wenn der falsche Parameter an die Vorlage übergeben wurde. Sie haben versucht, dies mit Hilfe verschiedener Sprach-Hacks zu bekämpfen, die ich nicht einmal erwähnen möchte (obwohl ich mich damit befassen musste).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Konzepte sollen dieses Missverständnis korrigieren. </font><font style="vertical-align: inherit;">Sie fügen den Vorlagen ein Schreibsystem hinzu, das sehr leistungsfähig ist. </font><font style="vertical-align: inherit;">Nachdem ich die Funktionen dieses Systems verstanden hatte, begann ich, die verfügbaren Materialien im Internet zu studieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ehrlich gesagt bin ich ein wenig schockiert :) C ++ ist eine bereits komplizierte Sprache, aber zumindest gibt es eine Entschuldigung: Es ist passiert. </font><font style="vertical-align: inherit;">Beim Entwerfen einer Sprache wurde die Metaprogrammierung von Vorlagen entdeckt und nicht festgelegt. </font><font style="vertical-align: inherit;">Und dann, als sie die nächsten Versionen der Sprache entwickelten, mussten sie sich an diese „Entdeckung“ anpassen, da in der Welt viel Code geschrieben wurde. </font><font style="vertical-align: inherit;">Konzepte sind eine grundlegend neue Chance. </font><font style="vertical-align: inherit;">Und es scheint mir, dass ihre Umsetzung bereits eine gewisse Undurchsichtigkeit aufweist. </font><font style="vertical-align: inherit;">Vielleicht ist dies eine Folge der Notwendigkeit, die enorme Menge an vererbten Fähigkeiten zu berücksichtigen? </font><font style="vertical-align: inherit;">Versuchen wir es herauszufinden ...</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allgemeine Information</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Konzept ist eine neue Sprachentität, die auf der Vorlagensyntax basiert. </font><font style="vertical-align: inherit;">Ein Konzept hat einen Namen, Parameter und einen Körper - ein Prädikat, das abhängig von den Parametern des Konzepts einen konstanten (d. H. In der Kompilierungsphase berechneten) logischen Wert zurückgibt. </font><font style="vertical-align: inherit;">So:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt; 
<span class="hljs-keyword">concept</span> Even = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;  <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> FourByte = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Technisch gesehen sind Konzepte Template-Constexpr-Ausdrücken wie bool sehr ähnlich:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> EvenX = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> FourByteX = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können Konzepte sogar in allgemeinen Ausdrücken verwenden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Even&lt;<span class="hljs-number">2</span>&gt;; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden von</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptidee der Konzepte besteht darin, dass sie anstelle des Typnamens oder der Klassenschlüsselwörter in Vorlagen verwendet werden können. </font><font style="vertical-align: inherit;">Wie Metatypen ("Typen für Typen"). </font><font style="vertical-align: inherit;">Somit wird eine statische Typisierung in die Vorlagen eingeführt.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;FourByte T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp; t)</span> </span>{}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir nun int als Vorlagenparameter verwenden, wird der Code in den allermeisten Fällen kompiliert. </font><font style="vertical-align: inherit;">und wenn doppelt, wird eine kurze und verständliche Fehlermeldung ausgegeben. </font><font style="vertical-align: inherit;">Einfache und übersichtliche Eingabe von Vorlagen, bisher ist alles in Ordnung.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfordert</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein neues "kontextuelles" C ++ 20-Schlüsselwort mit einem doppelten Zweck: erfordert Klausel und erfordert Ausdruck. </font><font style="vertical-align: inherit;">Wie später gezeigt wird, führt diese seltsame Keyword-Einsparung zu Verwirrung.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfordert Ausdruck</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie zunächst den Ausdruck. </font><font style="vertical-align: inherit;">Die Idee ist ziemlich gut: Dieses Wort hat einen Block in geschweiften Klammern, dessen Code zur Kompilierung ausgewertet wird. </font><font style="vertical-align: inherit;">Der dortige Code sollte zwar nicht </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in C ++ geschrieben sein, sondern in einer speziellen Sprache, die C ++ nahe kommt, aber seine eigenen Eigenschaften hat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (dies ist die erste Kuriosität, es war durchaus möglich, nur C ++ - Code zu erstellen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Code korrekt ist - erfordert Ausdruck, dass true zurückgegeben wird, andernfalls false. </font><font style="vertical-align: inherit;">Der Code selbst wird natürlich niemals in die Codegenerierung einbezogen, ähnlich wie Ausdrücke in Größe oder Dekltyp. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider ist das Wort kontextbezogen und funktioniert nur innerhalb von Vorlagen, dh außerhalb der Vorlage wird dies nicht kompiliert:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b = <span class="hljs-keyword">requires</span> { <span class="hljs-number">3.14</span> &gt;&gt; <span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und in der Vorlage - bitte:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> Shiftable = <span class="hljs-keyword">requires</span>(T i) { i&gt;&gt;<span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und es wird funktionieren:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Shiftable&lt;<span class="hljs-keyword">int</span>&gt;; <span class="hljs-comment">// true</span>
<span class="hljs-keyword">bool</span> b2 = Shiftable&lt;<span class="hljs-keyword">double</span>&gt;; <span class="hljs-comment">// false</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptverwendung von erfordert Ausdruck ist die Erstellung von Konzepten. </font><font style="vertical-align: inherit;">Auf diese Weise können Sie beispielsweise das Vorhandensein von Feldern und Methoden in einem Typ überprüfen. </font><font style="vertical-align: inherit;">Ein sehr beliebter Fall.</font></font><br>
<br>
<pre><code class="plaintext hljs">template &lt;typename T&gt;<font></font>
concept Machine = <font></font>
  requires(T m) {  //   `m` ,   Machine<font></font>
	m.start();     //    `m.start()` <font></font>
	m.stop();      //   `m.stop()`<font></font>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Übrigens müssen alle Variablen, die im getesteten Code erforderlich sein können (nicht nur die Vorlagenparameter), in Klammern deklariert werden. </font><font style="vertical-align: inherit;">Aus irgendeinem Grund ist das Deklarieren einer Variablen einfach nicht möglich.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typprüfung im Inneren erfordert</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier beginnen die Unterschiede zwischen dem erforderlichen Code und dem Standard-C ++. </font><font style="vertical-align: inherit;">Um die zurückgegebenen Typen zu überprüfen, wird eine spezielle Syntax verwendet: Das Objekt wird in geschweiften Klammern gesetzt, ein Pfeil wird platziert und danach wird ein Konzept geschrieben, das der Typ erfüllen muss. </font><font style="vertical-align: inherit;">Darüber hinaus ist die Verwendung von direkten Typen nicht zulässig. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überprüfen Sie, ob die Rückgabe der Funktion in int konvertiert werden kann:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">int</span>&gt;;<font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überprüfen Sie, ob die Rückgabefunktion genau int ist:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::same_as&lt;<span class="hljs-keyword">int</span>&gt;; <font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(std :: same_as und std :: convertible_to sind Konzepte aus der Standardbibliothek). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie keinen Ausdruck einschließen, dessen Typ in geschweiften Klammern markiert ist, versteht der Compiler nicht, was er von ihm will, und interpretiert die gesamte Zeichenfolge als einen einzelnen Ausdruck, der für die Kompilierung überprüft werden muss.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfordert innen erfordert</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Schlüsselwort require hat eine besondere Bedeutung. </font><font style="vertical-align: inherit;">Verschachtelte Anforderungsausdrücke (bereits ohne geschweifte Klammern) werden nicht zur Kompilierung, sondern auf Gleichheit wahr oder falsch geprüft. </font><font style="vertical-align: inherit;">Wenn sich ein solcher Ausdruck als falsch herausstellt, stellt sich der einschließende Ausdruck sofort als falsch heraus (und die weitere Kompilierungsanalyse wird unterbrochen). </font><font style="vertical-align: inherit;">Generelle Form:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> { <font></font>
  expression;         <span class="hljs-comment">// expression is valid</span>
  <span class="hljs-keyword">requires</span> predicate; <span class="hljs-comment">// predicate is true</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Prädikat können beispielsweise zuvor definierte Konzepte oder Typmerkmale verwendet werden. </font><font style="vertical-align: inherit;">Beispiel:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(Iter it) {
  <span class="hljs-comment">//     (   Iter   *  ++)</span><font></font>
  *it++;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_convertible_v&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gleichzeitig sind verschachtelte Anforderungsausdrücke mit Code in geschweiften Klammern zulässig, der auf Gültigkeit überprüft wird. </font><font style="vertical-align: inherit;">Wenn Sie jedoch einfach einen erforderlichen Ausdruck in einen anderen schreiben, wird der verschachtelte Ausdruck (alles als Ganzes, einschließlich des verschachtelten Schlüsselworts require) einfach auf Gültigkeit überprüft:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">typename</span> T::value_type x) { ++x; }; <span class="hljs-comment">//     , </span>
												<span class="hljs-comment">//     !</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher entstand eine seltsame Form mit Doppelanforderungen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span> <span class="hljs-params">(<span class="hljs-keyword">typename</span> T::value_type x)</span> </span>{ ++x; }; <span class="hljs-comment">//       "++x"</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist so eine lustige Fluchtsequenz von "erfordert". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine andere Kombination von zwei erfordert übrigens diese Zeitklausel (siehe unten) und den Ausdruck:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span><span class="hljs-params">(T x, T y)</span> </span>{ <span class="hljs-keyword">bool</span>(x &lt; y); }
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">equivalent</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; x, T <span class="hljs-keyword">const</span>&amp; y)</span>
</span>{
  <span class="hljs-keyword">return</span> !(x &lt; y) &amp;&amp; !(y &lt; x);<font></font>
};</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfordert Klausel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kommen wir nun zu einer anderen Verwendung des Wortes, die erforderlich ist - um Einschränkungen eines Vorlagentyps zu deklarieren. </font><font style="vertical-align: inherit;">Dies ist eine Alternative zur Verwendung von Konzeptnamen anstelle von Typnamen. </font><font style="vertical-align: inherit;">Im folgenden Beispiel sind alle drei Methoden gleichwertig:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  require</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
	<span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span></span>;<font></font>
<font></font>
<span class="hljs-comment">//   require (  )</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span> <span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;</span>;<font></font>
<font></font>
<span class="hljs-comment">//    typename</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;Sortable Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span>  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erfordernde Deklaration kann mehrere Prädikate verwenden, die von logischen Operatoren kombiniert werden.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s;<font></font>
 <font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// ok</span>
  fun(s);  <span class="hljs-comment">// compiler error</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Invertieren Sie jedoch einfach eine der Bedingungen, da ein Kompilierungsfehler auftritt:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; !is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Beispiel, das auch nicht kompiliert wird</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> !<span class="hljs-function">is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;	</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Grund dafür sind die Mehrdeutigkeiten, die beim Parsen einiger Ausdrücke auftreten. </font><font style="vertical-align: inherit;">Zum Beispiel in einer solchen Vorlage:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">bool</span>)&amp;<span class="hljs-function">T::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist unklar, wem wir den Operator oder den Prototyp der Funktion foo () ohne Vorzeichen zuordnen sollen. </font><font style="vertical-align: inherit;">Daher entschieden die Entwickler, dass ohne Klammern, da Argumente eine Klausel erfordern, nur eine sehr begrenzte Menge von Entitäten verwendet werden kann - wahre oder falsche Literale, Feldnamen vom Typ bool des Formularwerts, Wert, T :: Wert, ns :: Trait :: Wert, Konzeptnamen vom Typ Concept und erfordern Ausdrücke. </font><font style="vertical-align: inherit;">Alles andere sollte in Klammern stehen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!is_trivial_v&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun zu Prädikat-Features in der require-Klausel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie ein anderes Beispiel.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel erfordert require ein Merkmal, das vom Typ des verschachtelten value_type abhängt. </font><font style="vertical-align: inherit;">Es ist nicht im Voraus bekannt, ob ein beliebiger Typ einen solchen verschachtelten Typ hat, der an die Vorlage übergeben werden kann. </font><font style="vertical-align: inherit;">Wenn Sie beispielsweise einen einfachen int-Typ an eine solche Vorlage übergeben, tritt ein Kompilierungsfehler auf. Wenn wir jedoch zwei Spezialisierungen der Vorlage haben, tritt kein Fehler auf. </font><font style="vertical-align: inherit;">Es wird nur eine weitere Spezialisierung ausgewählt.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"1"</span>; } <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"2"</span>; } <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// displays: "2"</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher wird die Spezialisierung nicht nur verworfen, wenn das Prädikat der require-Klausel false zurückgibt, sondern auch, wenn es sich als falsch herausstellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Klammern um das Prädikat sind eine wichtige Erinnerung daran, dass in der require-Klausel die Umkehrung des Prädikats nicht das Gegenteil des Prädikats selbst ist. </font><font style="vertical-align: inherit;">Damit,</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bedeutet, dass das Merkmal korrekt ist und true zurückgibt. </font><font style="vertical-align: inherit;">Dabei</font></font><br>
<br>
<pre><code class="cpp hljs">!is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
würde bedeuten "das Merkmal ist korrekt und gibt falsch zurück" Die </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
wahre logische Umkehrung des ersten Prädikats ist NICHT ("das Merkmal ist korrekt und gibt wahr zurück") == "das Merkmal ist falsch oder gibt falsch zurück" - dies wird auf etwas komplexere Weise erreicht - durch eine explizite Definition des Konzepts:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> value_type_valid_and_trivial <font></font>
  = is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;; <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!value_type_valid_and_trivial&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konjunktion und Disjunktion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die logischen Konjunktions- und Disjunktionsoperatoren sehen wie gewohnt aus, funktionieren jedoch tatsächlich etwas anders als in normalem C ++. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie zwei sehr ähnliche Codefragmente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste ist ein Prädikat ohne Klammern:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		|| <span class="hljs-function"><span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite ist mit Klammern:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> (<span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		 || <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Unterschied besteht nur in Klammern. </font><font style="vertical-align: inherit;">Aus diesem Grund gibt es in der zweiten Vorlage nicht zwei Einschränkungen, die durch eine „Anforderungsklausel“ verbunden sind, sondern eine, die durch ein übliches logisches ODER verbunden ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Unterschied ist wie folgt. </font><font style="vertical-align: inherit;">Betrachten Sie den Code</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::optional&lt;<span class="hljs-keyword">int</span>&gt; oi {};
<span class="hljs-keyword">int</span> i {};<font></font>
fun(i, oi);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier wird die Vorlage durch die Typen int und std :: optional instanziiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im ersten Fall ist der Typ int :: value_type ungültig und die erste Einschränkung ist damit nicht erfüllt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Typ optional :: value_type ist jedoch gültig, das zweite Merkmal gibt true zurück, und da sich zwischen den Einschränkungen ein ODER-Operator befindet, ist das gesamte Prädikat insgesamt erfüllt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im zweiten Fall ist dies ein einzelner Ausdruck, der einen ungültigen Typ enthält, weshalb er im Allgemeinen ungültig ist und das Prädikat nicht erfüllt ist. </font><font style="vertical-align: inherit;">Einfache Klammern ändern also unmerklich die Bedeutung des Geschehens.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abschließend</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich werden hier nicht alle Merkmale der Konzepte gezeigt. Ich bin einfach nicht weiter gegangen. Aber als erster Eindruck - eine sehr interessante Idee und eine etwas seltsame verwirrte Umsetzung. Und eine lustige Syntax mit Wiederholung erfordert, was wirklich verwirrt. Gibt es wirklich so wenige englische Wörter, dass Sie ein Wort für ganz andere Zwecke verwenden mussten? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee mit kompiliertem Code ist definitiv gut. Es ist sogar etwas ähnlich wie "Quasi-Quoting" in Syntaxmakros. Aber hat es sich gelohnt, die spezielle Syntax für die Überprüfung von Rückgabetypen zu verwechseln? IMHO, dafür wäre es einfach notwendig, ein separates Schlüsselwort zu erstellen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das implizite Mischen der Begriffe "wahr / falsch" und "kompiliert / kompiliert nicht" in einem Haufen, und infolgedessen sind auch Witze mit Klammern falsch. </font><font style="vertical-align: inherit;">Dies sind unterschiedliche Konzepte, und sie müssen streng in unterschiedlichen Kontexten existieren (obwohl ich verstehe, woher sie stammen - aus der SFINAE-Regel, in der nicht kompilierter Code die Spezialisierung nur stillschweigend von der Betrachtung ausschloss). </font><font style="vertical-align: inherit;">Aber wenn das Ziel der Konzepte darin besteht, den Code so explizit wie möglich zu gestalten, hat es sich gelohnt, all diese impliziten Dinge in neue Funktionen zu ziehen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel wurde hauptsächlich auf der Grundlage von </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/01/29/requires-expression </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/03/26/requires-clause</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
(es gibt viel mehr Beispiele und interessante Funktionen) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mit meinen Ergänzungen von geschrieben In anderen Quellen können </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
alle Beispiele überprüft werden</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wandbox.org</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de495380/index.html">Große ägyptische Firewall</a></li>
<li><a href="../de495384/index.html">Meine Praktikumserfahrung bei Microsoft Redmond und ein Angebot bekommen</a></li>
<li><a href="../de495388/index.html">1970er Fernsehsendung, die ein Vorfahr des eSports wurde</a></li>
<li><a href="../de495390/index.html">STM32CubeMonitor ist einen Versuch wert</a></li>
<li><a href="../de495392/index.html">So suchen Sie im Frontend nach Fehlern: 4 Hauptphasen</a></li>
<li><a href="../de495398/index.html">Ro.Ri.Re</a></li>
<li><a href="../de495400/index.html">Arbeiten Sie mit der SD-Karte über die SPI-Schnittstelle. VHDL-Implementierung</a></li>
<li><a href="../de495402/index.html">Letztes Jahr haben wir endlich ein Schwarzes Loch fotografiert. Was jetzt?</a></li>
<li><a href="../de495404/index.html">Sind sinkende Aktien vielversprechend? Lassen Sie uns mit Python analysieren</a></li>
<li><a href="../de495408/index.html"># 02 - Und ein ganzes Byte reicht nicht ... | Das Kreuz der Veränderungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>