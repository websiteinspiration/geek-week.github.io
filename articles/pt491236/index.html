<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úäüèΩ üéµ üôåüèæ Programa√ß√£o ass√≠ncrona no .NET: pr√°ticas recomendadas üßíüèª üï¥üèª üõ´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O advento de async / waitit em C # levou a uma redefini√ß√£o de como escrever c√≥digo paralelo simples e correto. Freq√ºentemente, usando programa√ß√£o ass√≠...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programa√ß√£o ass√≠ncrona no .NET: pr√°ticas recomendadas</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/491236/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O advento de async / waitit em C # levou a uma redefini√ß√£o de como escrever c√≥digo paralelo simples e correto. Freq√ºentemente, usando programa√ß√£o ass√≠ncrona, os programadores n√£o apenas resolvem os problemas que estavam com os encadeamentos, mas tamb√©m introduzem novos. Os impasses e os voos n√£o v√£o a lugar algum - eles apenas se tornam mais dif√≠ceis de diagnosticar. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/uz/8g/buuz8gok2hqubwnj1773hwimncq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dmitry Ivanov - Equipe de An√°lise de SoftwareLead na Huawei, um ex-desenvolvedor de tecnologia JetBrains Rider e desenvolvedor do n√∫cleo ReSharper: estruturas de dados, caches, multithreading e palestrante regular na confer√™ncia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sob a cena - grava√ß√£o de v√≠deo e transcri√ß√£o de texto do relat√≥rio de Dmitry da confer√™ncia DotNext 2019 Piter.</font></font><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/wM-h6P1BJRk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Narra√ß√£o adicional em nome do orador.</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
No c√≥digo multithread ou ass√≠ncrono, algo geralmente quebra. O motivo pode ser tanto impasse quanto corrida. Como regra, uma corrida falha uma vez em cada mil, geralmente n√£o localmente, mas apenas em um servidor de compila√ß√£o, e leva v√°rios dias para ser detectada. Tenho certeza de que, para muitos, √© uma situa√ß√£o familiar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, olhando para o c√≥digo ass√≠ncrono, mesmo por desenvolvedores experientes, me pego pensando que algumas coisas podem ser escritas tr√™s vezes mais curtas e mais corretamente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso sugere que o problema n√£o est√° nas pessoas, mas no instrumento. </font><font style="vertical-align: inherit;">As pessoas simplesmente usam a ferramenta e querem que ela resolva seu problema. </font><font style="vertical-align: inherit;">A ferramenta em si possui um n√∫mero muito grande de recursos (√†s vezes at√© sup√©rfluos), configura√ß√µes, um contexto impl√≠cito, o que leva ao fato de que √© muito f√°cil de usar incorretamente. </font><font style="vertical-align: inherit;">Vamos tentar descobrir como usar async / waitit e trabalhar com uma classe </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no .NET.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plano</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problemas com abordagens que s√£o resolvidas com async / wait.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplos de design controverso.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma tarefa da vida real que resolveremos de forma ass√≠ncrona.</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ass√≠ncrono / espera e problemas a serem resolvidos</font></font></h2><br>
<img src="https://habrastorage.org/webt/v1/ym/30/v1ym304jgxmwh_4kymlyqr4wddi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que precisamos de async / wait? Digamos que temos um c√≥digo que funciona com mem√≥ria compartilhada compartilhada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No in√≠cio do trabalho, lemos a solicita√ß√£o, neste caso, o arquivo da fila de bloqueio (por exemplo, da Internet ou do disco), usando a solicita√ß√£o de bloqueio de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remo√ß√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> da </font><i><font style="vertical-align: inherit;">fila</font></i><font style="vertical-align: inherit;"> (as solicita√ß√µes de bloqueio ser√£o marcadas em vermelho nas figuras com exemplos). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa abordagem requer muitos encadeamentos, e cada encadeamento requer recursos, cria uma carga no </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agendador</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mas este n√£o √© o principal problema. Suponha que as pessoas possam reescrever sistemas operacionais para que esses sistemas suportem tanto cem mil como um milh√£o de threads. Mas o principal problema √© que alguns threads simplesmente n√£o podem ser utilizados. Por exemplo, voc√™ tem um encadeamento da interface do usu√°rio. N√£o h√° estruturas de interface do usu√°rio adequadas normais em que o acesso aos dados n√£o seria apenas de um encadeamento. O thread da interface do usu√°rio n√£o pode ser bloqueado. E para n√£o bloque√°-lo, precisamos de c√≥digo ass√≠ncrono. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos falar sobre a segunda tarefa. Depois de lermos o arquivo, ele precisa ser processado de alguma forma. Vamos fazer isso em paralelo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muitos de voc√™s j√° ouviram dizer que paralelismo n√£o √© o mesmo que assincronia. Nesse caso, surge a pergunta: a assincronia pode ajudar a escrever c√≥digo paralelo mais compacto, bonito e mais r√°pido?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A √∫ltima tarefa √© trabalhar com mem√≥ria compartilhada. </font><font style="vertical-align: inherit;">Precisamos arrastar esse mecanismo com bloqueios, sincroniza√ß√£o com c√≥digo ass√≠ncrono ou isso pode ser evitado de alguma forma? </font><font style="vertical-align: inherit;">O </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ass√≠ncrono / aguarda</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ajuda com isso?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caminho para ass√≠ncrono / aguardar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejamos a evolu√ß√£o da programa√ß√£o ass√≠ncrona em geral no mundo e no .NET.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ligue de volta</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Void <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {‚Ä¶}<font></font>
 <font></font>
<font></font>
<span class="hljs-function">Void <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ‚Ä¶<span class="hljs-comment">//synchronous code</span><font></font>
 <font></font>
    Foo(<span class="hljs-keyword">params</span>,() =&gt;{<font></font>
       ‚Ä¶<span class="hljs-comment">//asynchronous code;continuation</span><font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A programa√ß√£o ass√≠ncrona come√ßou com retornos de chamada. </font><font style="vertical-align: inherit;">Ou seja, primeiro voc√™ precisa chamar parte do c√≥digo de forma s√≠ncrona e a segunda parte - de forma ass√≠ncrona. </font><font style="vertical-align: inherit;">Por exemplo, voc√™ l√™ um arquivo e, quando os dados estiverem prontos, eles ser√£o entregues a voc√™ de alguma forma. </font><font style="vertical-align: inherit;">Esta parte ass√≠ncrona √© passada como um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retorno de chamada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais retornos de chamada</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {...} 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">Action callback</span>)</span> {...}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Baz</span>(<span class="hljs-params">Action callback</span>)</span> {...}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
    <font></font>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; { <font></font>
      ... <span class="hljs-comment">//continuation 1 </span><font></font>
      Bar(() =&gt; {<font></font>
        <span class="hljs-comment">//continuation 2</span><font></font>
        Baz(() =&gt; {<font></font>
          <span class="hljs-comment">//continuation 3</span><font></font>
        }); <font></font>
      });<font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, a partir de um retorno de chamada, voc√™ pode registrar outro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retorno de chamada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , do qual √© poss√≠vel registrar um terceiro retorno de chamada e, no final, tudo se transforma em um </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inferno de retorno de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chamada </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/vq/8g/bfvq8gknishmtrdwaiixz6mzuvs.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retorno de chamada: exce√ß√µes</font></font></h3><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action onSuccess, Action onFailure</span>)</span> {...}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code </span>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; {<font></font>
      ... <span class="hljs-comment">//asynchronous code on success </span><font></font>
    },<font></font>
    () =&gt; {<font></font>
        ... <span class="hljs-comment">//asynchronous code on failure</span><font></font>
    }); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como trabalhar com exce√ß√µes? Por exemplo, o ReSharper, ao responder separadamente √†s exce√ß√µes e √† boa execu√ß√£o, n√£o demonstra as partes mais bonitas do c√≥digo - h√° retornos de chamada separados para uma situa√ß√£o excepcional e para uma continua√ß√£o bem-sucedida. O resultado √© um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inferno de retorno de chamada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas n√£o linear, mas semelhante a uma √°rvore, o que pode ser completamente confuso. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/hs/y3/lghsy31j9pke1do-8rpmcyuovfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No .NET, a primeira abordagem de retorno de chamada √© chamada de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modelo de programa√ß√£o ass√≠ncrona</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (APM). O m√©todo ser√° chamado </font></font><code>AsyncCallback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que √© essencialmente o mesmo que </font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas a abordagem possui alguns recursos. Antes de tudo, os m√©todos devem come√ßar com a palavra "Begin" (a leitura de um arquivo √© BeginRead), que retorna alguns </font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ele mesmo</font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Este √© um manipulador que sabe que a opera√ß√£o foi conclu√≠da e que possui um mecanismo </font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Voc√™ </font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode esperar, aguardando a conclus√£o da opera√ß√£o de forma ass√≠ncrona. Por outro lado, voc√™ pode chamar </font></font><code>EndOperation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, isto √©, criar </font></font><code>EndRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e travar de forma s√≠ncrona (que √© muito semelhante a uma propriedade </font></font><code>Task.Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa abordagem tem v√°rios problemas. Em primeiro lugar, n√£o nos protege do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inferno de retorno</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><i><font style="vertical-align: inherit;">chamada</font></i><font style="vertical-align: inherit;"> . Em segundo lugar, ainda n√£o est√° claro o que fazer com exce√ß√µes. Em terceiro lugar, n√£o est√° claro em qual thread esse retorno de chamada ser√° chamado - n√£o temos controle sobre a chamada. Quarto, surge a pergunta: como combinar trechos de c√≥digo com retornos de chamada? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mr/5z/xr/mr5zxr01ztmadod_fuetd3loqew.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O segundo modelo √© chamado </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padr√£o Ass√≠ncrono Baseado em Evento</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Essa √© uma abordagem de retorno de chamada reativa. A id√©ia do m√©todo √© que passemos para o m√©todo </font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algum objeto que tenha o evento Conclu√≠do e nos inscrevamos nesse evento. Como voc√™ notou, </font></font><code>BeginOperationName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muda para </font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pode ocorrer confus√£o quando voc√™ entra na classe Socket, onde dois padr√µes s√£o misturados: </font></font><code>ConnectAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>BeginConnect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por favor, note que voc√™ deve ligar para cancelar </font></font><code>OperationNameAsyncCancel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Como no .NET isso n√£o √© encontrado em nenhum outro lugar, geralmente todos enviam </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellationToken s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Portanto, se voc√™ encontrar acidentalmente um m√©todo na biblioteca que termina com </font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, precisar√° entender que ele n√£o necessariamente retorna </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas pode retornar uma constru√ß√£o semelhante. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/w4/4u/6sw44uh3ljw5kwdkowtxylfz5xc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere um modelo conhecido em Java como</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Futuros</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , em JavaScript, como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promessas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e em .NET, como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padr√µes Ass√≠ncronos de Tarefas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , em outras palavras, ‚Äútarefas‚Äù. Este m√©todo pressup√µe que voc√™ tenha algum objeto de c√°lculo e pode ver o status desse objeto (em execu√ß√£o ou conclu√≠do). No .NET, existe uma </font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separa√ß√£o conveniente </font><font style="vertical-align: inherit;">chamada </font><font style="vertical-align: inherit;">de dois status: o in√≠cio da tarefa e a conclus√£o da tarefa. Um erro comum ocorre quando um m√©todo √© chamado em uma tarefa </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que retorna uma continua√ß√£o sem √™xito, mas </font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Faulted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Portanto, o resultado de clicar em "Cancelar" no aplicativo de interface do usu√°rio deve diferir do retorno de exce√ß√µes (execu√ß√µes). No .NET, foi feita uma distin√ß√£o: se a execu√ß√£o √© seu erro que voc√™ deseja proteger, ent√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancelar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- opera√ß√£o for√ßada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No .NET, tamb√©m foi introduzido um conceito </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- √© um tipo de abstra√ß√£o em cima de threads que informa onde executar a tarefa. Nesse caso, o suporte de cancelamento foi projetado no n√≠vel do design. Quase todas as opera√ß√µes na biblioteca do .NET t√™m </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isso que podem ser passadas. Isso n√£o funciona para todos os idiomas: por exemplo, no Kotlin, voc√™ pode desfazer a tarefa, mas no .NET, n√£o. A solu√ß√£o pode ser a divis√£o de responsabilidade entre aqueles que cancelam a tarefa e a pr√≥pria tarefa. Quando voc√™ recebe uma tarefa, n√£o pode cancel√°-la, a n√£o ser explicitamente - voc√™ deve transmiti-la </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um objeto especial </font></font><code>TaskCompletionSoure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permite adaptar facilmente as APIs antigas associadas ao </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padr√£o Ass√≠ncrono Baseado em Evento</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou ao </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modelo de Programa√ß√£o Ass√≠ncrona</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">H√° um documento que voc√™ deve ler se programar em tarefas. </font><font style="vertical-align: inherit;">Ele descreve todos os acordos sobre tasas. </font><font style="vertical-align: inherit;">Por exemplo, qualquer m√©todo, retornando a tarefa, deve retorn√°-lo em um estado de execu√ß√£o, o que significa que n√£o pode ser </font></font><code>Created</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, enquanto todas essas opera√ß√µes devem terminar </font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combinando continua√ß√µes</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Task <span class="hljs-title">ourMethod</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">return</span> Task.RunSynchronously(() =&gt;{<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Foo(); <span class="hljs-comment">//continuation 1</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Bar(); <span class="hljs-comment">//continuation 2</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Baz(); <span class="hljs-comment">//continuation 3</span><font></font>
  })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quanto √† combina√ß√£o, levando em considera√ß√£o o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inferno de retorno de chamada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ela pode aparecer de uma forma mais linear, apesar da presen√ßa de partes do c√≥digo repetido com altera√ß√µes m√≠nimas. </font><font style="vertical-align: inherit;">Parece que o c√≥digo est√° melhorando dessa maneira, mas tamb√©m existem armadilhas.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iniciar e continuar tarefas</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
  TaskCreationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)<font></font>
Task.ContinueWith(Action&lt;Task&gt;, <font></font>
  TaskContinuationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos passar para tr√™s par√¢metros durante o in√≠cio da tarefa padr√£o: o primeiro s√£o as op√ß√µes para iniciar a tarefa, o segundo √© </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquele no qual a tarefa √© iniciada e o terceiro - </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/w_/a4/fw/w_a4fwuiwflisfw-ifxqwtgnpxu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TaskScheduler informa onde a tarefa √© iniciada e √© um objeto que voc√™ pode substituir independentemente. Por exemplo, voc√™ pode substituir um m√©todo </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se voc√™ faz </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o m√©todo </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leva um fio de </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e envia sua tarefa l√°. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ assumir </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o encadeamento principal, ele colocar√° tudo em uma fila e as tarefas ser√£o executadas sequencialmente no encadeamento principal. No entanto, o problema √© que, no .NET, voc√™ pode executar tarefas sem passar </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Surge a pergunta: como ent√£o o .NET calcula qual tarefa foi passada para ela? Quando a tarefa come√ßa por </font></font><code>StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro</font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exibido no </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que n√≥s demos a ela. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse design parece bastante controverso devido ao contexto impl√≠cito. Houve casos em que ele </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continha c√≥digo ass√≠ncrono que herdou muito profundamente em algum lugar </font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e se sobrep√¥s a outro agendador, o que levou a conflitos. Neste caso, voc√™ pode usar a op√ß√£o </font></font><code>TaskCreationOption.HideScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esta √© uma campainha de alarme que diz que temos alguma op√ß√£o que substitui a </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">configura√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo √© o mesmo com continua√ß√µes. Surge a pergunta: de onde ela vem </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para continua√ß√µes? Primeiro de tudo, √© utilizado no m√©todo em que voc√™ iniciou </font></font><code>Continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tamb√©m √© </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retirado do ThreadStatic. √â importante que, para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ass√≠ncrono / espera,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> continua√ß√µes funcionem de maneira muito diferente.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bt/-f/ne/bt-fnekfbdnfmn4n-u3zrvp7bdc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos voltamos para os par√¢metros </font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>TaskContinuationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O principal problema deles √© que existem muitos deles. Alguns desses par√¢metros se cancelam, outros s√£o mutuamente exclusivos. Todos esses par√¢metros podem ser usados ‚Äã‚Äãem todas as combina√ß√µes poss√≠veis, por isso √© dif√≠cil ter em mente tudo o que pode acontecer com o desejo. Algumas dessas op√ß√µes funcionam de maneira completamente incompreens√≠vel. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/us/wh/aguswhpfaos0qjqvfopo_rr8aeo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, os par√¢metros </font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">representam duas op√ß√µes poss√≠veis de aplicativos, mas se a continua√ß√£o ser√° iniciada de forma s√≠ncrona ou ass√≠ncrona depende de tantas coisas que voc√™ n√£o saber√°. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jm/-c/zv/jm-czv9x4lhhmibfgxqxwjcvxqe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro exemplo: lan√ßamos tarefa, lan√ßamos continua√ß√£o e, simultaneamente, fornecemos dois par√¢metros</font></font><code>TaskContinuations.ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ap√≥s o qual eles iniciaram a continua√ß√£o de forma ass√≠ncrona. </font><font style="vertical-align: inherit;">Ser√° executado na mesma pilha em que a tarefa anterior termina ou ser√° transferido para </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Nesse caso, haver√° uma terceira op√ß√£o: depende.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/j6/8z/vvj68zu1keb_n50viyk4iqbydae.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCompletionSource</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ao criar uma tarefa, voc√™ define seu resultado </font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para adaptar os padr√µes ass√≠ncronos anteriores ao mundo da tarefa. Voc√™ </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode solicitar </font></font><code>tcs.Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e esta tarefa entrar√° em um estado </font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando voc√™ ligar </font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. No entanto, se voc√™ executar isso no </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conjunto de encadeamentos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , obter√° um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impasse</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . A quest√£o √©: por que se n√£o escrevemos nada, mesmo que de forma s√≠ncrona? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v5/g1/2b/v5g12bn0tycbshdrascqvi-hkug.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Criamos </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, iniciamos uma nova tarefa e temos um segundo thread que inicia algo nessa tarefa. Ele repassa e cai na expectativa de cem milissegundos. Ent√£o nossa linha principal - verde - vai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aguardar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e √© isso. Ele libera a pilha, a pilha trava, esperando para ser chamada em uma continua√ß√£o em</font></font><code>task.Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exposto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na linha azul chegamos a </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e depois o mais interessante. </font><font style="vertical-align: inherit;">Com base em considera√ß√µes internas do .NET, ele </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acredita que a continua√ß√£o disso </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode ser executada de forma s√≠ncrona, ou seja, diretamente na mesma pilha, e ent√£o </font></font><code>task.Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realizada de forma s√≠ncrona na mesma pilha. </font><font style="vertical-align: inherit;">Isso √© muito estranho, apesar de nem sequer escrevermos em lugar algum </font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este √© provavelmente o problema com a mistura de c√≥digo s√≠ncrono e ass√≠ncrono. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uv/7z/go/uv7zgosoif24okbeyq7fffwdz8o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro problema </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© que, quando chamamos </font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sob o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloqueio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , voc√™ n√£o pode chamar c√≥digo arbitr√°rio, pois, sob o bloqueio, voc√™ pode executar apenas algumas pequenas atividades granulares. </font><font style="vertical-align: inherit;">Corra sob algumas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a√ß√µes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, √© imposs√≠vel vir de onde eles vieram. </font><font style="vertical-align: inherit;">Como resolver este problema?</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span>  tcs  =  <span class="hljs-keyword">new</span>   TaskCompletionSource&lt;<span class="hljs-keyword">int</span>&gt;(<font></font>
       TaskContinuationsOptions.RunContinuationsAsynchronously  <font></font>
) ;<font></font>
<span class="hljs-keyword">lock</span>(mylock)<font></font>
{  <font></font>
    tcs.SetResult(O); <font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vale a </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pena </font><font style="vertical-align: inherit;">usar </font><font style="vertical-align: inherit;">apenas para adapta√ß√£o do </font><font style="vertical-align: inherit;">c√≥digo </font><font style="vertical-align: inherit;">n√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nas bibliotecas. </font><font style="vertical-align: inherit;">Quase tudo o mais pode ser resolvido atrav√©s do aguardar. </font><font style="vertical-align: inherit;">Nesse caso, √© sempre altamente recomend√°vel prescrever o par√¢metro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"TaskCompletionSource.RunContinuationsAsynchronously"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Voc√™ quase sempre precisa executar uma continua√ß√£o de forma ass√≠ncrona. </font><font style="vertical-align: inherit;">Nesse caso, voc√™ </font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tem algo sob o qual nada ser√° lan√ßado. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ap/_-/ab/ap_-abu8wjhwxr0edsvayrcc-6w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que a continua√ß√£o deve ser realizada de forma s√≠ncrona? </font><font style="vertical-align: inherit;">Porque se </font></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">refere ao seguinte </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e n√£o ao nosso. </font><font style="vertical-align: inherit;">Para que ele se relacione com o nosso, voc√™ precisa escrever o seguinte: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/zj/6q/qbzj6q1fjhhqozii8yec5ok3pcy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este exemplo mostra como os par√¢metros n√£o s√£o intuitivos, como eles se cruzam, como eles introduzem a complexidade cognitiva - √© t√£o dif√≠cil escrever.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hierarquia pai-filho</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   })<font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// don‚Äôt wait for child</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem outras op√ß√µes para o uso de par√¢metros. Por exemplo, uma </font><font style="vertical-align: inherit;">hierarquia </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pai-filho</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> surge </font><font style="vertical-align: inherit;">quando voc√™ inicia uma tarefa e executa outra sob ela. Nesse caso, se voc√™ escrever </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o esperar√° a tarefa iniciada dentro. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gw/se/28/gwse28nxykd4vfwt_chfw0qjt_w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ escrever </font></font><code>TaskCreationOptions.AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, isso </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ir√° esperar. Voc√™ pode usar essa propriedade em seus produtos. Eu acho que todos podem criar um exemplo no qual existe uma hierarquia de tarefas, com a tarefa aguardando a subtarefa e a subtarefa por suas subtarefas. N√£o h√° necessidade de escrever em qualquer lugar </font></font><code>WaitForChildren</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, essa espera acontece de forma ass√≠ncrona. Ou seja, o corpo da tarefa pai termina e, depois disso, a tarefa pai n√£o √© considerada conclu√≠da, n√£o inicia suas continua√ß√µes at√© que as tarefas filho funcionem.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// still wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... parent task to attach is in ThreadStatic</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pode haver um problema no qual a tarefa √© transferida para algum lugar </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e tudo o que voc√™ iniciou </font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ser√° adicionado a essa tarefa pai, que √© uma campainha de alarme.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo();<font></font>
}, TaskCreationOptions.DenyChildAttach)<font></font>
.ContinueWith(...) <span class="hljs-comment">// don‚Äôt wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por outro lado, h√° uma op√ß√£o que cancela a op√ß√£o anterior </font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esse aplicativo ocorre com bastante frequ√™ncia.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Run(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">//don‚Äôt wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
    }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vale lembrar que </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta √© a maneira padr√£o de come√ßar, o que, por padr√£o, implica </font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O contexto impl√≠cito que voc√™ coloca </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adiciona complexidade a voc√™. Voc√™ n√£o entende como a tarefa funciona, porque precisa conhecer o contexto. Outro problema que pode surgir est√° relacionado ao estado ocioso de ass√≠ncrono / espera. Isso porque em </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / waitit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> voc√™ n√£o tem tarefas, mas a√ß√µes. A continua√ß√£o n√£o √© tarefa honesta, mas a√ß√£o. Ao escrever c√≥digo ass√≠ncrono / aguardar, voc√™ n√£o precisa us√°-lo </font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque vincula explicitamente as tarefas a aguardar pela espera, e essa √© a abordagem correta. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/k7/q5/vg/k7q5vgi8h9qwvvo3akgzow8vu_q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ tem seis op√ß√µes sobre como iniciar uma continua√ß√£o. Voc√™ lan√ßou a tarefa, lan√ßou</font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pergunta: Qual status essa continua√ß√£o ter√°? </font><font style="vertical-align: inherit;">Existem cinco respostas poss√≠veis:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a continua√ß√£o geral ser√° conclu√≠da com √™xito; RunToCompletion ocorrer√°;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a tarefa estar√° errada;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cancelamento ocorrer√°;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a tarefa n√£o chegar√° √† conclus√£o, ser√° em algum tipo de limbo;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">op√ß√£o - "depende".</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/5u/x5/1k/5ux51kwpr4aixg_2io3xroerxam.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, a tarefa estar√° no estado cancelado, embora em nenhum lugar a palavra "cancelado" em qualquer lugar. </font><font style="vertical-align: inherit;">Aqui jogamos a recep√ß√£o e n√£o fazemos nada. </font><font style="vertical-align: inherit;">O problema √© que, quando voc√™ l√™ o c√≥digo de outra pessoa com muitas op√ß√µes - mesmo se voc√™ soubesse dessas op√ß√µes h√° 10 minutos - ainda esquece o que acontece aqui. </font><font style="vertical-align: inherit;">Ent√£o n√£o escreva.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancelamento</font></font></h3><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(); <font></font>
});<font></font>
<font></font>
                                                      Failed</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O terceiro par√¢metro no in√≠cio da tarefa √© kancellation. </font><font style="vertical-align: inherit;">Voc√™ escreve </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ou seja, uma a√ß√£o especial que coloca a tarefa no estado "Cancelado". </font><font style="vertical-align: inherit;">Nesse caso, a tarefa estar√° no estado "Falha", porque nem todos </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√£o iguais.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(cancellationToken); <font></font>
}, cancellationToken);<font></font>
<font></font>
                                                      Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que a tarefa seja capaz </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, √© necess√°rio jog√°-la </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">junto com seu CancellationToken. </font><font style="vertical-align: inherit;">Na realidade, voc√™ nunca faz isso explicitamente, mas faz o seguinte:</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    cancellationToken.ThrowIfCancellationRequested(); <font></font>
}, cancellationToken);<font></font>
                                                       Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â necess√°rio distinguir cancellationToken? </font><font style="vertical-align: inherit;">Em algum lugar da tarefa, voc√™ verifica se algu√©m o excluiu: lance o cancelamento e a tarefa entra em estado </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ou algu√©m clicou em "Cancelar" no tempo de execu√ß√£o e cancelou a tarefa. </font><font style="vertical-align: inherit;">Nossa pr√°tica no JetBrains sugere que voc√™ n√£o precisa distinguir entre esses tokens. </font><font style="vertical-align: inherit;">Se voc√™ receber uma </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OperationCanceledException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - um tipo especial que ocorre quando ocorre algum cancelamento, voc√™ pode distingui-lo. </font><font style="vertical-align: inherit;">Nesse caso, voc√™ s√≥ precisa concluir a tarefa normalmente, n√£o fa√ßa o login e, quando receber a execu√ß√£o, fa√ßa o login.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilha profunda</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    Foo();<font></font>
}, cancellationToken);<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
     Bar() {<font></font>
       ...<font></font>
          Baz() {<font></font>
             <span class="hljs-comment">//how to get cancellation token?</span><font></font>
          } <font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos que voc√™ tenha uma pilha profunda. Este </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© o √∫nico par√¢metro expl√≠cito que discutimos. Ele deve ser transmitido para todos os lugares atrav√©s de absolutamente todas as hierarquias. O que devo fazer se, na presen√ßa de uma hierarquia profunda, voc√™ precisar cancelar sua tarefa em algum lugar, no n√≠vel mais baixo, para descartar a recep√ß√£o? Existe um truque t√£o especial que usamos. Ele √© chamado </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">static</span> AsyncLocal&lt;Cancelation&gt; asyncLocalCancellation;<font></font>
<font></font>
Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
     asyncLocalCancellation.Set(cancellationToken) <font></font>
    Foo();<font></font>
}, cancellationToken); <span class="hljs-comment">// use AsyncLocal to put cancellation int</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { 
     <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span> {<font></font>
      ...<font></font>
         Baz() {<font></font>
             asyncLocalCancellation.Value.CheckForInterrupt(); <font></font>
         }<font></font>
   } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â o mesmo que, </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apenas o especial </font></font><code>ThreadLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que sobrevive a viagens ass√≠ncronas / a aguardar c√≥digo. </font><font style="vertical-align: inherit;">Como seu c√≥digo √© ass√≠ncrono e voc√™ tem esse kancellation, voc√™ o coloca </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, </font><font style="vertical-align: inherit;">em </font><font style="vertical-align: inherit;">algum n√≠vel profundo, voc√™ pode dizer " </font></font><code>CheckForInterrupt Throw If Cancellation Requested</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". </font><font style="vertical-align: inherit;">Novamente, este √© o √∫nico par√¢metro </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que precisa manchar completamente o c√≥digo inteiro, mas, na minha opini√£o, para a maioria das tarefas, voc√™ s√≥ precisa saber o que aconteceu </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, a partir disso, tirar uma conclus√£o sobre o estado: Cancelado ou com falha.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complexidade cognitiva</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
    TaskCreationOptions, <font></font>
    TaskScheduler, <font></font>
    CancellationToken<font></font>
)<font></font>
                                                   JetBrains.Lifetimes<font></font>
<font></font>
lifetime.Start(TaskScheduler, Action) <span class="hljs-comment">//puts lifetime in AsyncLocal</span><font></font>
<font></font>
lifetime.StartMainRead(Action) <font></font>
lifetime.StartMainWrite(TaskScheduler, Action) <font></font>
lifetime.StartBackgroundRead(TaskScheduler, Action)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quanto mais dif√≠cil a leitura do c√≥digo ao iniciar a tarefa, maior o risco de erro. Observando o c√≥digo ap√≥s um ano, voc√™ esquecer√° o que faz, porque h√° um grande n√∫mero de par√¢metros. Mas temos a biblioteca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JetBrains.Lifetimes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que oferece vida √∫til moderna, CancellationToken bem otimizado, com o qual o m√©todo Start foi reescrito e o problema de repetir trechos de c√≥digo foi resolvido, como em </font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° um pequeno n√∫mero de agendadores que permitem agendar uma tarefa no encadeamento principal com bloqueio de leitura. Ou seja, o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloqueio de leitura</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o √© algo que voc√™ escolhe explicitamente, √© um agendador especial que agenda seu c√≥digo no segmento principal com </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloqueio de leitura</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bem como o encadeamento principal com bloqueio de grava√ß√£o, encadeamento em segundo plano - e agora os m√©todos se tornam muito simples para iniciar o shuffle. Ao mesmo tempo, o tempo de vida √∫til √© cancelado automaticamente </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, simplificando significativamente o c√≥digo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_h/1n/gu/_h1ngucdl-vvbpyyalkk_gwvapu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver como o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ass√≠ncrono / espera</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resolve esses problemas e quais problemas eles introduzem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste exemplo, parte do c√≥digo √© executada de forma s√≠ncrona e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aguarda um</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> c√≥digo ass√≠ncrono. Em primeiro lugar, √© bom que haja muito menos peda√ßos de c√≥digo repetidos ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">caldeira</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Em segundo lugar, √© bom que o c√≥digo ass√≠ncrono seja muito semelhante ao c√≥digo s√≠ncrono. √â exatamente para isso que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ass√≠ncrono / espera</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Voc√™ pode escrever de forma ass√≠ncrona da mesma maneira que escreveu de forma s√≠ncrona, sem ocupar threads.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que nesse caso o compilador implementar√°? O c√≥digo s√≠ncrono ser√° executado de forma s√≠ncrona, ap√≥s o qual a tarefa </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ser√° </font><font style="vertical-align: inherit;">executada de forma s√≠ncrona </font><font style="vertical-align: inherit;">, de onde vem o objeto GetAwaiter especial. Nesse caso, estamos interessados </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Voc√™ pode escrever seu gar√ßom para absolutamente qualquer objeto. Como resultado, aguardamos a conclus√£o da tarefa </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a executamos de forma s√≠ncrona </font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se a tarefa n√£o for conclu√≠da, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuationCode</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ser√° agendado no planejador de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contexto</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pode ser que, mesmo que voc√™ tenha escrito √† </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espera</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , absolutamente tudo ser√° chamado de forma s√≠ncrona.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
   <span class="hljs-keyword">await</span> InnerAsync();
   <span class="hljs-keyword">await</span> Task.Yield(); <span class="hljs-comment">//guaranteed !IsCompleted </span><font></font>
   continuationCode();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° um truque </font></font><code>Task.Yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- essa √© uma tarefa especial que garante que seu gar√ßom nem sempre retorne para voc√™ </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por conseguinte, </font></font><code>continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o ser√° chamado de forma s√≠ncrona neste local. Para um encadeamento da interface do usu√°rio, isso pode ser importante porque voc√™ n√£o utiliza esse encadeamento por um longo per√≠odo de tempo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jg/jy/7d/jgjy7dh0cnbslfcyk4jpyapc9du.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como escolher um segmento para continua√ß√£o? A filosofia </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ass√≠ncrona / aguardada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© a </font><font style="vertical-align: inherit;">seguinte: voc√™ escreve c√≥digo ass√≠ncrono da mesma forma que s√≠ncrono. Se voc√™ possui um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pool de threads</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">isso </font><font style="vertical-align: inherit;">n√£o </font><font style="vertical-align: inherit;">faz </font><font style="vertical-align: inherit;">diferen√ßa para voc√™ - o continuationCode ser√° executado em outro thread. Independentemente de ter sido </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conclu√≠do quando voc√™ disse </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aguardar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou n√£o, voc√™ precisa de tudo para executar no encadeamento da interface do usu√°rio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O mecanismo da tarefa aguardada √© o seguinte: √© utilizado </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, √© chamado</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a partir dele √© criado </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SynchronizationContext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© uma coisa do m√©todo Post, que √© muito semelhante ao m√©todo </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">De fato </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, anteriormente, ele simplesmente toma </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e atrav√©s do Post executa sua tarefa nele.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
    continuationCode(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existe uma maneira de alterar esse comportamento usando um par√¢metro </font></font><code>ContinueOnCapturedContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A API mais repugnante do .NET √© chamada </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nesse caso, a API cria um gar√ßom especial diferente </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">daquele que muda a continua√ß√£o, √© executado no mesmo encadeamento, no mesmo contexto em que o m√©todo terminou </font></font><code>InnerAsync </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e onde a tarefa foi encerrada.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//code must be absolutely context-agnostic</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° uma quantidade insana de conselhos na Internet: se voc√™ tiver um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impasse</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , limpe todo o seu c√≥digo ConfigureAwait e tudo ficar√° bem. </font><font style="vertical-align: inherit;">Este √© o caminho errado. </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode ser usado nos casos em que voc√™ deseja melhorar um pouco o desempenho, ou no final do m√©todo, em alguns m√©todos da biblioteca.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deadlocks</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode();<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este √© um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impasse</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cl√°ssico </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No thread da interface do usu√°rio, eles esperaram dez segundos e o fizeram </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Devido ao que voc√™ fez </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ele </font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nunca ser√° lan√ßado e, </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">portanto </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">nunca retornar√°. </font><font style="vertical-align: inherit;">Tudo isso acontece no come√ßo.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">OnBluttionClick</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span>
  <span class="hljs-keyword">int</span> v = Button.Text.ParseInt();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
  Button.Text.Set((v+<span class="hljs-number">1</span>).ToString());<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagine que essa √© uma atividade real. Clicamos no bot√£o, pegamos </font></font><code>Button.ParseInt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aguardamos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , escrevemos </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dizemos: "Por favor, n√£o feche o fluxo da interface do usu√°rio, execute a continua√ß√£o". O problema √© que queremos que a segunda parte </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamb√©m seja executada no thread da interface do usu√°rio, porque esta √© a filosofia de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aguardar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ou seja, seu c√≥digo ass√≠ncrono parece o mesmo que o c√≥digo s√≠ncrono e √© executado no mesmo contexto. Nesse caso, √© claro, haver√° um erro. Al√©m disso </font></font><code>Button.Text.Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pode haver qualquer n√∫mero de chamadas de m√©todo que tamb√©m assumem seu contexto. O que fazer nessa situa√ß√£o? Voc√™ consegue fazer isso:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//The same UI context</span><font></font>
}<font></font>
PumpUntil(() =&gt; task.IsCompleted);<font></font>
<span class="hljs-comment">//VS synchronization contexts always pump on any Wait</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com um encadeamento da interface do usu√°rio, voc√™ deve proibi-lo </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em encadeamentos que tenham uma fila de mensagens comum. Em vez de fazer </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou escrever </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, voc√™ pode bombear essa fila de mensagens e, ao mesmo tempo, o continuum tamb√©m ser√° bombeado. Se voc√™ n√£o pode misturar c√≥digo s√≠ncrono e ass√≠ncrono, n√£o deve mistur√°-los. Mas √†s vezes isso n√£o pode ser evitado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, voc√™ tem um c√≥digo antigo e precisa mistur√°-lo e depois bombear o fluxo da interface do usu√°rio. O Visual Studio bombeia o thread da interface do usu√°rio com as expectativas, at√© </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mudou um pouco. Se voc√™ entrar no WaitHandle em qualquer um </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, quando voc√™ travar, o fluxo da interface do usu√°rio ser√° bombeado. Assim, eles escolhem entre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impasses</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e ra√ßas em favor das ra√ßas. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pumpuntil</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Essa √© uma API n√£o ideal, ou seja, quando voc√™ executa continuidade aleat√≥ria em um local arbitr√°rio, pode haver nuances. </font><font style="vertical-align: inherit;">Infelizmente n√£o h√° outro caminho. </font><font style="vertical-align: inherit;">Misture c√≥digos s√≠ncronos e ass√≠ncronos. </font><font style="vertical-align: inherit;">Se qualquer coisa, todo o Cavaleiro est√° t√£o organizado nos lugares antigos, ent√£o √†s vezes tamb√©m existem nuances.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alterar contexto</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> myTaskScheduler;<font></font>
    continuationCode(); <span class="hljs-comment">//on scheduler context </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existe outra maneira interessante de usar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / waitit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Voc√™ pode escrever </font></font><code>Awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e saltar sobre t√≥picos. </font><font style="vertical-align: inherit;">Eu li postagens no Visual Studio, eles escreveram por muito tempo que n√£o √© bom ir e voltar no meio do m√©todo, mas agora eles fazem isso sozinhos. </font><font style="vertical-align: inherit;">O Visual Studio tem uma API que salta nos threads pelos agendadores. </font><font style="vertical-align: inherit;">Para uso normal, fazer isso n√£o √© bom.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concorr√™ncia estruturada</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Factory.StartNew(() =&gt; {...}, myTaskScheduler);<font></font>
    continuationCode(); <span class="hljs-comment">//on initial context </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para uma imers√£o conveniente no novo contexto e retorno ao antigo, alguma competi√ß√£o estrutural ou paralelismo estrutural deve ser constru√≠da. </font><font style="vertical-align: inherit;">Por exemplo, nos anos sessenta, o operador GoTo foi considerado prejudicial por violar a estruturalidade. </font><font style="vertical-align: inherit;">Ent√£o √© aqui. </font><font style="vertical-align: inherit;">Saltar sobre as linhas viola o estrutural. </font><font style="vertical-align: inherit;">Surpreendentemente, usar uma m√°quina de estado ass√≠ncrona parece uma boa sa√≠da. </font><font style="vertical-align: inherit;">Ou seja, onde sua estrutura usual √© violada, voc√™ pula no GoTo, pode violar a estrutura do thread: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aguarde</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">misture </font><font style="vertical-align: inherit;">-a com tags. </font><font style="vertical-align: inherit;">Essa √© uma situa√ß√£o extremamente estranha e rara quando voc√™ precisa fazer isso. </font><font style="vertical-align: inherit;">Ainda assim, √© melhor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esperar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quando o </font><font style="vertical-align: inherit;">retorno ao mesmo contexto. </font><font style="vertical-align: inherit;">Portanto, o conjunto de encadeamentos n√£o ter√° o mesmo encadeamento, mas o mesmo contexto que era originalmente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comportamento sequencial</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esperar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o √© o mesmo que execu√ß√£o paralela? </font><font style="vertical-align: inherit;">Aguardar execu√ß√£o √© execu√ß√£o sequencial. </font><font style="vertical-align: inherit;">Nesse caso, iniciamos a primeira tarefa, esperamos por ela, iniciamos a segunda tarefa - esperamos. </font><font style="vertical-align: inherit;">N√£o temos paralelismo. </font><font style="vertical-align: inherit;">Para a maioria dos usos, o paralelismo n√£o √© necess√°rio. </font><font style="vertical-align: inherit;">O paralelismo em si √© mais complexo que a sequ√™ncia. </font><font style="vertical-align: inherit;">O c√≥digo de s√©rie √© mais simples que paralelo, √© um axioma. </font><font style="vertical-align: inherit;">Mas, √†s vezes, voc√™ precisa executar algo em c√≥digo paralelo e faz o seguinte:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">await</span> task1;<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comportamento concorrente</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();<font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui as tarefas come√ßam em paralelo. </font><font style="vertical-align: inherit;">√â claro que os m√©todos podem retornar a tarefa imediatamente em um estado de execu√ß√£o, ent√£o n√£o haver√° paralelismo. </font><font style="vertical-align: inherit;">Digamos que ambos os tarefas executem uma execu√ß√£o. </font><font style="vertical-align: inherit;">E voc√™ esperou a primeira tarefa, depois a primeira espera decolou. </font><font style="vertical-align: inherit;">Ou seja, assim que voc√™ escreveu </font></font><code>await task1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, voc√™ decolou e n√£o processou </font></font><code>exception task2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Curiosamente, este √© um c√≥digo absolutamente v√°lido. </font><font style="vertical-align: inherit;">E foi esse c√≥digo que levou o .NET ao fato de que, na vers√£o 4.5, o comportamento de trabalhar com execu√ß√µes mudou.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manipula√ß√£o de exce√ß√£o</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async(); <font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2;<font></font>
<font></font>
  <span class="hljs-comment">// if task1 throws exception and task2 throws exception we only throw and</span>
  <span class="hljs-comment">// handle task1‚Äôs exception</span><font></font>
<font></font>
  <span class="hljs-comment">//4.0 -&gt; 4.5 framework: unhandled exceptions now don‚Äôt crush process</span>
  <span class="hljs-comment">//still visible in UnobservedExceptionHandler</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anteriormente, as execu√ß√µes n√£o tratadas simplesmente lan√ßavam o processo e, se voc√™ n√£o capturava alguma execu√ß√£o </font></font><code>UnobservedExceptionHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(tamb√©m s√£o algumas </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que podem ser anexadas aos agendadores), esse processo n√£o era executado. Agora, este √© um c√≥digo absolutamente v√°lido. Embora o .NET tenha alterado seu comportamento, ele manteve a configura√ß√£o para retornar o comportamento na dire√ß√£o oposta.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span>  Task  <span class="hljs-title">MyAsync</span>(<span class="hljs-params">CancellationToken cancellationToken</span>)</span>  {  <font></font>
<font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">SomeTask1  <span class="hljs-title">Async</span>(<span class="hljs-params">cancellationToken</span>)</span>; <font></font>
 <font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">Some <span class="hljs-title">Task2Async</span>(<span class="hljs-params"> cancellation  Token</span>)</span>; 
  <span class="hljs-comment">//you should always pass use async API with cancelationToken  if possible </span><font></font>
} <font></font>
  <font></font>
<span class="hljs-keyword">try</span> { 
    <span class="hljs-keyword">await</span>  MyAsync( cancellation  Token); <font></font>
} <span class="hljs-keyword">catch</span> (OperationException e) { <span class="hljs-comment">// do nothing: OCE happened</span>
} <span class="hljs-keyword">catch</span> (Exception e) { <font></font>
    log.Error(e);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veja como √© o processamento da execu√ß√£o. </font><font style="vertical-align: inherit;">CancellationToken-s deve ser transmitido, √© necess√°rio "manchar" todo o c√≥digo de CancellationToken-s. </font><font style="vertical-align: inherit;">O comportamento normal do ass√≠ncrono √© que voc√™ n√£o verifica em nenhum lugar </font></font><code>Task.Status ancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, trabalha com c√≥digo ass√≠ncrono da mesma maneira que com s√≠ncrono. </font><font style="vertical-align: inherit;">Ou seja, no caso de um cancelamento, voc√™ obt√©m uma execu√ß√£o e, nesse caso, n√£o faz nada quando a recebe </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A diferen√ßa entre o status de Cancelado e Falha √© que voc√™ n√£o recebeu </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas a execu√ß√£o usual. </font><font style="vertical-align: inherit;">E, neste caso, podemos prometer, voc√™ s√≥ precisa obter uma execu√ß√£o e tirar conclus√µes com base nisso. </font><font style="vertical-align: inherit;">Se voc√™ iniciou a tarefa explicitamente, atrav√©s da Tarefa, teria voado </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">E em ass√≠ncrono, no caso, eles </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sempre lan√ßam a primeira execu√ß√£o que estava nela (neste caso - </font></font><code>OperationCanceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na pr√°tica</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todo s√≠ncrono</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SynchronousWorker</span>(<span class="hljs-params">...</span>)</span> {<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, um dem√¥nio trabalha no ReSharper - um editor que tinge o arquivo para voc√™. </font><font style="vertical-align: inherit;">Se o arquivo for aberto no editor, h√° alguma atividade que o coloca em uma fila de bloqueio. </font><font style="vertical-align: inherit;">Nosso processo </font></font><code>worker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l√™ a partir da√≠, ap√≥s o qual ele executa v√°rias tarefas diferentes com esse arquivo, o tinge, analisa, cria, ap√≥s o qual esses arquivos s√£o adicionados </font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Com uma </font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trava, outros mecanismos j√° est√£o trabalhando com ela.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todo ass√≠ncrono</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao reescrever o c√≥digo para ass√≠ncrono, primeiro substitu√≠-lo-emos </font></font><code>void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>async Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Certifique-se de escrever a palavra "Async" no final. </font><font style="vertical-align: inherit;">Todos os m√©todos ass√≠ncronos devem terminar em Async - esta √© uma conven√ß√£o.</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
<font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois disso, voc√™ precisa fazer algo com o nosso </font></font><code>blockingQueue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Obviamente, se houver alguma primitiva s√≠ncrona, deve haver alguma primitiva ass√≠ncrona. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-6/zk/8i/-6zk8ilnmdsonzd6zkafkcloqyi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse primitivo √© chamado de canal: os canais que vivem no pacote </font></font><code>System.Threading.Channels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Voc√™ pode criar canais e filas, limitados e ilimitados, que podem esperar de forma ass√≠ncrona. Al√©m disso, voc√™ pode criar um canal com o valor "zero", ou seja, ele n√£o ter√° um buffer. Esses canais s√£o chamados de canais de encontro e s√£o promovidos ativamente em Go e Kotlin. E, em princ√≠pio, se √© poss√≠vel usar canais em c√≥digo ass√≠ncrono, esse √© um padr√£o muito bom. Ou seja, alteramos a fila para o canal em que existem m√©todos </font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>WriteAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessInParallel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© um monte de c√≥digo paralelo que processa um arquivo e o transforma em</font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O ass√≠ncrono pode nos ajudar a escrever c√≥digos n√£o ass√≠ncronos, mas paralelos, de maneira mais compacta?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplificar c√≥digo paralelo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O c√≥digo pode ser reescrito desta maneira:</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e0/zt/8u/e0zt8ud_8b4_wsiqsrd9_baalwy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como eles s√£o </font></font><code>ProcessInParallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Por exemplo, temos um arquivo Primeiro, dividimos em lexemas e podemos ter duas tarefas em paralelo: a cria√ß√£o de caches de pesquisa e a constru√ß√£o de uma √°rvore de sintaxe. Depois disso, vem a tarefa de "procurar erros sem√¢nticos". √â importante aqui que todas essas tarefas formem um gr√°fico ac√≠clico direcionado. Ou seja, voc√™ pode executar algumas partes em encadeamentos paralelos, outras n√£o, e obviamente existem depend√™ncias de qual tarefa deve aguardar outras. Voc√™ obt√©m um gr√°fico dessas tarefas e deseja dispers√°-las de alguma forma pelos threads. √â poss√≠vel escrev√™-lo lindamente, sem erros? Em nosso c√≥digo, esse problema foi resolvido v√°rias vezes, cada vez de uma maneira diferente. Isso raramente acontece quando esse c√≥digo √© escrito sem erros.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xh/-h/3j/xh-h3jav69twzsqei3rrjbe2ymy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Definimos esse gr√°fico de tarefas da seguinte forma: digamos que cada tarefa tenha outras tarefas das quais depende; em seguida, usando o dicion√°rio ExecuteBefore, escrevemos o esqueleto do nosso m√©todo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solu√ß√µes esquel√©ticas</font></font></h3> <br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore; <span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();<font></font>
<font></font>
<font></font>
  <span class="hljs-comment">// lots of work with toposort, locks, etc.</span><font></font>
<font></font>
  <span class="hljs-keyword">return</span> res; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ resolver esse problema de frente, precisar√° fazer uma classifica√ß√£o topol√≥gica deste gr√°fico. </font><font style="vertical-align: inherit;">Em seguida, pegue uma tarefa que n√£o possui tarefas dependentes, execute-a, analise a estrutura sob um bloqueio, veja quais tarefas n√£o possuem dependentes. </font><font style="vertical-align: inherit;">Corra, espalhe-os de alguma forma </font></font><code>Task Runner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Escrevemos um pouco de forma mais compacta: classifica√ß√£o topol√≥gica do gr√°fico + execu√ß√£o de tais tarefas em diferentes threads.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async pregui√ßoso</font></font></h3><br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore;
<span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();
  <span class="hljs-keyword">var</span> lazy = <span class="hljs-keyword">new</span> Dictionary&lt;Action&lt;ProcessedFile&gt;, Lazy&lt;Task&gt;&gt;(); 
  <span class="hljs-keyword">foreach</span> ((action, beforeList) <span class="hljs-keyword">in</span> ExecuteBefore)<font></font>
    lazy[action] = <span class="hljs-keyword">new</span> Lazy&lt;Task&gt;(<span class="hljs-keyword">async</span> () =&gt; <font></font>
    {<font></font>
      <span class="hljs-keyword">await</span> Task.WhenAll(beforeList.Select(b =&gt; lazy[b].Value)) 
      <span class="hljs-keyword">await</span> Task.Yield();<font></font>
      action(res);<font></font>
}<font></font>
  <span class="hljs-keyword">await</span> Task.WhenAll(lazy.Values.Select(l =&gt; l.Value)) 
  <span class="hljs-keyword">return</span> res;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existe um padr√£o chamado </font></font><code>Async Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Criamos o nosso </font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sobre o qual diferentes a√ß√µes devem ser executadas. Vamos criar um dicion√°rio: formataremos cada um dos nossos est√°gios (Action ProcessedFile) em alguma tarefa, ou melhor, em Lazy from Task e executaremos o gr√°fico original. A vari√°vel </font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ter√° a pr√≥pria </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a√ß√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e em beforeList - aquelas a√ß√µes que devem ser executadas antes da nossa. Ent√£o crie a </font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partir de </font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Escrevemos em Tarefa </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Portanto, estamos aguardando todas as tarefas que devem ser conclu√≠das antes dele. No beforeList, selecione o </font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que est√° neste dicion√°rio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que aqui nada ser√° executado de forma s√≠ncrona, portanto esse c√≥digo n√£o ser√° ativado </font></font><code>ItemNotFoundException in Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Realizamos todas as tarefas anteriores √† nossa, realizando uma pesquisa por a√ß√£o</font></font><code>Lazy Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ent√£o, executamos nossa a√ß√£o. </font><font style="vertical-align: inherit;">No final, voc√™ s√≥ precisa solicitar que cada tarefa inicie, caso contr√°rio, voc√™ nunca sabe se algo n√£o foi iniciado. </font><font style="vertical-align: inherit;">Nesse caso, nada come√ßou. </font><font style="vertical-align: inherit;">Essa √© a solu√ß√£o. </font><font style="vertical-align: inherit;">Este m√©todo √© escrito em 10 minutos, √© absolutamente √≥bvio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, o c√≥digo ass√≠ncrono tomou nossa decis√£o, inicialmente ocupou duas telas com c√≥digo competitivo complexo. </font><font style="vertical-align: inherit;">Aqui ele √© absolutamente consistente. </font><font style="vertical-align: inherit;">Eu nem uso </font></font><code>ConcurrentDictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, eu uso o habitual </font></font><code>Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque n√£o escrevemos nada para ele de forma competitiva. </font><font style="vertical-align: inherit;">Existe um c√≥digo consistente e consistente. </font><font style="vertical-align: inherit;">Resolvemos o problema de escrever c√≥digo paralelo usando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async-s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lindamente, o que significa - sem erros.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Livre-se dos bloqueios</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
    <span class="hljs-keyword">lock</span> (_lock) {<font></font>
      sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
   }<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vale a pena puxar ass√≠ncrono e esses bloqueios? Agora, existem todos os tipos de bloqueios ass√≠ncronos, sem√°foros ass√≠ncronos, ou seja, uma tentativa de usar os primitivos que est√£o no c√≥digo s√≠ncrono e ass√≠ncrono. Esse conceito parece estar errado, porque com o bloqueio voc√™ protege algo da execu√ß√£o paralela. Nossa tarefa √© traduzir a execu√ß√£o paralela em seq√ºencial, porque √© mais f√°cil. E se for mais simples, menos erros.</font></font><br>
<br>
<pre><code class="cs hljs">Channel&lt;Pair&lt;File, ProcessedFile&gt;&gt; output;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
  <font></font>
  <span class="hljs-keyword">await</span> output.WriteAsync(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos criar um canal e colocar alguns arquivos e ProcessedFile, e </font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algum outro procedimento </font><font style="vertical-align: inherit;">processar√° esse canal </font><font style="vertical-align: inherit;">e o far√° sequencialmente. O pr√≥prio bloqueio, al√©m de proteger a estrutura, lineariza essencialmente o acesso, um local onde todos os segmentos dos consecutivos se tornam paralelos. E estamos substituindo isso explicitamente pelo canal. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q_/qe/mf/q_qemfc4mssz9shitqlekzee6nc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A arquitetura √© a seguinte: os trabalhadores recebem arquivos </font></font><code>input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e os enviam para algum lugar no processador, que tamb√©m processa tudo sequencialmente, sem paralelismo. O c√≥digo parece muito mais simples. Entendo que nem tudo pode ser feito dessa maneira. Essa arquitetura, quando voc√™ pode criar canais de dados, nem sempre funciona.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7k/9j/sv/7k9jsvdwqbqrzgbejoozsk5lj_s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pode ser que voc√™ tenha um segundo canal que entra no seu processador e n√£o √© formado um gr√°fico direcionado ac√≠clico a partir dos canais, mas um gr√°fico com ciclos. </font><font style="vertical-align: inherit;">Este √© um exemplo que Roman Elizarov disse √† KotlinConf em 2018. </font><font style="vertical-align: inherit;">Ele escreveu um exemplo no Kotlin com esses canais, e havia ciclos l√°, e esse exemplo foi encerrado. </font><font style="vertical-align: inherit;">O problema era que, se voc√™ tem esses ciclos em um gr√°fico, tudo se torna mais complicado no mundo ass√≠ncrono. </font><font style="vertical-align: inherit;">Os bloqueios ass√≠ncronos s√£o ruins, pois s√£o muito mais dif√≠ceis de resolver do que s√≠ncronos quando voc√™ tem uma pilha de encadeamentos, e est√° claro o que se manteve. </font><font style="vertical-align: inherit;">Portanto, √© uma ferramenta que deve ser usada corretamente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sum√°rio</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evite a sincroniza√ß√£o no c√≥digo ass√≠ncrono.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O c√≥digo de s√©rie √© mais simples que paralelo.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O c√≥digo ass√≠ncrono pode ser simples e usar um m√≠nimo de par√¢metros e um contexto impl√≠cito que altera seu comportamento.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ desenvolveu o h√°bito de escrever c√≥digo s√≠ncrono, e mesmo se o c√≥digo ass√≠ncrono for muito semelhante ao s√≠ncrono, n√£o arraste as primitivas para l√°, com as quais voc√™ est√° acostumado no c√≥digo s√≠ncrono </font></font><code>async mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Use feeds, se poss√≠vel, e outras primitivas para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transmiss√£o de mensagens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O c√≥digo de s√©rie √© mais simples que paralelo. Se voc√™ puder escrever sua arquitetura de forma que pare√ßa sequencialmente, sem executar c√≥digo paralelo e bloqueio, escreva a arquitetura sequencialmente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E a √∫ltima coisa que vimos de um grande n√∫mero de exemplos com tarefas. </font><font style="vertical-align: inherit;">Ao projetar seu sistema, tente confiar menos no contexto impl√≠cito. </font><font style="vertical-align: inherit;">O contexto impl√≠cito leva a um mal-entendido do que est√° acontecendo no c√≥digo, e voc√™ pode esquecer os problemas impl√≠citos em um ano. </font><font style="vertical-align: inherit;">E se outra pessoa trabalha nesse c√≥digo e refaz algo nele, isso pode levar a dificuldades que voc√™ conhecia e o novo programador n√£o conhece por causa do contexto impl√≠cito. </font><font style="vertical-align: inherit;">Como resultado, o design inadequado √© caracterizado por um grande n√∫mero de par√¢metros, sua combina√ß√£o e contexto impl√≠cito.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que ler</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documento TAP</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Orienta√ß√£o ass√≠ncrona</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vida √∫til</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">medium.com/@elizarov/deadlocks-in-non-hierarchical-csp-e5910d137cc</font></font></a></li>
</ul><br>
<blockquote>     -10     .     DotNext   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt491218/index.html">Integra√ß√£o do PVS-Studio no PlatformIO</a></li>
<li><a href="../pt491224/index.html">Automa√ß√£o de um servi√ßo de expedi√ß√£o ou Como uma empresa de servi√ßos pode reduzir os custos de transporte em 30%</a></li>
<li><a href="../pt491230/index.html">Como eu fui para a escola 21 e a divulga√ß√£o de segredos</a></li>
<li><a href="../pt491232/index.html">RPA + Machine Learning = Automa√ß√£o Inteligente</a></li>
<li><a href="../pt491234/index.html">Tr√™s truques para trabalhar com o SOLIDWORKS para modelar pe√ßas para impress√£o 3D</a></li>
<li><a href="../pt491238/index.html">An√°lise de C√≥digo Gen√©tico II</a></li>
<li><a href="../pt491240/index.html">O caminho para as nuvens: ontem e hoje Adobe</a></li>
<li><a href="../pt491244/index.html">O Ableton n√£o √© necess√°rio: conecte o Ableton Push 2 ao rack de VCV</a></li>
<li><a href="../pt491246/index.html">Confer√™ncia DEFCON 27. Seu carro √© meu carro. Parte 2</a></li>
<li><a href="../pt491250/index.html">L√¢mpadas LED Gauss Basic</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>