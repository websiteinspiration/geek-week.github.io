<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👩🏻 👨🏻‍🚒 👩🏽‍🤝‍👨🏾 3 formas de renderizar listas grandes en Angular 👨🏻‍✈️ 📥 ⛳️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En 2020, los marcos front-end se volvieron mejores, más eficientes y más rápidos. Pero incluso con esto en mente, renderizar listas grandes sin congel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>3 formas de renderizar listas grandes en Angular</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/492506/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En 2020, los marcos front-end se volvieron mejores, más eficientes y más rápidos. Pero incluso con esto en mente, renderizar listas grandes sin congelar el navegador puede ser una tarea desalentadora incluso para los marcos existentes más rápidos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es uno de esos casos donde "el marco es rápido y el código es lento". </font><font style="vertical-align: inherit;">
Existen muchos enfoques que le permiten mostrar una gran cantidad de elementos sin bloquear la interacción del usuario con la página web. </font><font style="vertical-align: inherit;">
El autor del artículo, cuya traducción publicamos hoy, quiere explorar los métodos existentes para mostrar grandes listas en páginas web y hablar sobre sus áreas de aplicación.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ql/ap/04/qlap04o-7mdhzho6nedwbgz64gk.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aunque este material está dirigido a Angular, lo que se discute aquí se aplica a otros marcos y proyectos que están escritos en JavaScript puro. </font><font style="vertical-align: inherit;">En particular, los siguientes enfoques para representar listas grandes se considerarán aquí:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desplazamiento virtual (usando Angular CDK).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Representación manual.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render progresivo</font></font></li>
</ul><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desplazamiento virtual</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El desplazamiento virtual es quizás la forma más eficiente de trabajar con listas grandes. </font><font style="vertical-align: inherit;">Es cierto que tiene algunas desventajas. </font><font style="vertical-align: inherit;">El desplazamiento virtual, gracias a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angular CDK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y otros complementos, es muy fácil de implementar en cualquier componente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea detrás del desplazamiento virtual es simple, pero no siempre es fácil de implementar. </font><font style="vertical-align: inherit;">La conclusión aquí es que tenemos un contenedor y una lista de elementos. </font><font style="vertical-align: inherit;">Un elemento se representa solo si está dentro del área visible del contenedor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilizaremos el módulo </font></font><code>scrolling</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de Angular CDK, que está diseñado para organizar el desplazamiento virtual. </font><font style="vertical-align: inherit;">Para hacer esto, primero debe instalar el CDK:</font></font><br>
<br>
<pre><code class="bash hljs">npm i @angular/cdk
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces necesitas importar el módulo:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { ScrollingModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/cdk/scrolling'</span>;<font></font>
@NgModule({<font></font>
&nbsp;...<font></font>
&nbsp;imports: [ ScrollingModule, ...]<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> </span>{}
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de eso, en los componentes que puede usar </font></font><code>cdk-virtual-scroll-viewport</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cdk-virtual-scroll-viewport</span> <span class="hljs-attr">itemSize</span>=<span class="hljs-string">"50"</span>&gt;</span>
&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">cdkVirtualFor</span>=<span class="hljs-string">"let item of items"</span>&gt;</span><font></font>
&nbsp;&nbsp;&nbsp;{{ item }}<font></font>
&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">cdk-virtual-scroll-viewport</span>&gt;</span>
</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí hay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un proyecto de ejemplo que utiliza este enfoque para organizar el desplazamiento virtual. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver, los mecanismos angulares estándar permiten, sin mucha dificultad, lograr resultados impresionantes. El componente en el ejemplo representa muchos miles de elementos sin ningún problema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si el desplazamiento virtual es tan bueno y es tan fácil de implementar, surge la pregunta de por qué estudiar otras formas de generar listas grandes. También me interesó esta pregunta. Al final resultó que, este estado de cosas tiene varias razones:</font></font><br>
<br>
<ul>
<li>,      ,     .        ,     . ,      <code>Autocomplete</code> (    ).  , ,    ,   ,  .     —        .</li>
<li>      —    ,    .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay algunos problemas con la accesibilidad y la facilidad de uso de los contenidos de una lista con desplazamiento virtual. </font><font style="vertical-align: inherit;">Los elementos ocultos no se representan: esto significa que no estarán disponibles para los lectores de pantalla y que no se pueden encontrar en la página utilizando mecanismos de navegador estándar.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El desplazamiento virtual es ideal en una serie de situaciones (siempre que funcione):</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En ese caso, si desea mostrar listas cuyo tamaño no se conoce de antemano, o aquellas que pueden ser enormes (según una estimación aproximada, listas que incluyen más de 5 mil elementos, pero esto depende en gran medida de la complejidad de cada elemento).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el caso de que necesite organizar un desplazamiento sin fin.</font></font></li>
</ul><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderizado manual</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una de las formas de trabajar con listas que traté de acelerar la salida de un gran conjunto de elementos es utilizar el renderizado manual utilizando la API angular </font></font><code>*ngFor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos una plantilla simple que usa un ciclo organizado usando la directiva *</font></font><code>ngFor</code><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&nbsp;
*<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of data; trackBy: trackById; let isEven = even; let isOdd = odd"</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">class</span>=<span class="hljs-string">"h-12"</span>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="hljs-attr">class.bg-gray-400</span>]=<span class="hljs-string">"isEven"</span>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="hljs-attr">class.bg-gray-500</span>]=<span class="hljs-string">"isOdd"</span>
&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"py-2 px-4"</span>&gt;</span>{{ item.id }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{ item.label }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"py-2 px-4 rounded (click)="</span><span class="hljs-attr">remove</span>(<span class="hljs-attr">item</span>)"&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para medir el rendimiento de representación de 10.000 elementos simples, utilicé un punto de referencia basado en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">js-frameworks-benchmark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, examiné el rendimiento de una lista, que usa un bucle regular para la salida </font></font><code>*ngFor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como resultado, resultó que la ejecución del código (Scripting) tomó 1099 ms., La representación (Rendering) tomó 1553 ms., Y el dibujo (Pintura) - 3 ms.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdc/65d/617/bdc65d6174798028877e98bdcc7830d8.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un estudio del rendimiento de una lista, que utiliza * ngFor para la salida, los</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
elementos de la</font><i><font color="#999999"><font style="vertical-align: inherit;"> lista</font></font></i><font style="vertical-align: inherit;"> se pueden representar manualmente utilizando la API angular:</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> #<span class="hljs-attr">itemsContainer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> #<span class="hljs-attr">item</span> <span class="hljs-attr">let-item</span>=<span class="hljs-string">"item"</span> <span class="hljs-attr">let-isEven</span>=<span class="hljs-string">"isEven"</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"h-12 "</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="hljs-attr">class.bg-gray-400</span>]=<span class="hljs-string">"isEven"</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="hljs-attr">class.bg-gray-500</span>]=<span class="hljs-string">"!isEven"</span>
&nbsp;&nbsp;&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"py-2 px-4"</span>&gt;</span>{{ item.id }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{ item.label }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"py-2 px-4 rounded"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"remove(item)"</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
&nbsp;&nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hablemos de cómo ha cambiado el código del controlador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Declaramos una plantilla y un contenedor:</font></font><br>
<br>
<pre><code class="html hljs xml">@ViewChild('itemsContainer', { read: ViewContainerRef }) container: ViewContainerRef;<font></font>
@ViewChild('item', { read: TemplateRef }) template: TemplateRef<span class="hljs-tag">&lt;<span class="hljs-name">any</span>&gt;</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al generar datos, los representamos utilizando el método de </font></font><code>createEmbeddedView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entidad </font></font><code>ViewContainerRef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="html hljs xml">private buildData(length: number) {<font></font>
&nbsp;&nbsp;const start = this.data.length;<font></font>
&nbsp;&nbsp;const end = start + length;<font></font>
<font></font>
&nbsp;&nbsp;for (let n = start; n <span class="hljs-tag">&lt;<span class="hljs-name">=</span> <span class="hljs-attr">end</span>; <span class="hljs-attr">n</span>++) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">this.container.createEmbeddedView</span>(<span class="hljs-attr">this.template</span>, {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">item:</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">id:</span> <span class="hljs-attr">n</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">label:</span> <span class="hljs-attr">Math.random</span>()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">isEven:</span> <span class="hljs-attr">n</span> % <span class="hljs-attr">2</span> === <span class="hljs-string">0</span>
&nbsp;&nbsp;&nbsp;&nbsp;});
&nbsp;&nbsp;}
}
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, los indicadores que caracterizan el rendimiento de la lista se mejoraron ligeramente. </font><font style="vertical-align: inherit;">Es decir, se necesitaron 734 ms para ejecutar el código, 1443 ms para renderizar, 2 ms para dibujar.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a67/3dd/0c5/a673dd0c5ca9c97dc057124d056646e7.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Investigar el rendimiento de una lista que usa la API angular para generar</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
True, en la práctica, esto significa que la lista sigue siendo extremadamente lenta. </font><font style="vertical-align: inherit;">Cuando hace clic en el botón correspondiente, el navegador se "congela" durante unos segundos. </font><font style="vertical-align: inherit;">Si esto apareciera en producción, a los usuarios definitivamente no les gustaría. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Así es como se ve (aquí, usando el mouse, imito el indicador de carga).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f45/5a3/6bc/f455a36bc281147be801caed867b1f1f.gif"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reducción de la lista</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ahora, para mejorar la representación manual de la lista, intentaremos aplicar la tecnología de representación progresiva.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderizado progresivo</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea de renderizado progresivo es simple. </font><font style="vertical-align: inherit;">Consiste en representar un subconjunto de elementos progresivamente, posponiendo la representación de otros elementos en el bucle de eventos. </font><font style="vertical-align: inherit;">Esto permite que el navegador muestre todos los elementos sin "disminuir la velocidad". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente código que implementa la representación progresiva de listas es muy sencillo:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, usando esto </font></font><code>setInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, establecemos una llamada regular, cada 10 ms. A la función que representa 500 elementos cuando se llama.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Después de deducir todos los elementos, que determinamos en función del análisis del índice del elemento actual, detenemos la llamada a la función regular e interrumpimos el ciclo.</font></font></li>
</ul><br>
<pre><code class="javascript hljs">private buildData(length: number) {
&nbsp;&nbsp;<span class="hljs-keyword">const</span> ITEMS_RENDERED_AT_ONCE = <span class="hljs-number">500</span>;
&nbsp;&nbsp;<span class="hljs-keyword">const</span> INTERVAL_IN_MS = <span class="hljs-number">10</span>;<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">let</span> currentIndex = <span class="hljs-number">0</span>;<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">const</span> interval = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> nextIndex = currentIndex + ITEMS_RENDERED_AT_ONCE;<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n = currentIndex; n &lt;= nextIndex ; n++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span> (n &gt;= length) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearInterval(interval);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">break</span>;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> context = {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">item</span>: {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">id</span>: n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">label</span>: <span class="hljs-built_in">Math</span>.random()<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">isEven</span>: n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.container.createEmbeddedView(<span class="hljs-keyword">this</span>.template, context);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;currentIndex += ITEMS_RENDERED_AT_ONCE;<font></font>
&nbsp;&nbsp;}, INTERVAL_IN_MS);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que el número de elementos que se muestran por llamada a la función que se transfiere </font></font><code>setInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, así como la frecuencia de la llamada a esta función, depende completamente de las circunstancias. Por ejemplo, si los elementos de la lista que se muestran son muy complejos, la salida de 500 de estos elementos de una sola vez será inaceptablemente lenta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al medir el rendimiento de esta solución, obtuve resultados que se ven peor que los que recibí anteriormente. Ejecución de código - 907 ms., Representación - 2555 ms., Dibujo - 16 ms.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8eb/91e/bdc/8eb91ebdce039a630cb7ff043afdcb38.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Investigando el rendimiento de una lista, cuyo resultado utiliza renderizado progresivo,</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
pero el usuario, trabajando con dicha lista, experimentará sensaciones mucho más agradables que antes. </font><font style="vertical-align: inherit;">Aunque el tiempo requerido para representar la lista ha aumentado, el usuario no lo notará. </font><font style="vertical-align: inherit;">Nosotros, de una vez, renderizamos 500 elementos. </font><font style="vertical-align: inherit;">En este caso, la representación se realiza fuera de los límites del contenedor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí, pueden surgir algunos problemas debido al hecho de que el contenedor cambia de tamaño durante el renderizado, o la posición del desplazamiento de contenido cambia. </font><font style="vertical-align: inherit;">Si esto sucede, tendrá que lidiar con problemas similares. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Así es como se ve trabajar con dicha lista.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d85/34a/33c/d8534a33c099a4f62a561802db2ff995.gif"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La lista es rápida</font></font></font></i><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resumen</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las técnicas de renderizado manual y progresivo para listas grandes son ciertamente útiles en algunas situaciones. </font><font style="vertical-align: inherit;">Los usé en casos en los que el desplazamiento virtual por alguna razón no me convenía. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado lo anterior, podemos decir que la mayoría de las veces, el desplazamiento virtual, construido sobre la base de una buena biblioteca, como Angular CDK, es la mejor manera de mostrar listas grandes. </font><font style="vertical-align: inherit;">Pero si el desplazamiento virtual no se puede utilizar por alguna razón, el desarrollador tiene otras posibilidades. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Queridos lectores! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cómo genera grandes listas en sus proyectos web?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es492492/index.html">NikiRobot - una evolución en robótica educativa</a></li>
<li><a href="../es492496/index.html">Ejemplo de Simple Notes SPA en Mithril.js</a></li>
<li><a href="../es492500/index.html">Science Garage en ruso. Experiencia traduciendo un show americano</a></li>
<li><a href="../es492502/index.html">MIP * = RE: evidencia de la época del campo de la informática que causó el efecto dominó en física y matemáticas</a></li>
<li><a href="../es492504/index.html">¿Qué sucede cuando un módulo JS se importa dos veces?</a></li>
<li><a href="../es492508/index.html">Libro Kubernetes para DevOps</a></li>
<li><a href="../es492510/index.html">Módulos ES6 en el navegador: ¿están listos o no?</a></li>
<li><a href="../es492512/index.html">CSS: aventuras en la tierra de la translucidez</a></li>
<li><a href="../es492514/index.html">¿Cómo establecer un flujo de documentos electrónicos legalmente significativo de contrapartes en Rusia y Kazajstán?</a></li>
<li><a href="../es492518/index.html">El brote de virus requiere trabajo remoto, lo que significa la firma digital de documentos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>