<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆔 💱 ⛱️ 手続き型パズルジェネレーターの作成 ❄️ 🤸 ➿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この投稿では、私のLinjatパズルゲームのレベルジェネレーターについて説明します。投稿は準備なしで読むことができますが、複数のレベルでプレイすると同化しやすくなります。ソースコードをgithubに投稿しました。記事で説明されているすべてはファイルにありますsrc/main.cc。
 
 投稿プラン...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>手続き型パズルジェネレーターの作成</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452090/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この投稿では、私の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linjat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パズル</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ゲームの</font></a><font style="vertical-align: inherit;">レベルジェネレーターについて説明します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">投稿は準備なしで読むことができますが、複数のレベルでプレイすると同化しやすくなります。</font><font style="vertical-align: inherit;">ソースコード</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をgithub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">投稿しました</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">記事で説明されているすべてはファイルにあります</font></font><code>src/main.cc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
投稿プランの例：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linjatはロジックゲームで、グリッド内のすべての数値とポイントを線で閉じる必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パズルは、ソルバー、ジェネレーター、オプティマイザーの組み合わせを使用して手続き的に生成されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソルバーは、人がするのと同じ方法でパズルを解こうとし、各パズルに興味のある評価を割り当てます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パズルジェネレーターは、パズルの一部（番号）を簡単に変更し、同時に他のすべての部分（ポイント）を変更できるように設計されているため、パズルはまだ解決されていません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パズルオプティマイザーはレベルを繰り返し解決し、現時点で見つかった最も興味深いものから新しいバリエーションを生成します。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ルール</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レベルジェネレーターのしくみを理解するには、残念ながらゲームのルールを理解する必要があります。</font><font style="vertical-align: inherit;">幸い、それらは非常に単純です。</font><font style="vertical-align: inherit;">パズルは、空の正方形、数字、ドットを含むグリッドで構成されています。</font><font style="vertical-align: inherit;">例：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/641/0d0/547/6410d0547bc14faae51beb3942867cb0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレーヤーの目標は、次の3つの条件のもとで、各数値に垂直または水平の線を引くことです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数字を通る線は、数字と同じ長さでなければなりません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線は交差できません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのポイントは線で閉じられている必要があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソリューションの例：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/3ce/91c/7e13ce91c2da2e2d64bd98f523010671.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
やったー！</font><font style="vertical-align: inherit;">ゲームデザインの準備が整い、UIが実装されました。今残っているのは、数百の優れたパズルを見つけることだけです。</font><font style="vertical-align: inherit;">そして、そのようなゲームでは、そのようなパズルを手動で作成しようとすることは通常意味がありません。</font><font style="vertical-align: inherit;">これはコンピューターの仕事です。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要条件</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このゲームのパズルの良いところは何ですか？パズルゲームは2つのカテゴリに分類できると思います。最初から最後まで複雑な状態空間を探索するゲーム（たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">倉庫番</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラッシュアワーなど</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）があり、どの状態がゲームに存在するかが明確でない場合があります。また、最初からすべての状態がわかっているゲームもあり、不要なもの（たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数独</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピクロス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を排除するプロセスを使用して、状態空間を徐々に作成しています</font><font style="vertical-align: inherit;">。私のゲームは間違いなく2番目のカテゴリに属しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレイヤーは、これらの異なるタイプのパズルに対して非常に異なる要件を持っています。</font><font style="vertical-align: inherit;">2番目のケースでは、彼らはパズルが控除によってのみ解決できること、そして戻る/推測/試行錯誤する必要がないことを期待しています</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[0] </font></font></sup><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パズルがロジックによってのみ解決できるかどうかを知るだけでは十分ではありません。</font><font style="vertical-align: inherit;">さらに、作成されたパズルがどれほど優れているかを理解する必要があります。</font><font style="vertical-align: inherit;">それ以外の場合、ほとんどのレベルはほんのささいなスラグになります。</font><font style="vertical-align: inherit;">理想的な状況では、この原則を使用して滑らかな進行曲線を作成することもできます。これにより、プレーヤーがゲームを進めるにつれて、レベルが徐々に難しくなります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソルバー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの要件を満たすための最初のステップは、この目的のために最適化されたゲームソルバーを作成することです。</font><font style="vertical-align: inherit;">バックトラックソルバーを使用すると、パズルが解けるかどうかをすばやく正確に判断できます。</font><font style="vertical-align: inherit;">さらに、ソリューションを一意にするかどうかを決定するために変更できます。</font><font style="vertical-align: inherit;">しかし、人々はそれらを異なる方法で解決するので、彼はパズルが実際にどれほど複雑であるかという考えを与えることはできません。</font><font style="vertical-align: inherit;">ソルバーは人間の行動を真似する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人はこのパズルをどのように解決しますか？</font><font style="vertical-align: inherit;">ここでは、ゲーム内チュートリアルが教える明確な動きをいくつか示します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つの番号からのみポイントに到達できる場合、ポイントを閉じるには、その番号から線を引く必要があります。</font><font style="vertical-align: inherit;">この例では、ポイントは3つからのみ到達でき、4つからは到達できません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76d/1d4/e3e/76d1d4e3e87a0cc9efdebbd586420c84.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これはこの状況につながります：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a15/db3/05f/a15db305fa78a149ee614de0b4b8ed54.png"></div></li>
<li>      ,      .         ,   ,    :<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ef/048/99f/5ef04899f1c9da5a5b8492e1316ddcbf.png"></div></li>
<li> ,    X      (/)    ,     X     ,      .         ,     ,        .    ,       :<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02c/bfa/021/02cbfa02113362bc6e3c5217baee3ff3.png"></div></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様の推論がゲームの基本です。プレーヤーは、少し1行を伸ばす方法を探し、フィールドをもう一度調べます。これにより、フィールドは別の論理的な結論を出すための情報を提供することができます。これらのルールに従うソルバーを作成する</font><font style="vertical-align: inherit;">ことで</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人が前に戻ることなくパズルを解ける</font><font style="vertical-align: inherit;">か</font><i><font style="vertical-align: inherit;">どうか</font></i><font style="vertical-align: inherit;">を判断</font><font style="vertical-align: inherit;">できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、これはレベルの複雑さや面白さについては何も教えてくれません。可解性に加えて、どういうわけか複雑さを定量化する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
評価関数の明白な最初のアイデア：パズルを解くために必要な動きが多いほど、難しくなります。これはおそらく他のゲームでは良い指標ですが、おそらく私の場合は、プレーヤーの許可された動きの数よりも重要です。プレーヤーが10の論理的な結論を出すことができる場合、彼はおそらくそれらの1つを非常に迅速に見つけます。正しい動きが1つしかない場合は、さらに時間がかかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、最初の近似として、決定木を深く狭くする必要があります。最初から最後までの移動には長い依存関係があり、各瞬間にチェーンを上る方法は少数しかありません</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
木の幅と深さをどのように決定しますか？作成されたツリーのパズルと評価に対する単一のソリューションでは、正確な答えが得られません。移動が行われる正確な順序は、木の形に影響します。考えられるすべてのソリューションを検討し、それらを使用して、最適なケースと最悪のケースの最適化を行う必要があります。私は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パズルゲームでの検索グラフの大まかな検索の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手法に精通してい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">が、このプロジェクトでは、ある種の網羅的な検索ではなく、ワンパスソルバーを作成したいと思いました。最適化フェーズのため、ソルバーの実行時間を秒単位ではなくミリ秒単位で測定するようにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しないことにしました。代わりに、私のソルバーは実際には一度に1つの動きをするのではなく、パズルをレイヤーで解決します。状態を取得すると、彼は可能なすべての有効な動きを見つけます。次に、これらすべての動きを同時に適用し、新しい状態で新たに開始します。レイヤーの数と1つのレイヤーで見つかった移動の最大数は、検索ツリー全体の深さと幅のおおよその値として使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このモデルで難しいパズルの1つを解決する方法は次のとおりです。点線はソルバーのこのレイヤーで引き伸ばされた線で、実線は変更されていない線です。緑の線は正しい長さで、赤の線はまだ完全ではありません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2af/1de/cfb/2af1decfbc170ec8965ae8b1cce2cbea.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の問題は、プレイヤーが行ったすべての動きが等しく作成されることです。</font><font style="vertical-align: inherit;">このセクションの最初に挙げたのは、単なる常識です。</font><font style="vertical-align: inherit;">次に、より複雑な控除規則の例を示します。この検索で​​は、もう少し考える必要があります。</font><font style="vertical-align: inherit;">次のフィールドを検討してください。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/c18/772/9c4c187726bf50f03bbffa748137cf44.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CとDのポイントは、5つと真ん中の4つだけでカバーできます（同時に、両方のポイントをカバーできる数値はありません）。</font><font style="vertical-align: inherit;">これは、中央の4つが2つのポイントの1つをカバーする必要があるため、Aをカバーするために使用できないことを意味します。したがって、ポイントAは左下隅の4つを閉じる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、この推論の連鎖を単純な結論「この点からしか到達できない」に等しいと考えるのはばかげているでしょう。評価関数は、これらのより複雑なルールにより大きな重みを与えることができますか？残念ながら、レイヤーベースのソルバーでは、最小のコストで解を見つけることが保証されていないため、これは不可能です。これは理論上の問題だけではありません。実際には、フィールドの一部が単一の複雑な引数によって、またはより単純な移動のチェーンによって解決できることがよくあります。実際、レイヤーベースのソルバーは最短で最もコストのかからないパスを見つけ、これを評価関数に反映することはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、私はこの決定に至りました。私はソルバーを変更して、各レイヤーが1種類の推論のみで構成されるようにしました。</font><font style="vertical-align: inherit;">アルゴリズムは、おおよその複雑さの順序で推論のルールをバイパスします。</font><font style="vertical-align: inherit;">ルールがいくつかの動きを見つけた場合、それらが適用され、反復が終了し、次の反復がリストを最初から開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、決定には評価が割り当てられます。各レイヤーには、そのレイヤーで使用された1つのルールに基づいてコストが割り当てられます。</font><font style="vertical-align: inherit;">これは、ソリューションが最も低コストであることを保証しませんが、重みが正しく選択されている場合、安価なソリューションがあれば、アルゴリズムは少なくとも高価なソリューションを見つけられません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、それは人々がパズルを解く方法と非常によく似ています。</font><font style="vertical-align: inherit;">彼らはまず簡単な解決策を見つけようとし、単純な動きがない場合にのみ積極的に頭を動かし始めます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発生器</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前のセクションでは、特定のレベルが良いか悪いかを判断しました。</font><font style="vertical-align: inherit;">しかし、これだけでは十分ではなく、ソルバーがレベルを評価できるように、何らかの方法でレベルを生成する必要があります。</font><font style="vertical-align: inherit;">ランダムに生成された世界が解決可能であることは非常にまれです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主なアイデア（決して新しいわけではありません）は、ソルバーとジェネレーターを交互に使用することです。</font><font style="vertical-align: inherit;">おそらく解決できないパズルから始めましょう。2〜5個の数値をセルのランダムな正方形に配置するだけです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cf/164/3c5/8cf1643c568477bc2c774d33a0994f96.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソルバーは、さらに発展するまで機能します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64f/9b4/a5c/64f9b4a5c022b2560c1a26746a0c3539.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ジェネレーターは、より多くの情報を点の形でパズルに追加します。その後、ソルバーの実行が続行されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b4/397/23f/1b439723f7d229887c8392ebc07053f3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、ソルバーに追加されたポイントは、今後の開発には不十分です。</font><font style="vertical-align: inherit;">次に、ジェネレーターはソルバーを満たすまで新しい点を追加し続けます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b2/3a0/48d/6b23a048dc66700a3eadf94206705c7c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ソルバーは彼の通常の作業を続けます：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8e/b9a/77a/b8eb9a77a027a741ce259a1b95fe9c89.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロセスは、パズルが解決されるまで、または追加する情報がなくなるまで続きます（たとえば、数値から到達できる各セルにすでにポイントが含まれている場合）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法が機能するのは、追加された新しい情報によって、以前に行われた結論が不正確にならない場合のみです。</font><font style="vertical-align: inherit;">グリッドに数値を追加する場合、これは難しいでしょう</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、フィールドに新しいポイントを追加することには、この特性があります。</font><font style="vertical-align: inherit;">少なくとも私がこのプログラムで使用している推論規則については。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムはどこにポイントを追加する必要がありますか？結局、できるだけ多くの行で初期状態で閉じることができる空のスペースにそれらを追加して、各ポイントができるだけ少ない情報を提供しようとするようにすることにしました。私は、ソルバーが動けなくなった瞬間にパズルを解くための進歩に役立つであろう場所にポイントを明確に配置しようとはしませんでした。これは非常に便利な効果を生み出します。パズルの最初のポイントのほとんどは完全に役に立たないように見え、パズルは実際よりも複雑に見えます。このすべてがプレーヤーが行える明白な動きの多くであるが、何らかの理由でそれらの1つが正しく機能しない場合。その結果、パズルジェネレーターはブタのように振る舞います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロセスは常にソリューションを作成するわけではありませんが、非常に高速（約50〜100ミリ秒）なので、レベルを生成するには、単純に数回繰り返すことができます。</font><font style="vertical-align: inherit;">残念ながら、彼は通常、平凡なパズルを作成します。</font><font style="vertical-align: inherit;">当初から明らかな動きが多すぎて、フィールドは非常に速く埋まり、決定木はかなり浅いことがわかります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプティマイザ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のプロセスにより、平凡なパズルが作成されました。最終段階では、これらのレベルを最適化プロセスの基礎として使用します。次のように動作します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オプティマイザは、最大10個のパズルオプションを含むプールを作成します。プールは、新しく生成されたランダムパズルで初期化されます。各反復で、オプティマイザはプールから1つのパズルを選択し、その変更を実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
突然変異はすべてのポイントを削除してから、数値をわずかに変更します（つまり、ランダムに選択された数値の値を増減するか、グリッド内の別のセルに数値を移動します）。複数のミューテーションをフィールドに同時に適用できます。次に、前のセクションで説明した特別なレベル生成モードでソルバーを実行します。彼はパズルに十分なポイントを追加して、再び解けるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、今度は通常モードでソルバーを再び開始します。この実行中、ソルバーは、a）決定木の深さ、b）異なるタイプのルールが必要になる頻度、c）異なる時点での決定木の幅を監視します。パズルは上記の基準に基づいて評価されます。評価関数は、深くて狭いソリューションを優先し、複雑さが増すと、推論のより複雑なルールが必要なパズルの重みが増します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、新しいパズルがプールに追加されます。プールに10個を超えるパズルが含まれている場合、最悪のパズルは破棄されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロセスは数回繰り返されます（約10,000〜50000回の繰り返しで満足しました）。</font><font style="vertical-align: inherit;">その後、最も評価の高いバージョンのパズルがパズルレベルのデータベースに保存されます。</font><font style="vertical-align: inherit;">1回の最適化実行での最良のパズルの進行状況は次のとおりです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/504/e61/40c/504e6140c20049ca3424456de0985aaf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の方法で構造最適化を試みました。</font><font style="vertical-align: inherit;">1つのバージョンでは、シミュレーテッドアニーリングが使用されましたが、他のバージョンでは、さまざまな交差操作を伴う遺伝的アルゴリズムが使用されました。</font><font style="vertical-align: inherit;">トップに戻るオプションのプールを持つ単純なアルゴリズムと同様に、実行されたソリューションはありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独自の単一ソリューション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パズルにユニークなユニークなソリューションがある場合、興味深い問題が発生します。</font><font style="vertical-align: inherit;">プレーヤーに1つの解決策があると想定し、これに基づいて結論を出すことは可能ですか？</font><font style="vertical-align: inherit;">パズルジェネレーターがプレーヤーがそうすることを提案した場合、それは公平でしょうか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HackerNewsの投稿で、私はこの状況に対処するための4つのオプションがあると述べました：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソリューションの一意性を最初から宣言し、ジェネレータにこの種の推論を必要とするレベルを作成させる。</font><font style="vertical-align: inherit;">これはルールの理解を複雑にするため、悪い決定です。</font><font style="vertical-align: inherit;">そして通常これらは人々が忘れる詳細です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">決定の一意性を保証しないでください。潜在的に多くの決定があり、それらすべてを決定します。</font><font style="vertical-align: inherit;">実際、これは問題を解決しませんが、それを押しのけます。</font></font></li>
<li> ,     ,     . (      .)</li>
<li>    ,     ,        . (,  ,    .)</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は後者のオプションを選びましたが、それはひどい間違いでした。ソリューションの一意性が情報漏えいにつながった1つの方法のみを考慮したことがわかりましたが、実際には非常にまれです。しかし、他にもあります。それらの1つは、本質的に私が生成したすべてのレベルに存在し、解決策が簡単になったという事実にしばしばつながりました。そのため、2019年5月に、3番目のオプションを使用してハードモードとエキスパートモードを変更しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も煩わしいケースは、このフィールドに破線のあるデュースです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af9/ecf/34f/af9ecf34f96e0d74ae1f514207940020.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
狡猾なプレーヤーはなぜそのような結論を下せるのでしょうか？</font><font style="vertical-align: inherit;">デュースは、隣接する4つの正方形のいずれかをカバーできます。</font><font style="vertical-align: inherit;">ドットが付いていないため、線で覆われている必要はありません。</font><font style="vertical-align: inherit;">また、下の正方形には他の数字とのオーバーレイはありません。</font><font style="vertical-align: inherit;">単一のソリューションがある場合、他の数値が残りの3つの正方形をカバーし、2つがその下の正方形を閉じる場合に当てはまります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決策は、そのようなケースを認識するときにいくつかのポイントを追加することです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7d/d45/ebd/d7dd45ebd5d0a7aebbc78e7da61e1cd9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の一般的なケースは、このフィールドの点線のダッシュです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/252/fc8/13e/252fc813e342f503a2c189645590e7f1.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つの左と上の正方形は違いはありません。それらのどれにもポイントがなく、他の番号から到達することはできません。デュースが上部の正方形をカバーするソリューションには、左の正方形を閉じる対応するソリューションがあり、逆も同様です。単一のユニークなソリューションがあった場合、これは不可能であり、デュースは一番下の四角をカバーしているはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなケースは、「痛い場合は触れないで」と決めました。ソルバーは、優先順位のリストの早い段階でこのルールを適用し、そのような動きに負の重みを割り当てました。この機能を備えたパズルは通常、オプティマイザによって破棄され、残りのいくつかは、公開されたゲームの最終的なレベル選択の段階で破棄されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは完全なリストではありませんが、エラーを意図的に検索したプレイテスト中に、独自の解決策に関する他の多くのルールを見つけました。</font><font style="vertical-align: inherit;">しかし、それらのほとんどは珍しいようで、見つけるのに十分であったため、ゲームを大幅に単純化しませんでした。</font><font style="vertical-align: inherit;">誰かがそのような推論を使ってパズルを解いたとしても、私は彼らのせいにはしません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当初、このゲームは、手続き型のパズルを生成する実験として開発されました。</font><font style="vertical-align: inherit;">ゲームのデザインとジェネレーターは連携していたため、テクニック自体を他のゲームに直接適用することは困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が答えられない質問：手続き型世代へのそのような努力の投資はそれ自体正当化されますか？</font><font style="vertical-align: inherit;">レベルデザインに関するプレイヤーのフィードバックは非常に物議を醸していました。</font><font style="vertical-align: inherit;">肯定的なコメントでは、通常、パズルには常にトリッキーなトリックが感じられると言われていました。</font><font style="vertical-align: inherit;">ほとんどの否定的なレビューでは、ゲームには複雑さの勾配がないと書いてありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はまだ初期の段階でいくつかのパズルを抱えており、ジェネレーターが非常に好きだったので、同様の手続き型アプローチを使用する可能性が高いです。</font><font style="vertical-align: inherit;">変更するのは1つだけです。最初から、エラーを検索してアクティブなプレイテストを実施します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノート</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[0]または、少なくとも、それは私には思えました。しかし、私がプレーヤーをライブで見たとき、彼らのほぼ半分はただ推測をして、それから彼らを通して繰り返しました。とにかく。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[1]私の記事の読者は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マインスイーパの解決と</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Magnus Hoffの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">改善</font></a><font style="vertical-align: inherit;">についての記事も読む必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[2]木の深さ/狭さは、他のすべてのパズルではなく、自分のゲームにとって重要であると考えた指標であることを明確にします。たとえば</font><font style="vertical-align: inherit;">、ラッシュアワーパズルは、ほぼ同じ長さではないがほぼ解決するためのいくつかのパスがある場合、興味深い</font><font style="vertical-align: inherit;">ものであるという</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://web.archive.org/web/20130703141244/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">良い議論</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります。しかし、それはラッシュアワーが最短の解決策を見つけるためのゲームであり、単なる解決策ではないために起こりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[3]ユニットの追加を除く。</font><font style="vertical-align: inherit;">パズルの最初のバージョンにはドットがなく、必要に応じてジェネレーターがユニットを追加する計画でした。</font><font style="vertical-align: inherit;">しかし、それは制限が厳しすぎるように見えました。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja452072/index.html">FlutterにCircularRevealAnimationを実装し、同時にpub.devにライブラリを公開します</a></li>
<li><a href="../ja452074/index.html">Unityの最初のゲームまたは6か月かかったゲーム</a></li>
<li><a href="../ja452078/index.html">Kubernetesの予約：存在します</a></li>
<li><a href="../ja452086/index.html">私のピクセルには何がありますか：プラズモンメタサーフェスを使用したナノピクセルの作成</a></li>
<li><a href="../ja452088/index.html">セマンティックセグメンテーションによる道路認識</a></li>
<li><a href="../ja452092/index.html">アプリ内アップデート：Androidアプリケーションアップデートの高速化</a></li>
<li><a href="../ja452094/index.html">.NET：マルチスレッドと非同期を操作するためのツール。パート1</a></li>
<li><a href="../ja452098/index.html">フロントエンド開発者Habrのログ：リファクタリングと反射</a></li>
<li><a href="../ja452102/index.html">ドローンが好きな人のための写真ゲーム：AirSelfie 2について簡単に</a></li>
<li><a href="../ja452106/index.html">2019年6月16日の夏のDIYミーティングにスピーカーを招待します</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>