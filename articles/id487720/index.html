<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ñ™Ô∏è ‚è±Ô∏è ‚óºÔ∏è Tentang persaingan ketat (menggunakan pemrograman reaktif sebagai contoh) üê® üññüèæ üë®üèΩ‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Perkenalan
 Persaingan untuk pikiran, suasana hati dan aspirasi pemrogram, menurut saya, merupakan tren modern dalam pengembangan pemrograman. Keti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Tentang persaingan ketat (menggunakan pemrograman reaktif sebagai contoh)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487720/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Perkenalan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Persaingan untuk pikiran, suasana hati dan aspirasi pemrogram, menurut saya, merupakan tren modern dalam pengembangan pemrograman. Ketika hampir tidak ada yang diusulkan, meskipun di bawah slogan perjuangan untuk itu. Sangat, sangat sulit untuk dikenali dalam himpitan paradigma perangkat lunak sesuatu yang baru, yang pada kenyataannya sering ternyata cukup terkenal dan, kadang-kadang, hanya ketinggalan jaman. Semuanya ‚Äúhanyut‚Äù oleh kesenangan terminologis, analisis verbose, dan contoh multiline dalam banyak bahasa pemrograman. Pada saat yang sama, permintaan untuk membuka dan / atau mempertimbangkan latar belakang solusi, esensi dari inovasi dihindarkan dengan keras kepala, upaya untuk mengetahui berapa banyak ini dibutuhkan dan apa yang akan memberikan pada akhirnya, yang secara kualitatif membedakan inovasi dari pendekatan yang sudah dikenal dan alat pemrograman, digagalkan pada tahap awal.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya muncul di Habr√©, seperti yang benar-benar diperhatikan dalam salah satu diskusi, setelah pembekuan tertentu. Saya bahkan tidak keberatan. Setidaknya, kesan itu, ternyata, hanya itu. Karena itu, saya setuju, saya akui, meskipun, kalau itu salah saya, itu hanya sebagian. Saya akui, saya hidup dengan ide-ide tentang pemrograman paralel, dibentuk pada tahun 80-an abad terakhir. Jaman dahulu? Mungkin. Tapi katakan padaku apa yang baru, yang tentangnya ilmu pemrograman [paralel] belum akan diketahui saat itu (lihat detail [1]). Pada saat itu, program paralel dibagi menjadi dua kelas - paralel-serial dan asinkron. Jika yang pertama sudah dianggap kuno, maka yang terakhir - maju dan benar-benar paralel. Di antara yang terakhir, pemrograman dengan kontrol acara (atau hanya pemrograman acara), kontrol aliran, dan pemrograman dinamis dipilih.Itu semua secara umum. Rincian lebih lanjut sudah.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan apa yang ditawarkan pemrograman saat ini selain apa yang sudah diketahui setidaknya 40 tahun yang lalu? Dalam "tampilan beku" saya - tidak ada. Coroutine, sekarang ternyata, sekarang disebut coroutine atau bahkan goroutine, istilah konkurensi dan kompetisi masuk ke dalam keadaan pingsan, tampaknya, bukan hanya penerjemah. Dan tidak ada contoh seperti itu. Misalnya, apa perbedaan antara pemrograman reaktif (RP) dan pemrograman acara atau streaming? Manakah dari kategori dan / atau klasifikasi yang dikenal yang termasuk dalam kategori ini? Sepertinya tidak ada yang tertarik pada ini, dan tidak ada yang bisa mengklarifikasi ini. Atau bisakah Anda mengklasifikasikan sekarang berdasarkan nama? Kemudian, memang, coroutine dan coroutine adalah hal yang berbeda, dan pemrograman paralel diharuskan berbeda dari yang kompetitif. Bagaimana dengan mesin negara? Teknik keajaiban macam apa ini?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Spaghetti" di kepala muncul dari pelupaan teori di mana, ketika model baru diperkenalkan, itu dibandingkan dengan model yang sudah dikenal dan dipelajari dengan baik. </font><font style="vertical-align: inherit;">Apakah ini akan dilakukan dengan baik, tetapi setidaknya Anda bisa mengetahuinya, karena prosesnya diformalkan. </font><font style="vertical-align: inherit;">Tetapi bagaimana cara mengatasinya jika Anda memberikan nama panggilan baru pada coroutine dan kemudian memilih "kode kap mesin" secara bersamaan dalam lima bahasa, mengevaluasi juga prospek migrasi ke stream. </font><font style="vertical-align: inherit;">Dan ini hanya coroutine, yang, sejujurnya, harus sudah dilupakan karena sifat dasar mereka dan penggunaannya yang kecil (ini, tentu saja, tentang pengalaman saya).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Pemrograman reaktif dan segalanya, segalanya, segalanya</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami tidak akan menetapkan tujuan memahami konsep "pemrograman reaktif", meskipun kami akan mengambil "contoh reaktif" sebagai dasar untuk diskusi lebih lanjut. </font><font style="vertical-align: inherit;">Model formalnya akan dibuat berdasarkan model formalnya yang terkenal. </font><font style="vertical-align: inherit;">Dan ini, saya harap, akan memungkinkan kita untuk secara jelas, akurat, secara terperinci memahami interpretasi dan pengoperasian program asli. </font><font style="vertical-align: inherit;">Tetapi berapa banyak model yang dibuat dan implementasinya akan "reaktif" tergantung pada para apologis dari jenis pemrograman ini untuk memutuskan. </font><font style="vertical-align: inherit;">Saat ini, sudah cukup untuk sekarang bahwa model baru harus menerapkan / memodelkan semua nuansa contoh asli. </font><font style="vertical-align: inherit;">Jika ada sesuatu yang tidak diperhitungkan, maka saya berharap ada orang yang mengoreksi saya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, dalam [2], contoh program reaktif dipertimbangkan, kode yang ditunjukkan pada Listing 1.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar 1. Kode program reaktif</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">1. 1 = 2 <font></font>
2. 2 = 3 <font></font>
3. 3 = 1 + 2 <font></font>
4.  1, 2, 3 <font></font>
5. 1 = 4 <font></font>
6.  1, 2, 3</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam dunia pemrograman reaktif, hasil kerjanya akan berbeda dari hasil program reguler dengan jenis yang sama. Ini saja buruk, jika tidak dikatakan jelek, karena Hasil program harus jelas dan tidak tergantung pada implementasi. Tapi yang lain lebih membingungkan. Pertama, dalam penampilan hampir tidak mungkin untuk membedakan kode serupa biasa dari yang reaktif. Kedua, tampaknya, penulis sendiri tidak sepenuhnya yakin dengan pekerjaan program reaktif, berbicara tentang hasil "kemungkinan besar". Dan ketiga, hasil manakah yang dianggap benar?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ambiguitas dalam penafsiran kode tersebut telah menyebabkan fakta bahwa tidak mungkin untuk "memotong" kode itu. </font><font style="vertical-align: inherit;">Tetapi kemudian, seperti yang sering terjadi, semuanya ternyata jauh lebih sederhana dari yang diperkirakan. </font><font style="vertical-align: inherit;">Gambar 1 menunjukkan dua diagram struktural yang, semoga, sesuai dengan struktur dan menjelaskan operasi contoh. </font><font style="vertical-align: inherit;">Di diagram atas, blok X1 dan X2 mengatur entri data, memberi sinyal blok X3 tentang perubahannya. </font><font style="vertical-align: inherit;">Yang terakhir melakukan penjumlahan dan memungkinkan blok Pr untuk mencetak nilai saat ini dari variabel. </font><font style="vertical-align: inherit;">Setelah dicetak, blok Pr memberi sinyal ke blok X3, apalagi, kepadanya dan hanya kepadanya bahwa ia siap mencetak nilai baru.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. </font><font style="vertical-align: inherit;">1. Dua model struktural dari contoh</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/tw/hs/rq/twhsrqxfdfuyxi4txtd9ciat6hs.jpeg" alt="image"><br>
</div></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skema kedua, dibandingkan dengan yang pertama, cukup mendasar. Sebagai bagian dari satu blok, ia memasukkan data dan mengimplementasikan secara berurutan: 1) menghitung jumlah data input dan 2) mencetaknya. Pengisian internal blok pada tingkat presentasi ini tidak diungkapkan. Meskipun dapat dikatakan bahwa pada tingkat struktural itu bisa menjadi "kotak hitam termasuk skema empat blok. Tapi tetap saja, perangkat [algoritmik] -nya seharusnya berbeda. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komentar. Pendekatan terhadap program sebagai kotak hitam pada dasarnya mencerminkan sikap pengguna terhadapnya. Yang terakhir ini tidak tertarik pada implementasinya, tetapi pada hasil pekerjaan. Apakah itu program reaktif, program acara, atau yang lainnya, tetapi hasilnya sesuai dengan teori algoritma harus jelas dan dapat diprediksi.</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam gbr. </font><font style="vertical-align: inherit;">2 menyajikan model algoritmik yang menjelaskan secara detail struktur internal [algoritmik] dari blok sirkuit. </font><font style="vertical-align: inherit;">Model atas diwakili oleh jaringan automata, di mana masing-masing automata adalah model algoritmik dari blok yang terpisah. </font><font style="vertical-align: inherit;">Sambungan antara automata yang ditunjukkan oleh busur putus-putus sesuai dengan koneksi rangkaian. </font><font style="vertical-align: inherit;">Model otomat tunggal menjelaskan algoritma operasi diagram blok yang terdiri dari satu blok (lihat blok Pr terpisah pada Gambar. 1).</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. </font><font style="vertical-align: inherit;">2. Model algoritma untuk skema struktural</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/rj/4f/ds/rj4fdsx8kekihnbqqebmpji1y9e.jpeg" alt="image"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Automata X1 dan X2 (nama-nama automata dan blok bertepatan dengan nama-nama variabel mereka), mendeteksi perubahan dan, jika otomat X3 siap untuk melakukan operasi penambahan (dalam keadaan "s0"), masuk ke negara "s1", mengingat nilai variabel saat ini. Mesin X3, setelah menerima izin untuk memasuki status "s1", melakukan operasi tambahan dan, jika perlu, menunggu penyelesaian pencetakan variabel. ‚ÄúMesin cetak‚Äú Pr, setelah selesai mencetak, kembali ke status awal ‚Äúp0‚Äù, di mana ia menunggu perintah berikutnya. Perhatikan bahwa statusnya "p1" memulai rantai transisi mundur - robot X3 ke keadaan "s0", dan X1 dan X2 ke keadaan "s0". Setelah itu, analisis data input, kemudian penjumlahan dan pencetakan berikutnya diulang.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dibandingkan dengan jaringan otomat, algoritma otomat Pr terpisah cukup sederhana, tetapi, kami mencatat, ia melakukan pekerjaan yang sama dan bahkan mungkin lebih cepat. </font><font style="vertical-align: inherit;">Predikatnya mengungkapkan perubahan dalam variabel. </font><font style="vertical-align: inherit;">Jika ini terjadi, maka transisi ke status "p1" dilakukan dengan dimulainya tindakan y1 (lihat Gambar. 2), yang merangkum nilai saat ini dari variabel, sambil mengingatnya. </font><font style="vertical-align: inherit;">Kemudian, pada transisi tanpa syarat dari keadaan "p1" ke keadaan "p0", tindakan y2 mencetak variabel. </font><font style="vertical-align: inherit;">Setelah itu, proses kembali ke analisis data input. </font><font style="vertical-align: inherit;">Kode implementasi untuk model terbaru ditunjukkan pada Listing 2.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar 2. Implementasi Protokol</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span>
<span class="hljs-keyword">extern</span> LArc TBL_PlusX3[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FPlusX3</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FPlusX3(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FPlusX3(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_PlusX3, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarY;        		<span class="hljs-comment">// </span>
    CVar *pVarX1;        		<span class="hljs-comment">// </span>
    CVar *pVarX2;        		<span class="hljs-comment">// </span>
    CVar *pVarX3;        		<span class="hljs-comment">// </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//   X1</span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//   X2</span>
    CVar *pVarStrNameX3;		<span class="hljs-comment">//   X3</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };
    <span class="hljs-keyword">double</span> dSaveX1{<span class="hljs-number">0</span>};
    <span class="hljs-keyword">double</span> dSaveX2{<span class="hljs-number">0</span>};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fplusx3.h"</span></span><font></font>
<font></font>
LArc TBL_PlusX3[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x2"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p1"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"--"</span>,  <span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FPlusX3::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"strY"</span>, CLocVar::vtString, <span class="hljs-string">"print of output string"</span>);			<span class="hljs-comment">//  </span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"dX1"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarX2 = CreateLocVar(<span class="hljs-string">"dX2"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarX3 = CreateLocVar(<span class="hljs-string">"dX3"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX3 = CreateLocVar(<span class="hljs-string">"strNameX3"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;<font></font>
    str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    str = pVarStrNameX3-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX3 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPlusX3::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1-&gt;GetDataSrc() != dSaveX1; }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPlusX3::x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX2-&gt;GetDataSrc() != dSaveX2; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FPlusX3::y1</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// X3 = X1 + X2</span>
    <span class="hljs-keyword">double</span> dX1 = pVarX1-&gt;GetDataSrc(); <span class="hljs-keyword">double</span> dX2 = pVarX2-&gt;GetDataSrc();
    <span class="hljs-keyword">double</span> dX3 = dX1 + dX2;<font></font>
    pVarX3-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, dX3);<font></font>
    dSaveX1 = dX1; dSaveX2 = dX2;<font></font>
<span class="hljs-comment">//  1, 2, 3</span><font></font>
    QString strX1; strX1.setNum(dX1); QString strX2; strX2.setNum(dX2);<font></font>
    QString strX3; strX3.setNum(dX3);<font></font>
    QString qstr = <span class="hljs-string">"X1="</span> + strX1 + <span class="hljs-string">", X2="</span> + strX2 + <span class="hljs-string">", X3="</span> + strX3;<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, qstr.toStdString(), <span class="hljs-literal">nullptr</span>);<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jumlah kode jelas jauh lebih besar dari contoh aslinya. Tapi, perhatikan, bukan kode tunggal. Solusi baru menghilangkan semua masalah fungsi, tidak memungkinkan untuk mengalami fantasi dalam penafsiran program. Sebuah contoh yang terlihat kompak dan elegan, tetapi yang dapat Anda katakan ‚Äúkemungkinan besar‚Äù, tidak menyebabkan, katakanlah, emosi positif dan keinginan untuk bekerja dengannya. Perlu juga dicatat bahwa perlu membandingkan sebenarnya dengan aksi otomat y1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sisa kode terkait dengan persyaratan "lingkungan otomatis", yang, saya perhatikan, tidak diucapkan dalam kode sumber. Jadi, metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FCreationOfLinksForVariables</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari </font><font style="vertical-align: inherit;">kelas automaton dasar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LFsaAppl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membuat variabel lokal untuk mesin dan tautan ke mereka ketika di tingkat VKPA simbolik nama lingkungan dari variabel lingkungan lain yang terkait dengannya ditunjukkan. Pertama kali dimulai ketika membuat otomat, dan kemudian dalam kerangka metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FInit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (lihat langkah y12), karena tidak semua tautan diketahui saat membuat objek. Mesin akan berada dalam status "st" sampai semua tautan yang diperlukan yang diperiksa oleh predikat x12 diinisialisasi. Referensi ke variabel, jika diberi namanya, mengembalikan metode GetAddressVar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menghapus kemungkinan pertanyaan, kami sajikan kode jaringan otomat. </font><font style="vertical-align: inherit;">Itu ditunjukkan pada Listing 3 dan termasuk kode untuk tiga kelas otomat. </font><font style="vertical-align: inherit;">Atas dasar itulah banyak objek dibuat yang sesuai dengan diagram struktural jaringan yang ditunjukkan pada Gambar. </font><font style="vertical-align: inherit;">1. Perhatikan bahwa objek X1 dan X2 diturunkan dari kelas umum FSynch.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar 3. Kelas jaringan otomatis</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_Synch[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSynch</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dGetData</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX-&gt;GetDataSrc(); };
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FSynch(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FSynch(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Synch, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarX;			<span class="hljs-comment">// </span>
    CVar *pVarStrNameX;		<span class="hljs-comment">//   </span>
    CVar *pVarStrNameObject;<span class="hljs-comment">//  -</span>
    LFsaAppl *pL {<span class="hljs-literal">nullptr</span>};
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX-&gt;GetDataSrc() != dSaveX; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pL-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pL != <span class="hljs-literal">nullptr</span>; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span> </span>{ dSaveX = pVarX-&gt;GetDataSrc(); }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };
    <span class="hljs-keyword">double</span> dSaveX{<span class="hljs-number">0</span>};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
LArc TBL_Synch[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x2"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FSynch::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX = CreateLocVar(<span class="hljs-string">"x"</span>, CLocVar::vtDouble, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameObject = CreateLocVar(<span class="hljs-string">"strNameObject"</span>, CLocVar::vtString, <span class="hljs-string">"name of function"</span>);                   <span class="hljs-comment">//  </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX) {<font></font>
        str = pVarStrNameX-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    str = pVarStrNameObject-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pL = FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_X1X2X3[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FX1X2X3</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dGetData</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX3-&gt;GetDataSrc(); };
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FX1X2X3(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FX1X2X3(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_X1X2X3, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarX1{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarX2{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarX3{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarStrNameFX1;		<span class="hljs-comment">//  X1</span>
    CVar *pVarStrNameFX2;		<span class="hljs-comment">//  X2</span>
    CVar *pVarStrNameFPr;		<span class="hljs-comment">//  Pr</span>
    CVar *pVarStrNameX3;		<span class="hljs-comment">//   </span>
    FSynch *pLX1 {<span class="hljs-literal">nullptr</span>};<font></font>
    FSynch *pLX2 {<span class="hljs-literal">nullptr</span>};<font></font>
    LFsaAppl *pLPr {<span class="hljs-literal">nullptr</span>};
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX1-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX2-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x3</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLPr-&gt;FGetState() == <span class="hljs-string">"p1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLPr != <span class="hljs-literal">nullptr</span> &amp;&amp; pLX1 &amp;&amp; pLX2 &amp;&amp; pVarX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span> </span>{ pVarX3-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, pLX1-&gt;dGetData() + pLX2-&gt;dGetData()); }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };<font></font>
};<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fx1x2x3.h"</span></span><font></font>
<font></font>
LArc TBL_X1X2X3[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x2"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x3"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FX1X2X3::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX3 = CreateLocVar(<span class="hljs-string">"x"</span>, CLocVar::vtDouble, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameFX1 = CreateLocVar(<span class="hljs-string">"strNameFX1"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameFX2 = CreateLocVar(<span class="hljs-string">"strNameFX2"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameFPr = CreateLocVar(<span class="hljs-string">"strNameFPr"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameX3 = CreateLocVar(<span class="hljs-string">"strNameX3"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str; str = pVarStrNameFX1-&gt;strGetDataSrc();
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX1 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX2 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFPr-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLPr = FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_Print[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FX1X2X3</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FPrint</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FPrint(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FPrint(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Print, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarY;        		<span class="hljs-comment">// </span>
    CVar *pVarStrNameFX1;		<span class="hljs-comment">//    X1</span>
    CVar *pVarStrNameFX2;		<span class="hljs-comment">//    X2</span>
    CVar *pVarStrNameFX3;		<span class="hljs-comment">//    X3</span>
    FSynch *pLX1 {<span class="hljs-literal">nullptr</span>};     <span class="hljs-comment">//    X1</span>
    FSynch *pLX2 {<span class="hljs-literal">nullptr</span>};     <span class="hljs-comment">//    X2</span>
    FX1X2X3 *pLX3 {<span class="hljs-literal">nullptr</span>};    <span class="hljs-comment">//    X3</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX3 != <span class="hljs-literal">nullptr</span> &amp;&amp; pLX1 &amp;&amp; pLX2 &amp;&amp; pLX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };<font></font>
};<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fprint.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fx1x2x3.h"</span></span><font></font>
<font></font>
LArc TBL_Print[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p1"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FPrint::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"strY"</span>, CLocVar::vtString, <span class="hljs-string">"print of output string"</span>);			<span class="hljs-comment">//  </span>
    pVarStrNameFX1 = CreateLocVar(<span class="hljs-string">"strNameFX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameFX2 = CreateLocVar(<span class="hljs-string">"strNameFX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameFX3 = CreateLocVar(<span class="hljs-string">"strNameFX3"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(pr)"</span>);			<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;<font></font>
    str = pVarStrNameFX1-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX1 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX2 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX3-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX3 = (FX1X2X3*)FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPrint::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX3-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FPrint::y1</span><span class="hljs-params">()</span> </span>{<font></font>
    QString strX1; strX1.setNum(pLX1-&gt;dGetData());<font></font>
    QString strX2; strX2.setNum(pLX2-&gt;dGetData());<font></font>
    QString strX3; strX3.setNum(pLX3-&gt;dGetData());<font></font>
    QString qstr = <span class="hljs-string">"X1="</span> + strX1 + <span class="hljs-string">", X2="</span> + strX2 + <span class="hljs-string">", X3="</span> + strX3;<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, qstr.toStdString(), <span class="hljs-literal">nullptr</span>);<font></font>
}<font></font>
</code></pre> <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode ini berbeda dari Listing 1, seperti gambar pesawat terbang dari dokumentasi desainnya. Tapi, saya pikir, kita terutama programmer, dan, tidak ada pelanggaran yang akan diberitahukan kepada mereka, beberapa desainer. "Kode desain" kami harus mudah dipahami dan diinterpretasikan secara jelas sehingga "pesawat" kami tidak jatuh pada penerbangan pertama. Dan jika kemalangan seperti itu terjadi, dan dengan program ini terjadi lebih sering daripada dengan pesawat terbang, maka alasannya dapat ditemukan dengan mudah dan cepat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh karena itu, mempertimbangkan Listing 3, Anda perlu membayangkan bahwa jumlah kelas tidak secara langsung terkait dengan jumlah objek yang sesuai dalam program paralel. Kode tidak mencerminkan hubungan antara objek, tetapi berisi mekanisme yang membuatnya. Jadi, kelas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSynch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berisi pointer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke objek bertipe</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LFsaAppl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nama objek ini ditentukan oleh variabel lokal, yang dalam lingkungan VKPa akan sesuai dengan variabel automaton dengan nama </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strNameObject</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pointer diperlukan untuk menggunakan metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FGetState untuk</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memantau keadaan saat ini dari objek robot tipe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSynch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (lihat kode predikat x2). Pointer yang mirip dengan objek, variabel untuk menentukan nama objek, dan predikat yang diperlukan untuk mengatur hubungan mengandung kelas lain.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang beberapa kata tentang "pembangunan" program paralel di lingkungan VKPA. Itu dibuat selama memuat konfigurasi program. Dalam hal ini, objek pertama dibuat berdasarkan kelas dari pustaka dinamis tematik tipe otomat (setnya ditentukan oleh konfigurasi aplikasi / program). Objek yang dibuat diidentifikasi dengan namanya (sebut saja </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variabel otomatis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Kemudian, nilai yang diperlukan ditulis ke variabel lokal automata. </font><font style="vertical-align: inherit;">Dalam kasus kami, variabel dengan tipe string diatur ke nama variabel objek lain dan / atau nama objek. </font><font style="vertical-align: inherit;">Dengan cara ini, koneksi antara objek program otomat paralel dibangun (lihat Gambar. 1). </font><font style="vertical-align: inherit;">Selanjutnya, mengubah nilai-nilai variabel input (menggunakan dialog kontrol objek individu atau dialog standar / dialog lingkungan untuk menetapkan nilai-nilai untuk variabel lingkungan), kami memperbaiki hasilnya. </font><font style="vertical-align: inherit;">Itu dapat dilihat menggunakan dialog lingkungan standar untuk menampilkan nilai-nilai variabel.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Untuk analisis program paralel</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentang berfungsinya program paralel, kecuali jika paralelnya cukup sederhana, sangat, sangat sulit untuk mengatakan sesuatu yang konkret. Jaringan automata yang dipertimbangkan tidak terkecuali. Selanjutnya, kita akan melihat ini, memahami apa yang bisa diharapkan darinya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otomat yang dihasilkan dan jaringan yang dibangun ditunjukkan pada Gambar. </font><font style="vertical-align: inherit;">3. Dari jaringan pada Gambar. </font><font style="vertical-align: inherit;">2, selain mengganti nama elemen-elemennya - automata, sinyal input dan output, itu dibedakan dengan tidak adanya "mesin cetak" variabel. </font><font style="vertical-align: inherit;">Yang terakhir tidak penting untuk operasi jaringan, dan penggantian nama memungkinkan Anda untuk menggunakan operasi komposisi untuk membangun otomat yang dihasilkan. </font><font style="vertical-align: inherit;">Selain itu, untuk membuat nama yang lebih pendek, pengkodean diperkenalkan ketika, misalnya, status "a0" dari otomat A diwakili oleh simbol "0", dan "a1" dengan simbol "1". </font><font style="vertical-align: inherit;">Begitu pula untuk mesin lain. </font><font style="vertical-align: inherit;">Dalam hal ini, status komponen jaringan, misalnya, "a1b0c1", diberi nama "101". </font><font style="vertical-align: inherit;">Demikian pula, nama-nama dibentuk untuk semua status komponen jaringan, yang jumlahnya ditentukan oleh produk status komponen automata.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. </font><font style="vertical-align: inherit;">3. Otomat jaringan yang dihasilkan</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/a8/oc/9k/a8oc9kfwbbm3apemxhjzpbz5mxw.jpeg" alt="image"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Otomat yang dihasilkan dapat, tentu saja, dihitung dengan cara formal murni, tetapi untuk ini kita memerlukan "kalkulator" yang tepat. Tetapi jika tidak, maka Anda dapat menggunakan algoritma intuitif yang cukup sederhana. Dalam kerangka kerjanya, satu atau beberapa komponen lain dari jaringan direkam dan kemudian, menyortir semua situasi input yang mungkin, status komponen target ditentukan oleh "pegangan". Jadi, setelah memperbaiki keadaan "000" sesuai dengan keadaan saat ini dari komponen automata - "a0", "b0", "c0", transisi untuk konjungsi dari variabel input ^ x1 ^ x2, ^ x1x2, x1 ^ x2, x1x2 ditentukan. Kita masing-masing mendapatkan transisi dalam menyatakan "a0b0c0", "a0b1c0", "a1b0c0", "a1b1c0", yang ditandai "000", "010", "010", "100" dan "110" pada mesin yang dihasilkan. loopyang tidak dimuat dengan tindakan dapat dikecualikan dari grafik.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang kita miliki "di residu kering". Kami mencapai hal utama - kami menerima otomat yang dihasilkan, yang secara akurat menggambarkan operasi jaringan. Kami menemukan bahwa dari delapan kemungkinan status jaringan, satu tidak dapat diakses (terisolasi) - status "001". Ini berarti bahwa operasi penjumlahan dalam keadaan apapun tidak akan dipicu untuk variabel input yang belum mengubah nilai saat ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang mengganggu, meskipun pengujian tidak mengungkapkan kesalahan. Pada grafik automaton yang dihasilkan, transisi yang bertentangan dalam tindakan keluaran ditemukan. Mereka ditandai dengan kombinasi tindakan y1y3 dan y2y3. Tindakan y1 dan y2 dipicu ketika input data berubah, dan kemudian tindakan lain y3 menghitung jumlah variabel secara paralel dengan mereka. Nilai apa yang akan beroperasi pada - lama atau hanya diubah oleh yang baru? Untuk menghilangkan ambiguitas, Anda cukup mengubah tindakan y3 dan y4. Dalam hal ini, kode mereka adalah sebagai berikut: X3 = X1Sav + X2Sav dan cetak (X1Sav, X2Sav, X3).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Begitu. </font><font style="vertical-align: inherit;">Konstruksi otomat yang dihasilkan mengungkapkan masalah yang jelas dalam model paralel yang dibuat. </font><font style="vertical-align: inherit;">Apakah mereka muncul dalam program reaktif adalah pertanyaan. </font><font style="vertical-align: inherit;">Semuanya akan, tampaknya, tergantung pada pendekatan implementasi paralelisme dalam paradigma reaktif. </font><font style="vertical-align: inherit;">Bagaimanapun, ketergantungan seperti itu harus diperhitungkan dan entah bagaimana dihilangkan. </font><font style="vertical-align: inherit;">Dalam kasus jaringan otomatis, lebih mudah meninggalkan versi yang diubah daripada mencoba mengubah jaringan. </font><font style="vertical-align: inherit;">Tidak apa-apa jika data "lama" yang memulai operasi jaringan dicetak pertama, dan kemudian data saat ini dicetak berikutnya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Kesimpulan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap solusi yang dipertimbangkan memiliki pro dan kontra. Yang pertama sangat sederhana, jaringan lebih rumit, dan dibuat berdasarkan satu mesin, ia akan mulai menganalisis data input hanya setelah visualisasi. Karena paralelismenya, jaringan otomatis yang sama akan memulai analisis data input sebelum akhir prosedur pencetakan. Dan jika waktu visualisasi panjang, tetapi ini akan menjadi kasus terhadap operasi penjumlahan, maka jaringan akan lebih cepat dari sudut pandang kontrol input. Itu penilaian berdasarkan estimasi jumlah kode dalam kasus program paralel tidak selalu objektif. Dalam istilah yang lebih sederhana, jaringan itu paralel, solusi satu komponen sebagian besar berurutan (predikat dan tindakannya paralel). Dan kami, pertama-tama, berbicara tentang program paralel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Model jaringan juga merupakan contoh dari solusi yang fleksibel. Pertama, komponen dapat dirancang secara independen satu sama lain. Kedua, komponen apa pun dapat diganti oleh yang lain. Dan ketiga, komponen jaringan apa pun dapat menjadi elemen pustaka proses otomatis dan digunakan dalam solusi jaringan lain. Dan ini hanyalah manfaat paling nyata dari solusi paralel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi kembali ke pemrograman reaktif. Apakah RP menganggap semua pernyataan program pada awalnya paralel? Kita hanya dapat berasumsi bahwa tanpa ini, sulit untuk berbicara tentang paradigma pemrograman "yang berorientasi pada aliran data dan penyebaran perubahan" (lihat definisi pemrograman reaktif dalam [3]). Tapi apa bedanya pemrograman dengan kontrol streaming (untuk lebih jelasnya lihat [1])? Jadi kita kembali ke tempat kita mulai: bagaimana mengklasifikasikan pemrograman reaktif dalam kerangka klasifikasi terkenal? Dan, jika RP adalah sesuatu yang pemrograman khusus, lalu apa bedanya dengan paradigma pemrograman yang dikenal?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nah, tentang teorinya. Tanpa itu, analisis algoritma paralel tidak hanya akan menjadi sulit - tidak mungkin. Proses analisis kadang-kadang mengungkapkan masalah yang, bahkan dengan tampilan yang cermat dan penuh perhatian pada program, seperti, secara kebetulan, pada "dokumen desain", tidak mungkin untuk ditebak. Bagaimanapun, saya mendukung fakta bahwa pesawat, baik dalam arti kiasan maupun dalam arti lain, tidak jatuh. Ini saya dengan fakta bahwa, tentu saja, Anda perlu berjuang untuk kesederhanaan dan keanggunan bentuk, tetapi tanpa kehilangan kualitas. Kami, programmer, tidak hanya ‚Äúmenggambar‚Äù program, tetapi sering mengontrol apa yang tersembunyi di sana, termasuk dengan pesawat terbang!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya, saya hampir lupa. Saya akan mengklasifikasikan pemrograman otomatis (AP) sebagai pemrograman dengan kontrol dinamis. Adapun asynchrony - saya bertaruh. Mengingat bahwa dasar dari model kontrol AP adalah jaringan dalam satu waktu, yaitu jaringan automata sinkron, maka itu sinkron. Tetapi karena lingkungan VKPa juga mengimplementasikan banyak jaringan melalui konsep "dunia otomat," itu sepenuhnya tidak sinkron. Secara umum, saya menentang kerangka klasifikasi yang sangat kaku, tetapi tidak untuk anarki. Dalam hal ini, dalam VKPa, saya berharap kompromi tertentu telah dicapai antara kekakuan pemrograman paralel-serial dan anarkisme asinkron tertentu. Mengingat fakta bahwa pemrograman otomatis juga mencakup kelas program acara (lihat [4]), dan program streaming mudah dimodelkan di dalamnya,pemrograman apa yang masih bisa Anda impikan? Pasti - bagi saya.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">literatur</font></font></b><div class="spoiler_text">1.   /.. , .. , .. , .. ;  . .. . ‚Äì .:   , 1983. ‚Äì 240.<br>
2.      . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/ru/post/486632</a> . . . (  07.02.2020).<br>
3.  . . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">ru.wikipedia.org/wiki/_</a> . . . (  07.02.2020).<br>
4.  ‚Äî  ? [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/ru/post/483610</a> . . . (  07.02.2020).<br>
</div></div></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id487698/index.html">Acara digital di St. Petersburg dari 10 hingga 16 Februari</a></li>
<li><a href="../id487702/index.html">Pilihan artikel tentang pembelajaran mesin: studi kasus, panduan dan penelitian untuk Januari 2020</a></li>
<li><a href="../id487704/index.html">Bagaimana kami membuat laporan dinamis di SSRS 2014</a></li>
<li><a href="../id487706/index.html">Service Discovery dalam sistem terdistribusi menggunakan contoh Konsul. Alexander Sigachev</a></li>
<li><a href="../id487716/index.html">SAST sempurna. Parser</a></li>
<li><a href="../id487724/index.html">BlazingPizza: Aplikasi Blazor dari awal hingga akhir. Bagian 2. Tambahkan komponen</a></li>
<li><a href="../id487728/index.html">@Pythonetc kompilasi, Januari 2020</a></li>
<li><a href="../id487730/index.html">Pemrosesan Bahasa Alami. Hasil 2019 dan tren untuk 2020</a></li>
<li><a href="../id487734/index.html">Mempercepat Inti Kerangka Entitas</a></li>
<li><a href="../id487738/index.html">Animasi skema di SCADA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>