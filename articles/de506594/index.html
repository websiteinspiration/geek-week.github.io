<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚜️ 🎅🏾 🙆🏻 Redis Best Practices, Teil 3 🚨 👩🏼‍🤝‍👨🏻 🅱️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Endgültige Übersetzung der Redis Best Practices- Abschnitte von der offiziellen Website von Redis Labs. Das ungewöhnlichste und interessanteste heute ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Redis Best Practices, Teil 3</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506594/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endgültige Übersetzung der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Best Practices-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abschnitte </font><font style="vertical-align: inherit;">von der offiziellen Website von Redis Labs. </font><font style="vertical-align: inherit;">Das ungewöhnlichste und interessanteste heute unter dem Schnitt!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hr/6y/f5/hr6yf5w1hp0fh-i5vfa0p1pxeuy.png" width="15%"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste Teil ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und der zweite ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel enthält die folgenden Themen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen auf sortierten Mengen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen auf lexikographisch sortierten Mengen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen auf Bitfeldern;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grundlegendes Bandbreitenbegrenzungsmuster;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blütenfilter;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zähler;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitzählmuster;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyperLogLog;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lua-Skripte.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzdaten</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zeitsequenzdaten oder Daten mit einer natürlichen Zeitreihenfolge können in Redis auf verschiedene Arten modelliert werden, abhängig von den Daten selbst und der Art und Weise, wie Sie darauf zugreifen möchten. </font><font style="vertical-align: inherit;">Wir werden uns einige dieser Muster ansehen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen auf sortierten Mengen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen auf lexikographisch sortierten Mengen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen auf Bitfeldern;</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen auf sortierten Mengen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zeitsequenzen auf sortierten Mengen (zsets) sind eine typische Methode zur Modellierung einer Zeitsequenz in Redis. </font><font style="vertical-align: inherit;">Sortierte Mengen bestehen aus eindeutigen Objekten, deren Ergebnisse unter einem Schlüssel gespeichert sind. </font><font style="vertical-align: inherit;">Die Verwendung dieses Datentyps für sortierte Sätze bedeutet, dass sich die Zählung als eine Art Zeitindikator verhält (häufig handelt es sich um einen millisekundengenauen Zeitstempel) und das Element Daten aufzeichnet. </font><font style="vertical-align: inherit;">Der einzige Vorteil besteht darin, dass nur eindeutige Elemente zulässig sind, da dies eine Form eines Satzes ist. Wenn Sie versuchen, Zeitsequenzen mit denselben Werten aufzuzeichnen, wird nur die Punktzahl aktualisiert. </font><font style="vertical-align: inherit;">Um dieses Problem zu veranschaulichen, nehmen wir das folgende Beispiel für die periodische Aufzeichnung der Temperatur:</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitstempel</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temperatur, C.</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697976001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697977001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697978001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sie einfach mit ZADD zum sortierten Satz hinzufügen, können einige Werte verloren gehen: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ANTI-PATTERN</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD temperature 1586697976001 21<font></font>
(integer) 1<font></font>
&gt; ZADD temperature 1586697977001 22<font></font>
(integer) 1<font></font>
&gt; ZADD temperature 1586697978001 21<font></font>
(integer) 0<font></font>
&gt; ZRANGEBYSCORE temperature -inf +inf WITHSCORES<font></font>
1) "22"<font></font>
2) "1586697977001"<font></font>
3) "21"<font></font>
4) "1586697978001"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass der dritte Aufruf von ZADD 0 zurückgibt, was darauf hinweist, dass das neue Element nicht zum Satz hinzugefügt wurde. Dann sehen wir in ZRANGEBYSCORE, dass es nur zwei Datensätze in der sortierten Menge gibt. Warum? Weil der erste und der dritte das gleiche Objekt teilen und wir gerade das Konto für dieses Objekt aktualisiert haben. Es gibt verschiedene Möglichkeiten, um dieses Problem zu umgehen. Eine davon besteht darin, einige zufällige Daten mit ausreichender Variation aufzunehmen, um so die Eindeutigkeit sicherzustellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie zuerst eine pseudozufällige reelle Zahl von 0 bis einschließlich 1 und fügen Sie sie dann unserem Zeitstempel hinzu. In unserem Beispiel belassen wir es aus Gründen der Lesbarkeit in Dezimalform (in Wirklichkeit wäre es klüger, nur in eine 8-Byte-Zeichenfolge zu konvertieren, um Platz zu sparen).</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD temperature2 1586697976001 21:1586697976001.2583<font></font>
(integer) 1<font></font>
&gt; ZADD temperature2 1586697977001 22:1586697977001.941678<font></font>
(integer) 1<font></font>
&gt; ZADD temperature2 1586697978001 21:1586697978001.732015<font></font>
(integer) 1<font></font>
&gt; ZRANGEBYSCORE temperature2 -inf +inf WITHSCORES<font></font>
1) "21:1586697976001.2583"<font></font>
2) "1511533205001"<font></font>
3) "22:1586697977001.941678"<font></font>
4) "1586697977001"<font></font>
5) "21:1586697978001.732015"<font></font>
6) "1586697978001"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, haben alle ZADDs 1 zurückgegeben, was auf eine erfolgreiche Addition hinweist, und ZRANGEBYSCORE hat alle Werte zurückgegeben. </font><font style="vertical-align: inherit;">Dies ist eine Arbeitsmethode, die jedoch aufgrund der Verschwendung von Bytes nicht sehr effizient ist, um die Eindeutigkeit sicherzustellen, was den Speicheraufwand erhöht. </font><font style="vertical-align: inherit;">In den meisten Fällen wird die Einzigartigkeit einfach von Ihrer Anwendung weggefegt. </font><font style="vertical-align: inherit;">Es ist zu beachten, dass das Hinzufügen von Eindeutigkeit nicht erforderlich ist, wenn Ihre Daten bereits eindeutig sind (z. B. Daten einschließlich UUIDs). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dieser Methode haben Sie Zugriff auf alle Methoden sortierter Mengen zur Analyse und Steuerung:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit ZRANGEBYSCORE können Sie ein bestimmtes Slice zwischen zwei Zeitstempeln abrufen (ZREVRANGEBYSCORE gibt das Slice in absteigender Reihenfolge zurück).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit ZREMRANGEBYSCORE können Sie einen bestimmten Bereich von Zeitstempeln löschen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZCOUNT - die Anzahl der Elemente zwischen dem Zeitstempelbereich;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZINTERSTORE - Ermöglicht es Ihnen, den Schnittpunkt zweier Daten zu ermitteln und unter einem neuen Schlüssel zu speichern.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZUNIONSTORE - Ermöglicht es Ihnen, zwei Daten zusammenzuführen und unter einem neuen Schlüssel zu speichern. </font><font style="vertical-align: inherit;">Sie können dies auch verwenden, um einen sortierten Satz zu duplizieren.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZINTERSTORE- und ZUNIONSTORE-Vorgänge, die mit mehreren Schlüsseln arbeiten. </font><font style="vertical-align: inherit;">Wenn Sie mit einer gemeinsam genutzten Umgebung arbeiten, müssen Sie sorgfältig prüfen, ob sich Ihr neuer Schlüssel im selben Segment befindet. Andernfalls führen diese Befehle zu einem Fehler.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen auf lexikographisch sortierten Mengen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine andere Möglichkeit, mit Zeitsequenzen zu arbeiten, besteht darin, die lexikografischen Eigenschaften sortierter Mengen zum Speichern eines Zeitstempels und eines Werts zu verwenden. Wenn Sie damit noch nicht vertraut sind, lesen Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesen Abschnitt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei dieser Methode speichern wir alles mit der gleichen Anzahl und codieren zuerst den Zeitstempel und fügen dann den Wert als Element hinzu. Nehmen Sie ein Beispiel:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD lex-temperature 0 1589392163001:21<font></font>
(integer) 1<font></font>
&gt; ZADD lex-temperature 0 1589392164001:22<font></font>
(integer) 1<font></font>
&gt; ZADD lex-temperature 0 1589392165001:21<font></font>
(integer) 1<font></font>
&gt; ZRANGE lex-temperature 0 -1<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei diesen drei ZADD-Aufrufen wird der Zeitstempel durch einen Doppelpunkt vom Wert getrennt, und wir können sehen, dass jedes Mal 1 zurückgegeben wird, was bedeutet, dass alle drei hinzugefügt wurden. In ZRANGE sehen wir die gespeicherte Bestellung. Warum? Wenn in sortierten Sätzen die Punktzahl gleich ist, werden die Ergebnisse mit der gleichen Punktzahl nach binärer Sortierung sortiert. Da Zeitstempel in diesem Zeitraum die gleiche Anzahl von Ziffern haben, wird alles korrekt sortiert (wenn Ihre Zeitstempel vor 2002 oder nach 2285 liegen, benötigen Sie mehr Ziffern zum Ausfüllen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie den Befehl ZRANGEBYLEX, um einen Wertebereich von diesem Typ abzurufen:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature (1511533200001 +<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite Argument hat ein Präfix (das die Exklusivität des Wertes angibt (Inklusivität wird mit [bezeichnet). In der Praxis macht dieses Format Inklusivität und Exklusivität irrelevant, da auf den Zeitstempel immer zusätzliche Daten folgen. Das dritte Argument + gibt die Unbegrenztheit der Obergrenze an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen Sie, das Datum zwischen zu ermitteln 1589392160001 und 1589392165001 einschließlich:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature [1589392160001 [1589392165001<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum sind die Zeitstempeldaten 1589392165001 trotz des Inklusivpräfix nicht in das Beispiel aufgenommen worden? </font><font style="vertical-align: inherit;">Ich möchte glauben, dass Redis irgendwie versteht, dass dies ein Zeitstempel ist. </font><font style="vertical-align: inherit;">Tatsächlich sieht Redis nur eine binäre Sortierung. </font><font style="vertical-align: inherit;">Bei der binären Sortierung ist 1589392165001: 21 größer als 1589392165001 einschließlich oder exklusiv. </font><font style="vertical-align: inherit;">Der richtige Weg, dies in die Obergrenze aufzunehmen, besteht darin, 1 Millisekunde zur gewünschten Obergrenze hinzuzufügen und Exklusivität zu verwenden:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature [1589392160001 (1589392165002<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Temporäre Sequenzen mit lexikografisch sortierten Mengen verfügen über ähnliche nützliche Befehle wie temporäre Sequenzen mit einfach sortierten Mengen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZRANGEBYLEX / ZREVRANGEBYLEX - Ruft einen Wertebereich in aufsteigender oder absteigender Reihenfolge ab.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZREMRANGEBYLEX - Entfernt einen bestimmten sortierten Wertebereich.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZLEXCOUNT - Ruft die Anzahl der Elemente in einem sortierten Wertebereich ab.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZINTERSTORE und ZUNIONSTORE können für lexikografisch sortierte Sätze verwendet werden. Es besteht jedoch die Gefahr eines Datenverlusts, da doppelte Kombinationen von Zeitstempeln und Werten im zurückgegebenen Ergebnis nicht dupliziert werden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie fragen sich vielleicht, warum Sie sortierte Sätze mit Zeitstempeln wählen sollten, anstatt lexikografisch sortierte Sätze zu codieren. </font><font style="vertical-align: inherit;">In der Regel ist es besser, mit lexikografisch sortierten Mengen für Zeitsequenzen zu arbeiten. Wenn die Werte nicht immer eindeutig sind, sind Zeitstempel effektiver.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitliche Bitfeldsequenzen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis kann Zeitsequenzen effektiv in Bitfeldern speichern. </font><font style="vertical-align: inherit;">Dazu müssen Sie zunächst einen beliebigen Referenzpunkt und ein numerisches Format auswählen. </font><font style="vertical-align: inherit;">Nehmen Sie das Beispiel der Temperaturmessung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir möchten die Temperatur jede Minute messen und setzen jeden Tag den Startpunkt für Mitternacht. </font><font style="vertical-align: inherit;">Wir messen die Raumtemperatur in Grad Celsius. </font><font style="vertical-align: inherit;">Sie können die Daten wie folgt strukturieren:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 Minute = Byte 0;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Temperatur wird in einer vorzeichenlosen 8-Bit-Zahl (0-255) geschrieben.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für einen Tag werden Daten mit etwa 1,44 kb eingegeben. </font><font style="vertical-align: inherit;">Sie können die Temperatur mit dem Befehl BITFIELD aufzeichnen:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #0 22<font></font>
1) (integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall wird unter Verwendung des Bit-ts-Schlüssels der Temperaturwert 22 um Mitternacht (# 0) in die vorzeichenlose 8-Bit-Nummer (u8) geschrieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitfelder sind nicht auf vorzeichenlose 8-Bit-Werte beschränkt. </font><font style="vertical-align: inherit;">Achten Sie vor dem Versatz auf das Pfundzeichen. </font><font style="vertical-align: inherit;">Dies bedeutet, dass die Ausrichtung für den ausgewählten Typ erfolgt. </font><font style="vertical-align: inherit;">Wenn Sie beispielsweise "# 79" angeben, bedeutet dies das 79. Byte, "79" das 79. Bit (siehe BITFIELD-Hilfe). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Versatz kann durch den Typ der gespeicherten Zahl ab 0 ausgerichtet werden. Wenn wir beispielsweise 1 Uhr morgens unter Berücksichtigung der Nullschlitze schreiben möchten, verwenden wir den Versatz Nr. 59 oder den Versatz Nr. 719 für den Mittag.</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #59 23 SET u8 #719 25<font></font>
1) (integer) 0<font></font>
2) (integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Beispiel zeigt auch, dass BITFIELD variabel ist, d.h. </font><font style="vertical-align: inherit;">Sie können mit mehreren Werten in einem Aufruf arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen Sie einige weitere Werte hinzu:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #60 21 SET u8 #61 20<font></font>
1) (integer) 0<font></font>
2) (integer) 0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt werden wir extrahieren:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts GET u8 #59 GET u8 #60 GET u8 #61<font></font>
1) (integer) 23<font></font>
2) (integer) 21<font></font>
3) (integer) 20</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Signatur des GET-Bit-Unterbefehls ähnelt der SET-Signatur, mit dem einzigen Unterschied, dass kein Wert als drittes Argument akzeptiert wird. </font><font style="vertical-align: inherit;">Es ist normal, wenn wir alle Indizes kennen, die abgerufen werden müssen, aber manchmal benötigen wir einen Wertebereich, und jedes einzelne Byte ist zu stressig. </font><font style="vertical-align: inherit;">Wir können den Befehl GETRANGE verwenden. </font><font style="vertical-align: inherit;">In einer normalen Situation wird es verwendet, um Bytes aus einer Zeichenfolge abzurufen, aber BITFIELDs sind nur eine andere Möglichkeit, dieselben Daten zu adressieren.</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; GETRANGE bit-ts 59 61<font></font>
"\x17\x15\x14"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Befehl gab die Bytes 59 bis 61 hexadezimal (23, 21 und 20 dezimal) zurück. Client-Sprachen verarbeiten Binärdaten besser als redis-cli und können normalerweise ein sprachspezifisches Byte-Array erhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Beispiel haben wir Bytes 0 verwendet , 59-61 und 719. Was passiert, wenn wir noch nicht gesetzte Bytes anfordern?</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts GET u8 #40<font></font>
1) (integer) 0<font></font>
&gt; BITFIELD bit-ts GET u8 #750<font></font>
1) (integer) 0<font></font>
&gt; GETRANGE bit-ts 30 50<font></font>
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis gibt nicht angegebene Bytes als 0 zurück. Dies kann zu Schwierigkeiten beim Arbeiten mit Zeitsequenzdaten führen. Die Anwendungslogik muss zwischen 0 und einem undefinierten Wert unterscheiden. </font><font style="vertical-align: inherit;">Rundungen und Auslassungen von 0-Werten sind möglich, insbesondere wenn vorzeichenbehaftete Ganzzahlen verwendet werden, da dies möglicherweise ein gültiger Wert in der Mitte Ihres Bereichs ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die tatsächliche Länge der Zeitsequenz hängt tatsächlich vom letzten Byte ab. </font><font style="vertical-align: inherit;">In diesem Beispiel ist das zuletzt gespeicherte Byte 719, die Datenlänge also 720 Byte.</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; STRLEN bit-ts<font></font>
(integer) 720</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BITFIELD-basierte Zeitsequenzen sind ein leistungsstarkes und kompaktes Muster zum Speichern von numerischen oder binären Daten. </font><font style="vertical-align: inherit;">Diese Lösung deckt jedoch nicht alle Anwendungsfälle ab, und ihre Verwendung sollte sorgfältig überlegt werden, um Ihren Anforderungen zu entsprechen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundlegendes Bandbreitenbegrenzungsmuster</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erstellen eines Bandbreitenbegrenzers mit Redis ist dank der Befehle INCR und EXPIRE einfach. </font><font style="vertical-align: inherit;">Die Idee ist, dass Sie Anforderungen für einen bestimmten Zeitraum auf einen bestimmten Dienst beschränken möchten. </font><font style="vertical-align: inherit;">Angenommen, wir haben einen Dienst, bei dem Benutzer durch einen API-Schlüssel identifiziert werden. </font><font style="vertical-align: inherit;">Der Service ist auf 20 Anfragen pro Minute begrenzt. </font><font style="vertical-align: inherit;">Um dies zu implementieren, möchten wir jede Minute einen Redis-Schlüssel auf dem API-Schlüssel erstellen. </font><font style="vertical-align: inherit;">Um die Datenbank nicht zu verschmutzen, wird die Gültigkeitsdauer des Schlüssels ebenfalls auf 1 Minute festgelegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
API-Schlüssel - zA21X31, fett - Limit erreicht:</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Key</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 1</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 2</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 3</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 4</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwanzig</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwanzig</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Läuft ab in</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:05</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:06</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:01</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></b></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Schlüssel besteht aus dem API-Schlüssel und der Minutenzahl durch einen Doppelpunkt. </font><font style="vertical-align: inherit;">Da die Schlüssel immer ablaufen, reicht es aus, nur die Minutenzahlen zu verwenden. Mit Beginn der neuen Stunde können wir sicher sein, dass keine weiteren 59 Schlüssel vorhanden sind (sie sind vor 59 Minuten abgelaufen). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie es funktioniert:</font></font><br>
<br>
<ol>
<li><pre><code class="plaintext hljs">&gt; GET [ API]:[ ]</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Ergebnis weniger als 20 beträgt oder nicht festgelegt ist, fahren Sie mit Schritt 4 fort, andernfalls fahren Sie mit Schritt 3 fort.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigen Sie eine Fehlermeldung an, schließen Sie die Verbindung und beenden Sie die Verbindung.</font></font></li>
<li><pre><code class="plaintext hljs">&gt; MULTI<font></font>
OK<font></font>
&gt; INCR [user-api-key]:[current minute number]<font></font>
QUEUED<font></font>
&gt; EXPIRE [user-api-key]:[current minute number] 59<font></font>
QUEUED<font></font>
&gt; EXEC<font></font>
OK</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setzen Sie das Programm fort.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zwei wichtige Punkte:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INCR für einen nicht vorhandenen Schlüssel ist immer 1;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPIRE befindet sich zusammen mit INCR innerhalb der MULTI-Transaktion, was bedeutet, dass es sich um eine atomare Operation handelt.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das schlimmste Szenario ist, wenn der Redis-Server aus einem sehr seltsamen und unwahrscheinlichen Grund zwischen INCR und EXPIRE stirbt. </font><font style="vertical-align: inherit;">Beim Wiederherstellen von Daten aus AOF oder einem In-Memory-Replikat wird INCR nicht wiederhergestellt, da die Transaktion nicht abgeschlossen wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Verwendung dieses Musters ist es möglich, dass ein Benutzer zwei Schlüssel hat: einen, der gerade verwendet wird, und den anderen, der in dieser Minute abläuft. </font><font style="vertical-align: inherit;">Das Muster ist jedoch sehr effektiv.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloom Filter</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Bloom-Filter ist eine interessante probabilistische Datenstruktur, mit der Sie überprüfen können, ob zuvor ein Element hinzugefügt wurde. Hier ist der Wortlaut absichtlich. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Wahrscheinlichkeit ist, dass es nur eine falsch positive Antwort geben kann, aber keine falsch negative. Der Bloom-Filter bietet eine viel kompaktere und schnellere Möglichkeit, die Verfügbarkeit zu überprüfen, als alle Elemente in einem Set zu speichern und SISMEMBER aufzurufen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Bloom-Filter führt ein Element durch die Quick-Hash-Funktion, wählt Bits aus und setzt sie in einem bestimmten Intervall im Bitfeld auf 1 und 0. Um das Vorhandensein eines Filters zu überprüfen, werden dieselben Bits ausgewählt. Viele Elemente haben möglicherweise überlappende Bits. Da die Hash-Funktion jedoch eindeutige Bezeichner erstellt, wissen wir, dass ein Bit aus dem Hash noch 0 hinzugefügt wurde, wenn es noch nicht 0 hinzugefügt wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis verwendet den Filter seit vielen Jahren als Client-Bibliothek, die GETBIT und SETBIT verwendet, um mit Bitfeldern zu arbeiten. Glücklicherweise ist das ReBloom-Modul in Redis 4.0 verfügbar, sodass Sie keine eigene Implementierung des Bloom-Filters erstellen müssen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein guter Anwendungsfall für diesen Filter ist die Überprüfung, ob der Benutzername bereits verwendet wurde. </font><font style="vertical-align: inherit;">Es gibt keine Probleme mit kleinen Datengrößen, aber wenn der Service wächst, können Datenbankabfragen teuer werden. </font><font style="vertical-align: inherit;">Dies lässt sich mit ReBloom leicht beheben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fügen Sie einige Namen für den Test hinzu:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BF.ADD usernames funnyfred<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames fredisfunny<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames fred<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames funfred<font></font>
(integer) 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Testen Sie nun den Bloom-Filter:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BF.EXISTS usernames fred<font></font>
(integer) 1<font></font>
&gt; BF.EXISTS usernames fred_is_funny<font></font>
(integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie erwartet hat </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fred_is_funny</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 zurückgegeben. Dies bedeutet, dass ein solcher Name nicht verwendet wurde. </font><font style="vertical-align: inherit;">Obwohl es unmöglich ist, sicher zu sagen, da sich Bits einfach zwischen mehreren Elementen überlappen können. </font><font style="vertical-align: inherit;">Grundsätzlich ist die Wahrscheinlichkeit von Fehlalarmen gering, aber nicht gleich 0. Wenn sich der Bloom-Filter füllt, steigt die Wahrscheinlichkeit, aber Sie können die Fehlerrate und die Anfangsgröße anpassen (standardmäßig 0,01 bzw. 100).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zähler</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Zähler in Redis kann auf verschiedene Arten implementiert werden. </font><font style="vertical-align: inherit;">Das offensichtlichste ist INCR et al. (INCRBY, INCRBYFLOAT, HINCRBY, HINCRBYFLOAT, ZINCRBY), das durch einfaches Lesen der Dokumentation gefunden werden kann. </font><font style="vertical-align: inherit;">Weniger offensichtlich ist die Verwendung von BITCOUNT und PFADD.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitzählmuster</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BITCOUNT zählt die Anzahl der Bits, die im Bitfeld per Schlüssel auf 1 gesetzt sind. </font><font style="vertical-align: inherit;">Dies kann verwendet werden, um eine Reihe von Aktivitäten über einen beliebigen Zeitraum zu berechnen (ähnlich dem Muster von Zeitsequenzen auf Bitfeldern). </font><font style="vertical-align: inherit;">Der Prozess besteht darin, einen Zeitpunkt auszuwählen, und jedes Bit repräsentiert eine Periodeneinheit. </font><font style="vertical-align: inherit;">Führen Sie SETBIT jedes Mal, wenn während dieser Zeit eine Aktion ausgeführt wird, in einem Abstand von 1 Einheit vom letzten Punkt aus.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:00</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></th>
</tr>
<tr>
<td></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 2 1</code></pre></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 3 1</code></pre></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 4 1</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Startpunkt]</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Handlung</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Handlung</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Handlung</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können Folgendes tun, um zu berechnen, zu welchen Minuten zwischen 12:00 und 12:30 Uhr Aktivitäten stattgefunden haben:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITCOUNT btct 0 30<font></font>
(integer) 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen beantwortet dieses Muster die Frage „Wie oft?“ Anstatt „Wie oft?“. </font><font style="vertical-align: inherit;">Ein Benutzer könnte beispielsweise 20 Mal in einer Minute aktiv sein, dies zählt jedoch als 1. Der </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eigentliche Vorteil dieser Vorlage besteht darin, dass sie für einen bestimmten Zeitraum die minimal mögliche Punktzahl bietet, da Bits die elementarsten Bausteine ​​für die Speicherung sind. </font><font style="vertical-align: inherit;">Dies ist buchstäblich das kleinste (unkomprimierte) Repository zum Zählen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyperLogLog</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Zählen einzigartiger Gegenstände kann schwierig sein. Dies bedeutet normalerweise, dass jedes einzelne Element gespeichert und diese Informationen dann auf irgendeine Weise aufgerufen werden. In Redis kann dies mit vielen und einem Team durchgeführt werden. Sowohl das belegte Volumen als auch die zeitliche Komplexität sind jedoch sehr groß. HyperLogLog bietet eine probabilistische Alternative. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HyperLogLog ähnelt intern einem Bloom-Filter, speist Elemente auch über eine nicht kryptografische Hash-Funktion und setzt Bits in ein Bitfeld. Im Gegensatz zum Bloom-Filter speichert HyperLogLog jedoch einen Elementzähler, der erhöht wird, wenn ein neues Element hinzugefügt wird, das zuvor noch nicht hinzugefügt wurde. Dies ergibt eine niedrige Fehlerrate beim Zählen eindeutiger Elemente in einem Satz. HyperLogLog ist direkt in Redis integriert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Redis gibt es 3 HyperLogLog-Befehle: PFADD, PFCOUNT und PFMERGE. </font><font style="vertical-align: inherit;">Angenommen, wir erstellen einen Webscanner und möchten die Anzahl der eindeutigen URLs der Seiten zählen, die während des Tages angezeigt werden. </font><font style="vertical-align: inherit;">Führen Sie für jede Seite den folgenden Befehl aus:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFADD crawled:20200613 "http://www.google.com/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200613 "http://www.redislabs.com/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200613 "http://www.redis.io/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200614 "http://www.redisearch.io/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200614 "http://www.redis.io/"<font></font>
(integer) 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder der oben genannten Schlüssel wird nach Tag indiziert. </font><font style="vertical-align: inherit;">Um zu sehen, wie viele Seiten am 13.06.2020 angezeigt wurden, können Sie Folgendes tun:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFCOUNT crawled:20200613<font></font>
(integer) 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie den Befehl PFMERGE, um einen neuen Schlüssel mit einem Wert zu erstellen, der zwei Zähler kombiniert, um die Anzahl der Seiten für den 13.06.2020 und den 14.06.2020 anzuzeigen. </font><font style="vertical-align: inherit;">Bitte beachten Sie, dass </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.redis.io</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in beiden Sätzen gespeichert wird und einmal berechnet wird:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFMERGE crawled:20200613-14 crawled:20200613 crawled:20200614<font></font>
OK<font></font>
&gt; PFCOUNT crawled:20200613-14<font></font>
(integer) 4</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Vorgang kann mit mehreren Schlüsseln ausgeführt werden. Seien Sie daher in einer geteilten Umgebung vorsichtig, damit sich die Schlüssel auf demselben Shard befinden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lua-Skripte</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis kann erstaunliche Dinge nur mit „redis-cli“ und noch mehr zwischen Redis und Ihrer Programmiersprache tun. Manchmal kann jedoch ein Verhalten erforderlich sein, das in der Client-Server-Architektur aufgrund von Effizienz- oder Sicherheitsproblemen nicht erzielt werden kann. Die Logik muss in der Datenbankschicht ausgeführt werden. In solchen Fällen kommt Lua zur Rettung. Lua arbeitet in Redis als Skriptsprache. Damit können Sie Code in Redis ausführen, ohne die Kosten für den Transport zum und vom Client.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Testfall fügt einem Hash-Feld einen Wert hinzu. </font><font style="vertical-align: inherit;">Während Redis mit APPEND problemlos einen Wert zu einem Zeichenfolgenschlüssel hinzufügen kann, gibt es keinen Befehl zum Hinzufügen eines Werts zu einem Hash-Feld. </font><font style="vertical-align: inherit;">Sie können versuchen, dies zu erreichen, indem Sie den Wert aus dem Client extrahieren, dem Wert eine neue Zeile hinzufügen und die Hash-Felder löschen. Dies ist jedoch eine schlechte Idee. </font><font style="vertical-align: inherit;">Da dies nicht atomar ist, ist es wahrscheinlich, dass ein anderer Client einen Wert früher hinzufügt, während Sie ihn hinzufügen, und dann den neuen Wert überschreibt.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kunde 1</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Client 2</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HGET myhash myfield</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Hallo kehrt zurück]</font></font></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[fügt "Welt" zu "Hallo" hinzu]</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HSET myhash myfield "goodbye"</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HSET myhash myfield "hello world"</code></pre></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; HGET myhash myfield</code></pre></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie in Zeile 2 sehen können, geht das Update verloren. </font><font style="vertical-align: inherit;">Sie können Lua-Skripte verwenden, um dieses Problem zu umgehen und die Kosten für das Senden / Empfangen von Werten vom Client zu entfernen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie in einem beliebigen Texteditor ein Skript und nennen Sie es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passiert.lua</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="lua hljs"><span class="hljs-keyword">local</span> original = redis.call(<span class="hljs-string">'HGET'</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>])
<span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">'HSET'</span>,KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>], original .. ARGV[<span class="hljs-number">2</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie in der ersten Zeile eine lokale Variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">original</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in der wir den aktuellen Wert des Hash-Schlüssels aus dem ersten übergebenen Argument speichern und das Feld das erste Nicht-Schlüssel-Argument ist. Es ist wichtig zu verstehen, dass Lua-Laufzeitskripte zwischen Schlüsseln und Nicht-Schlüsselargumenten unterscheiden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der zweiten Zeile wird HSET für denselben Schlüssel und dasselbe Feld aufgerufen. Anschließend kombinieren wir den ursprünglichen Wert mit dem zweiten Argument ohne Schlüssel. Dies kehrt zu Redis zurück, sodass wir den ursprünglichen HSET-Rückgabewert beibehalten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die direkte Ausführung von Lua-Skripten mit dem Befehl EVAL kann verwirrend und ineffizient sein. </font><font style="vertical-align: inherit;">Redis verfügt über einen integrierten Skript-Cache, mit dem Sie das Skript vorab laden und dann mit dem SHA1-Hash aus dem Hauptskript darauf zugreifen können. </font><font style="vertical-align: inherit;">Sie können dieses Skript über die Befehlszeile mit "cat" und "redis-cli" herunterladen. </font><font style="vertical-align: inherit;">Bitte beachten Sie, dass Ihr Skript, wenn es sich um mindestens ein Zeichen unterscheidet, einen völlig anderen Hash hat.</font></font><br>
<br>
<pre><code class="bash hljs">$ redis-cli -a yourRedisPassword SCRIPT LOAD <span class="hljs-string">"<span class="hljs-subst">$(cat ./happend.lua)</span>"</span>
<span class="hljs-string">"d30c7f6d0c23fcfe6d4630b11f4e3db4cb2db099"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt können Sie EVALSHA verwenden, um das Skript aufzurufen und Folgendes hinzuzufügen:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; HSET mynewhash greeting "Hello"<font></font>
(integer) 1<font></font>
&gt; EVALSHA d30c7f6d0c23fcfe6d4630b11f4e3db4cb2db099 1 mynewhash greeting " world"<font></font>
(integer) 0<font></font>
&gt; HGET mynewhash greeting<font></font>
"Hello world"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste Argument für den Befehl EVALSHA ist der Hash des von SCRIPT LOAD generierten Skripts. Das zweite Argument ist die Anzahl der Schlüssel. In unserem Fall ist der Schlüssel einer. Das dritte Argument ist der Schlüssel, an dem wir die Aktion ausführen. Und schließlich ist der vierte der Wert, den wir dem Feld hinzufügen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da das Hinzufügen innerhalb des Lua-Skripts erfolgt, wird das obige Skript abgebrochen, da die Lua-Skripte synchron und atomar ausgeführt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl Lua bei der Lösung von Problemen sehr hilfreich sein kann, müssen Sie es vorsichtig verwenden. Das Skript blockiert den Server und kann zu einer nicht reagierenden Datenbank führen. In Sharding-Situationen versuchen Skripte, alle Vorgänge auf einem einzelnen Server zu speichern, um Kreuzfehler zu vermeiden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier endet der Abschnitt Redis Best Practices. </font><font style="vertical-align: inherit;">Haben Sie keine Angst zu experimentieren, Redis ist sehr reich an Funktionen. </font><font style="vertical-align: inherit;">Hinterlassen Sie Ihre interessanten Anwendungsfälle in den Kommentaren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, dass die beschriebenen Techniken Ihnen helfen, wenn nicht direkt, dann zumindest, indem sie auf den richtigen Weg zur Lösung von Problemen zeigen!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de506574/index.html">Visualisierung einer Liste von Nobelpreisträgerinnen in Form von Kristallen in 3D mit Vue, WebGL, three.js</a></li>
<li><a href="../de506578/index.html">Verwaltetes Lead-Volume</a></li>
<li><a href="../de506586/index.html">Logisches FizzBuzz</a></li>
<li><a href="../de506588/index.html">Was ist ein Algorithmus? (Teil 2)</a></li>
<li><a href="../de506590/index.html">Konferenz DEVOXX UK. Wählen Sie ein Framework: Docker Swarm, Kubernetes oder Mesos. Teil 2</a></li>
<li><a href="../de506598/index.html">Microsoft: Rust является 'лучшим шансом' в отрасли программирования безопасных систем</a></li>
<li><a href="../de506600/index.html">Der Auftrag zur Entwicklung des Standortes im Hinblick auf das Projektmanagement (Theorie + Stichprobe)</a></li>
<li><a href="../de506604/index.html">Parallelität und Effizienz: Python vs FSM</a></li>
<li><a href="../de506606/index.html">PIXI.js Clicker-Erstellung</a></li>
<li><a href="../de506610/index.html">WAL-G: PostgreSQL-Datenbanksicherungen und -wiederherstellung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>