<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öúÔ∏è üéÖüèæ üôÜüèª Redis Best Practices, Teil 3 üö® üë©üèº‚Äçü§ù‚Äçüë®üèª üÖ±Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Endg√ºltige √úbersetzung der Redis Best Practices- Abschnitte von der offiziellen Website von Redis Labs. Das ungew√∂hnlichste und interessanteste heute ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Redis Best Practices, Teil 3</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506594/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endg√ºltige √úbersetzung der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Best Practices-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abschnitte </font><font style="vertical-align: inherit;">von der offiziellen Website von Redis Labs. </font><font style="vertical-align: inherit;">Das ungew√∂hnlichste und interessanteste heute unter dem Schnitt!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hr/6y/f5/hr6yf5w1hp0fh-i5vfa0p1pxeuy.png" width="15%"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der erste Teil ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und der zweite ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel enth√§lt die folgenden Themen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen auf sortierten Mengen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen auf lexikographisch sortierten Mengen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen auf Bitfeldern;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grundlegendes Bandbreitenbegrenzungsmuster;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bl√ºtenfilter;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z√§hler;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitz√§hlmuster;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyperLogLog;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lua-Skripte.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzdaten</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zeitsequenzdaten oder Daten mit einer nat√ºrlichen Zeitreihenfolge k√∂nnen in Redis auf verschiedene Arten modelliert werden, abh√§ngig von den Daten selbst und der Art und Weise, wie Sie darauf zugreifen m√∂chten. </font><font style="vertical-align: inherit;">Wir werden uns einige dieser Muster ansehen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen auf sortierten Mengen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen auf lexikographisch sortierten Mengen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen auf Bitfeldern;</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen auf sortierten Mengen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zeitsequenzen auf sortierten Mengen (zsets) sind eine typische Methode zur Modellierung einer Zeitsequenz in Redis. </font><font style="vertical-align: inherit;">Sortierte Mengen bestehen aus eindeutigen Objekten, deren Ergebnisse unter einem Schl√ºssel gespeichert sind. </font><font style="vertical-align: inherit;">Die Verwendung dieses Datentyps f√ºr sortierte S√§tze bedeutet, dass sich die Z√§hlung als eine Art Zeitindikator verh√§lt (h√§ufig handelt es sich um einen millisekundengenauen Zeitstempel) und das Element Daten aufzeichnet. </font><font style="vertical-align: inherit;">Der einzige Vorteil besteht darin, dass nur eindeutige Elemente zul√§ssig sind, da dies eine Form eines Satzes ist. Wenn Sie versuchen, Zeitsequenzen mit denselben Werten aufzuzeichnen, wird nur die Punktzahl aktualisiert. </font><font style="vertical-align: inherit;">Um dieses Problem zu veranschaulichen, nehmen wir das folgende Beispiel f√ºr die periodische Aufzeichnung der Temperatur:</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitstempel</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temperatur, C.</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697976001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697977001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1586697978001</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sie einfach mit ZADD zum sortierten Satz hinzuf√ºgen, k√∂nnen einige Werte verloren gehen: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ANTI-PATTERN</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD temperature 1586697976001 21<font></font>
(integer) 1<font></font>
&gt; ZADD temperature 1586697977001 22<font></font>
(integer) 1<font></font>
&gt; ZADD temperature 1586697978001 21<font></font>
(integer) 0<font></font>
&gt; ZRANGEBYSCORE temperature -inf +inf WITHSCORES<font></font>
1) "22"<font></font>
2) "1586697977001"<font></font>
3) "21"<font></font>
4) "1586697978001"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass der dritte Aufruf von ZADD 0 zur√ºckgibt, was darauf hinweist, dass das neue Element nicht zum Satz hinzugef√ºgt wurde. Dann sehen wir in ZRANGEBYSCORE, dass es nur zwei Datens√§tze in der sortierten Menge gibt. Warum? Weil der erste und der dritte das gleiche Objekt teilen und wir gerade das Konto f√ºr dieses Objekt aktualisiert haben. Es gibt verschiedene M√∂glichkeiten, um dieses Problem zu umgehen. Eine davon besteht darin, einige zuf√§llige Daten mit ausreichender Variation aufzunehmen, um so die Eindeutigkeit sicherzustellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie zuerst eine pseudozuf√§llige reelle Zahl von 0 bis einschlie√ülich 1 und f√ºgen Sie sie dann unserem Zeitstempel hinzu. In unserem Beispiel belassen wir es aus Gr√ºnden der Lesbarkeit in Dezimalform (in Wirklichkeit w√§re es kl√ºger, nur in eine 8-Byte-Zeichenfolge zu konvertieren, um Platz zu sparen).</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD temperature2 1586697976001 21:1586697976001.2583<font></font>
(integer) 1<font></font>
&gt; ZADD temperature2 1586697977001 22:1586697977001.941678<font></font>
(integer) 1<font></font>
&gt; ZADD temperature2 1586697978001 21:1586697978001.732015<font></font>
(integer) 1<font></font>
&gt; ZRANGEBYSCORE temperature2 -inf +inf WITHSCORES<font></font>
1) "21:1586697976001.2583"<font></font>
2) "1511533205001"<font></font>
3) "22:1586697977001.941678"<font></font>
4) "1586697977001"<font></font>
5) "21:1586697978001.732015"<font></font>
6) "1586697978001"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, haben alle ZADDs 1 zur√ºckgegeben, was auf eine erfolgreiche Addition hinweist, und ZRANGEBYSCORE hat alle Werte zur√ºckgegeben. </font><font style="vertical-align: inherit;">Dies ist eine Arbeitsmethode, die jedoch aufgrund der Verschwendung von Bytes nicht sehr effizient ist, um die Eindeutigkeit sicherzustellen, was den Speicheraufwand erh√∂ht. </font><font style="vertical-align: inherit;">In den meisten F√§llen wird die Einzigartigkeit einfach von Ihrer Anwendung weggefegt. </font><font style="vertical-align: inherit;">Es ist zu beachten, dass das Hinzuf√ºgen von Eindeutigkeit nicht erforderlich ist, wenn Ihre Daten bereits eindeutig sind (z. B. Daten einschlie√ülich UUIDs). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dieser Methode haben Sie Zugriff auf alle Methoden sortierter Mengen zur Analyse und Steuerung:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit ZRANGEBYSCORE k√∂nnen Sie ein bestimmtes Slice zwischen zwei Zeitstempeln abrufen (ZREVRANGEBYSCORE gibt das Slice in absteigender Reihenfolge zur√ºck).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit ZREMRANGEBYSCORE k√∂nnen Sie einen bestimmten Bereich von Zeitstempeln l√∂schen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZCOUNT - die Anzahl der Elemente zwischen dem Zeitstempelbereich;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZINTERSTORE - Erm√∂glicht es Ihnen, den Schnittpunkt zweier Daten zu ermitteln und unter einem neuen Schl√ºssel zu speichern.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZUNIONSTORE - Erm√∂glicht es Ihnen, zwei Daten zusammenzuf√ºhren und unter einem neuen Schl√ºssel zu speichern. </font><font style="vertical-align: inherit;">Sie k√∂nnen dies auch verwenden, um einen sortierten Satz zu duplizieren.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZINTERSTORE- und ZUNIONSTORE-Vorg√§nge, die mit mehreren Schl√ºsseln arbeiten. </font><font style="vertical-align: inherit;">Wenn Sie mit einer gemeinsam genutzten Umgebung arbeiten, m√ºssen Sie sorgf√§ltig pr√ºfen, ob sich Ihr neuer Schl√ºssel im selben Segment befindet. Andernfalls f√ºhren diese Befehle zu einem Fehler.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitsequenzen auf lexikographisch sortierten Mengen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine andere M√∂glichkeit, mit Zeitsequenzen zu arbeiten, besteht darin, die lexikografischen Eigenschaften sortierter Mengen zum Speichern eines Zeitstempels und eines Werts zu verwenden. Wenn Sie damit noch nicht vertraut sind, lesen Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesen Abschnitt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei dieser Methode speichern wir alles mit der gleichen Anzahl und codieren zuerst den Zeitstempel und f√ºgen dann den Wert als Element hinzu. Nehmen Sie ein Beispiel:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZADD lex-temperature 0 1589392163001:21<font></font>
(integer) 1<font></font>
&gt; ZADD lex-temperature 0 1589392164001:22<font></font>
(integer) 1<font></font>
&gt; ZADD lex-temperature 0 1589392165001:21<font></font>
(integer) 1<font></font>
&gt; ZRANGE lex-temperature 0 -1<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei diesen drei ZADD-Aufrufen wird der Zeitstempel durch einen Doppelpunkt vom Wert getrennt, und wir k√∂nnen sehen, dass jedes Mal 1 zur√ºckgegeben wird, was bedeutet, dass alle drei hinzugef√ºgt wurden. In ZRANGE sehen wir die gespeicherte Bestellung. Warum? Wenn in sortierten S√§tzen die Punktzahl gleich ist, werden die Ergebnisse mit der gleichen Punktzahl nach bin√§rer Sortierung sortiert. Da Zeitstempel in diesem Zeitraum die gleiche Anzahl von Ziffern haben, wird alles korrekt sortiert (wenn Ihre Zeitstempel vor 2002 oder nach 2285 liegen, ben√∂tigen Sie mehr Ziffern zum Ausf√ºllen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie den Befehl ZRANGEBYLEX, um einen Wertebereich von diesem Typ abzurufen:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature (1511533200001 +<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite Argument hat ein Pr√§fix (das die Exklusivit√§t des Wertes angibt (Inklusivit√§t wird mit [bezeichnet). In der Praxis macht dieses Format Inklusivit√§t und Exklusivit√§t irrelevant, da auf den Zeitstempel immer zus√§tzliche Daten folgen. Das dritte Argument + gibt die Unbegrenztheit der Obergrenze an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen Sie, das Datum zwischen zu ermitteln 1589392160001 und 1589392165001 einschlie√ülich:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature [1589392160001 [1589392165001<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum sind die Zeitstempeldaten 1589392165001 trotz des Inklusivpr√§fix nicht in das Beispiel aufgenommen worden? </font><font style="vertical-align: inherit;">Ich m√∂chte glauben, dass Redis irgendwie versteht, dass dies ein Zeitstempel ist. </font><font style="vertical-align: inherit;">Tats√§chlich sieht Redis nur eine bin√§re Sortierung. </font><font style="vertical-align: inherit;">Bei der bin√§ren Sortierung ist 1589392165001: 21 gr√∂√üer als 1589392165001 einschlie√ülich oder exklusiv. </font><font style="vertical-align: inherit;">Der richtige Weg, dies in die Obergrenze aufzunehmen, besteht darin, 1 Millisekunde zur gew√ºnschten Obergrenze hinzuzuf√ºgen und Exklusivit√§t zu verwenden:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; ZRANGEBYLEX lex-temperature [1589392160001 (1589392165002<font></font>
1) "1589392163001:21"<font></font>
2) "1589392164001:22"<font></font>
3) "1589392165001:21"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tempor√§re Sequenzen mit lexikografisch sortierten Mengen verf√ºgen √ºber √§hnliche n√ºtzliche Befehle wie tempor√§re Sequenzen mit einfach sortierten Mengen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZRANGEBYLEX / ZREVRANGEBYLEX - Ruft einen Wertebereich in aufsteigender oder absteigender Reihenfolge ab.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZREMRANGEBYLEX - Entfernt einen bestimmten sortierten Wertebereich.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZLEXCOUNT - Ruft die Anzahl der Elemente in einem sortierten Wertebereich ab.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZINTERSTORE und ZUNIONSTORE k√∂nnen f√ºr lexikografisch sortierte S√§tze verwendet werden. Es besteht jedoch die Gefahr eines Datenverlusts, da doppelte Kombinationen von Zeitstempeln und Werten im zur√ºckgegebenen Ergebnis nicht dupliziert werden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie fragen sich vielleicht, warum Sie sortierte S√§tze mit Zeitstempeln w√§hlen sollten, anstatt lexikografisch sortierte S√§tze zu codieren. </font><font style="vertical-align: inherit;">In der Regel ist es besser, mit lexikografisch sortierten Mengen f√ºr Zeitsequenzen zu arbeiten. Wenn die Werte nicht immer eindeutig sind, sind Zeitstempel effektiver.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitliche Bitfeldsequenzen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis kann Zeitsequenzen effektiv in Bitfeldern speichern. </font><font style="vertical-align: inherit;">Dazu m√ºssen Sie zun√§chst einen beliebigen Referenzpunkt und ein numerisches Format ausw√§hlen. </font><font style="vertical-align: inherit;">Nehmen Sie das Beispiel der Temperaturmessung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir m√∂chten die Temperatur jede Minute messen und setzen jeden Tag den Startpunkt f√ºr Mitternacht. </font><font style="vertical-align: inherit;">Wir messen die Raumtemperatur in Grad Celsius. </font><font style="vertical-align: inherit;">Sie k√∂nnen die Daten wie folgt strukturieren:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 Minute = Byte 0;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Temperatur wird in einer vorzeichenlosen 8-Bit-Zahl (0-255) geschrieben.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr einen Tag werden Daten mit etwa 1,44 kb eingegeben. </font><font style="vertical-align: inherit;">Sie k√∂nnen die Temperatur mit dem Befehl BITFIELD aufzeichnen:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #0 22<font></font>
1) (integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall wird unter Verwendung des Bit-ts-Schl√ºssels der Temperaturwert 22 um Mitternacht (# 0) in die vorzeichenlose 8-Bit-Nummer (u8) geschrieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitfelder sind nicht auf vorzeichenlose 8-Bit-Werte beschr√§nkt. </font><font style="vertical-align: inherit;">Achten Sie vor dem Versatz auf das Pfundzeichen. </font><font style="vertical-align: inherit;">Dies bedeutet, dass die Ausrichtung f√ºr den ausgew√§hlten Typ erfolgt. </font><font style="vertical-align: inherit;">Wenn Sie beispielsweise "# 79" angeben, bedeutet dies das 79. Byte, "79" das 79. Bit (siehe BITFIELD-Hilfe). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Versatz kann durch den Typ der gespeicherten Zahl ab 0 ausgerichtet werden. Wenn wir beispielsweise 1 Uhr morgens unter Ber√ºcksichtigung der Nullschlitze schreiben m√∂chten, verwenden wir den Versatz Nr. 59 oder den Versatz Nr. 719 f√ºr den Mittag.</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #59 23 SET u8 #719 25<font></font>
1) (integer) 0<font></font>
2) (integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Beispiel zeigt auch, dass BITFIELD variabel ist, d.h. </font><font style="vertical-align: inherit;">Sie k√∂nnen mit mehreren Werten in einem Aufruf arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºgen Sie einige weitere Werte hinzu:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts SET u8 #60 21 SET u8 #61 20<font></font>
1) (integer) 0<font></font>
2) (integer) 0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt werden wir extrahieren:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts GET u8 #59 GET u8 #60 GET u8 #61<font></font>
1) (integer) 23<font></font>
2) (integer) 21<font></font>
3) (integer) 20</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Signatur des GET-Bit-Unterbefehls √§hnelt der SET-Signatur, mit dem einzigen Unterschied, dass kein Wert als drittes Argument akzeptiert wird. </font><font style="vertical-align: inherit;">Es ist normal, wenn wir alle Indizes kennen, die abgerufen werden m√ºssen, aber manchmal ben√∂tigen wir einen Wertebereich, und jedes einzelne Byte ist zu stressig. </font><font style="vertical-align: inherit;">Wir k√∂nnen den Befehl GETRANGE verwenden. </font><font style="vertical-align: inherit;">In einer normalen Situation wird es verwendet, um Bytes aus einer Zeichenfolge abzurufen, aber BITFIELDs sind nur eine andere M√∂glichkeit, dieselben Daten zu adressieren.</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; GETRANGE bit-ts 59 61<font></font>
"\x17\x15\x14"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Befehl gab die Bytes 59 bis 61 hexadezimal (23, 21 und 20 dezimal) zur√ºck. Client-Sprachen verarbeiten Bin√§rdaten besser als redis-cli und k√∂nnen normalerweise ein sprachspezifisches Byte-Array erhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Beispiel haben wir Bytes 0 verwendet , 59-61 und 719. Was passiert, wenn wir noch nicht gesetzte Bytes anfordern?</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITFIELD bit-ts GET u8 #40<font></font>
1) (integer) 0<font></font>
&gt; BITFIELD bit-ts GET u8 #750<font></font>
1) (integer) 0<font></font>
&gt; GETRANGE bit-ts 30 50<font></font>
"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis gibt nicht angegebene Bytes als 0 zur√ºck. Dies kann zu Schwierigkeiten beim Arbeiten mit Zeitsequenzdaten f√ºhren. Die Anwendungslogik muss zwischen 0 und einem undefinierten Wert unterscheiden. </font><font style="vertical-align: inherit;">Rundungen und Auslassungen von 0-Werten sind m√∂glich, insbesondere wenn vorzeichenbehaftete Ganzzahlen verwendet werden, da dies m√∂glicherweise ein g√ºltiger Wert in der Mitte Ihres Bereichs ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die tats√§chliche L√§nge der Zeitsequenz h√§ngt tats√§chlich vom letzten Byte ab. </font><font style="vertical-align: inherit;">In diesem Beispiel ist das zuletzt gespeicherte Byte 719, die Datenl√§nge also 720 Byte.</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; STRLEN bit-ts<font></font>
(integer) 720</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BITFIELD-basierte Zeitsequenzen sind ein leistungsstarkes und kompaktes Muster zum Speichern von numerischen oder bin√§ren Daten. </font><font style="vertical-align: inherit;">Diese L√∂sung deckt jedoch nicht alle Anwendungsf√§lle ab, und ihre Verwendung sollte sorgf√§ltig √ºberlegt werden, um Ihren Anforderungen zu entsprechen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundlegendes Bandbreitenbegrenzungsmuster</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erstellen eines Bandbreitenbegrenzers mit Redis ist dank der Befehle INCR und EXPIRE einfach. </font><font style="vertical-align: inherit;">Die Idee ist, dass Sie Anforderungen f√ºr einen bestimmten Zeitraum auf einen bestimmten Dienst beschr√§nken m√∂chten. </font><font style="vertical-align: inherit;">Angenommen, wir haben einen Dienst, bei dem Benutzer durch einen API-Schl√ºssel identifiziert werden. </font><font style="vertical-align: inherit;">Der Service ist auf 20 Anfragen pro Minute begrenzt. </font><font style="vertical-align: inherit;">Um dies zu implementieren, m√∂chten wir jede Minute einen Redis-Schl√ºssel auf dem API-Schl√ºssel erstellen. </font><font style="vertical-align: inherit;">Um die Datenbank nicht zu verschmutzen, wird die G√ºltigkeitsdauer des Schl√ºssels ebenfalls auf 1 Minute festgelegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
API-Schl√ºssel - zA21X31, fett - Limit erreicht:</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Key</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 1</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 2</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 3</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zA21X31: 4</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwanzig</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwanzig</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√§uft ab in</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:05</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:06</font></font></b></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:01</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></td>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></b></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Schl√ºssel besteht aus dem API-Schl√ºssel und der Minutenzahl durch einen Doppelpunkt. </font><font style="vertical-align: inherit;">Da die Schl√ºssel immer ablaufen, reicht es aus, nur die Minutenzahlen zu verwenden. Mit Beginn der neuen Stunde k√∂nnen wir sicher sein, dass keine weiteren 59 Schl√ºssel vorhanden sind (sie sind vor 59 Minuten abgelaufen). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie es funktioniert:</font></font><br>
<br>
<ol>
<li><pre><code class="plaintext hljs">&gt; GET [ API]:[ ]</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Ergebnis weniger als 20 betr√§gt oder nicht festgelegt ist, fahren Sie mit Schritt 4 fort, andernfalls fahren Sie mit Schritt 3 fort.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigen Sie eine Fehlermeldung an, schlie√üen Sie die Verbindung und beenden Sie die Verbindung.</font></font></li>
<li><pre><code class="plaintext hljs">&gt; MULTI<font></font>
OK<font></font>
&gt; INCR [user-api-key]:[current minute number]<font></font>
QUEUED<font></font>
&gt; EXPIRE [user-api-key]:[current minute number] 59<font></font>
QUEUED<font></font>
&gt; EXEC<font></font>
OK</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setzen Sie das Programm fort.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zwei wichtige Punkte:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INCR f√ºr einen nicht vorhandenen Schl√ºssel ist immer 1;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPIRE befindet sich zusammen mit INCR innerhalb der MULTI-Transaktion, was bedeutet, dass es sich um eine atomare Operation handelt.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das schlimmste Szenario ist, wenn der Redis-Server aus einem sehr seltsamen und unwahrscheinlichen Grund zwischen INCR und EXPIRE stirbt. </font><font style="vertical-align: inherit;">Beim Wiederherstellen von Daten aus AOF oder einem In-Memory-Replikat wird INCR nicht wiederhergestellt, da die Transaktion nicht abgeschlossen wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Verwendung dieses Musters ist es m√∂glich, dass ein Benutzer zwei Schl√ºssel hat: einen, der gerade verwendet wird, und den anderen, der in dieser Minute abl√§uft. </font><font style="vertical-align: inherit;">Das Muster ist jedoch sehr effektiv.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloom Filter</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Bloom-Filter ist eine interessante probabilistische Datenstruktur, mit der Sie √ºberpr√ºfen k√∂nnen, ob zuvor ein Element hinzugef√ºgt wurde. Hier ist der Wortlaut absichtlich. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Wahrscheinlichkeit ist, dass es nur eine falsch positive Antwort geben kann, aber keine falsch negative. Der Bloom-Filter bietet eine viel kompaktere und schnellere M√∂glichkeit, die Verf√ºgbarkeit zu √ºberpr√ºfen, als alle Elemente in einem Set zu speichern und SISMEMBER aufzurufen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Bloom-Filter f√ºhrt ein Element durch die Quick-Hash-Funktion, w√§hlt Bits aus und setzt sie in einem bestimmten Intervall im Bitfeld auf 1 und 0. Um das Vorhandensein eines Filters zu √ºberpr√ºfen, werden dieselben Bits ausgew√§hlt. Viele Elemente haben m√∂glicherweise √ºberlappende Bits. Da die Hash-Funktion jedoch eindeutige Bezeichner erstellt, wissen wir, dass ein Bit aus dem Hash noch 0 hinzugef√ºgt wurde, wenn es noch nicht 0 hinzugef√ºgt wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis verwendet den Filter seit vielen Jahren als Client-Bibliothek, die GETBIT und SETBIT verwendet, um mit Bitfeldern zu arbeiten. Gl√ºcklicherweise ist das ReBloom-Modul in Redis 4.0 verf√ºgbar, sodass Sie keine eigene Implementierung des Bloom-Filters erstellen m√ºssen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein guter Anwendungsfall f√ºr diesen Filter ist die √úberpr√ºfung, ob der Benutzername bereits verwendet wurde. </font><font style="vertical-align: inherit;">Es gibt keine Probleme mit kleinen Datengr√∂√üen, aber wenn der Service w√§chst, k√∂nnen Datenbankabfragen teuer werden. </font><font style="vertical-align: inherit;">Dies l√§sst sich mit ReBloom leicht beheben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºgen Sie einige Namen f√ºr den Test hinzu:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BF.ADD usernames funnyfred<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames fredisfunny<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames fred<font></font>
(integer) 1<font></font>
&gt; BF.ADD usernames funfred<font></font>
(integer) 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Testen Sie nun den Bloom-Filter:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BF.EXISTS usernames fred<font></font>
(integer) 1<font></font>
&gt; BF.EXISTS usernames fred_is_funny<font></font>
(integer) 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie erwartet hat </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fred_is_funny</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 zur√ºckgegeben. Dies bedeutet, dass ein solcher Name nicht verwendet wurde. </font><font style="vertical-align: inherit;">Obwohl es unm√∂glich ist, sicher zu sagen, da sich Bits einfach zwischen mehreren Elementen √ºberlappen k√∂nnen. </font><font style="vertical-align: inherit;">Grunds√§tzlich ist die Wahrscheinlichkeit von Fehlalarmen gering, aber nicht gleich 0. Wenn sich der Bloom-Filter f√ºllt, steigt die Wahrscheinlichkeit, aber Sie k√∂nnen die Fehlerrate und die Anfangsgr√∂√üe anpassen (standardm√§√üig 0,01 bzw. 100).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z√§hler</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Z√§hler in Redis kann auf verschiedene Arten implementiert werden. </font><font style="vertical-align: inherit;">Das offensichtlichste ist INCR et al. (INCRBY, INCRBYFLOAT, HINCRBY, HINCRBYFLOAT, ZINCRBY), das durch einfaches Lesen der Dokumentation gefunden werden kann. </font><font style="vertical-align: inherit;">Weniger offensichtlich ist die Verwendung von BITCOUNT und PFADD.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitz√§hlmuster</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BITCOUNT z√§hlt die Anzahl der Bits, die im Bitfeld per Schl√ºssel auf 1 gesetzt sind. </font><font style="vertical-align: inherit;">Dies kann verwendet werden, um eine Reihe von Aktivit√§ten √ºber einen beliebigen Zeitraum zu berechnen (√§hnlich dem Muster von Zeitsequenzen auf Bitfeldern). </font><font style="vertical-align: inherit;">Der Prozess besteht darin, einen Zeitpunkt auszuw√§hlen, und jedes Bit repr√§sentiert eine Periodeneinheit. </font><font style="vertical-align: inherit;">F√ºhren Sie SETBIT jedes Mal, wenn w√§hrend dieser Zeit eine Aktion ausgef√ºhrt wird, in einem Abstand von 1 Einheit vom letzten Punkt aus.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:00</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:02</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:03</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12:04</font></font></th>
</tr>
<tr>
<td></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 2 1</code></pre></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 3 1</code></pre></td>
<td><pre><code class="plaintext hljs">&gt; SETBIT btct 4 1</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Startpunkt]</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Handlung</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Handlung</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Handlung</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen Folgendes tun, um zu berechnen, zu welchen Minuten zwischen 12:00 und 12:30 Uhr Aktivit√§ten stattgefunden haben:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; BITCOUNT btct 0 30<font></font>
(integer) 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen beantwortet dieses Muster die Frage ‚ÄûWie oft?‚Äú Anstatt ‚ÄûWie oft?‚Äú. </font><font style="vertical-align: inherit;">Ein Benutzer k√∂nnte beispielsweise 20 Mal in einer Minute aktiv sein, dies z√§hlt jedoch als 1. Der </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eigentliche Vorteil dieser Vorlage besteht darin, dass sie f√ºr einen bestimmten Zeitraum die minimal m√∂gliche Punktzahl bietet, da Bits die elementarsten Bausteine ‚Äã‚Äãf√ºr die Speicherung sind. </font><font style="vertical-align: inherit;">Dies ist buchst√§blich das kleinste (unkomprimierte) Repository zum Z√§hlen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyperLogLog</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Z√§hlen einzigartiger Gegenst√§nde kann schwierig sein. Dies bedeutet normalerweise, dass jedes einzelne Element gespeichert und diese Informationen dann auf irgendeine Weise aufgerufen werden. In Redis kann dies mit vielen und einem Team durchgef√ºhrt werden. Sowohl das belegte Volumen als auch die zeitliche Komplexit√§t sind jedoch sehr gro√ü. HyperLogLog bietet eine probabilistische Alternative. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HyperLogLog √§hnelt intern einem Bloom-Filter, speist Elemente auch √ºber eine nicht kryptografische Hash-Funktion und setzt Bits in ein Bitfeld. Im Gegensatz zum Bloom-Filter speichert HyperLogLog jedoch einen Elementz√§hler, der erh√∂ht wird, wenn ein neues Element hinzugef√ºgt wird, das zuvor noch nicht hinzugef√ºgt wurde. Dies ergibt eine niedrige Fehlerrate beim Z√§hlen eindeutiger Elemente in einem Satz. HyperLogLog ist direkt in Redis integriert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Redis gibt es 3 HyperLogLog-Befehle: PFADD, PFCOUNT und PFMERGE. </font><font style="vertical-align: inherit;">Angenommen, wir erstellen einen Webscanner und m√∂chten die Anzahl der eindeutigen URLs der Seiten z√§hlen, die w√§hrend des Tages angezeigt werden. </font><font style="vertical-align: inherit;">F√ºhren Sie f√ºr jede Seite den folgenden Befehl aus:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFADD crawled:20200613 "http://www.google.com/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200613 "http://www.redislabs.com/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200613 "http://www.redis.io/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200614 "http://www.redisearch.io/"<font></font>
(integer) 1<font></font>
&gt; PFADD crawled:20200614 "http://www.redis.io/"<font></font>
(integer) 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder der oben genannten Schl√ºssel wird nach Tag indiziert. </font><font style="vertical-align: inherit;">Um zu sehen, wie viele Seiten am 13.06.2020 angezeigt wurden, k√∂nnen Sie Folgendes tun:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFCOUNT crawled:20200613<font></font>
(integer) 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie den Befehl PFMERGE, um einen neuen Schl√ºssel mit einem Wert zu erstellen, der zwei Z√§hler kombiniert, um die Anzahl der Seiten f√ºr den 13.06.2020 und den 14.06.2020 anzuzeigen. </font><font style="vertical-align: inherit;">Bitte beachten Sie, dass </font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.redis.io</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in beiden S√§tzen gespeichert wird und einmal berechnet wird:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; PFMERGE crawled:20200613-14 crawled:20200613 crawled:20200614<font></font>
OK<font></font>
&gt; PFCOUNT crawled:20200613-14<font></font>
(integer) 4</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Vorgang kann mit mehreren Schl√ºsseln ausgef√ºhrt werden. Seien Sie daher in einer geteilten Umgebung vorsichtig, damit sich die Schl√ºssel auf demselben Shard befinden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lua-Skripte</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis kann erstaunliche Dinge nur mit ‚Äûredis-cli‚Äú und noch mehr zwischen Redis und Ihrer Programmiersprache tun. Manchmal kann jedoch ein Verhalten erforderlich sein, das in der Client-Server-Architektur aufgrund von Effizienz- oder Sicherheitsproblemen nicht erzielt werden kann. Die Logik muss in der Datenbankschicht ausgef√ºhrt werden. In solchen F√§llen kommt Lua zur Rettung. Lua arbeitet in Redis als Skriptsprache. Damit k√∂nnen Sie Code in Redis ausf√ºhren, ohne die Kosten f√ºr den Transport zum und vom Client.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Testfall f√ºgt einem Hash-Feld einen Wert hinzu. </font><font style="vertical-align: inherit;">W√§hrend Redis mit APPEND problemlos einen Wert zu einem Zeichenfolgenschl√ºssel hinzuf√ºgen kann, gibt es keinen Befehl zum Hinzuf√ºgen eines Werts zu einem Hash-Feld. </font><font style="vertical-align: inherit;">Sie k√∂nnen versuchen, dies zu erreichen, indem Sie den Wert aus dem Client extrahieren, dem Wert eine neue Zeile hinzuf√ºgen und die Hash-Felder l√∂schen. Dies ist jedoch eine schlechte Idee. </font><font style="vertical-align: inherit;">Da dies nicht atomar ist, ist es wahrscheinlich, dass ein anderer Client einen Wert fr√ºher hinzuf√ºgt, w√§hrend Sie ihn hinzuf√ºgen, und dann den neuen Wert √ºberschreibt.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kunde 1</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Client 2</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HGET myhash myfield</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Hallo kehrt zur√ºck]</font></font></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[f√ºgt "Welt" zu "Hallo" hinzu]</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HSET myhash myfield "goodbye"</code></pre></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><pre><code class="plaintext hljs">&gt; HSET myhash myfield "hello world"</code></pre></td>
<td></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td></td>
<td><pre><code class="plaintext hljs">&gt; HGET myhash myfield</code></pre></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie in Zeile 2 sehen k√∂nnen, geht das Update verloren. </font><font style="vertical-align: inherit;">Sie k√∂nnen Lua-Skripte verwenden, um dieses Problem zu umgehen und die Kosten f√ºr das Senden / Empfangen von Werten vom Client zu entfernen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie in einem beliebigen Texteditor ein Skript und nennen Sie es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passiert.lua</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="lua hljs"><span class="hljs-keyword">local</span> original = redis.call(<span class="hljs-string">'HGET'</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">1</span>])
<span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">'HSET'</span>,KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>], original .. ARGV[<span class="hljs-number">2</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen Sie in der ersten Zeile eine lokale Variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">original</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in der wir den aktuellen Wert des Hash-Schl√ºssels aus dem ersten √ºbergebenen Argument speichern und das Feld das erste Nicht-Schl√ºssel-Argument ist. Es ist wichtig zu verstehen, dass Lua-Laufzeitskripte zwischen Schl√ºsseln und Nicht-Schl√ºsselargumenten unterscheiden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der zweiten Zeile wird HSET f√ºr denselben Schl√ºssel und dasselbe Feld aufgerufen. Anschlie√üend kombinieren wir den urspr√ºnglichen Wert mit dem zweiten Argument ohne Schl√ºssel. Dies kehrt zu Redis zur√ºck, sodass wir den urspr√ºnglichen HSET-R√ºckgabewert beibehalten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die direkte Ausf√ºhrung von Lua-Skripten mit dem Befehl EVAL kann verwirrend und ineffizient sein. </font><font style="vertical-align: inherit;">Redis verf√ºgt √ºber einen integrierten Skript-Cache, mit dem Sie das Skript vorab laden und dann mit dem SHA1-Hash aus dem Hauptskript darauf zugreifen k√∂nnen. </font><font style="vertical-align: inherit;">Sie k√∂nnen dieses Skript √ºber die Befehlszeile mit "cat" und "redis-cli" herunterladen. </font><font style="vertical-align: inherit;">Bitte beachten Sie, dass Ihr Skript, wenn es sich um mindestens ein Zeichen unterscheidet, einen v√∂llig anderen Hash hat.</font></font><br>
<br>
<pre><code class="bash hljs">$ redis-cli -a yourRedisPassword SCRIPT LOAD <span class="hljs-string">"<span class="hljs-subst">$(cat ./happend.lua)</span>"</span>
<span class="hljs-string">"d30c7f6d0c23fcfe6d4630b11f4e3db4cb2db099"</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt k√∂nnen Sie EVALSHA verwenden, um das Skript aufzurufen und Folgendes hinzuzuf√ºgen:</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt; HSET mynewhash greeting "Hello"<font></font>
(integer) 1<font></font>
&gt; EVALSHA d30c7f6d0c23fcfe6d4630b11f4e3db4cb2db099 1 mynewhash greeting " world"<font></font>
(integer) 0<font></font>
&gt; HGET mynewhash greeting<font></font>
"Hello world"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste Argument f√ºr den Befehl EVALSHA ist der Hash des von SCRIPT LOAD generierten Skripts. Das zweite Argument ist die Anzahl der Schl√ºssel. In unserem Fall ist der Schl√ºssel einer. Das dritte Argument ist der Schl√ºssel, an dem wir die Aktion ausf√ºhren. Und schlie√ülich ist der vierte der Wert, den wir dem Feld hinzuf√ºgen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da das Hinzuf√ºgen innerhalb des Lua-Skripts erfolgt, wird das obige Skript abgebrochen, da die Lua-Skripte synchron und atomar ausgef√ºhrt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl Lua bei der L√∂sung von Problemen sehr hilfreich sein kann, m√ºssen Sie es vorsichtig verwenden. Das Skript blockiert den Server und kann zu einer nicht reagierenden Datenbank f√ºhren. In Sharding-Situationen versuchen Skripte, alle Vorg√§nge auf einem einzelnen Server zu speichern, um Kreuzfehler zu vermeiden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier endet der Abschnitt Redis Best Practices. </font><font style="vertical-align: inherit;">Haben Sie keine Angst zu experimentieren, Redis ist sehr reich an Funktionen. </font><font style="vertical-align: inherit;">Hinterlassen Sie Ihre interessanten Anwendungsf√§lle in den Kommentaren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, dass die beschriebenen Techniken Ihnen helfen, wenn nicht direkt, dann zumindest, indem sie auf den richtigen Weg zur L√∂sung von Problemen zeigen!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de506574/index.html">Visualisierung einer Liste von Nobelpreistr√§gerinnen in Form von Kristallen in 3D mit Vue, WebGL, three.js</a></li>
<li><a href="../de506578/index.html">Verwaltetes Lead-Volume</a></li>
<li><a href="../de506586/index.html">Logisches FizzBuzz</a></li>
<li><a href="../de506588/index.html">Was ist ein Algorithmus? (Teil 2)</a></li>
<li><a href="../de506590/index.html">Konferenz DEVOXX UK. W√§hlen Sie ein Framework: Docker Swarm, Kubernetes oder Mesos. Teil 2</a></li>
<li><a href="../de506598/index.html">Microsoft: Rust —è–≤–ª—è–µ—Ç—Å—è '–ª—É—á—à–∏–º —à–∞–Ω—Å–æ–º' –≤ –æ—Ç—Ä–∞—Å–ª–∏ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –±–µ–∑–æ–ø–∞—Å–Ω—ã—Ö —Å–∏—Å—Ç–µ–º</a></li>
<li><a href="../de506600/index.html">Der Auftrag zur Entwicklung des Standortes im Hinblick auf das Projektmanagement (Theorie + Stichprobe)</a></li>
<li><a href="../de506604/index.html">Parallelit√§t und Effizienz: Python vs FSM</a></li>
<li><a href="../de506606/index.html">PIXI.js Clicker-Erstellung</a></li>
<li><a href="../de506610/index.html">WAL-G: PostgreSQL-Datenbanksicherungen und -wiederherstellung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>