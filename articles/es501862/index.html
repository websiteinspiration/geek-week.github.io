<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏽 🤫 🉑 Aleteo bajo el capó 📙 🥁 👆🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¡Hola a todos! Mi nombre es Mikhail Zotiev, trabajo como desarrollador de Flutter en Surf. Probablemente, como la mayoría de los otros desarrolladores...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Aleteo bajo el capó</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/501862/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Hola a todos! Mi nombre es Mikhail Zotiev, trabajo como desarrollador de Flutter en Surf. Probablemente, como la mayoría de los otros desarrolladores que trabajan con Flutter, me gusta lo fácil que es crear aplicaciones hermosas y convenientes con su ayuda. Se necesita muy poco tiempo para entrar en el desarrollo de Flutter. Recientemente trabajé en desarrollo de juegos, y ahora he cambiado completamente al desarrollo móvil multiplataforma en Flutter.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cuál es la simplicidad? </font><font style="vertical-align: inherit;">Con una docena de widgets básicos, puede construir interfaces de usuario bastante decentes. </font><font style="vertical-align: inherit;">Y con el tiempo, cuando el equipaje utilizado es bastante decente, es poco probable que alguna tarea lo detenga: ya sea un diseño inusual o una animación sofisticada. </font><font style="vertical-align: inherit;">Y lo más interesante: lo más probable es que pueda usarlo sin siquiera pensar en la pregunta: "¿Cómo funciona?" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como Flutter tiene código abierto, decidí averiguar qué hay debajo del capó (en el lado de Dart de la Fuerza) y compartirlo contigo.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/ln/q6/lglnq6t8sbc8gq-emifhx1dxjwu.png"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos hemos escuchado la frase del equipo de desarrollo de framework más de una vez: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Todo en Flutter son widgets"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Veamos si esto es realmente así. </font><font style="vertical-align: inherit;">Para hacer esto, pasamos a la clase </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (en adelante, el widget) y comenzamos a familiarizarnos gradualmente con los contenidos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo primero que leeremos en la documentación de la clase:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Describe la configuración para un [Elemento].</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resulta que el widget en sí mismo es solo una descripción de algún </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elemento</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (en adelante, el elemento).</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los widgets son la jerarquía de clase central en el marco de Flutter. </font><font style="vertical-align: inherit;">Un widget es una descripción inmutable de parte de una interfaz de usuario. </font><font style="vertical-align: inherit;">Los widgets se pueden inflar en elementos, que administran el árbol de renderizado subyacente.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para resumir, la frase </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Todo en Flutter es un widget"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el nivel mínimo de comprensión de cómo se organiza todo para usar Flutter. </font><font style="vertical-align: inherit;">El widget es la clase central en la jerarquía Flutter. </font><font style="vertical-align: inherit;">Al mismo tiempo, hay muchos mecanismos adicionales a su alrededor que ayudan al marco a hacer frente a su tarea. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, aprendimos algunos hechos más:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">widget: una descripción inmutable de una parte de la interfaz de usuario;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el widget está asociado con alguna vista avanzada llamada elemento; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un elemento controla alguna entidad del árbol de renderizado.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debes haber notado algo extraño. </font><font style="vertical-align: inherit;">La interfaz de usuario y la inmutabilidad encajan muy mal, incluso diría que estos son conceptos completamente incompatibles. </font><font style="vertical-align: inherit;">Pero volveremos a esto cuando surja una imagen más completa del dispositivo del mundo Flutter, pero por ahora seguiremos familiarizándonos con la documentación del widget.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los widgets no tienen un estado mutable (todos sus campos deben ser finales). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si desea asociar el estado mutable con un widget, considere usar un [StatefulWidget], que crea un objeto [State] (a través de [StatefulWidget.createState]) cada vez que se infla en un elemento y se incorpora al árbol.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este párrafo complementa un poco el primer párrafo: si necesitamos una configuración mutable, usamos la entidad de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estado</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> especial </font><font style="vertical-align: inherit;">(en lo sucesivo, el estado), que describe el estado actual de este widget. </font><font style="vertical-align: inherit;">Sin embargo, el estado no está asociado con el widget, sino con su representación elemental.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un widget determinado se puede incluir en el árbol cero o más veces. </font><font style="vertical-align: inherit;">En particular, un widget determinado se puede colocar en el árbol varias veces. </font><font style="vertical-align: inherit;">Cada vez que se coloca un widget en el árbol, se infla en un [Elemento], lo que significa que un widget que se incorpora al árbol varias veces se inflará varias veces.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El mismo widget se puede incluir en el árbol de widgets muchas veces, o no se puede incluir en absoluto. </font><font style="vertical-align: inherit;">Pero cada vez que se incluye un widget en el árbol de widgets, se le asigna un elemento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, en esta etapa, los widgets están casi listos, resumamos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">widget: la clase central de la jerarquía;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">widget es alguna configuración; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">widget: una descripción inmutable de una parte de la interfaz de usuario; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el widget está asociado con un elemento que controla la representación de alguna manera; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alguna entidad puede describir el estado cambiante del widget, pero no está conectado con el widget, sino con el elemento que representa este widget.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elemento</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De lo que aprendimos, la pregunta plantea: "¿Cuáles son estos elementos que rigen todo?" </font><font style="vertical-align: inherit;">Haga lo mismo: abra la documentación para la clase Element.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una instanciación de un [Widget] en una ubicación particular del árbol.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un elemento es alguna representación de un widget en un lugar específico de un árbol.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los widgets describen cómo configurar un subárbol, pero el mismo widget se puede usar para configurar múltiples subárboles simultáneamente porque los widgets son inmutables. </font><font style="vertical-align: inherit;">Un [Elemento] representa el uso de un widget para configurar una ubicación específica en el árbol. </font><font style="vertical-align: inherit;">Con el tiempo, el widget asociado con un elemento dado puede cambiar, por ejemplo, si el widget padre se reconstruye y crea un nuevo widget para esta ubicación.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El widget describe la configuración de alguna parte de la interfaz de usuario, pero como ya sabemos, el mismo widget se puede usar en diferentes lugares del árbol. Cada uno de esos lugares estará representado por un elemento correspondiente. Pero con el tiempo, el widget asociado con el elemento puede cambiar. Esto significa que los elementos son más tenaces y continúan utilizándose, solo actualizando sus conexiones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es una decisión bastante racional. Como ya hemos definido anteriormente, los widgets son una configuración inmutable que simplemente describe una parte específica de la interfaz, lo que significa que deben ser muy livianos. Y los elementos en el área cuyo control es mucho más pesado, pero no se recrean innecesariamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para entender cómo se hace esto, considere el ciclo de vida de un elemento:</font></font><br>
<br>
<ul>
<li>     Widget.createElement    ,     .</li>
<li>   mount        .              .</li>
<li>       .</li>
<li>   ,    (,    ),     .       runtimeType  key,     .   ,     ,           .</li>
<li> ,       ,    ,             ,      (  deactivate).</li>
<li>   ,     .           ,       ,   (unmount),           .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando vuelva a incluir elementos en el árbol, por ejemplo, si el elemento o sus antepasados ​​tienen una clave global, se eliminará de la lista de elementos inactivos, se llamará al método de activación y el objeto renderizado asociado con este elemento volverá a incrustarse en el árbol de representación. </font><font style="vertical-align: inherit;">Esto significa que el elemento debería aparecer nuevamente en la pantalla.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la declaración de clase, vemos que el elemento implementa la interfaz BuildContext. </font><font style="vertical-align: inherit;">Un BuildContext es algo que controla la posición de un widget en un árbol de widgets, como se deduce de su documentación. </font><font style="vertical-align: inherit;">Casi coincide exactamente con la descripción del artículo. </font><font style="vertical-align: inherit;">Esta interfaz se utiliza para evitar la manipulación directa del elemento, pero al mismo tiempo da acceso a los métodos de contexto necesarios. </font><font style="vertical-align: inherit;">Por ejemplo, findRenderObject, que le permite encontrar el objeto del árbol de representación correspondiente a este elemento.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objeto de renderizado</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Queda por tratar con el último enlace de esta tríada: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RenderObject</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Como su nombre lo indica, este es un objeto del árbol de visualización. Tiene un objeto primario, así como un campo de datos que el objeto primario usa para almacenar información específica sobre este objeto, por ejemplo, su posición. Este objeto es responsable de la implementación de los protocolos básicos de representación y diseño.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RenderObject no limita el modelo de uso de objetos secundarios: puede haber ninguno, uno o muchos. </font><font style="vertical-align: inherit;">Además, el sistema de posicionamiento no se limita a: el sistema cartesiano, las coordenadas polares, todo esto y mucho más está disponible para su uso. </font><font style="vertical-align: inherit;">No hay restricciones en el uso de protocolos de ubicación: ajuste del ancho o alto, limitación del tamaño, configuración del tamaño y ubicación del elemento primario o, si es necesario, uso de los datos del objeto principal.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flutter World Picture</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tratemos de construir una imagen general de cómo funciona todo junto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya señalamos anteriormente, el widget es una descripción inmutable, pero la interfaz de usuario no es estática. </font><font style="vertical-align: inherit;">Esta discrepancia se elimina dividiendo en 3 niveles de objetos y la división de zonas de responsabilidad.</font></font><br>
<br>
<ul>
<li> ,          . </li>
<li> ,               . </li>
<li>  ,   — ,     .</li>
</ul><br>
<img src="https://habrastorage.org/webt/j_/n_/og/j_n_ogui1a0iawbuoq5vxclsnne.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos cómo se ven estos árboles con un ejemplo simple: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/u7/0o/wk/u70owkgirs6krcos85rwn-acli8.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
en este caso, tenemos un StatelessWidget envuelto en un widget de Relleno y que contiene texto dentro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pongámonos en lugar de Flutter: nos dieron este árbol de widgets. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Hey, Padding, necesito tu elemento"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Padding: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Por supuesto, mantén SingleChildRenderObjectElement"</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/jj/u7/zn/jju7znfat7skocfex74adc4cu7o.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Element, aquí está tu lugar, establecete"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
SingleChildRenderObjectElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Chicos, todo está bien, pero necesito RenderObject"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Padding, como para dibujarte?</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Relleno: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Hold it, RenderPadding"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
SingleChildRenderObjectElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Genial, ponte a trabajar"</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/zk/ty/se/zktyse7pgo6jdd6x7impyivfhy0.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter:</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Entonces, ¿quién es el próximo?" StatelessWidget, ahora deja que el elemento »</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
StatelessWidget: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Aquí StatelessElement»</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
trémolo: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«StatelessElement, que estará en sujeción a SingleChildRenderObjectElement, aquí está el lugar, embarcarse»</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
StatelessElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«OK»</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/7w/tb/ke/7wtbkebtfn_xeq1ieqxqbarpkro.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
trémolo: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«el texto enriquecido, presente elementik, por favor»</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
del texto enriquecido da MultiChildRenderObjectElement </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
trémolo: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"MultiChildRenderObjectElement, aquí tienes, comienza"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
MultiChildRenderObjectElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Necesito un render para trabajar"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"RichText, necesitamos un objeto de render"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
RichText: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Aquí hay un RenderParagraph"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Flutter:</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"RenderParagraph recibirás instrucciones RenderPadding, y controlarás MultiChildRenderObjectElement"</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
MultiChildRenderObjectElement: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Ahora todo está bien, estoy listo"</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/s4/24/fn/s424fnivo4j2tb4sv9pcirmxov0.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Seguramente harás una pregunta legítima: "¿Dónde está el objeto de representación para StatelessWidget? ¿Por qué no está allí? Decidimos que los elementos unen configuraciones con pantalla? " </font><font style="vertical-align: inherit;">Prestemos atención a la implementación básica del método de montaje, que se discutió en esta sección de la descripción del ciclo de vida.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">void</span> mount(Element parent, dynamic newSlot) {<font></font>
    assert(_debugLifecycleState == _ElementLifecycle.initial);<font></font>
    assert(widget != <span class="hljs-literal">null</span>);<font></font>
    assert(_parent == <span class="hljs-literal">null</span>);<font></font>
    assert(parent == <span class="hljs-literal">null</span> || parent._debugLifecycleState == _ElementLifecycle.active);<font></font>
    assert(slot == <span class="hljs-literal">null</span>);<font></font>
    assert(depth == <span class="hljs-literal">null</span>);<font></font>
    assert(!_active);<font></font>
    _parent = parent;<font></font>
    _slot = newSlot;<font></font>
    _depth = _parent != <span class="hljs-literal">null</span> ? _parent.depth + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<font></font>
    _active = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>)<font></font>
        _owner = parent.owner;<font></font>
    <span class="hljs-keyword">if</span> (widget.key is GlobalKey) {<font></font>
        final GlobalKey key = widget.key;<font></font>
        key._register(<span class="hljs-keyword">this</span>);<font></font>
    }<font></font>
    _updateInheritance();<font></font>
    assert(() {<font></font>
        _debugLifecycleState = _ElementLifecycle.active;<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }());<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No veremos en él la creación de un objeto de representación. </font><font style="vertical-align: inherit;">Pero el elemento implementa un BuildContext, que tiene un método de búsqueda de objetos de visualización findRenderObject, que nos llevará al siguiente getter:</font></font><br>
<br>
<pre><code class="javascript hljs">RenderObject get renderObject {<font></font>
    RenderObject result;<font></font>
    <span class="hljs-keyword">void</span> visit(Element element) {<font></font>
        assert(result == <span class="hljs-literal">null</span>); 
        <span class="hljs-keyword">if</span> (element is RenderObjectElement)<font></font>
            result = element.renderObject;<font></font>
        <span class="hljs-keyword">else</span><font></font>
            element.visitChildren(visit);<font></font>
    }<font></font>
    visit(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> result;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el caso básico, un elemento puede no crear un objeto de representación; solo RenderObjectElement y sus descendientes están obligados a hacerlo; sin embargo, en este caso, un elemento en algún nivel de anidación debe tener un elemento secundario que tenga un objeto de representación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parecería por qué todas estas dificultades. Hasta 3 árboles, diferentes áreas de responsabilidad, etc. La respuesta es bastante simple: aquí es donde se construye el rendimiento de Flutter. Los widgets son configuraciones inmutables, por lo tanto, a menudo se recrean, pero al mismo tiempo son bastante livianos, lo que no afecta el rendimiento. Pero Flutter está tratando de reutilizar elementos pesados ​​tanto como sea posible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considera un ejemplo. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texto en el medio de la pantalla. El código en este caso se verá así:</font></font></i><br>
<br>
<pre><code class="javascript hljs">body: Center(<font></font>
    child: Text(“Hello world!”)<font></font>
),</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, el árbol de widgets se verá así: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lc/wt/fa/lcwtfazdhkpaprcu9tqvhssvck4.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de que Flutter construya los 3 árboles, obtenemos la siguiente imagen: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uc/vx/ph/ucvxphu5r2ds-6_kmoizgyoczo8.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué sucede si cambiamos el texto que vamos a mostrar? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_u/8b/do/_u8bdowthfzx9jshpbprfnpj1ai.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora tenemos un nuevo árbol de widgets. Arriba hablamos sobre la máxima reutilización posible de elementos. Eche un vistazo al método de clase Widget, bajo el nombre parlante </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">canUpdate</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">static</span> bool canUpdate(Widget oldWidget, Widget newWidget) {
    <span class="hljs-keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType &amp;&amp; oldWidget.key == newWidget.key;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verificamos el tipo del widget anterior y el nuevo, así como sus claves. Si son iguales, entonces no hay necesidad de cambiar el artículo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, antes de la actualización, el primer elemento es Centro, después de la actualización, también Centro. Ambos no tienen llaves, una completa coincidencia. Podemos actualizar el enlace del elemento a un nuevo widget. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/he/tr/s4/hetrs4cgzrimhibqeilfoja5xzi.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero además del tipo y la clave, el widget es una descripción y configuración, y los valores de los parámetros necesarios para la visualización podrían cambiar. Es por eso que el elemento, después de actualizar el enlace al widget, debe iniciar actualizaciones para el objeto de representación. En el caso de Center, nada ha cambiado y seguimos comparando más. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una vez más, el tipo y la clave nos dicen que no tiene sentido recrear el elemento. El texto es un descendiente de StatelessWidget; no tiene un objeto de visualización directa.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dp/yy/6m/dpyy6mckv6cddryb0_yu5asy_uy.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vaya a RichText. El widget tampoco ha cambiado su tipo; no hay discrepancias en las claves. El elemento actualiza su asociación con el nuevo widget. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hw/vh/95/hwvh952jekjwhudyj6czju3hq6a.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La conexión se actualiza, solo queda actualizar las propiedades. Como resultado, RenderParagraph mostrará el nuevo valor de texto. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/_p/g-/lv_pg-n6wlmcmlunokumb60nqw0.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y tan pronto como llegue el momento del próximo marco de dibujo, veremos el resultado que esperamos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gracias a este tipo de trabajo, Flutter logra un rendimiento tan alto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El ejemplo anterior describe el caso cuando la estructura del widget en sí no ha cambiado. Pero, ¿qué pasa si la estructura cambia? Flutter, por supuesto, continuará tratando de maximizar el uso de los objetos existentes, como entendimos por la descripción del ciclo de vida, pero se crearán nuevos elementos para todos los nuevos widgets, y los antiguos y más innecesarios se eliminarán al final del marco.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos un par de ejemplos. </font><font style="vertical-align: inherit;">Y para asegurarnos de lo anterior, utilizamos la herramienta Android Studio: Flutter Inspector.</font></font><br>
<br>
<pre><code class="javascript hljs">@override<font></font>
Wid<span class="hljs-keyword">get</span> <span class="hljs-title">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> Scaffold(<font></font>
        body: Center(<font></font>
            child: _isFirst ? first() : second(),<font></font>
        ),<font></font>
        <span class="hljs-attr">floatingActionButton</span>: FloatingActionButton(<font></font>
            child: Text(<span class="hljs-string">"Switch"</span>),
            <span class="hljs-attr">onPressed</span>: () {<font></font>
                setState(() {<font></font>
                    _isFirst = !_isFirst;<font></font>
                });<font></font>
            },<font></font>
        ),<font></font>
    );<font></font>
}<font></font>
<font></font>
Wid<span class="hljs-keyword">get</span> <span class="hljs-title">first</span>() =&gt; <span class="hljs-title">Row</span>(<span class="hljs-params">
    mainAxisAlignment: MainAxisAlignment.center,
    children: &lt;Widget&gt;[
        Text(
            <span class="hljs-string">"test"</span>,
            style: TextStyle(fontSize: <span class="hljs-number">25</span></span>),<font></font>
        ),<font></font>
        <span class="hljs-title">SizedBox</span>(<span class="hljs-params">
            width: <span class="hljs-number">5</span>,
        </span>),
        <span class="hljs-title">Icon</span>(<span class="hljs-params">
            Icons.error,
        </span>),<font></font>
    ],<font></font>
);<font></font>
<font></font>
<span class="hljs-title">Widget</span> <span class="hljs-title">second</span>() =&gt; <span class="hljs-title">Row</span>(<span class="hljs-params">
    mainAxisAlignment: MainAxisAlignment.center,
    children: &lt;Widget&gt;[
        Text(
            <span class="hljs-string">"one more test"</span>,
            style: TextStyle(fontSize: <span class="hljs-number">25</span></span>),<font></font>
        ),<font></font>
        <span class="hljs-title">Padding</span>(<span class="hljs-params">
            padding: EdgeInsets.only(left: <span class="hljs-number">5</span></span>),<font></font>
        ),<font></font>
        <span class="hljs-title">Icon</span>(<span class="hljs-params">
            Icons.error,
        </span>),<font></font>
    ],<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, al hacer clic en el botón, uno de los widgets cambiará. </font><font style="vertical-align: inherit;">Veamos qué nos muestra el inspector. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wi/vt/vt/wivtvtojhv4uq3l7ouoje3le-u0.png" alt="imagen"><br>
<br>
<img src="https://habrastorage.org/webt/f4/rb/0a/f4rb0avn7pombux2ct6pkap2edi.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como podemos ver, Flutter recreó el render solo para Padding, el resto simplemente se reutilizó. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere 1 opción más en la que la estructura cambia de una manera más global: cambiamos los niveles de anidamiento.</font></font><br>
<br>
<pre><code class="javascript hljs">Wid<span class="hljs-keyword">get</span> <span class="hljs-title">second</span>() =&gt; <span class="hljs-title">Container</span>(<span class="hljs-params">child: first(</span>),);</code></pre><br>
<img src="https://habrastorage.org/webt/yt/8i/gs/yt8igsxt3r3b-ofhkrlcyjaqryc.png" alt="imagen"><br>
<br>
<img src="https://habrastorage.org/webt/j7/na/qw/j7naqwq6060sh-tw_atxna_umpa.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pesar de que el árbol no cambió visualmente en absoluto, se recrearon los elementos y objetos del árbol de representación. </font><font style="vertical-align: inherit;">Esto sucedió porque Flutter compara por nivel (en este caso, no importa que la mayor parte del árbol no haya cambiado), el tamizado de esta parte tuvo lugar al momento de comparar Contenedor y Fila. </font><font style="vertical-align: inherit;">Sin embargo, uno puede salir de esta situación. </font><font style="vertical-align: inherit;">Esto nos ayudará a GlobalKey. </font><font style="vertical-align: inherit;">Agregue una clave para Row.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> _key = GlobalKey(debugLabel: <span class="hljs-string">"testLabel"</span>);<font></font>
<font></font>
Wid<span class="hljs-keyword">get</span> <span class="hljs-title">first</span>() =&gt; <span class="hljs-title">Row</span>(<span class="hljs-params">
    key: _key,
    …
</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/gg/jp/zj/ggjpzjlpox-ijhgtwxy-i6rvcsk.png" alt="imagen"><br>
<br>
<img src="https://habrastorage.org/webt/zy/br/zy/zybrzywy-_ixs_apl7j1fiqsrco.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tan pronto como le dijimos a Flutter que la pieza podía reutilizarse, aprovechó la oportunidad.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusión </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos acercamos un poco más a la magia Flutter y ahora sabemos que no solo se trata de widgets. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flutter es un mecanismo bien coordinado y bien pensado con su propia jerarquía, áreas de responsabilidad, con el que puede crear no solo aplicaciones hermosas, sino también productivas. </font><font style="vertical-align: inherit;">Por supuesto, hemos examinado solo una pequeña parte, aunque bastante importante, de su dispositivo, por lo que continuaremos analizando varios aspectos del funcionamiento interno del marco en futuros artículos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que la información en este artículo sea útil para comprender cómo Flutter funciona internamente y lo ayude a encontrar soluciones elegantes y productivas durante el desarrollo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Gracias por la atención!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recursos</font></font></h4><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flutter </font></font></i><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Cómo Flutter hace Widgets" por Andrew Fitz Gibbon, Matt Sullivan</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es501850/index.html">Desmontamos el algoritmo EM en pequeños ladrillos</a></li>
<li><a href="../es501854/index.html">Cómo salir de la programación y comenzar a realizar</a></li>
<li><a href="../es501856/index.html">Tarantool: mirada de analista</a></li>
<li><a href="../es501858/index.html">Poniendo todos los puntos en el "psi"</a></li>
<li><a href="../es501860/index.html">15 de mayo RU-Center puede agregarle un servicio pago sin su participación</a></li>
<li><a href="../es501864/index.html">Asistente o inspector: ¿a quién llama el robot?</a></li>
<li><a href="../es501866/index.html">¿Cuántos trabajos destruirán los robots?</a></li>
<li><a href="../es501868/index.html">Cómo no dejar que el contador se arroje o transfiramos 1C a la nube. Instrucciones paso a paso</a></li>
<li><a href="../es501870/index.html">Número máximo de valores en enum Parte II</a></li>
<li><a href="../es501872/index.html">Lugar de estudio en sistemas cibernéticos.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>