<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💬 🕙 👏🏿 Stas Afanasyev. Juno. Pipa berdasarkan pada io.Reader / io.Writer. Bagian 1 👒 🚘 ⬆️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam laporan ini, kita akan berbicara tentang konsep io.Reader / io.Writer, mengapa mereka diperlukan, bagaimana menerapkannya dengan benar dan peran...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Stas Afanasyev. Juno. Pipa berdasarkan pada io.Reader / io.Writer. Bagian 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/491484/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam laporan ini, kita akan berbicara tentang konsep io.Reader / io.Writer, mengapa mereka diperlukan, bagaimana menerapkannya dengan benar dan perangkap apa yang ada dalam hal ini, serta tentang membangun jaringan pipa berdasarkan implementasi io.Reader / io.Writer standar dan kebiasaan .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rd/nv/uj/rdnvujcjwsukejxq_6a9syayawu.jpeg"><a name="habracut"></a><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stanislav Afanasyev (selanjutnya - SA):</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Selamat siang! Nama saya Stas. Saya datang dari Minsk, dari perusahaan Juno. Terima kasih telah datang pada hari hujan ini, setelah menemukan kekuatan untuk meninggalkan rumah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hari ini saya ingin berbicara dengan Anda tentang topik seperti membangun saluran pipa Go berdasarkan antarmuka io.Reader / io.Writer. Apa yang akan saya bicarakan hari ini adalah, secara umum, konsep antarmuka io.Reader / io.Writer, mengapa mereka diperlukan, cara menggunakannya dengan benar, dan yang paling penting, cara menerapkannya dengan benar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami juga akan berbicara tentang membangun saluran pipa berdasarkan berbagai implementasi dari antarmuka ini. Kami akan berbicara tentang metode yang ada, membahas pro dan kontra mereka. Saya akan menyebutkan berbagai jebakan (ini akan berlimpah).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum kita mulai, kita harus menjawab pertanyaan, mengapa antarmuka ini diperlukan? </font><font style="vertical-align: inherit;">Angkat tanganmu, yang bekerja dengan Go dengan erat (setiap hari, setiap hari) ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d2/pd/f4/d2pdf4kdwdjk_vxkqz6fwckqrgk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hebat! </font><font style="vertical-align: inherit;">Kami masih memiliki komunitas Go. </font><font style="vertical-align: inherit;">Saya pikir banyak dari Anda telah bekerja dengan antarmuka ini, paling tidak pernah mendengarnya. </font><font style="vertical-align: inherit;">Anda mungkin bahkan tidak tahu tentang mereka, tetapi Anda tentu harus mendengar sesuatu tentang mereka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama-tama, antarmuka ini adalah abstraksi operasi input-output dalam semua manifestasinya. </font><font style="vertical-align: inherit;">Kedua, ini adalah API yang sangat nyaman yang memungkinkan Anda membangun saluran pipa, seperti konstruktor dari kubus, tanpa benar-benar memikirkan detail internal implementasi. </font><font style="vertical-align: inherit;">Setidaknya itu awalnya dimaksudkan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah antarmuka yang sangat sederhana. Ini hanya terdiri dari satu metode - metode Baca. Secara konseptual, implementasi antarmuka io.Reader dapat menjadi koneksi jaringan - misalnya, di mana belum ada data, tetapi mereka dapat muncul di sana: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/n-/4n/dc/n-4ndcbxpoxkul6h227ue7hruli.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini dapat menjadi buffer di memori di mana data sudah ada dan dapat dibaca seluruhnya. Ini juga bisa menjadi deskriptor file - kita dapat membaca file ini dalam beberapa bagian jika sangat besar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implementasi konseptual dari antarmuka io.Reader adalah akses ke beberapa data. Semua kasus yang saya tulis didukung oleh metode Baca. Ini hanya memiliki satu argumen - ini adalah slice byte.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Satu hal yang ingin disampaikan di sini. Mereka yang datang ke Go baru-baru ini atau berasal dari beberapa teknologi lain, di mana tidak ada API serupa (saya salah satunya), tanda tangan ini agak membingungkan. Metode Baca tampaknya entah bagaimana membaca irisan ini. Faktanya, yang terjadi adalah sebaliknya: implementasi antarmuka Reader membaca data di dalam dan mengisi irisan ini dengan data yang dimiliki implementasi ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jumlah maksimum data yang dapat dibaca berdasarkan permintaan dengan metode Baca sama dengan panjang irisan ini. </font><font style="vertical-align: inherit;">Implementasi reguler mengembalikan data sebanyak yang dapat dikembalikan pada saat permintaan, atau jumlah maksimum yang cocok dengan irisan ini. </font><font style="vertical-align: inherit;">Ini menunjukkan bahwa Reader dapat dibaca dalam beberapa bagian: setidaknya dengan byte, setidaknya sepuluh - sesuka Anda. </font><font style="vertical-align: inherit;">Dan klien yang memanggil Pembaca, sesuai dengan nilai-nilai pengembalian dari metode Baca, berpikir untuk hidup terus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode Baca mengembalikan dua nilai:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jumlah byte dikurangi;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kesalahan jika itu terjadi.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nilai-nilai ini memengaruhi perilaku klien selanjutnya. </font><font style="vertical-align: inherit;">Ada gif pada slide yang menunjukkan, menampilkan proses ini, yang baru saja saya jelaskan:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/ww/sf/siwwsf6u8mb1nkztg0ltnumkckw.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/p1/hk/mb/p1hkmbpfp8-twtnznjj2ihireaa.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Io.Reader - Bagaimana caranya?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tepatnya ada dua cara agar data Anda memenuhi antarmuka Reader. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/l0/fm/e7/l0fme7quz_tqzilkfiuiddpgjk4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang pertama adalah yang paling sederhana. Jika Anda memiliki beberapa jenis byte slice, dan Anda ingin membuatnya memuaskan antarmuka Reader, Anda dapat mengambil implementasi beberapa perpustakaan standar yang sudah memenuhi antarmuka ini. Misalnya, Pembaca dari paket byte. Pada slide di atas, Anda dapat melihat tanda tangan tentang bagaimana Pembaca ini dibuat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada cara yang lebih rumit - untuk mengimplementasikan antarmuka Reader sendiri. Ada sekitar 30 baris dalam dokumentasi dengan aturan rumit, batasan yang harus diikuti. Sebelum kita berbicara tentang semuanya, menjadi menarik bagi saya: “Dan dalam hal apa implementasi standar yang tidak memadai (perpustakaan standar)? Kapan saat ketika kita perlu mengimplementasikan antarmuka Reader sendiri? "</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menjawab pertanyaan ini, saya mengambil ribuan repositori paling populer di Github (dengan jumlah bintang), menambahkannya dan menemukan semua implementasi antarmuka Reader di sana. </font><font style="vertical-align: inherit;">Pada slide, saya memiliki beberapa statistik (dikategorikan) ketika orang mengimplementasikan antarmuka ini.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kategori yang paling populer adalah koneksi. </font><font style="vertical-align: inherit;">Ini adalah implementasi dari protokol dan pembungkus berpemilik untuk tipe yang ada. </font><font style="vertical-align: inherit;">Jadi, Brad Fitzpatrick memiliki proyek Camlistore - ada contoh dalam bentuk statTrackingConn, yang, secara umum, adalah Wrapper biasa pada tipe con dari paket net (menambahkan metrik ke tipe ini).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kategori paling populer kedua adalah buffer khusus. </font><font style="vertical-align: inherit;">Di sini saya menyukai satu-satunya contoh: dataBuffer dari paket x / net. </font><font style="vertical-align: inherit;">Keunikannya adalah bahwa ia menyimpan data yang dipotong menjadi potongan-potongan, dan ketika mengurangi itu melewati potongan-potongan ini. </font><font style="vertical-align: inherit;">Jika data di chunk sudah selesai, ia akan pindah ke chunk berikutnya. </font><font style="vertical-align: inherit;">Pada saat yang sama, ia memperhitungkan panjangnya, tempat ia dapat mengisi irisan yang dikirimkan.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kategori lain adalah semua jenis progress-bar, menghitung jumlah byte yang dikurangi dengan pengiriman metrik ...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berdasarkan data ini, kita dapat mengatakan bahwa kebutuhan untuk mengimplementasikan antarmuka io.Reader cukup sering terjadi. </font><font style="vertical-align: inherit;">Mari kita mulai berbicara tentang aturan yang ada di dokumentasi.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan Dokumentasi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang saya katakan, daftar aturan, dan secara umum dokumentasinya cukup besar, masif. 30 baris sudah cukup untuk antarmuka yang hanya terdiri dari tiga baris. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aturan pertama dan terpenting menyangkut jumlah byte yang dikembalikan. Itu harus benar-benar lebih besar dari atau sama dengan nol dan kurang dari atau sama dengan panjang irisan yang dikirim. Mengapa ini penting? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1k/kp/xh/1kkpxhahoiicme8z8vbdbq5ajbm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena ini adalah kontrak yang cukup ketat, klien dapat mempercayai jumlah yang berasal dari implementasi. Ada Wrappers di perpustakaan standar (misalnya, bytes.Buffer dan bufio). Ada momen seperti itu di perpustakaan standar: beberapa implementasi percaya dibungkus Pembaca, beberapa tidak percaya (kita akan membicarakan ini nanti).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bufio sama sekali tidak mempercayai apa pun - itu benar-benar memeriksa segalanya. </font><font style="vertical-align: inherit;">Bytes.Buffer benar-benar mempercayai segala yang datang kepadanya. </font><font style="vertical-align: inherit;">Sekarang saya akan menunjukkan apa yang terjadi sehubungan dengan ini ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami sekarang akan mempertimbangkan tiga kemungkinan kasus - ini adalah tiga Pembaca yang diimplementasikan. </font><font style="vertical-align: inherit;">Mereka cukup sintetis, berguna untuk pengertian. </font><font style="vertical-align: inherit;">Kami akan membaca semua Pembaca ini menggunakan pembantu ReadAll. </font><font style="vertical-align: inherit;">Tanda tangannya disajikan di bagian atas slide:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ib/c1/7b/ibc17bdqyrimk3xce2khqwera4w.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader # 1. </font><font style="vertical-align: inherit;">Contoh 1</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ReadAll adalah penolong yang membutuhkan semacam implementasi antarmuka Reader, membaca semuanya dan mengembalikan data yang dibaca, serta kesalahan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh pertama kami adalah Reader, yang akan selalu mengembalikan -1 dan nil sebagai kesalahan, mis. NegativeReader. Mari kita jalankan dan lihat apa yang terjadi: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7n/3h/l-/7n3hl-2vdvmgvmw80eljlorapiw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda tahu, panik tanpa alasan adalah pertanda kebodohan. Tapi siapa yang dalam hal ini bodoh - saya atau byte.Buffer - tergantung pada sudut pandang. Mereka yang menulis paket ini dan yang mengikutinya memiliki sudut pandang yang berbeda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang terjadi disini? Bytes.Buffer menerima sejumlah byte negatif, tidak memeriksa apakah itu negatif, dan mencoba memotong buffer internal di sepanjang batas atas, yang diterimanya - dan kami keluar dari batas slice.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada dua masalah dalam contoh ini. Yang pertama adalah bahwa tanda tangan tidak dilarang untuk mengembalikan angka negatif, dan dokumentasinya dilarang. Jika tanda tangan memiliki Uint, maka kami akan mendapatkan luapan klasik (ketika nomor yang ditandatangani ditafsirkan sebagai tidak ditandatangani). Dan ini adalah bug yang sangat rumit, yang pasti akan terjadi pada Jumat malam, ketika Anda sudah dirakit di rumah. Karenanya, panik dalam hal ini adalah opsi yang lebih disukai.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Titik" kedua adalah bahwa jejak tumpukan tidak mengerti apa yang terjadi sama sekali. Jelas bahwa kita telah melampaui batas irisan - jadi apa? Ketika Anda memiliki pipa multilayer dan kesalahan seperti itu terjadi, tidak segera jelas apa yang terjadi. Jadi bufio dari perpustakaan standar juga "panik" dalam situasi ini, tetapi melakukannya dengan lebih indah. Dia segera menulis: “Saya mengurangi sejumlah byte negatif. Saya tidak akan melakukan hal lain - saya tidak tahu apa yang harus saya lakukan dengannya. "</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan byte. Buffer panik sebaik mungkin. </font><font style="vertical-align: inherit;">Saya memposting masalah ke Golang meminta saya untuk menambahkan kesalahan manusia. </font><font style="vertical-align: inherit;">Hari ketiga, kami membahas prospek keputusan ini. </font><font style="vertical-align: inherit;">Alasannya adalah ini: secara historis terjadi bahwa orang yang berbeda pada waktu yang berbeda membuat keputusan yang tidak terkoordinasi yang berbeda. </font><font style="vertical-align: inherit;">Dan sekarang kami memiliki yang berikut: dalam satu kasus kami tidak percaya sama sekali implementasi (kami memeriksa semuanya), dan yang lain kami percaya sepenuhnya, kami tidak mendapatkan apa yang datang dari sana. </font><font style="vertical-align: inherit;">Ini adalah masalah yang belum terselesaikan, dan kami akan berbicara lebih banyak tentang ini.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader # 1. </font><font style="vertical-align: inherit;">Contoh 2</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Situasi berikut: Pembaca kami akan selalu mengembalikan 0 dan nol sebagai hasilnya. </font><font style="vertical-align: inherit;">Dari sudut pandang kontrak, semuanya legal di sini - tidak ada masalah. </font><font style="vertical-align: inherit;">Satu-satunya peringatan: dokumentasi mengatakan bahwa implementasi tidak disarankan untuk mengembalikan nilai 0 dan nihil, di samping kasus ini, ketika panjang slice yang dikirim adalah nol. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kehidupan nyata, Pembaca seperti itu dapat menyebabkan banyak masalah. </font><font style="vertical-align: inherit;">Jadi, kita kembali ke pertanyaan, haruskah kita percaya pada Reader? </font><font style="vertical-align: inherit;">Sebagai contoh, sebuah cek dibangun ke dalam bufio: ia secara berurutan membaca Reader 100 kali - jika sepasang nilai dikembalikan 100 kali, ia hanya mengembalikan NoProgress. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak ada yang seperti ini di byte. Buffer. </font><font style="vertical-align: inherit;">Jika kita menjalankan contoh ini, kita hanya mendapatkan loop tanpa akhir (ReadAll menggunakan bytes.Buffer di bawah tenda, bukan Reader itu sendiri):</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xh/br/zu/xhbrzuvnof4dxubt2d26i6q4l_q.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader # 1. </font><font style="vertical-align: inherit;">Contoh 2</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Satu lagi contoh. </font><font style="vertical-align: inherit;">Ini juga cukup sintetik, tetapi berguna untuk memahami: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ga/pe/xp/gapexpzfyhd6za09ss_uuwbrmlk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita selalu mengembalikan 1 dan nihil. </font><font style="vertical-align: inherit;">Tampaknya tidak ada masalah di sini juga - semuanya legal dari sudut pandang kontrak. </font><font style="vertical-align: inherit;">Ada nuansa: jika saya menjalankan contoh ini di komputer saya, maka akan membeku setelah 30 detik ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini disebabkan oleh fakta bahwa klien yang membaca Pembaca ini (yaitu, bytes.Buffer) tidak pernah mendapat tanda akhir data - bunyinya, kurangi ... Plus, dia mendapat satu byte yang dikurangi setiap waktu. </font><font style="vertical-align: inherit;">Baginya, ini berarti bahwa pada titik tertentu, buffer yang direposisi berakhir, masih berjalan - situasinya berulang, dan itu berjalan hingga tak terbatas hingga meledak.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader # 2. </font><font style="vertical-align: inherit;">Kesalahan kembali</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami sampai pada aturan penting kedua untuk mengimplementasikan antarmuka Reader - ini adalah pengembalian kesalahan. </font><font style="vertical-align: inherit;">Dokumentasi menyatakan tiga kesalahan yang harus dikembalikan oleh implementasi. </font><font style="vertical-align: inherit;">Yang paling penting dari mereka adalah EOF. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EOF adalah tanda akhir dari data, yang implementasinya harus kembali setiap kali kehabisan data. </font><font style="vertical-align: inherit;">Secara konseptual, ini, secara umum, bukan kesalahan, tetapi dibuat sebagai kesalahan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada kesalahan lain yang disebut UnexpectedEOF. </font><font style="vertical-align: inherit;">Jika tiba-tiba saat membaca Pustaka tidak dapat lagi membaca data, diperkirakan akan mengembalikan UnexpectedEOF. </font><font style="vertical-align: inherit;">Namun pada kenyataannya, kesalahan ini hanya digunakan di satu tempat perpustakaan standar - dalam fungsi ReadAtLeast.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-c/og/la/-coglawtrylyakbq0kxlc0ob9rs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kesalahan lain adalah NoProgress, yang sudah kita bicarakan. </font><font style="vertical-align: inherit;">Dokumentasi mengatakan demikian: ini adalah tanda bahwa antarmuka diimplementasikan menyebalkan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya. Pemimpin # 3</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dokumentasi menetapkan serangkaian kasus tentang cara mengembalikan kesalahan dengan benar. </font><font style="vertical-align: inherit;">Di bawah ini Anda dapat melihat tiga kemungkinan kasus: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m1/ef/si/m1efsipabh8oypgch-7_ni2syc8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami dapat mengembalikan kesalahan baik dengan jumlah byte dikurangi, dan secara terpisah. </font><font style="vertical-align: inherit;">Tetapi jika tiba-tiba data Anda habis di Pustaka Anda, dan Anda tidak dapat mengembalikan [tanda akhir] EOF sekarang (banyak implementasi dari pekerjaan perpustakaan standar seperti itu), maka diasumsikan bahwa Anda akan mengembalikan EOF ke panggilan berikutnya yang berurutan (yaitu, Anda harus melepaskan pelanggan). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk klien, ini berarti tidak ada lagi data - jangan mendatangi saya lagi. </font><font style="vertical-align: inherit;">Jika Anda mengembalikan nol, dan klien membutuhkan data, maka ia harus mendatangi Anda lagi.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io.Reader. </font><font style="vertical-align: inherit;">Kesalahan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, menurut Reader, ini adalah aturan penting utama. </font><font style="vertical-align: inherit;">Masih ada satu set yang kecil, tetapi mereka tidak begitu penting dan tidak mengarah pada situasi seperti itu: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xv/iu/az/xviuazv5segzzd5ganrbinp8xli.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum kita membahas semua hal yang berkaitan dengan Reader, kita perlu menjawab pertanyaan: apakah ini penting, apakah kesalahan sering terjadi dalam implementasi custom? </font><font style="vertical-align: inherit;">Untuk menjawab pertanyaan ini, saya beralih ke spool saya untuk 1000 repositori (dan di sana kami mendapat sekitar 550 implementasi kustom). </font><font style="vertical-align: inherit;">Saya melihat seratus pertama dengan mata saya. </font><font style="vertical-align: inherit;">Tentu saja, ini bukan super-analisis, tetapi apa itu ... Saya </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mengidentifikasi dua kesalahan paling populer:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak pernah mengembalikan EOF;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terlalu banyak kepercayaan pada Pembaca terbungkus.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekali lagi, ini masalah dari sudut pandang saya. </font><font style="vertical-align: inherit;">Dan dari mereka yang menonton paket io, ini bukan masalah. </font><font style="vertical-align: inherit;">Kami akan membicarakan ini lagi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya ingin kembali ke satu nuansa. </font><font style="vertical-align: inherit;">Lihat: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/te/3h/9q/te3h9q46okeg22rijrfyxrmi4da.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Klien tidak boleh menafsirkan pasangan 0 dan nihil sebagai EOF. </font><font style="vertical-align: inherit;">Ini salah! </font><font style="vertical-align: inherit;">Bagi Pustaka, nilai ini hanyalah peluang untuk melepaskan klien. </font><font style="vertical-align: inherit;">Jadi, dua kesalahan yang saya sebutkan tampaknya tidak signifikan, tetapi cukup untuk membayangkan bahwa Anda memiliki pipa multi-layer di prod dan “bagul” licik merayap di tengah, maka “ketukan bawah tanah” tidak akan memakan waktu lama - dijamin! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menurut Reader, pada dasarnya semuanya. </font><font style="vertical-align: inherit;">Ini adalah aturan implementasi dasar.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penulis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di ujung lain dari jalur pipa, kami memiliki io.Writer, yang merupakan tempat kami biasanya menulis data. </font><font style="vertical-align: inherit;">Antarmuka yang sangat mirip: itu juga terdiri dari satu metode (Tulis), tanda tangan mereka mirip. </font><font style="vertical-align: inherit;">Dari sudut pandang semantik, antarmuka Writer lebih dapat dimengerti: Saya akan mengatakan bahwa ketika didengar, itu ditulis. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fq/ya/ls/fqyalshoz2lwp48cs5u8oa9ymdk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode Write mengambil byte slice dan menulisnya secara keseluruhan. </font><font style="vertical-align: inherit;">Ia juga memiliki seperangkat aturan yang harus diikuti.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang pertama adalah jumlah byte yang ditulis. </font><font style="vertical-align: inherit;">Saya akan mengatakan bahwa itu tidak begitu ketat, karena saya tidak menemukan satu pun contoh ketika itu akan menyebabkan beberapa konsekuensi kritis - misalnya, panik. </font><font style="vertical-align: inherit;">Ini tidak terlalu ketat karena ada aturan berikut ...</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi Writer diperlukan untuk mengembalikan kesalahan setiap kali jumlah data yang ditulis kurang dari apa yang dikirim. </font><font style="vertical-align: inherit;">Artinya, perekaman parsial tidak didukung. </font><font style="vertical-align: inherit;">Ini berarti bahwa tidak terlalu penting berapa banyak byte yang ditulis.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu lagi aturan: Penulis tidak boleh memodifikasi slice yang dikirim, karena klien masih akan bekerja dengan slice ini.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penulis tidak boleh memegang slice ini (Reader memiliki aturan yang sama). </font><font style="vertical-align: inherit;">Jika Anda memerlukan data dalam implementasi Anda untuk beberapa operasi, Anda hanya perlu menyalin slide ini, dan hanya itu.</font></font></li>
</ol><br>
<img src="https://habrastorage.org/webt/iy/tx/qe/iytxqemg1nabcwxyfzxtgszmjxy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oleh Pembaca dan Penulis, itu saja.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dendrogram</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Khusus untuk laporan ini, saya membuat grafik implementasi dan mendesainnya dalam bentuk dendrogram. </font><font style="vertical-align: inherit;">Mereka yang ingin sekarang dapat mengikuti kode QR ini: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/r2/zp/pq/r2zppqu-0snqu80oqyxxpxakkpc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dendrogram ini memiliki semua implementasi dari semua antarmuka paket io. </font><font style="vertical-align: inherit;">Dendrogram ini diperlukan hanya untuk memahami: apa dan dengan apa yang dapat Anda satukan dalam pipa, di mana dan apa yang dapat Anda baca, di mana Anda dapat menulis. </font><font style="vertical-align: inherit;">Saya masih akan merujuknya dalam laporan saya, jadi silakan merujuk ke kode QR.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jaringan pipa</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami berbicara tentang apa itu Reader, io.Writer. Sekarang mari kita bicara tentang API yang ada di perpustakaan standar untuk membangun jaringan pipa. Mari kita mulai dengan dasar-dasarnya. Mungkin itu bahkan tidak akan menarik bagi siapa pun. Namun, ini sangat penting. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan membaca data dari aliran input standar (dari Stdin): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zq/tq/4m/zqtq4mfocqntafmpk5m_scirhcm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stdin diwakili dalam Go oleh variabel global tipe file dari paket os. Jika Anda melihat pada dendrogram, Anda akan melihat bahwa jenis file juga mengimplementasikan antarmuka Reader dan Writer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat ini kami tertarik pada Pustaka. Kami akan membacakan Stdin menggunakan pembantu ReadAll yang sama yang telah kami gunakan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Satu nuansa mengenai pembantu ini patut dicatat: ReadAll membaca Pembaca sampai akhir, tetapi menentukan akhir dengan EOF, dengan tanda akhir yang kita bicarakan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami sekarang akan membatasi jumlah data yang kami baca dari Stdin. Untuk melakukan ini, ada implementasi LimitedReader di perpustakaan standar: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qq/dm/hn/qqdmhnj73dfyxpdlrpoffwzimgq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya ingin Anda memperhatikan bagaimana LimitedReader membatasi jumlah byte yang akan dibaca. Orang akan berpikir bahwa implementasi ini, Wrapper ini, mengurangi semua yang ada di Reader, yang dibungkusnya, dan kemudian memberikan sebanyak yang kita inginkan. Tapi semuanya bekerja sedikit berbeda ...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LimitedReader memotong irisan yang diberikan padanya sebagai argumen di sepanjang batas atas. </font><font style="vertical-align: inherit;">Dan dia memberikan potongan yang dipotong ini ke Reader, yang membungkusnya. </font><font style="vertical-align: inherit;">Ini adalah demonstrasi yang jelas tentang bagaimana panjang data yang dibaca diatur dalam implementasi antarmuka io.Reader.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesalahan saat mengembalikan file</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Poin menarik lainnya: perhatikan bagaimana implementasi ini menghasilkan kesalahan EOF! </font><font style="vertical-align: inherit;">Nilai-nilai yang dinamai digunakan di sini, dan mereka ditugaskan oleh nilai-nilai yang kami dapatkan dari Pembaca terbungkus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan jika itu terjadi bahwa ada lebih banyak data dalam Pembaca terbungkus dari yang kita butuhkan, kami menetapkan nilai Pembaca terbungkus - misalnya, 10 byte dan nihil - karena masih ada data dalam Pembaca terbungkus. </font><font style="vertical-align: inherit;">Tetapi variabel n, yang menurun (di garis kedua dari belakang), mengatakan bahwa kita telah mencapai "bawah" - akhir dari apa yang kita butuhkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam iterasi berikutnya, klien harus datang lagi - dengan syarat pertama, ia akan menerima EOF. </font><font style="vertical-align: inherit;">Ini adalah kasus yang saya sebutkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akan dilanjutkan segera ...</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/kuyjuGk1USY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sedikit iklan :)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terima kasih untuk tetap bersama kami. Apakah Anda suka artikel kami? Ingin melihat materi yang lebih menarik? Dukung kami dengan melakukan pemesanan atau merekomendasikan kepada teman Anda </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VPS berbasis cloud untuk pengembang mulai $ 4,99</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analog unik dari server entry-level yang diciptakan oleh kami untuk Anda: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seluruh kebenaran tentang VPS (KVM) E5-2697 v3 (6 Cores) 10GB DDR4 480GB SSD 1Gbps mulai dari $ 19 atau cara membagi server?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (opsi tersedia dengan RAID1 dan RAID10, hingga 24 core dan hingga 40GB DDR4). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2 kali lebih murah di pusat data Equinix Tier IV di Amsterdam?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hanya kami yang memiliki </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV dari $ 199</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di Belanda!</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - mulai dari $ 99! </font></font></b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baca tentang</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cara Membangun Infrastruktur Bldg. </font><font style="vertical-align: inherit;">kelas c menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id491462/index.html">Baca Akhir Pekan: 12 podcast, stasiun radio FM era matahari terbenam, dan aplikasi meditasi</a></li>
<li><a href="../id491476/index.html">Accelerometer MEMS, magnetometer, dan sudut orientasi</a></li>
<li><a href="../id491478/index.html">Implan baru untuk tunanetra terhubung langsung ke otak</a></li>
<li><a href="../id491480/index.html">Proyek CoVirus MVP - peta infeksi coronavirus online atau "tombol merah" di tangan Anda</a></li>
<li><a href="../id491482/index.html">Memperkenalkan PowerShell 7.0</a></li>
<li><a href="../id491486/index.html">Skrip khusus saat menutup penutup laptop dan mengunci layar tanpa tidur</a></li>
<li><a href="../id491488/index.html">Apa artinya menjadi Agile?</a></li>
<li><a href="../id491490/index.html">Bagaimana Gitlab-CI mewarisi variabel lingkungan?</a></li>
<li><a href="../id491494/index.html">Penipuan sains Soviet yang megah: mengapa sebuah kapal orbital yang dapat digunakan kembali ternyata hanya sekali saja</a></li>
<li><a href="../id491496/index.html">IntelliJ IDEA Tips & Trik: 1. Membandingkan File dan Folder</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>