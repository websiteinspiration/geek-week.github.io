<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰🏻 🔙 📀 Perutean cepat dan NAT di Linux 🏇🏾 🛑 😡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Karena alamat IPv4 habis, banyak operator telekomunikasi dihadapkan dengan kebutuhan untuk mengatur akses klien mereka ke jaringan menggunakan terjema...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Perutean cepat dan NAT di Linux</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501234/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena alamat IPv4 habis, banyak operator telekomunikasi dihadapkan dengan kebutuhan untuk mengatur akses klien mereka ke jaringan menggunakan terjemahan alamat. </font><font style="vertical-align: inherit;">Pada artikel ini saya akan memberi tahu Anda cara mendapatkan kinerja tingkat NAT Carrier Grade di server komoditas.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sedikit sejarah</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Topik kehabisan ruang alamat IPv4 tidak lagi baru. Pada titik tertentu, daftar tunggu muncul di RIPE, kemudian ada pertukaran di mana mereka berdagang blok alamat dan menyimpulkan transaksi untuk sewa mereka. Secara bertahap, operator telekomunikasi mulai menyediakan layanan akses Internet melalui terjemahan alamat dan porta. Seseorang tidak berhasil mendapatkan alamat yang cukup untuk memberikan alamat "putih" kepada setiap pelanggan, sementara seseorang mulai menabung dengan menolak membeli alamat di pasar sekunder. Produsen peralatan jaringan mendukung gagasan ini, seperti fungsi ini biasanya memerlukan modul ekspansi atau lisensi tambahan. Misalnya, dengan Juniper di jajaran router MX (kecuali untuk MX104 dan MX204 terbaru), NAPT dapat dilakukan pada kartu layanan MS-MIC yang terpisah, Cisco ASR1k memerlukan lisensi GN,pada Cisco ASR9k, modul A9K-ISM-100 yang terpisah dan lisensi A9K-CGN-LIC untuknya. Secara umum, kesenangan menghabiskan banyak uang.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iptables</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tugas melakukan NAT tidak memerlukan sumber daya komputasi khusus, prosesor tujuan umum yang diinstal, misalnya, di router rumah apa pun, dapat menyelesaikannya. </font><font style="vertical-align: inherit;">Pada skala operator, masalah ini dapat diselesaikan dengan menggunakan server komoditas yang menjalankan FreeBSD (ipfw / pf) atau GNU / Linux (iptables). </font><font style="vertical-align: inherit;">Kami tidak akan mempertimbangkan FreeBSD, karena </font><font style="vertical-align: inherit;">Saya menolak untuk menggunakan OS ini untuk waktu yang lama, jadi mari kita fokus pada GNU / Linux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengaktifkan terjemahan alamat sama sekali tidak sulit. </font><font style="vertical-align: inherit;">Pertama, Anda perlu menulis aturan di iptables di tabel nat:</font></font><br>
<br>
<pre><code class="bash hljs">iptables -t nat -A POSTROUTING -s 100.64.0.0/10 -j SNAT --to &lt;pool_start_addr&gt;-&lt;pool_end_addr&gt; --persistent
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sistem operasi akan memuat modul nf_conntrack, yang akan memonitor semua koneksi aktif dan melakukan konversi yang diperlukan. </font><font style="vertical-align: inherit;">Ada beberapa kehalusan. </font><font style="vertical-align: inherit;">Pertama, karena kita berbicara tentang NAT pada skala pembawa, perlu untuk memperketat batas waktu, karena dengan nilai-nilai default, ukuran tabel terjemahan akan dengan cepat tumbuh menjadi nilai-nilai bencana. </font><font style="vertical-align: inherit;">Di bawah ini adalah contoh pengaturan yang saya gunakan di server saya:</font></font><br>
<br>
<pre><code class="bash hljs">net.ipv4.ip_forward = 1<font></font>
net.ipv4.ip_local_port_range = 8192 65535<font></font>
<font></font>
net.netfilter.nf_conntrack_generic_timeout = 300<font></font>
net.netfilter.nf_conntrack_tcp_timeout_syn_sent = 60<font></font>
net.netfilter.nf_conntrack_tcp_timeout_syn_recv = 60<font></font>
net.netfilter.nf_conntrack_tcp_timeout_established = 600<font></font>
net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 60<font></font>
net.netfilter.nf_conntrack_tcp_timeout_close_wait = 45<font></font>
net.netfilter.nf_conntrack_tcp_timeout_last_ack = 30<font></font>
net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120<font></font>
net.netfilter.nf_conntrack_tcp_timeout_close = 10<font></font>
net.netfilter.nf_conntrack_tcp_timeout_max_retrans = 300<font></font>
net.netfilter.nf_conntrack_tcp_timeout_unacknowledged = 300<font></font>
net.netfilter.nf_conntrack_udp_timeout = 30<font></font>
net.netfilter.nf_conntrack_udp_timeout_stream = 60<font></font>
net.netfilter.nf_conntrack_icmpv6_timeout = 30<font></font>
net.netfilter.nf_conntrack_icmp_timeout = 30<font></font>
net.netfilter.nf_conntrack_events_retry_timeout = 15<font></font>
net.netfilter.nf_conntrack_checksum=0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan kedua, karena ukuran default dari tabel terjemahan tidak dirancang untuk bekerja dalam kondisi operator telekomunikasi, itu harus ditingkatkan:</font></font><br>
<br>
<pre><code class="plaintext hljs">net.netfilter.nf_conntrack_max = 3145728
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Anda juga perlu menambah jumlah bucket untuk tabel hash yang menyimpan semua terjemahan (ini merupakan opsi dari modul nf_conntrack): </font></font><br>
<br>
<pre><code class="plaintext hljs">options nf_conntrack hashsize=1572864
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah manipulasi sederhana ini, konstruksi yang berfungsi sepenuhnya diperoleh, yang dapat menerjemahkan sejumlah besar alamat klien ke kumpulan eksternal. Namun, kinerja solusi ini buruk. Dalam upaya pertama saya untuk menggunakan GNU / Linux untuk NAT (sekitar 2013), saya bisa mendapatkan kinerja sekitar 7Gbit / s pada 0,8Mpps per server (Xeon E5-1650v2). Sejak saat itu, banyak optimasi yang berbeda telah dibuat dalam tumpukan jaringan kernel GNU / Linux, kinerja satu server pada perangkat keras yang sama telah tumbuh hampir menjadi 18-19 Gbit / s pada 1,8-1,9 Mpps (ini adalah nilai batas), tetapi kebutuhan untuk volume lalu lintas, diproses oleh satu server, tumbuh lebih cepat. Akibatnya, skema load balancing untuk berbagai server dikembangkan, tetapi semua ini meningkatkan kompleksitas pengaturan,melayani dan menjaga kualitas layanan yang diberikan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nftables</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat ini, penggunaan DPDK dan XDP adalah arah yang modis dalam perangkat lunak "transfer paket". </font><font style="vertical-align: inherit;">Banyak artikel telah ditulis mengenai hal ini, banyak presentasi berbeda telah dibuat, produk komersial muncul (misalnya, SKAT dari VasExperts). </font><font style="vertical-align: inherit;">Tetapi dalam kondisi sumber daya yang terbatas dari pemrogram dari operator telekomunikasi, itu cukup bermasalah untuk memotong semacam "berbagi" berdasarkan kerangka kerja ini. </font><font style="vertical-align: inherit;">Untuk mengoperasikan solusi semacam itu di masa depan akan jauh lebih sulit, khususnya, akan diperlukan untuk mengembangkan alat diagnostik. </font><font style="vertical-align: inherit;">Misalnya, tcpdump reguler dengan DPDK tidak berfungsi, dan itu tidak akan “melihat” paket yang dikirim kembali ke kabel menggunakan XDP. </font><font style="vertical-align: inherit;">Di tengah semua pembicaraan tentang teknologi baru untuk mengirimkan penerusan paket ke ruang pengguna, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">laporan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">artikel</font></a><font style="vertical-align: inherit;"> tidak diperhatikan</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pablo Neira Ayuso, pengelola iptables, mengembangkan aliran offloading di nftables. Mari kita lihat mekanisme ini secara lebih rinci.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gagasan utama adalah bahwa jika router melewati paket satu sesi di kedua sisi aliran (sesi TCP masuk ke keadaan ESTABLISHED), maka tidak perlu untuk melewati paket berikutnya dari sesi ini melalui semua aturan firewall, karena semua cek ini akan berakhir dengan mentransfer paket lebih jauh ke routing. Ya, dan sebenarnya pilihan rute tidak perlu dilakukan - kita sudah tahu antarmuka mana dan tuan rumah mana yang harus meneruskan paket dalam sesi ini. Tetap hanya untuk menyimpan informasi ini dan menggunakannya untuk routing pada tahap awal pemrosesan paket. Saat melakukan NAT, perlu juga menyimpan informasi tentang perubahan alamat dan port yang dikonversi oleh modul nf_conntrack. Ya, tentu saja, dalam hal ini berbagai poliser dan aturan statistik informasi lainnya di iptables berhenti berfungsi,tetapi sebagai bagian dari tugas NAT berdiri terpisah atau, misalnya, perbatasan, ini tidak begitu penting, karena layanan didistribusikan di seluruh perangkat.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurasi</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menggunakan fungsi ini kita perlu:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gunakan kernel baru. </font><font style="vertical-align: inherit;">Terlepas dari kenyataan bahwa fungsi itu sendiri muncul di kernel 4,16, untuk beberapa saat itu sangat "mentah" dan secara teratur disebut panik kernel. </font><font style="vertical-align: inherit;">Semuanya stabil sekitar Desember 2019, ketika kernel LTS 4.19.90 dan 5.4.5 dirilis.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tulis ulang aturan iptables dalam format nftables menggunakan versi nftables yang cukup baru. </font><font style="vertical-align: inherit;">Berfungsi dengan baik dalam versi 0.9.0</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika semuanya jelas pada prinsipnya dengan paragraf pertama, hal utama adalah jangan lupa untuk menyertakan modul dalam konfigurasi selama perakitan (CONFIG_NFT_FLOW_OFFLOAD = m), maka paragraf kedua membutuhkan penjelasan. </font><font style="vertical-align: inherit;">Aturan nftables dijelaskan sangat berbeda dari pada iptables. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengungkapkan hampir semua poin, ada juga </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konverter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aturan </font><font style="vertical-align: inherit;">khusus </font><font style="vertical-align: inherit;">dari iptables ke nftables. </font><font style="vertical-align: inherit;">Karena itu, saya hanya akan memberikan contoh pengaturan NAT dan aliran offload. </font><font style="vertical-align: inherit;">Legenda kecil sebagai contoh: &lt;i_if&gt;, &lt;o_if&gt; adalah antarmuka jaringan yang dilaluinya lalu lintas, pada kenyataannya bisa lebih dari dua. </font><font style="vertical-align: inherit;">&lt;pool_addr_start&gt;, &lt;pool_addr_end&gt; - alamat awal dan akhir dari rentang alamat "putih". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Konfigurasi NAT sangat sederhana:</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-comment">#! /usr/sbin/nft -f</span><font></font>
<font></font>
table nat {<font></font>
        chain postrouting {<font></font>
                <span class="hljs-built_in">type</span> nat hook postrouting priority 100;<font></font>
                oif &lt;o_if&gt; snat to &lt;pool_addr_start&gt;-&lt;pool_addr_end&gt; persistent<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flow offload sedikit lebih rumit, tetapi dapat dimengerti:</font></font><br>
<pre><code class="bash hljs"><span class="hljs-comment">#! /usr/sbin/nft -f</span><font></font>
<font></font>
table inet filter {<font></font>
        flowtable fastnat {<font></font>
                hook ingress priority 0<font></font>
                devices = { &lt;i_if&gt;, &lt;o_if&gt; }<font></font>
        }<font></font>
<font></font>
        chain forward {<font></font>
                <span class="hljs-built_in">type</span> filter hook forward priority 0; policy accept;<font></font>
                ip protocol { tcp , udp } flow offload @fastnat;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu, pada kenyataannya, adalah seluruh pengaturan. </font><font style="vertical-align: inherit;">Sekarang semua lalu lintas TCP / UDP akan pergi ke tabel fastnat dan akan diproses lebih cepat.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hasil</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memperjelas seberapa “lebih cepat” ini, saya akan melampirkan tangkapan layar dari beban pada dua server nyata dengan perangkat keras yang sama (Xeon E5-1650v2), yang dikonfigurasi secara sama, menggunakan kernel Linux yang sama, tetapi menjalankan NAT di iptables (NAT4) dan di nftables (NAT5). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y7/ov/c7/y7ovc7nkxxoply2apwjtur9tj-m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak ada grafik paket per detik di tangkapan layar, tetapi di profil beban server ini ukuran paket rata-rata adalah sekitar 800 byte, sehingga nilainya naik hingga 1,5Mpps. </font><font style="vertical-align: inherit;">Seperti yang Anda lihat, margin kinerja server dengan nftables sangat besar. </font><font style="vertical-align: inherit;">Saat ini, server ini memproses hingga 30Gbit / s pada 3Mpps dan jelas dapat mengalami keterbatasan fisik jaringan 40Gbps, sambil memiliki sumber daya CPU gratis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya berharap materi ini akan bermanfaat bagi para insinyur jaringan yang berusaha meningkatkan kinerja server mereka.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id501220/index.html">Parsing: dapatkah perusahaan memiliki terlalu banyak uang?</a></li>
<li><a href="../id501222/index.html">Penerapan COBIT saat mengembangkan strategi TI</a></li>
<li><a href="../id501224/index.html">Apa jaringan saraf dapat "bernyanyi" dan melakukan death metal</a></li>
<li><a href="../id501226/index.html">Pencarian file cepat</a></li>
<li><a href="../id501232/index.html">Bagaimana seorang pakar IT bisa mendapat tambahan pengetahuannya?</a></li>
<li><a href="../id501236/index.html">Jadi apa ini semua, "protein lipat"?</a></li>
<li><a href="../id501240/index.html">Audit Keamanan Situs</a></li>
<li><a href="../id501244/index.html">Programmer tidak harus menyelesaikan masalah bisnis</a></li>
<li><a href="../id501246/index.html">Grafik Covid-19 yang Benar</a></li>
<li><a href="../id501248/index.html">Hall of Fame Ketenaran Tempat Kerja JavaScript, Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>