<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õ™Ô∏è ‚ò£Ô∏è ü•õ SwiftUI sur les √©tag√®res: animation, partie 2 ü§≤üèΩ üçè üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ceci est la deuxi√®me partie de l'histoire d'animation dans SwiftUI. Dans le premier article, nous avons examin√© des exemples simples pour les bases du...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SwiftUI sur les √©tag√®res: animation, partie 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506672/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci est la deuxi√®me partie de l'histoire d'animation dans SwiftUI. Dans le premier </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous avons examin√© des exemples simples pour les bases du fonctionnement de l'animation dans SwiftUI. Dans cette partie, nous irons plus loin, et nous analyserons en d√©tail l'exemple annonc√© avec animation arc-en-ciel. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sous la coupe, vous trouverez une analyse du timing de l'animation, cr√©ant votre propre m√©canisme de courbe de timing pour travailler dans une animation lin√©aire en boucle, des exemples de mise en ≈ìuvre de diff√©rents gradients et quelques astuces int√©ressantes qui vous aideront √† comprendre comment fonctionne l'animation sous le capot.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Permettez-moi de vous rappeler que j'ai espionn√© l'id√©e de mettre en ≈ìuvre une telle animation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . L√†, les auteurs ont pris le chemin de la moindre r√©sistance, et ont mis en ≈ìuvre le moyen le plus √©vident de mettre en ≈ìuvre ce concept en animant la forme. Le principe est simple: chaque onde est un contour d√©limit√© par une courbe de B√©zier, et le param√®tre ¬´temps¬ª affecte la position de la limite droite de cette onde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici √† quoi ressemble l'animation termin√©e: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour plus de clart√©, je vais r√©partir les vagues un peu verticalement. C'est facile √† faire, je viens d'ajouter √† la fin de NotchWave en d√©pla√ßant tout le contour jusqu'√† la hauteur de l'onde, en fonction de la phase actuelle de l'animation:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">return</span> p.applying(.<span class="hljs-keyword">init</span>(translationX: <span class="hljs-number">0</span>, y: height * <span class="hljs-keyword">self</span>.phase))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien et aussi .drowingGroup (), il ne faut pas oublier de se d√©connecter - cela ne signifie pas que l'image d√©passe les fronti√®res du cadre fixe. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z3/zv/bi/z3zvbiseywno8t1fnt-i0ugcqgm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'approche est simple, elle produit le r√©sultat souhait√© ... mais elle m'a paru trop ennuyeuse. </font><font style="vertical-align: inherit;">Mon chemin s'est av√©r√© beaucoup plus long, et je ne dirais pas que le r√©sultat final serait au moins un peu meilleur, mais ce serait int√©ressant en cours de route. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous n'√™tes pas encore tr√®s au courant des principes du travail d'animation dans SwiftUI, je vous recommande fortement de lire l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article pr√©c√©dent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Et je veux me plonger dans le code source sur le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travailler avec des d√©grad√©s</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au tout d√©but, j'ai choisi une approche diff√©rente. J'ai trouv√© qu'il √©tait beaucoup plus utile de traiter de l'animation du d√©placement d'objets que de l'animation des formes (j'appelle toujours la structure de forme du formulaire). Le d√©calage peut fonctionner avec n'importe quoi - diverses formes, images, autres vues. En tant que t√¢che √©ducative, je voulais mettre en ≈ìuvre une transition de couleur en douceur d'une vague √† l'autre. Dans le concept d'origine, quelque chose comme √ßa √©tait comme √ßa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au total, SwiftIUI propose trois utilisations possibles du gradient - lin√©aire, circulaire et angulaire. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t7/o6/7d/t7o67dwcm_v5svufist7tfp0kwe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le code, cela ressemble √† une sorte de constructeur de blocs. Remarquez comment l'onde enti√®re est segment√©e.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wa/af/el/waafeltt9cgiasfzxg1gjexwc8i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un d√©grad√© lin√©aire est caract√©ris√© par un point de d√©but et de fin pour le d√©grad√©. </font><font style="vertical-align: inherit;">Ce ne sont pas des points CGPoint avec des coordonn√©es absolues (x: y :), mais des points UnitPoint, c'est-√†-dire </font><font style="vertical-align: inherit;">les coordonn√©es relatives, o√π x: y: sont sp√©cifi√©es en fractions de la largeur et de la hauteur de la zone s√©lectionn√©e pour cette vue. </font><font style="vertical-align: inherit;">Il existe √©galement des points pr√©d√©finis correspondant aux coins (.topLeading, .bottomTrailing, etc.) et aux points m√©dians des c√¥t√©s (.top, .trailing, etc.).</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
    .fill(<span class="hljs-type">LinearGradient</span>(<font></font>
         gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
          startPoint: .leading,<font></font>
          endPoint: .trailing))<font></font>
    .frame(width: <span class="hljs-keyword">self</span>.gradientLength)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le segment de d√©grad√© lin√©aire est ¬´caoutchouc¬ª. </font><font style="vertical-align: inherit;">Il a une largeur fixe, mais sa hauteur n'est pas sp√©cifi√©e. </font><font style="vertical-align: inherit;">Ainsi, il remplira le montant total fourni. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une histoire un peu plus compliqu√©e avec un d√©grad√© circulaire. </font><font style="vertical-align: inherit;">Nous indiquons le point - le centre du cercle, le rayon du d√©but du gradient et le rayon de la fin du gradient. </font><font style="vertical-align: inherit;">Les rayons sont d√©j√† en termes absolus, c'est-√†-dire </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des points</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le centre du cercle est toujours d√©fini comme UnitPoint.</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
     .fill(<span class="hljs-type">RadialGradient</span>(<font></font>
          gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">0</span>),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">1</span>)]),<font></font>
          center: .bottomTrailing,<font></font>
          startRadius: <span class="hljs-keyword">self</span>.topRadius,<font></font>
          endRadius: <span class="hljs-keyword">self</span>.topRadius + <span class="hljs-keyword">self</span>.gradientLength)<font></font>
                )<font></font>
    .frame(height: <span class="hljs-keyword">self</span>.topRadius)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une pi√®ce avec un cercle sup√©rieur a une hauteur fixe, mais s'√©tire horizontalement. Apr√®s tout, nous d√©finissons des rayons fixes sp√©cifiques en points, il n'est donc pas n√©cessaire de coller un rectangle d'√©tirement suppl√©mentaire de la couleur de base, comme c'est le cas avec un d√©grad√© lin√©aire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le plus difficile √† appliquer est un gradient angulaire. Il est donn√© par l'angle de d√©but et de fin, ainsi que par la direction. Comme vous pouvez le voir dans la liste de codes, travailler avec des coins n'est pas tr√®s pratique. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous devez vous rappeler le cours de trigonom√©trie de l'√©cole afin de calculer l'angle requis, si vous devez commencer le gradient angulaire √† un point et terminer √† un autre.</font></font><br>
<br>
<pre><code class="swift hljs">       
<span class="hljs-type">Rectangle</span>()<font></font>
      .fill(<span class="hljs-type">AngularGradient</span>(<font></font>
            gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.angularGradientMiddleStop(blockWidth: geometry.size.width)),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
            center: .bottomLeading,<font></font>
            startAngle: <span class="hljs-keyword">self</span>.directionTo(gradientPart: <span class="hljs-keyword">self</span>.start, blockWidth: geometry.size.width),<font></font>
            endAngle: <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)))<font></font>
<font></font>
...<font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">directionTo</span><span class="hljs-params">(gradientPart: Color, blockWidth: CGFloat)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> angleOf = gradientAngles(blockWidth: blockWidth)
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>.zero
        <span class="hljs-keyword">switch</span> gradientPart{
            <span class="hljs-keyword">case</span> start: angle = angleOf.start
            <span class="hljs-keyword">case</span> middle: angle = angleOf.middle
            <span class="hljs-keyword">case</span> end: angle = angleOf.end
            <span class="hljs-keyword">default</span>: <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"there is no gradient stop with that color: \(gradientPart)"</span>)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gradientAngles</span><span class="hljs-params">(blockWidth: CGFloat)</span></span> -&gt; (start: <span class="hljs-type">Angle</span>, middle: <span class="hljs-type">Angle</span>, end: <span class="hljs-type">Angle</span>){
        <span class="hljs-keyword">let</span> blockHeight = <span class="hljs-keyword">self</span>.bottomRadius
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: blockHeight)
        <span class="hljs-keyword">let</span> topRight = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength)
        <span class="hljs-keyword">let</span> topGradientStarts = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength * (<span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop))
        <span class="hljs-keyword">let</span> startAngle = center.radialDirection(to: topRight)
        <span class="hljs-keyword">let</span> middleAngle = center.radialDirection(to: topGradientStarts)
        <span class="hljs-keyword">let</span> endAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)
        <span class="hljs-keyword">return</span> (start: startAngle, middle: middleAngle, end: endAngle)<font></font>
    }<font></font>
<font></font>
...<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">CGPoint</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">radialDirection</span><span class="hljs-params">(to point: CGPoint)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> deltaX =  point.x - <span class="hljs-keyword">self</span>.x
        <span class="hljs-keyword">let</span> deltaY =  point.y - <span class="hljs-keyword">self</span>.y
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span> deltaX == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaY == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaX / -deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(-deltaX / deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le gradient angulaire, qui est la queue de la vague, est √©galement en caoutchouc, mais d√©j√† en largeur - il occupe la moiti√© de la taille restante. En fait, c'est pourquoi il y a tellement de trigonom√©trie. Je connais la position de points sp√©cifiques sur le bord de l'√©cran o√π une certaine couleur devrait √™tre (puisque je colle un d√©grad√© circulaire avec un d√©grad√© angulaire). De plus, les valeurs des angles d√©pendent non seulement des rayons du gradient inf√©rieur, mais √©galement de la largeur du bloc lui-m√™me avec le gradient. Pour la premi√®re fois depuis l'√©cole, j'ai pris un crayon et j'ai rappel√© l'alg√®bre :)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les trois options utilisent une seule description des couleurs dans le d√©grad√©. </font><font style="vertical-align: inherit;">Il s'agit d'une simple liste de couleurs dans un tableau. </font><font style="vertical-align: inherit;">Leur distribution sera uniforme sur un segment donn√©. </font><font style="vertical-align: inherit;">Vous pouvez affiner la distribution √† l'aide d'un tableau d'√©l√©ments Stop. </font><font style="vertical-align: inherit;">En fait, c'est la m√™me √©num√©ration des couleurs, seulement pour chacune d'elles la coordonn√©e sur un seul segment o√π elle sera situ√©e est √©galement indiqu√©e. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, j'ai cr√©√© une vague d'environ la m√™me forme que dans le concept original. </font><font style="vertical-align: inherit;">Cependant, la transition d'une couleur √† l'autre n'est plus nette, mais liss√©e, ce qui devrait potentiellement rendre l'animation plus fluide.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La couleur n'est pas ce qu'elle semble</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un point li√© √† la couleur. </font><font style="vertical-align: inherit;">Pour cr√©er l'effet d'une onde roulante, j'ai d√©cid√© de faire la transition entre les couleurs pas tout √† fait lin√©aire. </font><font style="vertical-align: inherit;">Si vous regardez de plus pr√®s, vous remarquerez que le d√©grad√© est plus net sur le bord lui-m√™me, et plus il est √©loign√© du bord, plus il coule dans la couleur principale. </font></font><br>
<img src="https://habrastorage.org/webt/hb/k-/f-/hbk-f-u1tcrri8furxdgeg8tx50.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai atteint cet objectif en calculant la couleur interm√©diaire et en cr√©ant un d√©grad√© avec cette distribution:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">couleur initiale - 0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
couleur interm√©diaire - 0.3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
couleur finale - 1</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le probl√®me s'est pos√© avec le calcul de la moyenne de deux couleurs. SwiftUI signifie utiliser l'objet Color pour les d√©grad√©s, et j'ai √©t√© s√©duit. En fait, si vous souhaitez travailler avec des couleurs comme avec des objets RVB, utilisez initialement UIColor dans votre mod√®le, car Color n'a pas d'acc√®s direct √† la couleur. Vous ne pouvez pas non plus le reconvertir facilement en UIColor. La seule </font><font style="vertical-align: inherit;">solution </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(non)</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ad√©quate que j'ai trouv√©e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est d'obtenir une r√©flexion miroir avec une analyse de sa repr√©sentation sous forme de cha√Æne. Un tel passe-partout, mais il n'y a pas encore d'autres options.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et ce n'est pas une erreur, pas une omission. </font><font style="vertical-align: inherit;">Le fait est que SwiftUI dans l'objet Color ne duplique pas la fonctionnalit√© de UIColor. </font><font style="vertical-align: inherit;">Si vous avez besoin de travailler avec des canaux RVB - utilisez-le. </font><font style="vertical-align: inherit;">La couleur dans SwiftUI est une vue qui a une couleur de base, dont la valeur sp√©cifique peut varier l√©g√®rement en fonction de l'emplacement des √©toiles dans le ciel - une couleur RVB sp√©cifique n'est d√©termin√©e qu'au moment du dessin √† l'√©cran. </font><font style="vertical-align: inherit;">La documentation dit</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SwiftUI ne le r√©sout qu'en une valeur concr√®te juste avant de l'utiliser dans un environnement donn√©.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais ce que l'on entend par environnement: la couleur du mur derri√®re le dos de l'utilisateur ou le th√®me de conception iOS n'est pas clair. </font><font style="vertical-align: inherit;">Si cela ne vous convient pas, utilisez UIColor en mode natif.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animation sans fin</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'animation est sp√©cifi√©e par le modificateur .animation () et d√©marre apr√®s l'initialisation de View dans le modificateur </font></font><code>.onAppear()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en modifiant la </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable. </font><font style="vertical-align: inherit;">Par cons√©quent, le modificateur </font></font><code>.rotationEffect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s'abonne pour recevoir animatableData dans l'intervalle de "√©tait" √† "est devenu", conform√©ment au temporisateur du syst√®me. </font><font style="vertical-align: inherit;">Nous en avons parl√© dans la derni√®re partie.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
       <span class="hljs-keyword">return</span> <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>))
            <span class="hljs-type">Spacer</span>()<font></font>
       }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/fl/dw/_0/fldw_0xguydvz5fe_-2tpcp3qkm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En ex√©cutant une animation sans fin de cette mani√®re, vous devez comprendre que toute modification ult√©rieure des modificateurs anim√©s la "cassera". </font><font style="vertical-align: inherit;">Par exemple, si apr√®s avoir d√©marr√©, pour une raison quelconque, vous changez la valeur de l'angle √† 0, vous obtenez cet effet:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ad/vi/iv/adviivgxhwuw0rwwv1itknh2kie.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi? La r√©ponse r√©side dans le m√©canisme d'animation de la transition d'une animation √† une autre. Dans notre exemple, lors de la premi√®re apparition de la vue √† l'√©cran, nous avons commenc√© une transition anim√©e de 0 √† 90. La vue ne stocke en fait que la valeur finale de 90 et la valeur d'origine de 0 n'est stock√©e nulle part. Le moteur d'animation conna√Æt la position temporelle actuelle de l'animation et la valeur actuelle de AnimatableData. Au point de temps 0,5, il sera 45. Que se passe-t-il si √† ce moment l'utilisateur change la valeur √† 0? R√©ponse: l'animation de changement de la valeur de 45 √† 0 va commencer. Tout est toujours en boucle. Mais seulement visuellement, le cycle n'est pas ferm√©, mais rompu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, dans certains cas, l'animation se "casse" si votre vue utilise @ObservedObject ou d'autres param√®tres qui provoquent un nouveau rendu de la vue. Pour r√©soudre ce probl√®me, le modificateur .animation a un param√®tre .animation (: value :). En passant la valeur, nous indiquons au moteur de rendu que le red√©marrage de l'animation n'est n√©cessaire que lorsque cette valeur change.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, d√©couvrons comment arr√™ter l'animation si nous n'en avons plus besoin. Pour ce faire, vous devez fournir deux choses. √âvidemment, nous devons dire √† SwiftUI que l'animation sans fin n'est plus n√©cessaire, en la rempla√ßant par la finale habituelle. Mais ce n'est pas assez. Le modificateur .animation () est une instruction sur les timings √† utiliser, mais la rotation elle-m√™me est d√©crite dans le modificateur .rotationEffect (), et elle est d√©j√† abonn√©e pour recevoir de nouvelles valeurs de l'angle de rotation par timer. Pour arr√™ter la rotation, nous devons √©galement modifier sa valeur.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animation)<font></font>
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.angle == <span class="hljs-number">90</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">self</span>.animation = .<span class="hljs-keyword">default</span>
                }<span class="hljs-keyword">else</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span>
                    <span class="hljs-keyword">self</span>.animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/-o/-d/ui/-o-dui_0ep12qm5zwovo2iedvjm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme auparavant, le changement de la valeur de l'angle a conduit au d√©but d'une nouvelle animation (qui avait l'air cass√©e), ce changement sera √©galement anim√©, mais maintenant avec les timings d'une animation normale. C'est pourquoi, notre carr√© cesse de tourner non pas instantan√©ment, mais comme avec un ralentissement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La m√™me chose peut √™tre √©crite un peu plus succinctement, si vous suspendez toutes les fonctionnalit√©s sur une </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable de type on / off:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isStarted = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jusque-l√†, tout √©tait relativement facile. Mais notez que tous les √©v√©nements ici sont g√©n√©r√©s √† l'int√©rieur de la vue. </font></font><code>.onAppear{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est appel√© par le syst√®me et </font></font><code>onTapGesture{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bien s√ªr, par l'utilisateur. Cependant, que se passe-t-il si vous souhaitez encapsuler l'int√©gralit√© de l'animation dans une seule vue, en la passant uniquement sous / hors tension? SwiftUI n'implique la possibilit√© d'aucune m√©thode parent √† partir de la vue parent. Th√©oriquement, vous pouvez stocker la vue enfant en tant que structure et appeler ses m√©thodes de mutation, mais les </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables de la vue enfant ne peuvent pas √™tre modifi√©es de cette fa√ßon, je l'ai essay√© - cela ne fonctionne pas. La seule fa√ßon de faire quelque chose comme √ßa est d'utiliser le PassthroughSubject de Combine, comme vous l'avez fait dans l'article. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, tout est beaucoup plus simple. S'il est clairement pos√© sur les √©tag√®res de la t√™te,</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> c'est l'√©tat interne de la vue, et n'essayant pas de la manipuler de l'ext√©rieur, la bonne solution sera tr√®s simple:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButtonFromOutside</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectParentView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isOn = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">AnimatedRectStopButtonFromOutside</span>(isStarted: isOn)
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isOn.toggle()<font></font>
            }<font></font>
        }.onAppear(){<font></font>
            <span class="hljs-keyword">self</span>.isOn = <span class="hljs-literal">true</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, nous n'avons pas besoin d'un </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abonnement pour mettre √† jour la vue √† l'int√©rieur de la vue enfant - elle est d√©j√† mise √† jour dans son ensemble lorsque le param√®tre externe √† elle change. </font><font style="vertical-align: inherit;">Parfois, ce n'est pas pratique. </font><font style="vertical-align: inherit;">Parfois, nous ne voulons pas initialiser √† nouveau la vue enfant - par exemple, afin de ne pas interrompre l'animation, ou dans init () certains calculs complexes et gourmands en ressources (requ√™tes, par exemple) se produisent. </font><font style="vertical-align: inherit;">Dans ces cas, il est pr√©f√©rable d'utiliser des entit√©s objet, dont les modifications peuvent √™tre surveill√©es √† l'aide du modificateur onReceive.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modification de l'√©tat lors de la mise √† jour de la vue</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a encore une chose qui m√©rite d'√™tre couverte. Nous avons op√©r√© avec seulement deux valeurs de 0 et 90 degr√©s. La d√©sactivation de l'animation r√©initialise l'angle √† 0. Mais est-il possible de suspendre l'animation juste au moment o√π nous avons cliqu√© sur le bouton et de la reprendre √† partir du m√™me endroit lors de la reprise? Regardons le code qui permet cela:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRect</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> externalStarted = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(started externalStarted: <span class="hljs-type">Bool</span>){
        <span class="hljs-keyword">self</span>.externalStarted = externalStarted
        <span class="hljs-keyword">self</span>._internalStarted = <span class="hljs-type">State</span>(initialValue: !externalStarted)<span class="hljs-comment">//forse to start animation</span><font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-comment">//thats wrong. It just hiding a problem from SwiftUI not solving it</span>
        <span class="hljs-type">DispatchQueue</span>.main.async {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted == <span class="hljs-literal">false</span>{
                <span class="hljs-comment">// print("stop animation")</span>
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">false</span>
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted {
             <span class="hljs-comment">//    print("start animation")</span>
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">true</span>
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
       }<font></font>
         <font></font>
       <span class="hljs-keyword">return</span>  <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.red)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(internalStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e9/ci/ge/e9cigegcoxid1l9skuw2qxle238.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'id√©e principale est de suivre l'heure au d√©but de l'animation. Apr√®s un certain temps, quand il nous appartiendra d'arr√™ter l'animation, nous pourrons v√©rifier combien de cycles d'animation complets se sont √©coul√©s, et deviner quel angle de rotation du carr√© que nous voyons en ce moment. Apr√®s cela, nous pouvons affecter </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exactement cette valeur √† la variable d'angle de rotation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour que cette approche fonctionne, nous devons suivre le d√©but et la fin de l'animation. Init () ne fonctionnera pas. Nous ne pouvons pas acc√©der aux </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param√®tres </font><font style="vertical-align: inherit;">existants </font><font style="vertical-align: inherit;">pour obtenir l'heure de d√©but pr√©c√©dente de l'animation. Ceci est un jeton de </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables. Dans init, vous ne pouvez d√©finir que l'√©tat initial de cette variable, mais √† la fin de l'initialisation, si View existait d√©j√† avant init (), la valeur des </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables sera restaur√©e.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par cons√©quent, ici le param√®tre let externalStarted est impl√©ment√© (que nous contr√¥lons de l'ext√©rieur), et le param√®tre </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interne var internalStarted, avec lequel nous contr√¥lons directement l'animation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il ne manquait qu'un seul - un modificateur qui v√©rifierait leur conformit√© et mettrait √† jour si n√©cessaire, comme .onRecieve (), seulement pour travailler avec chaque rendu. </font><font style="vertical-align: inherit;">Et puis j'ai pens√© - apr√®s tout, le corps est appel√© pour chaque dessin, alors pourquoi ne pas faire cette v√©rification directement dedans? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'est av√©r√© que SwiftUI jure beaucoup, si pendant le processus de rendu la vue change la valeur des </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables, elle donne</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La modification de l'√©tat lors de la mise √† jour de la vue entra√Ænera un comportement ind√©fini.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et bloque un tel changement. Ensuite, je suis all√© chercher un hack sale et j'ai utilis√© DispatchQueue.main.async. Mais voyons pourquoi c'est un sale hack, et pourquoi cela ne devrait-il jamais √™tre fait? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est en fait le probl√®me. Si nous √©crivons √† l'int√©rieur du corps une stupidit√© √©vidente comme i + = 1, o√π i est une sorte de</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable, alors nous obtenons une boucle infinie. Au moment du rendu, nous rendons la vue en m√©moire non pertinente, car nous avons modifi√© les donn√©es initiales pour le rendu. Cela signifie qu'imm√©diatement apr√®s la fin du rendu, notre vue sera mise en file d'attente pour un nouveau rendu, mais m√™me dans ce cas, nous la rendrons imm√©diatement non pertinente. Nous cr√©ons un cycle sans fin de nos propres mains. Un appel asynchrone dans ce cas ne change rien. Il ne d√©place que l√©g√®rement l'initiation du tour suivant au moment ¬´imm√©diatement apr√®s le rendu¬ª. Ainsi, un appel asynchrone ne r√©sout pas le probl√®me, mais le masque seulement, emp√™chant SwiftUI de nous piquer avec son nez. C‚Äôest comme dans une voiture l‚Äôampoule ¬´check engine¬ª est arrach√©e.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
D'une part, qu'est-ce qui ne va pas avec √ßa? Dans n'importe quel langage de programmation, il existe des tonnes de fa√ßons de se tirer une balle dans le pied si vous ne comprenez pas ce que vous faites. Mais d'un autre c√¥t√©, cette approche n'est pas du tout comment SwiftUI devrait fonctionner. Travailler avec View en runtime est mauvais. Oui, vous pouvez battre vos talons dans la poitrine, en veillant √† toujours √©crire le bon code qui ne se terminera jamais dans une boucle sans fin ... Mais c'est comme avec une r√©cup√©ration non s√©curis√©e d'une option - c'est juste une mauvaise pratique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme je l'ai d√©j√† dit, dans de tels cas, vous devez utiliser Combine, en passant une nouvelle valeur en utilisant PassthroughSubject. Mais vous pouvez vous d√©brouiller avec l'ObservableObjet habituel en vous abonnant √† son √©v√©nement willChange.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandlerTest</span>
    <span class="hljs-keyword">let</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandlerTest</span>){
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)<font></font>
       }.onReceive(animationHandler.objectWillChange){<font></font>
            <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
            <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                withAnimation(.<span class="hljs-keyword">none</span>){<span class="hljs-comment">//not working:(((</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
                }<font></font>
            }<span class="hljs-keyword">else</span> {
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
        }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span>
            <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le point controvers√© ici est l'utilisation des valeurs de l'objet lui-m√™me dans l'abonnement √† la notification que l'objet ne sera modifi√© que. </font><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, dans mes exemples, j'ai un objet d√©j√† modifi√©. </font><font style="vertical-align: inherit;">Apparemment, les notifications s'accompagnent d'un certain retard. </font><font style="vertical-align: inherit;">Mais je ne peux pas garantir que ce sera toujours le cas, donc je conseille d'utiliser les notifications didChange faites par vous-m√™me, ou PassthroughSubject, en passant la nouvelle valeur.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wj/ou/nd/wjoundfihtxhnar7iucx7rrkvnm.gif"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifications d'animation d'animation</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir sur le gif, l'animation ne s'arr√™te pas instantan√©ment. </font><font style="vertical-align: inherit;">Elle a besoin de temps. </font><font style="vertical-align: inherit;">En effet, lorsque nous attribuons une valeur interm√©diaire √† l'angle, nous utilisons √©galement une certaine animation - celle par d√©faut.</font></font><br>
<br>
<pre><code class="swift hljs">.animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela conduit √† un comportement inhabituel. </font><font style="vertical-align: inherit;">Malgr√© la relative simplicit√© de tout ce que je d√©cris, un tas de nuances d'interaction restent sous le capot afin que l'image soit toujours fluide, m√™me si le programmeur imprudent n'a rien indiqu√©. </font><font style="vertical-align: inherit;">Par cons√©quent, l'animation par d√©faut est le printemps. </font><font style="vertical-align: inherit;">Il est le plus appropri√© pour simuler les lois de la physique. </font><font style="vertical-align: inherit;">Et ceci est une animation assez courte, environ 0,2 seconde. </font><font style="vertical-align: inherit;">Si l'animation de la transition vers un nouvel √©tat (l'angle calcul√© et indiqu√© par nous) n'a pas le temps de s'adapter parfaitement √† la valeur par d√©faut de 0,2 seconde afin de passer de la vitesse d'animation actuelle avec un beau ralentissement √† un arr√™t complet, SwiftUI lui-m√™me ajoutera une autre boucle d'animation sans fin, jou√©e dans la version acc√©l√©r√©e.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z0/b0/so/z0b0soljlzjqudxhek_irdxgyoy.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour √©viter cela, il suffit de ne pas utiliser l'animation par d√©faut. </font><font style="vertical-align: inherit;">Pour le carr√© inf√©rieur, j'ai d√©sactiv√© l'animation d'arr√™t de rotation comme ceci:</font></font><br>
<br>
<pre><code class="swift hljs">                
.animation(animationHandler.isStarted ? animation : <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou, vous pouvez calculer plus pr√©cis√©ment la valeur requise du param√®tre au moment de l'arr√™t, mais pour cela, vous devez non seulement assumer approximativement le moment actuel de l'animation, mais le savoir exactement. </font><font style="vertical-align: inherit;">Je vais montrer ci-dessous comment proc√©der.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mouvement de plusieurs vagues dans une m√™me animation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retour √† l'animation arc-en-ciel. </font><font style="vertical-align: inherit;">Donc, nous avons les vagues elles-m√™mes, apprenons-leur √† bouger. </font><font style="vertical-align: inherit;">La premi√®re chose que je voudrais faire est de lancer une animation sans fin. </font><font style="vertical-align: inherit;">J'ai d√©cid√© de le faire de cette fa√ßon: j'aurai une </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable responsable de la position actuelle de l'animation. </font><font style="vertical-align: inherit;">√Ä l'√©tat 0, la premi√®re vague sera au tout d√©but et la derni√®re √† la toute fin. </font><font style="vertical-align: inherit;">Les vagues elles-m√™mes se chevaucheront. </font><font style="vertical-align: inherit;">Ainsi, la longueur de la partie visible de chaque vague d√©pendra du nombre d'ondes. </font><font style="vertical-align: inherit;">J'ai impl√©ment√© cela en utilisant ZStack, qui r√©pertorie toutes les vagues, et mon propre modificateur .wavePosition, √† l'int√©rieur duquel je calcule la position actuelle de chaque vague au moment de l'animation, et l'ordre dans lequel elles se chevauchent.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beaucoup de code</font></font></b>
                        <div class="spoiler_text"><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpWavePosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">let</span> wave: <span class="hljs-type">WaveDescription</span>
    <span class="hljs-keyword">let</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    <span class="hljs-keyword">var</span> time: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> currentPosition: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
                <span class="hljs-keyword">self</span>.time = newValue
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(wave: <span class="hljs-type">WaveDescription</span>, time: <span class="hljs-type">CGFloat</span>, animationHandler: <span class="hljs-type">AnimationHandler</span>){
        <span class="hljs-keyword">self</span>.wave = wave
        <span class="hljs-keyword">self</span>.time = time
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-number">0</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(forWave: Int, ofWaves: Int, overTime: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{<font></font>
<font></font>
        <span class="hljs-keyword">let</span> time = overTime - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(overTime))
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(ofWaves)
        <span class="hljs-keyword">let</span> initialPosition = oneWaveWidth * <span class="hljs-type">CGFloat</span>(forWave)
        <span class="hljs-keyword">let</span> currentPosition = initialPosition + time
        <span class="hljs-keyword">let</span> fullRounds = <span class="hljs-type">Int</span>(currentPosition)
        <span class="hljs-keyword">var</span> result = currentPosition - <span class="hljs-type">CGFloat</span>(fullRounds)
        <span class="hljs-keyword">if</span> fullRounds &gt; <span class="hljs-number">0</span> &amp;&amp; result == <span class="hljs-number">0</span>{
            <span class="hljs-comment">// at the end of the round it should be 1, not 0</span>
            result = <span class="hljs-number">1</span><font></font>
        }<font></font>
 <span class="hljs-comment">//       print("wave \(forWave) in time \(overTime) was at position \(result)")</span>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(wave.totalWavesCount)
        <span class="hljs-keyword">var</span> thisIsFirstWave = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> currentPosition &lt; oneWaveWidth{<font></font>
            thisIsFirstWave = <span class="hljs-literal">true</span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span>
            <span class="hljs-type">Group</span>{<font></font>
                content<font></font>
                            .offset(x: -wave.width + currentPosition * (wave.width +  wave.gradientLength),<font></font>
                            <span class="hljs-comment">//to watch how waves move uncoment this</span>
                           <span class="hljs-comment">// y: CGFloat(self.waveInd * 20))</span>
                        y:<span class="hljs-number">0</span>)<font></font>
                    .zIndex(-<span class="hljs-type">Double</span>(currentPosition))<font></font>
                    .transition(.identity)<font></font>
                    .animation(<span class="hljs-literal">nil</span>)<font></font>
<font></font>
                <span class="hljs-keyword">if</span> thisIsFirstWave{<font></font>
                    content<font></font>
                        .offset(x: wave.gradientLength, y: <span class="hljs-number">0</span>)<font></font>
                        .zIndex(-<span class="hljs-number">2</span>)<font></font>
                        .transition(.identity)<font></font>
                        .animation(<span class="hljs-literal">nil</span>)<font></font>
                }<font></font>
            }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">positionOfSharp</span><span class="hljs-params">(wave: WaveDescription, inTime: CGFloat, animationHandler: AnimationHandler)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">SharpWavePosition</span>(wave: wave, time: inTime, animationHandler: animationHandler))<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpRainbowView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">let</span> waves: [<span class="hljs-type">SharpGradientBorder</span>]
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> rainbowPosition: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandler</span>,<font></font>
        backgroundColor: <span class="hljs-type">Color</span> = .clear<font></font>
    ){<font></font>
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">let</span> bottomRadius = animationHandler.waveGeometry.bottomRadius
        <span class="hljs-keyword">let</span> topRadius = animationHandler.waveGeometry.topRadius
        <span class="hljs-keyword">let</span> gradientLength = animationHandler.waveGeometry.gradientLength
        <span class="hljs-keyword">let</span> rainbowColors = animationHandler.rainbowColors
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">var</span> lastColor = rainbowColors.last <span class="hljs-keyword">else</span> {<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"no colors to display in rainbow"</span>)}
        <span class="hljs-keyword">var</span> allWaves = [<span class="hljs-type">SharpGradientBorder</span>]()
        <span class="hljs-keyword">for</span> color <span class="hljs-keyword">in</span> rainbowColors{
            <span class="hljs-keyword">let</span> view = <span class="hljs-type">SharpGradientBorder</span>(start: color,<font></font>
                                      end: lastColor,<font></font>
                                      bottomRadius: bottomRadius,<font></font>
                                      topRadius: topRadius,<font></font>
                                      gradientLength: gradientLength)<font></font>
            allWaves.append(view)<font></font>
            lastColor = color<font></font>
        }<font></font>
        <span class="hljs-keyword">self</span>.waves = allWaves<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">VStack</span>{
                <span class="hljs-type">ZStack</span>{
                    <span class="hljs-type">ForEach</span>(<span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){ind <span class="hljs-keyword">in</span>
                        <span class="hljs-keyword">self</span>.waves[ind]<font></font>
                            .positionOfSharp(wave: <span class="hljs-type">WaveDescription</span>(ind: ind,<font></font>
                                                    totalWavesCount: <span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">count</span>,<font></font>
                                                    width: geometry.size.width,<font></font>
                                                    baseColor: <span class="hljs-keyword">self</span>.waves[ind].end,<font></font>
                                                    gradientLength: <span class="hljs-keyword">self</span>.waves[ind].bottomRadius + <span class="hljs-keyword">self</span>.waves[ind].topRadius),<font></font>
                                             inTime: <span class="hljs-keyword">self</span>.rainbowPosition,<font></font>
                                             animationHandler: <span class="hljs-keyword">self</span>.animationHandler)<font></font>
                            .animation(<span class="hljs-keyword">self</span>.animationHandler.isStarted ? <span class="hljs-keyword">self</span>.animation : .linear(duration: <span class="hljs-number">0</span>))<font></font>
                    }<font></font>
                }<font></font>
     <span class="hljs-comment">//           .clipped()</span><font></font>
            }<font></font>
<font></font>
        }<font></font>
        .onAppear(){<font></font>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.rainbowPosition = <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
        .onReceive(animationHandler.objectWillChange){<font></font>
             <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
             <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                <span class="hljs-keyword">let</span> newPosition = <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"animated from \(self.rainbowPosition - 1) to \(self.rainbowPosition) stopped at \(newPosition)"</span>)
                    <span class="hljs-keyword">self</span>.rainbowPosition = newPosition<font></font>
             }<span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">self</span>.rainbowPosition += <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
 </code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La premi√®re fois que la vue est affich√©e √† l'√©cran, nous changeons l'√©tat de 0 √† 1, ce qui, en tenant compte de l'animation lin√©aire d√©clar√©e, fait que les vagues courent √† l'infini autour de l'√©cran. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/vr/ym/bgvrymyoubpekjmpgnsrtxxgco8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque le bord de l'onde atteint le bord droit, sa position suivante sera au tout d√©but, au-del√† du bord de l'√©cran. Il semblera qu'il dispara√Ætra simplement de la fin de l'onde, exposant le substrat de fond, ce que nous aimerions √©viter. √Ä cet effet, le bloc if {...} est apparu dans le modificateur, dans la fonction body (), dans lequel une copie de la premi√®re onde manquante √† l'√©cran est dessin√©e.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/6m/vt/si6mvtiimlv73kxy4c4imperxc4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez noter que j'ai d√ª transf√©rer les caract√©ristiques g√©om√©triques de chaque vague sous forme de param√®tres modificateurs. </font><font style="vertical-align: inherit;">Le probl√®me √©tait que je devais red√©finir le z-index de chaque vague en fonction de la phase d'animation actuelle. </font><font style="vertical-align: inherit;">J'ai pu extraire la largeur de la r√©gion visible en utilisant le modificateur GeometryReader {} √† l'int√©rieur, cependant, j'√©tais confront√© au fait qu'il bloque le changement de l'ordre de superposition des vagues. </font><font style="vertical-align: inherit;">Le modificateur .zIndex () ne fonctionne que dans le contexte du premier conteneur ZStack {} dans la hi√©rarchie View. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GeometryReader interrompt cette connexion et zIndex () cesse de fonctionner. </font><font style="vertical-align: inherit;">Si jusqu'√† pr√©sent vous pensiez que GeometryReader est un moyen inoffensif d'obtenir des donn√©es sur la taille de la vue actuelle, ce n'est pas tout √† fait vrai.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animation de flux</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre point important est la compr√©hension de l'animation des modificateurs int√©gr√©s √† l'int√©rieur de vos propres modificateurs. √Ä un certain point, chaque vague s'approche du bord de l'√©cran, obtenant le d√©calage horizontal maximum, puis va √† la position de d√©part, obtenant le d√©calage minimum. Il s'agit du m√™me changement que tout autre, et il est anim√©, m√™me √† l'int√©rieur de l'animation. Apr√®s tout, l'animation n'est qu'un transfert de valeurs tr√®s fr√©quent vers le modificateur, et elle sera √©galement effectu√©e avec l'animation, peu importe √† quel point cela semble √©trange. Il s'av√®re qu'√† l'int√©rieur de l'animation, en passant une nouvelle valeur √† l'int√©rieur de ce modificateur, nous ne modifions que le point final de l'animation de mouvement en cours. Il s'av√®re que chaque vague, atteignant le bord de l'√©cran, se retourne et flotte en arri√®re. Mais il n'atteint pas non plus le d√©but, mais t√¥t ou tard il rattrape la position requise,puis recommence √† se d√©placer de gauche √† droite.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/aj/xp/ky/ajxpkyp6nxn-e6ixzzrv7y-g-c4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez r√©soudre ce probl√®me en ins√©rant le modificateur .animation (nil). Ainsi, je d√©sactive l'animation de tous les modificateurs appliqu√©s ci-dessus dans le texte. C'est la logique g√©n√©rale du travail de tout modificateur: il change ce qui est sur son entr√©e, et sur l'entr√©e nous avons le r√©sultat de tous les modificateurs pr√©c√©dents.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De mani√®re g√©n√©rale, toute une hi√©rarchie de diff√©rentes animations fonctionne ici. La valeur par d√©faut est celle qui sera utilis√©e pour afficher les modifications apport√©es √† tous les modificateurs, sauf indication contraire de votre vue. Nous avons un fil d'ex√©cution (disons que c'est principal), au sein duquel le corps est appel√©. Nous supposons qu'il a le param√®tre .animation, qui est v√©rifi√© chaque fois qu'un modificateur re√ßoit une nouvelle valeur. Si le modificateur prend en charge l'animation (conforme au protocole AnimatableModifier) ‚Äã‚Äãet que l'animation est activ√©e pour le flux (une animation sp√©cifique est utilis√©e, pas .none ou nil), la modification sera anim√©e. C'est ce que nous faisons, en enfermant du code pour changer les </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param√®tres dans le bloc withAnimation {} - nous prescrivons une certaine animation dans le thread courant, puis nous faisons une sorte de changement</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable. Dans ce cas, avecAnimation {}, il s'agit d'une sorte d'√©quivalent de transaction, et toutes les modifications apport√©es √† cette transaction seront anim√©es. Par cons√©quent, √† l'int√©rieur du m√™me flux, un cycle de traduction de ces modifications vers toutes les vues d√©pendantes d√©marre, les modificateurs de ces vues re√ßoivent une nouvelle valeur et s'abonnent pour recevoir des valeurs interm√©diaires d'AnimatableData. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, il y a des √©l√©ments sur l'animation sur lesquels vous ne pouvez pas influencer. Par exemple, la position du curseur est anim√©e par elle-m√™me, par des m√©canismes internes, et il n'y a rien √† faire √† ce sujet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, withAnimation () est un moyen de d√©marrer l'animation par d√©faut pour l'action en cours. Mais pour certaines vues, vous pouvez explicitement sp√©cifier votre propre animation √† l'aide du modificateur .animation (). Dans ce cas, les modificateurs et les formulaires qui composent le contenu transmis √† .animation () (tout ce qui est r√©pertori√© dans le code avant d'appliquer .animation ()) re√ßoivent le timing que vous d√©crivez et ignorent l'animation de flux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans mon modificateur WavePosition, j'utilise .animation (nil) pour me d√©barrasser de l'animation offset int√©gr√©e, me demandant ainsi d'ignorer l'animation actuelle du flux.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La m√™me histoire avec l'embout. Permettez-moi de vous rappeler les conclusions du dernier article. En fait, nous avons N structures de modificateur WavePosition dans notre m√©moire, une pour chaque vague. Et ils obtiennent tous une nouvelle valeur de position du minuteur du syst√®me, calculant la position de chaque onde √† un moment donn√©. Cela signifie que nous avons √©galement N embouts pour chaque vague. C'est juste qu'un seul d'entre eux est affich√© √† un moment donn√©, gr√¢ce au bloc if {}. Cependant, le m√™me bloc nous pond un cochon. La disparition et l'apparition de la vue s'effectuent √©galement avec l'animation du flux. Cela signifie que le modificateur .transition est utilis√© pour animer l'apparence et la disparition de la vue apr√®s avoir chang√© la condition. Habituellement, .opacity est utilis√© par d√©faut, mais pour une raison quelconque, .slide a √©t√© utilis√© √† ma place. Aucun des deux ne me convient, j'ai donc juste annul√© cette animation,en utilisant .transition (.identity).</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">upd. </font><font style="vertical-align: inherit;">Pendant que je pr√©parais l'article, Xcode 11.4 est sorti, dans lequel, il semble, la transition a √©t√© retravaill√©e par d√©faut. </font><font style="vertical-align: inherit;">Au moins maintenant, j'ai comment√© .transition (.identity) sans aucun probl√®me et je n'ai pas re√ßu le probl√®me qui m'a amen√© √† l'ajouter.</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Horaires d'animation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant, nous arrivons enfin √† la question la plus int√©ressante: comment faire acc√©l√©rer les vagues? </font><font style="vertical-align: inherit;">Comme d'habitude, je viendrai de loin.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, l'animation est une description de la vitesse d'une animation donn√©e. Nous pouvons d√©terminer l'itin√©raire du point A au point B √† l'int√©rieur du modificateur lui-m√™me, mais SwiftUI d√©cide quand et quel type de valeur AnimatableData lui passer. Il le fait avec une courbe de synchronisation. Supposons que nous prenons le point A comme origine et marquons le point B comme un point avec des coordonn√©es (1; 1). Horizontalement, nous marquerons le temps √©coul√© (le mouvement du point A au point B prend exactement 1 unit√© de temps). Vertical - la distance parcourue en fractions d'une unit√©. Lorsque nous utilisons une animation lin√©aire, nous obtenons directement. Si nous voulons obtenir un mouvement un peu similaire au pr√©sent, nous devons d'abord consacrer un peu de temps √† l'acc√©l√©ration et, finalement, au freinage. droit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez jouer avec diff√©rentes options en dessinant votre propre courbe et en comparant son animation de mouvement avec celles standard. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans SwiftUI, les courbes de B√©zier sont utilis√©es pour diff√©rents types d'animation. </font><font style="vertical-align: inherit;">Dans tous les cas, il doit commencer √† (0; 0) et se terminer √† (1; 1). </font><font style="vertical-align: inherit;">La courbure de la ligne est d√©termin√©e par les points de contr√¥le.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Courbe de synchronisation imbriqu√©e dans une animation lin√©aire sans fin</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors, que devons-nous faire pour obtenir le mouvement acc√©l√©r√© de chaque vague (easelIn) √† l'int√©rieur d'une animation en boucle lin√©aire? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'option la plus d√©taill√©e que j'ai pu trouver √©tait d'impl√©menter ma propre courbe de synchronisation et de convertir le flux lin√©aire de temps avec elle en une sorte de .easeIn. </font><font style="vertical-align: inherit;">Avec cet exemple, vous pouvez tr√®s bien comprendre comment cela fonctionne.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'id√©e est simple. Nous cr√©erons notre propre classe, bas√©e sur le chemin - la courbe de B√©zier avec laquelle nous d√©terminerons la distance entre le point A et le point B, qui doit √™tre affich√©e √† chaque point sp√©cifique dans le temps. En fait, c'est exactement comme cela que l'animation fonctionne dans SwiftUI, et dans tout autre framework avec des fonctionnalit√©s similaires. En utilisant une courbe de synchronisation, les secondes r√©elles et les millisecondes (qui s'√©coulent le plus souvent, n√©anmoins lin√©airement) sont converties en fractions de la distance (plus pr√©cis√©ment, les fractions du segment anim√© - le vecteur AnimatableData, qui repr√©sente le changement effectu√©). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici ma premi√®re impl√©mentation:</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getActualPosition</span><span class="hljs-params">(of position: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-keyword">let</span> correctPosition = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">min</span>(position, <span class="hljs-number">1</span>), <span class="hljs-number">0</span>) / duration
        <span class="hljs-keyword">let</span> trimmingCurve = <span class="hljs-type">TimingCurve</span>.superEaseInPath
        <span class="hljs-keyword">if</span> correctPosition &lt; <span class="hljs-number">0.0000001</span>{
            <span class="hljs-keyword">let</span> reversedCurve = <span class="hljs-type">Path</span>(<span class="hljs-type">UIBezierPath</span>(cgPath: trimmingCurve.cgPath).reversing().cgPath)
            <span class="hljs-comment">//trim to start point is impossible, so reverce the curve and get last point</span>
            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = reversedCurve.currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve start point"</span>)}
            <span class="hljs-keyword">return</span> point.y<font></font>
        }<font></font>
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = trimmingCurve.trimmedPath(from: <span class="hljs-number">0</span>, to: correctPosition).currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve point at \(position)"</span>)}
        <span class="hljs-keyword">return</span> point.y * <span class="hljs-keyword">self</span>.duration<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apparemment, j'√©tais un peu stupide. Par d√©finition, je dois trouver un point sur la courbe correspondant √† la valeur donn√©e de X et le retourner √† Y. Je n'ai pas pu trouver de m√©thode int√©gr√©e standard pour r√©soudre ce probl√®me, ou un mod√®le populaire, j'ai donc d√©cid√© d'adapter la m√©thode de trim existante √† ces fins ( ) J'ai d√©cid√© que je pouvais tr√®s bien reconsid√©rer l'approche, et obtenir le point souhait√© en obtenant la partie du chemin correspondant √† la fraction de la distance parcourue. Pour z√©ro, cette m√©thode renverra 0, pour 1 elle renverra 1, eh bien, au milieu, probablement, tout sera √©galement approximativement correct.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je savais qu'une telle approche ne donnerait pas un r√©sultat tr√®s pr√©cis, cependant, la gravit√© du probl√®me est apparue plus tard lorsque j'ai essay√© de reproduire exactement la m√™me animation de mani√®re standard. J'ai √©t√© surpris de voir √† quel point c'est diff√©rent et j'ai d√©cid√© de v√©rifier sur le graphique dans quelle mesure les points ainsi obtenus seront √©loign√©s de la courbe d'origine. Le r√©sultat ne m'a pas plu. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fl/ed/s-/fleds-cdj4f8ellnui32gn-kiyk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Non seulement les points sont √©loign√©s de la courbe souhait√©e, mais la nature m√™me de la courbe est d√©form√©e. Il y a un coude suppl√©mentaire, dont je n'ai pas besoin du tout. En cons√©quence, je devais encore trouver un moyen relativement pr√©cis de trouver un point sur une courbe de B√©zier, ne connaissant qu'une seule coordonn√©e:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai d√ª stocker en m√©moire de nombreux segments dont les extr√©mit√©s se situent sur une courbe donn√©e. Une recherche de Y par un X donn√© avec cette approche est une recherche du segment correspondant, sa division en deux, si n√©cessaire, jusqu'√† ce que l'une des fronti√®res d'un tel segment soit suffisamment proche du point souhait√©. Dans ce cas, nous trouvons le point avec la coordonn√©e X requise se trouvant sur ce segment et le renvoyons Y. Si vous connaissez des moyens plus simples de trouver un point se trouvant sur une courbe de B√©zier arbitraire, en utilisant une coordonn√©e donn√©e, √©crivez dans les commentaires. Je pense que cela peut √™tre utile √† beaucoup. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cons√©quence, les points sont assez proches du graphique:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/bk/qi/wxbkqitda0fmf516tl1vjarqgoq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai fait un objet singlton pour cr√©er une courbe de synchronisation pour les points de contr√¥le et mettre en cache le tableau des segments avec lesquels Y est recherch√©. Ainsi, tout ce dont j'ai besoin pour trouver un point sp√©cifique sur la courbe est de trouver le segment √† l'int√©rieur duquel ce point se trouvera, le diviser en deux jusqu'√† ce que l'une des extr√©mit√©s du segment soit suffisamment proche de ce point pour tomber dans l'erreur donn√©e, puis interpoler lin√©airement la valeur de Y le long du X donn√©, en rempla√ßant une partie de la courbe par ce segment. Je ne pr√©tends pas que c'est la meilleure fa√ßon, et que cela fonctionnera dans tous les cas. Encore une fois, √©crivez dans les commentaires si vous connaissez de meilleures fa√ßons.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec l'aide d'un tel outil, la transformation d'une animation lin√©aire en non lin√©aire devient simple. </font><font style="vertical-align: inherit;">Il suffit de d√©crire la courbe par deux points de contr√¥le et de recalculer la position sur le segment en fonction de cette courbe. </font><font style="vertical-align: inherit;">Si une animation de diff√©rentes dur√©es est requise, nous utilisons toujours une courbe unitaire utilisant le coefficient appropri√© pour la coordonn√©e X.</font></font><br>
<br>
<pre><code class="swift hljs">        
<span class="hljs-keyword">self</span>.timing = <span class="hljs-type">TimingCurve</span>.superEaseIn(duration: <span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> animatedPosition = timing.getY(onX: currentPosition)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici √† quoi ressemble l'animation, ainsi que notre courbe de synchronisation: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vf/f0/fe/vff0fe07bgvlvqhhuok5vy_w8ga.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour le code complet, bienvenue dans le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , regardez le fichier TimingCurveView. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s avoir compris cet exemple, vous comprendrez √† 100% comment les temporisations d'animation sont organis√©es. </font><font style="vertical-align: inherit;">Soit dit en passant, vous pouvez utiliser ces connaissances, car SwiftUI vous permet de cr√©er votre propre courbe de synchronisation pour les points de contr√¥le √† l'aide de la fonction timingCurve (), et de l'utiliser comme n'importe quelle autre animation.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transition</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous avons une animation sans fin tol√©rable. Il ne reste plus qu'√† comprendre comment il doit s'allumer et s'√©teindre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'id√©e d'animer l'apparence est de faire appara√Ætre le bloc d'animation √† l'endroit d√©j√† allum√©, mais le rideau en serait retir√©, comme un rideau dans le th√©√¢tre. Si nous synchronisons la vitesse du rideau avec la vitesse des vagues √† l'int√©rieur de l'animation, et dans le rideau lui-m√™me faisons un d√©grad√© de la couleur d'arri√®re-plan √† la couleur de la vague incidente actuelle, nous obtenons un effet visuel, comme si ce rideau est la premi√®re vague roulante. Pour synchroniser la vitesse du mouvement, nous utilisons simplement la m√™me courbe de synchronisation que pour animer le mouvement de la vague. Heureusement, nous savons maintenant comment proc√©der.</font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.timingCurve(<span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.y),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.y),<font></font>
                                duration: <span class="hljs-number">1</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animation.timingCurve (x: y :) vous permet de d√©finir votre propre timing d'animation en fonction des points de contr√¥le des courbes de B√©zier. </font><font style="vertical-align: inherit;">√Ä la sortie, nous obtenons un objet d'animation √† part enti√®re, comme le familier .linear (dur√©e: 1), qui peut √™tre utilis√© sans restrictions. </font><font style="vertical-align: inherit;">Et √©tant donn√© que j'utilise exactement les m√™mes points de contr√¥le pour l'animation d'onde, l'animation sera synchrone.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il serait plus pratique d'organiser le code ...</font></font></b>
                        <div class="spoiler_text">   .<br>
<br>
 ,           ,    ,          ‚Ä¶     ,     ,     .  -  ,        ‚Äî    .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La d√©sactivation de l'animation peut se faire de la m√™me mani√®re, seul le rideau doit se glisser sur le bloc d'animation, en le fermant progressivement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier probl√®me est survenu au moment o√π j'avais besoin d'obtenir l'√©tat actuel de l'animation pour choisir la couleur du rideau. </font><font style="vertical-align: inherit;">Pour ce faire, j'ai cr√©√© un ObservableObject, que je passe √† l'int√©rieur du modificateur, et que je change √† l'int√©rieur du setter AnimatableData. </font><font style="vertical-align: inherit;">Il est important de comprendre ici que changer la propri√©t√© @Published 60 fois par seconde n'est pas du tout ce dont vous avez besoin. </font><font style="vertical-align: inherit;">Voici comment changer les </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables √† l'int√©rieur d'un bloc de corps. </font><font style="vertical-align: inherit;">Nous n'avons pas besoin d'initier quoi que ce soit lorsque l'√©tat de l'animation change. </font><font style="vertical-align: inherit;">Mais si nous en avons besoin, nous pouvons d√©couvrir l'√©tat de l'animation √† tout moment.</font></font><br>
<br>
<pre><code class="swift hljs">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">if</span> animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.time = newValue
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.time != <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition{
                    <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition = <span class="hljs-keyword">self</span>.time<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)
            <span class="hljs-keyword">if</span> currentPosition &lt; <span class="hljs-number">0.01</span>{<font></font>
                animationHandler.currentWaveBaseColor = wave.baseColor<font></font>
            }<font></font>
        }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est pourquoi je ne me suis pas inscrit SharpRainbowView pour suivre les changements d'AnimationHendler: </font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour illustrer le fonctionnement de ces rideaux, je vais activer l'affichage de ce qui se passe en dehors de la vue en commentant .clipped (). De plus, je d√©placerai le rideau l√©g√®rement au-dessus de l'animation, pour plus de clart√©. Maintenant, c'est plus clair, non? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/uf/0k/6suf0klfghhgxj95qfnrxd29zpe.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les rideaux devaient √™tre courts pour que le chemin parcouru par chaque vague et rideau co√Øncide (sinon il se r√©v√©lerait √™tre d√©synchronis√© dans l'animation), mais en m√™me temps, elle a r√©ussi √† dispara√Ætre compl√®tement de l'√©cran. Dans le m√™me temps, le rideau est dispos√© comme un d√©grad√© de trois couleurs. Ceci est clairement visible sur le rideau de fermeture. C'est √† cause de la longue queue que j'aimais tant au d√©but.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fait est que la premi√®re onde est le gradient des derni√®res et premi√®res couleurs du r√©seau transmis. Aucun d'eux ne peut correspondre √† la couleur d'arri√®re-plan. Par cons√©quent, il y avait un besoin de rideaux en g√©n√©ral. Pour rendre le rideau bicolore, de la couleur d'arri√®re-plan √† la couleur de base de la premi√®re vague, la longueur du rideau m'a emp√™ch√©. Elle ne chevauche simplement pas la longue queue de la premi√®re vague, et une bordure d'une couleur est obtenue, et la queue d'une autre. Par cons√©quent, j'ai d√ª faire le rideau jusqu'√† trois couleurs - d'abord de l'arri√®re-plan √† la couleur de la derni√®re vague, puis de la couleur de la derni√®re vague √† la premi√®re. Ensuite, la queue de la premi√®re vague s'accorde bien avec la bordure du rideau.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour √† peu pr√®s les m√™mes raisons, ils ont √©galement fait le rideau de fermeture tricolore. Sinon, la fronti√®re ne semblait pas naturelle. Mais en cons√©quence, la premi√®re ¬´vague¬ª (et maintenant nous savons que c'est en fait le rideau d√©crit dans Transition.truncate) s'est av√©r√©e courte. Et bien qu'il se d√©place de mani√®re compl√®tement synchrone avec la premi√®re vague, c'est-√†-dire acc√©l√©r√©e et non lin√©aire, sa largeur ne change pas avec le temps, bien que la largeur des vagues suivantes augmente visuellement. Cela peut √™tre vaincu en changeant dynamiquement la largeur du rideau, mais j'√©tais franchement paresseux. Consid√©rons cela comme un devoir pour ceux qui veulent plonger dans ces m√©canismes et fumer un code (je m'excuse aupr√®s de ces personnes √† l'avance, il y a beaucoup de traces de mes exp√©riences qui peuvent vous d√©router).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un probl√®me. </font><font style="vertical-align: inherit;">Si vous appuyez sur le bouton √† un moment infructueux, le rideau de fermeture couvrira √† peine la vague suivante. </font><font style="vertical-align: inherit;">√áa n'a pas l'air tr√®s bien. </font><font style="vertical-align: inherit;">Vous pouvez r√©soudre le probl√®me en introduisant un l√©ger retard dans le masquage de la vue avec une animation. </font><font style="vertical-align: inherit;">Nous avons un moyen de conna√Ætre la position actuelle de l'animation, nous avons juste besoin de reporter un peu le d√©but de la transition, et la derni√®re vague sera toujours enti√®rement affich√©e.</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle animation"</span>).onTapGesture {<font></font>
                withAnimation(){<font></font>
                    <span class="hljs-keyword">var</span> delay: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.isShown{
                        <span class="hljs-keyword">let</span> waveChangeTime: <span class="hljs-type">Double</span> = <span class="hljs-type">Double</span>(<span class="hljs-number">1</span>) /  <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.rainbowColors.<span class="hljs-built_in">count</span>)
                        <span class="hljs-keyword">let</span> currentTime = <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition)
                        <span class="hljs-keyword">let</span> wavesPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(currentTime / waveChangeTime))<font></font>
                        delay =  (wavesPassed + <span class="hljs-number">1</span>) * waveChangeTime - currentTime<font></font>
                        delay = <span class="hljs-built_in">max</span>(delay - <span class="hljs-number">0.05</span>, <span class="hljs-number">0</span>)
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">"currentTime: \(currentTime); delay \(delay)"</span>)<font></font>
                    }<font></font>
                    <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + delay) {
                        <span class="hljs-keyword">self</span>.isShown.toggle()<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien s√ªr, vous pouvez √©galement rendre le rideau d'une largeur variable pour cr√©er l'illusion de diff√©rentes vitesses de la fronti√®re entre l'arri√®re-plan et le rideau, et le rideau et la premi√®re vague, mais maintenant la premi√®re vague semble un peu artificielle, mais je suis d√©j√† trop paresseux pour d√©ranger.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La transition aime doubler un cochon</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En g√©n√©ral, les animations d'apparition et de disparition, comme pour moi, sont un outil tr√®s cool. Mais il semble que ce concept soit nouveau et que tous les outils ne le g√®rent pas normalement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, le modificateur .rotation3DEffect () inverse avec succ√®s la vue avec des animations complexes √† l'int√©rieur, mais il ne sait pas comment inverser .transition. C'√©tait tellement d√©cevant d'√©crire un code concis, de voir comment vos vagues se dispersent loin du centre de l'√©cran, puis de voir qu'√† gauche Voir les rideaux courir de gauche √† droite. J'ai d√ª √©crire un tas de passe-partout, pour que le modificateur de transition puisse fonctionner dans les deux sens.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pn/3c/fg/pn3cfg8f6zsersnfgdv5_ixrqu8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, le modificateur drowingGroup (), avec lequel vous pouvez connecter Metal pour transf√©rer au GPU un rendu ZStack avec un grand nombre de vues imbriqu√©es, en particulier de vues avec d√©grad√©s, ne sait pas comment effectuer la transition. </font><font style="vertical-align: inherit;">Il ne comprend pas l'animation d'apparition et de disparition que vous d√©crivez et la remplace par la sienne.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais comment cacher la barre d'√©tat?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tr√®s simple. SwiftUI a le modificateur .statisBar (cach√© :). Voici juste l'api pour contr√¥ler la transition pour la barre d'√©tat que SwiftUI ne fournit pas. Pour ce faire, nous devrons profiter des capacit√©s d'UIKit. Le fichier SceneDelegate utilise UIHostingController pour transformer la vue SwiftUI en UIKit ViewController. C'est √† ce stade qu'il est plus pratique d'utiliser certaines fonctions UIKit globales, comme travailler avec la barre d'√©tat ou d√©sactiver les gestes syst√®me associ√©s au bord de l'√©cran (PreferredScreenEdgesDeferringSystemGestures). Vous pouvez h√©riter de UIHostingController en rempla√ßant les valeurs de certaines propri√©t√©s syst√®me et utiliser ce descendant pour passer votre vue √† rootViewController. Malheureusement, seul un nombre limit√© de transitions peut accepter une barre d'√©tat: .fade, .slide et .none. La valeur par d√©faut est fade,et il convient mieux ici, alors laissez-le tel quel. Esp√©rons que cette fonctionnalit√© sera encore √©tendue.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin de synchroniser le masquage et l'apparence de la barre d'√©tat avec le mouvement de la vague, j'ai cr√©√© une vue s√©par√©e, √† l'int√©rieur de laquelle je change la valeur de ce param√®tre avec une pause:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarHider</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isShown: <span class="hljs-type">Bool</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalIsShown = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">true</span>{
            <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="hljs-number">0.7</span>){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">false</span>{
            <span class="hljs-type">DispatchQueue</span>.main.async(){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-type">Spacer</span>()<font></font>
            .statusBar(hidden: internalIsShown)<font></font>
            .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0.3</span>))<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, un simple Spacer () est form√© ici, dont j'avais d√©j√† besoin, mais le modificateur statusBar est enroul√© dessus. En g√©n√©ral, bien s√ªr, il √©tait illogique pour Apple de fournir cette fonctionnalit√© aux modificateurs, comme cela ne s'applique pas √† la vue sp√©cifique que vous modifiez, mais apparemment n'a tout simplement pas compris comment mieux faire. Beaucoup plus int√©ressant en est un autre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il utilise le m√™me hack sale que nous avons consid√©r√© pr√©c√©demment: √† l'int√©rieur du corps, j'ex√©cute quelques actions en runtime, tout en changeant la valeur de la </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable. La logique dans son ensemble est la m√™me, il y a un param√®tre de structure qui est transmis de l'ext√©rieur et une </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable qui est modifi√©e apr√®s un certain temps, ce qui fait dispara√Ætre ou appara√Ætre la barre d'√©tat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, j'avais besoin de ce hack car le contr√¥le de l'animation de la barre d'√©tat est une fonctionnalit√© UIKit qui est encore assez mal d√©velopp√©e dans SwiftUI. </font><font style="vertical-align: inherit;">En th√©orie, je visserais l'animation de d√©marrage diff√©r√© au modificateur .statusBar (cach√© :), mais cela ne fonctionne pas. </font><font style="vertical-align: inherit;">L'animation de masquage et l'apparence de la barre d'√©tat sont fixes et ne peuvent pas √™tre modifi√©es par SwiftUI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, rien ne m'a emp√™ch√© de faire le m√™me changement de mani√®re asynchrone avec le d√©lai souhait√©, pas dans cette vue, mais dans le parent, m√™me lorsque l'utilisateur a cliqu√© sur le bouton - mais laissons cela comme un monument √† mes tentatives pour comprendre ce qui est (et une raison de plus pour le dire que cela ne devrait pas √™tre fait).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et comment la taille et la position de la barre d'√©tat ont-elles √©t√© int√©gr√©es √† @Environment?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
@Environment (√† ne pas confondre avec @EnvironmentObject) est un wrapper qui donne acc√®s √† une liste fixe de variables qui refl√®tent l'environnement de notre application. Par exemple, l'orientation de l'√©cran ou le th√®me de couleur du syst√®me d'exploitation. Le m√™me wrapper permet √† votre vue d'√™tre abonn√©e pour modifier ces param√®tres. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette liste peut √™tre √©tendue. J'ai pens√© qu'avoir @Environment avait acc√®s √† la taille et √† la position de la barre d'√©tat serait juste. Voici comment je l'ai fait:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarFrame</span>: <span class="hljs-title">EnvironmentKey</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> defaultValue: <span class="hljs-type">CGRect</span> {
        <span class="hljs-type">CGRect</span>()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">EnvironmentValues</span> </span>{
    <span class="hljs-keyword">var</span> statusBarFrame: <span class="hljs-type">CGRect</span>{
        <span class="hljs-keyword">get</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>]<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>] = newValue<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai cr√©√© une structure avec une valeur statique par d√©faut. </font><font style="vertical-align: inherit;">Ensuite, j'ai d√©velopp√© la structure du syst√®me SystemValues ‚Äã‚Äãen ajoutant ma propre propri√©t√© calcul√©e, dont le getter et le setter font r√©f√©rence au type que j'ai cr√©√©. </font><font style="vertical-align: inherit;">Le type est utilis√© ici, car EnvironmentValues ‚Äã‚Äãimpl√©mente un indice dans lequel vous passez le type et obtenez la valeur stock√©e correspondant √† ce type. </font><font style="vertical-align: inherit;">Pas la valeur de ce type, mais la valeur stock√©e dans le dictionnaire conditionnel, o√π le type lui-m√™me est la cl√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La valeur dans @Environment est accessible √† l'aide de keyPath \ .statusBarFrame. </font><font style="vertical-align: inherit;">Par exemple, pour transmettre la valeur d'environnement √† tous les affichages dans la hi√©rarchie:</font></font><br>
<br>
<pre><code class="swift hljs">.environment(\.statusBarFrame, statusBarFrame) 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et dans la vue elle-m√™me pour r√©cup√©rer la valeur du magasin:</font></font><br>
<br>
<pre><code class="swift hljs">@<span class="hljs-type">Environment</span>(\.statusBarFrame) <span class="hljs-keyword">var</span> statusBarframe: <span class="hljs-type">CGRect</span> 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, pour travailler avec la barre d'√©tat dans l'objet UIWindowScene dans IOS 13, l'attribut statusBarManager est apparu. </font><font style="vertical-align: inherit;">Certains param√®tres peuvent en √™tre tir√©s. </font><font style="vertical-align: inherit;">Mais maintenant, vous ne pouvez plus les g√©rer. </font><font style="vertical-align: inherit;">Si je comprends bien, il √©tait auparavant possible d'acc√©der √† la barre d'√©tat de ViewController et d'y ajouter une sous-vue. </font><font style="vertical-align: inherit;">Apparemment, ils ont ferm√© le banc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De mani√®re g√©n√©rale, je transf√©rerais la fonctionnalit√© du modificateur .statusBar (cach√© :) exactement ici, ici ce serait plus appropri√©, comme pour moi. </font><font style="vertical-align: inherit;">Je pense que t√¥t ou tard, les d√©veloppeurs arriveront √† ce point.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, je pense que sur cet exemple fascinant, une excursion dans l'animation √† l'aide des outils SwiftUI peut √™tre consid√©r√©e comme compl√®te. √Ä l'aide d'exemples simples, j'ai parl√© des principaux outils d'animation, expliqu√© comment ils fonctionnent exactement sous le capot, comment ils devraient √™tre utilis√©s et pourquoi exactement. En utilisant des exemples plus complexes, j'ai montr√© les difficult√©s typiques que vous pouvez rencontrer et les moyens de les surmonter.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mon code, par rapport √† l'exemple de l'article ci-dessus, est-il plus propre, plus clair, plus court ou peut-√™tre plus facile √† entretenir? Peut-√™tre pas. Consomme-t-il moins de ressources? H√©las non. Peut-√™tre que mon approche est plus universelle, mais ce n'est pas exact. Cependant, il y a une t√¢che qu'il accomplit certainement mieux. Il illustre bien plus en profondeur le fonctionnement de SwiftUI sous le capot. Avec lui, vous pouvez mettre l'animation sur les √©tag√®res dans votre t√™te et l'appliquer librement dans vos applications.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUI est activement sci√©. </font><font style="vertical-align: inherit;">M√™me maintenant, deux semaines apr√®s avoir √©crit le code du premier article, maintenant, en v√©rifiant le code sur la version actuelle de Xcode, je vois comment certains bugs que j'ai d√ª contourner ont d√©j√† √©t√© corrig√©s. </font><font style="vertical-align: inherit;">Par cons√©quent, je suis rest√© un peu avec l'article. </font><font style="vertical-align: inherit;">Quelque chose a d√ª √™tre coup√© pour non-pertinence, et tout le reste - pour rev√©rifier. </font><font style="vertical-align: inherit;">Et √ßa fait plaisir. </font><font style="vertical-align: inherit;">SwiftUI est d√©finitivement l'avenir du d√©veloppement natif d'iOS, et il est tr√®s instructif de se tenir √† ses origines et d'observer comment il se d√©veloppe.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âpilogue</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le processus de pr√©paration du mat√©riel pour cet article, j'ai √©galement mis beaucoup de choses dans ma t√™te dans ma t√™te. </font><font style="vertical-align: inherit;">J'ai d√©couvert beaucoup de nuances dont je n'avais aucune id√©e quand j'ai commenc√© √† l'√©crire. </font><font style="vertical-align: inherit;">Par cons√©quent, j'exhorte tous ceux qui ont d√©j√† une exp√©rience dans le d√©veloppement SwiftUI - ne soyez pas timide, partagez votre exp√©rience et vos connaissances. </font><font style="vertical-align: inherit;">Ceci est tr√®s utile √† la fois pour la communaut√© et pour l'exhaustivit√© de vos propres connaissances. </font><font style="vertical-align: inherit;">C'est plus cool que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la m√©thode du caneton</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et il est √©galement n√©cessaire de formuler la r√©ponse. </font><font style="vertical-align: inherit;">L'essentiel est de ne pas √™tre paresseux √† chercher une telle r√©ponse pour que ce ne soit pas g√™nant pour les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gar√ßons de se montrer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr506648/index.html">Laravel Digest (8-14 juin 2020)</a></li>
<li><a href="../fr506658/index.html">GitLab 13.0 publi√© avec les clusters Gitaly, la hi√©rarchie √©pique sur les feuilles de route et le d√©ploiement automatique pour ECS</a></li>
<li><a href="../fr506662/index.html">Partition adaptative des courbes de B√©zier d'ordre 2 et 3</a></li>
<li><a href="../fr506664/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 419 (8-14 juin 2020)</a></li>
<li><a href="../fr506666/index.html">Textures ORM, mais √ßa vaut le coup?</a></li>
<li><a href="../fr506676/index.html">Qatar: centre mondial des greffes et ville nocturne</a></li>
<li><a href="../fr506680/index.html">.NET Core vs Node.js. Arguments et faits</a></li>
<li><a href="../fr506684/index.html">Comment j'ai transf√©r√© dedic.ru sur les pages github et j'ai √©t√© satisfait</a></li>
<li><a href="../fr506686/index.html">√âv√©nements num√©riques √† Moscou du 15 au 21 juin</a></li>
<li><a href="../fr506688/index.html">√âv√©nements num√©riques √† Saint-P√©tersbourg du 15 au 21 juin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>