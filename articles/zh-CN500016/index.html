<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎬 🤑 🍹 Redd集中的FPGA的实际工作。掌握用于Avalon-ST总线的DMA以及在Avalon-MM总线之间进行切换 🔑 🗜️ 👩🏼‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们将继续朝着基于Redd FPGA复合体创建真实设备的方向发展。对于另一个全硬件项目，我需要一个简单的逻辑分析器，因此我们将朝着这个方向发展。幸运-进入USB总线分析仪（但是从长远来看，这仍然是可行的）。任何分析仪的核心都是RAM，它是先将数据上传到RAM然后再检索的单元。今天我们将设计它。
 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Redd集中的FPGA的实际工作。掌握用于Avalon-ST总线的DMA以及在Avalon-MM总线之间进行切换</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500016/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将继续朝着基于Redd FPGA复合体创建真实设备的方向发展。</font><font style="vertical-align: inherit;">对于另一个全硬件项目，我需要一个简单的逻辑分析器，因此我们将朝着这个方向发展。</font><font style="vertical-align: inherit;">幸运-进入USB总线分析仪（但是从长远来看，这仍然是可行的）。</font><font style="vertical-align: inherit;">任何分析仪的核心都是RAM，它是先将数据上传到RAM然后再检索的单元。</font><font style="vertical-align: inherit;">今天我们将设计它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，我们将控制DMA模块。</font><font style="vertical-align: inherit;">通常，DMA是我最喜欢的主题。</font><font style="vertical-align: inherit;">我什至</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在一些ARM控制器上写了一篇有关DMA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的精彩</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">文章</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">从那篇文章中可以明显看出，DMA从总线上获取时钟周期。</font><font style="vertical-align: inherit;">在当前文章中，我们将考虑基于FPGA的处理器系统的运行情况。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cg/77/ve/cg77velzruiaao4svcvahmuumse.png"><br>
<a name="habracut"></a><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上一周期文章</font></font></b>
                        <div class="spoiler_text"><ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为Redd中安装的FPGA开发最简单的“固件”，并以内存测试为例进行调试。</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  «»  ,   Redd.  2.  .</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">          .</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">     Redd     .</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">              Redd.</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> ,       .</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    Redd.  1:  .</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    Redd.  2:      .</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  :        .</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    Redd,    FTDI</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">     Redd</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">       Redd</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> USB-  Windows 10   </a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   Nios II    Nios II</a></li>
</ol><br>
</div>
                    </div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硬件创作</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们开始创建硬件。为了了解DMA块与时钟周期有多少冲突，我们将需要在Avalon-MM总线（Avalon Memory-Mapped）上的高负载下进行准确的测量。我们已经</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发现</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，Altera JTAG至Avalon-MM桥无法提供高总线负载。因此，今天我们必须在系统中添加一个处理器内核，以便它可以高速访问总线。如何做到这一点已经说明</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。为了达到最佳效果，让我们为处理器核心禁用两个缓存，但是创建一个强连接的总线，如此</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处所示</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4z/a8/xx/4za8xxe_btr14mdgfjmzhpwxusi.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
添加8 KB的程序存储器和数据存储器。请记住，内存必须是双端口的，并且地址必须在特定范围内（为防止其跳转，锁定，我们在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">讨论了其原因</font><font style="vertical-align: inherit;">）。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/kp/km/3v/kpkm3vhuov70qf9zgfl89njhqum.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们已经创建了该项目一千次，因此在创建过程中没有什么特别有趣的（如果有的话，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述了创建项目的所有步骤</font><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基地准备好了。现在，我们需要一个数据源，将其放入内存中。理想的事情是一个不断计时的计时器。如果在某种程度上DMA块无法处理数据，那么我们将立即通过丢失的值看到它。好吧，也就是说，如果内存中有值1234和1236，则意味着在时钟上，当计时器发出1235时，DMA块没有传输数据。建立档案</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Timer_ST.sv</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有以下简单计数器：</font></font><br>
<br>
<pre><code class="plaintext hljs">module Timer_ST (<font></font>
  input              clk,<font></font>
  input              reset,<font></font>
	<font></font>
  input  logic       source_ready,<font></font>
  output logic       source_valid,<font></font>
  output logic[31:0] source_data<font></font>
	<font></font>
);<font></font>
    logic [31:0] counter;<font></font>
    always @ (posedge clk, posedge reset)<font></font>
    if (reset == 1)<font></font>
    begin<font></font>
        counter &lt;= 0;<font></font>
    end else<font></font>
    begin<font></font>
        counter &lt;= counter + 1;<font></font>
    end<font></font>
<font></font>
    assign source_valid = 1;<font></font>
    assign source_data [31:24] = counter [7:0];<font></font>
    assign source_data [23:16] = counter [15:8];<font></font>
    assign source_data [15:8] = counter [23:16];<font></font>
    assign source_data [7:0] = counter [31:24];<font></font>
<font></font>
endmodule<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这个计数器就像一个先驱：它总是准备就绪（在输出</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">source_valid</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">始终为1），并且始终计数（复位状态时刻除外）。</font><font style="vertical-align: inherit;">为什么模块恰好具有这些信号-我们</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本文中进行</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了讨论</font><font style="vertical-align: inherit;">。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们创建自己的组件（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">了</font></a><font style="vertical-align: inherit;">如何完成</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">自动化为我们错误地选择了Avalon_MM总线。</font><font style="vertical-align: inherit;">替换为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avalon_streaming_source</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并映射信号，如下所示：</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/to/u1/fb/tou1fbktluymact4id-sxeca5qq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好极了。</font><font style="vertical-align: inherit;">将我们的组件添加到系统中。</font><font style="vertical-align: inherit;">现在我们正在寻找DMA块...我们发现不是一个，而是三个。</font><font style="vertical-align: inherit;">所有这些都在</font><font style="vertical-align: inherit;">Altera </font><font style="vertical-align: inherit;">的文档《</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">嵌入式外围设备IP用户指南》中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行了描述</font><font style="vertical-align: inherit;">（与往常一样，我给出名称，但没有给出链接，因为链接总是会变化）。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/0q/a9/lo/0qa9lo90au55qrl5-02u3py-bb8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用哪一个？我无法抗拒怀旧之情。早在2012年，我就建立了一个基于PCIe总线的系统。 Altera的所有手册均包含基于这些模块中第一个模块的示例。但是他使用PCIe组件的速度不超过每秒4兆字节。在那些日子里，我吐口水并写了我的DMA块。现在我不记得他的速度了，但是他将SATA驱动器中的数据驱动到了当时驱动器和SSD的能力极限。也就是说，我已经在此块上磨了一下牙。但是，我不会对这三个方面进行比较。事实上，今天我们必须使用基于Avalon-ST（Avalon流接口）的源，并且只有</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modular Scatter-Gather DMA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">块支持此类源</font><font style="vertical-align: inherit;">。在这里，我们将其放在图表上。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在块设置中，选择模式</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流到内存映射</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。另外-我想从启动到填充SDRAM来驱动数据，因此我将最大数据传输单位从1 KB替换为4 MB。没错，我被警告说，最后，FMax参数不会太热（即使您将最大块替换为2 KB）。但是对于今天，FMax是可以接受的（104 MHz），然后我们将其找出来。我保持其余参数不变。您还可以将传输模式设置为“仅全字访问”，这会将FMax增大到109 MHz。但是我们今天不会为性能而战。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/u6/1y/8-/u61y8-h-wpei03u3xgkjsjtuurs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所以。源是DMA。接收器... SDRAM？在未来的战斗条件下，是的。但是今天，我们需要具有已知特征的记忆。不幸的是，SDRAM需要定期发送占用几个时钟周期的命令，而且此内存可能会被重新占用。因此，我们现在将使用内置的FPGA存储器代替它。一切都一步一步为她工作，没有不可预测的延迟。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于SDRAM控制器是单端口的，因此内置存储器也可以专门用于单端口模式。这很重要。事实是，我们要使用DMA块主控器写入存储器，但另一方面，我们要使用处理器内核或Altera JTAG-to-Avalon-MM块从该存储器读取。手伸出来，将读写块连接到两个不同的端口上……但是你做不到！相反，问题的条件禁止这样做。因为今天是可能的，但明天我们将用专用的单端口内存代替它。通常，我们得到这样一个由三个部分组成的块（计时器，DMA和内存）：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vb/ws/rv/vbwsrvdbjsns34syktoliarkudy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，纯粹出于形式上的考虑，我将UT和sysid添加到JTAG系统中（尽管第二个系统没有帮助，无论如何我仍然不得不使用JTAG适配器）。</font><font style="vertical-align: inherit;">这是什么，以及它们的添加如何解决小问题，我们已经进行了研究。</font><font style="vertical-align: inherit;">我不会给轮胎上色，轮胎一切都很好。</font><font style="vertical-align: inherit;">只需展示一下项目中的外观即可：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t5/xk/qv/t5xkqv474idlwer3fnklkz5whbs.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就是这样。</font><font style="vertical-align: inherit;">系统准备就绪。</font><font style="vertical-align: inherit;">我们分配地址，分配处理器向量，生成系统（不要忘记您需要使用与项目本身相同的名称进行保存，然后它将进入层次结构的顶层），将其添加到项目中。</font><font style="vertical-align: inherit;">使</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重置</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">支脚</font><font style="vertical-align: inherit;">虚拟，将</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clk</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连接</font><font style="vertical-align: inherit;">到</font><b><font style="vertical-align: inherit;">pin_25</font></b><font style="vertical-align: inherit;">支脚</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们正在组装该项目，将其倒入设备中……由于总的偏僻位置，在空荡荡的办公室里，这是多么可怜的事情？..对她来说，这很孤独又令人恐惧，也许是一个...但是我分心了。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建软件零件</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">训练</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在BSP编辑器中，随着手的通常动作，我打开了C ++支持。</font><font style="vertical-align: inherit;">我经常插入这种情况的屏幕截图，以至于我停止这样做。</font><font style="vertical-align: inherit;">但是，尽管已经看到了另一个屏幕截图，但仍然如此普遍。</font><font style="vertical-align: inherit;">因此，让我们再讨论一次。</font><font style="vertical-align: inherit;">我们记得系统正在尝试将数据放入最大的内存中。</font><font style="vertical-align: inherit;">这就是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buffer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，我们将所有内容强制为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ck/ge/g_/ckgeg_tcmcuz0oa8retrmdrfiiw.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序实验</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们编写的代码只是用源的内容填充内存（以计数器的角色）。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看代码</font></font></b>
                        <div class="spoiler_text"><pre><code class="plaintext hljs">#include "sys/alt_stdio.h"<font></font>
#include &lt;altera_msgdma.h&gt;<font></font>
#include &lt;altera_msgdma_descriptor_regs.h&gt;<font></font>
#include &lt;system.h&gt;<font></font>
#include &lt;string.h&gt;<font></font>
<font></font>
int main()<font></font>
{ <font></font>
  alt_putstr("Hello from Nios II!\n");<font></font>
<font></font>
  memset (BUFFER_BASE,0,BUFFER_SIZE_VALUE);<font></font>
<font></font>
  //  ,   <font></font>
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(MSGDMA_0_CSR_BASE,<font></font>
      ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);<font></font>
<font></font>
  //   ,      ,<font></font>
  //    ,   .  .<font></font>
<font></font>
  //    FIFO<font></font>
  IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(MSGDMA_0_DESCRIPTOR_SLAVE_BASE,<font></font>
      (alt_u32)0);<font></font>
  IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(MSGDMA_0_DESCRIPTOR_SLAVE_BASE,<font></font>
      (alt_u32)BUFFER_BASE);<font></font>
  IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(MSGDMA_0_DESCRIPTOR_SLAVE_BASE,<font></font>
      BUFFER_SIZE_VALUE);<font></font>
  IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(MSGDMA_0_DESCRIPTOR_SLAVE_BASE,<font></font>
      ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK);<font></font>
<font></font>
   //  ,    <font></font>
   IOWR_ALTERA_MSGDMA_CSR_CONTROL(MSGDMA_0_CSR_BASE,<font></font>
       ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK<font></font>
       &amp; (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)<font></font>
       &amp;(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;<font></font>
<font></font>
<font></font>
   //   <font></font>
   static const alt_u32 errMask = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |<font></font>
           ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |<font></font>
           ALTERA_MSGDMA_CSR_STOP_STATE_MASK |<font></font>
           ALTERA_MSGDMA_CSR_RESET_STATE_MASK;<font></font>
<font></font>
  volatile alt_u32 status;<font></font>
  do<font></font>
  {<font></font>
     status = IORD_ALTERA_MSGDMA_CSR_STATUS(MSGDMA_0_CSR_BASE);<font></font>
  } while (!(status &amp; errMask) &amp;&amp;(status &amp; ALTERA_MSGDMA_CSR_BUSY_MASK));     <font></font>
<font></font>
  alt_putstr("You can play with memory!\n");<font></font>
<font></font>
  /* Event loop never exits. */<font></font>
  while (1);<font></font>
<font></font>
  return 0;<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们开始，我们等待消息</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“您可以玩记忆！”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将程序置于暂停状态，并从地址0开始查看内存。起初，我很害怕：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rw/yd/kb/rwydkbfypprtgoj5wspybiq3sv8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从地址0x80开始，计数器急剧改变其值。而且，数量非常大。但是事实证明一切都很好。在我们这里，计数器永不停止且始终处于就绪状态，并且DMA具有自己的预读队列。让我提醒您DMA块的设置：</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/ty/hk/-6/tyhk-610qcr5r-jpmrr2dnxz4wg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0x80字节是0x20的32位字。</font><font style="vertical-align: inherit;">仅32位小数。</font><font style="vertical-align: inherit;">都适合。</font><font style="vertical-align: inherit;">在调试条件下，这并不可怕。</font><font style="vertical-align: inherit;">在战斗条件下，源将更正确地工作（其准备状态将被重置）。</font><font style="vertical-align: inherit;">因此，我们只是忽略此部分。</font><font style="vertical-align: inherit;">在其他区域，仪表按顺序计数。</font><font style="vertical-align: inherit;">我将仅显示转储片段的宽度。</font><font style="vertical-align: inherit;">用我完整检查过的一个词。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pw/hg/eq/pwhgeqyxbian3_fg-m46yliilrk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我不相信自己的眼睛，而是编写了一个代码来自动检查数据：</font></font><br>
<br>
<pre><code class="plaintext hljs">  volatile alt_u32* pData = (alt_u32*)BUFFER_BASE;<font></font>
  volatile alt_u32 cur = pData[0x10];<font></font>
  int nLine = 0;<font></font>
  for (volatile int i=0x11;i&lt;BUFFER_SIZE_VALUE/4;i++)<font></font>
  {<font></font>
	  if (pData[i]!=cur+1)<font></font>
	  {<font></font>
		  alt_printf("Problem at 0x%x\n",i*4);<font></font>
		  if (nLine++ &gt; 10)<font></font>
		  {<font></font>
			  break;<font></font>
		  }<font></font>
	  }<font></font>
	  cur = pData[i];<font></font>
  }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他也没有透露任何问题。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">试图发现至少一些问题</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，没有问题并不总是一件好事。</font><font style="vertical-align: inherit;">作为文章的一部分，我需要找到问题，然后说明如何解决这些问题。</font><font style="vertical-align: inherit;">毕竟，问题很明显。</font><font style="vertical-align: inherit;">繁忙的总线无法立即传递数据！</font><font style="vertical-align: inherit;">应该有延迟！</font><font style="vertical-align: inherit;">但是，让我们检查一下为什么一切如此美好。</font><font style="vertical-align: inherit;">首先，可能会发现整个过程都在DMA块的FIFO中。</font><font style="vertical-align: inherit;">将它们的大小减小到最小：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z3/vm/9i/z3vm9igmqgqcgynhiyzu-9dr7ss.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一切继续进行！</font><font style="vertical-align: inherit;">好。</font><font style="vertical-align: inherit;">确保我们引起对总线的访问数量大于FIFO维度。</font><font style="vertical-align: inherit;">添加点击计数器：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fa/f4/iq/faf4iqvpkc4ezbvhdz4uhpnrbjo.png"><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同的文字：</font></font></b>
                        <div class="spoiler_text"><pre><code class="plaintext hljs">  volatile alt_u32 status;<font></font>
  volatile int n = 0;<font></font>
  do<font></font>
  {<font></font>
	  status = IORD_ALTERA_MSGDMA_CSR_STATUS(MSGDMA_0_CSR_BASE);<font></font>
	  n += 1;<font></font>
  } while (!(status &amp; errMask) &amp;&amp;(status &amp; ALTERA_MSGDMA_CSR_BUSY_MASK));  <font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
工作结束时为29。大于16。也就是说，FIFO应该溢出。</font><font style="vertical-align: inherit;">以防万一，让我们添加更多状态寄存器读数。</font><font style="vertical-align: inherit;">没有帮助。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
悲痛的是，我断开了与远程Redd建筑群的连接，将项目重新定位到我现有的面包板上，现在可以用示波器连接到该板上（在办公室，没有人在远处，我无法到达示波器）。</font><font style="vertical-align: inherit;">为计时器添加了两个端口：</font></font><br>
<br>
<pre><code class="plaintext hljs">   output    clk_copy,<font></font>
   output    ready_copy<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并任命他们：</font></font><br>
<br>
<pre><code class="plaintext hljs">    assign clk_copy = clk;<font></font>
    assign ready_copy = source_ready;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，该模块开始如下所示：</font></font><br>
<br>
<pre><code class="plaintext hljs">module Timer_ST (<font></font>
   input           clk,<font></font>
   input           reset,<font></font>
	<font></font>
   input logic     source_ready,<font></font>
   output logic    source_valid,<font></font>
   output logic[31:0] source_data,<font></font>
<font></font>
   output    clk_copy,<font></font>
   output    ready_copy<font></font>
	<font></font>
);<font></font>
    logic [31:0] counter;<font></font>
    always @ (posedge clk, posedge reset)<font></font>
    if (reset == 1)<font></font>
    begin<font></font>
        counter &lt;= 0;<font></font>
    end else<font></font>
    begin<font></font>
        counter &lt;= counter + 1;<font></font>
    end<font></font>
<font></font>
    assign source_valid = 1;<font></font>
    assign source_data [31:24] = counter [7:0];<font></font>
    assign source_data [23:16] = counter [15:8];<font></font>
    assign source_data [15:8] = counter [23:16];<font></font>
    assign source_data [7:0] = counter [31:24];<font></font>
<font></font>
    assign clk_copy = clk;<font></font>
    assign ready_copy = source_ready;<font></font>
<font></font>
endmodule<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在家里，我有一个较小的带有水晶的手表，所以我不得不降低记忆力。结果发现我的原始程序无法放入4 KB的节中。因此，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上一篇文章中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提出的主题</font><font style="vertical-align: inherit;">是，哦，它有多重要。系统中的内存-勉强够用！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
程序启动时，我们将立即</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">准备</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16个或17个小节。它由DMA模块的FIFO填充。一开始就让我感到害怕的相同效果。这些数据将构成非常错误的缓冲区填充。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/i6/wy/-a/i6wy-a4xsnbwej_o9indj_plneg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，我们得到了40960纳秒的美丽画面，即2048个周期（对于家用晶体，缓冲区必须减小到8 KB，即2048个32位字）。这是它的开始：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9h/c5/1d/9hc51dpo8ur2_1whymyreqkvzre.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是结尾：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5l/3y/le/5l3ylew4zpty3b9xf6bn_zjunlc.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，贯穿始终-没有一个失败。</font><font style="vertical-align: inherit;">不，很明显这会发生，但是还是有希望的。。。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也许我们应该尝试在总线上写，而不仅仅是从总线上读？</font><font style="vertical-align: inherit;">我向系统添加了一个GPIO块：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rj/lg/o8/rjlgo8iyaj30cxjr8jhkc1njap4.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
等待就绪时为其添加了一个条目：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j4/ci/vp/j4civpmja0ccaz_9qinqqc247wu.png"><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同文字</font></font></b>
                        <div class="spoiler_text"><pre><code class="plaintext hljs">  volatile alt_u32 status;<font></font>
  volatile int n = 0;<font></font>
  do<font></font>
  {<font></font>
	status = IORD_ALTERA_MSGDMA_CSR_STATUS(MSGDMA_0_CSR_BASE);<font></font>
       IOWR_ALTERA_AVALON_PIO_DATA (PIO_0_BASE,0x01);<font></font>
       IOWR_ALTERA_AVALON_PIO_DATA (PIO_0_BASE,0x00);<font></font>
<font></font>
       n += 1;<font></font>
  } while (!(status &amp; errMask) &amp;&amp;(status &amp; ALTERA_MSGDMA_CSR_BUSY_MASK));  <font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没有问题，就是这样！</font><font style="vertical-align: inherit;">谁该怪？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有奇迹，但是有未开发的东西</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
谁该怪？带着悲痛，我开始研究</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platform Designer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工具的所有菜单</font><font style="vertical-align: inherit;">，似乎找到了一个线索。轮胎通常看起来像什么？客户端连接到的一组电线。所以？好像是我们可以从编辑器中的图中看到这一点。只是，本文的第二个目标是展示如何将总线划分为两个独立的部分，每个部分的工作都不会相互干扰。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，让我们看一下生成系统时出现的消息。突出显示关键字：</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/di/ri/c1/diric1mrzwztjmu2bcw3nrxg5du.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并且有很多类似的消息：它被添加，它被添加。事实证明，在用笔进行编辑后，系统还添加了许多其他内容。您如何看待所有可用的方案？我仍然在此游泳，但是通过选择以下菜单项，我们可以在本文的框架内获得最可能的答案：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/7s/k_/vv7sk_blrrjycf7wfixijjcdzus.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
打开的画面本身令人印象深刻，但我不会给出。然后，</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y-/ub/dv/y-ubdvljrhcecquyc0rg5u5t16e.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将</font><font style="vertical-align: inherit;">立即选择此选项卡：</font><font style="vertical-align: inherit;">然后我们将看到以下内容：我将</font></font><br>
<br>
<img src="https://habrastorage.org/webt/18/zk/_9/18zk_94hudf6j0r9lfliuu9wjy8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
显示最重要的部分：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gy/1u/if/gy1uifa4ln0x8_axbm4t9_juypq.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
轮胎没有结合！</font><font style="vertical-align: inherit;">他们被分割了！</font><font style="vertical-align: inherit;">我无法辩解（也许专家会在评论中纠正我），但似乎系统已为我们插入了开关！</font><font style="vertical-align: inherit;">这些开关创建了隔离的总线段，主系统可以与DMA单元并行工作，此时DMA单元可以无冲突地访问内存！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们惹出了真正的问题</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
掌握了所有这些知识后，我们得出结论，我们可以很好地引发问题。</font><font style="vertical-align: inherit;">为了确保测试系统可以创建它们，这是必需的，这意味着开发环境确实可以独立解决它们。</font><font style="vertical-align: inherit;">我们将不引用总线上的抽象设备，而是引用相同的缓冲存储器，以便</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cmd_mux_005</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">块</font><font style="vertical-align: inherit;">在处理器内核和DMA块之间分配总线。</font><font style="vertical-align: inherit;">我们这样重写长时间受苦的等待函数：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zm/ww/4n/zmww4n1xt_p-eo_2hqrfufgtmis.png"><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同文字</font></font></b>
                        <div class="spoiler_text"><pre><code class="plaintext hljs">  volatile alt_u32 status;<font></font>
  volatile int n = 0;<font></font>
  volatile alt_u32* pBuf = (alt_u32*)BUFFER_BASE;<font></font>
  volatile alt_u32 sum = 0;<font></font>
  do<font></font>
  {<font></font>
	  status = IORD_ALTERA_MSGDMA_CSR_STATUS(MSGDMA_0_CSR_BASE);<font></font>
	  sum += pBuf[n];<font></font>
<font></font>
	  n += 1;<font></font>
  } while (!(status &amp; errMask) &amp;&amp;(status &amp; ALTERA_MSGDMA_CSR_BUSY_MASK));<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，波峰出现在波形上！</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/po/rc/vvporcmhdl2i9julycbcib6vnfe.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内存检查功能也发现了很多遗漏：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xf/pf/8y/xfpf8ytbjo3wqlxsgqprx6eqnj0.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是的，我们很好地看到了数据在行与行之间的移动：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/eu/eh/uu/euehuuf9rp-ilidebmcy_zsdcuq.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个特定坏点的示例（缺少6CCE488F）：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v_/5e/rj/v_5erjk_wbxw9ujfrhptcxpeudy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们看到实验已正确完成，只是开发环境得以执行为我们优化。</font><font style="vertical-align: inherit;">我不是用嘲讽而是怀着感激之情说出“全然伤害所有钢铁”的情况。</font><font style="vertical-align: inherit;">感谢Quartus开发人员！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们学习了如何在系统中插入DMA块以将流数据传输到内存。</font><font style="vertical-align: inherit;">我们还确保在总线上下载其他设备的过程不会干扰下载过程。</font><font style="vertical-align: inherit;">开发环境将自动创建一个与总线的其他部分并行运行的隔离段。</font><font style="vertical-align: inherit;">当然，如果有人转向同一部分，则冲突和解决它们所花费的时间是不可避免的，但是程序员很可能会预见到这种情况。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在下一篇文章中，我们将用SDRAM控制器替换RAM，并用真实的“ head”替换计时器，并制作第一个逻辑分析器。</font><font style="vertical-align: inherit;">能行吗？我还不知道。</font><font style="vertical-align: inherit;">我希望问题不会出现。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN500002/index.html">IT专家与推销员：世界一分为二</a></li>
<li><a href="../zh-CN500008/index.html">满足升频器</a></li>
<li><a href="../zh-CN500010/index.html">氢气污染的历史</a></li>
<li><a href="../zh-CN500012/index.html">实体框架核心</a></li>
<li><a href="../zh-CN500014/index.html">完全响应式设计不只是媒体查询</a></li>
<li><a href="../zh-CN500018/index.html">以RoughJS为例模仿徒手画</a></li>
<li><a href="../zh-CN500020/index.html">Google Earth Engine-独特的大地理数据分析平台</a></li>
<li><a href="../zh-CN500022/index.html">为什么要参加社区生活，它如何帮助职业发展？</a></li>
<li><a href="../zh-CN500026/index.html">这个行业的废话*简直令人难以置信</a></li>
<li><a href="../zh-CN500028/index.html">数据管理平台：从外围到云</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>