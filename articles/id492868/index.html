<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â‰ï¸ ğŸ“ ğŸ›ï¸ Optimasi string di ClickHouse. Laporan Yandex â„ï¸ ğŸ›· ğŸ‘‡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mesin database analitik ClickHouse memproses banyak jalur yang berbeda, menghabiskan sumber daya. Untuk mempercepat sistem, optimisasi baru terus dita...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Optimasi string di ClickHouse. Laporan Yandex</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/492868/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesin database analitik ClickHouse memproses banyak jalur yang berbeda, menghabiskan sumber daya. </font><font style="vertical-align: inherit;">Untuk mempercepat sistem, optimisasi baru terus ditambahkan. </font><font style="vertical-align: inherit;">Pengembang ClickHouse Nikolay Kochetov berbicara tentang tipe data string, termasuk tipe baru, LowCardinality, dan menjelaskan cara mempercepat kerja dengan string.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/rqf-ILRgBdY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
- Pertama, mari kita lihat bagaimana Anda dapat menyimpan string. </font></font><br>
<a name="habracut"></a><br>
<img src="https://habrastorage.org/webt/ch/9s/zs/ch9szsqfnkkvpmjjxoo0lmpacno.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memiliki tipe data string. </font><font style="vertical-align: inherit;">String berfungsi dengan baik secara default, harus digunakan hampir selalu. </font><font style="vertical-align: inherit;">Ini memiliki Overhead kecil - 9 byte per baris. </font><font style="vertical-align: inherit;">Jika kita ingin ukuran baris diperbaiki dan diketahui sebelumnya, lebih baik menggunakan FixedString. </font><font style="vertical-align: inherit;">Di dalamnya Anda dapat mengatur jumlah byte yang kami butuhkan, mudah untuk data seperti alamat IP atau fungsi hash. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rd/lx/mo/rdlxmobm0ch5l88ab74sszn_fps.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, terkadang ada sesuatu yang melambat. </font><font style="vertical-align: inherit;">Misalkan Anda membuat kueri di atas meja. </font><font style="vertical-align: inherit;">ClickHouse membaca sejumlah besar data, katakanlah, pada kecepatan 100 GB / s, dengan beberapa baris sedang diproses. </font><font style="vertical-align: inherit;">Kami memiliki dua tabel yang menyimpan data yang hampir sama. </font><font style="vertical-align: inherit;">ClickHouse membaca data dari tabel kedua dengan kecepatan lebih tinggi, tetapi membaca tiga kali lebih sedikit baris per detik.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nd/tz/6l/ndtz6l6-1pwaycgcoxhslfj2hcm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita melihat ukuran data terkompresi, itu akan hampir sama. Faktanya, data yang sama ditulis dalam tabel - miliar angka pertama - hanya di kolom pertama ditulis dalam bentuk UInt64, dan di kolom kedua dalam String. Karena itu, permintaan kedua membaca data dari disk lebih lama dan mendekompresnya. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/i8/a2/vf/i8a2vfterxcfto5foypz6tig3zy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah contoh lain. Misalkan ada satu set garis yang telah ditentukan, terbatas pada konstanta 1000 atau 10.000 dan hampir tidak pernah berubah. Untuk kasus ini, tipe data Enum cocok untuk kita, di ClickHouse ada dua - Enum8 dan Enum16. Karena penyimpanan di Enum, kami dengan cepat memproses permintaan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ClickHouse memiliki akselerasi untuk GROUP BY, IN, DISTINCT dan optimisasi untuk beberapa fungsi, misalnya, untuk perbandingan dengan string konstan. Tentu saja, angka-angka dalam string tidak dikonversi, tetapi, sebaliknya, string konstan dikonversi ke nilai Enum. Setelah itu, semuanya dengan cepat dibandingkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun ada juga kekurangannya. Bahkan jika kita tahu rangkaian garis yang tepat, kadang-kadang perlu diisi ulang. Baris baru telah tiba - kita harus melakukan ALTER. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/b0/ay/sz/b0ayszedkf252ktki2xizo2fxfm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ALTER untuk Enum di ClickHouse diimplementasikan secara optimal. Kami tidak menimpa data pada disk, tetapi ALTER dapat memperlambat karena fakta bahwa struktur Enum disimpan dalam skema tabel itu sendiri. Karena itu, kita harus menunggu permintaan baca dari tabel, misalnya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertanyaannya adalah, bisakah seseorang berbuat lebih baik? Mungkin ya. Anda bisa menyimpan struktur Enum tidak dalam skema tabel, tetapi di ZooKeeper. Namun, masalah sinkronisasi dapat terjadi. Misalnya, satu replika menerima data, yang lain tidak, dan jika memiliki Enum yang lama, maka sesuatu akan pecah. (Di ClickHouse, kami hampir menyelesaikan permintaan ALTER non-pemblokiran. Ketika kami menyelesaikannya sepenuhnya, kami tidak akan harus menunggu permintaan baca.) </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yf/rc/vj/yfrcvjamitxxi5taditsaouvrl4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agar tidak mengacaukan dengan ALTER Enum, Anda dapat menggunakan kamus ClickHouse eksternal. Biarkan saya mengingatkan Anda bahwa ini adalah struktur data nilai kunci di dalam ClickHouse, yang dengannya Anda bisa mendapatkan data dari sumber eksternal, misalnya, dari tabel MySQL.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kamus ClickHouse, kami menyimpan banyak baris yang berbeda, dan dalam tabel pengidentifikasi mereka dalam bentuk angka. Jika kita perlu mendapatkan string, kita memanggil fungsi dictGet dan bekerja dengannya. Setelah itu kita jangan melakukan ALTER. Untuk menambahkan sesuatu ke Enum, kami menyisipkan ini ke dalam tabel MySQL yang sama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi ada masalah lain. Pertama, sintaks canggung. Jika kita ingin mendapatkan string, kita harus memanggil dictGet. Kedua, kurangnya beberapa optimasi. Perbandingan dengan string konstan untuk kamus juga tidak cepat dilakukan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin masih ada masalah dengan pembaruan. Misalkan kita meminta baris dalam kamus cache, tetapi tidak masuk ke cache. Maka kita harus menunggu hingga data dimuat dari sumber eksternal.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/em/4z/ii/em4ziibqzsukh-mvfu2o8dpncv0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelemahan umum kedua metode adalah kami menyimpan semua kunci di satu tempat dan menyinkronkannya. </font><font style="vertical-align: inherit;">Jadi mengapa tidak menyimpan kamus secara lokal? </font><font style="vertical-align: inherit;">Tanpa sinkronisasi - tidak ada masalah. </font><font style="vertical-align: inherit;">Anda dapat menyimpan kamus secara lokal di dalam disk. </font><font style="vertical-align: inherit;">Yaitu, kami memasukkan, mencatat kamus. </font><font style="vertical-align: inherit;">Jika kita bekerja dengan data dalam memori, kita dapat menulis kamus ke blok data, atau ke sepotong kolom, atau ke beberapa cache untuk mempercepat perhitungan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengkodean String Kosakata </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi kami sampai pada penciptaan tipe data baru di ClickHouse - LowCardinality. Ini adalah format untuk menyimpan data: bagaimana mereka ditulis ke disk dan bagaimana mereka dibaca, bagaimana mereka disajikan dalam memori dan skema pemrosesan mereka. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/se/5h/5e/se5h5er0yccult4fjfamsksw4rk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada dua kolom pada slide. Di sebelah kanan, string disimpan secara standar dalam tipe String. Dapat dilihat bahwa ini adalah semacam model ponsel. Di sebelah kiri ada kolom yang persis sama, hanya dalam jenis LowCardinality. Ini terdiri dari kamus dengan banyak baris berbeda (baris dari kolom di sebelah kanan) dan daftar posisi (nomor baris). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan menggunakan dua struktur ini, Anda dapat mengembalikan kolom asli. Ada juga indeks terbalik terbalik - tabel hash yang membantu Anda menemukan posisi dalam kamus per baris. Diperlukan untuk mempercepat beberapa permintaan. Misalnya, jika kita ingin membandingkan, cari baris di kolom kami atau gabungkan keduanya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LowCardinality adalah tipe data parametrik. Ini bisa berupa angka, atau sesuatu yang disimpan sebagai angka, atau string, atau Dapat dibatalkan dari mereka. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/et/r4/h9/etr4h9fjutj5sf6ffxqjmf04xpu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kekhasan LowCardinality adalah dapat disimpan untuk beberapa fungsi. Contoh permintaan ditampilkan pada slide. Pada baris pertama, saya membuat kolom tipe LowCardinality dari String, menamainya S. Lalu saya bertanya namanya - ClickHouse mengatakan bahwa itu adalah LowCardinality from String. Baiklah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baris ketiga hampir sama, hanya kita yang menyebut fungsi panjang. Di ClickHouse, fungsi panjang mengembalikan tipe data UInt64. Tapi kami mendapat LowCardinality dari UInt64. Apa gunanya?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6h/hs/0x/6hhs0xgy2-hnsc8tputwp8ukqqu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nama-nama ponsel disimpan dalam kamus, kami menerapkan fungsi panjang. Sekarang kami memiliki kamus serupa, yang hanya terdiri dari angka, ini adalah panjang string. Kolom dengan posisi tidak berubah. Akibatnya, kami memproses lebih sedikit data, disimpan pada waktu permintaan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin ada optimasi lain, seperti menambahkan cache sederhana. Saat menghitung nilai suatu fungsi, Anda dapat mengingatnya dan membuatnya sama, jangan menghitung ulang.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Optimalisasi GROUP BY juga dapat dilakukan, karena kolom kami dengan kamus sudah sebagian teragregasi - kami dapat dengan cepat menghitung nilai fungsi hash dan secara kasar menemukan ember tempat meletakkan baris berikutnya. Anda juga dapat mengkhususkan beberapa fungsi agregat, misalnya uniq, karena Anda hanya dapat mengirim kamus ke sana, dan membiarkan posisi tidak tersentuh - dengan cara ini semuanya akan bekerja lebih cepat. Dua optimasi pertama yang telah kami tambahkan ke ClickHouse.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kc/6u/v4/kc6uv48b2vbsmki20ckwvvbc990.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi bagaimana jika kita membuat kolom dengan tipe data kita dan memasukkan banyak baris berbeda yang buruk ke dalamnya? Apakah ingatan kita penuh? Tidak, ada dua pengaturan khusus untuk ini di ClickHouse. Yang pertama adalah low_cardinality_max_dictionary_size. Ini adalah ukuran maksimum kamus yang dapat ditulis ke disk. Penyisipan terjadi sebagai berikut: ketika kita memasukkan data, aliran garis datang kepada kita, dari mereka kita membentuk kamus umum yang besar. Jika kamus menjadi lebih besar dari nilai pengaturan, kami menulis kamus saat ini ke disk, dan sisa baris di suatu tempat di samping, di sebelah indeks. Akibatnya, kami tidak akan pernah menghitung ulang kamus besar dan tidak mendapatkan masalah memori.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengaturan kedua disebut low_cardinality_use_single_dictionary_for_part. Bayangkan dalam skema sebelumnya, ketika kami memasukkan data, kamus kami sudah penuh, dan kami menulisnya ke disk. Muncul pertanyaan, mengapa sekarang tidak membentuk kamus lain yang persis sama? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika meluap, kita akan kembali menulis ke disk dan mulai membentuk yang ketiga. Pengaturan ini hanya menonaktifkan fitur ini secara default.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faktanya, banyak kamus dapat berguna jika kita ingin memasukkan beberapa baris, tetapi secara tidak sengaja memasukkan "sampah". Katakanlah kita pertama-tama memasukkan garis buruk, dan kemudian kita memasukkan yang baik. Kemudian kamus akan dibagi menjadi banyak kamus kecil. Beberapa dari mereka akan dengan sampah, tetapi yang terakhir akan dengan garis-garis yang baik. Dan jika kita membaca, katakanlah, hanya pelet terakhir, maka semuanya juga akan bekerja dengan cepat. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jc/jx/jb/jcjxjbo7vmgmexmzxryscvj0lhu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum berbicara tentang keuntungan dari LowCardinality, saya akan segera mengatakan bahwa kami tidak mungkin mencapai pengurangan data pada disk (walaupun ini bisa terjadi), karena ClickHouse memampatkan data. Ada opsi default - LZ4. Anda juga dapat melakukan kompresi menggunakan ZSTD. Tetapi kedua algoritma sudah menerapkan kompresi kamus, jadi kamus ClickHouse eksternal kami tidak akan banyak membantu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agar tidak berdasar, saya mengambil beberapa data dari metrik - String, LowCardinality (String) dan Enum - dan menyimpannya dalam tipe data yang berbeda. </font><font style="vertical-align: inherit;">Ternyata tiga kolom, di mana satu miliar baris ditulis. </font><font style="vertical-align: inherit;">Kolom pertama, CodePage, memiliki total 62 nilai. </font><font style="vertical-align: inherit;">Dan Anda dapat melihat bahwa di LowCardinality (String), mereka meremasnya dengan lebih baik. </font><font style="vertical-align: inherit;">Tali sedikit lebih buruk, tetapi ini kemungkinan besar disebabkan oleh fakta bahwa senarnya pendek, kami menyimpan panjangnya, dan mereka mengambil banyak ruang dan tidak kompres dengan baik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda menggunakan PhoneModel, ada lebih dari 48 ribu di antaranya, dan hampir tidak ada perbedaan antara String dan LowCardinality (String). </font><font style="vertical-align: inherit;">Untuk URL, kami juga menyimpan hanya 2 GB - Saya pikir Anda tidak harus bergantung pada ini.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estimasi kecepatan kerja</font></font></h3> <br>
<img src="https://habrastorage.org/webt/3q/v7/ar/3qv7aronmenayqfhdjait6xo3tw.jpeg"><br>
<b><sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tautan dari slide</font></font></a></sub></sup></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sekarang mari kita mengevaluasi kecepatan kerja. Untuk mengevaluasinya, saya menggunakan dataset yang menggambarkan naik taksi di New York. Ini</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tersedia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di GitHub. Ini memiliki sedikit lebih dari satu miliar perjalanan. Ini menunjukkan lokasi, waktu mulai dan akhir perjalanan, metode pembayaran, jumlah penumpang dan bahkan jenis taksi - hijau, kuning dan Uber.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2o/9n/qb/2o9nqbsb7dodtnoimgnnl66lhlg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya membuat permintaan pertama cukup sederhana - saya bertanya di mana taksi paling sering dipesan. Untuk melakukan ini, Anda harus mengambil lokasi dari tempat Anda memesan, membuat GROUP BY di atasnya dan menghitung fungsi penghitungan. Di sini ClickHouse memberikan sesuatu.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/te/uy/kz/teuykz6_ucr7tuklbfsnobntncc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengukur kecepatan pemrosesan kueri, saya membuat tiga tabel dengan data yang sama, tetapi menggunakan tiga tipe data yang berbeda untuk lokasi awal kami - String, LowCardinality, dan Enum. LowCardinality dan Enum lima kali lebih cepat dari String. Enum lebih cepat karena berfungsi dengan angka. LowCardinality - karena optimasi GROUP BY diimplementasikan. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pl/mx/qr/plmxqrgggpwl4xp2quqggej847k.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita mempersulit permintaan - tanyakan di mana taman paling populer di New York berada. Sekali lagi, kami akan mengukur ini dengan tempat taksi paling sering dipesan, tetapi pada saat yang sama kami akan menyaring hanya lokasi-lokasi di mana kata "taman" tersedia. Juga tambahkan fungsi seperti.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0u/iq/bz/0uiqbzwkh280_wuzn8bccqg2lhi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami melihat waktu - kami melihat bahwa Enum tiba-tiba mulai melambat. Dan itu bekerja lebih lambat daripada tipe data String standar. Ini karena fungsi sejenisnya sama sekali tidak dioptimalkan untuk Enum. Kami harus mengubah jalur kami dari Enum ke jalur reguler - kami melakukan lebih banyak pekerjaan. LowCardinality (String) juga tidak dioptimalkan secara default, tetapi seperti berfungsi di kamus, jadi kueri lebih cepat dibandingkan dengan String. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada masalah yang lebih global dengan Enum. Jika kita ingin mengoptimalkannya, kita harus melakukannya di setiap tempat kode. Misalkan kita menulis fungsi baru - Anda pasti harus membuat optimasi untuk Enum. Dan dalam LowCardinality, semuanya dioptimalkan secara default.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_j/oc/eq/_joceq5ioy66p6gjatm1l5f2rqy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat permintaan terakhir, lebih buatan. </font><font style="vertical-align: inherit;">Kami hanya akan menghitung fungsi hash dari lokasi kami. </font><font style="vertical-align: inherit;">Fungsi hash adalah permintaan yang agak lambat, butuh waktu lama, jadi semuanya akan melambat tiga kali. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dn/06/x9/dn06x9ujvdxgdpmjcus8qzlccbg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Low Cardinality masih lebih cepat, meskipun tidak ada pemfilteran. </font><font style="vertical-align: inherit;">Ini disebabkan oleh fakta bahwa fungsi kami hanya berfungsi pada kamus. </font><font style="vertical-align: inherit;">Fungsi perhitungan hash memiliki satu argumen - ia dapat memproses lebih sedikit data dan juga dapat mengembalikan LowCardinality. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/63/yt/qz/63ytqzwuufiatce0y8wdy4whn5s.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rencana global kami adalah mencapai kecepatan yang tidak lebih rendah dari String dalam hal apa pun, dan menghemat akselerasi. </font><font style="vertical-align: inherit;">Dan mungkin suatu hari kita akan mengganti String dengan LowCardinality, Anda akan memperbarui ClickHouse, dan semuanya akan bekerja untuk Anda sedikit lebih cepat.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id492850/index.html">Tidak semua orang ingin beralih ke pekerjaan jarak jauh</a></li>
<li><a href="../id492856/index.html">Covid19, Masyarakat Anda dan Anda dari sudut pandang Ilmu Data. Artikel yang diterjemahkan oleh Jeremy Howard dan Rachel Thomas (fast.ai)</a></li>
<li><a href="../id492862/index.html">15 tips penyempurnaan kinerja Oracle APEX terbaik untuk pengembang</a></li>
<li><a href="../id492864/index.html">Bisakah saya meretas kapal?</a></li>
<li><a href="../id492866/index.html">Buku "Mesin Belajar tanpa kata-kata"</a></li>
<li><a href="../id492872/index.html">Bagaimana mengatur akses jarak jauh dan tidak menderita peretas</a></li>
<li><a href="../id492874/index.html">Optimalisasi rendering untuk Seluler</a></li>
<li><a href="../id492878/index.html">Sandal geek: mencari positif dalam penutupan kantor sementara</a></li>
<li><a href="../id492880/index.html">Apa yang harus kita bangun rumah pintar?</a></li>
<li><a href="../id492884/index.html">Menerima pesan dari siaran youtube + otorisasi google dalam PHP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>