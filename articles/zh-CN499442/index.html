<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗄️ 👨🏾‍🤝‍👨🏻 👶 创建一个伪3D赛车游戏：实现丘陵并完成游戏 💆🏼 🚾 🧔🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="第3部分。丘陵
 
 在上一部分中，我们创建了一个简单的伪三维赛车游戏，在其中实现了直线道路和弯道。
 
 这次我们要照顾山丘；幸运的是，这比创建弯曲的道路要容易得多。
 
 在第一部分中，我们使用相似三角形的定律创建了三维透视投影：
 
 
 ...导致我们获得了将3d世界的坐标投影到2d屏幕的坐...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>创建一个伪3D赛车游戏：实现丘陵并完成游戏</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499442/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第3部分。丘陵</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/892/231/4e8/8922314e8acebdd3ae14fba511d17294.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在上一部分中，我们创建了一个简单的伪三维</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">赛车游戏</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在其中实现了直线道路和弯道。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这次我们要照顾山丘；</font><font style="vertical-align: inherit;">幸运的是，这比创建弯曲的道路要容易得多。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第一部分中，我们使用相似三角形的定律创建了三维透视投影：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/949/0ab/47b/9490ab47bb570b61218e46e5913c18bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...导致我们获得了将3d世界的坐标投影到2d屏幕的坐标的方程式。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/246/e18/edb246e187e7fe0eb027b53c58790c34.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...但是从那时起，我们只使用直行道路，因此世界坐标只需要</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分量</font><font style="vertical-align: inherit;">，因为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都等于零。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这很适合我们，因为添加山足以为路段赋予对应的非零坐标</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后现有功能将</font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">神奇地起作用。</font></font><a name="habracut"></a><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ede/dc6/295/ededc629516e6f0d2c7f1ca6b111e17d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是的，这足以使人上山。</font><font style="vertical-align: inherit;">只需将</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分量添加到每个路段的世界坐标</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">道路几何形状的变化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将修改现有方法，</font></font><code>addSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以使调用它的函数可以传递</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2.world.y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1.world.y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将与上</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一段的</font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">p2.world.y</font></strong><font style="vertical-align: inherit;">相对应</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params">curve, y</span>) </span>{
  <span class="hljs-keyword">var</span> n = segments.length;<font></font>
  segments.push({<font></font>
     <span class="hljs-attr">index</span>: n,
        <span class="hljs-attr">p1</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">y</span>: lastY(), <span class="hljs-attr">z</span>:  n   *segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
        <span class="hljs-attr">p2</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">y</span>: y,       <span class="hljs-attr">z</span>: (n+<span class="hljs-number">1</span>)*segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
     <span class="hljs-attr">curve</span>: curve,
     <span class="hljs-attr">color</span>: <span class="hljs-built_in">Math</span>.floor(n/rumbleLength)%<span class="hljs-number">2</span> ? COLORS.DARK : COLORS.LIGHT<font></font>
  });<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastY</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (segments.length == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : segments[segments.length<span class="hljs-number">-1</span>].p2.world.y;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
添加常数以表示低（</font></font><code>LOW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），中（</font></font><code>MEDIUM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和高（</font></font><code>HIGH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）坡度：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> ROAD = {
  <span class="hljs-attr">LENGTH</span>: { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">SHORT</span>:  <span class="hljs-number">25</span>, <span class="hljs-attr">MEDIUM</span>:  <span class="hljs-number">50</span>, <span class="hljs-attr">LONG</span>:  <span class="hljs-number">100</span> },
  <span class="hljs-attr">HILL</span>:   { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">LOW</span>:    <span class="hljs-number">20</span>, <span class="hljs-attr">MEDIUM</span>:  <span class="hljs-number">40</span>, <span class="hljs-attr">HIGH</span>:   <span class="hljs-number">60</span> },
  <span class="hljs-attr">CURVE</span>:  { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">EASY</span>:    <span class="hljs-number">2</span>, <span class="hljs-attr">MEDIUM</span>:   <span class="hljs-number">4</span>, <span class="hljs-attr">HARD</span>:    <span class="hljs-number">6</span> }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更改现有方法</font></font><code>addRoad()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，使其接收参数</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">参数</font><font style="vertical-align: inherit;">将与平滑函数一起用于从山上逐渐上升和下降的情况：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRoad</span>(<span class="hljs-params">enter, hold, leave, curve, y</span>) </span>{
  <span class="hljs-keyword">var</span> startY   = lastY();
  <span class="hljs-keyword">var</span> endY     = startY + (Util.toInt(y, <span class="hljs-number">0</span>) * segmentLength);
  <span class="hljs-keyword">var</span> n, total = enter + hold + leave;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; enter ; n++)<font></font>
    addSegment(Util.easeIn(<span class="hljs-number">0</span>, curve, n/enter), Util.easeInOut(startY, endY, n/total));
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; hold  ; n++)<font></font>
    addSegment(curve, Util.easeInOut(startY, endY, (enter+n)/total));<font></font>
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; leave ; n++)<font></font>
    addSegment(Util.easeInOut(curve, <span class="hljs-number">0</span>, n/leave), Util.easeInOut(startY, endY, (enter+hold+n)/total));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，类似于我们在第2部分中所做的</font></font><code>addSCurves()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们可以强加我们构造几何所需的任何方法，例如：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addLowRollingHills</span>(<span class="hljs-params">num, height</span>) </span>{<font></font>
  num    = num    || ROAD.LENGTH.SHORT;<font></font>
  height = height || ROAD.HILL.LOW;<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  height/<span class="hljs-number">2</span>);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>, -height);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  height);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  height/<span class="hljs-number">2</span>);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>);<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改更新方法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们创建的街机游戏中，我们不会尝试模拟现实，因此丘陵不会以任何方式影响玩家或游戏世界，这意味着该方法</font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不需要更改。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">希尔渲染</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该方法</font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也不需要更改，因为投影方程最初是为了正确投影具有非零</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">坐标的路段而编写的</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视差滚动背景</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了将</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">坐标添加到所有路段外</font><font style="vertical-align: inherit;">，唯一的变化将是背景图层与丘陵的垂直位移的实现（就像它们随曲线水平移动一样）。</font><font style="vertical-align: inherit;">我们使用辅助函数的另一个参数来实现这一点</font></font><code>Render.background</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最简单的机制是相对于位置的通常背景位移</font></font><code>playerY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（应从</font><font style="vertical-align: inherit;">当前玩家细分的</font><font style="vertical-align: inherit;">世界位置</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内插</font><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这不是最现实的行为，因为可能值得考虑玩家当前路段的坡度，但是这种效果很简单，并且对于简单的演示来说效果很好。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就是这样，现在我们可以用真实的山丘来补充假曲线了：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/892/231/4e8/8922314e8acebdd3ae14fba511d17294.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们在第一部分中所做的工作，包括添加真实的3D丘陵的基础设施，我之前没有告诉过您。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文的最后一部分，我们将在道路边缘添加精灵，树木和广告牌。</font><font style="vertical-align: inherit;">我们还将添加其他可以与之竞争的赛车，识别碰撞并修复玩家的“圈数记录”。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第4部分。就绪版本</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/103/563/0d1/1035630d19106de2f85edebb24d0421f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这一部分，我们将添加：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">广告牌和树木</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他车</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">碰撞识别</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">汽车的基本AI</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与单圈计时器和单圈记录接口</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
……这将为我们提供足够的交互性，最终将我们的项目称为“游戏”。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关代码结构的注意事项</font></font></h2><br>
<blockquote><em>     ,            /,         Javascript.</em></blockquote><br>
<blockquote><em>                .     () ,             ...</em></blockquote><br>
<blockquote><em>…      ,       ,           ,  ,         .</em></blockquote><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6f/111/acc/f6f111accbba448459e25c6fe761ff05.png"></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第1部分中，在游戏周期开始之前，我们上传了一个精灵表，其中包含所有的汽车，树木和广告牌。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以在任何图像编辑器中手动创建一个精灵表，但是最好将图像的存储和坐标的计算委托给自动化工具。</font><font style="vertical-align: inherit;">在我的情况下，精灵表是由一个小的Rake任务使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruby Gem sprite-factory生成的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该任务从单独的图像文件生成组合的Spritesheets，并计算坐标x，y，w，h，这些坐标将存储在常量中</font></font><code>SPRITES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> SPRITES = {
  <span class="hljs-attr">PALM_TREE</span>:   { <span class="hljs-attr">x</span>:    <span class="hljs-number">5</span>, <span class="hljs-attr">y</span>:    <span class="hljs-number">5</span>, <span class="hljs-attr">w</span>:  <span class="hljs-number">215</span>, <span class="hljs-attr">h</span>:  <span class="hljs-number">540</span> },
  <span class="hljs-attr">BILLBOARD08</span>: { <span class="hljs-attr">x</span>:  <span class="hljs-number">230</span>, <span class="hljs-attr">y</span>:    <span class="hljs-number">5</span>, <span class="hljs-attr">w</span>:  <span class="hljs-number">385</span>, <span class="hljs-attr">h</span>:  <span class="hljs-number">265</span> },<font></font>
<font></font>
  <span class="hljs-comment">// ... etc</span><font></font>
<font></font>
  <span class="hljs-attr">CAR04</span>:       { <span class="hljs-attr">x</span>: <span class="hljs-number">1383</span>, <span class="hljs-attr">y</span>:  <span class="hljs-number">894</span>, <span class="hljs-attr">w</span>:   <span class="hljs-number">80</span>, <span class="hljs-attr">h</span>:   <span class="hljs-number">57</span> },
  <span class="hljs-attr">CAR01</span>:       { <span class="hljs-attr">x</span>: <span class="hljs-number">1205</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1018</span>, <span class="hljs-attr">w</span>:   <span class="hljs-number">80</span>, <span class="hljs-attr">h</span>:   <span class="hljs-number">56</span> },<font></font>
};</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加广告牌和树木</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在道路的每个路段上添加一个数组，其中将包含沿道路边缘的对象精灵。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个子图由</font></font><code>source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从集合</font><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">获取的</font></font><code>SPRITES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及水平偏移量组成</font></font><code>offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">水平偏移量</font><font style="vertical-align: inherit;">已归一化，因此-1表示道路的左边缘，而+1表示右边缘，这使我们不必依赖于值</font></font><code>roadWidth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有些精灵是有意放置的，有些则是随机的。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params"></span>) </span>{<font></font>
  segments.push({<font></font>
    ...<font></font>
    sprites: [],<font></font>
    ...<font></font>
  });<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSprite</span>(<span class="hljs-params">n, sprite, offset</span>) </span>{<font></font>
  segments[n].sprites.push({ <span class="hljs-attr">source</span>: sprite, <span class="hljs-attr">offset</span>: offset });<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetSprites</span>(<span class="hljs-params"></span>) </span>{<font></font>
<font></font>
  addSprite(<span class="hljs-number">20</span>,  SPRITES.BILLBOARD07, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">40</span>,  SPRITES.BILLBOARD06, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">60</span>,  SPRITES.BILLBOARD08, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">80</span>,  SPRITES.BILLBOARD09, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">100</span>, SPRITES.BILLBOARD01, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">120</span>, SPRITES.BILLBOARD02, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">140</span>, SPRITES.BILLBOARD03, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">160</span>, SPRITES.BILLBOARD04, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">180</span>, SPRITES.BILLBOARD05, <span class="hljs-number">-1</span>);<font></font>
<font></font>
  addSprite(<span class="hljs-number">240</span>, SPRITES.BILLBOARD07, <span class="hljs-number">-1.2</span>);<font></font>
  addSprite(<span class="hljs-number">240</span>, SPRITES.BILLBOARD06,  <span class="hljs-number">1.2</span>);<font></font>
<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">250</span> ; n &lt; <span class="hljs-number">1000</span> ; n += <span class="hljs-number">5</span>) {<font></font>
    addSprite(n, SPRITES.COLUMN, <span class="hljs-number">1.1</span>);<font></font>
    addSprite(n + Util.randomInt(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>), SPRITES.TREE1, <span class="hljs-number">-1</span> - (<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>));<font></font>
    addSprite(n + Util.randomInt(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>), SPRITES.TREE2, <span class="hljs-number">-1</span> - (<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>));<font></font>
  }<font></font>
<font></font>
  ...<font></font>
}</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：如果要创建真实的游戏，我们可以编写道路编辑器以可视化方式创建具有丘陵和曲线的地图，并添加沿道路布置精灵的机制...但是对于我们的任务，我们可以通过编程方式进行</font></font><code>addSprite()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加料机</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了道路边缘的对象精灵外，我们还将添加一个将占据每个路段</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">汽车</font><font style="vertical-align: inherit;">集合，</font><font style="vertical-align: inherit;">以及高速公路上</font><strong><font style="vertical-align: inherit;">所有</font></strong><font style="vertical-align: inherit;">汽车</font><font style="vertical-align: inherit;">的单独集合</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> cars      = [];  <span class="hljs-comment">// array of cars on the road</span>
<span class="hljs-keyword">var</span> totalCars = <span class="hljs-number">200</span>; <span class="hljs-comment">// total number of cars on the road</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params"></span>) </span>{<font></font>
  segments.push({<font></font>
    ...<font></font>
    cars: [], <span class="hljs-comment">// array of cars within this segment</span><font></font>
    ...<font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过存储两个汽车数据结构，我们可以轻松地以一种方法迭代地遍历所有汽车</font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并在必要时将它们从一个区段移动到另一个区段。</font><font style="vertical-align: inherit;">同时，这允许我们</font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅在可见段上</font><font style="vertical-align: inherit;">执行</font><font style="vertical-align: inherit;">机器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每台机器都有一个随机的水平位移，z位置，子画面源和速度：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetCars</span>(<span class="hljs-params"></span>) </span>{<font></font>
  cars = [];<font></font>
  <span class="hljs-keyword">var</span> n, car, segment, offset, z, sprite, speed;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span> ; n &lt; totalCars ; n++) {<font></font>
    offset = <span class="hljs-built_in">Math</span>.random() * Util.randomChoice([<span class="hljs-number">-0.8</span>, <span class="hljs-number">0.8</span>]);<font></font>
    z      = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * segments.length) * segmentLength;<font></font>
    sprite = Util.randomChoice(SPRITES.CARS);<font></font>
    speed  = maxSpeed/<span class="hljs-number">4</span> + <span class="hljs-built_in">Math</span>.random() * maxSpeed/(sprite == SPRITES.SEMI ? <span class="hljs-number">4</span> : <span class="hljs-number">2</span>);<font></font>
    car = { <span class="hljs-attr">offset</span>: offset, <span class="hljs-attr">z</span>: z, <span class="hljs-attr">sprite</span>: sprite, <span class="hljs-attr">speed</span>: speed };<font></font>
    segment = findSegment(car.z);<font></font>
    segment.cars.push(car);<font></font>
    cars.push(car);<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">希尔渲染（返回）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在前面的部分中，我讨论了渲染道路段（包括曲线和山丘）的过程，但是其中有几行我没有考虑过。他们关心的是一个变量，它</font></font><code>maxy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从屏幕底部开始，但是在渲染每个段以确定我们已经渲染了屏幕的哪一部分时递减：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; drawDistance ; n++) {<font></font>
<font></font>
  ...<font></font>
<font></font>
  if ((segment.p1.camera.z &lt;= cameraDepth) || <span class="hljs-comment">// behind us</span>
      (segment.p2.screen.y &gt;= maxy))          <span class="hljs-comment">// clip by (already rendered) segment</span>
    <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
  ...<font></font>
<font></font>
  maxy = segment.p2.screen.y;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这将使我们可以裁剪已被渲染的山丘覆盖的部分。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">艺术家的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传统</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">算法中，</font></a><font style="vertical-align: inherit;">渲染通常发生在背面，而较近的部分则与较远的部分重叠。</font><font style="vertical-align: inherit;">但是，我们不能花时间渲染最终会被覆盖的多边形，因此，如果投影坐标较小，则从前向后渲染和裁剪已被渲染的近段覆盖的遥远段变得容易</font></font><code>maxy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染广告牌，树木和汽车</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，渲染子画面时，从前到后的道路段迭代遍历将不起作用，因为它们经常相互重叠，因此必须使用艺术家的算法进行渲染。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这使我们的方法变得复杂，</font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并迫使我们分两个阶段绕过路段：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从前到后进行道路渲染</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">后退以渲染精灵</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8db/7d3/347/8db7d3347ac49621e67b7bbe2028fc6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了部分重叠的精灵外，我们还需要处理由于山顶的地平线而“略微突出”的精灵。如果子画面足够高，则即使它所在的路段位于山坡的后部，因此也不会呈现，因此我们应该看到其上部。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以通过保存的值解决这个最后的问题</font></font><code>maxy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个段为线</font></font><code>clip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在步骤1。然后，我们可以裁剪沿线本段的精灵</font></font><code>clip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在步骤2中</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
，呈现逻辑的其余部分确定如何比例和位置基于系数精灵</font></font><code>scale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和坐标</font></font><code>screen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的道路段的（计算阶段1），因此在该方法的第二阶段，</font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们需要进行以下操作：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// back to front painters algorithm</span>
<span class="hljs-keyword">for</span>(n = (drawDistance<span class="hljs-number">-1</span>) ; n &gt; <span class="hljs-number">0</span> ; n--) {<font></font>
  segment = segments[(baseSegment.index + n) % segments.length];<font></font>
<font></font>
  <span class="hljs-comment">// render roadside sprites</span>
  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span> ; i &lt; segment.sprites.length ; i++) {<font></font>
    sprite      = segment.sprites[i];<font></font>
    spriteScale = segment.p1.screen.scale;<font></font>
    spriteX     = segment.p1.screen.x + (spriteScale * sprite.offset * roadWidth * width/<span class="hljs-number">2</span>);<font></font>
    spriteY     = segment.p1.screen.y;<font></font>
    Render.sprite(ctx, width, height, resolution, roadWidth, sprites, sprite.source, spriteScale, spriteX, spriteY, (sprite.offset &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, segment.clip);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// render other cars</span>
  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span> ; i &lt; segment.cars.length ; i++) {<font></font>
    car         = segment.cars[i];<font></font>
    sprite      = car.sprite;<font></font>
    spriteScale = Util.interpolate(segment.p1.screen.scale, segment.p2.screen.scale, car.percent);<font></font>
    spriteX     = Util.interpolate(segment.p1.screen.x,     segment.p2.screen.x,     car.percent) + (spriteScale * car.offset * roadWidth * width/<span class="hljs-number">2</span>);<font></font>
    spriteY     = Util.interpolate(segment.p1.screen.y,     segment.p2.screen.y,     car.percent);<font></font>
    Render.sprite(ctx, width, height, resolution, roadWidth, sprites, car.sprite, spriteScale, spriteX, spriteY, <span class="hljs-number">-0.5</span>, <span class="hljs-number">-1</span>, segment.clip);<font></font>
  }<font></font>
<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与广告牌和树木的碰撞</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们可以沿道路边缘添加和渲染对象精灵，我们需要更改方法</font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以确定玩家在当前段中是否遇到了这些精灵中的任何</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个</font><font style="vertical-align: inherit;">：</font><font style="vertical-align: inherit;">我们使用辅助方法</font></font><code>Util.overlap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来实现对矩形相交的广义识别。</font><font style="vertical-align: inherit;">如果检测到交叉路口，我们将停车：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">if</span> ((playerX &lt; <span class="hljs-number">-1</span>) || (playerX &gt; <span class="hljs-number">1</span>)) {
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; playerSegment.sprites.length ; n++) {<font></font>
    sprite  = playerSegment.sprites[n];<font></font>
    spriteW = sprite.source.w * SPRITES.SCALE;<font></font>
    <span class="hljs-keyword">if</span> (Util.overlap(playerX, playerW, sprite.offset + spriteW/<span class="hljs-number">2</span> * (sprite.offset &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>), spriteW)) {
      <span class="hljs-comment">// stop the car</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：如果您学习真实的代码，您会发现实际上我们不是在停车，因为那样一来，它将无法侧向移动以避开障碍物；</font><font style="vertical-align: inherit;">作为一个简单的技巧，我们固定它们的位置，并允许汽车“滑动”到精灵周围。</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与汽车相撞</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了沿道路边缘与小精灵碰撞外，我们还需要识别与其他汽车的碰撞，如果检测到交叉路口，我们会通过将玩家“推”回与之碰撞的机器后面来减慢玩家的速度：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; playerSegment.cars.length ; n++) {<font></font>
  car  = playerSegment.cars[n];<font></font>
  carW = car.sprite.w * SPRITES.SCALE;<font></font>
  <span class="hljs-keyword">if</span> (speed &gt; car.speed) {
    <span class="hljs-keyword">if</span> (Util.overlap(playerX, playerW, car.offset, carW, <span class="hljs-number">0.8</span>)) {
      <span class="hljs-comment">// slow the car</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">机器更新</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了让其他汽车沿着道路行驶，我们将为他们提供最简单的AI：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以恒定的速度骑</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">超车时自动绕过玩家</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">超车时自动绕过其他汽车</font></font></li>
</ul><br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：我们不必担心在道路上沿着弯道转弯其他汽车，因为这些弯道不是真实的。</font><font style="vertical-align: inherit;">如果我们使汽车仅沿道路段移动，它们将自动沿曲线通过。</font></font></em></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有这一切都发生在</font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通话</font><font style="vertical-align: inherit;">期间的游戏周期中，</font><font style="vertical-align: inherit;">在此通话</font></font><code>updateCars()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中，我们将每辆汽车以恒定速度向前移动，如果在此帧中它们移动了足够的距离，则从一个段切换到下一个段。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateCars</span>(<span class="hljs-params">dt, playerSegment, playerW</span>) </span>{
  <span class="hljs-keyword">var</span> n, car, oldSegment, newSegment;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; cars.length ; n++) {<font></font>
    car         = cars[n];<font></font>
    oldSegment  = findSegment(car.z);<font></font>
    car.offset  = car.offset + updateCarOffset(car, oldSegment, playerSegment, playerW);<font></font>
    car.z       = Util.increase(car.z, dt * car.speed, trackLength);<font></font>
    car.percent = Util.percentRemaining(car.z, segmentLength); <span class="hljs-comment">// useful for interpolation during rendering phase</span><font></font>
    newSegment  = findSegment(car.z);<font></font>
    <span class="hljs-keyword">if</span> (oldSegment != newSegment) {<font></font>
      index = oldSegment.cars.indexOf(car);<font></font>
      oldSegment.cars.splice(index, <span class="hljs-number">1</span>);<font></font>
      newSegment.cars.push(car);<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该方法</font></font><code>updateCarOffset()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供了</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“人工智能”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的实现</font><font style="vertical-align: inherit;">，使机器可以绕过播放器或其他机器。</font><font style="vertical-align: inherit;">这是代码库中最复杂的方法之一，在实际游戏中，它应该更加复杂，以使机器看上去比简单的演示更为真实。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的项目中，我们使用幼稚的AI蛮力，迫使每台机器：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">期待20个细分市场</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果她发现前方有较慢的汽车横穿自己的小路，则绕过她</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从道路左侧的障碍物向右转</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在道路的右侧向左拐弯</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转弯足以避免在剩余距离内前方的障碍物</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们还可以用那些玩家看不见的汽车作弊，从而使它们不能相互绕过并通过。</font><font style="vertical-align: inherit;">他们应该只在玩家的视野范围内才显得“聪明”。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateCarOffset</span>(<span class="hljs-params">car, carSegment, playerSegment, playerW</span>) </span>{<font></font>
<font></font>
  <span class="hljs-keyword">var</span> i, j, dir, segment, otherCar, otherCarW, lookahead = <span class="hljs-number">20</span>, carW = car.sprite.w * SPRITES.SCALE;<font></font>
<font></font>
  <span class="hljs-comment">// optimization, dont bother steering around other cars when 'out of sight' of the player</span>
  <span class="hljs-keyword">if</span> ((carSegment.index - playerSegment.index) &gt; drawDistance)
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span> ; i &lt; lookahead ; i++) {<font></font>
    segment = segments[(carSegment.index+i)%segments.length];<font></font>
<font></font>
    <span class="hljs-keyword">if</span> ((segment === playerSegment) &amp;&amp; (car.speed &gt; speed) &amp;&amp; (Util.overlap(playerX, playerW, car.offset, carW, <span class="hljs-number">1.2</span>))) {
      <span class="hljs-keyword">if</span> (playerX &gt; <span class="hljs-number">0.5</span>)<font></font>
        dir = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (playerX &lt; <span class="hljs-number">-0.5</span>)<font></font>
        dir = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">else</span>
        dir = (car.offset &gt; playerX) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">return</span> dir * <span class="hljs-number">1</span>/i * (car.speed-speed)/maxSpeed; <span class="hljs-comment">// the closer the cars (smaller i) and the greater the speed ratio, the larger the offset</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span> ; j &lt; segment.cars.length ; j++) {<font></font>
      otherCar  = segment.cars[j];<font></font>
      otherCarW = otherCar.sprite.w * SPRITES.SCALE;<font></font>
      <span class="hljs-keyword">if</span> ((car.speed &gt; otherCar.speed) &amp;&amp; Util.overlap(car.offset, carW, otherCar.offset, otherCarW, <span class="hljs-number">1.2</span>)) {
        <span class="hljs-keyword">if</span> (otherCar.offset &gt; <span class="hljs-number">0.5</span>)<font></font>
          dir = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (otherCar.offset &lt; <span class="hljs-number">-0.5</span>)<font></font>
          dir = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span>
          dir = (car.offset &gt; otherCar.offset) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">return</span> dir * <span class="hljs-number">1</span>/i * (car.speed-otherCar.speed)/maxSpeed;<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在大多数情况下，该算法效果很好，但是在前面有大量汽车的情况下，我们可以注意到汽车在从左向右和向后移动，试图挤入其他两台机器之间的缝隙。</font><font style="vertical-align: inherit;">有许多方法可以提高AI的可靠性，例如，如果汽车发现没有足够的空间来避开障碍物，则可以让汽车减速。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接口</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，我们将创建一个基本的HTML界面：</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;div id =“ hud”&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id =“ speed” class =“ hud”&gt; &lt;span id =“ speed_value” class =“ value”&gt; 0 &lt;/ span&gt; mph &lt;/ span&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id =“ current_lap_time” class =“ hud”&gt;时间：&lt;span id =“ current_lap_time_value” class =“ value”&gt; 0.0 &lt;/ span&gt; &lt;/ span&gt; </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id =“ last_lap_time” class =“ hud”&gt;最后一圈：&lt;span id =“ last_lap_time_value” class =“ value”&gt; 0.0 &lt;/ span&gt; &lt;/ span&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id =“ fast_lap_time” class =“ hud”&gt;最快圈：&lt;span id =“ fast_lap_time_value” class =“ value”&gt; 0.0 &lt;/ span&gt; &lt;/ span&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&lt;/ div&gt;</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...并为其添加CSS样式</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-id">#hud</span>                   { <span class="hljs-attribute">position</span>: absolute; <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>; <span class="hljs-attribute">width</span>: <span class="hljs-number">640px</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span> <span class="hljs-number">0</span>; <span class="hljs-attribute">font-family</span>: Verdana, Geneva, sans-serif; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.8em</span>; <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.4</span>); <span class="hljs-attribute">color</span>: black; <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">2px</span> solid black; <span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-attribute">-moz-box-sizing</span>: border-box; <span class="hljs-attribute">-webkit-box-sizing</span>: border-box; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-class">.hud</span>              { <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0.6</span>); <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>; <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black; <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">5px</span>; <span class="hljs-attribute">transition-property</span>: background-color; <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">2s</span>; <span class="hljs-attribute">-webkit-transition-property</span>: background-color; <span class="hljs-attribute">-webkit-transition-duration</span>: <span class="hljs-number">2s</span>; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#speed</span>            { <span class="hljs-attribute">float</span>: right; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#current_lap_time</span> { <span class="hljs-attribute">float</span>: left;  }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#last_lap_time</span>    { <span class="hljs-attribute">float</span>: left; <span class="hljs-attribute">display</span>: none;  }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#fast_lap_time</span>    { <span class="hljs-attribute">display</span>: block; <span class="hljs-attribute">width</span>: <span class="hljs-number">12em</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto; <span class="hljs-attribute">text-align</span>: center; <span class="hljs-attribute">transition-property</span>: background-color; <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">2s</span>; <span class="hljs-attribute">-webkit-transition-property</span>: background-color; <span class="hljs-attribute">-webkit-transition-duration</span>: <span class="hljs-number">2s</span>; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-class">.value</span>            { <span class="hljs-attribute">color</span>: black; <span class="hljs-attribute">font-weight</span>: bold; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-class">.fastest</span>          { <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">215</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>); }</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...，我们将在游戏周期内执行其update（）：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">if</span> (position &gt; playerZ) {
  <span class="hljs-keyword">if</span> (currentLapTime &amp;&amp; (startPosition &lt; playerZ)) {<font></font>
    lastLapTime    = currentLapTime;<font></font>
    currentLapTime = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (lastLapTime &lt;= Util.toFloat(Dom.storage.fast_lap_time)) {<font></font>
      Dom.storage.fast_lap_time = lastLapTime;<font></font>
      updateHud(<span class="hljs-string">'fast_lap_time'</span>, formatTime(lastLapTime));<font></font>
      Dom.addClassName(<span class="hljs-string">'fast_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
      Dom.addClassName(<span class="hljs-string">'last_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span> {<font></font>
      Dom.removeClassName(<span class="hljs-string">'fast_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
      Dom.removeClassName(<span class="hljs-string">'last_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
    }<font></font>
    updateHud(<span class="hljs-string">'last_lap_time'</span>, formatTime(lastLapTime));<font></font>
    Dom.show(<span class="hljs-string">'last_lap_time'</span>);<font></font>
  }<font></font>
  <span class="hljs-keyword">else</span> {<font></font>
    currentLapTime += dt;<font></font>
  }<font></font>
}<font></font>
<font></font>
updateHud(<span class="hljs-string">'speed'</span>,            <span class="hljs-number">5</span> * <span class="hljs-built_in">Math</span>.round(speed/<span class="hljs-number">500</span>));<font></font>
updateHud(<span class="hljs-string">'current_lap_time'</span>, formatTime(currentLapTime));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
辅助方法</font></font><code>updateHud()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">允许我们仅在值更改时更新DOM元素，因为这样的更新可能是一个缓慢的过程，并且如果值本身不更改，我们不应该以60fps的速度执行它。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHud</span>(<span class="hljs-params">key, value</span>) </span>{ <span class="hljs-comment">// accessing DOM can be slow, so only do it if value has changed</span>
  <span class="hljs-keyword">if</span> (hud[key].value !== value) {<font></font>
    hud[key].value = value;<font></font>
    Dom.set(hud[key].dom, value);<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/103/563/0d1/1035630d19106de2f85edebb24d0421f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
！</font><font style="vertical-align: inherit;">最后一部分很长，但是我们仍然完成了，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成的版本</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到达了可以称为游戏的阶段。</font><font style="vertical-align: inherit;">她距离</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比赛</font><font style="vertical-align: inherit;">还很遥远</font><font style="vertical-align: inherit;">，但这仍然是一场比赛。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管如此简单，但我们确实设法创建了一个游戏，这真是令人惊讶。</font><font style="vertical-align: inherit;">我不打算将这个项目带入一个完整的状态。</font><font style="vertical-align: inherit;">它仅应视为</font><font style="vertical-align: inherit;">对伪三维赛车游戏主题</font><font style="vertical-align: inherit;">的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介绍</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该代码</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由github发布</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，您可以尝试将其转变为更高级的赛车游戏。</font><font style="vertical-align: inherit;">您也可以尝试：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为汽车增加音效</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">改善音乐同步</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全屏实施</font></font></li>
<li>   (   , ,    ,  ..)</li>
<li>    </li>
<li>   (,   ..)</li>
<li>       </li>
<li> ,     </li>
<li> ,          -</li>
<li> ,     </li>
<li>   (   ,     ..)</li>
<li>    drawDistance</li>
<li>         x,y</li>
<li>     </li>
<li>      (   ,  )</li>
<li> </li>
<li> </li>
<li>     </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">叉子和公路连接</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">昼夜的变化</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">天气状况</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隧道，桥梁，云层，墙壁，建筑物</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">城市，沙漠，海洋</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将西雅图和太空针塔添加到背景中</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“恶棍”-增加竞争对手与之竞争</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏模式-最快圈速，一对一比赛（捡硬币？向小人射击？）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大量的游戏自定义选项</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等等</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
至此就完成了。</font><font style="vertical-align: inherit;">另一个“周末项目”花费的时间比预期的要长得多，但最终结果还是不错的。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一系列文章，直线道路和曲线的开始</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">楼的伪3d页面</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可播放演示的链接：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直路演示</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲线演示</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">希尔斯演示</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成品版</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN499432/index.html">PHPUnit中单元测试的自治</a></li>
<li><a href="../zh-CN499434/index.html">如何实施知识管理：受益于“邮袋”，“鹦鹉罚款”和剪辑思维</a></li>
<li><a href="../zh-CN499436/index.html">遥控酶将加速中风和脊柱损伤的治疗</a></li>
<li><a href="../zh-CN499438/index.html">流向测试人员，而不仅仅是</a></li>
<li><a href="../zh-CN499440/index.html">当我们为调车机车编写世界上最酷的自动驾驶仪时</a></li>
<li><a href="../zh-CN499444/index.html">Postgres：膨胀，pg_repack和延迟约束</a></li>
<li><a href="../zh-CN499446/index.html">测试用于VR的STEP格式引导加载程序</a></li>
<li><a href="../zh-CN499448/index.html">使用TypeScript和InversifyJS在Node.js中实现SOLID和分层架构</a></li>
<li><a href="../zh-CN499450/index.html">使用Python中的遗传学/进化论为波斯游戏选择设备</a></li>
<li><a href="../zh-CN499452/index.html">诊所眼科医生的日常工作：医生不足时</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>