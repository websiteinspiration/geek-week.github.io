<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥝 🥊 🐳 QSerializer：シンプルなJSON / XMLシリアル化のソリューション 🐰 ⚜️ 🏴‍☠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！
 
 Java、C＃、Go、Pythonなどでは、どういうわけか不当に判明するのではないかと思いました。オブジェクトデータを現在ファッショナブルなJSONとXMLに快適にシリアル化するためのライブラリがありますが、C ++では、忘れてしまった、または望まなかった、または本当に必...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>QSerializer：シンプルなJSON / XMLシリアル化のソリューション</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496836/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java、C＃、Go、Pythonなどでは、どういうわけか不当に判明するのではないかと思いました。</font><font style="vertical-align: inherit;">オブジェクトデータを現在ファッショナブルなJSONとXMLに快適にシリアル化するためのライブラリがありますが、C ++では、忘れてしまった、または望まなかった、または本当に必要としなかった、あるいはすべて複雑である、またはすべて一緒になっている可能性があります。</font><font style="vertical-align: inherit;">だから私はこれを修正することにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いつも通り、カットの下のすべてのディテール。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j9/cp/vw/j9cpvwvjh9gfvhqxigysyx7m78c.png" alt="画像"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックグラウンド</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一度、私は次のペットプロジェクトを取り上げることに決めました。その本質はクライアントとサーバーの交換でしたが、多くのお気に入りのサーバーはRaspberryPiでした。とりわけ、「保存ポイント」の作成の問題に興味がありました。つまり、プロトタイプの一部として、オブジェクトの状態を保存してから終了し、次の開始時に回復できるように、できるだけ簡単にできるようにしました。 Pythonへの不当な敵意とQtに対する私の非常に温かい態度のため、Qt＆C ++を選択しました。 JSON解析のクラスとスパゲッティ関数を作成することは今でも楽しみです。私はいくつかの普遍的かつ同時に簡単な問題解決策を必要としていました。 「私たちはそれを理解しなければならない」と私は自分に言い聞かせた。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、用語について少し：</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シリアライゼーションは、データ構造を一連のビットに変換するプロセスです。</font><font style="vertical-align: inherit;">シリアル化操作の逆は、逆シリアル化（構造化）操作、つまりビットシーケンスからのデータ構造の初期状態の復元です。</font></font><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Goには、</font><font style="vertical-align: inherit;">Marshalメソッドを使用してオブジェクトのシリアル化を完了し、Unmarshalを使用して逆構造化を実行できる</font><font style="vertical-align: inherit;">、非常に便利な「ネイティブ」</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンコーディング/ json</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージ</font><font style="vertical-align: inherit;">があります（このライブラリのため、マーシャリングについては最初は正しくありませ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">んでした</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Desine sperare qui hic intras</font></a><font style="vertical-align: inherit;">） 。</font><font style="vertical-align: inherit;">このパッケージのコンセプトに従って、Java用の別のライブラリ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-GSON</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を見つけました</font><font style="vertical-align: inherit;">。これは非常に快適な製品であることが判明しました。これを使用できてうれしかったです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はこれらのライブラリーの何が好きかを考え、それが使いやすさだという結論に達しました。柔軟な機能とオールインワンの呼び出し。JSONでのシリアル化では、toJsonメソッドを呼び出してシリアル化可能なオブジェクトを渡すだけで十分でした。ただし、デフォルトでは、C ++自体には、たとえばJava（ClassName.class）で行われているように、クラスのフィールドに関する十分な情報を提供する適切なメタオブジェクト機能がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qtプラットフォームの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">QJson</font></a><font style="vertical-align: inherit;">だけが好き</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">でした</font></a><font style="vertical-align: inherit;">が、それでも、前述のライブラリによって生成された使いやすさについての私の理解にはまったく適合しませんでした。そのため、ここで説明するプロジェクトが登場しました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小さな免責事項：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このようなメカニズムでは、データ解釈の問題は解決されません。</font><font style="vertical-align: inherit;">それらから得ることができるすべてはあなたのためのより便利な形式へのデータの変換です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QSerializerプロジェクトの構造</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトと例は、GitHub（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リポジトリへのリンク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">で表示できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">詳細なインストール手順もそこに記載されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
建築上の自殺を予想して、これが最終版ではないことを予約します。</font><font style="vertical-align: inherit;">捨てられた石にもかかわらず、仕事は続けられますが、願いを叶えました。</font></font><br>
<img src="https://habrastorage.org/webt/lg/rp/op/lgrpopckj4waexmewif_u2zngf4.png" alt="QSerializerライブラリの一般的な構造依存関係"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロジェクトの主な目標は、C ++でユーザーフレンドリーなデータ形式を使用してシリアル化をアクセス可能で基本的なものにすることです。</font><font style="vertical-align: inherit;">製品の品質開発とメンテナンスの鍵は、そのアーキテクチャです。</font><font style="vertical-align: inherit;">他の実装方法がこの記事のコメントに表示される可能性があることを除外しないので、少し「創造性のためのスペース」を残しました。</font><font style="vertical-align: inherit;">実装を変更する場合は、PropertyKeeperインターフェースの新しい実装を追加するか、ファクトリメソッドを変更して、QSerializer関数で何も変更する必要がないようにすることができます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールド宣言</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qtでメタオブジェクト情報を収集する1つの方法は、Qt自体のメタオブジェクトシステムでそれを記述することです。</font><font style="vertical-align: inherit;">おそらくこれが最も簡単な方法です。</font></font><abbr title="メタオブジェクトコンパイラ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOCは</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コンパイル時に必要なすべてのメタデータ</font><abbr title="メタオブジェクトコンパイラ"><font style="vertical-align: inherit;">を</font></abbr><font style="vertical-align: inherit;">生成します。</font><font style="vertical-align: inherit;">記述されたオブジェクトのmetaObjectメソッドを呼び出すと、QMetaObjectクラスのインスタンスが返され、これを使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
直列化するフィールドを宣言するには、QObjectからクラスを継承し、それに</font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q_OBJECT</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マクロを含めて</font><font style="vertical-align: inherit;">、クラスタイプをQObjectからのベースタイプとして修飾することをMOCに明確にする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、</font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q_PROPERTY</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マクロ</font><font style="vertical-align: inherit;">はクラスのメンバーを記述します。</font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q_PROPERTYで</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明されている</font><font style="vertical-align: inherit;">プロパティプロパティ</font><font style="vertical-align: inherit;">を呼び出し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">QSerializerは、USERフラグがtrueに設定されていないプロパティを無視します。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜUSERフラグなのか</font></font></b>
                        <div class="spoiler_text">     , ,  QML.        . ,   <font color="#FF1493">Q_PROPERTY</font>  QML   QSerializer     .<br>
</div>
                    </div><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> :</span> <span class="hljs-keyword">public</span> QObject<font></font>
{<font></font>
Q_OBJECT<font></font>
<span class="hljs-comment">// Define data members to be serialized</span>
Q_PROPERTY(QString name MEMBER name USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(<span class="hljs-keyword">int</span> age MEMBER age USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(QString email MEMBER email USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt; phone MEMBER phone USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(<span class="hljs-keyword">bool</span> vacation MEMBER vacation USER <span class="hljs-literal">true</span>)
<span class="hljs-keyword">public</span>:
  <span class="hljs-comment">// Make base constructor</span><font></font>
  User() { }<font></font>
 <font></font>
  QString name;<font></font>
  <span class="hljs-keyword">int</span> age{<span class="hljs-number">0</span>};<font></font>
  QString email;<font></font>
  <span class="hljs-keyword">bool</span> vacation{<span class="hljs-literal">false</span>};
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt; phone; <font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qtメタオブジェクトシステムで非標準のユーザータイプを宣言するには、</font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qserializer.h</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で定義され</font><font style="vertical-align: inherit;">ている</font><font color="#FF1493"><font style="vertical-align: inherit;">QS_REGISTER</font></font><font style="vertical-align: inherit;">マクロを使用することをお勧めし</font><font style="vertical-align: inherit;">ます。</font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QS_REGISTER</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、タイプのバリエーションを登録するプロセスを自動化します。</font><font style="vertical-align: inherit;">ただし、qRegisterMetaType &lt; </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt;（）</font><font style="vertical-align: inherit;">を使用してタイプを登録する従来の方法を使用できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">メタオブジェクトシステムの場合、クラスタイプ（</font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）とクラスポインター（</font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> *）は完全に異なるタイプであり、一般的なタイプリストでは異なる識別子になります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> QS_METATYPE(Type) qRegisterMetaType<span class="hljs-meta-string">&lt;Type&gt;(#Type) ;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> QS_REGISTER(Type)       \
QS_METATYPE(Type)               \
QS_METATYPE(Type*)              \
QS_METATYPE(std::vector<span class="hljs-meta-string">&lt;Type*&gt;) \</span></span>
QS_METATYPE(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Type&gt;)  \
</code></pre><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>;</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
<span class="hljs-comment">// define user-type in Qt meta-object system</span><font></font>
QS_REGISTER(User)<font></font>
...<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QSerializer名前空間</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UMLダイアグラムからわかるように、QSerializerには、シリアル化と構造化のための多数の関数が含まれています。</font><font style="vertical-align: inherit;">名前空間は、QSerializerの宣言的な本質を概念的に反映しています。</font><font style="vertical-align: inherit;">埋め込み機能には、QSerializerの名前を使用してアクセスできます。コード内にオブジェクトを作成する必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のUserクラスのオブジェクトに基づいてJSONを構築する例を使用すると、QSerializer :: toJsonメソッドを呼び出すだけで済みます。</font></font><br>
<br>
<pre><code class="cpp hljs">User u;<font></font>
u.name = <span class="hljs-string">"Mike"</span>;<font></font>
u.age = <span class="hljs-number">25</span>;<font></font>
u.email = <span class="hljs-string">"example@exmail.com"</span>;<font></font>
u.phone.push_back(<span class="hljs-string">"+12345678989"</span>);<font></font>
u.phone.push_back(<span class="hljs-string">"+98765432121"</span>);<font></font>
u.vacation = <span class="hljs-literal">true</span>;<font></font>
QJsonObject json = QSerializer::toJson(&amp;u);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これが結果のJSONです。</font></font><br>
<br>
<pre><code class="json hljs">{
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Mike"</span>,
    <span class="hljs-attr">"age"</span>: <span class="hljs-number">25</span>,
    <span class="hljs-attr">"email"</span>: <span class="hljs-string">"example@exmail.com"</span>,
    <span class="hljs-attr">"phone"</span>: [
        <span class="hljs-string">"+12345678989"</span>,
        <span class="hljs-string">"+98765432121"</span><font></font>
    ],<font></font>
    <span class="hljs-attr">"vacation"</span>: <span class="hljs-literal">true</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトを構造化するには2つの方法があります。</font></font><br>
<br>
<ul>
<li><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトを変更する必要がある場合</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs">User u;<font></font>
QJsonObject userJson;<font></font>
QSerializer::fromJson(&amp;u, userJson);</code></pre></div>
                    </div></li>
<li><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいオブジェクトを取得する必要がある場合</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs">QJsonObject userJson;<font></font>
User * u = QSerializer::fromJson&lt;User&gt;(userJson);</code></pre></div>
                    </div></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その他の例と出力は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">example</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フォルダーにあります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーパー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
宣言されたプロパティの便利な書き込みと読み取りを整理するために、QSerializerは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keepers</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスを使用します</font><font style="vertical-align: inherit;">。それぞれの</font><font style="vertical-align: inherit;">クラス</font><font style="vertical-align: inherit;">は、オブジェクト（QObjectの子孫）へのポインターとそのQMetaPropertyの1つを格納します。</font><font style="vertical-align: inherit;">QMetaProperty自体は特定の値ではなく、実際には、MOCに対して宣言されているプロパティクラスの説明を持つオブジェクトにすぎません。</font><font style="vertical-align: inherit;">読み書きするには、このプロパティが記述されているクラスの特定のオブジェクトが必要です-これは覚えておくべき主要なことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シリアル化中の各シリアル化可能フィールドは、対応するタイプのカストディアンに渡されます。</font><font style="vertical-align: inherit;">キーパーは、特定のタイプの記述されたデータの特定の実装のシリアル化および構造化機能をカプセル化するために必要です。</font><font style="vertical-align: inherit;">私は4つのタイプを強調しました：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaSimpleKeeper-プリミティブなデータ型を持つプロパティキーパー</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaArrayKeeper-プリミティブデータの配列を持つプロパティキーパー</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaObjectKeeper-ネストされたオブジェクトのキーパー</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaObjectArrayKeeper-ネストされたオブジェクトの配列のキーパー </font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/dw/ao/0d/dwao0de8yeaqdcdb5zfkbuoof-k.png" alt="データストリーム"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
QMetaPropertyはデフォルトでQVariantと連携するため、プリミティブデータのカストディアンの中心は、JSON / XMLからQVariantへの情報の変換、およびその逆です。</font></font><br>
<br>
<pre><code class="cpp hljs">QMetaProperty prop;<font></font>
QObject * linkedObj;<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-built_in">std</span>::pair&lt;QString, QJsonValue&gt; <span class="hljs-title">QMetaSimpleKeeper::toJson</span><span class="hljs-params">()</span>
</span>{<font></font>
    QJsonValue result = QJsonValue::fromVariant(prop.read(linkedObj));<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_pair(QString(prop.name()), result);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QMetaSimpleKeeper::fromJson</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QJsonValue &amp;val)</span>
</span>{<font></font>
    prop.write(linkedObj, QVariant(val));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトキーパーは、JSON / XMLから他の一連のキーパーへの、またはその逆の情報の転送に基づいています。</font><font style="vertical-align: inherit;">このようなカストディアンは、独自のカストディアンを持つこともできる個別のオブジェクトとしてプロパティを処理します。そのタスクは、プロパティオブジェクトからシリアル化されたデータを収集し、使用可能なデータに従ってプロパティオブジェクトを構造化することです。</font></font><br>
<br>
<pre><code class="cpp hljs">QMetaProperty prop;<font></font>
QObject * linkedObj;<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QMetaObjectKeeper::fromJson</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QJsonValue &amp;json)</span>
</span>{<font></font>
    ...<font></font>
    QSerializer::fromJson(linkedObj, json.toObject());<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-built_in">std</span>::pair&lt;QString, QJsonValue&gt; <span class="hljs-title">QMetaObjectKeeper::toJson</span><span class="hljs-params">()</span>
</span>{<font></font>
    QJsonObject result = QSerializer::toJson(linkedObj);;<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_pair(prop.name(),QJsonValue(result));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーパーはPropertyKeeperインターフェースを実装し、そこからキーパーの基本抽象クラスが継承されます。</font><font style="vertical-align: inherit;">これにより、XMLまたはJSON形式のドキュメントを上から下に順番に解析および作成できます。実装の詳細に進むことなく、記述されているプロパティに埋め込まれているオブジェクトがある場合は、そのプロパティに埋め込まれているオブジェクトがある場合は、そこに降りていくだけです。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PropertyKeeperインターフェース</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertyKeeper</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~PropertyKeeper() = <span class="hljs-keyword">default</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">std</span>::pair&lt;QString, QJsonValue&gt; <span class="hljs-title">toJson</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fromJson</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QJsonValue&amp;)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">std</span>::pair&lt;QString, QDomNode&gt; <span class="hljs-title">toXml</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fromXml</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QDomNode &amp;)</span> </span>= <span class="hljs-number">0</span>;<font></font>
};<font></font>
</code></pre></div>
                    </div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガーディアンファクトリー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのカストディアンが1つのインターフェースを実装するため、すべての実装は便利な画面の背後に隠され、これらの実装のセットはKeepersFactoryファクトリーによって提供されます。</font><font style="vertical-align: inherit;">ファクトリーに転送されたオブジェクトから、QMetaObjectを通じて宣言されたすべてのプロパティのリストを取得できます。これに基づいて、カストディアンのタイプが決定されます。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KeepersFactoryファクトリの実装</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs">    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">simple_t</span> =<font></font>
    {<font></font>
        qMetaTypeId&lt;<span class="hljs-keyword">int</span>&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-keyword">bool</span>&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-keyword">double</span>&gt;(),<font></font>
        qMetaTypeId&lt;QString&gt;(),<font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">array_of_simple_t</span> =<font></font>
    {<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt;&gt;(),<font></font>
    };<font></font>
...<font></font>
<span class="hljs-function">PropertyKeeper *<span class="hljs-title">KeepersFactory::getMetaKeeper</span><span class="hljs-params">(QObject *obj, QMetaProperty prop)</span>
</span>{
    <span class="hljs-keyword">int</span> t_id = QMetaType::type(prop.typeName());
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">std</span>::find(<span class="hljs-keyword">simple_t</span>.begin(), <span class="hljs-keyword">simple_t</span>.end(), t_id) != <span class="hljs-keyword">simple_t</span>.end())
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaSimpleKeeper(obj,prop);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::find(<span class="hljs-keyword">array_of_simple_t</span>.begin(),<span class="hljs-keyword">array_of_simple_t</span>.end(), t_id) != <span class="hljs-keyword">array_of_simple_t</span>.end())<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span>( t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;<span class="hljs-keyword">int</span>&gt;(obj, prop);<font></font>
<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;QString&gt;(obj, prop);<font></font>
<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;<span class="hljs-keyword">double</span>&gt;(obj, prop);<font></font>
<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;<span class="hljs-keyword">bool</span>&gt;(obj, prop);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
        QObject * castobj = qvariant_cast&lt;QObject *&gt;(prop.read(obj));<font></font>
        <span class="hljs-keyword">if</span>(castobj)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaObjectKeeper(castobj,prop);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (QString(prop.typeName()).contains(<span class="hljs-string">"std::vector&lt;"</span>))<font></font>
        {<font></font>
            QString t = QString(prop.typeName()).remove(<span class="hljs-string">"std::vector&lt;"</span>).remove(<span class="hljs-string">"&gt;"</span>);
            <span class="hljs-keyword">int</span> idOfElement = QMetaType::type(t.toStdString().c_str());
            <span class="hljs-keyword">if</span>(QMetaType::typeFlags(idOfElement).testFlag(QMetaType::PointerToQObject))
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaObjectArrayKeeper(obj, prop);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">throw</span> QSException(UnsupportedPropertyType);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PropertyKeeper *&gt; <span class="hljs-title">KeepersFactory::getMetaKeepers</span><span class="hljs-params">(QObject *obj)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PropertyKeeper*&gt; keepers;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; obj-&gt;metaObject()-&gt;propertyCount(); i++)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span>(obj-&gt;metaObject()-&gt;property(i).isUser(obj))<font></font>
            keepers.push_back(getMetaKeeper(obj, obj-&gt;metaObject()-&gt;property(i)));<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> keepers;<font></font>
}<font></font>
...<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ガーディアンファクトリの重要な機能は、オブジェクトに完全な一連のガーディアンを提供する機能です。型識別子を使用して定数コレクションを編集することで、サポートされているプリミティブ型のリストを拡張できます。</font><font style="vertical-align: inherit;">キーパーの各シリーズは、オブジェクトのプロパティの一種のマップです。</font><font style="vertical-align: inherit;">KeepersFactoryオブジェクトが破棄されると、それによって提供される一連のキーパーに割り当てられていたメモリが解放されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制限と動作</font></font></h2><div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状況</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動作</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプがQObjectから継承されていないオブジェクトをシリアル化しようとしました</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイルエラー</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シリアライゼーション/ストチュラライゼーションを試行するときに宣言されていないタイプ</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QSException :: UnsupportedPropertyType例外</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simple_tおよびarray_of_simple_tコレクションで説明されているものとは異なるプリミティブ型でオブジェクトをシリアル化/構造化する試み。</font></font></td>
<td> QSException::UnsupportedPropertyType.    ,     —     ,   </td>
</tr>
<tr>
<td> JSON/XML   </td>
<td>  </td>
</tr>
<tr>
<td>   propertyes,    JSON/XML</td>
<td> propertyes .       —  propertyes          </td>
</tr>
<tr>
<td>      JSON  property </td>
<td> QSException</td>
</tr>
</tbody></table></div><br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では、この記事は書かれたので、このプロジェクトは価値があることがわかりました。</font><font style="vertical-align: inherit;">私自身、普遍的な解決策はないと結論付けました。常に何かを犠牲にしなければなりません。</font><font style="vertical-align: inherit;">用途、機能の点で柔軟に開発することで、シンプルさを損ない、逆もまた同様です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
QSerializerを使用することをお勧めしません。私の目標は、プログラマーとしての私自身の開発です。</font><font style="vertical-align: inherit;">もちろん、私は誰かを助けるという目標も追求しますが、そもそも、ただ喜びを得ることです。</font><font style="vertical-align: inherit;">ポジティブになれ）</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja496824/index.html">あなたの北欧の労働環境</a></li>
<li><a href="../ja496826/index.html">120+ fpsのミリオンスプライト</a></li>
<li><a href="../ja496828/index.html">楽しいフリーランスはどこにありますか？（ネタバレ：アップワークではない）</a></li>
<li><a href="../ja496830/index.html">Emergent Communicationとは何か、そしてなぜ知る必要があるのか</a></li>
<li><a href="../ja496832/index.html">フォトツアー：新物理研究所ITMOのハイブリッドナノフォトニクスとオプトエレクトロニクスの研究室で何をしているのか</a></li>
<li><a href="../ja496838/index.html">Slackで使用されているプロジェクトの展開方法</a></li>
<li><a href="../ja496840/index.html">ムスクは、12,000の衛星が天文学者に干渉しないと信じています。彼の意見はモデルと一致していません</a></li>
<li><a href="../ja496842/index.html">基本的なPythonツールを使用した単純な流行モデル</a></li>
<li><a href="../ja496846/index.html">スタックとポインタの言語力学</a></li>
<li><a href="../ja496848/index.html">モバイル＃340開発者向けの興味深い資料のダイジェスト（4月6〜12日）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>