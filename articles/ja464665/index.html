<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏯️ 🌝 🐮 SQL Serverでのパーティション分割 🧜🏾 👩🏼‍🔬 🎿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SQL Serverでのパーティショニング（「パーティショニング」）は単純に見える（「そうです-ファイルグループごとにテーブルとインデックスを分散すると、管理とパフォーマンスに利益がもたらされます」）はかなり広範囲にわたるトピックです。以下では、関数とパーティションスキームを作成して適用する方法と、...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SQL Serverでのパーティション分割</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464665/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL Serverでのパーティショニング（「パーティショニング」）は単純に見える（「そうです-ファイルグループごとにテーブルとインデックスを分散すると、管理とパフォーマンスに利益がもたらされます」）はかなり広範囲にわたるトピックです。</font><font style="vertical-align: inherit;">以下では、関数とパーティションスキームを作成して適用する方法と、発生する可能性のある問題について説明します。</font><font style="vertical-align: inherit;">テーブルから巨大なデータセットを即座に削除する場合、またはその逆の場合、セクションを切り替えることを除いて、利点については触れません。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msdn</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
は</font><font style="vertical-align: inherit;">次の</font><font style="vertical-align: inherit;">ように述べています</font><font style="vertical-align: inherit;">。「パーティション分割されたテーブルとインデックスのデータは、データベース内の複数のファイルグループに分散できるブロックに分割されます。</font><font style="vertical-align: inherit;">データは水平に分割されるため、行グループは個々のセクションにマップされます。</font><font style="vertical-align: inherit;">同じインデックスまたはテーブルのすべてのセクションは、同じデータベース内にある必要があります。</font><font style="vertical-align: inherit;">データに対してクエリまたは更新を実行する場合、テーブルまたはインデックスは単一の論理エンティティと見なされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主な利点もそこにリストされています：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データセットの整合性を維持しながら、データのサブセットを迅速かつ効率的に転送してアクセスする</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つ以上のセクションを使用すると、メンテナンス操作をより高速に実行できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハードウェア構成で頻繁に実行されるクエリによっては、クエリの実行速度を上げることができます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、パーティション分割は水平スケーリングに使用されます。テーブル/インデックスは、さまざまなファイルグループによって「分散」され、さまざまな物理ディスクに配置できるため、管理の利便性が大幅に向上し、理論的には、このデータに対するクエリのパフォーマンスが向上します。必要なセクションのみ（データが少ない）を読み取るか、すべてを読み取ることができます。並行して（デバイスは異なり、すばやく読み取る）。実際には、すべてがやや複雑であり、パーティション化されたテーブルへのクエリのパフォーマンスを向上させることができるのは、クエリがパーティション化したフィールドによる選択を使用する場合のみです。パーティション分割されたテーブルの経験がない場合は、クエリのパフォーマンスは変化しない可能性がありますが、低下する可能性があることに注意してください。テーブルを分割した後。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーティション分割を確実に実現する（ただし、これも使用できる必要がある）絶対的な利点について話しましょう。これは、データベース管理の利便性の確実な向上です。たとえば、10億レコードのテーブルがあり、そのうち9億は古い（「クローズ」）期間に属し、読み取り専用に使用されます。セクショニングの助けを借りて、この古いデータを別の読み取り専用ファイルグループに転送し、バックアップして、毎日のすべてのバックアップにドラッグする必要がなくなります。バックアップコピーの作成速度が向上し、サイズが減少します。テーブル全体ではなく、選択したセクション全体にインデックスを再構築できます。さらに、データベースの可用性が向上しています-セクションを持つファイルグループを含むデバイスの1つが故障しても、他のデバイスは引き続き使用可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残りの利点を実現するには（セクションを即座に切り替え、生産性を向上させる）-データ構造を具体的に設計し、クエリを作成する必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は読者を十分に困惑させたと思います、そして今、私は練習に進むことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、実験を行う4つのファイルグループを含むデータベースを作成します。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> [PartitionTest] 
<span class="hljs-keyword">on</span> primary (<span class="hljs-keyword">name</span> =<span class="hljs-string">'PTestPrimary'</span>, filename = <span class="hljs-string">'E:\data\partitionTestPrimary.mdf'</span>, <span class="hljs-keyword">size</span> = <span class="hljs-number">8092</span>KB, filegrowth = <span class="hljs-number">1024</span>KB)<font></font>
, filegroup [fg1] (<span class="hljs-keyword">name</span> =<span class="hljs-string">'PTestFG1'</span>, filename = <span class="hljs-string">'E:\data\partitionTestFG1.ndf'</span>, <span class="hljs-keyword">size</span> = <span class="hljs-number">8092</span>KB, filegrowth = <span class="hljs-number">1024</span>KB)<font></font>
, filegroup [fg2] (<span class="hljs-keyword">name</span> =<span class="hljs-string">'PTestFG2'</span>, filename = <span class="hljs-string">'E:\data\partitionTestFG2.ndf'</span>, <span class="hljs-keyword">size</span> = <span class="hljs-number">8092</span>KB, filegrowth = <span class="hljs-number">1024</span>KB)<font></font>
, filegroup [fg3] (<span class="hljs-keyword">name</span> =<span class="hljs-string">'PTestFG3'</span>, filename = <span class="hljs-string">'E:\data\partitionTestFG3.ndf'</span>, <span class="hljs-keyword">size</span> = <span class="hljs-number">8092</span>KB, filegrowth = <span class="hljs-number">1024</span>KB)
 <span class="hljs-keyword">log</span> <span class="hljs-keyword">on</span> (<span class="hljs-keyword">name</span> = <span class="hljs-string">'PTest_Log'</span>, filename = <span class="hljs-string">'E:\data\partitionTest_log.ldf'</span>, <span class="hljs-keyword">size</span> = <span class="hljs-number">2048</span>KB, filegrowth = <span class="hljs-number">1024</span>KB);<font></font>
go<font></font>
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">database</span> [PartitionTest] <span class="hljs-keyword">set</span> <span class="hljs-keyword">recovery</span> simple;<font></font>
go<font></font>
<span class="hljs-keyword">use</span> partitionTest;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
苦痛を与えるテーブルを作成します。 </font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> ptest (<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">identity</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), dt datetime, dummy_int <span class="hljs-built_in">int</span>, dummy_char <span class="hljs-built_in">char</span>(<span class="hljs-number">6000</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1年間のデータを入力します。</font></font><br>
<pre><code class="sql hljs">;<span class="hljs-keyword">with</span> nums <span class="hljs-keyword">as</span> <font></font>
(<font></font>
<span class="hljs-keyword">select</span> <span class="hljs-number">0</span> n <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> <span class="hljs-number">2</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> <span class="hljs-number">3</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> <span class="hljs-number">4</span> 
<span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> <span class="hljs-number">5</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> <span class="hljs-number">6</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> <span class="hljs-number">7</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> <span class="hljs-number">8</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> <span class="hljs-number">9</span> <font></font>
)<font></font>
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> ptest(dt, dummy_int, dummy_char)
<span class="hljs-keyword">select</span> <span class="hljs-keyword">dateadd</span>(hh, rn<span class="hljs-number">-1</span>, <span class="hljs-string">'20180101'</span>) dt, rn dummy_int, <span class="hljs-string">'dummy char column #'</span> + <span class="hljs-keyword">cast</span>(rn <span class="hljs-keyword">as</span> <span class="hljs-built_in">varchar</span>)
<span class="hljs-keyword">from</span><font></font>
(<font></font>
<span class="hljs-keyword">select</span> row_number() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (<span class="hljs-keyword">select</span> (<span class="hljs-literal">null</span>))) rn
<span class="hljs-keyword">from</span> nums n1, nums n2, nums n3, nums n4<font></font>
)t<font></font>
<span class="hljs-keyword">where</span> rn &lt; <span class="hljs-number">8761</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、pTestテーブルには2018年の1時間ごとに1つのレコードが含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、データをセクションに分割するための境界条件を記述するパーティション関数を作成する必要があります。 SQL Serverは範囲分割のみをサポートします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dt（datetime）列に従ってテーブルを分割し、各セクションに4か月のデータが含まれるようにします（ここで私は失敗しました-実際、最初のセクションには3のデータ、2番目は4のデータ、3番目は5か月のデータが含まれますが、デモ用-これは問題ではありません）</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">partition</span> <span class="hljs-keyword">function</span> pfTest (datetime) <span class="hljs-keyword">as</span> <span class="hljs-keyword">range</span>
<span class="hljs-keyword">for</span> <span class="hljs-keyword">values</span> (<span class="hljs-string">'20180401'</span>, <span class="hljs-string">'20180801'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが正常なようですが、ここでは意図的に1つの「間違い」を作りました。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msdn</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の構文</font><font style="vertical-align: inherit;">を見ると、作成中に、指定された境界線がどのセクションに属するかを指定できることがわかります（左または右）。</font><font style="vertical-align: inherit;">デフォルトでは、不明な理由により、指定された境界線は「左」セクションを参照しているため、私の場合は次のようにパーティション関数を作成するのが適切です。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">partition</span> <span class="hljs-keyword">function</span> pfTest (datetime) <span class="hljs-keyword">as</span> <span class="hljs-keyword">range</span> <span class="hljs-keyword">right</span>
<span class="hljs-keyword">for</span> <span class="hljs-keyword">values</span> (<span class="hljs-string">'20180401'</span>, <span class="hljs-string">'20180801'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が実際に実行している間：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">partition</span> <span class="hljs-keyword">function</span> pfTest (datetime) <span class="hljs-keyword">as</span> <span class="hljs-keyword">range</span> <span class="hljs-keyword">left</span>
<span class="hljs-keyword">for</span> <span class="hljs-keyword">values</span> (<span class="hljs-string">'20180401'</span>, <span class="hljs-string">'20180801'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、後でこれに戻って、パーティション関数を再作成します。</font><font style="vertical-align: inherit;">その間、私たちは何が起こったのか、なぜそれが私たちにとってあまり良くないのかを理解するために何が起こったのかを続けます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーティション関数を作成したら、パーティション構成を作成する必要があります。</font><font style="vertical-align: inherit;">セクションをファイルグループに明確にバインドします。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">partition</span> scheme psTest <span class="hljs-keyword">as</span> <span class="hljs-keyword">partition</span> pfTest <span class="hljs-keyword">to</span> ([FG1], [FG2], [FG3])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、3つのセクションはすべて異なるファイルグループに含まれています。</font><font style="vertical-align: inherit;">次に、テーブルをパーティション分割します。</font><font style="vertical-align: inherit;">これを行うには、クラスター化インデックスを作成し、それを配置するファイルグループを指定する代わりに、パーティションスキームを指定する必要があります。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> clustered <span class="hljs-keyword">index</span> cix_pTest_id <span class="hljs-keyword">on</span> pTest(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">on</span> psTest(dt)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてここでも、現在のスキームで「間違い」を犯しました。この列に一意のクラスター化インデックスを作成することはできますが、一意のインデックスを作成するときは、パーティション化を実行する列をインデックスに含める必要があります。</font><font style="vertical-align: inherit;">そして、私はあなたがこの構成で遭遇することができるものを示したいと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在の構成で何が得られたかを見てみましょう（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リクエストはここから取得されます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span>
    sc.name + N<span class="hljs-string">'.'</span> + so.name <span class="hljs-keyword">as</span> [Schema.Table],<font></font>
    si.index_id <span class="hljs-keyword">as</span> [<span class="hljs-keyword">Index</span> <span class="hljs-keyword">ID</span>],<font></font>
    si.type_desc <span class="hljs-keyword">as</span> [Structure],<font></font>
    si.name <span class="hljs-keyword">as</span> [<span class="hljs-keyword">Index</span>],<font></font>
    stat.row_count <span class="hljs-keyword">AS</span> [<span class="hljs-keyword">Rows</span>],<font></font>
    stat.in_row_reserved_page_count * <span class="hljs-number">8.</span>/<span class="hljs-number">1024.</span>/<span class="hljs-number">1024.</span> <span class="hljs-keyword">as</span> [<span class="hljs-keyword">In</span>-<span class="hljs-keyword">Row</span> GB],<font></font>
    stat.lob_reserved_page_count * <span class="hljs-number">8.</span>/<span class="hljs-number">1024.</span>/<span class="hljs-number">1024.</span> <span class="hljs-keyword">as</span> [<span class="hljs-keyword">LOB</span> GB],<font></font>
    p.partition_number <span class="hljs-keyword">AS</span> [<span class="hljs-keyword">Partition</span> <span class="hljs-comment">#],</span>
    pf.name <span class="hljs-keyword">as</span> [<span class="hljs-keyword">Partition</span> <span class="hljs-keyword">Function</span>],
    <span class="hljs-keyword">CASE</span> pf.boundary_value_on_right
        <span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> <span class="hljs-string">'Right / Lower'</span>
        <span class="hljs-keyword">ELSE</span> <span class="hljs-string">'Left / Upper'</span>
    <span class="hljs-keyword">END</span> <span class="hljs-keyword">as</span> [Boundary <span class="hljs-keyword">Type</span>],<font></font>
    prv.value <span class="hljs-keyword">as</span> [Boundary Point],<font></font>
    fg.name <span class="hljs-keyword">as</span> [Filegroup]
<span class="hljs-keyword">FROM</span> sys.partition_functions <span class="hljs-keyword">AS</span> pf
<span class="hljs-keyword">JOIN</span> sys.partition_schemes <span class="hljs-keyword">as</span> ps <span class="hljs-keyword">on</span> ps.function_id=pf.function_id
<span class="hljs-keyword">JOIN</span> sys.indexes <span class="hljs-keyword">as</span> si <span class="hljs-keyword">on</span> si.data_space_id=ps.data_space_id
<span class="hljs-keyword">JOIN</span> sys.objects <span class="hljs-keyword">as</span> so <span class="hljs-keyword">on</span> si.object_id = so.object_id
<span class="hljs-keyword">JOIN</span> sys.schemas <span class="hljs-keyword">as</span> sc <span class="hljs-keyword">on</span> so.schema_id = sc.schema_id
<span class="hljs-keyword">JOIN</span> sys.partitions <span class="hljs-keyword">as</span> p <span class="hljs-keyword">on</span> <font></font>
    si.object_id=p.object_id <font></font>
    <span class="hljs-keyword">and</span> si.index_id=p.index_id
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> sys.partition_range_values <span class="hljs-keyword">as</span> prv <span class="hljs-keyword">on</span> prv.function_id=pf.function_id
    <span class="hljs-keyword">and</span> p.partition_number= 
        <span class="hljs-keyword">CASE</span> pf.boundary_value_on_right <span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span>
            <span class="hljs-keyword">THEN</span> prv.boundary_id + <span class="hljs-number">1</span>
        <span class="hljs-keyword">ELSE</span> prv.boundary_id
        <span class="hljs-keyword">END</span>
        <span class="hljs-comment">/* For left-based functions, partition_number = boundary_id, 
           for right-based functions we need to add 1 */</span>
<span class="hljs-keyword">JOIN</span> sys.dm_db_partition_stats <span class="hljs-keyword">as</span> stat <span class="hljs-keyword">on</span> stat.object_id=p.object_id
    <span class="hljs-keyword">and</span> stat.index_id=p.index_id
    <span class="hljs-keyword">and</span> stat.index_id=p.index_id <span class="hljs-keyword">and</span> stat.partition_id=p.partition_id
    <span class="hljs-keyword">and</span> stat.partition_number=p.partition_number
<span class="hljs-keyword">JOIN</span> sys.allocation_units <span class="hljs-keyword">as</span> au <span class="hljs-keyword">on</span> au.container_id = p.hobt_id
    <span class="hljs-keyword">and</span> au.type_desc =<span class="hljs-string">'IN_ROW_DATA'</span> 
        <span class="hljs-comment">/* Avoiding double rows for columnstore indexes. */</span>
        <span class="hljs-comment">/* We can pick up LOB page count from partition_stats */</span>
<span class="hljs-keyword">JOIN</span> sys.filegroups <span class="hljs-keyword">as</span> fg <span class="hljs-keyword">on</span> fg.data_space_id = au.data_space_id
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> [Schema.Table], [<span class="hljs-keyword">Index</span> <span class="hljs-keyword">ID</span>], [<span class="hljs-keyword">Partition</span> <span class="hljs-keyword">Function</span>], [<span class="hljs-keyword">Partition</span> <span class="hljs-comment">#];</span></code></pre><br>
<img src="https://habrastorage.org/webt/72/qu/op/72quopaqu1glcalpur92qrwy6eo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、あまりうまくいかなかった3つのセクションを受け取りました。最初のストアのデータは、最初から04/01/2018 00:00:00まで、2番目のストアは、01/01/2018 00:00:01から08/01/2018 00:00:00までです。 3番目は2018年1月8日00:00:01から世界の終わりまで（SQL Serverがこれらの分数を書き込むグラデーションを覚えていないため、意図的に1秒の分数を逃しましたが、意味は正しく伝えられています）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、dummy_intフィールドに非クラスター化インデックスを作成し、同じパーティションスキームに従って「整列」します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜ整列インデックスが必要なのですか？</font></font></b><div class="spoiler_text">   ,        (switch) –      ,  , ,    .          —      <br>
</div></div><br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> nonclustered <span class="hljs-keyword">index</span> nix_pTest_dummyINT <span class="hljs-keyword">on</span> pTest(dummy_int) <span class="hljs-keyword">on</span> psTest(dt);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、セクショニングの実装後にクエリが遅くなる可能性があると私が言った理由を見てみましょう。</font><font style="vertical-align: inherit;">リクエストを実行します。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">ON</span>;<font></font>
<font></font>
<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> 
<span class="hljs-keyword">from</span> pTest
<span class="hljs-keyword">where</span> dummy_int = <span class="hljs-number">54</span> <font></font>
<font></font>
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">OFF</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、実行統計を見てみましょう：</font></font><br>
<br>
<pre><code class="sql hljs">Table 'ptest'. Scan count 3, logical reads 6, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして実装計画：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-i/ey/ay/-ieyay17s-rifng9eaij7bobfes.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インデックスはセクションごとに「調整」されているため、条件付きで、各セクションには独自のインデックスがあり、他のセクションのインデックスとは「関連付けられていません」。</font><font style="vertical-align: inherit;">インデックスがパーティション化されるフィールドに条件を課していなかったため、SQL Serverは各セクションでインデックスシークを実行するよう強制され、実際には1つではなく3つのインデックスシークを実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つのセクションを除外してみましょう。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">ON</span>;<font></font>
<font></font>
<span class="hljs-keyword">select</span> <span class="hljs-keyword">id</span> 
<span class="hljs-keyword">from</span> pTest
<span class="hljs-keyword">where</span> dummy_int = <span class="hljs-number">54</span> 
<span class="hljs-keyword">and</span> dt &lt; <span class="hljs-string">'20180801'</span><font></font>
<font></font>
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">OFF</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、実行統計を見てみましょう：</font></font><br>
<br>
<pre><code class="sql hljs">Table 'ptest'. Scan count 2, logical reads 4, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ええ、1つのセクションが除外され、目的の値の検索は2つのセクションでのみ実行されました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、パーティショニングを決定する際に覚えておかなければならないことです。</font><font style="vertical-align: inherit;">テーブルが分割されるフィールドの制限を使用しないクエリがある場合、問題がある可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非クラスター化インデックスは不要になったため、削除します</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> nix_pTest_dummyINT <span class="hljs-keyword">on</span> pTest;</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、なぜ非クラスターインデックスが必要でしたか？</font></font></b><div class="spoiler_text">,  -    ,         ,     ,        —    <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、次のシナリオを考えます。このテーブルのデータを4か月ごとにアーカイブします。古いデータを削除し、次の4か月のセクションを追加します（「スライディングウィンドウ」の構成については、msdnとブログのヒープで説明しています）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクを小さくてわかりやすいサブタスクに分割します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2019/01/01から2019/01/01までのデータのセクションを追加</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空のステージテーブルを作成する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステージングテーブルのデータセクションを2018年4月1日まで切り替えます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空のセクションを取り除く</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
始めましょう：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. FG1ファイルグループに新しいセクションが作成されることをお知らせします。まもなく、このセクションから解放されます。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">partition</span> scheme psTest
<span class="hljs-keyword">next</span> used [FG1];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、新しい境界線を追加して、パーティション関数を変更します。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">ON</span>;<font></font>
<font></font>
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">partition</span> <span class="hljs-keyword">function</span> pfTest() <span class="hljs-keyword">split</span> <span class="hljs-keyword">range</span> (<span class="hljs-string">'20190101'</span>);<font></font>
<font></font>
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">OFF</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
統計を見てみましょう：</font></font><br>
<br>
<pre><code class="sql hljs">Table 'ptest'. Scan count 1, logical reads 76171, physical reads 0, read-ahead reads 753, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<font></font>
Table 'Worktable'. Scan count 1, logical reads 7440, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テーブル（クラスターインデックス）には8809ページがあるので、当然ながら読み取りの数は善悪を超えています。セクションに何があるか見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s0/hy/yx/s0hyyxxh7iny_jc3t3k48ca83hs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、すべてが期待どおりでした-上限のある新しいセクションが表示されました（私たちの境界条件は左側のセクションに属していることに注意してください）01/01/2019と、より長い日付を持つ他のデータがある空のセクション。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべては問題ないようですが、なぜそれほど多くの測定値があるのですか？上の図を注意深く見ると、FG3にあった3番目のセクションからのデータはFG1で終わりましたが、次のセクションである空はFG3にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.ステージテーブルを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セクションをテーブルに（またはその逆に）切り替えるには、パーティション化されたテーブルと同じ制限とインデックスがすべて作成された空のテーブルが必要です。</font><font style="vertical-align: inherit;">テーブルは、ここで「切り替え」たいセクションと同じファイルグループにある必要があります。</font><font style="vertical-align: inherit;">最初の（アーカイブされた）セクションはFG1にあるため、同じ場所にテーブルとクラスターインデックスを作成します。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> stageTest (<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">identity</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), dt datetime, dummy_int <span class="hljs-built_in">int</span>, dummy_char <span class="hljs-built_in">char</span>(<span class="hljs-number">6000</span>)) ;
<span class="hljs-keyword">create</span> clustered <span class="hljs-keyword">index</span> cix_stageTest_id <span class="hljs-keyword">on</span> stageTest(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">on</span> [FG1];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このテーブルを分割する必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.これで、切り替える準備ができました。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">ON</span>;<font></font>
<font></font>
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> pTest <span class="hljs-keyword">switch</span> <span class="hljs-keyword">partition</span> <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> stageTest<font></font>
<font></font>
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">OFF</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これが私たちが得るものです：</font></font><br>
<br>
<pre><code class="sql hljs"> 4947,  16,  1,  59
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">SWITCH</span> <span class="hljs-keyword">statement</span> failed. There <span class="hljs-keyword">is</span> <span class="hljs-keyword">no</span> identical <span class="hljs-keyword">index</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">source</span> <span class="hljs-keyword">table</span> <span class="hljs-string">'PartitionTest.dbo.pTest'</span> <span class="hljs-keyword">for</span> the <span class="hljs-keyword">index</span> <span class="hljs-string">'cix_stageTest_id'</span> <span class="hljs-keyword">in</span> target <span class="hljs-keyword">table</span> <span class="hljs-string">'PartitionTest.dbo.stageTest'</span> .</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おかしい、インデックスに何があるか見てみましょう：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">select</span> o.name tblName, i.name indexName, c.name columnName, ic.is_included_column
<span class="hljs-keyword">from</span> sys.indexes i
<span class="hljs-keyword">join</span> sys.objects o <span class="hljs-keyword">on</span> i.object_id = o.object_id
<span class="hljs-keyword">join</span> sys.index_columns ic <span class="hljs-keyword">on</span> ic.object_id = i.object_id <span class="hljs-keyword">and</span> ic.index_id = i.index_id
<span class="hljs-keyword">join</span> sys.columns c <span class="hljs-keyword">on</span> ic.column_id = c.column_id <span class="hljs-keyword">and</span> o.object_id = c.object_id 
<span class="hljs-keyword">where</span> o.name <span class="hljs-keyword">in</span> (<span class="hljs-string">'pTest'</span>, <span class="hljs-string">'stageTest'</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/8e/mf/1u/8emf1uqyw18p6rghqkv3enygfx0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーティションテーブルに一意のクラスター化インデックスを作成する必要があると書いたことを覚えていますか？</font><font style="vertical-align: inherit;">それがまさにそれが必要だった理由です。</font><font style="vertical-align: inherit;">一意のクラスター化インデックスを作成する場合、SQL Serverでは、テーブルをパーティションに分割するための列をインデックスに明示的に含める必要があるため、自分で追加し、そのことを忘れていました。</font><font style="vertical-align: inherit;">そして、その理由は本当にわかりません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、一般的には問題は理解できます。ステージテーブルにクラスターインデックスを再作成します。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> clustered <span class="hljs-keyword">index</span> cix_stageTest_id <span class="hljs-keyword">on</span> stageTest(<span class="hljs-keyword">id</span>, dt) <span class="hljs-keyword">with</span> (drop_existing = <span class="hljs-keyword">on</span>) <span class="hljs-keyword">on</span> [FG1];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、もう一度、セクションを切り替えようとします。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">ON</span>;<font></font>
<font></font>
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> pTest <span class="hljs-keyword">switch</span> <span class="hljs-keyword">partition</span> <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> stageTest<font></font>
<font></font>
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">OFF</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タダム！</font><font style="vertical-align: inherit;">セクションが切り替わります。コストがかかるのを確認してください：</font></font><br>
<br>
<pre><code class="sql hljs">SQL Server parse and compile time: <font></font>
   CPU time = 0 ms, elapsed time = 0 ms.<font></font>
<font></font>
 SQL Server Execution Times:<font></font>
   CPU time = 0 ms,  elapsed time = 0 ms.<font></font>
SQL Server parse and compile time: <font></font>
   CPU time = 0 ms, elapsed time = 0 ms.<font></font>
<font></font>
 SQL Server Execution Times:<font></font>
   CPU time = 0 ms,  elapsed time = 0 ms.<font></font>
<font></font>
 SQL Server Execution Times:<font></font>
   CPU time = 0 ms,  elapsed time = 3 ms.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、何も。セクションを空のテーブルに、またはその逆に（完全なテーブルを空のセクションに）切り替えることは、メタデータのみに対する操作であり、これがまさにパーティション化が非常に優れた理由である理由です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのセクションの内容を見てみましょう：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mb/7j/pl/mb7jpl32ekb7e-vgl3mjfczd1ru.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが彼らにとって素晴らしいです。最初のセクションでは、レコードが残っていません。それらは、stageTestテーブルに安全に残されています。私たちは、上で移動させることができ</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、私たちのための遺骨は、私たちの空の最初のセクションを削除することであること4.すべて。実行して何が起こるかを確認します。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">ON</span>;<font></font>
<font></font>
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">partition</span> <span class="hljs-keyword">function</span> pfTest() <span class="hljs-keyword">merge</span> <span class="hljs-keyword">range</span> (<span class="hljs-string">'20180401'</span>);<font></font>
<font></font>
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">OFF</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これもメタデータのみの操作です。</font><font style="vertical-align: inherit;">セクションを見てみましょう。現状では、セクション</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ju/ce/lf/jucelfzq4upnfi3fqg_8snuurho.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
は3つしかありません。それぞれ独自のファイルグループにあります。</font><font style="vertical-align: inherit;">任務完了。</font><font style="vertical-align: inherit;">ここで何を改善できるでしょうか？</font><font style="vertical-align: inherit;">さて、最初に、境界値が「正しい」セクションを参照するようにして、セクションに4か月間のすべてのデータが含まれるようにします。</font><font style="vertical-align: inherit;">そして、私は新しいセクションの作成がより少ない血を要したいと思います。</font><font style="vertical-align: inherit;">テーブル自体の10倍のデータを読み取る-バスト。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今は最初のものでは何もできませんが、2つ目では試します。</font><font style="vertical-align: inherit;">2019年1月1日から2019年1月1日までのデータを含む新しいセクションを作成します。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">partition</span> scheme psTest
<span class="hljs-keyword">next</span> used [FG2];
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">ON</span>;<font></font>
<font></font>
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">partition</span> <span class="hljs-keyword">function</span> pfTest() <span class="hljs-keyword">split</span> <span class="hljs-keyword">range</span> (<span class="hljs-string">'20190401'</span>);<font></font>
<font></font>
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">OFF</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして私たちは見る：</font></font><br>
<br>
<pre><code class="sql hljs">SQL Server parse and compile time: <font></font>
   CPU time = 0 ms, elapsed time = 0 ms.<font></font>
<font></font>
 SQL Server Execution Times:<font></font>
   CPU time = 0 ms,  elapsed time = 0 ms.<font></font>
SQL Server parse and compile time: <font></font>
   CPU time = 0 ms, elapsed time = 0 ms.<font></font>
<font></font>
 SQL Server Execution Times:<font></font>
   CPU time = 0 ms,  elapsed time = 0 ms.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハ！</font><font style="vertical-align: inherit;">つまり、この操作はメタデータのみに対して行われるのですか？</font><font style="vertical-align: inherit;">はい、空のセクションを「分割」した場合-これはメタデータのみに対する操作であるため、保証された空のセクションの左と右の両方のセクションを保持し、必要に応じて新しいセクションを選択することは正しい決定です-そこから「カット」します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ステージテーブルのデータをパーティションテーブルに戻したい場合にどうなるかを見てみましょう。</font><font style="vertical-align: inherit;">これを行うには、次のものが必要です。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左側にデータ用の新しいセクションを作成します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テーブルをこのセクションに切り替えます</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは試みます（そしてFG1のstageTestを覚えています）：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">partition</span> scheme psTest
<span class="hljs-keyword">next</span> used [FG1];
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">ON</span>;<font></font>
<font></font>
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">partition</span> <span class="hljs-keyword">function</span> pfTest() <span class="hljs-keyword">split</span> <span class="hljs-keyword">range</span> (<span class="hljs-string">'20180401'</span>);<font></font>
<font></font>
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">OFF</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは見る： </font></font><br>
<br>
<pre><code class="sql hljs">Table 'Worktable'. Scan count 0, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<font></font>
Table 'ptest'. Scan count 1, logical reads 2939, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、悪くない、すなわち </font><font style="vertical-align: inherit;">左側のセクション（分割）だけを読んでください。</font><font style="vertical-align: inherit;">はい </font><font style="vertical-align: inherit;">パーティション化されていない空でないテーブルをパーティション化されたテーブルセクションに切り替えるには、ソーステーブルに制限を設定して、SQL Serverがすべてが問題ないことを認識し、切り替えをメタデータの操作として実行できるようにします（行内のすべてを読み取り、セクションが条件に一致するかどうかを確認するのではなく） ）：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> stageTest
<span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> check_dt <span class="hljs-keyword">check</span> (dt &lt;= <span class="hljs-string">'20180401'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
切り替えようとしています：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">ON</span>;<font></font>
<font></font>
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> stageTest <span class="hljs-keyword">switch</span> <span class="hljs-keyword">to</span> pTest <span class="hljs-keyword">partition</span> <span class="hljs-number">1</span> <font></font>
<font></font>
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">OFF</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
統計：</font></font><br>
<br>
<pre><code class="sql hljs"> SQL Server Execution Times:<font></font>
   CPU time = 15 ms,  elapsed time = 39 ms.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合も、操作はメタデータに対してのみ行われます。</font><font style="vertical-align: inherit;">セクションで何があるかを見て</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c2/wv/xe/c2wvxe_ex2iyvv3v7l9hvxokq70.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いきます。</font><font style="vertical-align: inherit;">整理されているようです。</font><font style="vertical-align: inherit;">次に、関数とパーティションスキームの再作成を試みます（パーティションスキームと関数を削除し、テーブルを再作成して再充填し、新しいパーティションスキームを使用してクラスターインデックスを再作成しました）。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">partition</span> <span class="hljs-keyword">function</span> pfTest (datetime) <span class="hljs-keyword">as</span> <span class="hljs-keyword">range</span> <span class="hljs-keyword">right</span>
<span class="hljs-keyword">for</span> <span class="hljs-keyword">values</span> (<span class="hljs-string">'20180401'</span>, <span class="hljs-string">'20180801'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが今持っているセクションを見てみましょう：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/b6/mw/j2/b6mwj2konz7su7x_ng5eonsgukw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すばらしい、これで3つの「論理的な」セクションができました-開始から04/01/2018 00:00:00（非包括的）、04/01/2018 00:00:00（包括的）まで2018年8月1日00:00:00（包括的ではない）および3番目、2018年8月1日00:00:00以上のすべて。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、前のパーティション関数で実行したのと同じデータのアーカイブタスクを実行してみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.新しいセクションを追加します。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">partition</span> scheme psTest
<span class="hljs-keyword">next</span> used [FG1];
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">ON</span>;<font></font>
<font></font>
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">partition</span> <span class="hljs-keyword">function</span> pfTest() <span class="hljs-keyword">split</span> <span class="hljs-keyword">range</span> (<span class="hljs-string">'20190101'</span>);<font></font>
<font></font>
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">OFF</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
統計を見てみましょう：</font></font><br>
<br>
<pre><code class="sql hljs">Table 'Worktable'. Scan count 0, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<font></font>
Table 'ptest'. Scan count 1, logical reads 3685, physical reads 0, read-ahead reads 4, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.<font></font>
Table 'Worktable'. Scan count 1, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
悪くない、少なくとも合理的に-彼らは最後のセクションを読むだけです。</font><font style="vertical-align: inherit;">セクションの内容を確認します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1l/yr/i9/1lyri90cqmu969imje4edli1e7m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完成した3番目のセクションはFG3に残り、FG1には新しい空のセクションが作成されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.ステージテーブルとそれに正しいクラスタインデックスを作成します</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> stageTest (<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">identity</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), dt datetime, dummy_int <span class="hljs-built_in">int</span>, dummy_char <span class="hljs-built_in">char</span>(<span class="hljs-number">6000</span>)) ;
<span class="hljs-keyword">create</span> clustered <span class="hljs-keyword">index</span> cix_stageTest_id <span class="hljs-keyword">on</span> stageTest(<span class="hljs-keyword">id</span>, dt)  <span class="hljs-keyword">on</span> [FG1];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.スイッチセクション</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">ON</span>;<font></font>
<font></font>
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> pTest <span class="hljs-keyword">switch</span> <span class="hljs-keyword">partition</span> <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> stageTest<font></font>
<font></font>
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">OFF</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
統計によると、メタデータ操作は次のとおりです。</font></font><br>
<br>
<pre><code class="sql hljs">SQL Server Execution Times:<font></font>
   CPU time = 0 ms,  elapsed time = 5 ms.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、驚きはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4.不要な部分を削除する</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">ON</span>;<font></font>
<font></font>
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">partition</span> <span class="hljs-keyword">function</span> pfTest() <span class="hljs-keyword">merge</span> <span class="hljs-keyword">range</span> (<span class="hljs-string">'20180401'</span>);<font></font>
<font></font>
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">STATISTICS</span> <span class="hljs-built_in">TIME</span>, IO <span class="hljs-keyword">OFF</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてここに驚きがあります：</font></font><br>
<br>
<pre><code class="sql hljs">Table 'ptest'. Scan count 1, logical reads 27057, physical reads 0, read-ahead reads 251, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セクションの内容を確認します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qn/_j/xr/qn_jxrttkmls8amaycjwxqrescu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで明らかになります。セクション＃2がfg2ファイルグループからfg1ファイルグループに移動しました。</font><font style="vertical-align: inherit;">クラス。</font><font style="vertical-align: inherit;">これについて何かできますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たぶん、常に空のセクションを用意し、「常に空の」左側のセクションと別のテーブルに「切り替えた」セクションの間の境界を「破棄」する必要があるだけかもしれません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論として：</font></font></b><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パーティション作成関数の完全な構文を使用します。デフォルト値に依存しないでください。必要なものが得られない場合があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空のセクションを左と右に維持します。「スライドウィンドウ」を構成するときに非常に役立ちます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空でないセクションを分割してマージします-常に傷つきます。可能であればこれを避けてください。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クエリを確認します。テーブルをパーティション分割する予定の列でフィルターを使用せず、セクションを切り替える機能が必要な場合は、パフォーマンスが大幅に低下する可能性があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何かしたい場合は、最初に本番環境ではなくテストしてください。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
資料がお役に立てば幸いです。</font><font style="vertical-align: inherit;">おそらくそれはしわくちゃになっていることが判明したかもしれませんが、宣言されたものの何かが明らかにされていないと思ったら、書いてください、私はそれを終えようとします。</font><font style="vertical-align: inherit;">ご清聴ありがとうございました。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja464651/index.html">AVRマイクロコントローラー用のアセンブラーコードジェネレーターライブラリ。パート5</a></li>
<li><a href="../ja464655/index.html">プログラミング言語の給与と人気は過去2年間でどのように変化したか</a></li>
<li><a href="../ja464657/index.html">電気コーニスAM82TVのリバースエンジニアリング</a></li>
<li><a href="../ja464659/index.html">アプリケーションのセキュリティ、またはカスタム開発にセキュリティを組み込む方法。AGIMAでの個人的な経験</a></li>
<li><a href="../ja464661/index.html">技術的再設備および再建施設の設計を誰に委託するか</a></li>
<li><a href="../ja464671/index.html">ViberおよびTelegramのインスタントメッセンジャーに定期的にSMSを受信します（GoIPゲートウェイを使用）</a></li>
<li><a href="../ja464673/index.html">TinyFL-マイクロコントローラーフラッシュライトドライバー</a></li>
<li><a href="../ja464675/index.html">Splunkのアプリケーションインターフェイスローカリゼーションメカニズムの分析</a></li>
<li><a href="../ja464677/index.html">証券取引所への投資と関連費用：証券会社のサービスはいくらですか</a></li>
<li><a href="../ja464679/index.html">Voxgun-余計な手間をかけずにプロフェッショナルなビデオコンテンツを作成するためのサービス</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>