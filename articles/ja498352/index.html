<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🔬 🏷️ 🧓🏾 SHISHUA：世界最速の疑似乱数ジェネレーター 👂🏽 🐙 👩🏾‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="6か月前、私はいくつかの変わったアーキテクチャで最高の疑似乱数ジェネレータ（PRNG）を作成したいと思っていました。最初は簡単だと思いました。作業を進めるにつれて、タスクは徐々に複雑になります。そして、最も難しい問題に対処するのに十分な速さですべてを学ぶことができるかと思いました。
 
 驚いたこと...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SHISHUA：世界最速の疑似乱数ジェネレーター</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/498352/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/ex/bl/5pexblhd_seedlgm8iidkfktef4.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6か月前、私はいくつかの変わったアーキテクチャで最高の疑似乱数ジェネレータ（PRNG）を作成したいと思っていました。最初は簡単だと思いました。作業を進めるにつれて、タスクは徐々に複雑になります。そして、最も難しい問題に対処するのに十分な速さですべてを学ぶことができるかと思いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
驚いたことに、複雑さは直線的に増加しませんでした。カイ二乗バイトのテストは非常に難しいことが判明しました！後に、ハードテストに合格するのも同じくらい困難でした。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在の結果</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">公開して、</font></a><font style="vertical-align: inherit;">他にどんな困難が待ち受けているかを理解しました。ただし</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その時点でPractRandテストは失敗しました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、BigCrushテスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">合格</font></a><font style="vertical-align: inherit;">するのは非常に困難</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">でした</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、PractRandを渡すときに32テラバイトのデータを転送することは非常に困難でした。</font><font style="vertical-align: inherit;">スピードが問題になっています。</font><font style="vertical-align: inherit;">PractRandの合格には1か月かかるため、毎秒10メガバイトを生成するデザインを作成するだけでは不十分でした。</font><font style="vertical-align: inherit;">しかし</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ギガバイト/秒の速度でこのテスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">合格</font></a><font style="vertical-align: inherit;">すること</font><font style="vertical-align: inherit;">は非常に困難</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">あっ</font><font style="vertical-align: inherit;">たこと</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">認めざるを得ません</font><font style="vertical-align: inherit;">。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
こんなに高いところまで上がったら……パレート国境に行けるかどうか知りたい。</font><font style="vertical-align: inherit;">最も複雑な統計テストに合格する世界最速のPRNGを作成したいとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は成功しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前の記事、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は私が私の目標を達成するために学んだことについて話しました。</font><font style="vertical-align: inherit;">そしてここでは、最終的なアーキテクチャがどのように機能するかを説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目的</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明白から始めましょう：</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速度はプラットフォームに依存します</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私は最新のx86-64アーキテクチャー（IntelおよびAMDプロセッサー）の最適化に焦点を当てました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パフォーマンスを比較するために、従来の</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メトリックが使用され</font><font style="vertical-align: inherit;">ます。これは、1バイトの生成に費やされたプロセッササイクルの数です。</font><font style="vertical-align: inherit;">このメトリックは</font><font style="vertical-align: inherit;">、すべての暗号化作業で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計算および比較さ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れます。</font><font style="vertical-align: inherit;">ソフトウェアまたはハードウェアの世界でわずかに低いcpbは、競争での勝利または世界中のWebサイトでの使用を確実にすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
cpbを改善するには、次の方法があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じ量の作業でより多くのバイトを生成し、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または、同じバイト数を生成するための作業を減らし、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または作業を並列化します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のすべてを行います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のポイントによると、各反復でより多くのビットを生成する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「32ビットの数値が得られない場合、これはPRSPではありません」、または64ビットの数値と同じことです。または：「PRNGはx86-64アーキテクチャーのみに対応する必要があります」。まるでPOPCNTのような命令や％xmm7のようなレジスターが禁止されているかのように。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、PRNGはエンジニアリングです。ジェネレーターは数十年にわたって、プロセッサーから可能な限りすべてのものを絞り込もうとしています。 ROLが登場したとき、彼らは彼に依存し始めました。 64ビットプロセッサの登場により、彼らは％raxに依存し始めました。もちろん、そのようなアルゴリズムはARMでは低速で動作する可能性があります（これはまだ確認されていません）。ただし、64ビットのPRNは、2019年にAndroidが64ビットのサポートを要求するようになる前から積極的に使用されていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、この領域はハードウェアとともに発展しています。そして今日、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX2に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よるIntelおよびAMDプロセッサは、</font><font style="vertical-align: inherit;">すでに256ビット操作</font><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">サポートし</font></a><font style="vertical-align: inherit;">ています。 RC4は1バイトを生成し、drand48は一度に4バイト、pcg64-8バイトを生成でき、すぐに32バイトを生成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8バイトは64ビットの数値にすることができ、ほとんどのプログラミング言語にはこのための組み込み型があります。</font><font style="vertical-align: inherit;">しかし、いくつかの言語は16バイトの型を提供します（注目すべき例外は</font><font style="vertical-align: inherit;">Cの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__uint128_t</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です）。</font><font style="vertical-align: inherit;">32バイトのタイプを持つ言語はさらに少ない（内部を除く）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、PRNG関数の通常のプロトタイプ（Vigny </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HWD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベンチマークの例</font><font style="vertical-align: inherit;">）に</font><font style="vertical-align: inherit;">別れを告げることができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">static uint64_t next(void);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
代わりに、バッファを満たすジェネレータを作成できます（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私のベンチマークの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font><font style="vertical-align: inherit;">）：</font></font><br>
<br>
<pre><code class="plaintext hljs">void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このソリューションの欠点は何ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネレーターが一度に32バイトを生成する場合、コンシューマーは32の倍数の配列を提供する必要があります（理想的には32バイトで整列されます）。</font><font style="vertical-align: inherit;">なくてもかまいませんが、バッファを埋めるだけです。</font><font style="vertical-align: inherit;">未使用のデータを削除し、必要に応じて再度入力します。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遅延</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は予測できなくなります。一部の呼び出しはバッファを読み取るだけです。</font><font style="vertical-align: inherit;">しかし、平均してすべてが同じになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、より多くのバイトが生成され、同じ量の作業が行われます。</font><font style="vertical-align: inherit;">それをどのように並列化しますか？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並列処理</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセッサーは、すべてのレベルで信じられないほどの並列化ツールのセットを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、これらはSIMD命令（単一命令、複数データ）です。たとえば、AVX2は4つの64ビット加算または8つの32ビット加算などを同時に実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暗号化で約15年間使用されています。同時実行性により、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaCha20の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">驚異的なパフォーマンスが実現し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ました</font></a><font style="vertical-align: inherit;">。 AESNIを使用しない最も重要なプリミティブで使用されます。たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NORX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gimliは</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並列処理を考慮して設計されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近、このトピックへの関心は、非暗号化PRNGコミュニティでも高まっています。特に、SIMD用に設計されていない既存のプリミティブは、非常に高速なPRNを作成するための基礎となります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セバスティアーノヴィーニャは彼の昇進とき</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アーキテクチャを</font><font style="vertical-align: inherit;">ジュリア標準ライブラリでは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼が見つけた</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各操作は全てPRNRsで同時に行われた場合8競争力のある、異なった初期化PRNGインスタンスの結果は非常に迅速に連結することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMDは、プロセッサの並列化レベルの1つにすぎません。</font><font style="vertical-align: inherit;">より良いアイデアを得るために</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、このトピックに関する以前の記事を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読むことをお勧め</font><font style="vertical-align: inherit;">しますが、いくつか説明します。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセッサパイプラインを</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用すると、複数の命令をさまざまな段階で処理できます。ステージ間の依存関係を減らすために実行順序が適切に構成されている場合は、命令の処理を高速化できます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スーパースカラー実行</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">により、命令の計算部分を同時に処理できます。</font><font style="vertical-align: inherit;">ただし、このため、読み取りと書き込みの依存関係はありません。</font><font style="vertical-align: inherit;">読む前に記録することで、アーキテクチャを調整してダウンタイムのリスクを減らすことができます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並外れた実行</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">により、プロセッサは命令をシーケンス順に実行することはできませんが、前の命令がまだ準備ができていなくても、準備が整っているため、実行できます。</font><font style="vertical-align: inherit;">ただし、これには読み取り/書き込みの依存関係があってはなりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして今、実装に移ります！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建築</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
semi-SHISHUAと呼ばれるスキームを考えます。</font><font style="vertical-align: inherit;">そのような名前がどこから来たのかは、あなたが読んでいくにつれて徐々に明らかになるでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スキームは次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd8/df1/b8f/bd8df1b8fcfae4897eb4b74f2c6e856f.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
行ごとに考えてみてください。</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct prng_state {<font></font>
  __m256i state[2];<font></font>
  __m256i output;<font></font>
  __m256i counter;<font></font>
} prng_state;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状態は2つの部分に分割され、AVX2レジスタ（256ビット）に配置されます。速度を上げるために、結果を状態自体に近づけますが、状態の一部ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
64ビットカウンターもあります。計算を簡単にするために、AVX2レジスタでもあります。実際には、AVX2には小さな機能があります。通常のレジスタ（％raxなど）はMOVを介してSIMDに直接転送できません。RAMを通過する必要があり（ほとんどの場合、スタックを通過する）、遅延が増加し、2つのプロセッサ命令がかかります。 （スタック上のMOV、スタックからのVM​​OV）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、世代を見てみましょう。ロードから始めて、バッファを通過し、反復ごとに32バイトでそれを埋めましょう。</font></font><br>
<br>
<pre><code class="plaintext hljs">inline void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size) {<font></font>
  __m256i s0 = s-&gt;state[0], counter = s-&gt;counter,<font></font>
          s1 = s-&gt;state[1],       o = s-&gt;output;<font></font>
  for (__uint64_t i = 0; i &lt; size; i += 4) {<font></font>
    _mm256_storeu_si256((__m256i*)&amp;buf[i], o);<font></font>
    // …<font></font>
  }<font></font>
  s-&gt;state[0] = s0; s-&gt;counter = counter;<font></font>
  s-&gt;state[1] = s1; s-&gt;output  = o;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数はインラインであるため、起動時にバッファをすぐに満たすと、プロセッサはこれに応じて、並外れた実行メカニズムを通じて命令をすぐに実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ループ内では、3つの状態操作をすばやく実行します。</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ft</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイル</font></font></li>
<li><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DD</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、SHISHUAという名前です！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まず、シフト</font></font></h3><br>
<pre><code class="plaintext hljs">u0 = _mm256_srli_epi64(s0, 1);              u1 = _mm256_srli_epi64(s1, 3);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、AVX2はリビジョンをサポートしていません。</font><font style="vertical-align: inherit;">しかし、64ビット数の1つの位置のビットを別の位置のビットと混在させたいです。</font><font style="vertical-align: inherit;">そして、シフトはこれを実現する最良の方法です。</font><font style="vertical-align: inherit;">奇数だけシフトして、各ビットが64ビットの位置の半分ではなくすべてのビットにアクセスするようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シフト中に、ビットが失われ、それによって情報が私たちの州から削除されます。</font><font style="vertical-align: inherit;">これは悪いことです。損失を最小限に抑える必要があります。</font><font style="vertical-align: inherit;">最小の奇数は1と3で、2つの部分の不一致を増やすために異なるシフト値を使用します。</font><font style="vertical-align: inherit;">これは、それらの自己相関の類似性を減らすのに役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
加算時に右端のビットの拡散が最小になるため、右にシフトします。たとえば、A + Bの最下位ビットは、最下位ビットAとBのXORです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">撹拌</font></font></h3><br>
<pre><code class="plaintext hljs">t0 = _mm256_permutevar8x32_epi32(s0, shu0); t1 = _mm256_permutevar8x32_epi32(s1, shu1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
32ビットミキシングを使用します。これは、あらゆる場所で使用する64ビット操作とは異なる細分性を提供するためです（64ビットアライメントに違反します）。さらに、これはクロスレーン操作になる可能性があります。他のシャッフルは、左から開始する場合は左の128ビット内で、右から開始する場合は右の128ビット内でビットを移動できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
混合定数：</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i shu0 = _mm256_set_epi32(4, 3, 2, 1, 0, 7, 6, 5),<font></font>
        shu1 = _mm256_set_epi32(2, 1, 0, 7, 6, 5, 4, 3);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ミキシングによって結果が本当に改善されるように、64ビットの加算の弱い（分散が小さい）32ビットの部分を強い位置に移動し、次の追加でそれらを豊かにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
64ビットチャンクの下位32ビット部分が、上位部分と同じ64ビットチャンクに移動することはありません。</font><font style="vertical-align: inherit;">したがって、両方の部分が同じチャンク内にとどまることはなく、混合が改善されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結局、各32ビットパーツは、AからB、BからC、... HからAのように、円のすべての位置を通過</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
します。これらすべての要件を考慮する最も単純なミキシングは、2つの256ビットであることに気づいたかもしれません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ターンオーバー（それぞれ96ビットと160ビットの右への回転）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シフトとミキシングという2つの一時変数から64ビットのチャンクを追加してみましょう。</font></font><br>
<br>
<pre><code class="plaintext hljs">s0 = _mm256_add_epi64(t0, u0);              s1 = _mm256_add_epi64(t1, u1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
加算が分散の主な原因です。この操作では、ビットは64ビットの位置に分散されたXORおよびAND式の既約の組み合わせに結合されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
加算結果を状態内に保存すると、この分散が永久に保存されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出力機能</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どこから出力を取得しますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シンプルです。作成した構造により、2つの独立した状態パーツs0とs1を生成できます。これらのパーツは互いに影響を与えません。</font><font style="vertical-align: inherit;">それらにXORを適用し、完全にランダムな結果を取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XORを適用するデータ間の独立性を強化するために、1つの状態のシフト部分と別の状態の混合部分の部分的な結果を取得します。</font></font><br>
<br>
<pre><code class="plaintext hljs">o = _mm256_xor_si256(u0, t1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、u0とt1がs0とs1に読み取る準備ができているかのように、スーパースカラープロセッサの命令間の読み取りと書き込みの依存関係を減らすことに似ています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カウンターについて説明します。サイクルの最初に処理します。まず、状態を変更してから、カウンター値を増やします。</font></font><br>
<br>
<pre><code class="plaintext hljs">s1 = _mm256_add_epi64(s1, counter);<font></font>
counter = _mm256_add_epi64(counter, increment);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に状態を変更してからカウンターを更新するのはなぜですか？ s1はより早く利用可能になるため、これを読み取る後続の命令がプロセッサパイプラインで停止する可能性が低くなります。また、このシーケンスは、読み書きカウンターの直接依存を回避するのに役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カウンターはs0ではなくs1に適用します。どちらもいずれにしても出力に影響を与えるためですが、s1はシフトにより多くのビットを失うため、シフト後に「立ち上がる」のに役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カウンターはPractRandテストを記録しない場合があります。その唯一の目的は、下限を2 </font><sup><font style="vertical-align: inherit;">69</font></sup><font style="vertical-align: inherit;">に設定することです</font></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイト= PRNG期間の512エクスビバイト：サイクルを繰り返し始めるのは、1千年の作業が毎秒10ギバイトの速度で行われた後です。今後数世紀にわたって実用化するには遅すぎるとは考えられません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インクリメント：</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i increment = _mm256_set_epi64x(1, 3, 5, 7);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本の素数のみが有限体GF（2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">サイクル全体をカバーし、</font><font style="vertical-align: inherit;">すべての奇数は2の素数であるため、奇数は</font><font style="vertical-align: inherit;">増分として選択されます</font><font style="vertical-align: inherit;">。つまり、0から4、4の後に0に戻ると、シーケンス0-2-0-2- ...がわかります。これは、1または3につながることはありません。そして、奇数の増分はすべての整数を通過します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状態にあるすべての64ビット数について、異なる奇数を使用します。これにより、さらに奇数が分離され、混合がわずかに増加します。</font><font style="vertical-align: inherit;">奇妙な数字にならないように、最小の奇数を選びました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが、状態遷移と出力機能の仕組みです。</font><font style="vertical-align: inherit;">それらを初期化する方法は？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初期化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16進数Φを使用して状態を初期化します。Φは、分数で最も近似されない無理数です。</font></font><br>
<br>
<pre><code class="plaintext hljs">static __uint64_t phi[8] = {<font></font>
  0x9E3779B97F4A7C15, 0xF39CC0605CEDC834, 0x1082276BF3A27251, 0xF86C6A11D0C18E95,<font></font>
  0x2767F0B153D27B7F, 0x0347045B5BF1827F, 0x01886F0928403002, 0xC1D64BA40F335E36,<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256ビットのシードを取ります。</font><font style="vertical-align: inherit;">これは多くの場合、暗号化で行われ、非暗号化PRNGの作業には影響しません。</font></font><br>
<br>
<pre><code class="plaintext hljs">prng_state prng_init(SEEDTYPE seed[4]) {<font></font>
  prng_state s;<font></font>
  // …<font></font>
  return s;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この初期番号で状態の全体（s0またはs1）を再定義する必要はなく、半分に影響を与えるだけで済みます。</font><font style="vertical-align: inherit;">このようにして、偶然または意図的に既知の弱い初期状態を生じさせる減衰初期値の使用を回避します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各状態の半分は変更しないため、128のステータスビットを制御できます。</font><font style="vertical-align: inherit;">このようなエントロピーは、強い地位を​​築き、維持するのに十分です。</font></font><br>
<br>
<pre><code class="plaintext hljs">s.state[0] = _mm256_set_epi64x(phi[3], phi[2] ^ seed[1], phi[1], phi[0] ^ seed[0]);<font></font>
s.state[1] = _mm256_set_epi64x(phi[7], phi[6] ^ seed[3], phi[5], phi[4] ^ seed[2]);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、</font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のシーケンス</font><font style="vertical-align: inherit;">を（</font><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">数回繰り返し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHISHUA反復</font><font style="vertical-align: inherit;">のステップ（</font><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">実行します</font><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態の一部を別の状態に割り当て、他の部分を出力に割り当てます。</font></font></li>
</ol><br>
<pre><code class="plaintext hljs">for (char i = 0; i &lt; ROUNDS; i++) {<font></font>
  prng_gen(&amp;s, buf, 4 * STEPS);<font></font>
  s.state[0] = s.state[1];<font></font>
  s.state[1] = s.output;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出力結果を割り当てると、状態のばらつきが大きくなります。</font><font style="vertical-align: inherit;">初期化時には、この一連の操作が1回実行されるため、追加の作業と状態の相関は重要ではありません。</font><font style="vertical-align: inherit;">初期化中の分散のみに関心があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期値の相関関係への影響を評価した後、</font></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値に2 </font><font style="vertical-align: inherit;">を、</font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">10 </font><font style="vertical-align: inherit;">を選択</font><font style="vertical-align: inherit;">しました。PractRandのPRNG品質管理ツールから生じる「異常な」および「疑わしい」異常を計算することによって相関関係を計算しました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの理由で速度を測定することは困難です：</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クロック測定</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は十分に正確ではないかもしれません。</font></font></li>
<li>    <strong></strong>,      , -  ,  -,       .</li>
<li>,        .        <strong></strong>   .</li>
<li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><strong>  </strong></a>:        ,       .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サイクル数を計算するRDTSCプロセッサ命令を使用しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰でも私の結果を再現できるように、私はクラウドベースの仮想マシンを使用しています。これは、ローカルテストと比較してベンチマーク結果のレベルを変更しません。さらに、私のコンピュータと同じものを購入する必要はありません。最後に、PRNGがクラウドで起動される多くの状況があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はGoogle Cloud Platform N2（Intelプロセッサー）とN2D（AMDプロセッサー）を選びました。 GCPの利点は、両方のメーカーのプロセッサを搭載したサーバーを提供することです。この記事ではIntelに焦点を当てますが、AMDの場合、結果は同じ順序になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トピックをさらに掘り下げるために、まず古いRC4暗号ジェネレーターを実行してみましょう。作業を並列化できません。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.5 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（生成されたバイトあたりのサイクル）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、非常に人気があり高速なMCGを実行します</font><font style="vertical-align: inherit;">。BigCrushテストに合格し</font><font style="vertical-align: inherit;">た</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も単純なLehmer128 PRSPは</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.5 cpbを</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示し</font><strong><font style="vertical-align: inherit;">ました</font></strong><font style="vertical-align: inherit;">。すごい！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、高速ハッシュテーブルに使用される最新の開発を実行します</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-wyrand</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.41 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、少し良いです！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のPRSPは32テラバイトのPractRandテストに合格しませんが、非常に迅速に機能します。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xoshiro256 +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は512メビバイトに達しましたが、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.34 cpbと</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に高速</font><strong><font style="vertical-align: inherit;">でした</font></strong><font style="vertical-align: inherit;">。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">RomuTrioの</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
別の最近の開発</font><font style="vertical-align: inherit;">。彼女は世界で最も速いPRNGであると主張しています</font><strong><font style="vertical-align: inherit;">-0.31 cpb</font></strong></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いいでしょうそれで十分です </font><font style="vertical-align: inherit;">semi-SHISHUAは何を示しましたか？</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.14 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">RomuTrioの2倍の速さ。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c84/f7a/c9f/c84f7ac9fcbc4d4a7b2400ae552522a4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
涼しい。</font><font style="vertical-align: inherit;">次に、暗号ジェネレーターChaCha8をテストします。</font><font style="vertical-align: inherit;">彼は... </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.12 cpbに</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">達し</font><strong><font style="vertical-align: inherit;">ました</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ああ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMDは本当の魔法です！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暗号化コミュニティにとって、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは特別な驚きではありませんでした</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ChaCha8は並列化が非常に簡単です。</font><font style="vertical-align: inherit;">これは、拡散状態のハッシュ化されたカウンタです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Julia言語チームがVignyのアーキテクチャの複数のインスタンスを組み合わせて、高速なSIMDベースのPRCHを作成しようとしたことを覚えていますか？</font><font style="vertical-align: inherit;">この手法（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xoshiro256 + 8個</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を使用して結果を見てみましょう</font><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.09 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
技術的には、私のラップトップが結果に影響を与える可能性があります。 Juliaチームの開発がGCPのChaCha8より速い理由はわかりませんが、ローカルでテストすると遅くなります。私のマシンでは、準SHISHUAはJuliaチームの開発よりも高速で実行されますが、ChaCha8よりは低速です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての競争相手を倒す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく以前のバージョンのセミSHISHUAジェネレーターを呼び出した理由をすでにお聞きでしょうか。セミSHISHUAの2つのコピーを実行すると、速度が2倍になりやすいことがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juliaコマンドのアイデアと同様に、2つのPRNG（256ビット状態の4つのブロック）を個別に初期化し、それらの作業の出力を交互に提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、さらに多くの状態を作成すると、4つの状態をペアで組み合わせることにより、さらに多くのデータを生成できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">o0 = _mm256_xor_si256(u0, t1);<font></font>
o1 = _mm256_xor_si256(u2, t3);<font></font>
o2 = _mm256_xor_si256(s0, s3);<font></font>
o3 = _mm256_xor_si256(s2, s1);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だから私たちは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.06 cpbの</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速度を示したSHISHUAを得</font><strong><font style="vertical-align: inherit;">ました</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、32テラバイトのPractRandテストに合格した、世界で最も速い競合他社の2倍の速さです。</font><font style="vertical-align: inherit;">結果はグラフにあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発は競争力のあるものになったと思います。</font><font style="vertical-align: inherit;">それは私のラップトップ-0.03 cpbでさらに速く動作しますが、ベンチマークに関する私の原則に従います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
うまくいけば、あと数週間、私の発電機が世界最速の表彰台に留まるでしょう（そうしてください）。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">品質</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネレータは、BigCrushと32テラバイトのPractRandテストに正直に合格します。そして、すべて4つの出力ストリームに感謝します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アーキテクチャの欠点には、その</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不可逆性が</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">含まれます</font><font style="vertical-align: inherit;">。これは、</font></font><code>s0 = [a, b]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">およびで</font><font style="vertical-align: inherit;">4ビット状態に削減することで確認できます</font></font><code>s1 = [c, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。シフトを使用する</font></font><code>[0, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>[0, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、および</font><font style="vertical-align: inherit;">を取得</font><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">、攪拌を使用する</font></font><code>[b, c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">および</font></font><code>[d, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。新しい</font></font><code>s0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は等しい</font></font><code>[b, c] + [0, a] = [b⊕(a∧c), a⊕c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font><code>s1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等しい</font></font><code>[d, a] + [0, c] = [d⊕(a∧c), a⊕c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。もし</font></font><code>a = ¬c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その後、</font></font><code>a⊕c = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><code>a∧c = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それゆえ、</font></font><code>s0 = [b, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>s1 = [d, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。つまり、我々は2つの組み合わせを取得</font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、</font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちと同じ最終状態を与え、。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの場合、64ビットカウンターも状態の一部であるため、これは問題ではありません。 2 </font><sup><font style="vertical-align: inherit;">71の</font></sup><font style="vertical-align: inherit;">最小サイクルが</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">わかります</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイト（状態遷移あたり128バイト）。これは10ギバイト/秒の速度です。</font><font style="vertical-align: inherit;">7000年続くでしょう。</font><font style="vertical-align: inherit;">これは失われた状態のバランスをとります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、不可逆性にもかかわらず、状態間の平均遷移期間は2 ^（（256 + 1）÷2）です。</font><font style="vertical-align: inherit;">これにより、</font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2,135</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイトの</font><font style="vertical-align: inherit;">平均サイクルが得られ</font><font style="vertical-align: inherit;">ます（10ギバイト/秒の速度で。宇宙が存在する場合よりも1兆倍以上長く続きます）。</font><font style="vertical-align: inherit;">中間サイクルは、ジェネレーターの品質について何も教えてくれないため、過大評価されていると思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ベンチマークの結果は次のとおりです。</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発生器</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンス</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">品質</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">種子の相関</font></font></strong></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHISHUA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.06</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 256 GiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 + x8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.09</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaCha8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB？</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB？</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RomuTrio</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.31</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 +</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.34</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">512 MiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワイランド</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.41</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レーマー128</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.44</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RC4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.48</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
</tbody></table></div><br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンス</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：生成された1バイトに費やされたプロセッササイクルの数。</font><font style="vertical-align: inherit;">クラウドマシンN2 GCPとN2D（AMD）で受け取った場合、順序は同じです。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">品質</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：ジェネレータがPractRandテストに合格しないレベル。</font><font style="vertical-align: inherit;">失敗しない場合は、&gt;記号があります。</font><font style="vertical-align: inherit;">結果が証明されない場合は、疑問符が付きます。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シード番号の相関</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><strong><font style="vertical-align: inherit;">シード番号が</font></strong><font style="vertical-align: inherit;"> 0、1、2、4、8、16、32、64の8つのストリームのバイトを交互に使用したPractRandトラバーサル。二重畳み込みと高度なテストでPractRandを使用します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/3f6/f1d/ea73f6f1db25664622785ba127764dbc.png"></div><br>
</li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さらに</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのケースでは不可逆性の問題はありませんが、私たちはまだSHISHUAを改善できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では、理想的なPRNGには次の特性があります。</font></font><br>
<br>
<ol>
<li><strong>      </strong>,     2<sup>1024</sup>.      10 /.    10<sup>282</sup>  ,   .    «» (  ).              ,       .  ,      128-  NEON   ARM?  ,      ,     .</li>
<li><strong>    </strong>.      ,   SHISHUA  XOR    .     ,     .</li>
<li><strong>  ,</strong>      2<sup>128</sup>    (     ).        SHISHUA,  ,  .  ,      ( )    (, , .  2).</li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態の初期化には完全な分散</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります。初期値のすべてのビットは、同じ確率で状態のすべてのビットに影響します。</font><font style="vertical-align: inherit;">しゅしあとの関わりを知りたい。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PRNGと暗号化の開発を全体として遅らせる問題の1つは、より優れた汎用ツールの不足です。</font><font style="vertical-align: inherit;">さまざまなアーキテクチャをその場で比較できるように、正確な測定結果をすぐに提供できるツールが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、PractRandは以前と比べて優れています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高品質のジェネレータを評価することはできないため、それらを互いに比較することは不可能です。</font><font style="vertical-align: inherit;">「ええと、32テラバイトを超えると異常はありません...」</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行には数週間かかります...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状況が大幅に改善されることを願っています。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja498332/index.html">Zero-Trusted Security Architecture Implementation：Second Edition</a></li>
<li><a href="../ja498334/index.html">SAP Analytics Cloudで計画プロセスを整理する方法</a></li>
<li><a href="../ja498340/index.html">新しいIDAホームについて（レビュー）</a></li>
<li><a href="../ja498346/index.html">GoLand 2020.1-Goモジュールのサポートの強化、多くのオートコンプリートなど</a></li>
<li><a href="../ja498350/index.html">就職の面接や就職活動に最適な資料</a></li>
<li><a href="../ja498354/index.html">「ウィッシュリスト」を「ハードウェア」、または半理想的なセミモバイルセミデスクトップに変換する方法</a></li>
<li><a href="../ja498358/index.html">フランス語を学ぶか、PSA診断スキャナーからユニバーサルアダプターを入手する方法</a></li>
<li><a href="../ja498360/index.html">統合サーバー負荷メトリックの評価</a></li>
<li><a href="../ja498362/index.html">キングストンはSSDの出荷においてリーダーシップを維持しています。</a></li>
<li><a href="../ja498366/index.html">Yandex開発者が毎日実装しているアルゴリズム</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>