<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✅ 👨‍🚀 🧑🏾‍🤝‍🧑🏾 PEP 572 (expresiones de asignación en python 3.8) 🎅🏼 🔆 🏷️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr Esta vez veremos PEP 572, que habla sobre expresiones de asignación. Si todavía es escéptico sobre el operador ": =" o no comprende completa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PEP 572 (expresiones de asignación en python 3.8)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499666/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hola Habr </font><font style="vertical-align: inherit;">Esta vez veremos PEP 572, que habla sobre expresiones de asignación. </font><font style="vertical-align: inherit;">Si todavía es escéptico sobre el operador ": =" o no comprende completamente las reglas para su uso, entonces este artículo es para usted. </font><font style="vertical-align: inherit;">Aquí encontrará muchos ejemplos y respuestas a la pregunta: "¿Por qué es así?" </font><font style="vertical-align: inherit;">Este artículo resultó ser lo más completo posible, y si tienes poco tiempo, mira la sección que escribí. </font><font style="vertical-align: inherit;">Al principio, las principales "tesis" se recopilan para un trabajo cómodo con expresiones de asignación. </font><font style="vertical-align: inherit;">Perdóname por adelantado si encuentras errores (escríbemelos, lo arreglaré). </font><font style="vertical-align: inherit;">Empecemos:</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PEP 572 - Expresiones de asignación</font></font></h2><div class="scrollable-table"><table>
<tbody><tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Energía</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">572</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Título:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expresiones de asignación</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autores</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris Angelico &lt;rosuav en gmail.com&gt;, Tim Peters &lt;tim.peters en gmail.com&gt;, Guido van Rossum &lt;guido en python.org&gt;</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discusión:</font></font></b></td>
<td><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doc-sig en python.org</font></font></a></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estado:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aceptado</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un tipo:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estándar</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creado:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28-feb-2018</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versión de Python:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.8</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Publicar historia:</font></font></b></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28-feb-2018, 02-mar-2018, 23-mar-2018, 04-abr-2018, 17-abr-2018, 25-abr-2018, 09-jul-2018, 05-ago-2019</font></font></td>
</tr>
<tr>
<td><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permiso para adoptar la norma:</font></font></b></td>
<td><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mail.python.org/pipermail/python-dev/2018-July/154601.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (con VPN durante mucho tiempo, pero se carga)</font></font></td>
</tr>
</tbody></table></div><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenido</font></font></b><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anotación</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Justificación</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaxis y Semántica</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La especificación cambia durante la implementación</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplos</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternativas rechazadas</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objeciones frecuentes</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recomendaciones de estilo</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gracias</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apéndice A: Conclusiones de Tim Peters</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apéndice B: Un intérprete de código aproximado para generadores</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apéndice C: Sin cambios en la semántica del alcance</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referencias</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Derechos de autor</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mi parte</font></font></a></li>
</ul><br>
<a name="ann"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anotación</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta convención hablará sobre la posibilidad de asignación dentro de expresiones, usando la nueva notación NAME: = expr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como parte de las innovaciones, se ha actualizado el procedimiento para calcular generadores de diccionario (comprensión del diccionario). Esto garantiza que la expresión clave se evalúe antes que la expresión de valor (esto le permite vincular la clave a una variable y luego reutilizar la variable creada en el cálculo del valor correspondiente a la clave). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durante una discusión de este PEP, este operador se hizo conocido extraoficialmente como el operador de la morsa. El nombre formal de la construcción es "Expresión de asignación" (de acuerdo con el título PEP: Expresiones de asignación), pero puede denominarse "Expresiones con nombre". Por ejemplo, la implementación de referencia en CPython usa este mismo nombre.</font></font><br>
<br>
<a name="oboc"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Justificación</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El nombramiento es una parte importante de la programación que le permite usar un nombre "descriptivo" en lugar de una expresión más larga, y también facilita la reutilización de valores. </font><font style="vertical-align: inherit;">Actualmente, esto solo se puede hacer en forma de instrucciones, lo que hace que esta operación no esté disponible al generar listas (comprensión de listas), así como en otras expresiones.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, nombrar partes de una expresión grande puede ayudar con la depuración interactiva al proporcionar herramientas para mostrar mensajes y resultados intermedios. </font><font style="vertical-align: inherit;">Sin la capacidad de capturar los resultados de expresiones anidadas, necesitará cambiar el código fuente, pero usando las expresiones de asignación solo necesita insertar algunos "marcadores" de la forma "nombre: = expresión". </font><font style="vertical-align: inherit;">Esto elimina la refactorización innecesaria y, por lo tanto, reduce la probabilidad de cambios involuntarios de código durante la depuración (una causa común de Heisenbugs son los errores que cambian las propiedades del código durante la depuración y pueden aparecer inesperadamente en la producción]), y este código será más comprensible para otro al programador</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La importancia del código real</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durante el desarrollo de esta PEP, muchas personas (tanto proponentes como críticos) se centraron demasiado en los ejemplos de juguetes, por un lado, y en los ejemplos demasiado complejos, por el otro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El peligro de los ejemplos de juguetes es doble: a menudo son demasiado abstractos para hacer que alguien diga "oh, esto es irresistible", y también son fácilmente rechazados con las palabras "Nunca escribiría eso". El peligro de los ejemplos demasiado complejos es que proporcionan un entorno conveniente para los críticos que sugieren que se elimine esta funcionalidad ("Esto es demasiado confuso", dicen esas personas). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, hay un buen uso de tales ejemplos: ayudan a aclarar la semántica prevista. Por lo tanto, daremos algunos de ellos a continuación. Sin embargo, para ser </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convincentes</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , los ejemplos deben basarse en</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">código </font><b><font style="vertical-align: inherit;">real</font></b><font style="vertical-align: inherit;"> que fue escrito sin pensar en este PEP. Es decir, el código que forma parte de una aplicación realmente útil (no hay diferencia: ya sea grande o pequeña). Tim Peters nos ayudó mucho mirando sus repositorios personales y eligiendo ejemplos del código que escribió, que (en su opinión) sería más comprensible si se reescribieran (sin fanatismo) usando expresiones de asignación. Su conclusión es la siguiente: los cambios actuales traerían una mejora modesta pero obvia en algunos bits de su código. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro ejemplo de código real es la observación indirecta de cómo los programadores valoran la compacidad. Guido van Rossum revisó la base de código de Dropbox y encontró alguna evidencia de que los programadores prefieren escribir menos líneas de código que usar algunas expresiones pequeñas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Caso en cuestión: Guido encontró varios puntos ilustrativos cuando un programador repite una subexpresión (lo que ralentiza el programa), pero guarda una línea adicional de código. </font><font style="vertical-align: inherit;">Por ejemplo, en lugar de escribir:</font></font><br>
<br>
<pre><code class="python hljs">match = re.match(data)<font></font>
group = match.group(<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> match <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los programadores prefirieron esta opción:</font></font><br>
<br>
<pre><code class="python hljs">group = re.match(data).group(<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> re.match(data) <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí hay otro ejemplo que muestra que los programadores a veces están dispuestos a hacer más trabajo para mantener el "nivel anterior" de sangría:</font></font><br>
<br>
<pre><code class="python hljs">match1 = pattern1.match(data)<font></font>
match2 = pattern2.match(data)<font></font>
<span class="hljs-keyword">if</span> match1:<font></font>
    result = match1.group(<span class="hljs-number">1</span>)
<span class="hljs-keyword">elif</span> match2:<font></font>
    result = match2.group(<span class="hljs-number">2</span>)
<span class="hljs-keyword">else</span>:<font></font>
    result = <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este código calcula el patrón2, incluso si el patrón1 ya coincide (en este caso, la segunda subcondición nunca se cumplirá). </font><font style="vertical-align: inherit;">Por lo tanto, la siguiente solución es más efectiva, pero menos atractiva:</font></font><br>
<br>
<pre><code class="python hljs">match1 = pattern1.match(data)
<span class="hljs-keyword">if</span> match1:<font></font>
    result = match1.group(<span class="hljs-number">1</span>)
<span class="hljs-keyword">else</span>:<font></font>
    match2 = pattern2.match(data)<font></font>
    <span class="hljs-keyword">if</span> match2:<font></font>
        result = match2.group(<span class="hljs-number">2</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        result = <span class="hljs-literal">None</span></code></pre><br>
<a name="sint"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaxis y Semántica</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la mayoría de los casos en los que Python usa expresiones arbitrarias, ahora puede usar expresiones de asignación. </font><font style="vertical-align: inherit;">Tienen la forma NOMBRE: = expr, donde expr es cualquier expresión válida de Python, excepto la tupla sin paréntesis, y NAME es el identificador. </font><font style="vertical-align: inherit;">El valor de tal expresión coincide con el original, pero un efecto adicional es la asignación de un valor al objeto de destino:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Handle a matched regex</span>
<span class="hljs-keyword">if</span> (match := pattern.search(data)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
    <span class="hljs-comment"># Do something with match</span><font></font>
<font></font>
<span class="hljs-comment"># A loop that can't be trivially rewritten using 2-arg iter()</span>
<span class="hljs-keyword">while</span> chunk := file.read(<span class="hljs-number">8192</span>):<font></font>
   process(chunk)<font></font>
<font></font>
<span class="hljs-comment"># Reuse a value that's expensive to compute</span>
[y := f(x), y**<span class="hljs-number">2</span>, y**<span class="hljs-number">3</span>]<font></font>
<font></font>
<span class="hljs-comment"># Share a subexpression between a comprehension filter clause and its output</span>
filtered_data = [y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data <span class="hljs-keyword">if</span> (y := f(x)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>]</code></pre><br>
<a name="iskluch"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casos excepcionales</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay varios lugares donde las expresiones de asignación no están permitidas para evitar ambigüedades o confusión entre los usuarios:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las expresiones de asignación no incluidas entre paréntesis están prohibidas en el nivel "superior":</font></font><br>
<br>
<pre><code class="python hljs">y := f(x)  <span class="hljs-comment"># </span>
(y := f(x))  <span class="hljs-comment"># ,   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta regla facilitará que el programador elija entre un operador de asignación y una expresión de asignación; no habrá una situación sintáctica en la que ambas opciones sean equivalentes.</font></font></li>
<li>           . :<br>
<br>
<pre><code class="python hljs">y0 = y1 := f(x)  <span class="hljs-comment"># </span>
y0 = (y1 := f(x))  <span class="hljs-comment"># ,   </span></code></pre><br>
             . :<br>
<br>
<pre><code class="python hljs">foo(x = y := f(x))  <span class="hljs-comment"># </span>
foo(x=(y := f(x)))  <span class="hljs-comment"># ,     </span></code></pre><br>
 ,               .</li>
<li>           . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer = p := <span class="hljs-number">42</span></span>):</span>  <span class="hljs-comment"># </span><font></font>
    ...<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer=(<span class="hljs-params">p := <span class="hljs-number">42</span></span>)</span>):</span>  <span class="hljs-comment"># Valid, though not great style</span>
    ...</code></pre><br>
        ,           (.    ,     «»     ).</li>
<li>           ,    . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer: p := <span class="hljs-number">42</span> = <span class="hljs-number">5</span></span>):</span>  <span class="hljs-comment"># </span><font></font>
    ...<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">answer: (<span class="hljs-params">p := <span class="hljs-number">42</span></span>) = <span class="hljs-number">5</span></span>):</span>  <span class="hljs-comment"># ,  </span>
    ...</code></pre><br>
       : ,     "="  ":="   .</li>
<li>        -. :<br>
<br>
<pre><code class="python hljs">(<span class="hljs-keyword">lambda</span>: x := <span class="hljs-number">1</span>) <span class="hljs-comment"># </span>
<span class="hljs-keyword">lambda</span>: (x := <span class="hljs-number">1</span>) <span class="hljs-comment"># ,  </span>
(x := <span class="hljs-keyword">lambda</span>: <span class="hljs-number">1</span>) <span class="hljs-comment"># </span>
<span class="hljs-keyword">lambda</span> line: (m := re.match(pattern, line)) <span class="hljs-keyword">and</span> m.group(<span class="hljs-number">1</span>) <span class="hljs-comment"># Valid</span></code></pre><br>
-    ,  ":=".       .  ,     ,    ()  ,         .</li>
<li>   f-  . :<br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f'<span class="hljs-subst">{(x:=<span class="hljs-number">10</span>)}</span>'</span>  <span class="hljs-comment"># ,  </span>
<span class="hljs-string">'10'</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>x = <span class="hljs-number">10</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">f'<span class="hljs-subst">{x:=<span class="hljs-number">10</span>}</span>'</span>    <span class="hljs-comment"># ,  ,  '=10'</span>
<span class="hljs-string">'        10'</span></code></pre><br>
 ,    ,     f-,  .  f-   ":"    .    ,      f-      .     ,      .</li>
</ul><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una expresión de asignación no introduce un nuevo alcance. En la mayoría de los casos, el alcance en el que se creará la variable no requiere explicación: será actual. Si la variable usó las palabras clave no locales o globales antes, entonces la expresión de asignación tendrá esto en cuenta. Solo lambda (que es una definición anónima de una función) se considera un ámbito separado para estos fines. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un caso especial: una expresión de asignación que se produce en los generadores de listas, conjuntos, diccionarios o en las "expresiones de los generadores" mismos (en adelante denominados colectivamente "generadores" (comprensiones)) vincula la variable al alcance que contiene el generador, observando el modificador globab o no global, si existe.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La justificación de este caso especial es doble. </font><font style="vertical-align: inherit;">En primer lugar, nos permite capturar convenientemente el "miembro" en las expresiones any () y all (), por ejemplo:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> any((comment := line).startswith(<span class="hljs-string">'#'</span>) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"First comment:"</span>, comment)
<span class="hljs-keyword">else</span>:<font></font>
    print(<span class="hljs-string">"There are no comments"</span>)<font></font>
<font></font>
<span class="hljs-keyword">if</span> all((nonblank := line).strip() == <span class="hljs-string">''</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"All lines are blank"</span>)
<span class="hljs-keyword">else</span>:<font></font>
    print(<span class="hljs-string">"First non-blank line:"</span>, nonblank)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En segundo lugar, proporciona una forma compacta de actualizar una variable desde un generador, por ejemplo:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Compute partial sums in a list comprehension</span>
total = <span class="hljs-number">0</span>
partial_sums = [total := total + v <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> values]<font></font>
print(<span class="hljs-string">"Total:"</span>, total)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, el nombre de la variable de la expresión de asignación no puede coincidir con el nombre ya utilizado en los generadores por el ciclo for para iterar. </font><font style="vertical-align: inherit;">Los apellidos son locales para el generador en el que aparecen. </font><font style="vertical-align: inherit;">Sería inconsistente si las expresiones de asignación también se refirieran al alcance dentro del generador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, [i: = i + 1 para i en el rango (5)] no es válido: el bucle for determina que i es local para el generador, pero la parte "i: = i + 1" insiste en que i es una variable desde el externo alcance </font><font style="vertical-align: inherit;">Por la misma razón, los siguientes ejemplos no funcionarán:</font></font><br>
<br>
<pre><code class="python hljs">
[[(j := j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># </span>
[i := <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff]                       <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (i := stuff)]                      <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aunque técnicamente es posible asignar una semántica consistente para tales casos, es difícil determinar si la forma en que entendemos esta semántica funcionará en su código real. Es por eso que la implementación de referencia garantiza que tales casos generen SyntaxError en lugar de ejecutarse con un comportamiento indefinido, dependiendo de la implementación particular del hardware. Esta restricción se aplica incluso si una expresión de asignación nunca se ejecuta:</font></font><br>
<br>
<pre><code class="python hljs">[<span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> (i := <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff]     <span class="hljs-comment"># </span>
[i <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> stuff <span class="hljs-keyword">if</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> (j := <span class="hljs-number">1</span>)]  <span class="hljs-comment"># </span><font></font>
<font></font>
<span class="hljs-comment"># [.  . - ""   </span>
<span class="hljs-comment"># ,       </span>
<span class="hljs-comment"># ,    ,   ]</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para el cuerpo del generador (la parte anterior a la primera palabra clave "for") y la expresión de filtro (la parte posterior al "if" y antes de cualquier "for" anidado), esta restricción se aplica exclusivamente a los nombres de variables que se utilizan simultáneamente como variables iterativas. Como ya dijimos, las expresiones Lambda introducen un nuevo alcance explícito de la función y, por lo tanto, pueden usarse en expresiones de generadores sin restricciones adicionales. [aprox. nuevamente, excepto en tales casos: [i para i en el rango (2, (lambda: (s: = 2) ()))]]</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debido a las limitaciones de diseño en la implementación de referencia (el analizador de la tabla de símbolos no puede reconocer si los nombres de la parte izquierda del generador se usan en la parte restante donde se encuentra la expresión iterable), por lo tanto, las expresiones de asignación están completamente prohibidas como parte de iterable (en la parte después de cada "in" y antes de cualquier palabra clave posterior "si" o "para"). </font><font style="vertical-align: inherit;">Es decir, todos estos casos son inaceptables:</font></font><br>
<br>
<pre><code class="python hljs">[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (j := stuff)]                    <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (k := stuff)]  <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [j <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> (k := stuff)]]       <span class="hljs-comment"># </span>
[i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-keyword">lambda</span>: (j := stuff))()]        <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra excepción ocurre cuando se usa una expresión de asignación en generadores que están dentro del alcance de una clase. </font><font style="vertical-align: inherit;">Si, al usar las reglas anteriores, se produce la creación de una clase medida nuevamente en el alcance, entonces dicha expresión de asignación no es válida y dará como resultado un SyntaxError:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span>:</span>
    [(j := i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]  <span class="hljs-comment"># </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(El motivo de la última excepción es el alcance implícito de la función creada por el generador; actualmente no existe un mecanismo de tiempo de ejecución para que las funciones hagan referencia a una variable ubicada en el alcance de la clase, y no queremos agregar dicho mecanismo. Si este problema se resuelve alguna vez, entonces este caso especial (posiblemente) se eliminará de la especificación de las expresiones de asignación. Tenga en cuenta que este problema ocurrirá incluso si creó una variable en el alcance de la clase anteriormente e intente cambiarla con una expresión de asignación del generador). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consulte el Apéndice B para ver ejemplos de Las expresiones de asignación que se encuentran en los generadores se convierten en código equivalente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prioridad relativa: =</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El operador: = se agrupa más fuerte que la coma en todas las posiciones sintácticas donde sea posible, pero más débil que todos los demás operadores, incluyendo o, y, no, y expresiones condicionales (A si C más B). Como se deduce de la sección "Casos excepcionales" anterior, las expresiones de asignación nunca funcionan en el mismo "nivel" que la asignación clásica =. Si se requiere un orden diferente de operaciones, use paréntesis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El operador: = se puede usar directamente cuando se llama al argumento posicional de una función. Sin embargo, esto no funcionará directamente en el argumento. Algunos ejemplos que aclaran lo que está técnicamente permitido y lo que no es posible:</font></font><br>
<br>
<pre><code class="python hljs">x := <span class="hljs-number">0</span> <span class="hljs-comment"># </span><font></font>
<font></font>
(x := <span class="hljs-number">0</span>) <span class="hljs-comment">#  </span><font></font>
<font></font>
x = y := <span class="hljs-number">0</span> <span class="hljs-comment"># </span><font></font>
<font></font>
x = (y := <span class="hljs-number">0</span>) <span class="hljs-comment">#  </span><font></font>
<font></font>
len(lines := f.readlines()) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(x := <span class="hljs-number">3</span>, cat=<span class="hljs-string">'vector'</span>) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(cat=category := <span class="hljs-string">'vector'</span>) <span class="hljs-comment"># </span><font></font>
<font></font>
foo(cat=(category := <span class="hljs-string">'vector'</span>)) <span class="hljs-comment">#  </span></code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mayoría de los ejemplos "válidos" anteriores no se recomiendan para su uso en la práctica, ya que las personas que escanean rápidamente su código fuente pueden no entender correctamente su significado. </font><font style="vertical-align: inherit;">Pero en casos simples esto está permitido:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Valid</span>
<span class="hljs-keyword">if</span> any(len(longline := line) &gt;= <span class="hljs-number">100</span> <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines):<font></font>
    print(<span class="hljs-string">"Extremely long line:"</span>, longline)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta PEP recomienda que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siempre</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ponga espacios alrededor: =, similar a la recomendación de PEP 8 para = para la asignación clásica. </font><font style="vertical-align: inherit;">(La diferencia de la última recomendación es que prohíbe espacios alrededor de =, que se utiliza para pasar argumentos clave a la función).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambiar el orden de los cálculos.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para tener una semántica bien definida, este acuerdo requiere que el procedimiento de evaluación esté claramente definido. </font><font style="vertical-align: inherit;">Técnicamente, este no es un requisito nuevo. </font><font style="vertical-align: inherit;">Python ya tiene una regla de que las subexpresiones generalmente se evalúan de izquierda a derecha. </font><font style="vertical-align: inherit;">Sin embargo, las expresiones de asignación hacen que estos "efectos secundarios" sean más notorios, y proponemos un cambio en el orden de cálculo actual:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En los generadores de diccionario {X: Y para ...}, Y se evalúa actualmente antes que X. Sugerimos cambiar esto para que X se calcule antes que Y. (En un dict clásico como {X: Y}, así como en dict ((X, Y) para ...) esto ya se ha implementado. Por lo tanto, los generadores de diccionario deben cumplir con este mecanismo)</font></font></li>
</ul><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferencias entre expresiones de asignación e instrucciones de asignación.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo más importante es que ": =" es una </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expresión</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , lo que significa que se puede usar en casos donde las </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instrucciones</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no </font><b><font style="vertical-align: inherit;">son</font></b><font style="vertical-align: inherit;"> válidas, incluidas las funciones y generadores lambda. </font><font style="vertical-align: inherit;">Por el contrario, las </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expresiones de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> asignación no admiten la funcionalidad extendida que se puede usar en las </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instrucciones de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> asignación:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La asignación en cascada no se admite directamente</font></font><br>
<br>
<pre><code class="python hljs">x = y = z = <span class="hljs-number">0</span>  <span class="hljs-comment"># Equivalent: (z := (y := (x := 0)))</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No se admiten "objetivos" separados, excepto el nombre de variable simple NAME:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># No equivalent</span><font></font>
a[i] = x<font></font>
self.rest = []</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funcionalidad y las comas de prioridad "alrededor" son diferentes:</font></font><br>
<br>
<pre><code class="python hljs">x = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>  <span class="hljs-comment"># Sets x to (1, 2)</span>
(x := <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># Sets x to 1</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los valores de desempaque y desempaque no tienen equivalencia "pura" o no son compatibles</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Equivalent needs extra parentheses</span>
loc = x, y  <span class="hljs-comment"># Use (loc := (x, y))</span>
info = name, phone, *rest  <span class="hljs-comment"># Use (info := (name, phone, *rest))</span><font></font>
<font></font>
<span class="hljs-comment"># No equivalent</span><font></font>
px, py, pz = position<font></font>
name, phone, email, *other_info = contact</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las anotaciones de tipo en línea no son compatibles:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Closest equivalent is "p: Optional[int]" as a separate declaration</span>
p: Optional[int] = <span class="hljs-literal">None</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No hay una forma abreviada de operaciones:</font></font><br>
<br>
<pre><code class="python hljs">total += tax  <span class="hljs-comment"># Equivalent: (total := total + tax)</span></code></pre></li>
</ul><br>
<a name="cpec"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La especificación cambia durante la implementación</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los siguientes cambios se realizaron en base a nuestra experiencia y análisis adicional después de la primera redacción de este PEP y antes del lanzamiento de Python 3.8:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para garantizar la coherencia con otras excepciones similares, y no introducir un nuevo nombre que puede no ser conveniente para los usuarios finales, la subclase propuesta originalmente de TargetScopeError para SyntaxError se ha eliminado y reducido al SyntaxError habitual. </font><font style="vertical-align: inherit;">[3]</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debido a las limitaciones en el análisis de la tabla de caracteres CPython, la implementación de referencia de la expresión de asignación genera un SyntaxError para todos los usos dentro de los iteradores. </font><font style="vertical-align: inherit;">Anteriormente, esta excepción ocurría solo si el nombre de la variable que se estaba creando coincidía con el que ya se usaba en la expresión iterativa. </font><font style="vertical-align: inherit;">Esto puede revisarse si hay ejemplos suficientemente convincentes, pero la complejidad adicional parece inapropiada para casos de uso puramente "hipotéticos".</font></font></li>
</ul><br>
<a name="prim"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplos</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplos de la biblioteca estándar de Python</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
env_base se usa solo en una condición, por lo que la asignación se puede colocar en if, como el "encabezado" de un bloque lógico.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código actual:</font></font><br>
<pre><code class="python hljs">env_base = os.environ.get(<span class="hljs-string">"PYTHONUSERBASE"</span>, <span class="hljs-literal">None</span>)
<span class="hljs-keyword">if</span> env_base:
    <span class="hljs-keyword">return</span> env_base</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código mejorado:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> env_base := os.environ.get(<span class="hljs-string">"PYTHONUSERBASE"</span>, <span class="hljs-literal">None</span>):
    <span class="hljs-keyword">return</span> env_base</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_pydecimal.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede evitar ifs anidados, eliminando así un nivel de sangría.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código actual:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> self._is_special:<font></font>
    ans = self._check_nans(context=context)<font></font>
    <span class="hljs-keyword">if</span> ans:
        <span class="hljs-keyword">return</span> ans</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código mejorado:</font></font><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> self._is_special <span class="hljs-keyword">and</span> (ans := self._check_nans(context=context)):
    <span class="hljs-keyword">return</span> ans</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copy.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El código parece más clásico y también evita el anidamiento múltiple de sentencias condicionales. </font><font style="vertical-align: inherit;">(Consulte el Apéndice A para obtener más información sobre el origen de este ejemplo).</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código actual:</font></font><br>
<pre><code class="python hljs">reductor = dispatch_table.get(cls)
<span class="hljs-keyword">if</span> reductor:<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">else</span>:<font></font>
    reductor = getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> reductor:<font></font>
        rv = reductor(<span class="hljs-number">4</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        reductor = getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> reductor:<font></font>
            rv = reductor()<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Error(
                <span class="hljs-string">"un(deep)copyable object of type %s"</span> % cls)</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código mejorado:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> reductor := dispatch_table.get(cls):<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor(<span class="hljs-number">4</span>)
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor()<font></font>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(deep)copyable object of type %s"</span> % cls)</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datetime.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tz se usa solo para s + = tz. </font><font style="vertical-align: inherit;">Moverlo hacia adentro si ayuda a mostrar su área lógica de uso.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código actual:</font></font><br>
<br>
<pre><code class="python hljs">s = _format_time(self._hour, self._minute,<font></font>
                 self._second, self._microsecond,<font></font>
                 timespec)<font></font>
tz = self._tzstr()<font></font>
<span class="hljs-keyword">if</span> tz:<font></font>
    s += tz<font></font>
<span class="hljs-keyword">return</span> s</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código mejorado:</font></font><br>
<br>
<pre><code class="python hljs">s = _format_time(self._hour, self._minute,<font></font>
                 self._second, self._microsecond,<font></font>
                 timespec)<font></font>
<span class="hljs-keyword">if</span> tz := self._tzstr():<font></font>
    s += tz<font></font>
<span class="hljs-keyword">return</span> s</code></pre></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sysconfig.py</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Llamar a fp.readline () como una "condición" en el ciclo while (así como llamar al método .match ()) en la condición if hace que el código sea más compacto sin complicar su comprensión.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código actual:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    line = fp.readline()<font></font>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line:
        <span class="hljs-keyword">break</span><font></font>
    m = define_rx.match(line)<font></font>
    <span class="hljs-keyword">if</span> m:<font></font>
        n, v = m.group(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">try</span>:<font></font>
            v = int(v)<font></font>
        <span class="hljs-keyword">except</span> ValueError:
            <span class="hljs-keyword">pass</span><font></font>
        vars[n] = v<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
        m = undef_rx.match(line)<font></font>
        <span class="hljs-keyword">if</span> m:<font></font>
            vars[m.group(<span class="hljs-number">1</span>)] = <span class="hljs-number">0</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código mejorado:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> line := fp.readline():
    <span class="hljs-keyword">if</span> m := define_rx.match(line):<font></font>
        n, v = m.group(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
        <span class="hljs-keyword">try</span>:<font></font>
            v = int(v)<font></font>
        <span class="hljs-keyword">except</span> ValueError:
            <span class="hljs-keyword">pass</span><font></font>
        vars[n] = v<font></font>
    <span class="hljs-keyword">elif</span> m := undef_rx.match(line):<font></font>
        vars[m.group(<span class="hljs-number">1</span>)] = <span class="hljs-number">0</span></code></pre></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplificar generadores de listas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora el generador de listas se puede filtrar efectivamente "capturando" la condición:</font></font><br>
<br>
<pre><code class="python hljs">results = [(x, y, x/y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> input_data <span class="hljs-keyword">if</span> (y := f(x)) &gt; <span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de eso, la variable se puede reutilizar en otra expresión:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [[y := f(x), x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta nuevamente que en ambos casos la variable </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> está en el mismo alcance que el resultado de las variables y demás.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capturar valores en condiciones</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las expresiones de asignación se pueden usar efectivamente en las condiciones de una declaración if o while:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Loop-and-a-half</span>
<span class="hljs-keyword">while</span> (command := input(<span class="hljs-string">"&gt; "</span>)) != <span class="hljs-string">"quit"</span>:<font></font>
    print(<span class="hljs-string">"You entered:"</span>, command)<font></font>
<font></font>
<span class="hljs-comment"># Capturing regular expression match objects</span>
<span class="hljs-comment"># See, for instance, Lib/pydoc.py, which uses a multiline spelling</span>
<span class="hljs-comment"># of this effect</span>
<span class="hljs-keyword">if</span> match := re.search(pat, text):<font></font>
    print(<span class="hljs-string">"Found:"</span>, match.group(<span class="hljs-number">0</span>))
<span class="hljs-comment"># The same syntax chains nicely into 'elif' statements, unlike the</span>
<span class="hljs-comment"># equivalent using assignment statements.</span>
<span class="hljs-keyword">elif</span> match := re.search(otherpat, text):<font></font>
    print(<span class="hljs-string">"Alternate found:"</span>, match.group(<span class="hljs-number">0</span>))
<span class="hljs-keyword">elif</span> match := re.search(third, text):<font></font>
    print(<span class="hljs-string">"Fallback found:"</span>, match.group(<span class="hljs-number">0</span>))<font></font>
<font></font>
<span class="hljs-comment"># Reading socket data until an empty string is returned</span>
<span class="hljs-keyword">while</span> data := sock.recv(<span class="hljs-number">8192</span>):<font></font>
    print(<span class="hljs-string">"Received data:"</span>, data)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En particular, este enfoque puede eliminar la necesidad de crear un bucle infinito, asignación y verificación de condición. </font><font style="vertical-align: inherit;">También le permite dibujar un paralelo suave entre un ciclo que usa una llamada de función como su condición, así como un ciclo que no solo verifica la condición, sino que también usa el valor real devuelto por la función en el futuro.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenedor</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un ejemplo del mundo de bajo nivel de UNIX: [aprox. </font><font style="vertical-align: inherit;">Fork () es una llamada al sistema en sistemas operativos tipo Unix que crea un nuevo subproceso en relación con el padre.]</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> pid := os.fork():
    <span class="hljs-comment"># Parent code</span>
<span class="hljs-keyword">else</span>:
    <span class="hljs-comment"># Child code</span></code></pre><br>
<a name="otklon"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternativas rechazadas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, sugerencias similares son bastante comunes en la comunidad python. </font><font style="vertical-align: inherit;">A continuación hay una serie de sintaxis alternativas para expresiones de asignación que son demasiado específicas para comprender y que han sido rechazadas a favor de lo anterior.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambiar el alcance de los generadores</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En una versión anterior de este PEP, se propuso realizar cambios sutiles en las reglas de alcance de los generadores para hacerlos más adecuados para su uso en el alcance de las clases. </font><font style="vertical-align: inherit;">Sin embargo, estas propuestas conducirían a una incompatibilidad hacia atrás y, por lo tanto, fueron rechazadas. </font><font style="vertical-align: inherit;">Por lo tanto, este PEP pudo enfocarse completamente solo en expresiones de asignación.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ortografía alternativa</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, las expresiones de asignación propuestas tienen la misma semántica, pero están escritas de manera diferente.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPR como NOMBRE:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [[f(x) <span class="hljs-keyword">as</span> y, x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
   EXPR as NAME       import, except  with,         (,       ).<br>
<br>
( ,  «with EXPR as VAR»     EXPR  VAR,   EXPR.__enter__()        VAR.)<br>
<br>
 ,   ":="   :<br>
<ul>
<li>  ,  <b>if f(x) as y</b>     ,    ​​   <b>if f x blah-blah</b>,        <b>if f(x) and y</b>.</li>
<li>   ,  <b>as</b> ,           ,     : <ul>
<li>import foo as bar</li>
<li>except Exc as var</li>
<li>with ctxmgr() as var</li>
</ul><br>
 , <b>as</b>     if  while     ,   <b>as</b>  « »   .</li>
<li>  «»  <ul>
<li>NAME = EXPR</li>
<li>if NAME := EXPR</li>
</ul><br>
     .</li>
</ul></li>
<li>EXPR -&gt; NAME<br>
<br>
<pre><code class="python hljs">stuff = [[f(x) -&gt; y, x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
     ,  R  Haskell,     . ( ,    - <b>y &lt; — f (x) </b>   Python,      -   .)       «as»   ,      import, except  with,      .             Python (    ),      ":=" (   Algol-58)     .</li>
<li>  «»    <br>
<br>
<pre><code class="python hljs">stuff = [[(f(x) <span class="hljs-keyword">as</span> .y), x/.y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># with "as"</span>
stuff = [[(.y := f(x)), x/.y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-comment"># with ":="</span></code></pre><br>
         .         Python,        ,   .</li>
<li> where:       :<br>
<br>
<pre><code class="python hljs">value = x**<span class="hljs-number">2</span> + <span class="hljs-number">2</span>*x where:<font></font>
    x = spam(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, q)</code></pre><br>
   (    ,     «»).      ,   «»  (  with:). . PEP 3150,      (    <i>given:</i> ).</li>
<li>TARGET from EXPR:<br>
<br>
<pre><code class="python hljs">stuff = [[y <span class="hljs-keyword">from</span> f(x), x/y] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es menos probable que esta sintaxis entre en conflicto con otros que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (a menos que cuente las construcciones elevar Exc de Exc), pero de lo contrario sea comparable a ellos. </font><font style="vertical-align: inherit;">En lugar de un paralelo con expr como objetivo: (que puede ser útil, pero también puede ser confuso), esta opción no tiene paralelos con nada en absoluto, pero sorprendentemente se recuerda mejor.</font></font></li>
</ol><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casos especiales en declaraciones condicionales</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uno de los casos de uso más comunes para las expresiones de asignación son las declaraciones if y while. </font><font style="vertical-align: inherit;">En lugar de una solución más general, el uso de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mejora la sintaxis de estas dos declaraciones al agregar un medio de capturar el valor a comparar:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> re.search(pat, text) <span class="hljs-keyword">as</span> match:<font></font>
    print(<span class="hljs-string">"Found:"</span>, match.group(<span class="hljs-number">0</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto funciona bien, pero </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOLO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cuando la condición deseada se basa en la "corrección" del valor de retorno. </font><font style="vertical-align: inherit;">Por lo tanto, este método es efectivo para casos específicos (verificar expresiones regulares, leer sockets, devolver una cadena vacía cuando finaliza la ejecución), y es completamente inútil en casos más complejos (por ejemplo, cuando la condición es f (x) &lt;0, y desea guardar el valor de f (x)). </font><font style="vertical-align: inherit;">Además, esto no tiene sentido en los generadores de listas. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ventajas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : sin ambigüedades sintácticas. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desventajas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : incluso si lo usa solo en declaraciones if / while, solo funciona bien en algunos casos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casos especiales en generadores</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro caso de uso común para las expresiones de asignación son los generadores (list / set / dict y genexps). </font><font style="vertical-align: inherit;">Como se indicó anteriormente, se hicieron sugerencias para soluciones específicas.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">donde, dejar o dado:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) where y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<font></font>
stuff = [(y, x/y) let y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<font></font>
stuff = [(y, x/y) given y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este método da como resultado una subexpresión entre el bucle for y la expresión principal. </font><font style="vertical-align: inherit;">También introduce una palabra clave de idioma adicional, que puede crear conflictos. </font><font style="vertical-align: inherit;">De las tres opciones, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dónde</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es la más limpia y legible, pero aún existen conflictos potenciales (por ejemplo, SQLAlchemy y numpy tienen sus métodos where, así como tkinter.dnd.Icon en la biblioteca estándar).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con NAME = EXPR:</font></font><br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) <span class="hljs-keyword">with</span> y = f(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
  ,     ,     <b>with</b>.         .   ,           «»  for.    C,         ,    .   : «  «with NAME = EXPR:»       ,   ?»</li>
<li>with EXPR as NAME:<br>
<br>
<pre><code class="python hljs">stuff = [(y, x/y) <span class="hljs-keyword">with</span> f(x) <span class="hljs-keyword">as</span> y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]</code></pre><br>
   ,    <b>as</b>,    .       ,        for.      with          </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Independientemente del método elegido, se introducirá una gran diferencia semántica entre los generadores y sus versiones implementadas a través de un bucle for. </font><font style="vertical-align: inherit;">Sería imposible envolver el ciclo en un generador sin procesar la etapa de creación de las variables. </font><font style="vertical-align: inherit;">La única palabra clave que podría reorientarse para esta tarea es la palabra </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pero esto le dará una semántica diferente en diferentes partes del código, lo que significa que necesita crear una nueva palabra clave, pero esto implica muchos costos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baja prioridad del operador</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El operador = = tiene dos prioridades lógicas. O debería tener la menor prioridad posible (a la par con el operador de asignación). O debería tener mayor prioridad que los operadores de comparación. Colocar su prioridad entre los operadores de comparación y las operaciones aritméticas (para ser precisos: un poco más bajo que OR a nivel de bits) le permitirá prescindir de paréntesis en la mayoría de los casos cuando y mientras lo usa, ya que es más probable que desee mantener el valor de algo antes cómo se realizará la comparación en él:</font></font><br>
<br>
<pre><code class="python hljs">pos = <span class="hljs-number">-1</span>
<span class="hljs-keyword">while</span> pos := buffer.find(search_term, pos + <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>:<font></font>
    ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tan pronto como find () devuelve -1, el ciclo termina. </font><font style="vertical-align: inherit;">Si: = une los operandos tan libremente como =, entonces el resultado de find () primero será "capturado" en el operador de comparación y generalmente devolverá Verdadero o Falso, lo que es menos útil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aunque este comportamiento sería conveniente en la práctica en muchas situaciones, sería más difícil de explicar. </font><font style="vertical-align: inherit;">Y entonces podemos decir que "el operador: = se comporta igual que el operador de asignación habitual". </font><font style="vertical-align: inherit;">Es decir, la prioridad para: = se eligió lo más cerca posible del operador = (excepto que: = tiene una prioridad más alta que la coma).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da comas a la derecha</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algunos críticos argumentan que las expresiones de asignación deben reconocer tuplas sin la adición de corchetes para que las dos entradas sean equivalentes:</font></font><br>
<br>
<pre><code class="python hljs">(point := (x, y))<font></font>
(point := x, y)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(En la versión actual del estándar, el último registro será equivalente a la expresión ((punto: = x), y).) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero es lógico que en esta situación, cuando se usa la expresión de asignación en la llamada a la función, también tenga una prioridad menor que la coma, por lo que obtuvimos sería la siguiente equivalencia confusa:</font></font><br>
<br>
<pre><code class="python hljs">foo (x: = <span class="hljs-number">1</span>, y)<font></font>
foo (x: = (<span class="hljs-number">1</span>, y))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y obtenemos la única salida menos confusa: hacer que el operador: = sea una prioridad más baja que la coma.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siempre requiere soportes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Siempre se ha propuesto poner entre corchetes las expresiones de asignación. </font><font style="vertical-align: inherit;">Esto nos ahorraría muchas ambigüedades. </font><font style="vertical-align: inherit;">De hecho, a menudo se necesitarán paréntesis para extraer el valor deseado. </font><font style="vertical-align: inherit;">Pero en los siguientes casos, la presencia de paréntesis nos pareció claramente superflua:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># Top level in if</span>
<span class="hljs-keyword">if</span> match := pattern.match(line):
    <span class="hljs-keyword">return</span> match.group(<span class="hljs-number">1</span>)<font></font>
<font></font>
<span class="hljs-comment"># Short call</span>
len(lines := f.readlines())</code></pre><br>
<a name="chast"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objeciones frecuentes</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Por qué no simplemente convertir las declaraciones de asignación en expresiones?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C y lenguajes similares definen el operador </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como una expresión, no una instrucción, como lo hace Python. </font><font style="vertical-align: inherit;">Esto permite la asignación en muchas situaciones, incluidos los lugares donde se comparan las variables. </font><font style="vertical-align: inherit;">Las similitudes sintácticas entre if (x == y) y if (x = y) contradicen su semántica muy diferente. </font><font style="vertical-align: inherit;">Por lo tanto, esta PEP presenta al operador: = para aclarar sus diferencias.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Por qué molestarse con las </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expresiones de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> asignación </font><font style="vertical-align: inherit;">si existen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instrucciones de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> asignación?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas dos formas tienen diferentes flexibilidades. </font><font style="vertical-align: inherit;">El operador: = puede usarse dentro de una expresión más grande, y en el operador = puede ser usado por la "familia de mini-operadores" del tipo "+ =". </font><font style="vertical-align: inherit;">También = le permite asignar valores por atributos e índices.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Por qué no usar el alcance local y prevenir la contaminación del espacio de nombres?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las versiones anteriores de este estándar incluían un alcance local real (limitado a una declaración) para expresiones de asignación, evitando la fuga de nombres y la contaminación del espacio de nombres. </font><font style="vertical-align: inherit;">A pesar del hecho de que en algunas situaciones esto dio una cierta ventaja, en muchas otras complica la tarea, y los beneficios no están justificados por las ventajas del enfoque existente. </font><font style="vertical-align: inherit;">Esto se hace en interés de la simplicidad del lenguaje. </font><font style="vertical-align: inherit;">¿Ya no necesitas esta variable? </font><font style="vertical-align: inherit;">Hay una solución: elimine la variable usando la palabra clave del o agregue un guión bajo a su nombre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(El autor desea agradecer a Guido van Rossum y Christophe Groth por sus sugerencias para avanzar el estándar PEP en esta dirección. [2])</font></font><br>
<br>
<a name="rekom"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recomendaciones de estilo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que las expresiones de asignación a veces se pueden usar a la par con un operador de asignación, surge la pregunta, ¿qué se prefiere? De acuerdo con otras convenciones de estilo (como PEP 8), hay dos recomendaciones:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si puede usar ambas opciones de asignación, entonces dé preferencia a los operadores. </font><font style="vertical-align: inherit;">Expresan más claramente sus intenciones.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el uso de expresiones de asignación genera ambigüedad en el orden de ejecución, reescriba el código con el operador clásico.</font></font></li>
</ol><br>
<a name="blag"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gracias</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los autores de esta norma desean agradecer a Nick Coghlan y Steven D'Aprano por sus importantes contribuciones a este PEP, así como a los miembros de Python Core Mentorship por su ayuda para implementar esto.</font></font><br>
<br>
<a name="prilA"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apéndice A: Conclusiones de Tim Peters</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí hay un breve ensayo que Tim Peters escribió sobre este tema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No me gusta el código "confundido", y tampoco me gusta poner lógica conceptualmente no relacionada en una línea. </font><font style="vertical-align: inherit;">Entonces, por ejemplo, en lugar de:</font></font><br>
<br>
<pre><code class="python hljs">i = j = count = nerrors = <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prefiero escribir:</font></font><br>
<br>
<pre><code class="python hljs">i = j = <span class="hljs-number">0</span>
count = <span class="hljs-number">0</span>
nerrors = <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, creo que encontraré varios lugares donde quiero usar expresiones de asignación. </font><font style="vertical-align: inherit;">Ni siquiera quiero hablar sobre su uso en expresiones que ya están extendidas a la mitad de la pantalla. </font><font style="vertical-align: inherit;">En otros casos, comportamientos como:</font></font><br>
<br>
<pre><code class="python hljs">mylast = mylast[<span class="hljs-number">1</span>]
<span class="hljs-keyword">yield</span> mylast[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Significativamente mejor que esto:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">yield</span> (mylast := mylast[<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estos dos códigos tienen conceptos completamente diferentes y mezclarlos sería una locura. </font><font style="vertical-align: inherit;">En otros casos, la combinación de expresiones lógicas complica la comprensión del código. </font><font style="vertical-align: inherit;">Por ejemplo, reescribiendo:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    old = total<font></font>
    total += term<font></font>
    <span class="hljs-keyword">if</span> old == total:
        <span class="hljs-keyword">return</span> total<font></font>
    term *= mx2 / (i*(i+<span class="hljs-number">1</span>))<font></font>
    i += <span class="hljs-number">2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En una forma más corta, hemos perdido la "lógica". </font><font style="vertical-align: inherit;">Debe comprender cómo funciona este código. </font><font style="vertical-align: inherit;">Mi cerebro no quiere hacer esto:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> total != (total := total + term):<font></font>
    term *= mx2 / (i*(i+<span class="hljs-number">1</span>))<font></font>
    i += <span class="hljs-number">2</span>
<span class="hljs-keyword">return</span> total</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero tales casos son raros. </font><font style="vertical-align: inherit;">La tarea de preservar el resultado es muy común, y "disperso es mejor que denso" no significa que "casi vacío es mejor que disperso" [aprox. </font><font style="vertical-align: inherit;">una referencia a Zen Python]. </font><font style="vertical-align: inherit;">Por ejemplo, tengo muchas funciones que devuelven Ninguna o 0 para decir "No tengo nada útil, pero como esto sucede a menudo, no quiero molestarlo con excepciones". </font><font style="vertical-align: inherit;">De hecho, este mecanismo también se usa en expresiones regulares que devuelven None cuando no hay coincidencias. </font><font style="vertical-align: inherit;">Por lo tanto, en este ejemplo, mucho código:</font></font><br>
<br>
<pre><code class="python hljs">result = solution(xs, n)
<span class="hljs-keyword">if</span> result:
    <span class="hljs-comment"># use result</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La siguiente opción me parece más comprensible y, por supuesto, más legible:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> result := solution(xs, n):
    <span class="hljs-comment"># use result</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al principio no le di mucha importancia a esto, pero una construcción tan corta apareció tan a menudo que pronto comenzó a molestarme que no podía usarla. </font><font style="vertical-align: inherit;">¡Me sorprendió! </font><font style="vertical-align: inherit;">[aprox. </font><font style="vertical-align: inherit;">aparentemente esto fue escrito antes de que Python 3.8 fuera lanzado oficialmente.] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay otros casos donde las expresiones de asignación realmente "disparan". </font><font style="vertical-align: inherit;">En lugar de hurgar en mi código nuevamente, Kirill Balunov dio un buen ejemplo de la función copy () de la biblioteca estándar copy.py:</font></font><br>
<br>
<pre><code class="python hljs">reductor = dispatch_table.get(cls)
<span class="hljs-keyword">if</span> reductor:<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">else</span>:<font></font>
    reductor = getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> reductor:<font></font>
        rv = reductor(<span class="hljs-number">4</span>)
    <span class="hljs-keyword">else</span>:<font></font>
        reductor = getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>)
        <span class="hljs-keyword">if</span> reductor:<font></font>
            rv = reductor()<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(shallow)copyable object of type %s"</span> % cls)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La sangría cada vez mayor es engañosa: después de todo, la lógica es plana: la primera prueba exitosa "gana":</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> reductor := dispatch_table.get(cls):<font></font>
    rv = reductor(x)<font></font>
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce_ex__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor(<span class="hljs-number">4</span>)
<span class="hljs-keyword">elif</span> reductor := getattr(x, <span class="hljs-string">"__reduce__"</span>, <span class="hljs-literal">None</span>):<font></font>
    rv = reductor()<font></font>
<span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">raise</span> Error(<span class="hljs-string">"un(shallow)copyable object of type %s"</span> % cls)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El uso simple de expresiones de asignación permite que la estructura visual del código enfatice el "plano" de la lógica. </font><font style="vertical-align: inherit;">Pero la sangría cada vez mayor lo hace implícito. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí hay otro pequeño ejemplo de mi código, que me hizo muy feliz porque me permitió poner lógica internamente relacionada en una línea y eliminar el molesto nivel de sangría "artificial". </font><font style="vertical-align: inherit;">Esto es exactamente lo que quiero de la declaración if y facilita la lectura. </font><font style="vertical-align: inherit;">El siguiente código:</font></font><br>
<br>
<pre><code class="python hljs">diff = x - x_base
<span class="hljs-keyword">if</span> diff:<font></font>
    g = gcd(diff, n)<font></font>
    <span class="hljs-keyword">if</span> g &gt; <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> g</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Convertido en:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> (diff := x - x_base) <span class="hljs-keyword">and</span> (g := gcd(diff, n)) &gt; <span class="hljs-number">1</span>:
    <span class="hljs-keyword">return</span> g</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, en la mayoría de las líneas donde ocurre la asignación variable, no usaría expresiones de asignación. </font><font style="vertical-align: inherit;">Pero este diseño es tan frecuente que todavía hay muchos lugares donde aprovecharía esta oportunidad. </font><font style="vertical-align: inherit;">En los casos más recientes, gané un poco, ya que a menudo aparecían. </font><font style="vertical-align: inherit;">En la subparte restante, esto condujo a mejoras medianas o grandes. </font><font style="vertical-align: inherit;">Por lo tanto, usaría expresiones de asignación con mucha más frecuencia que un triple si, pero con mucha menos frecuencia que la asignación aumentada [aprox. </font><font style="vertical-align: inherit;">opciones cortas: * =, / =, + =, etc.].</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo numérico</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tengo otro ejemplo que me llamó la atención antes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si todas las variables son números enteros positivos, y la variable </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a es</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mayor que la enésima raíz de x, entonces este algoritmo devuelve el redondeo "inferior" de la enésima raíz de x (y aproximadamente duplica el número de bits exactos por iteración):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> a &gt; (d := x // a**(n<span class="hljs-number">-1</span>)):<font></font>
    a = ((n<span class="hljs-number">-1</span>)*a + d) // n
<span class="hljs-keyword">return</span> a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No está claro por qué, pero tal variante del algoritmo es menos obvia que un bucle infinito con un salto de rama condicional (bucle y medio). También es difícil demostrar la corrección de esta implementación sin depender de una declaración matemática ("media aritmética - desigualdad de la media geométrica") y sin saber algunas cosas no triviales sobre cómo las funciones de redondeo anidado se comportan hacia abajo. Pero aquí el problema ya está en las matemáticas, y no en la programación. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y si sabe todo esto, entonces la opción que usa expresiones de asignación se lee muy fácilmente, como una oración simple: "Verifique la" suposición "actual y si es demasiado grande, reduzca" y la condición le permite guardar inmediatamente el valor intermedio de la condición del bucle. En mi opinión, la forma clásica es más difícil de entender:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
    d = x // a**(n<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">if</span> a &lt;= d:
        <span class="hljs-keyword">break</span>
    a = ((n<span class="hljs-number">-1</span>)*a + d) // n
<span class="hljs-keyword">return</span> a</code></pre><br>
<a name="prilB"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apéndice B: Un intérprete de código aproximado para generadores</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este apéndice intenta aclarar (aunque no especificar) las reglas mediante las cuales se debe crear una variable en expresiones generadoras. </font><font style="vertical-align: inherit;">Para una serie de ejemplos ilustrativos, mostramos el código fuente donde el generador es reemplazado por una función equivalente en combinación con algunos "andamios". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como [x para ...] es equivalente a list (x para ...), los ejemplos no pierden su generalidad. </font><font style="vertical-align: inherit;">Y dado que estos ejemplos están destinados solo a aclarar las reglas generales, no pretenden ser realistas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nota: los generadores ahora se implementan mediante la creación de funciones de generador anidadas (similares a las que se proporcionan en este apéndice). </font><font style="vertical-align: inherit;">Los ejemplos muestran la nueva parte, que agrega la funcionalidad adecuada para trabajar con el alcance de las expresiones de asignación (como el alcance si la asignación se realizó en un bloque que contiene el generador más externo). </font><font style="vertical-align: inherit;">Para simplificar la "inferencia de tipos", estos ejemplos ilustrativos no tienen en cuenta que las expresiones de asignación son opcionales (pero tienen en cuenta el alcance de la variable creada dentro del generador). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero recordemos qué código se genera "bajo el capó" para generadores sin expresiones de asignación:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código fuente (EXPR usa con mayor frecuencia la variable VAR):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El código convertido (no nos preocupemos por los conflictos de nombres):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:
            <span class="hljs-keyword">yield</span> EXPR<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agreguemos una expresión de asignación simple.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuente:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código convertido:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<font></font>
        TARGET = <span class="hljs-literal">None</span>  <span class="hljs-comment"># Dead code to ensure TARGET is a local variable</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
            TARGET = EXPR<font></font>
            <span class="hljs-keyword">yield</span> TARGET<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora agreguemos la declaración TARGET global a la declaración de la función f ().</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuente:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">global</span> TARGET<font></font>
    a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código convertido:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">global</span> TARGET
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
        <span class="hljs-keyword">global</span> TARGET
        <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
            TARGET = EXPR<font></font>
            <span class="hljs-keyword">yield</span> TARGET<font></font>
    a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O viceversa, agreguemos TARGET no local a la declaración de la función f ().</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuente:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><font></font>
    TARGET = ...<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
        <span class="hljs-keyword">nonlocal</span> TARGET<font></font>
        a = [TARGET := EXPR <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> ITERABLE]
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código convertido:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span>():</span><font></font>
    TARGET = ...<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genexpr</span>(<span class="hljs-params">iterator</span>):</span>
            <span class="hljs-keyword">nonlocal</span> TARGET
            <span class="hljs-keyword">for</span> VAR <span class="hljs-keyword">in</span> iterator:<font></font>
                TARGET = EXPR<font></font>
                <span class="hljs-keyword">yield</span> TARGET<font></font>
        a = list(genexpr(iter(ITERABLE)))</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, pongamos dos generadores.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuente:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    a = [[TARGET := i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>)]
    <span class="hljs-comment"># I.e., a = [[0, 1, 2], [0, 1, 2]]</span>
    print(TARGET)  <span class="hljs-comment"># prints 2</span>
</code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código convertido:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-keyword">if</span> <span class="hljs-literal">False</span>:<font></font>
        TARGET = <span class="hljs-literal">None</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer_genexpr</span>(<span class="hljs-params">outer_iterator</span>):</span>
        <span class="hljs-keyword">nonlocal</span> TARGET
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner_generator</span>(<span class="hljs-params">inner_iterator</span>):</span>
            <span class="hljs-keyword">nonlocal</span> TARGET
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> inner_iterator:<font></font>
                TARGET = i<font></font>
                <span class="hljs-keyword">yield</span> i
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> outer_iterator:
            <span class="hljs-keyword">yield</span> list(inner_generator(range(<span class="hljs-number">3</span>)))<font></font>
    a = list(outer_genexpr(range(<span class="hljs-number">2</span>)))<font></font>
    print(TARGET)</code></pre></li>
</ul><br>
<a name="prilC"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apéndice C: Sin cambios en la semántica del alcance</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que en Python la semántica del alcance no ha cambiado. </font><font style="vertical-align: inherit;">El alcance de las funciones locales aún se determina en el momento de la compilación y tiene una extensión de tiempo indefinida en el tiempo de ejecución (cierre). </font><font style="vertical-align: inherit;">Ejemplo:</font></font><br>
<br>
<pre><code class="python hljs">a = <span class="hljs-number">42</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span>
    <span class="hljs-comment"># `a` is local to `f`, but remains unbound</span>
    <span class="hljs-comment"># until the caller executes this genexp:</span>
    <span class="hljs-keyword">yield</span> ((a := i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>))
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">lambda</span>: a + <span class="hljs-number">100</span>
    print(<span class="hljs-string">"done"</span>)
    <span class="hljs-keyword">try</span>:<font></font>
        print(<span class="hljs-string">f"`a` is bound to <span class="hljs-subst">{a}</span>"</span>)
        <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">except</span> UnboundLocalError:<font></font>
        print(<span class="hljs-string">"`a` is not yet bound"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">&gt;&gt;&gt; </span>results = list(f()) <span class="hljs-comment"># [genexp, lambda]</span><font></font>
done<font></font>
`a` <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> yet bound
<span class="hljs-comment"># The execution frame for f no longer exists in CPython,</span>
<span class="hljs-comment"># but f's locals live so long as they can still be referenced.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>list(map(type, results))<font></font>
[&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">generator</span>'&gt;, &lt;<span class="hljs-title">class</span> '<span class="hljs-title">function</span>'&gt;]
&gt;&gt;&gt; <span class="hljs-title">list</span>(<span class="hljs-params">results[<span class="hljs-number">0</span>]</span>)
[0, 1, 2]
&gt;&gt;&gt; <span class="hljs-title">results</span>[1]()
102
&gt;&gt;&gt; <span class="hljs-title">a</span>
42</span></code></pre><br>
<a name="ssilki"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referencias</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prueba de implementación del concepto</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discusión de la semántica de las expresiones de asignación</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (VPN está apretada pero cargada)</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Discusión de TargetScopeError en PEP 572</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (cargado de manera similar a la anterior)</font></font></li>
</ol><br>
<a name="avtori"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Derechos de autor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este documento se ha hecho público. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fuente: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/python/peps/blob/master/pep-0572.rst</font></font></a><br>
<br>
<a name="my"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mi parte</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comenzar, resumamos:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que las </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">personas no intenten</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eliminar la dualidad semántica, en muchos lugares "clásicos" en los que podría usar "=" y ": =" existen restricciones, por lo tanto, el operador :: = debe estar entre corchetes. </font><font style="vertical-align: inherit;">Estos casos deberán revisarse en la sección que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">describe el uso básico.</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La prioridad de las expresiones de asignación es ligeramente mayor que la de una coma. </font><font style="vertical-align: inherit;">Debido a esto, las tuplas no se forman durante la asignación. </font><font style="vertical-align: inherit;">También hace posible usar el operador: = al pasar argumentos a una función.</font></font></li>
<li> ,   ,    ,    .       .    lambda    ,    «»  .</li>
<li>        :   ,     </li>
<li>      ,   .</li>
<li>          /  .</li>
<li>   ,      .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al final, quiero decir que me gustó el nuevo operador. </font><font style="vertical-align: inherit;">Le permite escribir código más plano en condiciones, listas de "filtro" y también (finalmente) eliminar la "línea solitaria" misma antes de if. </font><font style="vertical-align: inherit;">Si las personas usan expresiones de asignación para su propósito previsto, esta será una herramienta muy conveniente que aumentará la legibilidad y la belleza del código (aunque, esto se puede decir sobre cualquier lenguaje funcional ...)</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es499654/index.html">¿Cómo implementar CRM en un sitio remoto y ganar?</a></li>
<li><a href="../es499656/index.html">Simulación de controlador de temperatura PID</a></li>
<li><a href="../es499658/index.html">¿Un hombre trabajador en lugar de un probador? ¿Vale la pena estudiar Selenium en 2020?</a></li>
<li><a href="../es499662/index.html">Raíz de confianza para IoT y otras tendencias de seguridad de IoT</a></li>
<li><a href="../es499664/index.html">Portar APIs a TypeScript como un solucionador de problemas</a></li>
<li><a href="../es499668/index.html">Road to Hell Dependencias de JavaScript</a></li>
<li><a href="../es499670/index.html">Я перехожу на JavaScript</a></li>
<li><a href="../es499674/index.html">Otro paso para las computadoras ópticas</a></li>
<li><a href="../es499676/index.html">Más de 90 herramientas útiles para Kubernetes: implementación, administración, monitoreo, seguridad y más</a></li>
<li><a href="../es499680/index.html">Learning Kubernetes: Básico 14-16 de mayo, Avanzado 18-20 de mayo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>