<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏽 🤵🏽 👸🏻 Tri en douceur 🐒 ➖ 🥑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous continuons à nous immerger dans une variété de tas. 
 
 Aujourd'hui, nous analyserons une méthode de commande élégante qui utilise des tas spécia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Tri en douceur</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/496852/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img align="left" width="350" height="350" src="https://habrastorage.org/webt/rn/rl/bg/rnrlbgzncwdiackzlubtakt02u0.jpeg"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous continuons à nous immerger dans une variété de tas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aujourd'hui, nous analyserons une méthode de commande élégante qui utilise des tas spéciaux basés sur les chiffres de Leonardo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beaucoup ont entendu parler de ce tri, mais peu de gens savent exactement comment cela fonctionne. Aujourd'hui, nous verrons qu'il n'y a rien de compliqué. </font><font style="vertical-align: inherit;">
La méthode a été inventée par le légendaire Edsger Dijkstra. En plus des nombreuses réalisations les plus brillantes de la théorie des algorithmes, il est également l'auteur d'une telle déclaration pleine d'esprit: </font><i><font style="vertical-align: inherit;">«Les étudiants qui ont étudié le Basic auparavant, il est presque impossible d'enseigner une bonne programmation. En tant que programmeurs potentiels, ils ont subi une dégradation mentale irréversible. »</font></i><font style="vertical-align: inherit;"> 
J'espère que ce n'est pas un blasphème que l'animation de l'article ait été créée en utilisant VBA :-)</font></font><br>
<br>
<img width="750" height="1" src="https://habrastorage.org/webt/63/4u/g_/634ug_fmfdzyhgeg6ta-ddcdpau.gif"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img align="right" width="195" height="280" src="https://habrastorage.org/webt/fq/vt/v1/fqvtv1xelqwwshwtuxa3frztsle.jpeg"></a><br clear="left"><font style="vertical-align: inherit;"></font><br>
<br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Logiciel EDISON - développement web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Logiciel EDISON - développement web"></a><br clear="right">
     EDISON.<br>
<br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    </a>,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   Android  iOS</a>.<br>
<br>
    ! ;-)</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le tri en tas est en soi très bon, car sa complexité temporelle est </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quelles que soient les données. Afin de ne pas représenter un tableau, la complexité du heapsort ne se dégrade jamais en </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></b><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui peut se produire, par exemple, avec un tri rapide. Le revers de la médaille est que le tri par tas binaire ne peut pas être accéléré, la complexité </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne peut pas non plus être attendue (mais le même tri rapide, dans certaines conditions, peut atteindre de tels indicateurs). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, il y avait une question à l'ordre du jour: est-il possible de concevoir de telle sorte que la complexité temporelle du tri par tas, d'une part, ne soit pas inférieure à</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais dans un scénario favorable (en particulier, si un tableau presque trié est traité) augmenté à </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce problème a été personnellement abordé par Edsger Dijkstra lui-même, qui a découvert que oui, c'est possible. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est supposé que ceux qui lisent cet article comprennent comment fonctionne le tri par tas en général, ils savent ce qu'est l'arbre de tri et pourquoi un tri est nécessaire. </font><font style="vertical-align: inherit;">Si quelqu'un a des lacunes dans ces connaissances, avant de continuer la lecture, je vous </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recommande de lire l'article précédent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quel est le problème avec un tas binaire</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment heapsort trie un tableau presque ordonné et voyons pourquoi cet algorithme ne traite pas ces données entrantes plus rapidement.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><div style="text-align:center;"><img width="646" height="303" src="https://habrastorage.org/webt/mr/x_/g9/mrx_g9exydmumk4rh-efffgvw_u.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cliquez sur l'animation pour aller à l'article "Tri par une n-pyramide".</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
La première chose qui attire votre attention est que lors du tamisage, les maxima sont constamment poussés à la racine du tas, ce qui correspond au premier élément du tableau. Si le tableau d'entrée est presque ordonné, alors pour l'algorithme, cela n'ajoutera qu'un peu de travail. Les éléments plus petits descendent toujours en premier dans l'arbre, c'est-à-dire rapprochez-vous de la fin du tableau, pas de son début.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxième facteur de ralentissement, qui n'est pas si évident, est que le tas binaire standard lui-même est toujours un arbre équilibré. </font><font style="vertical-align: inherit;">Dans le cas de données initialement ordonnées, cela joue un rôle négatif. </font><font style="vertical-align: inherit;">S'il y a des données aléatoires dans le tableau d'origine, alors elles sont réparties uniformément dans un arbre équilibré, et le tri multiple passe par toutes les branches environ le même nombre de fois. </font><font style="vertical-align: inherit;">Pour les données presque ordonnées, un arbre déséquilibré est plus préférable - dans ce cas, les données sur la partie du tableau qui correspond à des branches plus longues de l'arbre seront traitées moins souvent que les autres.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numéros de Leonardo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour résoudre ces deux problèmes, Dijkstra a proposé d'utiliser des tas binaires spéciaux basés sur les nombres de Leonardo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les chiffres de Leonardo sont presque comme les chiffres de Fibonacci, mais en mieux. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une série de nombres de Leonardo est donnée récursivement: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les 20 premiers nombres de Leonardo: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1, 1, 3, 5, 9, 15, 25, 41, 67 , 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, 13529 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Absolument tout entier peut être représenté comme la somme des nombres Leonardo ayant des numéros de série différents. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci est très utile dans notre cas. Tableau de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les éléments ne peuvent pas toujours être représentés comme un seul tas de Leonardo (si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n n'est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pas un nombre de Leonardo). </font><font style="vertical-align: inherit;">Mais alors, tout tableau peut toujours être divisé en plusieurs sous-réseaux qui correspondront à différents nombres de Leonardo, c'est-à-dire </font><font style="vertical-align: inherit;">être des tas d'ordre différent. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un exemple d'un tableau du 21e élément, composé de trois tas de Leonard. </font><font style="vertical-align: inherit;">Dans chacun des tas, le nombre de nœuds correspond à n'importe quel nombre de Leonardo.</font></font><br>
<br>
<div style="text-align:center;"><img width="760" height="369" src="https://habrastorage.org/webt/-9/w7/1b/-9w71bwg0hst69nkbnewpiyku9m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Points importants à savoir:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque pile Leonardov est un arbre binaire déséquilibré.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La racine de chaque segment est le dernier (et non le premier, comme dans un segment binaire normal) du sous-tableau correspondant.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout nœud avec tous ses descendants est également un tas Leonard d'un ordre plus petit.</font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Construire et démonter des tas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la formule de récurrence des nombres de Leonardo, </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 est </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
très satisfait de l'unité à la fin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et c'est pourquoi. Supposons que nous ayons deux sous-réseaux adjacents dans le tableau qui correspondent à des tas construits sur deux nombres Leonardo adjacents. En utilisant l'élément immédiatement après ces sous-réseaux, ces sous-réseaux peuvent être combinés en un tas commun, qui correspond au numéro de Leonard suivant.</font></font><br>
<br>
<div style="text-align:center;"><img width="694" height="423" src="https://habrastorage.org/webt/ds/jv/5b/dsjv5bfc0ao4k9d-frevjzg3wee.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En parcourant les éléments du tableau, nous construisons un tas de tas de Leonard. Si vous utilisez l'élément, vous pouvez combiner les deux tas précédents (cela est possible si et seulement si les deux tas précédents correspondent à deux nombres Leonardo consécutifs), alors combinez. Si la combinaison n'est pas possible (les deux tas précédents ne correspondent pas à deux nombres Leonardo consécutifs), alors l'élément courant forme simplement un nouveau tas d'un élément correspondant au premier (ou second, si le premier est utilisé avant) nombre Leonardo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À la deuxième étape de l'algorithme, le processus inverse se produit - nous analysons les tas. Si nous supprimons la racine dans le tas, nous obtenons alors deux tas plus petits correspondant aux deux nombres de Leonardo précédents. Cela peut être fait parce que: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 1 = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n - 2</font></font></sub></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dans les nombres de Fibonacci il n'y a pas une telle unité utile, donc nous n'utilisons pas le tas de Fibonacci.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri en douceur :: Smoothsort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'algorithme final:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I. Créez un tas de tas de Leonard à partir du tableau, chacun étant un arbre de tri.</font></font></b><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I.1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itérer sur les éléments du tableau de gauche à droite.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous vérifions si en utilisant l'élément courant, il est possible de combiner les deux tas les plus à gauche dans le tas existant de tas de Leonard:</font></font><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1.a. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si oui, alors nous combinons les deux tas les plus à gauche en un seul, l'élément courant devient la racine de ce tas, nous faisons un tri pour le tas combiné.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1.b. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si ce n'est pas le cas, ajoutez l'élément actuel en tant que nouveau tas (constitué d'un nœud jusqu'à présent) au tas existant de tas Leonard.</font></font></li>
</ul></li>
</ul></li>
<li><b>II.      ,       :</b><ul>
<li><b>II.1.</b>     .          ,      .</li>
<li><b>II.2.</b>   (     )       (     ).</li>
<li><b>II.3.</b>    ,         .     .</li>
<li><b>II.4.</b>      (    ),          .</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.5. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir déplacé l'élément maximal jusqu'à la fin, la partie triée du tableau a augmenté et la partie non triée a diminué. </font><font style="vertical-align: inherit;">Répétez les étapes II.1 à II.4 pour la partie non triée restante de la baie.</font></font></li>
</ul></li>
</ul><br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/wo/hc/ve/wohcve4fi78vdotmyfuw9pr2yyo.gif"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple d'implémentation de Python</font></font></h3><br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> random<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">smoothsort</span>(<span class="hljs-params">lst</span>):</span><font></font>
<font></font>
    <span class="hljs-comment">#    </span><font></font>
    leo_nums = leonardo_numbers(len(lst))<font></font>
<font></font>
<font></font>
    <span class="hljs-comment">#       </span><font></font>
    heap = []<font></font>
<font></font>
    <span class="hljs-comment">#   </span>
    <span class="hljs-comment">#       </span>
    <span class="hljs-comment">#       </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(lst)):
        <span class="hljs-keyword">if</span> len(heap) &gt;= <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> heap[<span class="hljs-number">-2</span>] == heap[<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>:<font></font>
            heap.pop()<font></font>
            heap[<span class="hljs-number">-1</span>] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> len(heap) &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> heap[<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>:<font></font>
                heap.append(<span class="hljs-number">0</span>)
            <span class="hljs-keyword">else</span>:<font></font>
                heap.append(<span class="hljs-number">1</span>)<font></font>
        restore_heap(lst, i, heap, leo_nums)<font></font>
<font></font>
    <span class="hljs-comment">#  </span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> reversed(range(len(lst))):
        <span class="hljs-keyword">if</span> heap[<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">2</span>:<font></font>
            heap.pop()<font></font>
        <span class="hljs-keyword">else</span>:<font></font>
            k = heap.pop()<font></font>
            t_r, k_r, t_l, k_l = get_child_trees(i, k, leo_nums)<font></font>
            heap.append(k_l)<font></font>
            restore_heap(lst, t_l, heap, leo_nums)<font></font>
            heap.append(k_r)<font></font>
            restore_heap(lst, t_r, heap, leo_nums)<font></font>
<font></font>
<span class="hljs-comment">#   ,     </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leonardo_numbers</span>(<span class="hljs-params">hi</span>):</span><font></font>
<font></font>
    a, b = <span class="hljs-number">1</span>, <span class="hljs-number">1</span><font></font>
    numbers = []<font></font>
    <span class="hljs-keyword">while</span> a &lt;= hi:<font></font>
        numbers.append(a)<font></font>
        a, b = b, a + b + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> numbers<font></font>
<font></font>
<span class="hljs-comment">#        </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">restore_heap</span>(<span class="hljs-params">lst, i, heap, leo_nums</span>):</span><font></font>
    <font></font>
    <span class="hljs-comment">#      </span><font></font>
    <font></font>
    current = len(heap) - <span class="hljs-number">1</span><font></font>
    k = heap[current]<font></font>
<font></font>
    <span class="hljs-keyword">while</span> current &gt; <span class="hljs-number">0</span>:<font></font>
        j = i - leo_nums[k]<font></font>
        <span class="hljs-keyword">if</span> (lst[j] &gt; lst[i] <span class="hljs-keyword">and</span>
            (k &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> lst[j] &gt; lst[i<span class="hljs-number">-1</span>] <span class="hljs-keyword">and</span> lst[j] &gt; lst[i<span class="hljs-number">-2</span>])):<font></font>
            lst[i], lst[j] = lst[j], lst[i]<font></font>
            i = j<font></font>
            current -= <span class="hljs-number">1</span><font></font>
            k = heap[current]<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span><font></font>
<font></font>
    <span class="hljs-comment"># </span><font></font>
    <font></font>
    <span class="hljs-keyword">while</span> k &gt;= <span class="hljs-number">2</span>:<font></font>
        t_r, k_r, t_l, k_l = get_child_trees(i, k, leo_nums)<font></font>
        <span class="hljs-keyword">if</span> lst[i] &lt; lst[t_r] <span class="hljs-keyword">or</span> lst[i] &lt; lst[t_l]:
            <span class="hljs-keyword">if</span> lst[t_r] &gt; lst[t_l]:<font></font>
                lst[i], lst[t_r] = lst[t_r], lst[i]<font></font>
                i, k = t_r, k_r<font></font>
            <span class="hljs-keyword">else</span>:<font></font>
                lst[i], lst[t_l] = lst[t_l], lst[i]<font></font>
                i, k = t_l, k_l<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span><font></font>
<font></font>
<span class="hljs-comment">#         ,</span>
<span class="hljs-comment">#     </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_child_trees</span>(<span class="hljs-params">i, k, leo_nums</span>):</span><font></font>
<font></font>
    t_r, k_r = i - <span class="hljs-number">1</span>, k - <span class="hljs-number">2</span>
    t_l, k_l = t_r - leo_nums[k_r], k - <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> t_r, k_r, t_l, k_l<font></font>
<font></font>
<span class="hljs-comment">#  </span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">n</span>):</span><font></font>
    lst = list(range(n))<font></font>
    random.shuffle(lst)<font></font>
    print(lst)<font></font>
    smoothsort(lst)<font></font>
    print(lst)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complexité temporelle</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous prenons un tableau presque ordonné en entrée, la visualisation montre pourquoi un tel tableau est traité beaucoup plus rapidement.</font></font><br>
<br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/x1/g1/kg/x1g1kglflod3zdnc2vuiqumjoyy.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les économies se produisent uniquement grâce au tamisage. Dans des données presque ordonnées, le tamisage coule peu profond dans l'arbre, y compris après que les tas ont été progressivement dissous au cours de la deuxième étape. Dans les données initialement aléatoires, le criblage est plus cher, car il tombe souvent dans son tas jusqu'au dernier niveau. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estimons la complexité totale du temps. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À la première étape, nous itérons sur n éléments, en l'ajoutant aux tas déjà existants à gauche. L'ajout au tas lui-même est ignoré dans O (1), mais pour le tas, vous devez effectuer un tri. Dans les données ordonnées, un tamisage superficiel coûte souvent O (1) pour un élément ajouté au tas. Dans les données non ordonnées, le criblage pour chaque ajout est évalué en </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car en raison du caractère aléatoire, le tamisage doit passer souvent par les niveaux de l'arbre jusqu'au fond. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, à la première étape, la meilleure complexité temporelle est: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pour des données presque ordonnées - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pour des données aléatoires - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour la deuxième étape, la situation est similaire. Lors de l'échange du maximum suivant, vous devez à nouveau tamiser le tas à la racine duquel il se trouvait. Et les métriques de tri pour les données ordonnées et désordonnées seront différentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au deuxième stade, la meilleure complexité temporelle est la même qu'au premier: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pour des données presque ordonnées - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pour des données aléatoires - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ajout de la complexité temporelle pour les première et deuxième étapes: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pour les données presque ordonnées - O (2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pour les données aléatoires - O (2 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, la complexité temporelle la plus mauvaise et moyenne pour un tri en douceur est O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dijkstra dans ses calculs (dont je ne vous ennuierai pas) a prouvé que la meilleure complexité </font><font style="vertical-align: inherit;">tend vers </font><nobr><font style="vertical-align: inherit;">O ( </font></nobr><nobr><b><font style="vertical-align: inherit;">n</font></b></nobr><nobr><font style="vertical-align: inherit;"> ) en </font></nobr></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">douceur</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que les données entrantes les plus ordonnées. </font><font style="vertical-align: inherit;">D'où le nom - un tri en douceur.</font></font><nobr><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font></nobr><font style="vertical-align: inherit;"></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complexité de mémoire supplémentaire</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour décomposer les données en un tas de tas de Leonard, il vous suffit de vous rappeler exactement quels numéros Leonardo sont impliqués à chaque étape. </font><font style="vertical-align: inherit;">Connaissant ces nombres, les tas eux-mêmes sont alignés algorithmiquement. </font><font style="vertical-align: inherit;">Cette série de nombres croît très rapidement, donc même pour les grands tableaux, vous aurez besoin d'un très petit ensemble de nombres Leonard.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri par tas binomial :: Tri par tas binomial</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a une structure arborescente, très similaire à celle que nous avons triée - un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tas binomial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il s'agit également d'un tas de tas de tailles différentes, dans chacun desquels le nombre de nœuds est une puissance de deux. </font><font style="vertical-align: inherit;">Tout tableau de n'importe quel nombre d'éléments peut être développé dans ce tas, car tout nombre naturel est décomposé en la somme de deux degrés différents. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En principe, vous pouvez effectuer un tri en douceur basé sur des binômes:</font></font><br>
<br>
<div style="text-align:center;"><img width="722" height="537" src="https://habrastorage.org/webt/rw/p9/0y/rwp90yy_ub8vvvk2uczfoa4db8y.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela fonctionnera-t-il plus rapidement? </font><font style="vertical-align: inherit;">À peine. </font><font style="vertical-align: inherit;">Le tas binomial n'est pas binaire, et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le dernier article, nous avons découvert que l'augmentation du nombre de descendants n'accélère pas, mais ralentit l'écran</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">De plus, vous pouvez remarquer que le tas binomial a des branches plus longues, c'est pourquoi les régions ordonnées voisines de la matrice seront légèrement plus lentes à se connecter les unes aux autres. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On ne sait pas si le tas binomial de Dijkstra était généralement considéré comme une base possible pour son algorithme. </font><font style="vertical-align: inherit;">Quoi qu'il en soit, le tas Leonardov est probablement plus optimal.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remorque de la série suivante</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, même si une pile binomiale n'est pas la meilleure option pour un tri en douceur, vous ne devez pas la jeter complètement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si l'arbre binomial est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">légèrement modifié</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et que des idées complètement différentes (très audacieuses) sont utilisées pour le contourner, alors nous obtenons un algorithme original et efficace qui a ses propres avantages. </font><font style="vertical-align: inherit;">De quoi allons-nous parler la prochaine fois?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/1l/ay/j-/1layj-xmzm4dl7p5yv7_5iag5pa.gif"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cliquez sur l'animation pour accéder à l'article avec le prochain tri par tas.</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Références</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">nombre de Leonardo </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">lisse</font></a><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lisse</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">tas binomial</font></a><font style="vertical-align: inherit;"> / </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">tas binomial</font></a></font><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Articles de série:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application Excel AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exchange Sorts</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri d'insertion</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trier par sélection</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classes de tas: N-Pyramides</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Leonardo Numbers</font></font></b></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri par tas: tas faible</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Torts de bouquet: arbre cartésien</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autres tri de tas: tas miroir, mini tas, tamisage de bas en haut</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classes de tas: Jung Heap</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusionner les tris</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trier par distribution</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri hybride</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le tri fluide d'aujourd'hui a été ajouté à l'application AlgoLab. </font><font style="vertical-align: inherit;">Ainsi qu'un bonus - et le tri avec une pile binomiale. </font><font style="vertical-align: inherit;">Alors, qui veut conduire personnellement les données sur les tas de tas - mettez à jour le fichier Excel avec des macros.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr496840/index.html">Musk pense que 12 000 satellites n'interféreront pas avec les astronomes. Son opinion n'est pas conforme au modèle</a></li>
<li><a href="../fr496842/index.html">Un modèle épidémique simple avec des outils de base Python</a></li>
<li><a href="../fr496846/index.html">Mécanique du langage des piles et des pointeurs</a></li>
<li><a href="../fr496848/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 340 (du 6 au 12 avril)</a></li>
<li><a href="../fr496850/index.html">Plugin Maven pour JPackage de Java 14</a></li>
<li><a href="../fr496856/index.html">Maison intelligente sans télécommandes, mais avec un cube</a></li>
<li><a href="../fr496858/index.html">FOSS News n ° 11 - une revue des logiciels libres et open source du 6 au 12 avril 2020</a></li>
<li><a href="../fr496860/index.html">Première DI: Première DI sur les interfaces pour les applications dactylographiées</a></li>
<li><a href="../fr496862/index.html">Affichage Bulle Arduino</a></li>
<li><a href="../fr496864/index.html">Portefeuilles d'audit dans CryptoNote</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>