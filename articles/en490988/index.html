<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐛 💵 🛢️ We study multicast RxJS operators 👨🏾‍🏭 👨🏻‍🍳 👩🏻‍🤝‍👨🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! I present to you the translation of the article "Understanding RxJS Multicast Operators" by Netanel Basal. 
 
 Broadcast or multicast ope...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>We study multicast RxJS operators</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490988/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, Habr! </font><font style="vertical-align: inherit;">I present to you the translation of the article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Understanding RxJS Multicast Operators"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> by Netanel Basal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Broadcast or multicast operators often seem like the hardest topic to learn about RxJS. </font><font style="vertical-align: inherit;">In this article I will try to explain everything in an accessible way. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will consider the internal structure of multicast operators and the tasks they solve.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start by describing the basic building blocks of RxJS.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observable</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In RxJS, observable objects (hereinafter referred to as “streams”) are initially cold. This means that every time you subscribe to a stream, a callback of the subscription is performed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a better understanding, create the following implementation:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observable</span> </span>{
  <span class="hljs-keyword">constructor</span>(subscriptionFn) {
    <span class="hljs-keyword">this</span>.subscriptionFn = subscriptionFn;<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.subscriptionFn(observer);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The constructor </font></font><code>Observable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accepts a single parameter - the callback of the subscription </font></font><br>
 <code>subscriptionFn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It will be called every time we subscribe to the stream ( </font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sometimes they also call a callback of a subscription </font></font><code>producer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as it also “produces” values ​​for the subscriber (observer object in our code). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The method </font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">takes an input </font></font><code>observer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It is an object with three own methods: </font></font><code>next(), error(), complete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In live RxJS, you can pass three functions instead of an object. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The method, </font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when called, calls the subscription function passing it to the input </font></font><code>observer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We did not mention the method now</font></font><code>unsubscribe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but it should be borne in mind that each subscription provides a way to destroy it. </font><font style="vertical-align: inherit;">Most often, a subscription returns a function (or an object with the appropriate method), during which the connection between the stream and its subscribers is destroyed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is all pretty simple. </font><font style="vertical-align: inherit;">Let's move closer to reality now. </font><font style="vertical-align: inherit;">For example, wrap a native XHR API in a stream</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">http</span>(<span class="hljs-params">url</span>) </span>{
  <span class="hljs-comment">// This function will be called when we call http().subscribe()</span>
  <span class="hljs-keyword">const</span> subscriptionFn = <span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> {<font></font>
    log(<span class="hljs-string">'Observable execution: http'</span>);
    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<font></font>
    xhr.addEventListener(<span class="hljs-string">'load'</span>, () =&gt; {
      <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span> &amp;&amp; xhr.status === <span class="hljs-number">200</span>) {<font></font>
        observer.next(<span class="hljs-built_in">JSON</span>.parse(xhr.responseText));<font></font>
        observer.complete();<font></font>
      }<font></font>
    });<font></font>
    xhr.open(<span class="hljs-string">'GET'</span>, url);<font></font>
    xhr.send();<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> xhr.abort()<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(subscriptionFn);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We wrote a function </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that receives a URL, executes an http request, and returns a stream that emits the received http response. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, looking at our implementation, what do you think will happen when we subscribe to this stream twice?</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-comment">// A small observer helper</span>
<span class="hljs-keyword">const</span> observer = <span class="hljs-function"><span class="hljs-params">tag</span> =&gt;</span> ({<font></font>
  next(value) {<font></font>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${tag}</span>:`</span>, value);<font></font>
  }<font></font>
});<font></font>
<font></font>
http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .subscribe(observer(<span class="hljs-string">'subscriber-1'</span>));<font></font>
<font></font>
http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .subscribe(observer(<span class="hljs-string">'subscriber-2'</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Correctly, two http requests will be executed. </font><font style="vertical-align: inherit;">If we look again at the implementation of the Observable class, we will see why this is so. </font><font style="vertical-align: inherit;">Each subscriber calls a subscription callback, which in turn performs an http request each time.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ay/by/ee/aybyeesbyfdzvcjcp3etc8jhfww.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operators</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An operator is a function that takes a stream as an input, performs any action, and returns a stream. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will write our first own operator.</font></font><br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">source</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> {<font></font>
      log(<span class="hljs-string">'Observable execution: map'</span>);
      <span class="hljs-keyword">return</span> source.subscribe({<font></font>
        next(value) {<font></font>
          observer.next(fn(value));<font></font>
        }<font></font>
      });<font></font>
    });<font></font>
  };<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The function </font></font><code>map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns an operator that accepts the original stream and returns a stream in which all passing values ​​will be passed through the function </font></font><code>fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Those. </font><font style="vertical-align: inherit;">inside it there is always a subscription to the input stream. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before using this new operator, we need to somehow attach it to the stream. </font><font style="vertical-align: inherit;">Extend our class </font></font><code>Observable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by</font></font><code>pipe()</code><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observable</span> </span>{
  <span class="hljs-keyword">constructor</span>(subscriptionFn) {
    <span class="hljs-keyword">this</span>.subscriptionFn = subscriptionFn;<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.subscriptionFn(observer);<font></font>
  }<font></font>
<font></font>
  pipe(...operators) {<font></font>
    <span class="hljs-keyword">return</span> operators.reduce(<span class="hljs-function">(<span class="hljs-params">source, next</span>) =&gt;</span> next(source), <span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A simple method, just one line of code. </font></font><code>pipe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It takes an array of operators and calls them in turn, passing each input the result of the previous one. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's use our operator:</font></font><br>
<br>
<pre><code class="javascript hljs">http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .pipe(map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">0</span>]))<font></font>
  .subscribe(observer(<span class="hljs-string">'subscriber'</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When called </font></font><code>subscribe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a subscription to the output stream will be executed </font></font><code>map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and in turn </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a subscription to the original stream will be executed </font><font style="vertical-align: inherit;">inside </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The http stream emits the value it falls into </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Then, the function is executed </font></font><code>fn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the stream from </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emits the value to the final subscription. </font><font style="vertical-align: inherit;">It works like a </font></font><code>observable chain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thread chain. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/4a/ou/8r/4aou8rffl-aqkm6asdvs2224n84.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we subscribe to a chain twice, each subscription in the chain will be called twice.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> firstUser$ = http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
    .pipe(map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">0</span>]));<font></font>
<font></font>
firstUser$.subscribe(observer(<span class="hljs-string">'subscriber-1'</span>));<font></font>
firstUser$.subscribe(observer(<span class="hljs-string">'subscriber-2'</span>));
</code></pre><br>
<img src="https://habrastorage.org/webt/kg/c2/iw/kgc2iwjualmgnqh_kcaxfe4c45g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And if this behavior does not suit us? </font><font style="vertical-align: inherit;">If we want to call the subscription function only once, how many subscriptions would we have? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, what if we want to make one http request and use the result for all subscribers? </font><font style="vertical-align: inherit;">In this case you need </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Subjects</font></font></h2><br>
<code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it is both a stream and a subscriber. </font><font style="vertical-align: inherit;">The flow - because it has a method </font></font><code>subscribe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the subscriber - because it implements the subscriber interface - methods </font></font><code>next(), error(), complete().</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's write it.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.observers = [];<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">this</span>.observers.push(observer);<font></font>
  }<font></font>
<font></font>
  next(value) {<font></font>
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.next(value));<font></font>
  }<font></font>
<font></font>
  error(error) {<font></font>
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.error(error));<font></font>
  }<font></font>
<font></font>
  complete() {<font></font>
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.complete());<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
<code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can act as an intermediate between the cold stream and many subscribers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Change our example as follows:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> Subject();<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber1'</span>));<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber2'</span>));<font></font>
<font></font>
http(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>)<font></font>
  .pipe(map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">0</span>]))<font></font>
  .subscribe(subject);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When called </font></font><code>subject.subscribe(someFn)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, only one simple operation is performed - adding a </font></font><code>subject.observers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">function </font><font style="vertical-align: inherit;">to the array </font></font><code>someFn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, then, since it </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">behaves as a subscriber too, you can subscribe it to the original stream, i.e. </font><font style="vertical-align: inherit;">when the original thread issues a value, it is called </font></font><code>subject.next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which entails the transfer of this value to each of the subscribers </font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we have the original callback of the subscription is executed once, and only one http-request will be executed.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hk/8h/ld/hk8hld-xyjtum5d3srqpquhaqic.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Party latecomers</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What happens if the original stream already worked before we signed up? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It will not be possible to show this in the previous example, since http is asynchronous, even if you subscribe to it immediately after, the value will still come after the subscription. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's quickly create a generating function </font></font><code>of</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">of</span>(<span class="hljs-params">...values</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> {<font></font>
    log(<span class="hljs-string">'Observable execution: of'</span>);<font></font>
    values.forEach(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> observer.next(value));<font></font>
  });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A stream created by means </font></font><code>of()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emits values ​​synchronously, one after the other. </font><font style="vertical-align: inherit;">We will subscribe </font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after it has already subscribed to of.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> Subject();
<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).subscribe(subject);<font></font>
<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber1'</span>));<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber2'</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our subscribers have not received anything. Why? Our implementation does not support “late” subscribers. When the original stream from </font></font><code>of()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emits values, subscribers are not registered yet, these values ​​will go nowhere. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In actual examples on Angular, it may well be that the source stream worked, but your component is not yet present on the page. And when the component appears, it subscribes to the source, but does not receive the values ​​that have already passed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One way to solve the problem is this </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. We outline its version and see how it works.</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReplaySubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span> </span>{
  <span class="hljs-keyword">constructor</span>(bufferSize) {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.observers = [];
    <span class="hljs-keyword">this</span>.bufferSize = bufferSize;
    <span class="hljs-keyword">this</span>.buffer = [];<font></font>
  }<font></font>
<font></font>
  subscribe(observer) {<font></font>
    <span class="hljs-keyword">this</span>.buffer.forEach(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> observer.next(val));
    <span class="hljs-keyword">this</span>.observers.push(observer);<font></font>
  }<font></font>
<font></font>
  next(value) {<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.buffer.length === <span class="hljs-keyword">this</span>.bufferSize) {
      <span class="hljs-keyword">this</span>.buffer.shift();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">this</span>.buffer.push(value);
    <span class="hljs-keyword">this</span>.observers.forEach(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> observer.next(value));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The concept is simple. As the name implies, </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this is a special </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one that can reproduce old values ​​to all new subscribers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each released value will be transferred to all current subscribers and saved for future ones, the buffer size is </font></font><code>bufferSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">set in the constructor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rewrite the previous example with </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> ReplaySubject(<span class="hljs-number">3</span>);
<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).subscribe(subject);<font></font>
<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber1'</span>));<font></font>
subject.subscribe(observer(<span class="hljs-string">'subscriber2'</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The result has changed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despite the late subscription, we caught them all. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sg/xv/y1/sgxvy1flevy8totuzlejeiphvm0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Summarizing, the purpose </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the distribution of values ​​to all subscribers and caching them for future "late" subscribers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before moving on, I recommend that you try writing your own implementation </font></font><code>BehaviorSubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">You can find the finished code at the end of the article. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we finally move on to multicast operators. </font><font style="vertical-align: inherit;">I hope the above examples will help you understand them faster.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multicast operators</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multicast and Connect</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The operator </font></font><code>multicast() </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uses </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to issue the source stream to several subscribers.</font></font><br>
<br>
<pre><code class="javascript hljs">
<span class="hljs-keyword">import</span> { interval, Subject, ConnectableObservable } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { multicast } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-keyword">new</span> Subject())<font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">const</span> observer1 = connectableObservable.subscribe(log);
<span class="hljs-keyword">const</span> observer2 = connectableObservable.subscribe(log);<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectableSubscription = (connectableObservable <span class="hljs-keyword">as</span> ConnectableObservable&lt;any&gt;)<font></font>
  .connect();<font></font>
</code></pre><br>
<code>multicast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns an object </font></font><code>ConnectableObservable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that has a method </font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Its purpose is to subscribe the received subject to the source stream. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The method </font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allows us to determine when to start the execution of the original thread. </font><font style="vertical-align: inherit;">There is a moment to keep in mind - to unsubscribe from the source you need to do:</font></font><br>
<br>
<pre><code class="javascript hljs">connectableSubscription.unsubscribe();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We are not limited to simple </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Instead, you can use any derived class, for example </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { interval, ReplaySubject, ConnectableObservable } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { multicast } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-keyword">new</span> ReplaySubject(<span class="hljs-number">1</span>))<font></font>
)<font></font>
<font></font>
<span class="hljs-keyword">const</span> observer1 = connectableObservable.subscribe(log);<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Late subscriber</span><font></font>
  connectableObservable.subscribe(log);<font></font>
}, <span class="hljs-number">3000</span>)<font></font>
<font></font>
<span class="hljs-keyword">const</span> connectable = (connectableObservable <span class="hljs-keyword">as</span> ConnectableObservable&lt;any&gt;).connect();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From this code you can guess what will happen under the hood. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When we use </font></font><code>multicast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we can transfer not only </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but also a factory function, which returns a new one each time </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reused already completed </font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can not be, the factory function solves this problem.</font></font><br>
<br>
<pre><code class="javascript hljs">interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> Subject())<font></font>
)<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refount</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When we use the operator </font></font><code>multicast()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we are responsible for the call </font></font><code>connect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to start execution of the original observable. </font><font style="vertical-align: inherit;">Plus, we still have to monitor for possible memory leaks, manually unsubscribing from </font></font><code>ConnectableSubscription</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Automation of the process would avoid errors and simplify the code. </font><font style="vertical-align: inherit;">The kind RxJS developers thought about it for us and created an </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operator. </font></font><br>
<br>
<code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">counts subscriptions and when the first appears, it calls </font></font><code>connect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, i.e. </font><font style="vertical-align: inherit;">subscribes. </font><font style="vertical-align: inherit;">When it decreases back to zero, a response will be called.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  multicast(<span class="hljs-keyword">new</span> Subject()),<font></font>
  refCount()<font></font>
)<font></font>
 <font></font>
<span class="hljs-comment">// refCount === 1 =&gt; source.subscribe();</span>
<span class="hljs-keyword">const</span> observer1 = source.subscribe(log);<font></font>
<font></font>
<span class="hljs-comment">// refCount === 2</span>
<span class="hljs-keyword">const</span> observer2 = source.subscribe(log);<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// refCount - 1</span><font></font>
  observer1.unsubscribe();<font></font>
  <span class="hljs-comment">// refCount - 1</span><font></font>
  observer2.unsubscribe();<font></font>
  <span class="hljs-comment">// refCount === 0 =&gt; source.unsubcribe();</span>
}, <span class="hljs-number">3000</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Note that after </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we get the usual observable, not </font></font><code>ConnectableObservable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Publish and its options</font></font></h3><br>
<code>multicast() + Subject + refCount()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this is a fairly typical case in RxJS and the developers have reduced it to a single operator. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's see what options we have.</font></font><br>
<br>
<ul>
<li><code>publish()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> equivalent </font></font><code>multicast(() =&gt; new Subject())</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publish()<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>publishBehavior()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> equivalent </font></font><code>multicast(new BehaviorSubject())</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publishBehavior(<span class="hljs-number">100</span>)<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>publishReplay()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> equivalent </font></font><code>multicast(() =&gt; new ReplaySubject(x))</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publishReplay(<span class="hljs-number">3</span>)<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>publishLast()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> equivalent </font></font><code>multicast(new AsyncSubject())</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> connectableObservable = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  take(<span class="hljs-number">2</span>),<font></font>
  publishLast()<font></font>
)<font></font>
<font></font>
connectableObservable.connect();<font></font>
</code></pre><br>
</li>
<li><code>share()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> equivalent </font></font><code>multicast(() =&gt; new Subject()) + refCount()</code><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  share()<font></font>
)<font></font>
</code></pre><br>
</li>
<li><code>shareReplay(bufferSize) </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a multicast operator that uses </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">He has no inside </font></font><code>multicast()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and his result is observable, not </font></font><code>ConnectableObservable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It can be used with </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or without it. </font><font style="vertical-align: inherit;">Here are both options:</font></font><br>
<br>
<pre><code class="javascript hljs">interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  shareReplay({ <span class="hljs-attr">refCount</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bufferSize</span>: <span class="hljs-number">1</span> })<font></font>
)<font></font>
<font></font>
interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  shareReplay(<span class="hljs-number">1</span>)<font></font>
)<font></font>
</code></pre></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When </font></font><code>shareReplay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">called with </font></font><code>{ refCount: false }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is like calling </font></font><code>shareReplay(x)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, there will be no reference counting. </font><font style="vertical-align: inherit;">This means that until the original stream is completed, it </font></font><code>shareReplay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be subscribed to it, regardless of whether it itself has the final subscribers or not. </font><font style="vertical-align: inherit;">All new subscribers will receive the last x values.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shareReplay vs publishReplay + refCount</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At first glance </font><font style="vertical-align: inherit;">, it is </font></font><code>shareReplay({ refCount: true, bufferSize: X })</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">identical </font></font><code>publishReplay(X) + refCount() </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but this is not entirely true. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's see what are the similarities and what is the difference. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
They have the same behavior </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- subscribing and unsubscribing from the original stream based on the number of subscribers. </font><font style="vertical-align: inherit;">They also react the same when the original stream is completed - all new subscribers receive X last values. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, if the original stream is not yet finalized, in this case when we have </font></font><code>publishReplay(X) + refCount()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- all new subscribers receive X values ​​from the buffer, and then will be re-signed using the same one </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But if we use the </font></font><code>shareReplay({ refCount: true, bufferSize: 1 })</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">last X values, they will not get it, since inside it creates a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new one</font></font></i> <code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and uses it to re-subscribe to the source.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examples illustrating this:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  publishReplay(<span class="hljs-number">1</span>),<font></font>
  refCount()<font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">const</span> one = source.subscribe(observer(<span class="hljs-string">'subcriber-1'</span>));<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
  one.unsubscribe();<font></font>
 <font></font>
  <span class="hljs-comment">// This subscriber will get the last emitted values from the source</span>
  <span class="hljs-keyword">const</span> two = source.subscribe(observer(<span class="hljs-string">'subcriber-2'</span>));<font></font>
}, <span class="hljs-number">3000</span>);</code></pre><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> source = interval(<span class="hljs-number">1000</span>).pipe(<font></font>
  shareReplay({ <span class="hljs-attr">refCount</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bufferSize</span>: <span class="hljs-number">1</span> })<font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">const</span> one = source.subscribe(observer(<span class="hljs-string">'subcriber-1'</span>));<font></font>
<font></font>
setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
  one.unsubscribe();<font></font>
  <font></font>
  <span class="hljs-comment">// This subscriber will NOT get the last emitted values from the source</span>
  <span class="hljs-keyword">const</span> two = source.subscribe(observer(<span class="hljs-string">'subcriber-2'</span>));<font></font>
}, <span class="hljs-number">3000</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/6i/j1/ih/6ij1ihusgtdo_avliuz4tk4gsca.png"><br>
<br>
<img src="https://habrastorage.org/webt/ew/nk/6q/ewnk6q0ems5ysw574aa7unvy2jc.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actual examples in Angular</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's see how to use the studied multicast operators in combat conditions.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use share</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose we have a component that needs data from the original stream. </font><font style="vertical-align: inherit;">It could be an http request, a state, or whatever. </font><font style="vertical-align: inherit;">And we also need data manipulation, such as filtering, sorting, etc.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;users-list [users]="allUsers$ | async"&gt;&lt;/users-list&gt;
  `</span>,<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersPageComponent</span> </span>{
  <span class="hljs-attr">allUsers$</span>: Observable&lt;User[]&gt;;<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {<font></font>
  }<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">this</span>.allUsers$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://api/users'</span>).pipe(<font></font>
      map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> filter/sort),<font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And now we need another component that shows only the first user. </font><font style="vertical-align: inherit;">If we subscribe to the source stream as it is, then:</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;user [user]="firstUser$ | async"&gt;&lt;/user&gt;
    &lt;users-list [users]="allUsers$ | async"&gt;&lt;/users-list&gt;
  `</span>,<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersPageComponent</span> </span>{
  <span class="hljs-attr">allUsers$</span>: Observable&lt;User[]&gt;;<font></font>
  firstUser$: Observable&lt;User&gt;;<font></font>
  <font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {<font></font>
  }<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">this</span>.allUsers$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://api/users'</span>).pipe(<font></font>
      map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> filter/sort),<font></font>
    );<font></font>
    <font></font>
    <span class="hljs-keyword">this</span>.firstUser$ = <span class="hljs-keyword">this</span>.allUsers$.pipe(map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> users[<span class="hljs-number">0</span>]));<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And now we have two http requests, sorting or filtering operations will be performed twice. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We apply </font></font><code>share</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &lt;user [user]="firstUser$ | async"&gt;&lt;/user&gt;
    &lt;users-list [users]="allUsers$ | async"&gt;&lt;/users-list&gt;
  `</span>,<font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersPageComponent</span> </span>{
  <span class="hljs-attr">allUsers$</span>: Observable&lt;User[]&gt;;<font></font>
  firstUser$: Observable&lt;User&gt;;<font></font>
  <font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {<font></font>
  }<font></font>
<font></font>
  ngOnInit() {<font></font>
    <span class="hljs-keyword">this</span>.allUsers$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://api/users'</span>).pipe(<font></font>
      map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> filter/sort),<font></font>
      share()<font></font>
    );<font></font>
    <font></font>
    <span class="hljs-keyword">this</span>.firstUser$ = <span class="hljs-keyword">this</span>.allUsers$.pipe(map(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> users[<span class="hljs-number">0</span>]));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We already know that he creates a new </font></font><code>Subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one that subscribes to the source. </font><font style="vertical-align: inherit;">When the source emits, subject passes this value to all its subscribers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The problem is resolved, and when we subscribed to </font></font><code>firstUser$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- we subscribed to the internal </font></font><code>subject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and not the original stream directly.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using ShareReplay</font></font></h3><br>
<code>ShareReplay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">applies when you need to emit, cache and repeat the last X values. </font><font style="vertical-align: inherit;">A typical example is a singleton service that performs an http request.</font></font><br>
<br>
<pre><code class="javascript hljs">
@Injectable({ <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlogService</span> </span>{<font></font>
  posts$ = <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">'https://jsonplaceholder.typicode.com/posts'</span>)<font></font>
              .pipe(shareReplay(<span class="hljs-number">1</span>));<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private http: HttpClient) {}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It doesn’t matter how many components will request data now or in the future, there will be only one http request and the result will be saved in the internal buffer </font></font><code>ReplaySubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There may still be a case where you need to cancel an incomplete request, because there are no subscribers, then you will need to apply </font></font><code>refCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The full code can be found </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en490976/index.html">Frontend section on DUMP2020: we’ll vanguard that there will be a full house again. Top reports of last year and topics of this</a></li>
<li><a href="../en490978/index.html">Send commands to multiple devices at the same time using SecureCRT</a></li>
<li><a href="../en490982/index.html">Bad advice to the employer. How to "properly" interact with the developer</a></li>
<li><a href="../en490984/index.html">Materials from the Nizhny Novgorod Android mitap. MotionLayout, Kotlin Coroutines, CI / CD infrastructure and design systems</a></li>
<li><a href="../en490986/index.html">Testing AMD Ryzen processors to work with KOMPAS-3D</a></li>
<li><a href="../en490992/index.html">Price discount management: models for quantifying the effect of gas stations as an example</a></li>
<li><a href="../en490996/index.html">STOP RESCUE! Instructions for self-assembly of the "medical mask"</a></li>
<li><a href="../en490998/index.html">Hardware testing in SIBUR</a></li>
<li><a href="../en491000/index.html">Styling Select-Option (almost) without JavaScript</a></li>
<li><a href="../en491006/index.html">Intel NUC as a pass in Unity3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>