<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏽 👵 👩🏽‍🚀 .NET: tratamiento de dependencia 🛌🏼 🍜 ⬜️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¿Quién no ha encontrado problemas debido a la redirección de ensamblado? Lo más probable es que todos los que desarrollaron una aplicación relativamen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>.NET: tratamiento de dependencia</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/499838/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Quién no ha encontrado problemas debido a la redirección de ensamblado? </font><font style="vertical-align: inherit;">Lo más probable es que todos los que desarrollaron una aplicación relativamente grande tarde o temprano se enfrenten a este problema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora trabajo en JetBrains, en el proyecto JetBrains Rider, y estoy involucrado en la tarea de migrar Rider a .NET Core. </font><font style="vertical-align: inherit;">Anteriormente participó en infraestructura compartida en Circuit, una plataforma de alojamiento de aplicaciones basada en la nube. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/je/f5/e-/jef5e-nc0okqm_ssla0qhniugio.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debajo de la escena se encuentra la transcripción de mi informe de la conferencia DotNext 2019 de Moscú, donde hablé sobre las dificultades al trabajar con asambleas en .NET y mostré con ejemplos prácticos lo que sucede y cómo lidiar con él.</font></font><a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/fMlTLw1agE0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En todos los proyectos donde trabajé como desarrollador de .NET, tuve que lidiar con varios problemas con la conexión de dependencias y la carga de ensamblajes. </font><font style="vertical-align: inherit;">Hablaremos de esto.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estructura del poste:</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problemas de dependencia</font></font></b></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estricto equipo de carga</font></font></b></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redireccionamientos vinculantes</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nombramiento fuerte</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core</font></font></a></b> <br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Marcos compartidos, .runtimeconfig.json</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manifiesto de dependencia (.deps.json)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacks para ejecutar JetBrains Rider en Core</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depurar descargas de ensamblados</font></font></a> </b><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registros de fusión</font></font></a> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eventos de tiempo de ejecución</font></font></a></li>
</ul><br>
</li>
</ol><br>
<a name="problems"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cuáles son algunos problemas de dependencia?</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando comenzaron a desarrollar .NET Framework a principios de la década de 2000, el problema del infierno de dependencias ya era conocido, cuando en todas las bibliotecas los desarrolladores permiten cambios importantes, y estas bibliotecas se vuelven incompatibles para su uso con código ya compilado. </font><font style="vertical-align: inherit;">¿Cómo resolver tal problema? </font><font style="vertical-align: inherit;">La primera solución es obvia. </font><font style="vertical-align: inherit;">Mantenga siempre la compatibilidad con versiones anteriores. </font><font style="vertical-align: inherit;">Por supuesto, esto no es muy realista, porque romper el cambio es muy fácil de incluir en el código. </font><font style="vertical-align: inherit;">Por ejemplo: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/un/gj/tv/ungjtvaiofi7qkm6a4if5cpgh10.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cambios de última hora y bibliotecas .NET</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es un ejemplo específico de .NET. Tenemos un método y decidimos agregar un parámetro con un valor predeterminado. El código continuará compilándose si lo reensamblamos, pero binario serán dos métodos completamente diferentes: un método tiene cero argumentos, el segundo método tiene un argumento. Si el desarrollador dentro de la dependencia rompió la compatibilidad con versiones anteriores de esta manera, entonces no podremos usar el código que se compiló con esta dependencia en la versión anterior.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La segunda solución a los problemas de dependencia es agregar versiones de bibliotecas, ensamblajes, cualquier cosa. Puede haber diferentes reglas de versiones, el punto es que de alguna manera podemos distinguir diferentes versiones de la misma biblioteca entre sí, y usted puede entender si la actualización se romperá o no. Desafortunadamente, tan pronto como presentamos las versiones, aparece un tipo diferente de problema. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/xc/wu/vgxcwufmesq4jly-ecfrh5p-ko8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La versión hell es la incapacidad de usar una dependencia que sea compatible con binarios, pero al mismo tiempo tiene una versión que no se ajusta al tiempo de ejecución u otro componente que verifica estas versiones. En .NET, una manifestación típica de la versión hell es FileLoadException, aunque el archivo se encuentra en el disco, pero por alguna razón no está cargado con tiempo de ejecución.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qy/wg/5m/qywg5mjhpkuogm6yez7uhnxitji.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En .NET, los ensamblados tienen muchas versiones diferentes: intentaron corregir los infiernos de versiones de varias maneras y ver qué sucedió. Tenemos un paquete </font></font><code>System.Collections.Immutable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mucha gente lo conoce. Tiene la última versión del paquete NuGet 1.6.0. Contiene una biblioteca, un ensamblado con la versión 1.2.4.0. Ha recibido que no tiene una biblioteca de compilación versión 1.2.4.0. ¿Cómo entender que se encuentra en el paquete NuGet 1.6.0? No será fácil. Además de la versión de ensamblaje, esta biblioteca tiene varias versiones más. Por ejemplo, Versión de archivo de ensamblaje, Versión de información de ensamblaje. Este paquete NuGet en realidad contiene tres ensamblajes diferentes con las mismas versiones (para diferentes versiones del estándar .NET). </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentación .NET </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opbuild estándar</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se ha escrito mucha documentación sobre cómo trabajar con ensamblados en .NET. </font><font style="vertical-align: inherit;">Existe una Guía .NET para desarrollar aplicaciones modernas para .NET teniendo en cuenta .NET Framework, .NET Standard, .NET Core, código abierto y todo lo que puede ser. </font><font style="vertical-align: inherit;">Alrededor del 30% de todo el documento está dedicado a cargar ensamblajes. </font><font style="vertical-align: inherit;">Analizaremos problemas específicos y ejemplos que puedan surgir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Por qué es todo esto necesario? </font><font style="vertical-align: inherit;">En primer lugar, para evitar pisar un rastrillo. </font><font style="vertical-align: inherit;">En segundo lugar, puede facilitar la vida de los usuarios de sus bibliotecas porque con su biblioteca no tendrán los problemas de dependencia a los que están acostumbrados. </font><font style="vertical-align: inherit;">También lo ayudará a hacer frente a la migración de aplicaciones complejas a .NET Core. </font><font style="vertical-align: inherit;">Y para colmo, puede convertirse en un SRE, este es un ingeniero de redireccionamiento senior (vinculante), al que todos en el equipo vienen y preguntan cómo escribir otra redirección.</font></font><a name="assembly"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Montaje estricto Cargando</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La carga estricta del ensamblado es el principal problema que enfrentan los desarrolladores en .NET Framework. </font><font style="vertical-align: inherit;">Se expresa en </font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Antes de continuar con la carga del ensamblaje estricto, permíteme recordarte algunas cosas básicas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando crea una aplicación .NET, la salida es un artefacto, que generalmente se encuentra en Bin / Debug o en Bin / Release, y contiene un cierto conjunto de ensamblajes de ensamblaje y archivos de configuración. </font><font style="vertical-align: inherit;">Los ensamblajes se referirán entre sí por nombre, nombre de ensamblaje. </font><font style="vertical-align: inherit;">Es importante comprender que los enlaces de ensamblaje se encuentran directamente en el ensamblaje que hace referencia a este ensamblaje; no hay archivos de configuración mágicos donde se escriben las referencias de ensamblaje. </font><font style="vertical-align: inherit;">Aunque le parezca que tales archivos existen. </font><font style="vertical-align: inherit;">Las referencias se encuentran en los propios ensamblados en forma binaria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En .NET, hay un proceso de resolución de ensamblaje: esto es cuando la definición del ensamblado ya se ha convertido en un ensamblaje real, que está en el disco o cargado en algún lugar de la memoria. La resolución de ensamblaje se realiza dos veces: en la etapa de compilación, cuando tiene referencias en * .csproj, y en tiempo de ejecución, cuando tiene referencias dentro de los ensamblajes, y según algunas reglas, se convierten en ensamblajes que se pueden descargar. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Nombre simple </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MyAssembly, Version = 6.0.0.0, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Culture = neutral, PublicKeyToken = null </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Nombre </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
seguro Newtonsoft.Json, Version = 6.0.0.0, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Culture = neutral, PublicKeyToken = 30ad4fe6b2a6aeed // PublicKey</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pasemos al problema. Nombre de la asamblea hay dos tipos principales. El primer tipo de nombre de ensamblado es Nombre simple. Son fáciles de identificar por el hecho de que tienen PublicKeyToken = null. Hay un nombre Strong, es fácil identificarlos por el hecho de que su PublicKeyToken no es nulo, sino que tiene algún valor. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/40/0v/uf/400vuf0e3w-ykw2fkdx2-ufdutq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pongamos un ejemplo. Tenemos un programa que depende de la biblioteca con las utilidades MyUtils, y la versión de MyUtils es 9.0.0.0. El mismo programa tiene un enlace a otra biblioteca. Esta biblioteca también quiere usar MyUtils, pero la versión 6.0.0.0. MyUtils versión 9.0.0.0 y versión 6.0.0.0 tienen PublicKeyToken = null, es decir, tienen un nombre simple. ¿Qué versión caerá en el artefacto binario, 6.0.0.0 o 9.0.0.0? Novena versión. ¿Puede MyLibrary usar MyUtils versión 9.0.0.0, que entró en el artefacto binario?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/js/fs/2x/jsfs2xd1erckl8dkphbrhojfhxk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, puede, porque MyUtils tiene un nombre simple y, en consecuencia, la carga de ensamblaje estricta no existe para él. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kz/tn/a6/kztna61effl0kkiuwnkvi1gpad8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro ejemplo. </font><font style="vertical-align: inherit;">En lugar de MyUtils, tenemos una biblioteca completa de NuGet, que tiene un nombre Strong. </font><font style="vertical-align: inherit;">La mayoría de las bibliotecas en NuGet tienen un nombre fuerte.</font></font><br>
<br>
<a name="redirects"></a><img src="https://habrastorage.org/webt/rr/xp/qi/rrxpqilvehdbvemijol2iuutbie.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la etapa de compilación, la versión 9.0.0.0 se copia a BIN, pero en tiempo de ejecución obtenemos la famosa </font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para que MyLibrary, que quiere la versión 6.0.0.0 </font></font><code>Newtonsoft.Json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pueda usar la versión 9.0.0.0, debe ir y escribir Redireccionamiento de enlace </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redireccionamientos vinculantes</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/lw/d_/yq/lwd_yq2otb7kqsbpkpglszjlr-y.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redirección de versiones de ensamblaje</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Establece que un ensamblaje con dicho nombre y publicKeyToken debe redirigirse de un rango de versiones a un rango de versiones. </font><font style="vertical-align: inherit;">Parece ser un registro muy simple, pero sin embargo se encuentra aquí </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero podría estar en otros archivos. </font><font style="vertical-align: inherit;">Hay un archivo </font></font><code>machine.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro de .NET Framework, dentro del tiempo de ejecución, en el que se define un conjunto estándar de redireccionamientos, que pueden diferir de una versión a otra de .NET Framework. </font><font style="vertical-align: inherit;">Puede suceder que en 4.7.1 nada funcione para usted, pero en 4.7.2 ya funciona, o viceversa. </font></font><code>.App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debe </font><font style="vertical-align: inherit;">tener en cuenta que los redireccionamientos pueden provenir no solo del suyo </font><font style="vertical-align: inherit;">, y esto debe tenerse en cuenta al depurar.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplificamos la escritura de redireccionamientos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nadie quiere escribir redireccionamientos vinculantes con sus manos. ¡Démosle esta tarea a MSBuild! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pg/qk/ct/pgqkctk1hwcp0lewpamhi5wn35o.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cómo habilitar y deshabilitar la redirección automática de enlaces</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Algunos consejos sobre cómo simplificar el trabajo con la redirección de enlaces. Consejo uno: habilite la generación automática de redireccionamiento de enlace en MSBuild. Activado por propiedad en </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Al construir un proyecto, caerá en un artefacto binario </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que indica redirecciones a versiones de bibliotecas que están en el mismo artefacto. Esto solo funciona para ejecutar aplicaciones, aplicaciones de consola, WinExe. Para las bibliotecas, esto no funciona, porque para las bibliotecas</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la mayoría de las veces simplemente no es relevante, porque es relevante para una aplicación que se inicia y carga ensamblajes. Si realizó una configuración para la biblioteca, entonces en la aplicación algunas dependencias también pueden diferir de las que existían al construir la biblioteca, y resulta que la configuración para la biblioteca no tiene mucho sentido. Sin embargo, a veces para las bibliotecas las configuraciones todavía tienen sentido. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ik/g6/6n/ikg66nyqel3ejmqbln9xb1magyq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La situación cuando escribimos pruebas. Las pruebas generalmente se encuentran en ClassLibrary y también necesitan redireccionamientos. Los marcos de prueba pueden reconocer que la biblioteca con pruebas tiene una configuración dll e intercambiar las redirecciones que se encuentran en ellas por el código de las pruebas. Puede generar estos redireccionamientos automáticamente. Si tenemos un formato antiguo</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, no al estilo SDK, puede seguir el camino simple, cambiar el OutputType a Exe y agregar un punto de entrada vacío, esto obligará a MSBuild a generar redireccionamientos. Puedes ir hacia otro lado y usar el truco. Puede agregar otra propiedad a </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo que hace que MSBuild considere que para este OutputType todavía necesita generar redireccionamientos de enlace. Este método, aunque parece un truco, le permitirá generar redireccionamientos para bibliotecas que no se pueden rehacer en Exe, y para otros tipos de proyectos (excepto pruebas). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para el nuevo formato, los </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">redireccionamientos se generarán ellos mismos si usa Microsoft.NET.Test.Sdk moderno.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tercer consejo: no use la generación de redireccionamiento de enlace con NuGet. NuGet tiene la capacidad de generar redireccionamiento de enlace para bibliotecas que pasan de paquetes a las últimas versiones, pero esta no es la mejor opción. Todos estos redireccionamientos deberán agregarse </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y confirmarse, y si genera redireccionamientos utilizando MSBuild, los redireccionamientos se generarán durante la compilación. Si los cometes, es posible que tengas conflictos de fusión. Usted mismo puede simplemente olvidar actualizar la redirección de enlace en el archivo, y si se generan durante la compilación, no lo olvidará. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yi/fr/zq/yifrzq4fnvwitenrhkteup1cjfq.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resolver referencia de ensamblaje </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generar redireccionamientos de enlace</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tarea para aquellos que desean comprender mejor cómo funciona la generación de redireccionamientos de enlace: descubra cómo funciona, vea esto en el código. Vaya al directorio .NET, vaya a todas partes con la propiedad de nombre, que se utiliza para habilitar la generación. Este es generalmente un enfoque tan común, si hay alguna propiedad extraña para MSBuild, puede ir y aprovechar su uso. Afortunadamente, la propiedad generalmente se usa en configuraciones XML, y puede encontrar fácilmente su uso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si examina lo que hay en estos destinos XML, verá que esta propiedad activa dos tareas de MSBuild. Se llama a la primera tarea </font></font><code>ResolveAssemblyReferences</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y genera un conjunto de redireccionamientos que se escriben en los archivos. La segunda tarea </font></font><code>GenerateBindingRedirects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escribe los resultados de la primera tarea en</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Existe una lógica XML que corrige ligeramente el funcionamiento de la primera tarea y elimina algunos redireccionamientos innecesarios, o agrega otros nuevos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternativa a las configuraciones XML</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No siempre es conveniente mantener las redirecciones en la configuración XML. </font><font style="vertical-align: inherit;">Es posible que tengamos una situación en la que la aplicación descarga el complemento, y este complemento utiliza otras bibliotecas que requieren redireccionamientos. </font><font style="vertical-align: inherit;">En este caso, es posible que no conozcamos el conjunto de redireccionamientos que necesitamos o que no queramos generar XML. </font><font style="vertical-align: inherit;">En tal situación, podemos crear un AppDomain y, cuando se crea, aún transferirlo a donde se encuentra el XML con las redirecciones necesarias. </font><font style="vertical-align: inherit;">También podemos manejar errores de carga de ensamblajes en tiempo de ejecución. </font><font style="vertical-align: inherit;">Rantime .NET brinda esa oportunidad.</font></font><br>
<br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (sender, eventArgs) =&gt; <font></font>
{ <font></font>
   <span class="hljs-keyword">var</span> name = eventArgs.Name; 
   <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
   <font></font>
   <span class="hljs-keyword">return</span> Assembly.LoadFrom(...); <span class="hljs-comment">// PublicKeyToken should be equal</span><font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tiene un evento, se llama </font></font><code>CurrentDomain.AssemblyResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Al suscribirse a este evento, recibiremos errores sobre todas las descargas fallidas de ensamblajes. Obtenemos el nombre del ensamblaje que no se cargó, y obtenemos el ensamblaje de ensamblaje que solicitó que se cargara el primer ensamblaje. Aquí podemos cargar manualmente el ensamblaje desde el lugar correcto, por ejemplo, descartando la versión, simplemente tomándola del archivo y devolviendo este evento desde el controlador. O devuelva nulo si no tenemos nada que devolver, si no podemos cargar el ensamblado. PublicKeyToken debería ser el mismo, los ensamblados con diferentes PublicKeyToken de ninguna manera son amigos entre sí.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8q/m7/ge/8qm7ge64h4pbldvju9ya91uz8zm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este evento se aplica solo a un dominio de aplicación. </font><font style="vertical-align: inherit;">Si nuestro complemento crea un AppDomain dentro de sí mismo, esta redirección en tiempo de ejecución no funcionará en ellos. </font><font style="vertical-align: inherit;">Debe suscribirse de alguna manera a este evento en todos los AppDomain que creó el complemento. </font><font style="vertical-align: inherit;">Podemos hacer esto usando el AppDomainManager. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AppDomainManager es un ensamblado separado que contiene una clase que implementa una interfaz específica, y uno de los métodos de esta interfaz le permitirá inicializar cualquier nuevo AppDomain que se cree en la aplicación. </font><font style="vertical-align: inherit;">Una vez que se crea el AppDomain, se llamará a este método. </font><font style="vertical-align: inherit;">En él puedes suscribirte a este evento.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estricto montaje de carga y .NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En .NET Core no hay ningún problema llamado "Carga estricta de ensamblados", que se debe al hecho de que los ensamblados firmados requieren exactamente la versión solicitada. Hay otro requisito. Para todos los ensamblados, independientemente de si están firmados con un nombre seguro o no, se verifica que la versión que se cargó en tiempo de ejecución sea mayor o igual que la anterior. Si estamos en una situación de una aplicación con complementos, podemos tener una situación tal que el complemento se creó, por ejemplo, a partir de una nueva versión del SDK, y la aplicación en la que se descarga utiliza la versión anterior del SDK hasta ahora, y en lugar de desmoronarse, También podemos suscribirnos a este evento, pero ya en .NET Core, y también cargar el ensamblado que tenemos. Podemos escribir este código:</font></font><br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (s, eventArgs) =&gt; <font></font>
{ <font></font>
     CheckForRecursion(); <font></font>
     <span class="hljs-keyword">var</span> name = eventArgs.Name;
     <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
    <font></font>
     name.Version = <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <font></font>
     <font></font>
     <span class="hljs-keyword">return</span> Assembly.Load(name); <font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos el nombre del ensamblado que no se inició, anulamos la versión y la llamamos </font></font><code>Assembly.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde la misma versión. No habrá recursividad aquí, porque ya verifiqué la recursividad. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mt/cs/kr/mtcskrokxuvcn8i4gueywowb3_m.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Era necesario descargar MyUtils versión 0.0.2.0. En BIN, tenemos MyUtils versión 0.0.1.0. Realizamos una redirección de la versión 0.0.2.0 a la versión 0.0. La versión 0.0.1.0 no se cargará con nosotros. Nos saldrá una salida indicando que no fue posible cargar el ensamblaje con la versión 0.0.2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16–1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16-1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) == <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>) <font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Version</span> { 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Build; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Revision; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Major; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Minor; <font></font>
} <font></font>
(<span class="hljs-keyword">ushort</span>) <span class="hljs-number">-1</span> == <span class="hljs-number">65535</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la clase Versión, no todos los componentes son obligatorios, y en lugar de los componentes opcionales –1 se almacenan, pero en algún lugar del interior, se produce un desbordamiento y se obtienen los 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16–1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si está interesado, puede intentar encontrar exactamente dónde se produce el desbordamiento. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m5/bl/vl/m5blvl8u1xrfdigr0ay45_ps3q8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si trabaja con ensamblajes de reflexión y desea obtener todos los tipos, puede resultar que no todos los tipos puedan obtener su método GetTypes. Un ensamblado tiene una clase que hereda de otra clase que está en un ensamblaje que no está cargado.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> IEnumerable <span class="hljs-title">GetTypesSafe</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Assembly assembly</span>)</span> <font></font>
{ <font></font>
    <span class="hljs-keyword">try</span> <font></font>
    { <font></font>
        <span class="hljs-keyword">return</span> assembly.GetTypes(); <font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span> (ReflectionTypeLoadException e) <font></font>
   { <font></font>
        <span class="hljs-keyword">return</span> e.Types.Where(x =&gt; x != <span class="hljs-literal">null</span>); <font></font>
    } <font></font>
}<font></font>
<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, el problema será que se lanzará una ReflectionTypeLoadException. </font><font style="vertical-align: inherit;">En el interior </font></font><code>ReflectionTypeLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay una propiedad en la que hay esos tipos que aún lograron cargarse. </font><font style="vertical-align: inherit;">No todas las bibliotecas populares tienen esto en cuenta. </font><font style="vertical-align: inherit;">AutoMapper, al menos una de sus versiones, si se enfrenta a ReflectionTypeLoadException, simplemente se cayó, en lugar de ir y elegir los tipos desde el interior de la excepción.</font></font><a name="name"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nombramiento fuerte</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensamblados con nombre seguro</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Hablemos sobre las causas de la carga de ensamblados estrictos, este es el nombre Fuerte. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nombre seguro es la firma del ensamblado por parte de una clave privada que utiliza cifrado asimétrico. PublicKeyToken es el hash de clave pública de este ensamblado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Strong Naming le permite distinguir entre diferentes ensamblados que tienen el mismo nombre. Por ejemplo, MyUtils no es un nombre único, puede haber varios ensamblados con ese nombre, pero si firma el nombre Strong, tendrán diferentes PublicKeyToken y podemos distinguirlos de esta manera. Se requiere un nombre seguro para algunos escenarios de carga de ensamblaje.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, para instalar un ensamblaje en la Caché de ensamblados global o para descargar varias versiones de lado a lado a la vez. </font><font style="vertical-align: inherit;">Lo que es más importante, los conjuntos con nombre seguro solo pueden hacer referencia a otros conjuntos con nombre seguro. </font><font style="vertical-align: inherit;">Dado que algunos usuarios desean firmar sus compilaciones con el nombre Strong, los desarrolladores de la biblioteca también firman sus bibliotecas, para que sea más fácil para los usuarios instalarlas, de modo que los usuarios no tengan que volver a firmar estas bibliotecas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nombre fuerte: ¿Legado?</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nomenclatura fuerte y bibliotecas .NET</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Microsoft dice explícitamente en MSDN que no debe usar un nombre fuerte con fines de seguridad, que solo proporcionan para distinguir diferentes ensamblados con el mismo nombre. La clave de ensamblaje no se puede cambiar de ninguna manera; si la cambió, interrumpirá las redirecciones a todos sus usuarios. Si tiene una parte privada de la clave para el nombre Strong filtrada al acceso público, entonces no puede retirar esta firma de ninguna manera. El formato de archivo SNK en el que se encuentra el nombre seguro no ofrece esa oportunidad, y otros formatos para almacenar claves al menos contienen un enlace a la Lista de revocación de certificados CRL, por lo que se puede entender que este certificado ya no es válido. No hay nada de eso en SNK.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La guía de código abierto tiene las siguientes recomendaciones. En primer lugar, adicionalmente por razones de seguridad, use otras tecnologías. En segundo lugar, si tiene una biblioteca de código abierto, generalmente se sugiere que confirme la parte privada de la clave en el repositorio, para que sea más fácil para las personas bifurcar su biblioteca, reconstruirla y ponerla en una aplicación lista para usar. En tercer lugar, nunca cambie el nombre de Strong. Demasiado destructivo. A pesar de que es demasiado destructivo y está escrito al respecto en la guía de código abierto, Microsoft a veces tiene problemas con sus propias bibliotecas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ue/kg/l3/uekgl3iwrexq7ejjbabccq4y4p4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay una biblioteca llamada System.Reactive. </font><font style="vertical-align: inherit;">Anteriormente, estos eran varios paquetes NuGet, uno de ellos es Rx-Linq. </font><font style="vertical-align: inherit;">Esto es solo un ejemplo, lo mismo para el resto de los paquetes. </font><font style="vertical-align: inherit;">En la segunda versión, se firmó con una clave de Microsoft. </font><font style="vertical-align: inherit;">En la tercera versión, se mudó al repositorio en el proyecto </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/dotnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y comenzó a tener una firma de .NET Foundation. </font><font style="vertical-align: inherit;">La biblioteca, de hecho, ha cambiado el nombre de Strong. </font><font style="vertical-align: inherit;">Se cambió el nombre del paquete NuGet, pero el ensamblado se llama dentro exactamente igual que antes. </font><font style="vertical-align: inherit;">¿Cómo redirigir de la segunda versión a la tercera? </font><font style="vertical-align: inherit;">Esta redirección no se puede hacer.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Validación de nombre fuerte</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cómo: Deshabilitar la función de omisión de nombre seguro</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro argumento de que el nombre Strong ya es algo del pasado y sigue siendo puramente formal es que no están validados. Tenemos un ensamblado firmado y queremos corregir algún tipo de error, pero no tenemos acceso a las fuentes. Podemos tomar dnSpy: esta es una utilidad que le permite descompilar y reparar ensamblajes ya compilados. Todo funcionará para nosotros. Porque de manera predeterminada, la omisión de validación de nombre seguro está habilitada, es decir, solo verifica que PublicKeyToken sea igual y no se verifica la integridad de la firma. Puede haber estudios ambientales en los que la firma aún se verifique, y aquí un ejemplo vívido es IIS. La integridad de la firma se verifica en IIS (el bypass de validación de nombre seguro está deshabilitado de forma predeterminada), y todo se romperá si editamos el ensamblado firmado. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adición:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede deshabilitar la verificación de firma para el ensamblado mediante </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el signo público.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Con él, solo se utiliza la clave pública para la firma, lo que garantiza la seguridad del nombre del ensamblado. Las claves públicas utilizadas por Microsoft se publican </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Rider, el signo público se puede habilitar en las propiedades del proyecto. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vl/_j/ct/vl_jctjjgui-mbcgo5uyzd26lrc.png"><br>
<br>
<img src="https://habrastorage.org/webt/ni/if/hp/niifhpriuvymkfhz78sdeaigs54.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuándo cambiar las versiones de ensamblaje de archivos</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La guía de código abierto también ofrece algunas políticas de control de versiones, cuyo objetivo es reducir la cantidad de redireccionamientos y cambios de enlace necesarios para los usuarios en NET Framework. Esta política de versiones es que no debemos cambiar la versión de ensamblaje constantemente. Esto, por supuesto, puede generar problemas con la instalación en el GAC, por lo que la imagen nativa instalada puede no corresponder al ensamblado y tendrá que realizar la compilación JIT nuevamente, pero, en mi opinión, esto es menos malo que los problemas con el control de versiones. En el caso de CrossGen, los ensamblajes nativos no se instalan globalmente, no habrá problemas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, el paquete NuGet Newtonsoft.Json tiene varias versiones: 12.0.1, 12.0.2, etc. Todos estos paquetes tienen un ensamblaje con la versión 12.0.0.0. </font><font style="vertical-align: inherit;">La recomendación es que la versión de ensamblaje se actualice cuando cambie una versión principal del paquete NuGet.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomendaciones</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Siga los consejos para .NET Framework: genere redireccionamientos manualmente e intente usar la misma versión de dependencias en todos los proyectos de su solución. </font><font style="vertical-align: inherit;">Esto debería minimizar significativamente la cantidad de redireccionamientos. </font><font style="vertical-align: inherit;">Necesita nombres seguros solo si tiene un escenario de carga de compilación específico donde es necesario, o si está desarrollando una biblioteca y desea simplificar la vida de los usuarios que realmente necesitan nombres fuertes. </font><font style="vertical-align: inherit;">No cambie el nombre fuerte.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estándar .NET</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pasamos a .NET Standard. Está bastante relacionado con la versión hell en .NET Framework. .NET Standard es una herramienta para escribir bibliotecas que son compatibles con diversas implementaciones de la plataforma .NET. Las implementaciones se refieren a .NET Framework, .NET Core, Mono, Unity y Xamarin. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hk/-a/-u/hk-a-u16d-oitjurhvta7lhafdi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Enlace a la documentación</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es la tabla de soporte de .NET Standard para varias versiones de diferentes versiones de tiempos de ejecución. Y aquí podemos ver que .NET Framework de ninguna manera es compatible con .NET Standard versión 2.1. El lanzamiento de .NET Framework, que admitirá .NET Standard 2.1 y versiones posteriores, aún no está planeado. Si está desarrollando una biblioteca y desea que funcione para los usuarios en .NET Framework, deberá tener un objetivo para .NET Standard 2.0. Además del hecho de que .NET Framework no admite la última versión de .NET Standard, prestemos atención al asterisco. .NET Framework 4.6.1 es compatible con .NET Standard 2.0, pero con un asterisco. Hay una nota al pie de página directamente en la documentación, ¿de dónde saqué esta tabla?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ay/mq/yu/aymqyunvnqjivv13dpqkrzvac6i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere un proyecto de ejemplo. Una aplicación en .NET Framework que tiene una dependencia dirigida al estándar .NET. Algo así: ConsoleApp y ClassLibrary. Target Library .NET Standard. Cuando organicemos este proyecto, será así en nuestro BIN. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/62/og/fh62og_vou9gzibnv5gdd2mp_uk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tendremos cien DLL allí, de los cuales solo uno está relacionado con la aplicación, todo lo demás vino para admitir el estándar .NET. El hecho es que .NET Standard 2.0 apareció más tarde que .NET Framework 4.6.1, pero al mismo tiempo resultó ser compatible con API, y los desarrolladores decidieron agregar compatibilidad con Standard 2.0 a .NET 4.6.1. No lo hicimos de forma nativa (por inclusión </font></font><code>netstandard.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el tiempo de ejecución en sí), sino de tal manera que .NET Standard * .dll y todas las demás fachadas de ensamblaje se colocan directamente en BIN.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/af/15/am/af15amgkrw698xqylhfwemd67uy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si observamos las dependencias de la versión de .NET Framework a la que nos dirigimos y la cantidad de bibliotecas que cayeron en el BIN, veremos que no hay tantas en 4.7.1, y desde 4.7.2 no hay bibliotecas adicionales, y .NET Estándar es compatible allí de forma nativa. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rf/wu/va/rfwuvalfp3bi6zijyw5kjz-wjva.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es un tweet de uno de los desarrolladores de .NET, que describe este problema y recomienda usar .NET Framework versión 4.7.2 si tenemos bibliotecas .NET Standard. </font><font style="vertical-align: inherit;">Ni siquiera con la versión 2.0 aquí, sino con la versión 1.5.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomendaciones</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si es posible, eleve el Marco de destino en su proyecto al menos a 4.7.1, preferiblemente 4.7.2. </font><font style="vertical-align: inherit;">Si está desarrollando una biblioteca para facilitar la vida de los usuarios de la biblioteca, cree un Target separado para .NET Framework, evitará una gran cantidad de dlls que pueden entrar en conflicto con algo.</font></font><a name="dotnet"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comencemos con una teoría general. </font><font style="vertical-align: inherit;">Discutiremos cómo lanzamos JetBrains Rider en .NET Core, y por qué deberíamos hablar sobre eso. </font><font style="vertical-align: inherit;">Rider es un proyecto muy grande, tiene una gran solución empresarial con una gran cantidad de proyectos diferentes, un complejo sistema de dependencias, no puede simplemente tomarlo y migrar a otro tiempo de ejecución al mismo tiempo. </font><font style="vertical-align: inherit;">Para hacer esto, tenemos que usar algunos hacks, que también analizamos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplicación .NET Core</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cómo es una aplicación típica de .NET Core? Depende de cómo se implemente exactamente, a qué se destinará en última instancia. Podemos tener varios escenarios. El primero es una implementación dependiente de Framework. Esto es lo mismo que en .NET Framework cuando la aplicación usa el tiempo de ejecución preinstalado en la computadora. Puede ser una implementación autónoma, esto es cuando la aplicación lleva un tiempo de ejecución. Y puede haber una implementación de un solo archivo, esto es cuando obtenemos un archivo exe, pero en el caso de .NET Core dentro de este archivo exe hay un artefacto de aplicación autónoma, este es un archivo autoextraíble. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/yi/3c/hxyi3c3yxhavujn9ljcmtxkuvj0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solo consideraremos la implementación dependiente de Framework. Tenemos un dll con la aplicación, hay dos archivos de configuración, el primero de los cuales es obligatorio, este </font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font><code>deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Comenzando con .NET Core 3.0, se genera un archivo exe que es necesario para que la aplicación sea más conveniente de ejecutar, de modo que no necesite ingresar el comando .NET si estamos en Windows. </font><font style="vertical-align: inherit;">Las dependencias se incluyen en este artefacto, comenzando con .NET Core 3.0, en .NET Core 2.1 necesita publicar o usar otra propiedad </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><a name="config"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Marcos compartidos, </font></font><code>.runtimeconfig.json</code></h3><br>
<br>
<img src="https://habrastorage.org/webt/cc/a5/ab/cca5ab5zhb3v6b1itc9jjbsiwje.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contiene la configuración de tiempo de ejecución necesaria para ejecutarlo. Indica en qué marco compartido se iniciará la aplicación, y se ve así. Indicamos que la aplicación se ejecutará en "Microsoft.NETCore.App" versión 3.0.0, puede haber otro Marco compartido. Otras configuraciones también pueden estar aquí. Por ejemplo, puede habilitar el servidor Recolector de basura. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c5/un/ic/c5unicttj2dp5ol0jiewknhb48i.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generado durante el montaje del proyecto. Y si queremos incluir el servidor GC, entonces tenemos que modificar de alguna manera este archivo por adelantado, incluso antes de armar el proyecto, o agregarlo a mano. Puede agregar su configuración aquí de esta manera. Podemos incluir propiedades en </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, si dicha propiedad es proporcionada por desarrolladores de .NET, o si no se proporciona la propiedad, podemos crear un archivo llamado</font></font><code>runtimeconfig.template.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y escriba la configuración necesaria aquí. Durante el ensamblaje, se agregarán otras configuraciones necesarias a esta plantilla, por ejemplo, el mismo Marco compartido. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/bu/e9/rlbue9y7cikkyzwenefcu2rdxy8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Shared Framework es un conjunto de tiempo de ejecución y bibliotecas. De hecho, lo mismo que el tiempo de ejecución de .NET Framework, que solía instalarse una vez en la máquina y para todos era una versión. Shared Framework y, a diferencia de un solo tiempo de ejecución de .NET Framework, se puede versionar, diferentes aplicaciones pueden usar diferentes versiones de tiempos de ejecución instalados. También se puede heredar Framework compartido. El Marco compartido en sí se puede ver en las ubicaciones del disco que generalmente están instaladas en el sistema.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nc/df/7i/ncdf7ioj8afrolkvnlouh77jiaq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existen varios marcos compartidos estándar, por ejemplo, Microsoft.NETCore.App, que ejecuta aplicaciones de consola convencionales, AspNetCore.App, para aplicaciones web, y WindowsDesktop.App, el nuevo Marco compartido en .NET Core 3, que ejecuta aplicaciones de escritorio. en Windows Forms y WPF. Los dos últimos Shared Framework esencialmente complementan el primero necesario para las aplicaciones de consola, es decir, no tienen un tiempo de ejecución completamente nuevo, sino que simplemente complementan el existente con las bibliotecas necesarias. Parece que esta herencia también está en los directorios de Shared Framework </font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en los que se especifica el Shared Framework base.</font></font><a name="man"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manifiesto de dependencia ( </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/sc/qv/qbscqv1sh6jb_r19ps_qrusogfi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sondeo predeterminado - .NET Core El</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
segundo archivo de configuración es este </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este archivo contiene una descripción de todas las dependencias de la aplicación o el Marco compartido, o la biblioteca, las bibliotecas </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">también lo tienen. Contiene todas las dependencias, incluidas las transitivas. Y el comportamiento del tiempo de ejecución de .NET Core difiere dependiendo de si </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la aplicación lo tiene o no. De lo </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contrario, la aplicación podrá cargar todos los ensamblados que se encuentran en su Marco compartido o en su directorio BIN. Si lo hay </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, entonces la validación está habilitada. Si uno de los ensamblados que figuran en la lista </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no lo está, la aplicación simplemente no se iniciará. Verá el error presentado anteriormente. Si la aplicación intenta cargar algún ensamblaje en tiempo de ejecución, que</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si, por ejemplo, utilizando métodos de carga de ensamblaje o durante el proceso de resolución de ensamblajes, verá un error muy similar a la carga de ensamblaje estricto.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jinete de Jetbrains</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rider es un .NET IDE. No todos saben que Rider es un IDE que consiste en una interfaz basada en IntelliJ IDEA y escrita en Java y Kotlin, y un backend. El backend es esencialmente R #, que puede comunicarse con IntelliJ IDEA. Este backend es una aplicación multiplataforma .NET ahora. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿A dónde corre? Windows usa .NET Framework, que está instalado en la computadora del usuario. En otros sistemas de información, en Linux y Mac, se usa Mono. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta no es una solución ideal cuando hay diferentes tiempos de ejecución en todas partes, y quiero pasar al siguiente estado para que Rider se ejecute en .NET Core. Para mejorar el rendimiento, porque en .NET Core todas las características más recientes están asociadas con esto. Para reducir el consumo de memoria. Ahora hay un problema con el funcionamiento de Mono con la memoria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cambiar a .NET Core le permitirá abandonar las tecnologías heredadas y no compatibles y le permitirá corregir algunas soluciones a los problemas que se encontraron en tiempo de ejecución. </font><font style="vertical-align: inherit;">Cambiar a .NET Core le permitirá controlar la versión del tiempo de ejecución, es decir, Rider ya no se ejecutará en .NET Framework que está instalado en la computadora del usuario, sino en una versión específica de .NET Core, que puede prohibirse, en forma de una implementación autónoma. </font><font style="vertical-align: inherit;">La transición a .NET Core eventualmente permitirá el uso de nuevas API que se importan específicamente en Core. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, el objetivo es lanzar un prototipo, lanzarlo, solo para comprobar cómo funcionará, cuáles son los posibles puntos de falla, qué componentes tendrán que reescribirse nuevamente, lo que requerirá un procesamiento global.</font></font><br>
<br>
<a name="rider"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Características que dificultan la traducción de Rider a .NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visual Studio, incluso si R # no está instalado, se </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloquea por</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> falta </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">de memoria en soluciones grandes, dentro de las cuales hay proyectos con SDK-style * .csproj</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">SDK-style * .csproj es una de las principales condiciones para una reubicación completa de .NET Core. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto es un problema porque Rider se basa en R #, viven en el mismo repositorio, los desarrolladores de R # quieren usar Visual Studio para desarrollar su propio producto en su producto para que sea un alimento. </font><font style="vertical-align: inherit;">En R # hay bibliotecas específicas de enlaces para el marco con el que debe hacer algo. </font><font style="vertical-align: inherit;">En Windows, podemos usar el Framework para aplicaciones de escritorio, y en Linux y Mac, Mock ya se usa para bibliotecas de Windows con una funcionalidad mínima.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decisión</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Decidimos quedarnos con los viejos por ahora </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ensamblarlos bajo el Framework completo, pero como los ensamblajes de Framework y Core son compatibles con binarios, ejecútelos en Core. </font><font style="vertical-align: inherit;">No utilizamos funciones incompatibles, agregamos todos los archivos de configuración necesarios manualmente y descargamos versiones especiales de dependencias para .NET Core, si las hay.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿A qué hacks has tenido que ir?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un truco: queremos llamar a un método que solo está disponible en Framework, por ejemplo, este método es necesario en R #, pero no en Core. </font><font style="vertical-align: inherit;">El problema es que si no hay un método, el método que lo llama durante la compilación JIT caerá antes </font></font><code>MissingMethodException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es decir, un método que no existe ha arruinado el método que lo llama.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>(<span class="hljs-params"></span>)</span> { 
  <span class="hljs-keyword">if</span> (NetFramework) <font></font>
     CallNETFrameworkOnlyMethod();<font></font>
<font></font>
  ... <font></font>
} <font></font>
[<span class="hljs-meta">MethodImpl(MethodImplOptions.NoInlining)</span>] 
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallNETFrameworkOnlyMethod</span>(<span class="hljs-params"></span>)</span> { <font></font>
  NETFrameworkOnlyMethod(); <font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La solución está aquí: hacemos llamadas a métodos incompatibles en métodos separados. Hay un problema más: dicho método puede volverse en línea, por lo tanto, lo marcamos con un atributo </font></font><code>NoInlining</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hack número dos: necesitamos poder cargar ensamblajes en rutas relativas. Tenemos un ensamblaje para Framework, hay una versión especial para .NET Core. ¿Cómo descargamos la versión .NET Core para .NET Core? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qm/zm/w7/qmzmw79gtllee8uyswgrn0oqnum.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos ayudarán </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Veamos la </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biblioteca System.Diagnostics.PerformanceCounter. Tal biblioteca es notable en términos de su</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tiene una sección de tiempo de ejecución, en la que se indica una versión de la biblioteca con su ruta relativa. Esta biblioteca, el ensamblado se cargará en todos los tiempos de ejecución, y solo arroja las ejecuciones. Si, por ejemplo, se carga en Linux, PerformanceCounter no funciona en el diseño en Linux, y una excepción PlatformNotSupportedException vuela desde allí. También hay </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una sección runtimeTargets </font><font style="vertical-align: inherit;">en esto </font><font style="vertical-align: inherit;">y aquí ya se indica la versión de este ensamblado específicamente para Windows, donde PerformanceCounter debería funcionar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si tomamos la sección de tiempo de ejecución y escribimos en ella la ruta relativa a la biblioteca que queremos cargar, esto no nos ayudará. La sección de tiempo de ejecución en realidad establece la ruta relativa dentro del paquete NuGet, y no en relación con el BIN. Si buscamos este ensamblado en BIN, solo se usará el nombre del archivo desde allí. La sección runtimeTargets ya contiene una ruta relativa honesta, una ruta honesta relativa a BIN. Prescribiremos una ruta relativa para nuestros ensamblados en la sección runtimeTargets. En lugar del identificador de tiempo de ejecución, que es "ganar" aquí, podemos tomar otro que nos guste. Por ejemplo, escribiremos el identificador de tiempo de ejecución "any", y este ensamblado se cargará generalmente en todas las plataformas. O escribiremos "unix", y arrancará en Linux, y en Mac, y así sucesivamente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Siguiente truco: queremos descargar en Linux y en Mac Mock para construir WindowsBase. El problema es que el ensamblado llamado WindowsBase ya está presente en Shared Framework </font></font><code>Microsoft.NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, incluso si no estamos en Windows. En el Marco compartido de Windows, </font></font><code>Microsoft.WindowsDesktop.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowsBase redefine la versión en la que se encuentra </font></font><code>NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Miremos </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estos Framework, más precisamente en aquellas secciones que describen WindowsBase. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gc/ox/f3/gcoxf3q7mbfm_a9hzmcujfin5zc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí está la diferencia: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5q/pz/wq/5qpzwq-n21m38b_0xedi9txpwoc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
si alguna biblioteca entra en conflicto y está presente en varias </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, entonces se selecciona el máximo de ellas para el par formado por </font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La guía .NET dice que </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo es necesario mostrarlo en el Explorador de Windows, pero no es así, cae en</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este es el único caso que conozco cuando la versión prescrita </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, realmente se utilizan. En todos los demás casos, vi un comportamiento que, independientemente de las versiones </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escritas, el ensamblado continuaría cargándose de todos modos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/re/j8/bwrej8fa8_gyuyvcjnt3ixvljce.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuarto truco. Tarea: tenemos un archivo .deps.json para los dos hacks anteriores, y lo necesitamos solo para dependencias específicas. Dado que se </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generan en modo semi-manual, tenemos un script que, de acuerdo con alguna descripción de lo que debería llegar allí, lo genera durante la compilación, queremos mantener esto lo más </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mínimo posible para que podamos entender lo </font><font style="vertical-align: inherit;">que contiene </font><font style="vertical-align: inherit;">. Queremos deshabilitar la validación y permitir la descarga de ensamblajes que están en el BIN pero que no se describen en </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solución: habilite la configuración personalizada en runtimeconfig. </font><font style="vertical-align: inherit;">Esta configuración es realmente necesaria para la compatibilidad con versiones anteriores de .NET Core 1.0.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomendaciones</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, </font></font><code>.runtime.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en .NET Core, estos son una especie de análogos </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le permite hacer lo mismo, por ejemplo, cargar ensamblajes de manera relativa. </font><font style="vertical-align: inherit;">Utilizando </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, reescribiéndolo manualmente, puede personalizar la carga de ensamblados en .NET Core, si tiene un escenario muy complejo.</font></font><a name="load"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depurar descargas de ensamblados</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hablé sobre algunos tipos de problemas, por lo que debe ser capaz de depurar problemas al cargar ensamblajes. </font><font style="vertical-align: inherit;">¿Qué puede ayudar con esto? </font><font style="vertical-align: inherit;">Primero, los tiempos de ejecución escriben registros sobre cómo cargan los ensamblados. </font><font style="vertical-align: inherit;">En segundo lugar, puedes mirar más de cerca las ejecuciones que vuelan hacia ti. </font><font style="vertical-align: inherit;">También puede centrarse en eventos de tiempo de ejecución.</font></font><a name="fusion"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registros de fusión</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/jl/4v/be/jl4vbeqsyjzmab2rx0xvdg-lpi4.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volver a lo básico: uso del visor de registro de Fusion para depurar errores oscuros </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusion</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
El mecanismo para cargar ensamblados en .NET Framework se llama Fusion y sabe cómo registrar lo que hizo en el disco. Para habilitar el registro, debe agregar configuraciones especiales al registro. Esto no es muy conveniente, por lo que tiene sentido usar utilidades, a saber, Fusion Log Viewer y Fusion ++. Fusion Log Viewer es una utilidad estándar que viene con Visual Studio y se puede iniciar desde la línea de comandos de Visual Studio, Visual Studio Developer Command Prompt. Fusion ++ es un análogo de código abierto de esta herramienta con una interfaz más agradable.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ou/9h/bt/ou9hbtdgx1yjp6rjjdm3q61efpu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fusion Log Viewer se ve así. Esto es peor que WinDbg porque esta ventana ni siquiera se estira. Sin embargo, puede perforar las marcas de verificación aquí, aunque no siempre es obvio qué conjunto de marcas de verificación es correcto. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gu/h2/by/guh2byfmgazm8yvbxfa_jhf25wo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fusion ++ tiene un botón "Iniciar registro", y luego aparece el botón "Detener registro". En él, puede ver todos los registros sobre la carga de ensamblajes, leer los registros sobre lo que estaba sucediendo exactamente. Estos registros se parecen a esto de una manera concisa.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zf/ep/5m/zfep5myuovdov4t7mmtw4czhwqc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es una ejecución de la carga estricta del ensamblado. </font><font style="vertical-align: inherit;">Si miramos los registros de Fusion, veremos que necesitábamos descargar la versión 9.0.0.0 después de procesar todas las configuraciones. </font><font style="vertical-align: inherit;">Encontramos un archivo en el que se sospecha que tenemos el ensamblaje que necesitamos. </font><font style="vertical-align: inherit;">Vimos que la versión 6.0.0.0 está en este archivo. </font><font style="vertical-align: inherit;">Tenemos una advertencia de que comparamos los nombres completos de los ensamblados, y difieren en la versión principal. </font><font style="vertical-align: inherit;">Y luego se produjo un error: la versión no coincide.</font></font><a name="events"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eventos de tiempo de ejecución</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/pu/np/bn/punpbnrdvfv_mm5bpweej75ofq8.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registro de eventos de tiempo de ejecución</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En Mono, puede habilitar el registro utilizando variables de entorno, y los registros eventualmente se escribirán en </font></font><code>stdout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. No es tan conveniente, pero la solución está funcionando. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rj/vv/g9/rjvvg9dfv0ji5sbxm_crgu3ok0a.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sondeo predeterminado: </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentación de </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">.NET Core </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">/ documentos de diseño / rastreo de host</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
. .NET Core también tiene una variable de entorno especial </font></font><code>COREHOST_TRACE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que incluye el inicio de sesión </font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Con .NET Core 3.0, puede escribir registros en un archivo especificando la ruta en una variable </font></font><code>COREHOST_TRACEFILE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<img src="https://habrastorage.org/webt/eo/b5/yf/eob5yf90z7cgilees68uxtrhw0w.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un evento que se dispara cuando los ensamblajes no se cargan. Se trata de un evento </font></font><code>AssembleResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Hay un segundo evento útil, este </font></font><code>FirstChanceException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Puede suscribirse y obtener un error sobre la carga de ensamblajes, incluso si alguien escribió try..catch y se perdió todas las ejecuciones en el lugar donde</font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ocurrió. </font><font style="vertical-align: inherit;">Si la aplicación ya se ha compilado, puede iniciarla </font></font><code>perfview</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y puede monitorear las ejecuciones de .NET, y encontrar las relacionadas con la descarga de archivos allí.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomendaciones</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transfiera el trabajo a herramientas, a herramientas de desarrollo, a un IDE, a MSBuild, que le permite generar redireccionamientos. </font><font style="vertical-align: inherit;">Puede cambiar a .NET Core, luego olvidará lo que es la carga estricta de ensamblajes y podrá usar la nueva API tal como queremos lograrla en Rider. </font><font style="vertical-align: inherit;">Si conecta la biblioteca .NET Standard, aumente la versión de destino de .NET Framework al menos a 4.7.1. </font><font style="vertical-align: inherit;">Si pareces estar en una situación desesperada, busca hacks, úsalos o inventa tus propios hacks para situaciones desesperadas. </font><font style="vertical-align: inherit;">Y armarse con herramientas de depuración. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le recomiendo que lea los siguientes enlaces:</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">.NET Guide</a>;</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">     .NET Core</a>.</li>
</ul><br>
<br>
<blockquote>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DotNext 2020 Piter</a> .       ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> 8   JUG Ru Group</a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es499824/index.html">El resumen de eventos para reclutadores de recursos humanos y TI en mayo de 2020</a></li>
<li><a href="../es499826/index.html">Presión arterial distribuida</a></li>
<li><a href="../es499832/index.html">¿Cómo organizar de forma rápida y segura el trabajo remoto de los empleados? Hablamos de diferentes enfoques: con VDI y no solo</a></li>
<li><a href="../es499834/index.html">Conoce el aritmómetro Felix</a></li>
<li><a href="../es499836/index.html">Udalenka vs. oficina para el equipo de desarrollo</a></li>
<li><a href="../es499842/index.html">¿Por qué la gente vuelve a aprender?</a></li>
<li><a href="../es499846/index.html">Cuándo comenzará a funcionar la recolección de basura por separado y por qué es necesaria la videovigilancia de los sitios para contenedores de basura</a></li>
<li><a href="../es499850/index.html">Cómo analizar competidores y establecer una estrategia digital en 40 minutos</a></li>
<li><a href="../es499852/index.html">Documentación en inglés para Angular</a></li>
<li><a href="../es499854/index.html">Apache Bigtop y la elección de la distribución de Hadoop hoy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>