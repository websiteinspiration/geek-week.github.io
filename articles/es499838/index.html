<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèΩ üëµ üë©üèΩ‚ÄçüöÄ .NET: tratamiento de dependencia üõåüèº üçú ‚¨úÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øQui√©n no ha encontrado problemas debido a la redirecci√≥n de ensamblado? Lo m√°s probable es que todos los que desarrollaron una aplicaci√≥n relativamen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>.NET: tratamiento de dependencia</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/499838/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQui√©n no ha encontrado problemas debido a la redirecci√≥n de ensamblado? </font><font style="vertical-align: inherit;">Lo m√°s probable es que todos los que desarrollaron una aplicaci√≥n relativamente grande tarde o temprano se enfrenten a este problema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora trabajo en JetBrains, en el proyecto JetBrains Rider, y estoy involucrado en la tarea de migrar Rider a .NET Core. </font><font style="vertical-align: inherit;">Anteriormente particip√≥ en infraestructura compartida en Circuit, una plataforma de alojamiento de aplicaciones basada en la nube. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/je/f5/e-/jef5e-nc0okqm_ssla0qhniugio.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debajo de la escena se encuentra la transcripci√≥n de mi informe de la conferencia DotNext 2019 de Mosc√∫, donde habl√© sobre las dificultades al trabajar con asambleas en .NET y mostr√© con ejemplos pr√°cticos lo que sucede y c√≥mo lidiar con √©l.</font></font><a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/fMlTLw1agE0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En todos los proyectos donde trabaj√© como desarrollador de .NET, tuve que lidiar con varios problemas con la conexi√≥n de dependencias y la carga de ensamblajes. </font><font style="vertical-align: inherit;">Hablaremos de esto.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estructura del poste:</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problemas de dependencia</font></font></b></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estricto equipo de carga</font></font></b></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redireccionamientos vinculantes</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nombramiento fuerte</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core</font></font></a></b> <br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Marcos compartidos, .runtimeconfig.json</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manifiesto de dependencia (.deps.json)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacks para ejecutar JetBrains Rider en Core</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depurar descargas de ensamblados</font></font></a> </b><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registros de fusi√≥n</font></font></a> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eventos de tiempo de ejecuci√≥n</font></font></a></li>
</ul><br>
</li>
</ol><br>
<a name="problems"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCu√°les son algunos problemas de dependencia?</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando comenzaron a desarrollar .NET Framework a principios de la d√©cada de 2000, el problema del infierno de dependencias ya era conocido, cuando en todas las bibliotecas los desarrolladores permiten cambios importantes, y estas bibliotecas se vuelven incompatibles para su uso con c√≥digo ya compilado. </font><font style="vertical-align: inherit;">¬øC√≥mo resolver tal problema? </font><font style="vertical-align: inherit;">La primera soluci√≥n es obvia. </font><font style="vertical-align: inherit;">Mantenga siempre la compatibilidad con versiones anteriores. </font><font style="vertical-align: inherit;">Por supuesto, esto no es muy realista, porque romper el cambio es muy f√°cil de incluir en el c√≥digo. </font><font style="vertical-align: inherit;">Por ejemplo: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/un/gj/tv/ungjtvaiofi7qkm6a4if5cpgh10.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cambios de √∫ltima hora y bibliotecas .NET</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es un ejemplo espec√≠fico de .NET. Tenemos un m√©todo y decidimos agregar un par√°metro con un valor predeterminado. El c√≥digo continuar√° compil√°ndose si lo reensamblamos, pero binario ser√°n dos m√©todos completamente diferentes: un m√©todo tiene cero argumentos, el segundo m√©todo tiene un argumento. Si el desarrollador dentro de la dependencia rompi√≥ la compatibilidad con versiones anteriores de esta manera, entonces no podremos usar el c√≥digo que se compil√≥ con esta dependencia en la versi√≥n anterior.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La segunda soluci√≥n a los problemas de dependencia es agregar versiones de bibliotecas, ensamblajes, cualquier cosa. Puede haber diferentes reglas de versiones, el punto es que de alguna manera podemos distinguir diferentes versiones de la misma biblioteca entre s√≠, y usted puede entender si la actualizaci√≥n se romper√° o no. Desafortunadamente, tan pronto como presentamos las versiones, aparece un tipo diferente de problema. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/xc/wu/vgxcwufmesq4jly-ecfrh5p-ko8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La versi√≥n hell es la incapacidad de usar una dependencia que sea compatible con binarios, pero al mismo tiempo tiene una versi√≥n que no se ajusta al tiempo de ejecuci√≥n u otro componente que verifica estas versiones. En .NET, una manifestaci√≥n t√≠pica de la versi√≥n hell es FileLoadException, aunque el archivo se encuentra en el disco, pero por alguna raz√≥n no est√° cargado con tiempo de ejecuci√≥n.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qy/wg/5m/qywg5mjhpkuogm6yez7uhnxitji.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En .NET, los ensamblados tienen muchas versiones diferentes: intentaron corregir los infiernos de versiones de varias maneras y ver qu√© sucedi√≥. Tenemos un paquete </font></font><code>System.Collections.Immutable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mucha gente lo conoce. Tiene la √∫ltima versi√≥n del paquete NuGet 1.6.0. Contiene una biblioteca, un ensamblado con la versi√≥n 1.2.4.0. Ha recibido que no tiene una biblioteca de compilaci√≥n versi√≥n 1.2.4.0. ¬øC√≥mo entender que se encuentra en el paquete NuGet 1.6.0? No ser√° f√°cil. Adem√°s de la versi√≥n de ensamblaje, esta biblioteca tiene varias versiones m√°s. Por ejemplo, Versi√≥n de archivo de ensamblaje, Versi√≥n de informaci√≥n de ensamblaje. Este paquete NuGet en realidad contiene tres ensamblajes diferentes con las mismas versiones (para diferentes versiones del est√°ndar .NET). </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentaci√≥n .NET </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opbuild est√°ndar</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se ha escrito mucha documentaci√≥n sobre c√≥mo trabajar con ensamblados en .NET. </font><font style="vertical-align: inherit;">Existe una Gu√≠a .NET para desarrollar aplicaciones modernas para .NET teniendo en cuenta .NET Framework, .NET Standard, .NET Core, c√≥digo abierto y todo lo que puede ser. </font><font style="vertical-align: inherit;">Alrededor del 30% de todo el documento est√° dedicado a cargar ensamblajes. </font><font style="vertical-align: inherit;">Analizaremos problemas espec√≠ficos y ejemplos que puedan surgir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øPor qu√© es todo esto necesario? </font><font style="vertical-align: inherit;">En primer lugar, para evitar pisar un rastrillo. </font><font style="vertical-align: inherit;">En segundo lugar, puede facilitar la vida de los usuarios de sus bibliotecas porque con su biblioteca no tendr√°n los problemas de dependencia a los que est√°n acostumbrados. </font><font style="vertical-align: inherit;">Tambi√©n lo ayudar√° a hacer frente a la migraci√≥n de aplicaciones complejas a .NET Core. </font><font style="vertical-align: inherit;">Y para colmo, puede convertirse en un SRE, este es un ingeniero de redireccionamiento senior (vinculante), al que todos en el equipo vienen y preguntan c√≥mo escribir otra redirecci√≥n.</font></font><a name="assembly"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Montaje estricto Cargando</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La carga estricta del ensamblado es el principal problema que enfrentan los desarrolladores en .NET Framework. </font><font style="vertical-align: inherit;">Se expresa en </font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Antes de continuar con la carga del ensamblaje estricto, perm√≠teme recordarte algunas cosas b√°sicas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando crea una aplicaci√≥n .NET, la salida es un artefacto, que generalmente se encuentra en Bin / Debug o en Bin / Release, y contiene un cierto conjunto de ensamblajes de ensamblaje y archivos de configuraci√≥n. </font><font style="vertical-align: inherit;">Los ensamblajes se referir√°n entre s√≠ por nombre, nombre de ensamblaje. </font><font style="vertical-align: inherit;">Es importante comprender que los enlaces de ensamblaje se encuentran directamente en el ensamblaje que hace referencia a este ensamblaje; no hay archivos de configuraci√≥n m√°gicos donde se escriben las referencias de ensamblaje. </font><font style="vertical-align: inherit;">Aunque le parezca que tales archivos existen. </font><font style="vertical-align: inherit;">Las referencias se encuentran en los propios ensamblados en forma binaria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En .NET, hay un proceso de resoluci√≥n de ensamblaje: esto es cuando la definici√≥n del ensamblado ya se ha convertido en un ensamblaje real, que est√° en el disco o cargado en alg√∫n lugar de la memoria. La resoluci√≥n de ensamblaje se realiza dos veces: en la etapa de compilaci√≥n, cuando tiene referencias en * .csproj, y en tiempo de ejecuci√≥n, cuando tiene referencias dentro de los ensamblajes, y seg√∫n algunas reglas, se convierten en ensamblajes que se pueden descargar. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Nombre simple </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MyAssembly, Version = 6.0.0.0, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Culture = neutral, PublicKeyToken = null </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Nombre </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
seguro Newtonsoft.Json, Version = 6.0.0.0, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Culture = neutral, PublicKeyToken = 30ad4fe6b2a6aeed // PublicKey</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pasemos al problema. Nombre de la asamblea hay dos tipos principales. El primer tipo de nombre de ensamblado es Nombre simple. Son f√°ciles de identificar por el hecho de que tienen PublicKeyToken = null. Hay un nombre Strong, es f√°cil identificarlos por el hecho de que su PublicKeyToken no es nulo, sino que tiene alg√∫n valor. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/40/0v/uf/400vuf0e3w-ykw2fkdx2-ufdutq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pongamos un ejemplo. Tenemos un programa que depende de la biblioteca con las utilidades MyUtils, y la versi√≥n de MyUtils es 9.0.0.0. El mismo programa tiene un enlace a otra biblioteca. Esta biblioteca tambi√©n quiere usar MyUtils, pero la versi√≥n 6.0.0.0. MyUtils versi√≥n 9.0.0.0 y versi√≥n 6.0.0.0 tienen PublicKeyToken = null, es decir, tienen un nombre simple. ¬øQu√© versi√≥n caer√° en el artefacto binario, 6.0.0.0 o 9.0.0.0? Novena versi√≥n. ¬øPuede MyLibrary usar MyUtils versi√≥n 9.0.0.0, que entr√≥ en el artefacto binario?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/js/fs/2x/jsfs2xd1erckl8dkphbrhojfhxk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, puede, porque MyUtils tiene un nombre simple y, en consecuencia, la carga de ensamblaje estricta no existe para √©l. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kz/tn/a6/kztna61effl0kkiuwnkvi1gpad8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro ejemplo. </font><font style="vertical-align: inherit;">En lugar de MyUtils, tenemos una biblioteca completa de NuGet, que tiene un nombre Strong. </font><font style="vertical-align: inherit;">La mayor√≠a de las bibliotecas en NuGet tienen un nombre fuerte.</font></font><br>
<br>
<a name="redirects"></a><img src="https://habrastorage.org/webt/rr/xp/qi/rrxpqilvehdbvemijol2iuutbie.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la etapa de compilaci√≥n, la versi√≥n 9.0.0.0 se copia a BIN, pero en tiempo de ejecuci√≥n obtenemos la famosa </font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para que MyLibrary, que quiere la versi√≥n 6.0.0.0 </font></font><code>Newtonsoft.Json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pueda usar la versi√≥n 9.0.0.0, debe ir y escribir Redireccionamiento de enlace </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redireccionamientos vinculantes</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/lw/d_/yq/lwd_yq2otb7kqsbpkpglszjlr-y.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redirecci√≥n de versiones de ensamblaje</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Establece que un ensamblaje con dicho nombre y publicKeyToken debe redirigirse de un rango de versiones a un rango de versiones. </font><font style="vertical-align: inherit;">Parece ser un registro muy simple, pero sin embargo se encuentra aqu√≠ </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero podr√≠a estar en otros archivos. </font><font style="vertical-align: inherit;">Hay un archivo </font></font><code>machine.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro de .NET Framework, dentro del tiempo de ejecuci√≥n, en el que se define un conjunto est√°ndar de redireccionamientos, que pueden diferir de una versi√≥n a otra de .NET Framework. </font><font style="vertical-align: inherit;">Puede suceder que en 4.7.1 nada funcione para usted, pero en 4.7.2 ya funciona, o viceversa. </font></font><code>.App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debe </font><font style="vertical-align: inherit;">tener en cuenta que los redireccionamientos pueden provenir no solo del suyo </font><font style="vertical-align: inherit;">, y esto debe tenerse en cuenta al depurar.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplificamos la escritura de redireccionamientos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nadie quiere escribir redireccionamientos vinculantes con sus manos. ¬°D√©mosle esta tarea a MSBuild! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pg/qk/ct/pgqkctk1hwcp0lewpamhi5wn35o.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥mo habilitar y deshabilitar la redirecci√≥n autom√°tica de enlaces</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Algunos consejos sobre c√≥mo simplificar el trabajo con la redirecci√≥n de enlaces. Consejo uno: habilite la generaci√≥n autom√°tica de redireccionamiento de enlace en MSBuild. Activado por propiedad en </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Al construir un proyecto, caer√° en un artefacto binario </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que indica redirecciones a versiones de bibliotecas que est√°n en el mismo artefacto. Esto solo funciona para ejecutar aplicaciones, aplicaciones de consola, WinExe. Para las bibliotecas, esto no funciona, porque para las bibliotecas</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la mayor√≠a de las veces simplemente no es relevante, porque es relevante para una aplicaci√≥n que se inicia y carga ensamblajes. Si realiz√≥ una configuraci√≥n para la biblioteca, entonces en la aplicaci√≥n algunas dependencias tambi√©n pueden diferir de las que exist√≠an al construir la biblioteca, y resulta que la configuraci√≥n para la biblioteca no tiene mucho sentido. Sin embargo, a veces para las bibliotecas las configuraciones todav√≠a tienen sentido. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ik/g6/6n/ikg66nyqel3ejmqbln9xb1magyq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La situaci√≥n cuando escribimos pruebas. Las pruebas generalmente se encuentran en ClassLibrary y tambi√©n necesitan redireccionamientos. Los marcos de prueba pueden reconocer que la biblioteca con pruebas tiene una configuraci√≥n dll e intercambiar las redirecciones que se encuentran en ellas por el c√≥digo de las pruebas. Puede generar estos redireccionamientos autom√°ticamente. Si tenemos un formato antiguo</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, no al estilo SDK, puede seguir el camino simple, cambiar el OutputType a Exe y agregar un punto de entrada vac√≠o, esto obligar√° a MSBuild a generar redireccionamientos. Puedes ir hacia otro lado y usar el truco. Puede agregar otra propiedad a </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo que hace que MSBuild considere que para este OutputType todav√≠a necesita generar redireccionamientos de enlace. Este m√©todo, aunque parece un truco, le permitir√° generar redireccionamientos para bibliotecas que no se pueden rehacer en Exe, y para otros tipos de proyectos (excepto pruebas). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para el nuevo formato, los </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">redireccionamientos se generar√°n ellos mismos si usa Microsoft.NET.Test.Sdk moderno.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tercer consejo: no use la generaci√≥n de redireccionamiento de enlace con NuGet. NuGet tiene la capacidad de generar redireccionamiento de enlace para bibliotecas que pasan de paquetes a las √∫ltimas versiones, pero esta no es la mejor opci√≥n. Todos estos redireccionamientos deber√°n agregarse </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y confirmarse, y si genera redireccionamientos utilizando MSBuild, los redireccionamientos se generar√°n durante la compilaci√≥n. Si los cometes, es posible que tengas conflictos de fusi√≥n. Usted mismo puede simplemente olvidar actualizar la redirecci√≥n de enlace en el archivo, y si se generan durante la compilaci√≥n, no lo olvidar√°. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yi/fr/zq/yifrzq4fnvwitenrhkteup1cjfq.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resolver referencia de ensamblaje </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generar redireccionamientos de enlace</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tarea para aquellos que desean comprender mejor c√≥mo funciona la generaci√≥n de redireccionamientos de enlace: descubra c√≥mo funciona, vea esto en el c√≥digo. Vaya al directorio .NET, vaya a todas partes con la propiedad de nombre, que se utiliza para habilitar la generaci√≥n. Este es generalmente un enfoque tan com√∫n, si hay alguna propiedad extra√±a para MSBuild, puede ir y aprovechar su uso. Afortunadamente, la propiedad generalmente se usa en configuraciones XML, y puede encontrar f√°cilmente su uso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si examina lo que hay en estos destinos XML, ver√° que esta propiedad activa dos tareas de MSBuild. Se llama a la primera tarea </font></font><code>ResolveAssemblyReferences</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y genera un conjunto de redireccionamientos que se escriben en los archivos. La segunda tarea </font></font><code>GenerateBindingRedirects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escribe los resultados de la primera tarea en</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Existe una l√≥gica XML que corrige ligeramente el funcionamiento de la primera tarea y elimina algunos redireccionamientos innecesarios, o agrega otros nuevos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternativa a las configuraciones XML</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No siempre es conveniente mantener las redirecciones en la configuraci√≥n XML. </font><font style="vertical-align: inherit;">Es posible que tengamos una situaci√≥n en la que la aplicaci√≥n descarga el complemento, y este complemento utiliza otras bibliotecas que requieren redireccionamientos. </font><font style="vertical-align: inherit;">En este caso, es posible que no conozcamos el conjunto de redireccionamientos que necesitamos o que no queramos generar XML. </font><font style="vertical-align: inherit;">En tal situaci√≥n, podemos crear un AppDomain y, cuando se crea, a√∫n transferirlo a donde se encuentra el XML con las redirecciones necesarias. </font><font style="vertical-align: inherit;">Tambi√©n podemos manejar errores de carga de ensamblajes en tiempo de ejecuci√≥n. </font><font style="vertical-align: inherit;">Rantime .NET brinda esa oportunidad.</font></font><br>
<br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (sender, eventArgs) =&gt; <font></font>
{ <font></font>
   <span class="hljs-keyword">var</span> name = eventArgs.Name; 
   <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
   <font></font>
   <span class="hljs-keyword">return</span> Assembly.LoadFrom(...); <span class="hljs-comment">// PublicKeyToken should be equal</span><font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tiene un evento, se llama </font></font><code>CurrentDomain.AssemblyResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Al suscribirse a este evento, recibiremos errores sobre todas las descargas fallidas de ensamblajes. Obtenemos el nombre del ensamblaje que no se carg√≥, y obtenemos el ensamblaje de ensamblaje que solicit√≥ que se cargara el primer ensamblaje. Aqu√≠ podemos cargar manualmente el ensamblaje desde el lugar correcto, por ejemplo, descartando la versi√≥n, simplemente tom√°ndola del archivo y devolviendo este evento desde el controlador. O devuelva nulo si no tenemos nada que devolver, si no podemos cargar el ensamblado. PublicKeyToken deber√≠a ser el mismo, los ensamblados con diferentes PublicKeyToken de ninguna manera son amigos entre s√≠.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8q/m7/ge/8qm7ge64h4pbldvju9ya91uz8zm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este evento se aplica solo a un dominio de aplicaci√≥n. </font><font style="vertical-align: inherit;">Si nuestro complemento crea un AppDomain dentro de s√≠ mismo, esta redirecci√≥n en tiempo de ejecuci√≥n no funcionar√° en ellos. </font><font style="vertical-align: inherit;">Debe suscribirse de alguna manera a este evento en todos los AppDomain que cre√≥ el complemento. </font><font style="vertical-align: inherit;">Podemos hacer esto usando el AppDomainManager. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AppDomainManager es un ensamblado separado que contiene una clase que implementa una interfaz espec√≠fica, y uno de los m√©todos de esta interfaz le permitir√° inicializar cualquier nuevo AppDomain que se cree en la aplicaci√≥n. </font><font style="vertical-align: inherit;">Una vez que se crea el AppDomain, se llamar√° a este m√©todo. </font><font style="vertical-align: inherit;">En √©l puedes suscribirte a este evento.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estricto montaje de carga y .NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En .NET Core no hay ning√∫n problema llamado "Carga estricta de ensamblados", que se debe al hecho de que los ensamblados firmados requieren exactamente la versi√≥n solicitada. Hay otro requisito. Para todos los ensamblados, independientemente de si est√°n firmados con un nombre seguro o no, se verifica que la versi√≥n que se carg√≥ en tiempo de ejecuci√≥n sea mayor o igual que la anterior. Si estamos en una situaci√≥n de una aplicaci√≥n con complementos, podemos tener una situaci√≥n tal que el complemento se cre√≥, por ejemplo, a partir de una nueva versi√≥n del SDK, y la aplicaci√≥n en la que se descarga utiliza la versi√≥n anterior del SDK hasta ahora, y en lugar de desmoronarse, Tambi√©n podemos suscribirnos a este evento, pero ya en .NET Core, y tambi√©n cargar el ensamblado que tenemos. Podemos escribir este c√≥digo:</font></font><br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (s, eventArgs) =&gt; <font></font>
{ <font></font>
     CheckForRecursion(); <font></font>
     <span class="hljs-keyword">var</span> name = eventArgs.Name;
     <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
    <font></font>
     name.Version = <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <font></font>
     <font></font>
     <span class="hljs-keyword">return</span> Assembly.Load(name); <font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenemos el nombre del ensamblado que no se inici√≥, anulamos la versi√≥n y la llamamos </font></font><code>Assembly.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde la misma versi√≥n. No habr√° recursividad aqu√≠, porque ya verifiqu√© la recursividad. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mt/cs/kr/mtcskrokxuvcn8i4gueywowb3_m.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Era necesario descargar MyUtils versi√≥n 0.0.2.0. En BIN, tenemos MyUtils versi√≥n 0.0.1.0. Realizamos una redirecci√≥n de la versi√≥n 0.0.2.0 a la versi√≥n 0.0. La versi√≥n 0.0.1.0 no se cargar√° con nosotros. Nos saldr√° una salida indicando que no fue posible cargar el ensamblaje con la versi√≥n 0.0.2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16‚Äì1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16-1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) == <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>) <font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Version</span> { 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Build; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Revision; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Major; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Minor; <font></font>
} <font></font>
(<span class="hljs-keyword">ushort</span>) <span class="hljs-number">-1</span> == <span class="hljs-number">65535</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la clase Versi√≥n, no todos los componentes son obligatorios, y en lugar de los componentes opcionales ‚Äì1 se almacenan, pero en alg√∫n lugar del interior, se produce un desbordamiento y se obtienen los 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16‚Äì1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si est√° interesado, puede intentar encontrar exactamente d√≥nde se produce el desbordamiento. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m5/bl/vl/m5blvl8u1xrfdigr0ay45_ps3q8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si trabaja con ensamblajes de reflexi√≥n y desea obtener todos los tipos, puede resultar que no todos los tipos puedan obtener su m√©todo GetTypes. Un ensamblado tiene una clase que hereda de otra clase que est√° en un ensamblaje que no est√° cargado.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> IEnumerable <span class="hljs-title">GetTypesSafe</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Assembly assembly</span>)</span> <font></font>
{ <font></font>
    <span class="hljs-keyword">try</span> <font></font>
    { <font></font>
        <span class="hljs-keyword">return</span> assembly.GetTypes(); <font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span> (ReflectionTypeLoadException e) <font></font>
   { <font></font>
        <span class="hljs-keyword">return</span> e.Types.Where(x =&gt; x != <span class="hljs-literal">null</span>); <font></font>
    } <font></font>
}<font></font>
<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, el problema ser√° que se lanzar√° una ReflectionTypeLoadException. </font><font style="vertical-align: inherit;">En el interior </font></font><code>ReflectionTypeLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay una propiedad en la que hay esos tipos que a√∫n lograron cargarse. </font><font style="vertical-align: inherit;">No todas las bibliotecas populares tienen esto en cuenta. </font><font style="vertical-align: inherit;">AutoMapper, al menos una de sus versiones, si se enfrenta a ReflectionTypeLoadException, simplemente se cay√≥, en lugar de ir y elegir los tipos desde el interior de la excepci√≥n.</font></font><a name="name"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nombramiento fuerte</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensamblados con nombre seguro</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Hablemos sobre las causas de la carga de ensamblados estrictos, este es el nombre Fuerte. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nombre seguro es la firma del ensamblado por parte de una clave privada que utiliza cifrado asim√©trico. PublicKeyToken es el hash de clave p√∫blica de este ensamblado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Strong Naming le permite distinguir entre diferentes ensamblados que tienen el mismo nombre. Por ejemplo, MyUtils no es un nombre √∫nico, puede haber varios ensamblados con ese nombre, pero si firma el nombre Strong, tendr√°n diferentes PublicKeyToken y podemos distinguirlos de esta manera. Se requiere un nombre seguro para algunos escenarios de carga de ensamblaje.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, para instalar un ensamblaje en la Cach√© de ensamblados global o para descargar varias versiones de lado a lado a la vez. </font><font style="vertical-align: inherit;">Lo que es m√°s importante, los conjuntos con nombre seguro solo pueden hacer referencia a otros conjuntos con nombre seguro. </font><font style="vertical-align: inherit;">Dado que algunos usuarios desean firmar sus compilaciones con el nombre Strong, los desarrolladores de la biblioteca tambi√©n firman sus bibliotecas, para que sea m√°s f√°cil para los usuarios instalarlas, de modo que los usuarios no tengan que volver a firmar estas bibliotecas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nombre fuerte: ¬øLegado?</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nomenclatura fuerte y bibliotecas .NET</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Microsoft dice expl√≠citamente en MSDN que no debe usar un nombre fuerte con fines de seguridad, que solo proporcionan para distinguir diferentes ensamblados con el mismo nombre. La clave de ensamblaje no se puede cambiar de ninguna manera; si la cambi√≥, interrumpir√° las redirecciones a todos sus usuarios. Si tiene una parte privada de la clave para el nombre Strong filtrada al acceso p√∫blico, entonces no puede retirar esta firma de ninguna manera. El formato de archivo SNK en el que se encuentra el nombre seguro no ofrece esa oportunidad, y otros formatos para almacenar claves al menos contienen un enlace a la Lista de revocaci√≥n de certificados CRL, por lo que se puede entender que este certificado ya no es v√°lido. No hay nada de eso en SNK.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La gu√≠a de c√≥digo abierto tiene las siguientes recomendaciones. En primer lugar, adicionalmente por razones de seguridad, use otras tecnolog√≠as. En segundo lugar, si tiene una biblioteca de c√≥digo abierto, generalmente se sugiere que confirme la parte privada de la clave en el repositorio, para que sea m√°s f√°cil para las personas bifurcar su biblioteca, reconstruirla y ponerla en una aplicaci√≥n lista para usar. En tercer lugar, nunca cambie el nombre de Strong. Demasiado destructivo. A pesar de que es demasiado destructivo y est√° escrito al respecto en la gu√≠a de c√≥digo abierto, Microsoft a veces tiene problemas con sus propias bibliotecas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ue/kg/l3/uekgl3iwrexq7ejjbabccq4y4p4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay una biblioteca llamada System.Reactive. </font><font style="vertical-align: inherit;">Anteriormente, estos eran varios paquetes NuGet, uno de ellos es Rx-Linq. </font><font style="vertical-align: inherit;">Esto es solo un ejemplo, lo mismo para el resto de los paquetes. </font><font style="vertical-align: inherit;">En la segunda versi√≥n, se firm√≥ con una clave de Microsoft. </font><font style="vertical-align: inherit;">En la tercera versi√≥n, se mud√≥ al repositorio en el proyecto </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/dotnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y comenz√≥ a tener una firma de .NET Foundation. </font><font style="vertical-align: inherit;">La biblioteca, de hecho, ha cambiado el nombre de Strong. </font><font style="vertical-align: inherit;">Se cambi√≥ el nombre del paquete NuGet, pero el ensamblado se llama dentro exactamente igual que antes. </font><font style="vertical-align: inherit;">¬øC√≥mo redirigir de la segunda versi√≥n a la tercera? </font><font style="vertical-align: inherit;">Esta redirecci√≥n no se puede hacer.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Validaci√≥n de nombre fuerte</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥mo: Deshabilitar la funci√≥n de omisi√≥n de nombre seguro</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro argumento de que el nombre Strong ya es algo del pasado y sigue siendo puramente formal es que no est√°n validados. Tenemos un ensamblado firmado y queremos corregir alg√∫n tipo de error, pero no tenemos acceso a las fuentes. Podemos tomar dnSpy: esta es una utilidad que le permite descompilar y reparar ensamblajes ya compilados. Todo funcionar√° para nosotros. Porque de manera predeterminada, la omisi√≥n de validaci√≥n de nombre seguro est√° habilitada, es decir, solo verifica que PublicKeyToken sea igual y no se verifica la integridad de la firma. Puede haber estudios ambientales en los que la firma a√∫n se verifique, y aqu√≠ un ejemplo v√≠vido es IIS. La integridad de la firma se verifica en IIS (el bypass de validaci√≥n de nombre seguro est√° deshabilitado de forma predeterminada), y todo se romper√° si editamos el ensamblado firmado. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adici√≥n:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede deshabilitar la verificaci√≥n de firma para el ensamblado mediante </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el signo p√∫blico.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Con √©l, solo se utiliza la clave p√∫blica para la firma, lo que garantiza la seguridad del nombre del ensamblado. Las claves p√∫blicas utilizadas por Microsoft se publican </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Rider, el signo p√∫blico se puede habilitar en las propiedades del proyecto. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vl/_j/ct/vl_jctjjgui-mbcgo5uyzd26lrc.png"><br>
<br>
<img src="https://habrastorage.org/webt/ni/if/hp/niifhpriuvymkfhz78sdeaigs54.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cu√°ndo cambiar las versiones de ensamblaje de archivos</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La gu√≠a de c√≥digo abierto tambi√©n ofrece algunas pol√≠ticas de control de versiones, cuyo objetivo es reducir la cantidad de redireccionamientos y cambios de enlace necesarios para los usuarios en NET Framework. Esta pol√≠tica de versiones es que no debemos cambiar la versi√≥n de ensamblaje constantemente. Esto, por supuesto, puede generar problemas con la instalaci√≥n en el GAC, por lo que la imagen nativa instalada puede no corresponder al ensamblado y tendr√° que realizar la compilaci√≥n JIT nuevamente, pero, en mi opini√≥n, esto es menos malo que los problemas con el control de versiones. En el caso de CrossGen, los ensamblajes nativos no se instalan globalmente, no habr√° problemas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, el paquete NuGet Newtonsoft.Json tiene varias versiones: 12.0.1, 12.0.2, etc. Todos estos paquetes tienen un ensamblaje con la versi√≥n 12.0.0.0. </font><font style="vertical-align: inherit;">La recomendaci√≥n es que la versi√≥n de ensamblaje se actualice cuando cambie una versi√≥n principal del paquete NuGet.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomendaciones</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Siga los consejos para .NET Framework: genere redireccionamientos manualmente e intente usar la misma versi√≥n de dependencias en todos los proyectos de su soluci√≥n. </font><font style="vertical-align: inherit;">Esto deber√≠a minimizar significativamente la cantidad de redireccionamientos. </font><font style="vertical-align: inherit;">Necesita nombres seguros solo si tiene un escenario de carga de compilaci√≥n espec√≠fico donde es necesario, o si est√° desarrollando una biblioteca y desea simplificar la vida de los usuarios que realmente necesitan nombres fuertes. </font><font style="vertical-align: inherit;">No cambie el nombre fuerte.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est√°ndar .NET</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pasamos a .NET Standard. Est√° bastante relacionado con la versi√≥n hell en .NET Framework. .NET Standard es una herramienta para escribir bibliotecas que son compatibles con diversas implementaciones de la plataforma .NET. Las implementaciones se refieren a .NET Framework, .NET Core, Mono, Unity y Xamarin. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hk/-a/-u/hk-a-u16d-oitjurhvta7lhafdi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Enlace a la documentaci√≥n</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es la tabla de soporte de .NET Standard para varias versiones de diferentes versiones de tiempos de ejecuci√≥n. Y aqu√≠ podemos ver que .NET Framework de ninguna manera es compatible con .NET Standard versi√≥n 2.1. El lanzamiento de .NET Framework, que admitir√° .NET Standard 2.1 y versiones posteriores, a√∫n no est√° planeado. Si est√° desarrollando una biblioteca y desea que funcione para los usuarios en .NET Framework, deber√° tener un objetivo para .NET Standard 2.0. Adem√°s del hecho de que .NET Framework no admite la √∫ltima versi√≥n de .NET Standard, prestemos atenci√≥n al asterisco. .NET Framework 4.6.1 es compatible con .NET Standard 2.0, pero con un asterisco. Hay una nota al pie de p√°gina directamente en la documentaci√≥n, ¬øde d√≥nde saqu√© esta tabla?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ay/mq/yu/aymqyunvnqjivv13dpqkrzvac6i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere un proyecto de ejemplo. Una aplicaci√≥n en .NET Framework que tiene una dependencia dirigida al est√°ndar .NET. Algo as√≠: ConsoleApp y ClassLibrary. Target Library .NET Standard. Cuando organicemos este proyecto, ser√° as√≠ en nuestro BIN. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/62/og/fh62og_vou9gzibnv5gdd2mp_uk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tendremos cien DLL all√≠, de los cuales solo uno est√° relacionado con la aplicaci√≥n, todo lo dem√°s vino para admitir el est√°ndar .NET. El hecho es que .NET Standard 2.0 apareci√≥ m√°s tarde que .NET Framework 4.6.1, pero al mismo tiempo result√≥ ser compatible con API, y los desarrolladores decidieron agregar compatibilidad con Standard 2.0 a .NET 4.6.1. No lo hicimos de forma nativa (por inclusi√≥n </font></font><code>netstandard.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el tiempo de ejecuci√≥n en s√≠), sino de tal manera que .NET Standard * .dll y todas las dem√°s fachadas de ensamblaje se colocan directamente en BIN.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/af/15/am/af15amgkrw698xqylhfwemd67uy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si observamos las dependencias de la versi√≥n de .NET Framework a la que nos dirigimos y la cantidad de bibliotecas que cayeron en el BIN, veremos que no hay tantas en 4.7.1, y desde 4.7.2 no hay bibliotecas adicionales, y .NET Est√°ndar es compatible all√≠ de forma nativa. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rf/wu/va/rfwuvalfp3bi6zijyw5kjz-wjva.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es un tweet de uno de los desarrolladores de .NET, que describe este problema y recomienda usar .NET Framework versi√≥n 4.7.2 si tenemos bibliotecas .NET Standard. </font><font style="vertical-align: inherit;">Ni siquiera con la versi√≥n 2.0 aqu√≠, sino con la versi√≥n 1.5.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomendaciones</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si es posible, eleve el Marco de destino en su proyecto al menos a 4.7.1, preferiblemente 4.7.2. </font><font style="vertical-align: inherit;">Si est√° desarrollando una biblioteca para facilitar la vida de los usuarios de la biblioteca, cree un Target separado para .NET Framework, evitar√° una gran cantidad de dlls que pueden entrar en conflicto con algo.</font></font><a name="dotnet"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comencemos con una teor√≠a general. </font><font style="vertical-align: inherit;">Discutiremos c√≥mo lanzamos JetBrains Rider en .NET Core, y por qu√© deber√≠amos hablar sobre eso. </font><font style="vertical-align: inherit;">Rider es un proyecto muy grande, tiene una gran soluci√≥n empresarial con una gran cantidad de proyectos diferentes, un complejo sistema de dependencias, no puede simplemente tomarlo y migrar a otro tiempo de ejecuci√≥n al mismo tiempo. </font><font style="vertical-align: inherit;">Para hacer esto, tenemos que usar algunos hacks, que tambi√©n analizamos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplicaci√≥n .NET Core</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øC√≥mo es una aplicaci√≥n t√≠pica de .NET Core? Depende de c√≥mo se implemente exactamente, a qu√© se destinar√° en √∫ltima instancia. Podemos tener varios escenarios. El primero es una implementaci√≥n dependiente de Framework. Esto es lo mismo que en .NET Framework cuando la aplicaci√≥n usa el tiempo de ejecuci√≥n preinstalado en la computadora. Puede ser una implementaci√≥n aut√≥noma, esto es cuando la aplicaci√≥n lleva un tiempo de ejecuci√≥n. Y puede haber una implementaci√≥n de un solo archivo, esto es cuando obtenemos un archivo exe, pero en el caso de .NET Core dentro de este archivo exe hay un artefacto de aplicaci√≥n aut√≥noma, este es un archivo autoextra√≠ble. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/yi/3c/hxyi3c3yxhavujn9ljcmtxkuvj0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solo consideraremos la implementaci√≥n dependiente de Framework. Tenemos un dll con la aplicaci√≥n, hay dos archivos de configuraci√≥n, el primero de los cuales es obligatorio, este </font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font><code>deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Comenzando con .NET Core 3.0, se genera un archivo exe que es necesario para que la aplicaci√≥n sea m√°s conveniente de ejecutar, de modo que no necesite ingresar el comando .NET si estamos en Windows. </font><font style="vertical-align: inherit;">Las dependencias se incluyen en este artefacto, comenzando con .NET Core 3.0, en .NET Core 2.1 necesita publicar o usar otra propiedad </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><a name="config"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Marcos compartidos, </font></font><code>.runtimeconfig.json</code></h3><br>
<br>
<img src="https://habrastorage.org/webt/cc/a5/ab/cca5ab5zhb3v6b1itc9jjbsiwje.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contiene la configuraci√≥n de tiempo de ejecuci√≥n necesaria para ejecutarlo. Indica en qu√© marco compartido se iniciar√° la aplicaci√≥n, y se ve as√≠. Indicamos que la aplicaci√≥n se ejecutar√° en "Microsoft.NETCore.App" versi√≥n 3.0.0, puede haber otro Marco compartido. Otras configuraciones tambi√©n pueden estar aqu√≠. Por ejemplo, puede habilitar el servidor Recolector de basura. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c5/un/ic/c5unicttj2dp5ol0jiewknhb48i.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generado durante el montaje del proyecto. Y si queremos incluir el servidor GC, entonces tenemos que modificar de alguna manera este archivo por adelantado, incluso antes de armar el proyecto, o agregarlo a mano. Puede agregar su configuraci√≥n aqu√≠ de esta manera. Podemos incluir propiedades en </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, si dicha propiedad es proporcionada por desarrolladores de .NET, o si no se proporciona la propiedad, podemos crear un archivo llamado</font></font><code>runtimeconfig.template.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y escriba la configuraci√≥n necesaria aqu√≠. Durante el ensamblaje, se agregar√°n otras configuraciones necesarias a esta plantilla, por ejemplo, el mismo Marco compartido. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/bu/e9/rlbue9y7cikkyzwenefcu2rdxy8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Shared Framework es un conjunto de tiempo de ejecuci√≥n y bibliotecas. De hecho, lo mismo que el tiempo de ejecuci√≥n de .NET Framework, que sol√≠a instalarse una vez en la m√°quina y para todos era una versi√≥n. Shared Framework y, a diferencia de un solo tiempo de ejecuci√≥n de .NET Framework, se puede versionar, diferentes aplicaciones pueden usar diferentes versiones de tiempos de ejecuci√≥n instalados. Tambi√©n se puede heredar Framework compartido. El Marco compartido en s√≠ se puede ver en las ubicaciones del disco que generalmente est√°n instaladas en el sistema.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nc/df/7i/ncdf7ioj8afrolkvnlouh77jiaq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existen varios marcos compartidos est√°ndar, por ejemplo, Microsoft.NETCore.App, que ejecuta aplicaciones de consola convencionales, AspNetCore.App, para aplicaciones web, y WindowsDesktop.App, el nuevo Marco compartido en .NET Core 3, que ejecuta aplicaciones de escritorio. en Windows Forms y WPF. Los dos √∫ltimos Shared Framework esencialmente complementan el primero necesario para las aplicaciones de consola, es decir, no tienen un tiempo de ejecuci√≥n completamente nuevo, sino que simplemente complementan el existente con las bibliotecas necesarias. Parece que esta herencia tambi√©n est√° en los directorios de Shared Framework </font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en los que se especifica el Shared Framework base.</font></font><a name="man"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manifiesto de dependencia ( </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/sc/qv/qbscqv1sh6jb_r19ps_qrusogfi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sondeo predeterminado - .NET Core El</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
segundo archivo de configuraci√≥n es este </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este archivo contiene una descripci√≥n de todas las dependencias de la aplicaci√≥n o el Marco compartido, o la biblioteca, las bibliotecas </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambi√©n lo tienen. Contiene todas las dependencias, incluidas las transitivas. Y el comportamiento del tiempo de ejecuci√≥n de .NET Core difiere dependiendo de si </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la aplicaci√≥n lo tiene o no. De lo </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contrario, la aplicaci√≥n podr√° cargar todos los ensamblados que se encuentran en su Marco compartido o en su directorio BIN. Si lo hay </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, entonces la validaci√≥n est√° habilitada. Si uno de los ensamblados que figuran en la lista </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no lo est√°, la aplicaci√≥n simplemente no se iniciar√°. Ver√° el error presentado anteriormente. Si la aplicaci√≥n intenta cargar alg√∫n ensamblaje en tiempo de ejecuci√≥n, que</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si, por ejemplo, utilizando m√©todos de carga de ensamblaje o durante el proceso de resoluci√≥n de ensamblajes, ver√° un error muy similar a la carga de ensamblaje estricto.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jinete de Jetbrains</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rider es un .NET IDE. No todos saben que Rider es un IDE que consiste en una interfaz basada en IntelliJ IDEA y escrita en Java y Kotlin, y un backend. El backend es esencialmente R #, que puede comunicarse con IntelliJ IDEA. Este backend es una aplicaci√≥n multiplataforma .NET ahora. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øA d√≥nde corre? Windows usa .NET Framework, que est√° instalado en la computadora del usuario. En otros sistemas de informaci√≥n, en Linux y Mac, se usa Mono. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta no es una soluci√≥n ideal cuando hay diferentes tiempos de ejecuci√≥n en todas partes, y quiero pasar al siguiente estado para que Rider se ejecute en .NET Core. Para mejorar el rendimiento, porque en .NET Core todas las caracter√≠sticas m√°s recientes est√°n asociadas con esto. Para reducir el consumo de memoria. Ahora hay un problema con el funcionamiento de Mono con la memoria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cambiar a .NET Core le permitir√° abandonar las tecnolog√≠as heredadas y no compatibles y le permitir√° corregir algunas soluciones a los problemas que se encontraron en tiempo de ejecuci√≥n. </font><font style="vertical-align: inherit;">Cambiar a .NET Core le permitir√° controlar la versi√≥n del tiempo de ejecuci√≥n, es decir, Rider ya no se ejecutar√° en .NET Framework que est√° instalado en la computadora del usuario, sino en una versi√≥n espec√≠fica de .NET Core, que puede prohibirse, en forma de una implementaci√≥n aut√≥noma. </font><font style="vertical-align: inherit;">La transici√≥n a .NET Core eventualmente permitir√° el uso de nuevas API que se importan espec√≠ficamente en Core. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, el objetivo es lanzar un prototipo, lanzarlo, solo para comprobar c√≥mo funcionar√°, cu√°les son los posibles puntos de falla, qu√© componentes tendr√°n que reescribirse nuevamente, lo que requerir√° un procesamiento global.</font></font><br>
<br>
<a name="rider"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caracter√≠sticas que dificultan la traducci√≥n de Rider a .NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visual Studio, incluso si R # no est√° instalado, se </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloquea por</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> falta </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">de memoria en soluciones grandes, dentro de las cuales hay proyectos con SDK-style * .csproj</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">SDK-style * .csproj es una de las principales condiciones para una reubicaci√≥n completa de .NET Core. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto es un problema porque Rider se basa en R #, viven en el mismo repositorio, los desarrolladores de R # quieren usar Visual Studio para desarrollar su propio producto en su producto para que sea un alimento. </font><font style="vertical-align: inherit;">En R # hay bibliotecas espec√≠ficas de enlaces para el marco con el que debe hacer algo. </font><font style="vertical-align: inherit;">En Windows, podemos usar el Framework para aplicaciones de escritorio, y en Linux y Mac, Mock ya se usa para bibliotecas de Windows con una funcionalidad m√≠nima.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decisi√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Decidimos quedarnos con los viejos por ahora </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ensamblarlos bajo el Framework completo, pero como los ensamblajes de Framework y Core son compatibles con binarios, ejec√∫telos en Core. </font><font style="vertical-align: inherit;">No utilizamos funciones incompatibles, agregamos todos los archivos de configuraci√≥n necesarios manualmente y descargamos versiones especiales de dependencias para .NET Core, si las hay.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øA qu√© hacks has tenido que ir?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un truco: queremos llamar a un m√©todo que solo est√° disponible en Framework, por ejemplo, este m√©todo es necesario en R #, pero no en Core. </font><font style="vertical-align: inherit;">El problema es que si no hay un m√©todo, el m√©todo que lo llama durante la compilaci√≥n JIT caer√° antes </font></font><code>MissingMethodException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es decir, un m√©todo que no existe ha arruinado el m√©todo que lo llama.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>(<span class="hljs-params"></span>)</span> { 
  <span class="hljs-keyword">if</span> (NetFramework) <font></font>
     CallNETFrameworkOnlyMethod();<font></font>
<font></font>
  ... <font></font>
} <font></font>
[<span class="hljs-meta">MethodImpl(MethodImplOptions.NoInlining)</span>] 
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallNETFrameworkOnlyMethod</span>(<span class="hljs-params"></span>)</span> { <font></font>
  NETFrameworkOnlyMethod(); <font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La soluci√≥n est√° aqu√≠: hacemos llamadas a m√©todos incompatibles en m√©todos separados. Hay un problema m√°s: dicho m√©todo puede volverse en l√≠nea, por lo tanto, lo marcamos con un atributo </font></font><code>NoInlining</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hack n√∫mero dos: necesitamos poder cargar ensamblajes en rutas relativas. Tenemos un ensamblaje para Framework, hay una versi√≥n especial para .NET Core. ¬øC√≥mo descargamos la versi√≥n .NET Core para .NET Core? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qm/zm/w7/qmzmw79gtllee8uyswgrn0oqnum.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos ayudar√°n </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Veamos la </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biblioteca System.Diagnostics.PerformanceCounter. Tal biblioteca es notable en t√©rminos de su</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tiene una secci√≥n de tiempo de ejecuci√≥n, en la que se indica una versi√≥n de la biblioteca con su ruta relativa. Esta biblioteca, el ensamblado se cargar√° en todos los tiempos de ejecuci√≥n, y solo arroja las ejecuciones. Si, por ejemplo, se carga en Linux, PerformanceCounter no funciona en el dise√±o en Linux, y una excepci√≥n PlatformNotSupportedException vuela desde all√≠. Tambi√©n hay </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una secci√≥n runtimeTargets </font><font style="vertical-align: inherit;">en esto </font><font style="vertical-align: inherit;">y aqu√≠ ya se indica la versi√≥n de este ensamblado espec√≠ficamente para Windows, donde PerformanceCounter deber√≠a funcionar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si tomamos la secci√≥n de tiempo de ejecuci√≥n y escribimos en ella la ruta relativa a la biblioteca que queremos cargar, esto no nos ayudar√°. La secci√≥n de tiempo de ejecuci√≥n en realidad establece la ruta relativa dentro del paquete NuGet, y no en relaci√≥n con el BIN. Si buscamos este ensamblado en BIN, solo se usar√° el nombre del archivo desde all√≠. La secci√≥n runtimeTargets ya contiene una ruta relativa honesta, una ruta honesta relativa a BIN. Prescribiremos una ruta relativa para nuestros ensamblados en la secci√≥n runtimeTargets. En lugar del identificador de tiempo de ejecuci√≥n, que es "ganar" aqu√≠, podemos tomar otro que nos guste. Por ejemplo, escribiremos el identificador de tiempo de ejecuci√≥n "any", y este ensamblado se cargar√° generalmente en todas las plataformas. O escribiremos "unix", y arrancar√° en Linux, y en Mac, y as√≠ sucesivamente.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Siguiente truco: queremos descargar en Linux y en Mac Mock para construir WindowsBase. El problema es que el ensamblado llamado WindowsBase ya est√° presente en Shared Framework </font></font><code>Microsoft.NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, incluso si no estamos en Windows. En el Marco compartido de Windows, </font></font><code>Microsoft.WindowsDesktop.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowsBase redefine la versi√≥n en la que se encuentra </font></font><code>NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Miremos </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estos Framework, m√°s precisamente en aquellas secciones que describen WindowsBase. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gc/ox/f3/gcoxf3q7mbfm_a9hzmcujfin5zc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ est√° la diferencia: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5q/pz/wq/5qpzwq-n21m38b_0xedi9txpwoc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
si alguna biblioteca entra en conflicto y est√° presente en varias </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, entonces se selecciona el m√°ximo de ellas para el par formado por </font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La gu√≠a .NET dice que </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo es necesario mostrarlo en el Explorador de Windows, pero no es as√≠, cae en</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este es el √∫nico caso que conozco cuando la versi√≥n prescrita </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, realmente se utilizan. En todos los dem√°s casos, vi un comportamiento que, independientemente de las versiones </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escritas, el ensamblado continuar√≠a carg√°ndose de todos modos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/re/j8/bwrej8fa8_gyuyvcjnt3ixvljce.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuarto truco. Tarea: tenemos un archivo .deps.json para los dos hacks anteriores, y lo necesitamos solo para dependencias espec√≠ficas. Dado que se </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generan en modo semi-manual, tenemos un script que, de acuerdo con alguna descripci√≥n de lo que deber√≠a llegar all√≠, lo genera durante la compilaci√≥n, queremos mantener esto lo m√°s </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√≠nimo posible para que podamos entender lo </font><font style="vertical-align: inherit;">que contiene </font><font style="vertical-align: inherit;">. Queremos deshabilitar la validaci√≥n y permitir la descarga de ensamblajes que est√°n en el BIN pero que no se describen en </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soluci√≥n: habilite la configuraci√≥n personalizada en runtimeconfig. </font><font style="vertical-align: inherit;">Esta configuraci√≥n es realmente necesaria para la compatibilidad con versiones anteriores de .NET Core 1.0.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomendaciones</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, </font></font><code>.runtime.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en .NET Core, estos son una especie de an√°logos </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le permite hacer lo mismo, por ejemplo, cargar ensamblajes de manera relativa. </font><font style="vertical-align: inherit;">Utilizando </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, reescribi√©ndolo manualmente, puede personalizar la carga de ensamblados en .NET Core, si tiene un escenario muy complejo.</font></font><a name="load"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depurar descargas de ensamblados</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Habl√© sobre algunos tipos de problemas, por lo que debe ser capaz de depurar problemas al cargar ensamblajes. </font><font style="vertical-align: inherit;">¬øQu√© puede ayudar con esto? </font><font style="vertical-align: inherit;">Primero, los tiempos de ejecuci√≥n escriben registros sobre c√≥mo cargan los ensamblados. </font><font style="vertical-align: inherit;">En segundo lugar, puedes mirar m√°s de cerca las ejecuciones que vuelan hacia ti. </font><font style="vertical-align: inherit;">Tambi√©n puede centrarse en eventos de tiempo de ejecuci√≥n.</font></font><a name="fusion"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registros de fusi√≥n</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/jl/4v/be/jl4vbeqsyjzmab2rx0xvdg-lpi4.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volver a lo b√°sico: uso del visor de registro de Fusion para depurar errores oscuros </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusion</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
El mecanismo para cargar ensamblados en .NET Framework se llama Fusion y sabe c√≥mo registrar lo que hizo en el disco. Para habilitar el registro, debe agregar configuraciones especiales al registro. Esto no es muy conveniente, por lo que tiene sentido usar utilidades, a saber, Fusion Log Viewer y Fusion ++. Fusion Log Viewer es una utilidad est√°ndar que viene con Visual Studio y se puede iniciar desde la l√≠nea de comandos de Visual Studio, Visual Studio Developer Command Prompt. Fusion ++ es un an√°logo de c√≥digo abierto de esta herramienta con una interfaz m√°s agradable.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ou/9h/bt/ou9hbtdgx1yjp6rjjdm3q61efpu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fusion Log Viewer se ve as√≠. Esto es peor que WinDbg porque esta ventana ni siquiera se estira. Sin embargo, puede perforar las marcas de verificaci√≥n aqu√≠, aunque no siempre es obvio qu√© conjunto de marcas de verificaci√≥n es correcto. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gu/h2/by/guh2byfmgazm8yvbxfa_jhf25wo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fusion ++ tiene un bot√≥n "Iniciar registro", y luego aparece el bot√≥n "Detener registro". En √©l, puede ver todos los registros sobre la carga de ensamblajes, leer los registros sobre lo que estaba sucediendo exactamente. Estos registros se parecen a esto de una manera concisa.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zf/ep/5m/zfep5myuovdov4t7mmtw4czhwqc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es una ejecuci√≥n de la carga estricta del ensamblado. </font><font style="vertical-align: inherit;">Si miramos los registros de Fusion, veremos que necesit√°bamos descargar la versi√≥n 9.0.0.0 despu√©s de procesar todas las configuraciones. </font><font style="vertical-align: inherit;">Encontramos un archivo en el que se sospecha que tenemos el ensamblaje que necesitamos. </font><font style="vertical-align: inherit;">Vimos que la versi√≥n 6.0.0.0 est√° en este archivo. </font><font style="vertical-align: inherit;">Tenemos una advertencia de que comparamos los nombres completos de los ensamblados, y difieren en la versi√≥n principal. </font><font style="vertical-align: inherit;">Y luego se produjo un error: la versi√≥n no coincide.</font></font><a name="events"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eventos de tiempo de ejecuci√≥n</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/pu/np/bn/punpbnrdvfv_mm5bpweej75ofq8.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registro de eventos de tiempo de ejecuci√≥n</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En Mono, puede habilitar el registro utilizando variables de entorno, y los registros eventualmente se escribir√°n en </font></font><code>stdout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. No es tan conveniente, pero la soluci√≥n est√° funcionando. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rj/vv/g9/rjvvg9dfv0ji5sbxm_crgu3ok0a.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sondeo predeterminado: </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentaci√≥n de </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">.NET Core </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">/ documentos de dise√±o / rastreo de host</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
. .NET Core tambi√©n tiene una variable de entorno especial </font></font><code>COREHOST_TRACE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que incluye el inicio de sesi√≥n </font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Con .NET Core 3.0, puede escribir registros en un archivo especificando la ruta en una variable </font></font><code>COREHOST_TRACEFILE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<img src="https://habrastorage.org/webt/eo/b5/yf/eob5yf90z7cgilees68uxtrhw0w.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un evento que se dispara cuando los ensamblajes no se cargan. Se trata de un evento </font></font><code>AssembleResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Hay un segundo evento √∫til, este </font></font><code>FirstChanceException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Puede suscribirse y obtener un error sobre la carga de ensamblajes, incluso si alguien escribi√≥ try..catch y se perdi√≥ todas las ejecuciones en el lugar donde</font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ocurri√≥. </font><font style="vertical-align: inherit;">Si la aplicaci√≥n ya se ha compilado, puede iniciarla </font></font><code>perfview</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y puede monitorear las ejecuciones de .NET, y encontrar las relacionadas con la descarga de archivos all√≠.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomendaciones</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transfiera el trabajo a herramientas, a herramientas de desarrollo, a un IDE, a MSBuild, que le permite generar redireccionamientos. </font><font style="vertical-align: inherit;">Puede cambiar a .NET Core, luego olvidar√° lo que es la carga estricta de ensamblajes y podr√° usar la nueva API tal como queremos lograrla en Rider. </font><font style="vertical-align: inherit;">Si conecta la biblioteca .NET Standard, aumente la versi√≥n de destino de .NET Framework al menos a 4.7.1. </font><font style="vertical-align: inherit;">Si pareces estar en una situaci√≥n desesperada, busca hacks, √∫salos o inventa tus propios hacks para situaciones desesperadas. </font><font style="vertical-align: inherit;">Y armarse con herramientas de depuraci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le recomiendo que lea los siguientes enlaces:</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">.NET Guide</a>;</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">     .NET Core</a>.</li>
</ul><br>
<br>
<blockquote>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DotNext 2020 Piter</a> .       ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> 8   JUG Ru Group</a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es499824/index.html">El resumen de eventos para reclutadores de recursos humanos y TI en mayo de 2020</a></li>
<li><a href="../es499826/index.html">Presi√≥n arterial distribuida</a></li>
<li><a href="../es499832/index.html">¬øC√≥mo organizar de forma r√°pida y segura el trabajo remoto de los empleados? Hablamos de diferentes enfoques: con VDI y no solo</a></li>
<li><a href="../es499834/index.html">Conoce el aritm√≥metro Felix</a></li>
<li><a href="../es499836/index.html">Udalenka vs. oficina para el equipo de desarrollo</a></li>
<li><a href="../es499842/index.html">¬øPor qu√© la gente vuelve a aprender?</a></li>
<li><a href="../es499846/index.html">Cu√°ndo comenzar√° a funcionar la recolecci√≥n de basura por separado y por qu√© es necesaria la videovigilancia de los sitios para contenedores de basura</a></li>
<li><a href="../es499850/index.html">C√≥mo analizar competidores y establecer una estrategia digital en 40 minutos</a></li>
<li><a href="../es499852/index.html">Documentaci√≥n en ingl√©s para Angular</a></li>
<li><a href="../es499854/index.html">Apache Bigtop y la elecci√≥n de la distribuci√≥n de Hadoop hoy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>