<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍦 👨🏽‍🤝‍👨🏻 👩🏽‍🎨 Le livre «Algorithme parfait. Algorithmes gourmands et programmation dynamique » 🥪 🥌 🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, habrozhiteli! Dans le nouveau livre, Tim Rafgarden parle d'algorithmes gourmands (le problème de la planification, les arbres couvrant minima...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Le livre «Algorithme parfait. Algorithmes gourmands et programmation dynamique »</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/489014/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/zt/4e/yp/zt4eypq-gybnz_assyf-7wpz3vu.jpeg" align="left" alt="image"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, habrozhiteli! Dans le nouveau livre, Tim Rafgarden parle d'algorithmes gourmands (le problème de la planification, les arbres couvrant minimal, le clustering, les codes Huffman) et la programmation dynamique (le problème du sac à dos, l'alignement des séquences, les chemins les plus courts, les arbres de recherche optimaux). Cet article présente un extrait «Développer un algorithme gourmand». Les algorithmes </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
gourmands semblent bien adaptés à la tâche de planification du travail, en minimisant la somme pondérée des temps d'exécution. La sortie a une structure itérative, où le travail est traité un à la fois. Pourquoi ne pas utiliser un algorithme gourmand qui décide itérativement quel travail sera le prochain?</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première étape de notre plan consiste à résoudre deux cas particuliers du problème général. </font><font style="vertical-align: inherit;">Nos solutions à ces cas montreront à quoi pourrait ressembler un algorithme gourmand dans le cas général. </font><font style="vertical-align: inherit;">Ensuite, nous restreignons le domaine à un seul algorithme candidat et prouvons que c'est ce candidat qui résout correctement le problème. </font><font style="vertical-align: inherit;">Le processus par lequel nous arrivons à cet algorithme est plus important à retenir que l'algorithme lui-même; </font><font style="vertical-align: inherit;">ce processus est reproductible et vous pouvez l'utiliser dans vos propres applications.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13.3.1. </font><font style="vertical-align: inherit;">Deux cas particuliers</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons que pour minimiser la somme pondérée des dates d'achèvement, il existe en fait un algorithme gourmand correct. </font><font style="vertical-align: inherit;">À quoi cela ressemblerait-il si nous supposons que toutes les œuvres ont la même longueur (mais éventuellement des poids différents) ou, inversement, ont le même poids (mais éventuellement des longueurs différentes)?</font></font><br>
<blockquote> 13.2<br>
<br>
(1)      ,          ?<br>
(2)      ,           ?<br>
) ; <br>
) ; <br>
) ; <br>
) ; <br>
(   .   13.3.3.)</blockquote><br>
<h3>13.3.2.   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, le travail peut avoir différents poids et différentes longueurs. Chaque fois que nos deux règles de base - préférer un travail plus court et un travail avec des poids plus élevés - ont la chance que deux emplois coïncident, nous savons lequel planifier en premier (plus court avec des poids plus élevés). Mais que faire si ces deux règles donnent des conseils contradictoires? Que devons-nous faire avec un travail court avec un poids faible et un travail long avec un poids élevé?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quel sera l'algorithme gourmand le plus simple qui fonctionnera comme il se doit? Chaque travail a deux paramètres, et l'algorithme doit examiner les deux. La meilleure option serait de développer une formule qui compile la longueur et le poids de chaque travail en une seule note (contribution), de sorte que la planification des travaux de la plus haute à la plus basse est garantie pour minimiser le nombre de dates d'achèvement pondérées. Si une telle formule existe, il s'ensuit de nos deux cas particuliers qu'elle doit avoir deux propriétés: (i) en laissant la longueur fixe, elle devrait augmenter du poids de l'ouvrage; (ii) en laissant le poids fixe, il doit diminuer par rapport à la longueur de l'ouvrage (rappelez-vous que plus la note est élevée, mieux c'est). Passez une minute à réfléchir à plusieurs formules qui ont ces deux propriétés.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/-d/il/vm/-dilvmx9eulm9e96z9avlykyavg.jpeg" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction la plus simple, qui augmente en poids et diminue en longueur, est peut-être la différence: la </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
proposition n ° 1 pour la marque de l'œuvre. </font></font><img src="https://habrastorage.org/webt/rx/du/mi/rxdumiqofl604y3nzq_xoihf_su.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La marque indiquée pourrait être négative, mais cela ne fait pas obstacle à la construction cohérente des œuvres de la plus haute à la plus basse. . </font><font style="vertical-align: inherit;">Cependant, il existe de nombreuses autres options. </font><font style="vertical-align: inherit;">Par exemple, le rapport de deux paramètres est un autre candidat: la </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
proposition n ° 2 pour le marquage de l'œuvre </font></font><img src="https://habrastorage.org/webt/wc/es/rk/wcesrkmtu6wqde7gcbjhvqb3rts.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces deux fonctions de calcul de la note conduisent à deux algorithmes gourmands différents.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GREEDYDIFF GREED DIFFERENCE </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Planifier le travail dans l'ordre décroissant </font></font><img src="https://habrastorage.org/webt/e-/r2/8x/e-r28xu0dqhniboc96n0xh7mui4.jpeg" alt="image"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(rompre arbitrairement la coïncidence des valeurs).</font></font></blockquote><blockquote>  GREEDYRATIO<br>
<br>
     <img src="https://habrastorage.org/webt/ww/p_/vg/wwp_vgagganqj0q5ztncmnt-u04.jpeg" alt="image"><br>
(   ).</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, déjà notre première étude de cas illustre le premier sujet du paradigme gourmand (section 13.1.2): il n'est généralement pas difficile de proposer plusieurs algorithmes gourmands concurrents pour une tâche. Mais lequel des deux algorithmes, le cas échéant, est correct? Un moyen rapide d'exclure l'un d'eux est de trouver une instance dans laquelle deux algorithmes affichent des planifications différentes avec des valeurs différentes de la fonction objectif. Pour tout algorithme dont les résultats sont pires dans cet exemple, nous pouvons conclure qu'il n'est pas toujours optimal. Dans deux cas particuliers avec des œuvres de même poids ou de même longueur, les deux algorithmes agissent correctement. L'exemple le plus simple possible de l'exclusion de l'un d'eux peut être une instance d'une tâche dans laquelle deux œuvres ont des poids et des longueurs différentes,en conséquence, les deux algorithmes prévoient de fonctionner dans des ordres opposés. Autrement dit, nous recherchons deux œuvres, dont l'ordre dans la différence est l'opposé de leur ordre par rapport. Exemple:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/bk/2e/i8/bk2ei8vmvkm0p-poglz62vgncbw.jpeg" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier travail a un rapport plus grand </font></font><img src="https://habrastorage.org/webt/mm/k-/fk/mmk-fksrqtkrdi-k3reiw6zqgwk.jpeg" alt="image"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais plus grand (–2 vs –1). </font><font style="vertical-align: inherit;">Ainsi, l'algorithme </font></font><code>GreedyDiff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planifie d'abord le deuxième travail, tandis que l'algorithme </font></font><code>GreedyRatio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planifie le contraire.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXERCICE 13.3 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelle est la somme des dates d'achèvement pondérées dans les calendriers déduits respectivement par les algorithmes </font></font><code>GreedyDiff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>GreedyRatio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
a) 22 et 23 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
b) 23 et 22 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
c) 17 et 17 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
d) 17 et 11 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Pour une solution et une explication, voir la section 13.3.3.)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons avancé en excluant l'algorithme </font></font><code>GreedyDiff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de toute considération ultérieure. Cependant, le résultat de l'exercice 13.3 ne conduit pas directement au fait que l'algorithme </font></font><code>GreedyRatio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sera toujours optimal. À notre connaissance, il existe d'autres cas où cet algorithme produit un planning non optimal. Vous devez toujours être sceptique à l'égard d'un algorithme qui n'est pas accompagné d'une preuve de son exactitude, même si cet algorithme fait la bonne chose dans plusieurs cas de test et est extrêmement sceptique à l'égard des algorithmes gourmands. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre cas, l'algorithme est </font></font><code>GreedyRatio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en fait garanti pour minimiser le nombre de dates d'achèvement pondérées. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Théorème 13.1 (l'exactitude de l'algorithme </font></font><code>GreedyRatio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour chaque ensemble de poids de travail positifs</font></font><img src="https://habrastorage.org/webt/x2/pm/zv/x2pmzvo-1kgq9_qmlmve49gp_e0.jpeg" alt="image"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et des longueurs de travail positives, l' </font></font><img src="https://habrastorage.org/webt/hb/ez/xz/hbezxznweju_oegojdnbertn1ag.jpeg" alt="image"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algorithme </font></font><code>GreedyRatio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">affiche un calendrier avec la plus petite somme possible de dates d'achèvement pondérées.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Cette affirmation logique n'est pas évidente et vous ne devez pas lui faire confiance sans avoir reçu de preuves. Conformément au troisième thème du paradigme gourmand (section 13.1.2), cette preuve reprend toute la section suivante.</font></font><br>
<blockquote> ,   . .<br>
<br>
         .  —   ,      (         ).  —  ,       , ,   .    «» (       )    ,       .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le thème restant du paradigme gourmand est la simplicité de l'analyse d'exécution (section 13.1.2). </font><font style="vertical-align: inherit;">Ici, bien sûr, c'est. </font><font style="vertical-align: inherit;">L'algorithme GreedyRatio trie uniquement les travaux par relation, ce qui prend du temps O (n log n), où n est le nombre de travaux en entrée (voir la note de bas de page 1 à la p. 24).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13.3.3. </font><font style="vertical-align: inherit;">Solutions d'exercice 13.2–13.3</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La solution pour l'exercice 13.2 La </font></font></b><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bonne réponse est: (a)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Supposons d'abord que tous les n travaux ont la même durée, disons 1. Ensuite, chaque programme a exactement le même ensemble de délais - {1, 2, 3, ..., n} - et la seule question est de savoir quel type de travail obtient date d'achèvement et quelle est la date limite. Notre sémantique des poids de travail implique certainement que le travail avec un poids plus important devrait recevoir des temps de réalisation plus courts, et cela est vrai. Par exemple, vous ne voudriez pas planifier un travail avec un poids de 10 tiers (avec un délai de 3) et un travail avec un poids de 20 cinquième (avec un délai de 5); vous feriez mieux de changer les positions de ces deux œuvres, ce qui réduirait la somme des délais pondérés de 20 (comme vous pouvez le constater par vous-même).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxième cas, dans lequel toutes les œuvres ont le même poids, est légèrement plus fin. Ici, vous voulez donner la préférence à un travail plus court. Par exemple, considérons deux travaux de poids unitaire avec des longueurs de 1 et 2. Si vous prévoyez d'abord un travail plus court, les délais d'achèvement seront 1 et 3 avec un total de 4. Dans l'ordre inverse, les délais seront 2 et 3 avec le pire résultat 5. En général, le planifié le travail contribue d'abord au temps d'achèvement de tout travail, car tout travail doit attendre l'achèvement du premier. Toutes choses étant égales par ailleurs, la planification du travail le plus court minimise d'abord cet impact négatif. Le deuxième travail contribue à toutes les dates d'achèvement à l'exception du premier travail, donc le deuxième travail le plus court doit être planifié ensuite, et ainsi de suite. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solution de l'exercice 13.3</font></font></b><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La bonne réponse est b). </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'algorithme </font></font><code>GreedyDiff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prévoit d'abord un deuxième travail. </font><font style="vertical-align: inherit;">La date limite pour terminer ce travail est </font></font><img src="https://habrastorage.org/webt/8g/bc/eb/8gbcebnbsfr9eofdsf1znkmtihs.jpeg" alt="image"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alors que la date limite pour terminer un autre travail est la </font></font><img src="https://habrastorage.org/webt/om/qi/nm/omqinmdtfr7xnkccaazw3h63eb0.jpeg" alt="image"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">somme des délais pondérés pour l'achèvement.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/98/68/gz98683gqg4kf6uotkfcs0loxui.jpeg" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'algorithme </font></font><code>GreedyRatio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planifie d'abord le premier travail, entraînant des délais </font></font><img src="https://habrastorage.org/webt/rl/5h/bw/rl5hbwytgo1arwgetzmxqavafw0.jpeg" alt="image"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et la somme des délais pondérés égaux à</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ta/6f/qx/ta6fqxxmfcxvmhsyajnc_6tri0i.jpeg" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que l'algorithme </font></font><code>GreedyDiff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne parvient pas à calculer la planification optimale </font><font style="vertical-align: inherit;">pour cet exemple </font><font style="vertical-align: inherit;">, il n'est pas toujours correct. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
»Plus d'informations sur le livre peuvent être trouvées sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le site Web de l'éditeur</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenu</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extrait</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
pour Khabrozhiteley 25% de réduction sur le coupon - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithmes</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Lors du paiement de la version papier du livre, un livre électronique est envoyé par e-mail.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr489002/index.html">Registre de roues distribuées: expérience avec Hyperledger Fabric</a></li>
<li><a href="../fr489004/index.html">Téléphone portable avec Dial Dialer</a></li>
<li><a href="../fr489008/index.html">Routage dans des chatbots complexes avec le framework Hobot</a></li>
<li><a href="../fr489010/index.html">Nous partageons la plus grande couche de données en Russie sur la formation en ligne avec des projets en linguistique, personnalisation, conception graphique, ML</a></li>
<li><a href="../fr489012/index.html">Google Cloud Spanner: bon, mauvais, mal</a></li>
<li><a href="../fr489016/index.html">Gref allemand: «Nous avons essayé d'organiser une discussion sur l'AGI, et pas un seul scientifique qui se respecte n'est venu à lui»</a></li>
<li><a href="../fr489020/index.html">L'étude d'un malveillant</a></li>
<li><a href="../fr489022/index.html">Utilisation de RabbitMQ avec MonsterMQ Partie 2</a></li>
<li><a href="../fr489024/index.html">Bibliothèque JavaScript Webix vue par un débutant. Partie 5. Travailler avec des données côté utilisateur</a></li>
<li><a href="../fr489026/index.html">La modification des algorithmes Google AdSense peut conduire les propriétaires de sites et les webmasters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>