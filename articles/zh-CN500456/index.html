<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚎 🚴🏾 💆🏼 BpfTrace-最后，在Linux上完全替代Dtrace 🥄 ✈️ 👨🏽‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="碰巧系统有故障，速度变慢，崩溃了。系统越大，找到原因的难度就越大。要找出为什么某些东西无法按预期工作，修复或防止将来出现问题，您需要查看内部。为此，系统必须具有可观测性，这是通过广义上的仪器化来实现的。
 
 
 在HighLoad ++上， Peter Zaitsev（Percona）审查了Lin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>BpfTrace-最后，在Linux上完全替代Dtrace</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/500456/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">碰巧系统有故障，速度变慢，崩溃了。</font><font style="vertical-align: inherit;">系统越大，找到原因的难度就越大。</font><font style="vertical-align: inherit;">要找出为什么某些东西无法按预期工作，修复或防止将来出现问题，您需要查看内部。</font><font style="vertical-align: inherit;">为此，系统必须具有</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可观测性</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这是通过广义上的仪器化来实现的。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/6ExXwQecMrs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HighLoad ++上，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Peter Zaitsev（Percona）审查了Linux中可用的跟踪基础结构，并讨论了bpfTrace（顾名思义）具有许多优点。</font><font style="vertical-align: inherit;">我们制作了该报告的文本版本，以便您查看详细信息并且随时可以获取其他材料。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仪表可分为两个大块：</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静态</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将信息集合连接到代码中时：记录日志，计数器，时间等。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamic</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果代码本身未检测到，但是有必要时可以执行。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一个分类选项基于记录数据的方法：</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">跟踪</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -如果某些代码有效，则会生成事件。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">采样</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -例如每秒检查系统状态100次，并确定系统中正在发生的情况。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静态仪器已经存在了很多年，几乎涵盖了所有领域。</font><font style="vertical-align: inherit;">在Linux上，许多标准工具（例如Vmstat或top）都使用它。</font><font style="vertical-align: inherit;">他们从procfs中读取数据，大致来说，是从内核代码中写入不同的计时器和计数器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是您不能插入太多这些计数器；您无法用它们覆盖世界上的所有事物。</font><font style="vertical-align: inherit;">因此，动态检测可能很有用，它使您可以精确地观察所需的内容。</font><font style="vertical-align: inherit;">例如，如果TCP / IP堆栈有任何问题，那么您可以深入了解并指导特定的细节。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/x8/nh/hz/x8nhhza-v08u7nlo01rb778nxqs.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">跟踪</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DTrace是由Sun Microsystems创建的最早的已知动态跟踪框架之一。它于2001年开始制作，并于2005年首次在Solaris 10中发布。事实证明这种方法非常流行，后来又进入了许多其他发行版。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有趣的是，DTrace允许您同时检测内核空间和用户空间。您可以在任何函数调用上放置跟踪，并专门指示程序：引入特殊的DTrace跟踪点，对于用户而言，比函数名称更容易理解。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这对于Solaris尤其重要，因为它不是开放式操作系统。不可能只看一下代码并了解跟踪点就需要像现在可以在新的开源Linux软件中完成的功能一样。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DTrace独特的功能（尤其是在当时）是其中之一，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">虽然未启用跟踪，但不花钱</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它的工作方式是用DTrace调用简单地替换一些CPU指令，该调用在返回时执行这些指令。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在DTrace中，检测是用一种特殊的D语言编写的，类似于C和Awk。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
后来，DTrace几乎出现在Linux之外的所有地方：2007年在MacOS上，2008年在FreeBSD上，2010年在NetBSD上。2011年，Oracle将DTrace包含在Oracle Unbreakable Linux中。</font><font style="vertical-align: inherit;">但是很少有人使用Oracle Linux，并且DTrace从未进入主Linux。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有趣的是，在2017年，Oracle最终在GPLv2下许可了DTrace，从原则上讲，它可以在没有许可困难的情况下将其包括在主线Linux中，但是为时已晚。</font><font style="vertical-align: inherit;">当时，Linux具有良好的BPF，主要用于标准化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DTrace甚至将包含在Windows中；现在在某些测试版本中可用。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux追踪</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Linux中是什么而不是DTrace？</font><font style="vertical-align: inherit;">实际上，在Linux中，有很多东西以开源精神的最好（或最坏）表现形式出现，在这段时间里已经积累了许多不同的跟踪框架。</font><font style="vertical-align: inherit;">因此，弄清楚什么不是那么简单。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wr/vu/ij/wrvuijy1unvtq2thcngvonvzsrq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您想了解这种变化并且对历史感兴趣，请参阅</font><font style="vertical-align: inherit;">带有图片</font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及Linux中跟踪方法的详细说明。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们通常讨论Linux中的跟踪基础结构，则分为三个级别：</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内核检测的接口：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kprobe，Uprobe，Dtrace探针等。</font></font></li>
<li><strong>«»,    .</strong> ,  probe,      ,          user space   .       :   ,     user space,  Kernel Module,   - ,  eBPF.</li>
<li><strong>-</strong>,    ,    : Perf, SystemTap, SysDig, BCC  .. bpfTtrace       ,  ,   .</li>
</ol><br>
<h2>eBPF —   Linux</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过所有这些框架，eBPF近年来已成为Linux上的标准。</font><font style="vertical-align: inherit;">这是一种更高级，高度灵活且有效的工具，几乎可以执行所有操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
什么是eBPF？它来自何处？</font><font style="vertical-align: inherit;">实际上，eBPF是扩展的Berkeley数据包过滤器，而BPF于1992年作为虚拟机开发，用于通过防火墙进行有效的数据包过滤。</font><font style="vertical-align: inherit;">最初，他与监视，可观察性或跟踪无关。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在更现代的版本中，eBPF已经扩展（因此扩展了单词），作为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理事件</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的通用</font><strong><font style="vertical-align: inherit;">框架</font></strong><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">当前版本与JIT编译器集成在一起，以提高效率。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eBPF与经典BPF的区别：</font></font></strong><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">寄存器已添加；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出现了一个堆栈；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有其他数据结构（地图）。</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/gj/9v/uh/gj9vuhqn64yciwp2zyjmekazpvs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，人们最经常忘记的是有一个旧的BPF，而eBPF简称为BPF。</font><font style="vertical-align: inherit;">在大多数现代表达式中，eBPF和BPF是相同的。</font><font style="vertical-align: inherit;">因此，该工具称为bpfTrace，而不是eBpfTrace。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自2014年以来，eBPF已被包括在主线Linux中，并且逐渐被包括在许多Linux工具中，包括Perf，SystemTap和SysDig。</font><font style="vertical-align: inherit;">有一个标准化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有趣的是，发展仍在进行中。</font><font style="vertical-align: inherit;">现代内核越来越支持eBPF。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/f9/ad/xi/f9adxi6tahas6qaz0crpgc4fldk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看到什么现代内核版本</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EBPF计划</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那么什么是eBPF？为什么它很有趣？</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eBPF是具有其特殊字节码的程序，该字节码</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接包含在内核中并执行跟踪事件的处理。而且，它是用特殊的字节码制成的，这一事实使内核可以进行一定的验证，证明该代码相当安全。例如，检查它是否不使用循环，因为内核关键部分中的循环会挂起整个系统。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但这不允许完全安全。例如，如果您编写一个非常复杂的eBPF程序，将其插入内核中每秒发生一千万次的事件，那么一切都会大大减慢速度。但是与此同时，当通过insmod插入一些内核模块，并且这些模块中可能包含任何内核模块时，eBPF比旧方法安全得多。如果有人犯了一个错误，或者仅仅是因为二进制不兼容，那么整个内核就会崩溃。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
eBPF代码可由LLVM Clang编译，也就是说，大体上，使用C的子集来创建eBPF程序，这当然很复杂。而且重要的是编译依赖于内核：标头用于了解使用了哪些结构以及它们的用途，等等。从某种意义上说，要么总是提供某些与特定内核相关的模块，要么需要重新编译，因此这不是很方便。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该图显示了eBPF的工作方式。</font></font><br>
<img src="https://habrastorage.org/webt/vf/f6/fq/vff6fqzhay_0tskbjguckrqe6e4.png"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.brendangregg.com/ebpf.html</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用户创建一个eBPF程序。此外，内核本身会检查并加载它。之后，eBPF可以连接到各种用于跟踪，处理信息的工具，并将其保存在地图（用于临时存储的数据结构）中。然后，用户程序可以读取统计信息，接收性能事件等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它显示了哪些eBPF在哪些版本的Linux内核中具有功能。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cy/ck/gr/cyckgrqgpnhpfmbg2wptd77b1q0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以看出，几乎涵盖了Linux内核的所有子系统，并且与硬件数据的集成很好，eBPF可以访问各种缓存未命中或分支未命中预测等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您对eBPF感兴趣，请查看</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">IO Visor</font></a><font style="vertical-align: inherit;">项目</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中包含大多数工具。</font><font style="vertical-align: inherit;">IO Visor公司正在从事他们的开发，他们将拥有最新版本和非常好的文档。</font><font style="vertical-align: inherit;">Linux发行版上出现了越来越多的eBPF工具，因此我建议您始终使用最新的可用版本。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EBPF表现</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在性能方面，eBPF非常有效。</font><font style="vertical-align: inherit;">要了解多少以及是否有开销，您可以添加一个探针，该探针每秒抽动数次，并检查执行它需要多长时间。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rb/jb/tq/rbjbtq7wvfiqdggh5bohn0dcaxc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
来自Cloudflare的家伙做出了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基准</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">一个简单的eBPF探针大约花费了100 ns，而一个更复杂的探针则花费了300 ns。</font><font style="vertical-align: inherit;">这意味着甚至一个复杂的探针也可以每秒大约300万次在单个内核上被调用。</font><font style="vertical-align: inherit;">如果探针在多核处理器上每秒震荡10万或一百万次，则不会对性能造成太大影响。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eBPF的前端</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您对eBPF和总体可观察性主题感兴趣，那么您可能听说过Brendan Gregg。他</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">撰写</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并讨论了</font><font style="vertical-align: inherit;">很多内容，</font><font style="vertical-align: inherit;">并制作了精美的图片，展示了eBPF的工具。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/da/-o/fi/da-ofi9xtmuvnkvygmbhzdftz00.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，您可以看到，例如，您可以使用Raw BPF（仅编写字节代码）即可，这将提供全部功能，但是使用起来非常困难。 Raw BPF涉及如何在汇编器中编写Web应用程序-原则上可以，但不需要这样做。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有趣的是，一方面，bpfTrace允许您从BCC和原始BPF中获得几乎所有内容，但使用起来却容易得多。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为，两个工具最有用：</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">密件抄送。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管根据Gregg的方案，BCC很复杂，但它包含</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">许多现成的功能</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，可以从命令行简单地启动它们。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BpfTrace</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它使您可以简单地编写自己的工具包或使用现成的解决方案。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以想象一下，如果您查看两个版本中相同工具的代码，那么在bpfTrace上编写代码会容易得多。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/df/yj/rg/dfyjrg8q4abkcjgcsnp00vuuymg.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DTrace和bpfTrace</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，DTrace和bpfTrace用于同一事物。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rh/uo/rm/rhuormrzvwap7cr3uwlqk8hcnqu.png"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.brendangregg.com/blog/2018-10-08/dtrace-for-linux-2018.html</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
不同之处在于BPF生态系统中还有一个BCC可用于复杂的工具。</font><font style="vertical-align: inherit;">DTrace中没有BCC等效项，因此，要制作复杂的工具箱，通常使用Shell + DTrace捆绑包。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建bpfTrace时，没有完全模拟DTrace的任务。也就是说，您不能使用DTrace脚本并在bpfTrace上运行它。但这没有多大意义，因为底层工具中的逻辑非常简单。在Linux，Solaris和FreeBSD中，了解需要连接到哪些跟踪点，系统调用的名称以及它们直接在底层进行的操作通常更为重要。那就是产生差异的地方。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，bpfTrace是在DTrace之后15年制成的。它具有DTrace所没有的一些其他功能。例如，他可以进行堆栈跟踪。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，当然，很多是从DTrace继承的。例如，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数名称和语法相似</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，尽管不完全相同。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/9l/cf/0z/9lcf0z37mltxok_7fsdvdhxanv8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DTrace和bpfTrace脚本的代码大小相近，而复杂度和语言功能则相似。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/re/ud/br/reudbrcb_yoslb9ylo0loe9e-os.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bpfTrace</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们更详细地了解bpfTrace中的内容，如何使用它以及需要什么。</font><font style="vertical-align: inherit;">使用bpfTrace的</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux要求</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<img src="https://habrastorage.org/webt/1_/sc/tk/1_sctkrpgkd3rd2b0ccrk4fur2y.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要使用所有功能，您需要的版本至少为4.9。</font><font style="vertical-align: inherit;">BpfTrace允许您进行许多不同的探查，从用于在用户应用程序，内核探针等中检测函数调用的uprobe开始。</font></font><br>
<img src="https://habrastorage.org/webt/la/v4/zq/lav4zqiss3uj4a42cx9lf5cu9hs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有趣的是，自定义uprobe功能有一个uretprobe等效项。对于内核，相同的是kprobe和kretprobe。这意味着实际上，在跟踪框架中，您可以在调用函数时以及完成此函数时生成事件-这通常用于计时。或者您可以分析该函数返回的值并根据调用该函数的参数对其进行分组。如果捕获到一个函数调用并从中返回，则可以做很多很酷的事情。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在bpfTrace中，它的工作方式是这样的：我们编写了一个bpf程序，将其解析，转换为C，然后通过Clang处理，该程序会生成bpf字节代码，然后加载该程序。</font></font><br>
<img src="https://habrastorage.org/webt/2r/my/_i/2rmy_ipzm97oydg5q8xdltdbchs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该过程非常困难，因此存在局限性。</font><font style="vertical-align: inherit;">在功能强大的服务器上，bpfTrace可以很好地工作。</font><font style="vertical-align: inherit;">但是将Clang拖到一个小型嵌入式设备上以了解发生了什么不是一个好主意。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">帘布层</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">适合于此</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">当然，它不具有bpfTrace的所有功能，但可以直接生成字节码。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux支援</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
bpfTrace的稳定版本大约于一年前发布，因此在较旧的Linux发行版中不可用。</font><font style="vertical-align: inherit;">最好打包或编译IO Visor分发的最新版本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有趣的是，最新的Ubuntu LTS 18.04没有bpfTrace，但可以使用snap软件包进行交付。</font><font style="vertical-align: inherit;">一方面，这很方便，但是另一方面，由于制作和隔离snap包的方式，并非所有功能都可以使用。</font><font style="vertical-align: inherit;">对于内核跟踪，具有snap的程序包效果很好；对于用户跟踪，它可能无法正常工作。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d3/si/co/d3sicofnas8mpwyrsvmkp1kdbvm.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流程跟踪示例</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑最简单的示例，该示例使您可以获取有关IO请求的统计信息：</font></font><br>
<br>
<pre><code class="bash hljs">bpftrace -e <span class="hljs-string">'kprobe:vfs_read { @start[tid] = nsecs; }
kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); }'</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们连接到函数</font></font><code>vfs_read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kretprobe和kprobe。</font><font style="vertical-align: inherit;">此外，对于每个线程ID（tid），即对于每个请求，我们跟踪其执行的开始和结束。</font><font style="vertical-align: inherit;">数据不仅可以按整个系统的整体进行分组，还可以按不同的流程进行分组。</font><font style="vertical-align: inherit;">以下是MySQL的IO输出。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/e1/dx/om/e1dxomau1ormvas-7juk1as0sqy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
经典的双峰I / O分布可见。</font><font style="vertical-align: inherit;">大量快速请求是从缓存中读取的数据。</font><font style="vertical-align: inherit;">第二个高峰是从磁盘读取数据，而延迟要高得多。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以将其另存为脚本（通常使用bt扩展名），编写注释，对其进行格式化以及仅作进一步使用</font></font><code>#bpftrace read.bt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="bash hljs">// read.bt file<font></font>
tracepoint:syscalls:sys_enter_read<font></font>
{<font></font>
  @start[tid] = nsecs;<font></font>
}<font></font>
tracepoint:syscalls:sys_exit_read / @start[tid]/ <font></font>
{<font></font>
  @<span class="hljs-built_in">times</span> = hist(nsecs - @start[tid]);<font></font>
  delete(@start[tid]);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
语言的一般概念非常简单。</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语法：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择要连接的探针</font></font><code>probe[,probe,...] /filter/ { action }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过滤器：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定过滤器，例如，仅指定给定Pid的给定进程上的数据。</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行动：一个</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">微型程序，可以直接转换为bpf程序，并在调用bpfTrace时运行。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到更多详细信息</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bpftrace工具</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BpfTrace也有一个工具箱。</font><font style="vertical-align: inherit;">现在，在bpfTrace上实现了许多BCC上相当简单的工具。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dz/sr/f1/dzsrf1-klsvpjawbgtdzffgegra.png"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">馆藏</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仍然很小，但BCC中没有。</font><font style="vertical-align: inherit;">例如，killsnoop允许您跟踪kill（）引起的信号。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您有兴趣查看bpf代码，则可以在bpfTrace中通过</font></font><code>-v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看生成的字节代码。</font><font style="vertical-align: inherit;">如果您想了解繁重的调查，这很有用。</font><font style="vertical-align: inherit;">查看代码并估算其大小（一页或两页）后，您可以了解它的复杂性。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fo/sr/zg/fosrzgluhzrwsysvgvtsrkth8qe.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MySQL追踪范例</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我向您展示一个MySQL的示例，它如何工作。</font><font style="vertical-align: inherit;">MySQL具有</font></font><code>dispatch_command</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中所有MySQL查询执行都发生的功能。</font></font><br>
<br>
<pre><code class="bash hljs">bpftrace -e <span class="hljs-string">'uprobe:/usr/sbin/mysqld:dispatch_command { printf("%s\n", str(arg2)); }'</span>
failed to <span class="hljs-built_in">stat</span> uprobe target file /usr/sbin/mysqld: No such file or directory</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我只是想连接一个套子来打印MySQL的查询文本-这是一项原始任务。</font><font style="vertical-align: inherit;">遇到了问题-说没有这样的文件。</font><font style="vertical-align: inherit;">就像不在这里时一样：</font></font><br>
<br>
<pre><code class="xml hljs">root@mysql1:/# ls -la /usr/sbin/mysqld<font></font>
-rwxr-xr-x 1 root root 60718384 Oct 25 09:19 /usr/sbin/mysqld</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些只是一时的惊喜。</font><font style="vertical-align: inherit;">如果通过快照设置，则在应用程序级别可能会出现问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，我通过apt版本（较新的Ubuntu）重新安装：</font></font><br>
<br>
<pre><code class="xml hljs">root@mysql1:~# bpftrace -e 'uprobe:/usr/sbin/mysqld:dispatch_command { printf("%s\n", str(arg2)); }'<font></font>
Attaching 1 probe...<font></font>
Could not resolve symbol: /usr/sbin/mysqld:dispatch_command</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“没有这样的符号”-怎么不？</font><font style="vertical-align: inherit;">我查看</font></font><code>nm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是否有这样的符号：</font></font><br>
<br>
<pre><code class="xml hljs">root@mysql1:~# nm -D /usr/sbin/mysqld | grep dispatch_command<font></font>
00000000005af770 T <font></font>
_Z16dispatch_command19enum_server_commandP3THDPcjbb<font></font>
<font></font>
root@localhost:~# bpftrace -e 'uprobe:/usr/sbin/mysqld:_Z16dispatch_command19enum_server_commandP3THDPcjbb { printf("%s\n", str(arg2)); }'<font></font>
Attaching 1 probe...<font></font>
select @@version_comment limit 1<font></font>
select 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有这样的符号，但是由于MySQL是从C ++编译的，因此在其中使用了mangling。</font><font style="vertical-align: inherit;">实际上，此命令中使用的函数的当前名称如下：</font></font><code>_Z16dispatch_command19enum_server_commandP3THDPcjbb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果在函数中使用它，则可以连接并获取结果。</font><font style="vertical-align: inherit;">在perf生态系统中，许多工具可以使自动取消管理，而bpfTrace尚不支持。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外要注意的标志</font></font><code>-D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><code>nm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这很重要，因为MySQL和现在的许多其他软件包都没有动态符号（调试符号）-它们在其他软件包中。</font><font style="vertical-align: inherit;">如果要使用这些字符，则需要一个标志</font></font><code>-D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，否则nm将看不到它们。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有用的链接</font></font></b>
                        <div class="spoiler_text"><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/zoidbergwill/awesome-ebpf</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">slideplayer.com/slide/12710510</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.brendangregg.com/ebpf.html</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">vger.kernel.org/netconf2018_files/BrendanGregg_netconf2018.pdf</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.brendangregg.com/Slides/Velocity2017_BPF_superpowers.pdf</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">lwn.net/Articles/740157</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tracingsummit.org/w/images/8/82/Tracingsummit2018-bpftrace-robertson.pdf</a></li>
</ul></div>
                    </div><br>
<blockquote><i>   :</i>  ++ 25–26    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>        ,     .    ,       ,            . <br>
<br>
<i>   :</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">++ Online</a>   .       5 900        ,      ,        -.<br>
<br>
<i>   :</i>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DevOpsConf 2019</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HighLoad++ 2019</a> —   ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>. <br>
<br>
       — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>, . </blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN500446/index.html">关于R2DBC和PostgreSQL的几句话</a></li>
<li><a href="../zh-CN500448/index.html">Prometheus：通过Blackbox导出程序进行HTTP监视</a></li>
<li><a href="../zh-CN500450/index.html">用儿童合成器制作MIDI键盘</a></li>
<li><a href="../zh-CN500452/index.html">深度学习的高度推理</a></li>
<li><a href="../zh-CN500454/index.html">“什么码头？” 或者我们使用Xamarin（Android）上的移动应用程序通过蓝牙控制控制器</a></li>
<li><a href="../zh-CN500458/index.html">在线语音技术功能：入门包</a></li>
<li><a href="../zh-CN500462/index.html">检测场景变化并将h264视频剪辑保存到Raspberry Pi中而不进行解码</a></li>
<li><a href="../zh-CN500468/index.html">Java功能指南8-14</a></li>
<li><a href="../zh-CN500470/index.html">使您现有的业务解决方案适应SwiftUI。第3部分。使用体系结构</a></li>
<li><a href="../zh-CN500472/index.html">Python是时候腾出空间了。关于朱莉娅的前景</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>