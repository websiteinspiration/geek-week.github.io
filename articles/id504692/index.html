<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😲 🎅🏻 🤤 Dasar-Dasar ZFS: Penyimpanan dan Kinerja 😁 ❓ 👩‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada musim semi ini, kami telah membahas beberapa topik pengantar, seperti cara memeriksa kecepatan drive Anda dan apa itu RAID . Pada yang kedua dari...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Dasar-Dasar ZFS: Penyimpanan dan Kinerja</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504692/"><img src="https://habrastorage.org/getpro/habr/post_images/abf/883/e96/abf883e96b01dbc78420e0dc1a158460.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada musim semi ini, kami telah membahas beberapa topik pengantar, seperti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cara memeriksa kecepatan drive Anda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apa itu RAID</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pada yang kedua dari mereka, kami bahkan berjanji untuk terus mempelajari kinerja berbagai topologi multi-disk di ZFS. </font><font style="vertical-align: inherit;">Ini adalah sistem file generasi berikutnya yang sedang diterapkan di mana-mana: dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apple</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubuntu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nah, hari ini adalah hari terbaik untuk mengenal ZFS, pembaca yang ingin tahu. </font><font style="vertical-align: inherit;">Perlu diketahui bahwa, menurut penilaian konservatif oleh pengembang OpenZFS Matt Arens, "ini benar-benar rumit." </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi sebelum kita sampai ke angka - dan mereka akan, saya berjanji - untuk semua varian konfigurasi ZFS vosmidiskovoy, Anda perlu berbicara tentang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cara</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> melakukan ZFS menyimpan data pada disk.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zpool, vdev, dan perangkat</font></font></h1><br>
<img src="https://habrastorage.org/getpro/habr/post_images/674/1c6/ab3/6741c6ab310f4e0edf2adf7e2ca4c6bb.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diagram kumpulan lengkap ini mencakup tiga vdev tambahan, satu untuk setiap kelas, dan empat untuk RAIDz2. </font></font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b9f/82c/887/b9f82c88748c44d1f86cc412a053bf94.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biasanya tidak ada alasan untuk membuat </font></font></font></i><font style="vertical-align: inherit;"><i><font color="gray"><font style="vertical-align: inherit;">kumpulan </font></font></i><i><font color="gray"><font style="vertical-align: inherit;">jenis dan ukuran </font></font></i><i><font color="gray"><font style="vertical-align: inherit;">vdev yang </font></font></i><i><font color="gray"><font style="vertical-align: inherit;">tidak pantas - tetapi jika Anda mau, tidak ada yang menghalangi Anda untuk melakukan ini.</font></font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Untuk benar-benar memahami sistem file ZFS , Anda perlu hati-hati melihat struktur yang sebenarnya. </font><font style="vertical-align: inherit;">Pertama, ZFS menggabungkan level tradisional manajemen volume dan sistem file. </font><font style="vertical-align: inherit;">Kedua, ia menggunakan mekanisme salinan transaksional saat menulis. </font><font style="vertical-align: inherit;">Fitur-fitur ini berarti bahwa sistem secara struktural sangat berbeda dari sistem file biasa dan array RAID. </font><font style="vertical-align: inherit;">Set pertama blok bangunan dasar untuk dipahami: kumpulan penyimpanan (zpool), perangkat virtual (vdev), dan perangkat nyata (perangkat).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zpool</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kolam penyimpanan zpool adalah struktur ZFS teratas. Setiap kumpulan berisi satu atau lebih perangkat virtual. Pada gilirannya, masing-masing berisi satu atau lebih perangkat nyata (perangkat). Kolam virtual adalah blok otonom. Satu komputer fisik dapat berisi dua atau lebih kumpulan yang terpisah, tetapi masing-masingnya sepenuhnya independen dari yang lain. Pools tidak dapat berbagi perangkat virtual. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redundansi ZFS ada di level perangkat virtual, tetapi tidak di level pool. Pada level pool, sama sekali tidak ada redundansi - jika ada drive vdev atau vdev khusus hilang, maka seluruh pool hilang bersamaan dengannya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kumpulan penyimpanan modern dapat bertahan dari kehilangan cache atau log perangkat virtual - meskipun mereka dapat kehilangan sejumlah kecil data kotor jika kehilangan log vdev selama pemadaman listrik atau kerusakan sistem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada kesalahpahaman umum bahwa "pita data" (strip) ZFS direkam di seluruh kumpulan. Ini tidak benar. Zpool sama sekali bukan RAID0 yang menyenangkan, ini adalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JBOD yang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menyenangkan </font><font style="vertical-align: inherit;">dengan mekanisme distribusi yang kompleks dan dapat diubah.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagian besar, entri didistribusikan di antara perangkat virtual yang tersedia sesuai dengan ruang yang tersedia, sehingga secara teoritis semuanya akan terisi secara bersamaan. Dalam versi ZFS yang lebih baru, penggunaan saat ini (pemanfaatan) vdev diperhitungkan - jika satu perangkat virtual secara signifikan lebih dimuat daripada yang lain (misalnya, karena beban baca), itu akan sementara dilewati untuk ditulis, meskipun terdapat koefisien ruang bebas tertinggi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mekanisme deteksi daur ulang yang dibangun ke dalam metode distribusi catatan ZFS modern dapat mengurangi latensi dan meningkatkan throughput selama periode beban tinggi yang tidak biasa - tetapi ini bukan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">carte blanche</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tanpa campur tangan mencampur HDD lambat dan SSD cepat dalam satu kelompok. </font><font style="vertical-align: inherit;">Kumpulan yang tidak sama seperti itu masih akan bekerja pada kecepatan perangkat paling lambat, yaitu seolah-olah seluruhnya terdiri dari perangkat tersebut.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vdev</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap kumpulan penyimpanan terdiri dari satu atau lebih perangkat virtual (perangkat virtual, vdev). </font><font style="vertical-align: inherit;">Pada gilirannya, setiap vdev mencakup satu atau lebih perangkat nyata. </font><font style="vertical-align: inherit;">Sebagian besar perangkat virtual digunakan untuk menyimpan data dengan mudah, tetapi ada beberapa kelas vdev pembantu, termasuk CACHE, LOG, dan SPECIAL. </font><font style="vertical-align: inherit;">Masing-masing tipe vdev ini dapat memiliki satu dari lima topologi: perangkat tunggal, RAIDz1, RAIDz2, RAIDz3, atau mirror.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAIDz1, RAIDz2, dan RAIDz3 adalah variasi khusus dari apa yang orang tua sebut dengan RAID ganda (diagonal) paritas. 1, 2, dan 3 merujuk pada berapa banyak blok paritas yang dialokasikan untuk setiap pita data. Alih-alih memisahkan disk untuk paritas, perangkat RAIDz virtual mendistribusikan paritas ini secara merata di seluruh disk. Array RAIDz dapat kehilangan banyak disk karena memiliki blok paritas; jika dia kehilangan yang lain, dia akan gagal dan mengambil kolam penyimpanan dengannya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di perangkat virtual cermin (mirror vdev), setiap blok disimpan di setiap perangkat di vdev. Meskipun cermin dua-lebar yang paling umum, bisa ada jumlah perangkat yang sewenang-wenang di cermin - dalam instalasi besar, tiga yang sering digunakan untuk meningkatkan kinerja membaca dan toleransi kesalahan. Cermin vdev dapat bertahan dari kegagalan sementara setidaknya satu perangkat di vdev terus berfungsi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vdev tunggal pada dasarnya berbahaya. Perangkat virtual semacam itu tidak akan selamat dari kegagalan tunggal - dan jika digunakan sebagai penyimpanan atau vdev khusus, maka kegagalannya akan menyebabkan penghancuran seluruh kumpulan. Berhati-hatilah di sini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peralatan virtual CACHE, LOG, dan SPECIAL dapat dibuat menggunakan salah satu dari topologi yang tercantum di atas - tetapi ingat bahwa kehilangan alat virtual SPECIAL berarti kehilangan kumpulan, sehingga topologi yang berlebihan sangat disarankan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alat</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini mungkin istilah termudah untuk dipahami dalam ZFS - ini secara harfiah adalah perangkat akses blok acak. Ingatlah bahwa perangkat virtual terdiri dari perangkat individual, dan kumpulan ini terdiri dari perangkat virtual. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Disk - magnetic atau solid-state - adalah perangkat blok paling umum yang digunakan sebagai blok bangunan vdev. Namun, perangkat apa pun dengan pegangan di / dev cocok - sehingga Anda dapat menggunakan seluruh array RAID perangkat keras sebagai perangkat terpisah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File mentah sederhana adalah salah satu perangkat blok alternatif terpenting yang dapat dibangun dari vdev. Tes kolam dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file jarang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;- Cara yang sangat mudah untuk memeriksa perintah kumpulan dan melihat berapa banyak ruang yang tersedia di kumpulan atau perangkat virtual dari topologi ini. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/5cf/aa5/62c/5cfaa562cb208b654af113f7535b8f57.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat membuat kumpulan uji dari file jarang hanya dalam beberapa detik - tetapi jangan lupa untuk menghapus seluruh kumpulan dan komponen-komponennya nanti.</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Misalkan Anda ingin meletakkan server pada delapan disk dan berencana untuk menggunakan disk 10 TB (~ 9300 GiB) - tetapi Anda tidak yakin yang mana Topologi paling sesuai dengan kebutuhan Anda. Dalam contoh di atas, dalam hitungan detik kami membangun kumpulan uji dari file jarang - dan sekarang kita tahu bahwa RAIDz2 vdev dari delapan drive 10 TB menyediakan 50 TiB kapasitas yang berguna.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas khusus perangkat lain adalah SPARE (cadangan). Perangkat hot-swappable, tidak seperti perangkat konvensional, milik seluruh kumpulan, bukan hanya satu perangkat virtual. Jika beberapa vdev di pool gagal, dan perangkat cadangan terhubung ke pool dan tersedia, maka secara otomatis akan bergabung dengan vdev yang terpengaruh. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah tersambung ke vdev yang terpengaruh, perangkat cadangan mulai menerima salinan atau rekonstruksi data yang seharusnya ada di perangkat yang hilang. Dalam RAID tradisional, ini disebut pembangunan kembali, sedangkan di ZFS disebut "resilvering".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penting untuk dicatat bahwa perangkat pengganti tidak secara permanen menggantikan perangkat yang gagal. </font><font style="vertical-align: inherit;">Ini hanya pengganti sementara untuk mengurangi waktu di mana degradasi vdev diamati. </font><font style="vertical-align: inherit;">Setelah administrator mengganti perangkat vdev yang gagal, redundansi dikembalikan ke perangkat permanen ini, dan SPARE terputus dari vdev dan kembali berfungsi sebagai cadangan untuk seluruh kumpulan.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kumpulan Data, Blok, dan Sektor</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kumpulan blok bangunan berikutnya yang perlu Anda pahami dalam perjalanan kami melalui ZFS bukanlah perangkat keras yang banyak, tetapi bagaimana data disusun dan disimpan. </font><font style="vertical-align: inherit;">Kami melewati beberapa level di sini - seperti metaslab - agar tidak menumpuk detail sembari mempertahankan pemahaman tentang keseluruhan struktur.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Himpunan data</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/bd3/c48/d9d/bd3c48d9dff6e0f493a5d90d1dca6d1d.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat kami pertama kali membuat dataset, ini menunjukkan semua ruang pool yang tersedia. Kemudian kita mengatur kuota - dan mengubah titik mount. Sihir! </font></font></font></i> <br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a18/3de/210/a183de210cdc57cd1421652201cbf2c3.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zvol sebagian besar hanyalah sebuah dataset, tanpa lapisan sistem file-nya, yang kami ganti di sini dengan</font></font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
sistem file</font><i><font color="gray"><font style="vertical-align: inherit;"> ext4 yang benar-benar normal</font></font></i><font style="vertical-align: inherit;"> . ZFS dataset kira-kira sama dengan sistem file yang dipasang standar. Seperti sistem file biasa, sekilas tampaknya "hanya folder lain". Tetapi juga, seperti sistem file yang dipasang secara konvensional, setiap dataset ZFS memiliki set properti dasarnya sendiri.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama-tama, dataset mungkin memiliki kuota yang ditetapkan. Jika diinstal</font></font><code>zfs set quota=100G poolname/datasetname</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka Anda tidak dapat menulis ke folder yang terpasang</font></font><code>/poolname/datasetname</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lebih dari 100 GiB.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan ada - dan tidak adanya - garis miring di awal setiap baris? Setiap set data memiliki tempat masing-masing dalam hierarki ZFS dan hierarki mount sistem. Tidak ada garis miring utama dalam hierarki ZFS - Anda mulai dengan nama kumpulan, dan kemudian jalur dari satu kumpulan data ke yang berikutnya. Misalnya, </font></font><code>pool/parent/child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk dataset yang disebutkan di </font></font><code>child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bawah dataset induk </font></font><code>parent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam </font><font style="vertical-align: inherit;">kumpulan </font><font style="vertical-align: inherit;">dengan nama kreatif </font></font><code>pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara default, mount point dari dataset akan setara dengan namanya dalam hirarki ZFS, dengan garis miring di awal - kolam renang dengan nama ini </font></font><code>pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dipasang sebagai </font></font><code>/pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dataset yang </font></font><code>parent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dipasang pada </font></font><code>/pool/parent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan anak </font><font style="vertical-align: inherit;">dataset </font><font style="vertical-align: inherit;">dipasang </font></font><code>child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di </font></font><code>/pool/parent/child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Namun, titik pemasangan sistem untuk dataset dapat diubah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kami menunjukkan</font></font><code>zfs set mountpoint=/lol pool/parent/child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka set data </font></font><code>pool/parent/child</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dipasang di sistem sebagai </font></font><code>/lol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain dataset, kita harus menyebutkan volume (zvol). </font><font style="vertical-align: inherit;">Volume kira-kira mirip dengan kumpulan data, kecuali bahwa sebenarnya tidak memiliki sistem file - itu hanya perangkat blok. </font><font style="vertical-align: inherit;">Anda dapat, misalnya, membuat </font></font><code>zvol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan nama </font></font><code>mypool/myzvol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lalu memformatnya dengan sistem file ext4, dan kemudian me-mount sistem file ini - sekarang Anda memiliki sistem file ext4, tetapi dengan dukungan untuk semua fitur keamanan ZFS! </font><font style="vertical-align: inherit;">Ini mungkin tampak konyol di satu komputer, tetapi jauh lebih masuk akal sebagai backend ketika mengekspor perangkat iSCSI.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blok</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/74b/4dd/d00/74b4ddd009e67db1b1b6c4467bcf6fa3.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">File diwakili oleh satu atau lebih blok. Setiap blok disimpan pada satu perangkat virtual. Ukuran blok biasanya sama dengan parameter </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recordsize</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi dapat dikurangi menjadi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 ^ ashift</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jika berisi metadata atau file kecil. </font></font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8d1/7fd/ad2/8d17fdad2eda641c801e5e6a302f6e38.png"><br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami benar- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak bergurau tentang kerusakan kinerja yang sangat besar jika Anda memasang ashift yang terlalu kecil</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Di</font><i><font color="gray"><font style="vertical-align: inherit;"> kumpulan</font></font></i><font style="vertical-align: inherit;"> ZFS, semua data, termasuk metadata, disimpan dalam blok. Ukuran blok maksimum untuk setiap set data ditentukan dalam properti</font></font><code>recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ukuran rekaman). Ukuran catatan dapat bervariasi, tetapi ini tidak akan mengubah ukuran atau lokasi blok apa pun yang telah ditulis ke dataset - itu hanya valid untuk blok baru seperti yang ditulis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kecuali ditentukan lain, ukuran perekaman saat ini adalah 128 KiB secara default. Ini adalah semacam kompromi yang sulit di mana kinerja tidak akan ideal, tetapi tidak buruk dalam banyak kasus. </font></font><code>Recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat diatur ke nilai apa pun dari 4K hingga 1M (dengan pengaturan tambahan </font></font><code>recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat mengatur lebih banyak lagi, tetapi ini jarang merupakan ide yang bagus). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Blok apa pun merujuk ke data hanya satu file - Anda tidak dapat memeras dua file berbeda menjadi satu blok. Setiap file terdiri dari satu atau lebih blok, tergantung pada ukurannya. Jika ukuran file lebih kecil dari ukuran record, itu akan disimpan dalam blok yang lebih kecil - misalnya, blok dengan file 2 KiB akan menempati hanya satu sektor 4 KiB pada disk. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika file cukup besar dan membutuhkan beberapa blok, maka semua catatan dengan file ini akan memiliki ukuran</font></font><code>recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;- termasuk catatan terakhir, bagian utama yang dapat berubah menjadi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ruang yang tidak digunakan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Volume Zvol tidak memiliki properti </font></font><code>recordsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;- sebaliknya mereka memiliki properti yang setara </font></font><code>volblocksize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sektor</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Blok bangunan terakhir yang paling mendasar adalah sektor ini. Ini adalah unit fisik terkecil yang dapat ditulis atau dibaca dari unit dasar. Selama beberapa dekade, sebagian besar disk menggunakan sektor 512-byte. Baru-baru ini, sebagian besar drive dikonfigurasikan untuk 4 sektor KiB, dan di beberapa - terutama SSD - 8 sektor KiB atau bahkan lebih. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFS memiliki properti yang memungkinkan Anda untuk mengatur ukuran sektor secara manual. Ini properti </font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Agak membingungkan bahwa ashift adalah kekuatan dua. Misalnya, ini </font></font><code>ashift=9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berarti ukuran sektor 2 ^ 9, atau 512 byte.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFS meminta sistem operasi untuk informasi terperinci tentang setiap perangkat blok ketika ditambahkan ke vdev baru, dan secara teoritis secara otomatis menyetel ashift dengan benar berdasarkan informasi ini. Sayangnya, banyak disk berbohong tentang ukuran sektor mereka untuk menjaga kompatibilitas dengan Windows XP (yang tidak dapat memahami disk dengan ukuran sektor lainnya). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini berarti bahwa administrator ZFS sangat disarankan untuk mengetahui ukuran sektor aktual dari perangkat mereka dan menginstal secara manual</font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jika terlalu kecil ashift diatur, maka jumlah operasi baca / tulis secara astronomis meningkat. Jadi, menulis "sektor" 512-byte ke sektor 4 KiB nyata berarti menulis "sektor" pertama, kemudian membaca sektor 4 KiB, mengubahnya dengan "sektor" 512-byte kedua, menuliskannya kembali ke sektor 4 KiB yang baru, dan seterusnya untuk setiap entri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di dunia nyata, hukuman seperti itu mengalahkan Samsung EVO </font></font><code>ashift=13</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSD </font><font style="vertical-align: inherit;">, yang harus ditindaklanjuti </font><font style="vertical-align: inherit;">, tetapi SSD ini terletak pada ukuran sektornya, dan karenanya diatur secara default </font></font><code>ashift=9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jika administrator sistem yang berpengalaman tidak mengubah pengaturan ini, maka SSD ini </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lebih lambat daripada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HDD magnetik biasa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai perbandingan, untuk ukuran yang terlalu besar</font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hampir tidak ada penalti. </font><font style="vertical-align: inherit;">Tidak ada penurunan nyata dalam produktivitas, dan peningkatan ruang yang tidak digunakan sangat kecil (atau sama dengan nol dengan kompresi diaktifkan). </font><font style="vertical-align: inherit;">Oleh karena itu, kami sangat menyarankan agar drive yang benar-benar menggunakan sektor 512-byte diinstal </font></font><code>ashift=12</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau bahkan </font></font><code>ashift=13</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk melihat dengan percaya diri ke masa depan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Properti </font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diatur untuk setiap perangkat virtual vdev, dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bukan untuk pool</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , karena banyak orang berpikir keliru - dan tidak berubah setelah instalasi. </font><font style="vertical-align: inherit;">Jika Anda secara tidak sengaja terjatuh </font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ketika menambahkan vdev baru ke kolam, maka Anda mencemari kolam ini dengan perangkat berkinerja rendah dan, sebagai aturan, tidak ada cara lain selain menghancurkan kolam dan memulai dari awal lagi. </font><font style="vertical-align: inherit;">Bahkan menghapus vdev tidak akan menyelamatkan Anda dari pengaturan yang rusak</font></font><code>ashift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">!</font></font><br>
<br>
<h3>   </h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/38b/a1e/4a8/38ba1e4a8fa0e255081ed8db259a302f.gif"><br>
<i><font color="gray">      &nbsp;—     ,   </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/90d/4cb/a35/90d4cba35ffa5a3e44a7ca5f61d4491b.gif"><br>
<i><font color="gray">         ,     </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/c8b/2af/ffb/c8b2afffbc46f63f6a7fe1167edf5dcb.gif"><br>
<i><font color="gray">  ,      ,   « »   « »,        </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4c1/e2b/818/4c1e2b818077cb07d651527e214363fe.gif"><br>
<i><font color="gray">     ,       —      ,     ,       </font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Copy on Write (CoW) adalah fondasi dasar dari apa yang membuat ZFS luar biasa. Konsep dasarnya sederhana - jika Anda meminta sistem file tradisional untuk memodifikasi file, itu akan melakukan persis apa yang Anda minta. Jika Anda meminta sistem file dengan menyalin selama perekaman untuk melakukan hal yang sama, itu akan mengatakan "baik" - tetapi itu akan berbohong kepada Anda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai gantinya, sistem file salin-tulis menulis versi baru dari blok yang dimodifikasi, dan kemudian memperbarui metadata file untuk memutus koneksi dengan blok lama dan mengaitkan blok baru yang baru saja Anda tulis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memutuskan sambungan unit lama dan menghubungkan yang baru dilakukan dalam satu operasi, sehingga tidak dapat terganggu - jika Anda mengatur ulang daya setelah ini terjadi, Anda memiliki versi file yang baru, dan jika Anda mengatur ulang daya lebih awal, maka Anda memiliki versi yang lama. </font><font style="vertical-align: inherit;">Bagaimanapun, tidak akan ada konflik dalam sistem file. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menyalin ketika menulis ke ZFS terjadi tidak hanya di level sistem file, tetapi juga di level manajemen disk. </font><font style="vertical-align: inherit;">Ini berarti bahwa ZFS tidak tunduk pada ruang dalam catatan ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lubang di RAID</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - sebuah fenomena ketika strip hanya berhasil merekam sebagian sebelum sistem crash, dengan array rusak setelah reboot. </font><font style="vertical-align: inherit;">Di sini strip adalah atom, vdev selalu konsisten, dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bob adalah pamanmu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZIL: ZFS Intent Log</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/567/71c/73f/56771c73f9a28ebaed161e02313deadb.png"><br>
<i><font color="gray"> ZFS     &nbsp;—  ,      ZIL,            </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/cec/7c5/437/cec7c5437087f6816f9cdea5f6829820.png"><br>
<i><font color="gray"> ,   ZIL,    .      </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/075/65a/d6b/07565ad6b2f431db3e6bc20cd24a653b.png"><br>
<i><font color="gray">SLOG,   LOG-, —   &nbsp;— , ,  &nbsp;—&nbsp;vdev,  ZIL      </font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/927/0f7/539/9270f7539b759aa37896d41e04c4ec47.png"><br>
<i><font color="gray">      ZIL &nbsp;—    ZIL   SLOG,      </font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada dua kategori utama operasi tulis - sinkron (sinkron) dan asinkron (async). Untuk sebagian besar beban kerja, sebagian besar operasi penulisan tidak sinkron - sistem file memungkinkan Anda untuk menggabungkannya dan mengirimkannya dalam batch, mengurangi fragmentasi dan meningkatkan throughput secara signifikan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rekaman sinkron adalah hal yang sangat berbeda. Ketika suatu aplikasi meminta penulisan yang sinkron, ia memberi tahu sistem file: "Anda harus melakukan ini pada memori yang tidak mudah menguap </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sekarang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan sampai saat itu saya tidak bisa berbuat apa-apa lagi." Oleh karena itu, rekaman sinkron harus segera dilakukan ke disk - dan jika itu meningkatkan fragmentasi atau mengurangi bandwidth, maka jadilah itu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFS memproses catatan sinkron secara berbeda dari sistem file biasa - alih-alih segera mengunggahnya ke penyimpanan biasa, ZFS mencatatnya di area penyimpanan khusus yang disebut log maksud ZFS - ZFS Intent Log, atau ZIL. Kuncinya adalah bahwa catatan-catatan ini </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juga</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tetap ada dalam memori, yang dikumpulkan bersama dengan permintaan tulis asinkron biasa, untuk kemudian dibuang ke penyimpanan sebagai TXG yang sangat normal (Grup Transaksi, Grup Transaksi). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam operasi normal, ZIL direkam dan tidak pernah dibaca lagi. Ketika, setelah beberapa saat, rekaman dari ZIL diperbaiki di penyimpanan utama dalam TXG biasa dari RAM, mereka terputus dari ZIL. Satu-satunya hal ketika sesuatu dibaca dari ZIL adalah saat mengimpor kolam.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika ZFS lumpuh - sistem operasi mogok atau pemadaman listrik - ketika ada data di ZIL, data ini akan dibaca selama impor kumpulan berikutnya (misalnya, ketika sistem darurat dimulai kembali). Segala sesuatu yang ada di ZIL akan dibaca, digabungkan ke dalam grup TXG, berkomitmen untuk penyimpanan utama, dan kemudian diputuskan dari ZIL selama proses impor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu kelas pembantu vdev disebut LOG atau SLOG, perangkat LOG sekunder. Dia memiliki satu tugas - untuk menyediakan kumpulan dengan perangkat vdev yang terpisah dan, lebih disukai, lebih cepat, dengan resistensi yang sangat tinggi, untuk menyimpan ZIL, alih-alih menyimpan ZIL dalam penyimpanan vdev utama. ZIL sendiri berperilaku sama terlepas dari lokasi penyimpanan, tetapi jika vdev dengan LOG memiliki kinerja penulisan yang sangat tinggi, maka penulisan sinkron akan lebih cepat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menambahkan vdev dengan LOG ke kumpulan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak dapat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> meningkatkan kinerja penulisan asinkron - bahkan jika Anda memaksa semua penulisan ke ZIL dengan </font></font><code>zfs set sync=always</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mereka masih akan terikat ke repositori utama di TXG dengan cara yang sama dan pada kecepatan yang sama seperti tanpa log. </font><font style="vertical-align: inherit;">Satu-satunya peningkatan kinerja langsung adalah penundaan dalam perekaman sinkron (karena kecepatan log yang lebih tinggi mempercepat operasi </font></font><code>sync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, dalam lingkungan yang sudah membutuhkan sejumlah besar penulisan sinkron, vdev LOG dapat secara tidak langsung mempercepat penulisan asinkron dan bacaan tanpa-cache. </font><font style="vertical-align: inherit;">Mengunggah catatan ZIL ke vdev LOG terpisah berarti lebih sedikit kompetisi untuk IOPS di penyimpanan utama, yang pada tingkat tertentu meningkatkan kinerja semua operasi baca dan tulis.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jepretan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mekanisme copy copy juga merupakan fondasi penting untuk snapshot ZFS atom dan replikasi asinkron tambahan. </font><font style="vertical-align: inherit;">Sistem file aktif memiliki pohon penunjuk yang menandai semua catatan dengan data saat ini - ketika Anda mengambil snapshot, Anda cukup membuat salinan pohon penunjuk ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika catatan ditimpa dalam sistem file aktif, ZFS pertama menulis versi baru dari blok ke ruang yang tidak terpakai. </font><font style="vertical-align: inherit;">Itu kemudian melepaskan versi lama dari blok dari sistem file saat ini. </font><font style="vertical-align: inherit;">Tetapi jika beberapa snapshot mengacu pada blok lama, itu tetap tidak berubah. </font><font style="vertical-align: inherit;">Blok lama tidak akan benar-benar dikembalikan sebagai ruang kosong sampai semua foto yang tertaut ke blok ini dihancurkan!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Replikasi</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/e69/167/01d/e6916701d4aa3ff27bb42efc43be60da.png"><br>
<i><font color="gray">  Steam  2015   158&nbsp;   126&nbsp;927 .        rsync&nbsp;—  ZFS    « »  750% .</font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/25f/376/0ab/25f3760ab64d6647571b9c02804b39f0.png"><br>
<i><font color="gray">      40-     Windows 7&nbsp;—   .  ZFS   289  ,  rsync&nbsp;—  «»  161  ,    ,   rsync   --inplace.</font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/776/46b/a3a/77646ba3ac20eeb0933d7dc7d644296c.png"><br>
<i><font color="gray">    ,  rsync    .  1,9         &nbsp;—    ,   ZFS   1148  ,  rsync,    rsync --inplace</font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah Anda memahami cara kerja snapshot, mudah untuk memahami inti dari replikasi. Karena snapshot adalah hanya pohon pointer ke catatan, maka jika kita membuat </font></font><code>zfs send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">snapshot, maka kita mengirim pohon ini dan semua catatan yang terkait dengannya. Ketika kami melewati ini </font></font><code>zfs send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di </font></font><code>zfs receive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke objek sasaran, itu menulis baik isi sebenarnya dari blok dan pohon pointer yang referensi blok ke set data sasaran. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya menjadi lebih menarik di detik </font></font><code>zfs send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sekarang kami memiliki dua sistem, yang masing-masing berisi </font></font><code>poolname/datasetname@1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan Anda mengambil snapshot baru </font></font><code>poolname/datasetname@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Oleh karena itu, di kumpulan sumber yang Anda miliki </font></font><code>datasetname@1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>datasetname@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan di kumpulan target sejauh ini hanya snapshot pertama </font></font><code>datasetname@1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena kita memiliki snapshot umum antara sumber dan target</font></font><code>datasetname@1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kita bisa melakukan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incremental</font></font></i> <code>zfs send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di atasnya. Saat kami memberi tahu sistem </font></font><code>zfs send -i poolname/datasetname@1 poolname/datasetname@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ia membandingkan dua pohon pointer. Pointer apa pun yang ada hanya di </font></font><code>@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jelas, merujuk ke blok baru - jadi kita perlu isi dari blok ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada sistem jarak jauh, pemrosesan tambahan </font></font><code>send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sama mudahnya. Pertama, kami merekam semua entri baru yang termasuk dalam aliran </font></font><code>send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kemudian menambahkan pointer ke blok ini. Voila, dalam </font></font><code>@2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistem baru </font><font style="vertical-align: inherit;">kami </font><font style="vertical-align: inherit;">! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Replikasi incremental asinkron ZFS adalah peningkatan besar dibandingkan metode non-snapshot sebelumnya seperti rsync. Dalam kedua kasus, hanya data yang berubah yang dikirimkan - tetapi rsync harus terlebih dahulu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membaca</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari disk semua data di kedua sisi untuk memeriksa jumlah dan membandingkannya. </font><font style="vertical-align: inherit;">Sebaliknya, replikasi ZFS hanya membaca pohon pointer - dan semua blok yang tidak terwakili dalam snapshot umum.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompresi sebaris</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mekanisme tulis-salin juga menyederhanakan sistem kompresi bawaan. Dalam sistem file tradisional, kompresi bermasalah - baik versi lama dan versi baru dari data yang diubah berada di ruang yang sama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda mempertimbangkan sepotong data di tengah file yang memulai kehidupannya sebagai megabyte nol mulai 0x00000000 dan seterusnya - sangat mudah untuk mengompresnya ke satu sektor pada disk. Tetapi apa yang terjadi jika kita mengganti megabyte nol ini dengan megabyte data yang tidak dapat dikompres seperti JPEG atau pseudo-random noise? Tiba-tiba, megabyte data ini tidak hanya membutuhkan satu, tetapi 256 sektor dengan 4 KiB, dan di tempat ini pada disk hanya satu sektor yang dicadangkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFS tidak memiliki masalah seperti itu, karena catatan yang diubah selalu ditulis ke ruang yang tidak digunakan - blok asli hanya menempati satu sektor 4 KiB, dan catatan baru akan mengambil 256, tetapi ini bukan masalah - fragmen yang baru saja diubah dari "tengah" file akan ditulis ke ruang yang tidak digunakan terlepas dari apakah ukurannya telah berubah atau tidak, jadi untuk ZFS ini adalah situasi yang normal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompresi ZFS bawaan dinonaktifkan secara default, dan sistem menawarkan algoritma plug-in - sekarang di antaranya adalah LZ4, gzip (1-9), LZJB dan ZLE.</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LZ4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah algoritma streaming yang menawarkan kompresi dan dekompresi yang sangat cepat dan keuntungan kinerja untuk kebanyakan kasus penggunaan - bahkan pada CPU yang cukup lambat.</font></font><br>
</li>
<li><b>GZIP</b> —  ,       Unix-.        1-9,       CPU      9.       (   )  ,    &nbsp;   c CPU&nbsp;—    ,     .<br>
</li>
<li><b>LZJB</b> —    ZFS.       , LZ4     .<br>
</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZLE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - pengodean level nol, Pengodean Tingkat Nol. </font><font style="vertical-align: inherit;">Itu tidak menyentuh data normal sama sekali, tetapi kompres urutan nol besar. </font><font style="vertical-align: inherit;">Berguna untuk kumpulan data yang sepenuhnya tidak dapat dimampatkan (misalnya, JPEG, MP4, atau format lain yang sudah dikompresi), karena mengabaikan data yang tidak dapat dimampatkan, tetapi memampatkan ruang yang tidak digunakan dalam catatan yang dihasilkan.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami merekomendasikan kompresi LZ4 untuk hampir semua kasus penggunaan; </font><font style="vertical-align: inherit;">Hukuman kinerja untuk menghadapi data yang mampat sangat kecil, dan </font><font style="vertical-align: inherit;">kinerja </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keuntungan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk data khas adalah signifikan. </font><font style="vertical-align: inherit;">Menyalin gambar mesin virtual untuk instalasi baru sistem operasi Windows (OS yang baru diinstal, belum ada data di dalamnya) dengan </font></font><code>compression=lz4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lulus 27% lebih cepat daripada dengan </font></font><code>compression=none</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tes 2015 ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARC - cache pengganti adaptif</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ZFS adalah satu-satunya sistem file modern yang kita ketahui yang menggunakan mekanisme caching baca sendiri, dan tidak mengandalkan cache halaman sistem operasi untuk menyimpan salinan blok yang baru dibaca dalam RAM. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meskipun cache sendiri bukan tanpa masalah - ZFS tidak dapat menanggapi permintaan alokasi memori baru secepat kernel, sehingga panggilan </font></font><code>malloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alokasi memori </font><font style="vertical-align: inherit;">baru </font><font style="vertical-align: inherit;">mungkin gagal jika membutuhkan RAM yang saat ini ditempati oleh ARC. </font><font style="vertical-align: inherit;">Tetapi ada alasan bagus untuk menggunakan cache Anda sendiri, setidaknya untuk saat ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua sistem operasi modern yang terkenal, termasuk MacOS, Windows, Linux dan BSD, menggunakan algoritma LRU (Paling Baru Digunakan) untuk mengimplementasikan halaman cache. Ini adalah algoritma primitif yang menaikkan blok cache “naik antrian” setelah setiap pembacaan dan mendorong blok “turun antrian” sebagaimana diperlukan untuk menambahkan kesalahan cache yang baru (blok yang seharusnya dibaca dari disk, bukan dari cache) naik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biasanya, algoritme berfungsi dengan baik, tetapi pada sistem dengan dataset kerja yang besar, LRU dengan mudah mengarah ke thrashing - crowding out blok yang sering dibutuhkan untuk memberikan ruang bagi blok yang tidak akan pernah dibaca dari cache lagi. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUSUR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;- Algoritma yang jauh lebih naif, yang dapat dianggap sebagai cache "tertimbang". Setelah setiap pembacaan blok yang di-cache, itu menjadi sedikit "lebih berat" dan menjadi lebih sulit untuk keluar - dan bahkan setelah crowding out blok </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dilacak</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk periode waktu tertentu. Blok yang telah diperas tetapi kemudian perlu dibaca kembali ke cache juga akan menjadi "lebih berat".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasil akhir dari semua ini adalah cache dengan hit rasio yang jauh lebih besar - rasio antara hit dalam cache (baca dari cache) dan meleset (baca dari disk). </font><font style="vertical-align: inherit;">Ini adalah statistik yang sangat penting - tidak hanya cache mengenai pesanan layanan mereka sendiri yang lebih cepat, kesalahan cache juga dapat dilayani lebih cepat, karena semakin banyak cache hit, semakin sedikit permintaan disk secara bersamaan dan semakin sedikit penundaan untuk sisa kesalahan yang harus dilayani dengan mendorong.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah mempelajari semantik dasar ZFS - cara menyalin berfungsi saat menulis, serta hubungan antara kumpulan penyimpanan, perangkat virtual, blok, sektor, dan file - kami siap untuk mendiskusikan kinerja nyata dengan angka nyata. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada bagian selanjutnya, kita akan melihat kinerja aktual dari pool dengan mirror vdev dan RAIDz, dibandingkan satu sama lain, serta dibandingkan dengan topologi kernel Linux tradisional RAID, yang telah kita periksa </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebelumnya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada awalnya kami ingin mempertimbangkan hanya dasar-dasar - topologi ZFS sendiri - tetapi setelah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami akan siap untuk berbicara tentang penyetelan dan penyetelan ZFS yang lebih maju, termasuk penggunaan tipe vdev tambahan seperti L2ARC, SLOG dan Alokasi Khusus.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id504680/index.html">Gambaran Umum Perpustakaan NLP SpaL</a></li>
<li><a href="../id504682/index.html">Nostalgia Post: j2me, Gravity Defied, 64kb</a></li>
<li><a href="../id504686/index.html">Cara menggambar kucing</a></li>
<li><a href="../id504688/index.html">Topeng tidak berguna: kritik ilmiah terhadap kebijakan sosial di KOVID-19</a></li>
<li><a href="../id504690/index.html">Kisah Bagaimana Saya Mengkonfigurasi Azure AD B2C pada Bereaksi dan Bereaksi Asli Bagian 3 (Tutorial)</a></li>
<li><a href="../id504694/index.html">Cara mengkompilasi dekorator - C ++, Python dan implementasinya sendiri. Bagian 1</a></li>
<li><a href="../id504696/index.html">Berita dari dunia OpenStreetMap No. 513 (12.05.2020-18.05.2020)</a></li>
<li><a href="../id504698/index.html">Onboarding di situs jarak jauh</a></li>
<li><a href="../id504700/index.html">"Sketsa" tablet grafis Soviet</a></li>
<li><a href="../id504702/index.html">Orang tidak mau tahu bahasa Inggris</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>