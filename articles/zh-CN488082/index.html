<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎱 👩‍👧‍👦 🈳 简而言之：.NET中的Async / Await最佳实践 ✝️ 👨🏻‍🏫 ☸️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="预期课程的开始，“ C＃Developer”准备了一些有趣的材料的翻译。
 
 
 
 异步/等待-简介
 Async / Await语言构造自C＃版本5.0（2012）开始存在，并迅速成为现代.NET编程的支柱之一-任何自重的C＃开发人员都应使用它来提高应用程序性能，整体响应能力和代码可读性。
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>简而言之：.NET中的Async / Await最佳实践</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/488082/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预期课程的开始，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ C＃Developer”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">准备了一些有趣的材料的翻译。</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/6f/io/l8/6fiol8vwkg-r8ja-3zurutnz-ci.png"><br>
<hr><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步/等待-简介</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Async / Await语言构造自C＃版本5.0（2012）开始存在，并迅速成为现代.NET编程的支柱之一-任何自重的C＃开发人员都应使用它来提高应用程序性能，整体响应能力和代码可读性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Async / Await使引入异步代码的过程变得异常简单，并且不需要程序员了解其处理细节，但是我们当中有多少人真正知道它的工作原理，这种方法的优点和缺点是什么？</font><font style="vertical-align: inherit;">有很多有用的信息，但是它们是零散的，所以我决定写这篇文章。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，让我们深入研究该主题。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态机（IAsyncStateMachine）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您需要了解的第一件事是，每当您使用Async / Await获得方法或函数时，编译器实际上会将您的方法转换为生成的类，该类实现IAsyncStateMachine接口。此类负责在异步操作的生命周期内维护方法的状态-它以字段的形式封装方法的所有变量，并将您的代码分成在状态机在状态之间转换时执行的部分，以便线程可以离开方法以及何时离开方法。将返回，状态不会改变。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，这是一个非常简单的类定义，其中包含两个异步方法：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
using System.Threading.Tasks;</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Diagnostics;<font></font>
<font></font>
<span class="hljs-keyword">namespace</span> <span class="hljs-title">AsyncAwait</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AsyncAwait</span><font></font>
    {<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncAwaitExample</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">int</span> myVariable = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">await</span> DummyAsyncMethod();<font></font>
            Debug.WriteLine(<span class="hljs-string">"Continuation - After First Await"</span>);<font></font>
            myVariable = <span class="hljs-number">1</span>;<font></font>
<font></font>
            <span class="hljs-keyword">await</span> DummyAsyncMethod();<font></font>
            Debug.WriteLine(<span class="hljs-string">"Continuation - After Second Await"</span>);<font></font>
            myVariable = <span class="hljs-number">2</span>;<font></font>
<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">DummyAsyncMethod</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-comment">// </span><font></font>
        }<font></font>
<font></font>
    }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有两个异步方法的类</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
如果我们看一下在汇编过程中生成的代码，我们将看到以下内容：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qo/xe/63/qoxe63foidhmllsdwfi78tdhrsm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意，我们为我们生成了2个新的内部类，每个异步方法一个。这些类包含每个异步方法的状态机。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，在研究了的反编译代码之后</font></font><code><code>&lt;AsyncAwaitExample&gt;</code></code><code> d__0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们将注意到我们的内部变量</font></font><code>«myVariable»</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在是一个类字段：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/_m/qj/gd_mqjxvsjfw9-_zfd7740n42ua.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们还可以看到内部用于维护state的其他类字段</font></font><code>IAsyncStateMachine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。状态机使用以下方法来检查状态</font></font><code>MoveNext()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，实际上是一个很大的开关。</font><font style="vertical-align: inherit;">请注意，在每个异步调用（带有上一个继续标签）之后，该方法如何在不同的部分继续进行。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/km/li/ea/kmlieahswg0ebqn3db5nctfzsti.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这意味着异步/等待优雅是有代价的。</font><font style="vertical-align: inherit;">使用异步/等待实际上会增加一些复杂性（您可能没有意识到）。</font><font style="vertical-align: inherit;">在服务器端逻辑中，这可能并不重要，但是特别是在编写考虑每个CPU和KB内存周期的移动应用程序时，请牢记这一点，因为开销会迅速增加。</font><font style="vertical-align: inherit;">在本文的后面，我们将讨论仅在必要时使用Async / Await的最佳实践。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有关状态机的说明性说明，请</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">在YouTube上</font></a><font style="vertical-align: inherit;">观看此</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何时使用异步/等待</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常在两种情况下，“异步/等待”是正确的解决方案。</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与I / O相关的工作</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：您的代码将期望某些东西，例如来自数据库的数据，读取文件，调用Web服务。</font><font style="vertical-align: inherit;">在这种情况下，您应该使用异步/等待，而不是任务并行库。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与CPU相关的工作</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：您的代码将执行复杂的计算。</font><font style="vertical-align: inherit;">在这种情况下，您应该使用Async / Await，但是您需要使用Task.Run在另一个线程中开始工作。</font><font style="vertical-align: inherit;">您也可以考虑使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task Parallel Library</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br>
<hr><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一路异步</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当您开始使用异步方法时，您会很快注意到代码的异步性质开始在您的调用层次结构中上下扩散-这意味着您还必须使调用代码异步，依此类推。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可能很想通过使用Task.Result或Task.Wait阻止代码，转换应用程序的一小部分并将其包装在同步API中来“阻止”此操作，以便使应用程序的其余部分不受更改的影响。不幸的是，这是造成难以跟踪的死锁的秘诀。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解决此问题的最佳方法是允许异步代码在代码库中自然增长。</font><font style="vertical-align: inherit;">如果遵循此决定，您将看到异步代码到其入口点的扩展，通常是事件处理程序或控制器操作。</font><font style="vertical-align: inherit;">屈服于异步！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有关</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MSDN </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">文章的</font></a><font style="vertical-align: inherit;">更多信息</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果该方法声明为异步，请确保有一个等待！</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正如我们所讨论的，当编译器找到异步方法时，它将把该方法转换为状态机。</font><font style="vertical-align: inherit;">如果您的代码中没有等待代码，则编译器将生成警告，但仍会创建状态机，从而为永远无法完成的操作增加不必要的开销。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">避免异步无效</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
异步无效是应该真正避免的事情。</font><font style="vertical-align: inherit;">将使用异步任务而不是异步void设为规则。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AsyncVoidMethod</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">//!</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncTaskMethod</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">//!</span>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步void和异步Task方法的</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
原因有很多，其中包括：</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步void方法中引发的异常无法在此方法之外捕获</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font></li>
</ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从异步Task或异步Task </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">引发</font><font style="vertical-align: inherit;">异常时，将捕获此异常并将其放置在Task对象中。</font><font style="vertical-align: inherit;">使用异步void方法时，不存在Task对象，因此，将从异步void方法引发的任何异常直接在启动异步void方法时处于活动状态的SynchronizationContext中调用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑下面的示例。</font><font style="vertical-align: inherit;">捕获块将永远不会到达。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AsyncVoidMethodThrowsException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"Hmmm, something went wrong!"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ThisWillNotCatchTheException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">try</span><font></font>
    {<font></font>
        AsyncVoidMethodThrowsException();<font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span>(Exception ex)<font></font>
    {<font></font>
        <span class="hljs-comment">//     </span><font></font>
        Debug.WriteLine(ex.Message);<font></font>
    }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步void方法中引发的异常无法在此方法之外捕获，</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
与此代码进行比较，其中有异步Task而不是异步void。</font><font style="vertical-align: inherit;">在这种情况下，渔获量将达到。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncTaskMethodThrowsException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"Hmmm, something went wrong!"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">ThisWillCatchTheException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">try</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> AsyncTaskMethodThrowsException();<font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span> (Exception ex)<font></font>
    {<font></font>
        <span class="hljs-comment">//    </span><font></font>
        Debug.WriteLine(ex.Message);<font></font>
    }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">捕获异常并将其放置在Task对象中。</font></font></i><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果调用方不希望异步方法无效，则异步void方法可能会导致不良的副作用</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：如果您的异步方法未返回任何内容，请使用异步Task（</font><font style="vertical-align: inherit;">对于Task，</font><font style="vertical-align: inherit;">不带“ </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">”）作为返回类型。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步void方法非常难以测试</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：由于错误处理和布局上的差异，编写调用异步void方法的单元测试很困难。</font><font style="vertical-align: inherit;">异步MSTest测试仅适用于返回Task或Task </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T的</font><font style="vertical-align: inherit;">异步方法</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
异步事件处理程序是这种做法的一个例外。</font><font style="vertical-align: inherit;">但是即使在这种情况下，也建议尽量减少处理程序本身中编写的代码-期望包含逻辑的异步Task方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有关</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MSDN </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">文章的</font></a><font style="vertical-align: inherit;">更多信息</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优先选择return Task而不是return等待</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如前所述，每次将方法声明为异步方法时，编译器都会创建一个状态机类，该类实际上包装了方法的逻辑。这会增加某些可能累积的开销，尤其是对于我们的资源限制更为严格的移动设备。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有时，方法不必是异步的，但它返回Task </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并允许另一端相应地对其进行处理。如果你的代码的最后一句是AWAIT回报，你应该考虑重构它，这样的方法的返回类型是任务</font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ŧ</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（而不是异步T）。</font><font style="vertical-align: inherit;">因此，您避免生成状态机，这会使您的代码更加灵活。</font><font style="vertical-align: inherit;">我们真正要等待的唯一情况是当我们使用异步Task进行某些操作时导致方法的继续。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">AsyncTask</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">//  !</span>
   <span class="hljs-comment">//...  -  </span>
   <span class="hljs-comment">//await -   ,  await  </span><font></font>
<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> GetData();<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">JustTask</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">//!</span>
   <span class="hljs-comment">//...  -  </span>
   <span class="hljs-comment">// Task</span><font></font>
<font></font>
   <span class="hljs-keyword">return</span> GetData();<font></font>
<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优先选择return Task而不是return await</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
注意，如果没有等待，而是返回Task </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则返回立即发生，因此，如果代码在try / catch块中，则不会捕获异常。</font><font style="vertical-align: inherit;">同样，如果代码在using块内，它将立即删除该对象。</font><font style="vertical-align: inherit;">请参阅下一个提示。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不要将return Task包装在try..catch {}内或使用{}块</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当在try..catch块（永远不会捕获由异步方法抛出的异常）或using块中使用返回任务时，可能会导致未定义的行为，因为该任务将立即返回。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果需要将异步代码包装在try..catch或using块中，请改用return await。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">ReturnTaskExceptionNotCaught</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-keyword">try</span><font></font>
   {<font></font>
       <span class="hljs-comment">// ...</span><font></font>
<font></font>
       <span class="hljs-keyword">return</span> GetData();<font></font>
<font></font>
   }<font></font>
   <span class="hljs-keyword">catch</span> (Exception ex)<font></font>
<font></font>
   {<font></font>
       <span class="hljs-comment">//     </span><font></font>
<font></font>
       Debug.WriteLine(ex.Message);<font></font>
       <span class="hljs-keyword">throw</span>;<font></font>
   }<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">ReturnTaskUsingProblem</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> resource = GetResource())<font></font>
   {<font></font>
<font></font>
       <span class="hljs-comment">// ...  ,     , ,    </span><font></font>
<font></font>
       <span class="hljs-keyword">return</span> GetData(resource);<font></font>
   }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不要将return任务包装在块</font></font><code>try..catch{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或中</font></font><code>using{}</code></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有关</font><font style="vertical-align: inherit;">堆栈溢出的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线程中的</font><font style="vertical-align: inherit;">更多信息</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">避免使用</font></font><code>.Wait()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><code>.Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-改为使用</font></font><code>GetAwaiter().GetResult()</code></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要阻止</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待异步任务完成，请使用</font></font><code>GetAwaiter().GetResult().</code> <code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并</font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抛出中的任何异常</font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这会使错误处理变得复杂。</font><font style="vertical-align: inherit;">好处</font></font><code>GetAwaiter().GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是它返回了通常的异常</font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetAwaiterGetResultExample</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">// ,    ,     AggregateException  </span><font></font>
<font></font>
   <span class="hljs-keyword">string</span> data = GetData().Result;<font></font>
<font></font>
   <span class="hljs-comment">// ,   ,      </span><font></font>
<font></font>
   data = GetData().GetAwaiter().GetResult();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您需要阻止等待异步任务完成，请使用</font></font><code>GetAwaiter().GetResult().</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接上</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">更多信息</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果该方法是异步的，请在其名称后添加Async后缀</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是.NET中使用的约定，可以更轻松地区分同步方法和异步方法（事件处理程序或Web控制器方法除外，但您的代码仍不应显式调用它们）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步库方法应使用Task.ConfigureAwait（false）来提高性能</font></font></h3><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NET Framework具有“同步上下文”的概念，这是“回到以前的状态”的一种方式。每当任务正在等待时，它都会在等待之前捕获当前的同步上下文。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Task完成后</font></font><code>.Post()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将</font><font style="vertical-align: inherit;">调用</font><font style="vertical-align: inherit;">同步上下文</font><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">从以前的位置恢复工作。这对于返回用户界面线程或返回相同的ASP.NET上下文等很有用。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在编写库代码时，您几乎不需要返回到之前的上下文。使用Task.ConfigureAwait（false）时，代码不再尝试从之前的位置恢复，而是，如果可能的话，代码将在完成任务的线程中退出，从而避免了上下文切换。这样可以稍微提高性能，并有助于避免死锁。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">ConfigureAwaitExample</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">//   ConfigureAwait(false)   .</span><font></font>
<font></font>
   <span class="hljs-keyword">var</span> data = <span class="hljs-keyword">await</span> GetData().ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，对服务器进程和库代码使用ConfigureAwait（false）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当多次调用该库方法时，这对于提高响应速度尤为重要。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，通常对服务器进程使用ConfigureAwait（false）。我们不在乎使用哪个线程继续执行，这与需要返回用户界面线程的应用程序不同。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在...在ASP.NET Core中，Microsoft取消了SynchronizationContext，因此从理论上讲您不需要它。但是，如果编写的库代码有可能在其他应用程序（例如UI App，Legacy ASP.NET，Xamarin Forms）中重用，则这</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仍然是最佳做法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有关此概念的详细说明，请观看</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步任务进度报告</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
异步方法的一个相当普遍的用例是在后台工作，释放用户界面线程以执行其他任务，并保持响应能力。在这种情况下，您可能需要将进度报告回用户界面，以便用户可以监视流程的进度并与操作进行交互。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了解决此常见问题，.NET提供了IProgress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font><font style="vertical-align: inherit;">接口</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">接口</font><font style="vertical-align: inherit;">提供了Report </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font><font style="vertical-align: inherit;">方法</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">由异步任务调用，以将进度报告给调用方。该接口被接受为异步方法的参数-调用方必须提供一个实现此接口的对象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NET提供了Progress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font><font style="vertical-align: inherit;">（实际上</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是IProgress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font><font style="vertical-align: inherit;">的默认实现）</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为它可以处理与保存和还原同步上下文相关的所有低级逻辑，因此，实际上建议使用它。进度</font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还提供了动作</font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font><font style="vertical-align: inherit;">事件和回调</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-在任务报告进度时都将调用它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IProgress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和Progress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T一起</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供了一种将进度信息从后台任务传输到用户界面线程的简便方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，</font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它可以是一个简单的值（例如int），也可以是提供上下文进度信息（例如完成百分比，当前操作的字符串描述，ETA等）的对象。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑一下您报告进度的频率。</font><font style="vertical-align: inherit;">根据您正在执行的操作，您可能会发现代码报告每秒每秒执行几次进度，这可能导致用户界面的响应速度变慢。</font><font style="vertical-align: inherit;">在这种情况下，建议以较大的时间间隔报告进度。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">本文</font></a><font style="vertical-align: inherit;">在Microsoft .NET官方博客上的</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更多信息</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取消异步任务</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
后台任务的另一个常见用例是取消执行的能力。</font><font style="vertical-align: inherit;">.NET提供了CancellationToken类。</font><font style="vertical-align: inherit;">异步方法接收CancellationToken对象，然后由主叫方代码和异步方法共享该对象，从而提供了用于信号消除的机制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在最常见的情况下，取消发生如下：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用方创建一个CancellationTokenSource对象。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用方调用已取消的异步API，并从CancellationTokenSource（CancellationTokenSource.Token）传递CancellationToken。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用方使用CancellationTokenSource（CancellationTokenSource.Cancel（））对象请求取消。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该任务通常使用CancellationToken.ThrowIfCancellationRequested方法确认取消并自行取消。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，为使此机制正常工作，您需要编写代码以定期检查请求的取消操作（例如，每次代码迭代或逻辑中的自然断点）。</font><font style="vertical-align: inherit;">理想情况下，在取消请求之后，应尽快取消异步任务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您应该考虑对所有可能花费很长时间才能完成的方法使用撤消。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">本文</font></a><font style="vertical-align: inherit;">在Microsoft .NET官方博客上的</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更多信息</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进度和取消报告-示例</font></font></h4><br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Threading.Tasks;
<span class="hljs-keyword">using</span> System.Windows.Forms;
<span class="hljs-keyword">using</span> System.Threading;
<span class="hljs-keyword">namespace</span> <span class="hljs-title">TestAsyncAwait</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AsyncProgressCancelExampleForm</span> : <span class="hljs-title">Form</span><font></font>
   {<font></font>
       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AsyncProgressCancelExampleForm</span>(<span class="hljs-params"></span>)</span><font></font>
       {<font></font>
           InitializeComponent();<font></font>
       }<font></font>
<font></font>
       CancellationTokenSource _cts = <span class="hljs-keyword">new</span> CancellationTokenSource();<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnRunAsync_Click</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> sender, EventArgs e</span>)</span><font></font>
<font></font>
       {<font></font>
<font></font>
           <span class="hljs-comment">//   .</span><font></font>
<font></font>
            &lt;<span class="hljs-keyword">int</span>&gt;   ,          ,   ,    , ETA  . .<font></font>
<font></font>
           <span class="hljs-keyword">var</span> progressIndicator = <span class="hljs-keyword">new</span> Progress&lt;<span class="hljs-keyword">int</span>&gt;(ReportProgress);<font></font>
<font></font>
           <span class="hljs-keyword">try</span><font></font>
<font></font>
           {<font></font>
               <span class="hljs-comment">//   ,         </span><font></font>
<font></font>
               <span class="hljs-keyword">await</span> AsyncMethod(progressIndicator, _cts.Token);<font></font>
<font></font>
           }<font></font>
<font></font>
           <span class="hljs-keyword">catch</span> (OperationCanceledException ex)<font></font>
<font></font>
           {<font></font>
               <span class="hljs-comment">// </span><font></font>
<font></font>
               lblProgress.Text = <span class="hljs-string">"Cancelled"</span>;<font></font>
           }<font></font>
       }<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnCancel_Click</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> sender, EventArgs e</span>)</span><font></font>
<font></font>
       {<font></font>
          <span class="hljs-comment">// </span><font></font>
           _cts.Cancel();<font></font>
<font></font>
       }<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReportProgress</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span></span>)</span><font></font>
<font></font>
       {<font></font>
           <span class="hljs-comment">//    </span><font></font>
<font></font>
           lblProgress.Text = <span class="hljs-keyword">value</span>.ToString();<font></font>
<font></font>
       }<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncMethod</span>(<span class="hljs-params">IProgress&lt;<span class="hljs-keyword">int</span>&gt; progress, CancellationToken ct</span>)</span><font></font>
<font></font>
       {<font></font>
<font></font>
           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<font></font>
<font></font>
           {<font></font>
              <span class="hljs-comment">//   ,     </span><font></font>
<font></font>
               <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);<font></font>
<font></font>
               <span class="hljs-comment">//   </span><font></font>
<font></font>
               <span class="hljs-keyword">if</span> (ct != <span class="hljs-literal">null</span>)<font></font>
<font></font>
               {<font></font>
<font></font>
                   ct.ThrowIfCancellationRequested();<font></font>
<font></font>
               }<font></font>
<font></font>
               <span class="hljs-comment">//   </span><font></font>
<font></font>
               <span class="hljs-keyword">if</span> (progress != <span class="hljs-literal">null</span>)<font></font>
<font></font>
               {<font></font>
<font></font>
                   progress.Report(i);<font></font>
               }<font></font>
           }<font></font>
       }<font></font>
   }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待一段时间</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您需要等待一段时间（例如，再次尝试检查资源的可用性），请确保使用Task.Delay-在这种情况下切勿使用Thread.Sleep。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待几个异步任务完成</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用Task.WaitAny等待任何任务的完成。</font><font style="vertical-align: inherit;">使用Task.WaitAll等待所有任务完成。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我是否必须急于切换到C＃7或8？</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注册免费的网络研讨会</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来讨论此主题。</font></font></b></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN488060/index.html">Backblaze-2019硬盘统计</a></li>
<li><a href="../zh-CN488062/index.html">Lamoda的Dynamics 365和Power Platform聚会-报告</a></li>
<li><a href="../zh-CN488064/index.html">Linux的七个理由</a></li>
<li><a href="../zh-CN488072/index.html">是Koin依赖注入还是服务定位器？</a></li>
<li><a href="../zh-CN488078/index.html">我的机器人参加2019年俄罗斯人工智能杯</a></li>
<li><a href="../zh-CN488088/index.html">哈伯如何与国家机构和其他申请人互动。多年来的透明度报告</a></li>
<li><a href="../zh-CN488092/index.html">黑客马拉松。如何充分利用并生存</a></li>
<li><a href="../zh-CN488096/index.html">400克 从变速器侧面看。ZR / ZR +</a></li>
<li><a href="../zh-CN488098/index.html">如何从模板创建Django项目</a></li>
<li><a href="../zh-CN488102/index.html">C＃和C＃之间的关系：REST，gRPC及其之间的所有内容</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>