<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë©üèª üßëüèæ‚Äçü§ù‚Äçüßëüèº ‚òÉÔ∏è GO Scheduler: maintenant pas coop√©ratif? ü§ΩüèΩ üòü üöß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si vous lisez les notes de publication de la version GO 1.14, vous avez probablement remarqu√© des changements assez int√©ressants dans l'ex√©cution du l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>GO Scheduler: maintenant pas coop√©ratif?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502506/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous lisez les notes de publication de la version GO 1.14, vous avez probablement remarqu√© des changements assez int√©ressants dans l'ex√©cution du langage. </font><font style="vertical-align: inherit;">J'ai donc √©t√© tr√®s int√©ress√© par l'article: "Les goroutines sont d√©sormais pr√©emptives de mani√®re asynchrone." </font><font style="vertical-align: inherit;">Il s'av√®re que GO Scheduler (Scheduler) n'est d√©sormais plus coop√©ratif? </font><font style="vertical-align: inherit;">Eh bien, apr√®s avoir lu la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proposition</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> correspondante en diagonale, la </font><font style="vertical-align: inherit;">curiosit√© √©tait satisfaite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, apr√®s un certain temps, j'ai d√©cid√© de rechercher plus en d√©tail les innovations. </font><font style="vertical-align: inherit;">Je voudrais partager les r√©sultats de ces √©tudes.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s0/ur/hn/s0urhnlqgwhwtkwumpnyd2hfmyy.png" alt="image"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuration requise</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les choses d√©crites ci-dessous n√©cessitent du lecteur, en plus de la connaissance de la langue GO, des connaissances suppl√©mentaires, √† savoir:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compr√©hension des principes de l'ordonnanceur (bien que j'essaierai d'expliquer ci-dessous, ¬´sur les doigts¬ª)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comprendre le fonctionnement du ramasse-miettes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comprendre ce qu'est l'assembleur GO </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fin de compte, je vais laisser quelques liens qui, √† mon avis, couvrent bien ces sujets.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En bref sur le planificateur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, permettez-moi de vous rappeler ce qu'est le multit√¢che coop√©ratif et non coop√©ratif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec le multit√¢che non coop√©ratif (√©viction), nous connaissons tous l'exemple du planificateur du syst√®me d'exploitation. Ce planificateur fonctionne en arri√®re-plan, d√©charge les threads bas√©s sur diverses heuristiques, et au lieu du temps CPU d√©charg√©, d'autres threads commencent √† recevoir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le planificateur coop√©ratif se caract√©rise par un comportement diff√©rent - il dort jusqu'√† ce que l'un des goroutins le r√©veille clairement avec un soup√ßon de disponibilit√© √† donner sa place √† un autre. Le planificateur d√©cidera alors par lui-m√™me s'il est n√©cessaire de retirer le goroutine actuel du contexte, et si oui, qui mettre √† sa place. C‚Äôest ainsi que le planificateur GO a fonctionn√©. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, nous consid√©rons les pierres angulaires avec lesquelles le planificateur fonctionne:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P - processeurs logiques (nous pouvons changer leur nombre avec la fonction runtime.GOMAXPROCS), sur chaque processeur logique une goroutine peut √™tre ex√©cut√©e ind√©pendamment √† la fois. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Threads M - OS. </font><font style="vertical-align: inherit;">Chaque P s'ex√©cute sur un thread de M. Notez que P n'est pas toujours √©gal √† M, par exemple, un thread peut √™tre bloqu√© par syscall puis un autre thread sera allou√© pour son P. </font><font style="vertical-align: inherit;">Et il y a CGO et d'autres nuances.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G - gorutins. </font><font style="vertical-align: inherit;">Eh bien ici, c'est clair, G doit √™tre ex√©cut√© sur chaque P et le planificateur le surveille.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et la derni√®re chose que vous devez savoir, et quand l'ordonnanceur appelle-t-il r√©ellement goroutine? </font><font style="vertical-align: inherit;">C'est simple, g√©n√©ralement des instructions pour l'appel sont ins√©r√©es par le compilateur au d√©but du corps (prologue) de la fonction (un peu plus loin nous en parlerons plus en d√©tail).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et quel est le probl√®me en fait?</font></font></h3><br>
<img src="https://habrastorage.org/webt/8o/fa/qt/8ofaqt_aquvkvzoskizadsuzfyw.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depuis le d√©but de l'article, vous avez d√©j√† compris que le principe du travail de l'ordonnanceur a chang√© dans GO, examinons les raisons pour lesquelles ces modifications ont √©t√© apport√©es. </font><font style="vertical-align: inherit;">Jetez un ≈ìil au code:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sous le spoiler</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	runtime.GOMAXPROCS(<span class="hljs-number">1</span>)
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">var</span> u <span class="hljs-keyword">int</span>
		<span class="hljs-keyword">for</span> {<font></font>
			u -= <span class="hljs-number">2</span>
			<span class="hljs-keyword">if</span> u == <span class="hljs-number">1</span> {
				<span class="hljs-keyword">break</span><font></font>
			}<font></font>
		}<font></font>
	}()<font></font>
	&lt;-time.After(time.Millisecond * <span class="hljs-number">5</span>) <span class="hljs-comment">//    main   ,         </span><font></font>
<font></font>
	fmt.Println(<span class="hljs-string">"go 1.13 has never been here"</span>)<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous le compilez avec la version GO &lt;1.14, alors la ligne "go 1.13 n'a jamais √©t√© l√†" que vous ne verrez pas √† l'√©cran. </font><font style="vertical-align: inherit;">Cela se produit car, d√®s que le planificateur donne du temps processeur au goroutine avec une boucle infinie, il capture compl√®tement P, aucun appel de fonction ne se produit √† l'int√©rieur de ce goroutine, ce qui signifie que nous ne r√©veillerons plus le planificateur. </font><font style="vertical-align: inherit;">Et seul un appel explicite √† runtime.Gosched () permettra √† notre programme de se terminer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci est juste un exemple o√π goroutine capture P et emp√™che pendant longtemps d'autres goroutines de s'ex√©cuter sur ce P. Plus d'options lorsque ce comportement provoque des probl√®mes peuvent √™tre trouv√©es en lisant la proposition.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse de la proposition</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La solution √† ce probl√®me est assez simple. Faisons la m√™me chose que dans le planificateur du syst√®me d'exploitation! Laissez simplement GO sortir le goroutine de P et mettez-en un autre, et pour cela, nous utiliserons les outils du syst√®me d'exploitation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OK, comment impl√©menter cela? Nous allons permettre au runtime d'envoyer un signal au flux sur lequel goroutine fonctionne. Nous enregistrerons le processeur de ce signal sur chaque flux de M, la t√¢che du processeur est de d√©terminer si le goroutine actuel peut √™tre supplant√©. Si c'est le cas, nous enregistrerons son √©tat actuel (registres et √©tat de la pile) et donnerons des ressources √† un autre, sinon nous continuerons √† ex√©cuter le goroutine actuel. Il convient de noter que le concept avec un signal est une solution pour les syst√®mes de base UNIX, alors que, par exemple, l'impl√©mentation pour Windows est l√©g√®rement diff√©rente. Soit dit en passant, SIGURG a √©t√© s√©lectionn√© comme signal pour l'envoi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La partie la plus difficile de cette mise en ≈ìuvre consiste √† d√©terminer si le goroutine peut √™tre expuls√©. </font><font style="vertical-align: inherit;">Le fait est que certains endroits de notre code devraient √™tre atomiques, du point de vue du garbage collector. </font><font style="vertical-align: inherit;">Nous appelons ces endroits des points dangereux. </font><font style="vertical-align: inherit;">Si nous pressons goroutine au moment de l'ex√©cution du code √† partir de unsafe-point, puis que GC d√©marre, alors il remplacera l'√©tat de notre goroutine, pris en unsafe-point'e, et peut faire des choses. </font><font style="vertical-align: inherit;">Examinons de plus pr√®s le concept s√ªr / dangereux.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ätes-vous all√© l√†-bas, GC?</font></font></h3><br>
<img src="https://habrastorage.org/webt/yw/ao/mw/ywaomwcstazbytzl9gwewm9agy8.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les versions ant√©rieures √† 1.12, le runtime Gosched utilisait des points de s√©curit√© dans des endroits o√π vous pouvez certainement appeler le planificateur sans craindre de nous retrouver dans la section atomique du code pour GC. </font><font style="vertical-align: inherit;">Comme nous l'avons d√©j√† dit, les donn√©es des points de s√©curit√© sont situ√©es dans le prologue d'une fonction (mais pas de chaque fonction, pensez-vous). </font><font style="vertical-align: inherit;">Si vous avez d√©sassembl√© l'assembleur go-shn, vous pourriez vous opposer - aucun appel de planificateur √©vident n'y est visible. </font><font style="vertical-align: inherit;">Oui, mais vous pouvez y trouver l'instruction d'appel runtime.morestack, et si vous regardez √† l'int√©rieur de cette fonction, un appel de planificateur sera trouv√©. </font><font style="vertical-align: inherit;">Sous le spoiler, je cacherai le commentaire des sources GO, ou vous pouvez trouver l'assembleur pour morestack vous-m√™me.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trouv√© dans la source</font></font></b>
                        <div class="spoiler_text">Synchronous safe-points are implemented by overloading the stack bound check in function prologues. To preempt a goroutine at the next synchronous safe-point, the runtime poisons the goroutine's stack bound to a value that will cause the next stack bound check to fail and enter the stack growth implementation, which will detect that it was actually a preemption and redirect to preemption handling.<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De toute √©vidence, lors du passage √† un concept d'√©viction, un signal d'√©viction peut attraper notre gorutin n'importe o√π. Mais les auteurs de GO ont d√©cid√© de ne pas laisser de points de s√©curit√©, mais de d√©clarer des points de s√©curit√© partout! Eh bien, bien s√ªr, il y a un hic, presque partout en fait. Comme mentionn√© ci-dessus, il y a des points dangereux o√π nous ne forcerons personne. √âcrivons un simple point dangereux.</font></font><br>
<br>
<pre><code class="go hljs"><font></font>
j := &amp;someStruct{}<font></font>
p := unsafe.Pointer(j)<font></font>
<span class="hljs-comment">// unsafe-point start</span>
u := <span class="hljs-keyword">uintptr</span>(p)
<span class="hljs-comment">//do some stuff here</span><font></font>
p = unsafe.Pointer(u)<font></font>
<span class="hljs-comment">// unsafe-point end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour comprendre quel est le probl√®me, essayons sur la peau d'un garbage collector. Chaque fois que nous allons travailler, nous devons trouver les n≈ìuds racine (pointeurs sur la pile et dans les registres), avec lesquels nous commencerons √† marquer. Puisqu'il est impossible de dire au moment de l'ex√©cution si 64 octets en m√©moire sont un pointeur ou juste un nombre, nous nous tournons vers les cartes de pile et d'enregistrement (un cache avec des m√©tadonn√©es), aimablement fournies par le compilateur GO. Les informations de ces cartes nous permettent de trouver des pointeurs. Nous avons donc √©t√© r√©veill√©s et envoy√©s au travail lorsque GO a ex√©cut√© la ligne num√©ro 4. En arrivant √† l'endroit et en regardant les cartes, nous avons constat√© qu'il √©tait vide (et cela est vrai, car uintptr du point de vue de GC est un nombre et non un pointeur). Eh bien, hier, nous avons entendu parler de l'allocation de m√©moire pour j, car maintenant nous ne pouvons pas acc√©der √† cette m√©moire - nous devons la nettoyer, et apr√®s avoir retir√© la m√©moire, nous nous endormons.Et apr√®s? Eh bien, les autorit√©s se sont r√©veill√©es, la nuit, en criant, eh bien, vous avez vous-m√™me compris.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout avec la th√©orie, je propose de consid√©rer dans la pratique comment fonctionnent tous ces signaux, points dangereux et registres de cartes et piles.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passons √† la pratique</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai ex√©cut√© deux fois (passez √† 1.14 et 1.13) un exemple du d√©but de l'article du perf profiler afin de voir quels appels syst√®me se produisent et de les comparer. </font><font style="vertical-align: inherit;">L'appel syst√®me requis dans la 14e version a √©t√© trouv√© assez rapidement:</font></font><br>
<br>
<pre><code class="plaintext hljs">15.652 ( 0.003 ms): main/29614 tgkill(tgid: 29613 (main), pid: 29613 (main), sig: URG                ) = 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, √©videmment, le runtime a envoy√© SIGURG au thread sur lequel goroutine tourne. </font><font style="vertical-align: inherit;">Prenant cette connaissance comme point de d√©part, je suis all√© regarder les commits dans GO pour trouver o√π et pour quelle raison ce signal est envoy√©, et aussi pour trouver l'endroit o√π le gestionnaire de signal est install√©. </font><font style="vertical-align: inherit;">Commen√ßons par l'envoi, nous trouverons la fonction d'envoi de signal dans runtime / os_linux.go</font></font><br>
<br>
<pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">signalM</span><span class="hljs-params">(mp *m, sig <span class="hljs-keyword">int</span>)</span></span> {<font></font>
	tgkill(getpid(), <span class="hljs-keyword">int</span>(mp.procid), sig)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous trouvons des endroits dans le code d'ex√©cution, d'o√π nous envoyons le signal:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque goroutine est suspendu, s'il est en √©tat de marche. </font><font style="vertical-align: inherit;">La demande de suspension provient du garbage collector. </font><font style="vertical-align: inherit;">Ici, peut-√™tre, je n'ajouterai pas de code, mais il peut √™tre trouv√© dans le fichier runtime / preempt.go (suspendG)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si le planificateur d√©cide que goroutine fonctionne trop longtemps, runtime / proc.go (retake)</font></font><br>
<pre><code class="go hljs">
<span class="hljs-keyword">if</span> pd.schedwhen+forcePreemptNS &lt;= now {<font></font>
	signalM(_p_)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
forcePreemptNS - constante √©gale √† 10 ms, pd.schedwhen - heure √† laquelle le planificateur du flux pd a √©t√© appel√© la derni√®re fois</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ainsi que tous les flux, ce signal est envoy√© lors d'une panique, StopTheWorld (GC) et quelques autres cas (que je dois contourner, car la taille de l'article d√©passera d√©j√† les limites)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons compris comment et quand le runtime envoie un signal √† M. </font><font style="vertical-align: inherit;">Maintenant, trouvons le gestionnaire de ce signal et voyons ce que fait le flux lorsqu'il est re√ßu.</font></font><br>
<br>
<pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSigPreempt</span><span class="hljs-params">(gp *g, ctxt *sigctxt)</span></span> {
	<span class="hljs-keyword">if</span> wantAsyncPreempt(gp) &amp;&amp; isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()) {
		<span class="hljs-comment">// Inject a call to asyncPreempt.</span><font></font>
		ctxt.pushCall(funcPC(asyncPreempt))<font></font>
	}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A partir de cette fonction, il est clair que pour "verrouiller" vous devez passer par 2 contr√¥les:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wantAsyncPreempt - nous v√©rifions si G veut √™tre expuls√©, ici, par exemple, la validit√© de l'√©tat actuel du goroutine sera v√©rifi√©e.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isAsyncSafePoint - v√©rifiez s'il peut √™tre √©vinc√© en ce moment. </font><font style="vertical-align: inherit;">Le plus int√©ressant des contr√¥les ici est de savoir si G est dans un point s√ªr ou non. </font><font style="vertical-align: inherit;">De plus, nous devons √™tre s√ªrs que le thread sur lequel G s'ex√©cute est √©galement pr√™t √† pr√©empter G.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si les deux v√©rifications sont r√©ussies, des instructions seront appel√©es √† partir du code ex√©cutable qui enregistre l'√©tat G et appelle l'ordonnanceur.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et plus sur dangereux</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je propose d'analyser un nouvel exemple, il illustrera un autre cas avec unsafe-point:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un autre programme sans fin</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">infiniteLoop</span><span class="hljs-params">()</span></span> {
	<span class="hljs-keyword">var</span> u <span class="hljs-keyword">int</span>
	<span class="hljs-keyword">for</span> {<font></font>
		u -= <span class="hljs-number">2</span>
		<span class="hljs-keyword">if</span> u == <span class="hljs-number">1</span> {
			<span class="hljs-keyword">break</span><font></font>
		}<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	runtime.GOMAXPROCS(<span class="hljs-number">1</span>)
	<span class="hljs-keyword">go</span> infiniteLoop()<font></font>
	&lt;-time.After(time.Millisecond * <span class="hljs-number">5</span>)<font></font>
<font></font>
	fmt.Println(<span class="hljs-string">"go 1.13 and 1.14 has never been here"</span>)<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le deviner, l'inscription ¬´go 1.13 et 1.14 n'a jamais √©t√© ici¬ª que nous ne verrons pas dans GO 1.14. </font><font style="vertical-align: inherit;">C'est parce que nous avons explicitement interdit d'interrompre la fonction infiniteLoop (go: nosplit). </font><font style="vertical-align: inherit;">Une telle interdiction est mise en ≈ìuvre uniquement √† l'aide de unsafe-point, qui est le corps entier de la fonction. </font><font style="vertical-align: inherit;">Voyons ce que le compilateur a g√©n√©r√© pour la fonction infiniteLoop.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembleur Attention</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   TEXT    <span class="hljs-string">""</span>.infiniteLoop(SB), NOSPLIT|ABIInternal, $<span class="hljs-number">0</span><span class="hljs-number">-0</span>
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   PCDATA  $<span class="hljs-number">0</span>, $<span class="hljs-number">-2</span>
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   PCDATA  $<span class="hljs-number">1</span>, $<span class="hljs-number">-2</span>
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   FUNCDATA        $<span class="hljs-number">0</span>, gclocals¬∑<span class="hljs-number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   FUNCDATA        $<span class="hljs-number">1</span>, gclocals¬∑<span class="hljs-number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   FUNCDATA        $<span class="hljs-number">2</span>, gclocals¬∑<span class="hljs-number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   XORL    AX, AX
        <span class="hljs-number">0x0002</span> <span class="hljs-number">00002</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">12</span>)   JMP     <span class="hljs-number">8</span>
        <span class="hljs-number">0x0004</span> <span class="hljs-number">00004</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">13</span>)   ADDQ    $<span class="hljs-number">-2</span>, AX
        <span class="hljs-number">0x0008</span> <span class="hljs-number">00008</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>)   CMPQ    AX, $<span class="hljs-number">3</span>
        <span class="hljs-number">0x000c</span> <span class="hljs-number">00012</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>)   JNE     <span class="hljs-number">4</span>
        <span class="hljs-number">0x000e</span> <span class="hljs-number">00014</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">15</span>)   PCDATA  $<span class="hljs-number">0</span>, $<span class="hljs-number">-1</span>
        <span class="hljs-number">0x000e</span> <span class="hljs-number">00014</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">15</span>)   PCDATA  $<span class="hljs-number">1</span>, $<span class="hljs-number">-1</span>
        <span class="hljs-number">0x000e</span> <span class="hljs-number">00014</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">15</span>)   RET
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre cas, l'instruction PCDATA est int√©ressante. </font><font style="vertical-align: inherit;">Lorsque l'√©diteur de liens voit cette instruction, il ne la convertit pas en un "v√©ritable" assembleur. </font><font style="vertical-align: inherit;">Au lieu de cela, la valeur du 2e argument avec la cl√© √©gale au compteur de programme correspondant (le nombre qui peut √™tre observ√© √† gauche du nom de la fonction + ligne) sera plac√©e dans le registre ou la mappe de pile (d√©termin√©e par le 1er argument). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme nous le voyons sur les lignes 10 et 15, nous mettons les valeurs $ 2 et -1 dans la carte $ 0 et $ 1, respectivement. </font><font style="vertical-align: inherit;">Souvenons-nous de ce moment et jetons un ≈ìil √† l'int√©rieur de la fonction isAsyncSafePoint, sur laquelle j'ai d√©j√† attir√© votre attention. </font><font style="vertical-align: inherit;">L√†, nous verrons les lignes suivantes:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isAsyncSafePoint</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
	smi := pcdatavalue(f, _PCDATA_RegMapIndex, pc, <span class="hljs-literal">nil</span>)
	<span class="hljs-keyword">if</span> smi == <span class="hljs-number">-2</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
	}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est √† cet endroit que l'on v√©rifie si la goroutine est actuellement au point de s√©curit√©. </font><font style="vertical-align: inherit;">Nous passons √† la carte des registres (_PCDATA_RegMapIndex = 0), et en lui passant le pc actuel, nous v√©rifions la valeur, si -2 alors G n'est pas en point s√ªr, ce qui signifie qu'il ne peut pas √™tre √©vinc√©.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai arr√™t√© mes ¬´recherches¬ª l√†-dessus, j'esp√®re que l'article vous a √©t√© utile aussi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je poste les liens promis, mais soyez prudent, car certaines des informations contenues dans ces articles peuvent √™tre obsol√®tes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Planificateur GO - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deux fois</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembleur GO.</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr502494/index.html">7 erreurs d'un Black Friday et comment fonctionne Magento Cloud - vid√©o</a></li>
<li><a href="../fr502496/index.html">Acc√®s Web facile aux applications LabVIEW VI PHP via le serveur ActiveX</a></li>
<li><a href="../fr502498/index.html">Meilleures pratiques pour am√©liorer les performances en C #</a></li>
<li><a href="../fr502500/index.html">L'√©volution d'un scanner de passeport: de l'artisanat du contreplaqu√© √† la vraie entreprise</a></li>
<li><a href="../fr502504/index.html">Entourez le chiffre de l'utilisateur</a></li>
<li><a href="../fr502508/index.html">Trolley Robot 2.0. Partie 2. Gestion dans rviz et sans √©l√©ments de beaut√© dans rviz</a></li>
<li><a href="../fr502510/index.html">Quoi √©conomiser dans le cloud</a></li>
<li><a href="../fr502512/index.html">R√©sultats du concours des experts du canap√©: les r√®gles du piquant scientifique</a></li>
<li><a href="../fr502518/index.html">Comment grimper √† un arbre</a></li>
<li><a href="../fr502520/index.html">Rapports vid√©o des rapports Mitap sur l'analyse des produits</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>