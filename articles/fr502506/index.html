<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👩🏻 🧑🏾‍🤝‍🧑🏼 ☃️ GO Scheduler: maintenant pas coopératif? 🤽🏽 😟 🚧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si vous lisez les notes de publication de la version GO 1.14, vous avez probablement remarqué des changements assez intéressants dans l'exécution du l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>GO Scheduler: maintenant pas coopératif?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502506/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous lisez les notes de publication de la version GO 1.14, vous avez probablement remarqué des changements assez intéressants dans l'exécution du langage. </font><font style="vertical-align: inherit;">J'ai donc été très intéressé par l'article: "Les goroutines sont désormais préemptives de manière asynchrone." </font><font style="vertical-align: inherit;">Il s'avère que GO Scheduler (Scheduler) n'est désormais plus coopératif? </font><font style="vertical-align: inherit;">Eh bien, après avoir lu la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proposition</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> correspondante en diagonale, la </font><font style="vertical-align: inherit;">curiosité était satisfaite. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, après un certain temps, j'ai décidé de rechercher plus en détail les innovations. </font><font style="vertical-align: inherit;">Je voudrais partager les résultats de ces études.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s0/ur/hn/s0urhnlqgwhwtkwumpnyd2hfmyy.png" alt="image"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuration requise</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les choses décrites ci-dessous nécessitent du lecteur, en plus de la connaissance de la langue GO, des connaissances supplémentaires, à savoir:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compréhension des principes de l'ordonnanceur (bien que j'essaierai d'expliquer ci-dessous, «sur les doigts»)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comprendre le fonctionnement du ramasse-miettes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comprendre ce qu'est l'assembleur GO </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fin de compte, je vais laisser quelques liens qui, à mon avis, couvrent bien ces sujets.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En bref sur le planificateur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, permettez-moi de vous rappeler ce qu'est le multitâche coopératif et non coopératif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec le multitâche non coopératif (éviction), nous connaissons tous l'exemple du planificateur du système d'exploitation. Ce planificateur fonctionne en arrière-plan, décharge les threads basés sur diverses heuristiques, et au lieu du temps CPU déchargé, d'autres threads commencent à recevoir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le planificateur coopératif se caractérise par un comportement différent - il dort jusqu'à ce que l'un des goroutins le réveille clairement avec un soupçon de disponibilité à donner sa place à un autre. Le planificateur décidera alors par lui-même s'il est nécessaire de retirer le goroutine actuel du contexte, et si oui, qui mettre à sa place. C’est ainsi que le planificateur GO a fonctionné. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, nous considérons les pierres angulaires avec lesquelles le planificateur fonctionne:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P - processeurs logiques (nous pouvons changer leur nombre avec la fonction runtime.GOMAXPROCS), sur chaque processeur logique une goroutine peut être exécutée indépendamment à la fois. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Threads M - OS. </font><font style="vertical-align: inherit;">Chaque P s'exécute sur un thread de M. Notez que P n'est pas toujours égal à M, par exemple, un thread peut être bloqué par syscall puis un autre thread sera alloué pour son P. </font><font style="vertical-align: inherit;">Et il y a CGO et d'autres nuances.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G - gorutins. </font><font style="vertical-align: inherit;">Eh bien ici, c'est clair, G doit être exécuté sur chaque P et le planificateur le surveille.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et la dernière chose que vous devez savoir, et quand l'ordonnanceur appelle-t-il réellement goroutine? </font><font style="vertical-align: inherit;">C'est simple, généralement des instructions pour l'appel sont insérées par le compilateur au début du corps (prologue) de la fonction (un peu plus loin nous en parlerons plus en détail).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et quel est le problème en fait?</font></font></h3><br>
<img src="https://habrastorage.org/webt/8o/fa/qt/8ofaqt_aquvkvzoskizadsuzfyw.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depuis le début de l'article, vous avez déjà compris que le principe du travail de l'ordonnanceur a changé dans GO, examinons les raisons pour lesquelles ces modifications ont été apportées. </font><font style="vertical-align: inherit;">Jetez un œil au code:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sous le spoiler</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	runtime.GOMAXPROCS(<span class="hljs-number">1</span>)
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">var</span> u <span class="hljs-keyword">int</span>
		<span class="hljs-keyword">for</span> {<font></font>
			u -= <span class="hljs-number">2</span>
			<span class="hljs-keyword">if</span> u == <span class="hljs-number">1</span> {
				<span class="hljs-keyword">break</span><font></font>
			}<font></font>
		}<font></font>
	}()<font></font>
	&lt;-time.After(time.Millisecond * <span class="hljs-number">5</span>) <span class="hljs-comment">//    main   ,         </span><font></font>
<font></font>
	fmt.Println(<span class="hljs-string">"go 1.13 has never been here"</span>)<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous le compilez avec la version GO &lt;1.14, alors la ligne "go 1.13 n'a jamais été là" que vous ne verrez pas à l'écran. </font><font style="vertical-align: inherit;">Cela se produit car, dès que le planificateur donne du temps processeur au goroutine avec une boucle infinie, il capture complètement P, aucun appel de fonction ne se produit à l'intérieur de ce goroutine, ce qui signifie que nous ne réveillerons plus le planificateur. </font><font style="vertical-align: inherit;">Et seul un appel explicite à runtime.Gosched () permettra à notre programme de se terminer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci est juste un exemple où goroutine capture P et empêche pendant longtemps d'autres goroutines de s'exécuter sur ce P. Plus d'options lorsque ce comportement provoque des problèmes peuvent être trouvées en lisant la proposition.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse de la proposition</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La solution à ce problème est assez simple. Faisons la même chose que dans le planificateur du système d'exploitation! Laissez simplement GO sortir le goroutine de P et mettez-en un autre, et pour cela, nous utiliserons les outils du système d'exploitation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OK, comment implémenter cela? Nous allons permettre au runtime d'envoyer un signal au flux sur lequel goroutine fonctionne. Nous enregistrerons le processeur de ce signal sur chaque flux de M, la tâche du processeur est de déterminer si le goroutine actuel peut être supplanté. Si c'est le cas, nous enregistrerons son état actuel (registres et état de la pile) et donnerons des ressources à un autre, sinon nous continuerons à exécuter le goroutine actuel. Il convient de noter que le concept avec un signal est une solution pour les systèmes de base UNIX, alors que, par exemple, l'implémentation pour Windows est légèrement différente. Soit dit en passant, SIGURG a été sélectionné comme signal pour l'envoi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La partie la plus difficile de cette mise en œuvre consiste à déterminer si le goroutine peut être expulsé. </font><font style="vertical-align: inherit;">Le fait est que certains endroits de notre code devraient être atomiques, du point de vue du garbage collector. </font><font style="vertical-align: inherit;">Nous appelons ces endroits des points dangereux. </font><font style="vertical-align: inherit;">Si nous pressons goroutine au moment de l'exécution du code à partir de unsafe-point, puis que GC démarre, alors il remplacera l'état de notre goroutine, pris en unsafe-point'e, et peut faire des choses. </font><font style="vertical-align: inherit;">Examinons de plus près le concept sûr / dangereux.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Êtes-vous allé là-bas, GC?</font></font></h3><br>
<img src="https://habrastorage.org/webt/yw/ao/mw/ywaomwcstazbytzl9gwewm9agy8.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les versions antérieures à 1.12, le runtime Gosched utilisait des points de sécurité dans des endroits où vous pouvez certainement appeler le planificateur sans craindre de nous retrouver dans la section atomique du code pour GC. </font><font style="vertical-align: inherit;">Comme nous l'avons déjà dit, les données des points de sécurité sont situées dans le prologue d'une fonction (mais pas de chaque fonction, pensez-vous). </font><font style="vertical-align: inherit;">Si vous avez désassemblé l'assembleur go-shn, vous pourriez vous opposer - aucun appel de planificateur évident n'y est visible. </font><font style="vertical-align: inherit;">Oui, mais vous pouvez y trouver l'instruction d'appel runtime.morestack, et si vous regardez à l'intérieur de cette fonction, un appel de planificateur sera trouvé. </font><font style="vertical-align: inherit;">Sous le spoiler, je cacherai le commentaire des sources GO, ou vous pouvez trouver l'assembleur pour morestack vous-même.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trouvé dans la source</font></font></b>
                        <div class="spoiler_text">Synchronous safe-points are implemented by overloading the stack bound check in function prologues. To preempt a goroutine at the next synchronous safe-point, the runtime poisons the goroutine's stack bound to a value that will cause the next stack bound check to fail and enter the stack growth implementation, which will detect that it was actually a preemption and redirect to preemption handling.<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De toute évidence, lors du passage à un concept d'éviction, un signal d'éviction peut attraper notre gorutin n'importe où. Mais les auteurs de GO ont décidé de ne pas laisser de points de sécurité, mais de déclarer des points de sécurité partout! Eh bien, bien sûr, il y a un hic, presque partout en fait. Comme mentionné ci-dessus, il y a des points dangereux où nous ne forcerons personne. Écrivons un simple point dangereux.</font></font><br>
<br>
<pre><code class="go hljs"><font></font>
j := &amp;someStruct{}<font></font>
p := unsafe.Pointer(j)<font></font>
<span class="hljs-comment">// unsafe-point start</span>
u := <span class="hljs-keyword">uintptr</span>(p)
<span class="hljs-comment">//do some stuff here</span><font></font>
p = unsafe.Pointer(u)<font></font>
<span class="hljs-comment">// unsafe-point end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour comprendre quel est le problème, essayons sur la peau d'un garbage collector. Chaque fois que nous allons travailler, nous devons trouver les nœuds racine (pointeurs sur la pile et dans les registres), avec lesquels nous commencerons à marquer. Puisqu'il est impossible de dire au moment de l'exécution si 64 octets en mémoire sont un pointeur ou juste un nombre, nous nous tournons vers les cartes de pile et d'enregistrement (un cache avec des métadonnées), aimablement fournies par le compilateur GO. Les informations de ces cartes nous permettent de trouver des pointeurs. Nous avons donc été réveillés et envoyés au travail lorsque GO a exécuté la ligne numéro 4. En arrivant à l'endroit et en regardant les cartes, nous avons constaté qu'il était vide (et cela est vrai, car uintptr du point de vue de GC est un nombre et non un pointeur). Eh bien, hier, nous avons entendu parler de l'allocation de mémoire pour j, car maintenant nous ne pouvons pas accéder à cette mémoire - nous devons la nettoyer, et après avoir retiré la mémoire, nous nous endormons.Et après? Eh bien, les autorités se sont réveillées, la nuit, en criant, eh bien, vous avez vous-même compris.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout avec la théorie, je propose de considérer dans la pratique comment fonctionnent tous ces signaux, points dangereux et registres de cartes et piles.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passons à la pratique</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai exécuté deux fois (passez à 1.14 et 1.13) un exemple du début de l'article du perf profiler afin de voir quels appels système se produisent et de les comparer. </font><font style="vertical-align: inherit;">L'appel système requis dans la 14e version a été trouvé assez rapidement:</font></font><br>
<br>
<pre><code class="plaintext hljs">15.652 ( 0.003 ms): main/29614 tgkill(tgid: 29613 (main), pid: 29613 (main), sig: URG                ) = 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, évidemment, le runtime a envoyé SIGURG au thread sur lequel goroutine tourne. </font><font style="vertical-align: inherit;">Prenant cette connaissance comme point de départ, je suis allé regarder les commits dans GO pour trouver où et pour quelle raison ce signal est envoyé, et aussi pour trouver l'endroit où le gestionnaire de signal est installé. </font><font style="vertical-align: inherit;">Commençons par l'envoi, nous trouverons la fonction d'envoi de signal dans runtime / os_linux.go</font></font><br>
<br>
<pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">signalM</span><span class="hljs-params">(mp *m, sig <span class="hljs-keyword">int</span>)</span></span> {<font></font>
	tgkill(getpid(), <span class="hljs-keyword">int</span>(mp.procid), sig)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous trouvons des endroits dans le code d'exécution, d'où nous envoyons le signal:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque goroutine est suspendu, s'il est en état de marche. </font><font style="vertical-align: inherit;">La demande de suspension provient du garbage collector. </font><font style="vertical-align: inherit;">Ici, peut-être, je n'ajouterai pas de code, mais il peut être trouvé dans le fichier runtime / preempt.go (suspendG)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si le planificateur décide que goroutine fonctionne trop longtemps, runtime / proc.go (retake)</font></font><br>
<pre><code class="go hljs">
<span class="hljs-keyword">if</span> pd.schedwhen+forcePreemptNS &lt;= now {<font></font>
	signalM(_p_)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
forcePreemptNS - constante égale à 10 ms, pd.schedwhen - heure à laquelle le planificateur du flux pd a été appelé la dernière fois</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ainsi que tous les flux, ce signal est envoyé lors d'une panique, StopTheWorld (GC) et quelques autres cas (que je dois contourner, car la taille de l'article dépassera déjà les limites)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons compris comment et quand le runtime envoie un signal à M. </font><font style="vertical-align: inherit;">Maintenant, trouvons le gestionnaire de ce signal et voyons ce que fait le flux lorsqu'il est reçu.</font></font><br>
<br>
<pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSigPreempt</span><span class="hljs-params">(gp *g, ctxt *sigctxt)</span></span> {
	<span class="hljs-keyword">if</span> wantAsyncPreempt(gp) &amp;&amp; isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()) {
		<span class="hljs-comment">// Inject a call to asyncPreempt.</span><font></font>
		ctxt.pushCall(funcPC(asyncPreempt))<font></font>
	}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A partir de cette fonction, il est clair que pour "verrouiller" vous devez passer par 2 contrôles:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wantAsyncPreempt - nous vérifions si G veut être expulsé, ici, par exemple, la validité de l'état actuel du goroutine sera vérifiée.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isAsyncSafePoint - vérifiez s'il peut être évincé en ce moment. </font><font style="vertical-align: inherit;">Le plus intéressant des contrôles ici est de savoir si G est dans un point sûr ou non. </font><font style="vertical-align: inherit;">De plus, nous devons être sûrs que le thread sur lequel G s'exécute est également prêt à préempter G.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si les deux vérifications sont réussies, des instructions seront appelées à partir du code exécutable qui enregistre l'état G et appelle l'ordonnanceur.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et plus sur dangereux</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je propose d'analyser un nouvel exemple, il illustrera un autre cas avec unsafe-point:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un autre programme sans fin</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">infiniteLoop</span><span class="hljs-params">()</span></span> {
	<span class="hljs-keyword">var</span> u <span class="hljs-keyword">int</span>
	<span class="hljs-keyword">for</span> {<font></font>
		u -= <span class="hljs-number">2</span>
		<span class="hljs-keyword">if</span> u == <span class="hljs-number">1</span> {
			<span class="hljs-keyword">break</span><font></font>
		}<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	runtime.GOMAXPROCS(<span class="hljs-number">1</span>)
	<span class="hljs-keyword">go</span> infiniteLoop()<font></font>
	&lt;-time.After(time.Millisecond * <span class="hljs-number">5</span>)<font></font>
<font></font>
	fmt.Println(<span class="hljs-string">"go 1.13 and 1.14 has never been here"</span>)<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le deviner, l'inscription «go 1.13 et 1.14 n'a jamais été ici» que nous ne verrons pas dans GO 1.14. </font><font style="vertical-align: inherit;">C'est parce que nous avons explicitement interdit d'interrompre la fonction infiniteLoop (go: nosplit). </font><font style="vertical-align: inherit;">Une telle interdiction est mise en œuvre uniquement à l'aide de unsafe-point, qui est le corps entier de la fonction. </font><font style="vertical-align: inherit;">Voyons ce que le compilateur a généré pour la fonction infiniteLoop.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembleur Attention</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   TEXT    <span class="hljs-string">""</span>.infiniteLoop(SB), NOSPLIT|ABIInternal, $<span class="hljs-number">0</span><span class="hljs-number">-0</span>
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   PCDATA  $<span class="hljs-number">0</span>, $<span class="hljs-number">-2</span>
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   PCDATA  $<span class="hljs-number">1</span>, $<span class="hljs-number">-2</span>
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   FUNCDATA        $<span class="hljs-number">0</span>, gclocals·<span class="hljs-number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   FUNCDATA        $<span class="hljs-number">1</span>, gclocals·<span class="hljs-number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   FUNCDATA        $<span class="hljs-number">2</span>, gclocals·<span class="hljs-number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   XORL    AX, AX
        <span class="hljs-number">0x0002</span> <span class="hljs-number">00002</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">12</span>)   JMP     <span class="hljs-number">8</span>
        <span class="hljs-number">0x0004</span> <span class="hljs-number">00004</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">13</span>)   ADDQ    $<span class="hljs-number">-2</span>, AX
        <span class="hljs-number">0x0008</span> <span class="hljs-number">00008</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>)   CMPQ    AX, $<span class="hljs-number">3</span>
        <span class="hljs-number">0x000c</span> <span class="hljs-number">00012</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>)   JNE     <span class="hljs-number">4</span>
        <span class="hljs-number">0x000e</span> <span class="hljs-number">00014</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">15</span>)   PCDATA  $<span class="hljs-number">0</span>, $<span class="hljs-number">-1</span>
        <span class="hljs-number">0x000e</span> <span class="hljs-number">00014</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">15</span>)   PCDATA  $<span class="hljs-number">1</span>, $<span class="hljs-number">-1</span>
        <span class="hljs-number">0x000e</span> <span class="hljs-number">00014</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">15</span>)   RET
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans notre cas, l'instruction PCDATA est intéressante. </font><font style="vertical-align: inherit;">Lorsque l'éditeur de liens voit cette instruction, il ne la convertit pas en un "véritable" assembleur. </font><font style="vertical-align: inherit;">Au lieu de cela, la valeur du 2e argument avec la clé égale au compteur de programme correspondant (le nombre qui peut être observé à gauche du nom de la fonction + ligne) sera placée dans le registre ou la mappe de pile (déterminée par le 1er argument). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme nous le voyons sur les lignes 10 et 15, nous mettons les valeurs $ 2 et -1 dans la carte $ 0 et $ 1, respectivement. </font><font style="vertical-align: inherit;">Souvenons-nous de ce moment et jetons un œil à l'intérieur de la fonction isAsyncSafePoint, sur laquelle j'ai déjà attiré votre attention. </font><font style="vertical-align: inherit;">Là, nous verrons les lignes suivantes:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isAsyncSafePoint</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
	smi := pcdatavalue(f, _PCDATA_RegMapIndex, pc, <span class="hljs-literal">nil</span>)
	<span class="hljs-keyword">if</span> smi == <span class="hljs-number">-2</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
	}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est à cet endroit que l'on vérifie si la goroutine est actuellement au point de sécurité. </font><font style="vertical-align: inherit;">Nous passons à la carte des registres (_PCDATA_RegMapIndex = 0), et en lui passant le pc actuel, nous vérifions la valeur, si -2 alors G n'est pas en point sûr, ce qui signifie qu'il ne peut pas être évincé.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai arrêté mes «recherches» là-dessus, j'espère que l'article vous a été utile aussi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je poste les liens promis, mais soyez prudent, car certaines des informations contenues dans ces articles peuvent être obsolètes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Planificateur GO - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deux fois</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembleur GO.</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr502494/index.html">7 erreurs d'un Black Friday et comment fonctionne Magento Cloud - vidéo</a></li>
<li><a href="../fr502496/index.html">Accès Web facile aux applications LabVIEW VI PHP via le serveur ActiveX</a></li>
<li><a href="../fr502498/index.html">Meilleures pratiques pour améliorer les performances en C #</a></li>
<li><a href="../fr502500/index.html">L'évolution d'un scanner de passeport: de l'artisanat du contreplaqué à la vraie entreprise</a></li>
<li><a href="../fr502504/index.html">Entourez le chiffre de l'utilisateur</a></li>
<li><a href="../fr502508/index.html">Trolley Robot 2.0. Partie 2. Gestion dans rviz et sans éléments de beauté dans rviz</a></li>
<li><a href="../fr502510/index.html">Quoi économiser dans le cloud</a></li>
<li><a href="../fr502512/index.html">Résultats du concours des experts du canapé: les règles du piquant scientifique</a></li>
<li><a href="../fr502518/index.html">Comment grimper à un arbre</a></li>
<li><a href="../fr502520/index.html">Rapports vidéo des rapports Mitap sur l'analyse des produits</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>