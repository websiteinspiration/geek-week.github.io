<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛃 🆔 💴 NORバルブをベースにしたコンピューター：アポロ搭載制御コンピューター内 📦 💏 👉🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近、私たちはアポロ搭載制御コンピューターの復元に携わっていました。これは、月面に飛んでいるアポロ計画の制御、ナビゲート、監視を担当するコンピューターです。この歴史的なコンピューターは、最初に集積回路（IC）を使用したものの1つであり、そのプロセッサーは完全にNORバルブで構築されていました（2番目...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>NORバルブをベースにしたコンピューター：アポロ搭載制御コンピューター内</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472792/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最近、私たちは</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アポロ搭載制御コンピューター</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">の復元に携わっていました</font></a><font style="vertical-align: inherit;">。これは、月面に飛んでいるアポロ計画の制御、ナビゲート、監視を担当するコンピューターです。</font><font style="vertical-align: inherit;">この歴史的なコンピューターは、最初に集積回路（IC）を使用したものの1つであり、そのプロセッサーは完全にNORバルブで構築されていました（2番目のタイプのIC、読み取りアンプはコンピューターのメモリーで使用されていました）。</font><font style="vertical-align: inherit;">この記事では、CPUのアーキテクチャーと設計について説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apollo Control Computer Architecture</font></font></h2><br>
<img src="https://habrastorage.org/getpro/habr/post_images/f69/7d2/d2b/f697d2d2bad17f528a245a0043e2ce90.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アポロ制御コンピューターの分離されたトレイ。左側のトレイには、NORゲートに基づくロジックが含まれています。右側には、メモリと補助コンポーネント。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アポロガイダンスコンピュータ（AGC）は、アポロ計画は、月に飛ぶことができるように1960年代に開発されました。ほとんどのコンピューターがフルサイズの冷蔵庫から部屋全体までのスペースを占めていた当時、AGCはユニークなものでした。アポロ宇宙船に搭載するのに十分な大きさで、重量は32 kgで0.03 m以下しかありませんでした。</font><sup><font style="vertical-align: inherit;">3</font></sup><font style="vertical-align: inherit;">（30リットル）。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AGCコンピュータは15ビットです。 2の累乗ではないワードサイズに出会うのは奇妙ですが、バイトが普及する前の1960年代には、コンピューターはさまざまなワードサイズを使用していました。 15ビットは月面着陸に十分な精度を提供し（必要に応じてデータを2倍および3倍の精度で使用）、16ビットはコンピューターのサイズと重量を不必要に増加させるだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AGC命令は15ビットワードに含まれており、オペレーションコードを示す3ビットと、メモリ内のアドレスを示す12ビットで構成されていました。残念ながら、これらのボリュームはまだ十分ではなかったので、コンピューターは多くのトリックと回避策を使用し、アーキテクチャーはかなり扱いにくいことがわかりました。 12ビットのメモリアドレスは4Kワードにしかアクセスできません。同時に、AGCにはメインRAMに2Kワード、コアメモリに36Kワードがありました。すべてのメモリにアクセスするために、AGCは高度なメモリバンクスイッチングシステムと複数のレジスタを使用しました。言い換えると、256ワード単位でメモリにアクセスでき、ROMは少し大きいサイズでアクセスできました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オペレーションコードの3ビットは、34の可能な命令を直接示すのに十分ではなかったため、AGCは、命令の値の拡張と、一部の命令が特定のメモリセルでのみ実行することに意味があるという事実を利用してトリックを使用しました。さらに、メモリ内の「マジック」アドレスなどのトリックが使用されました。たとえば、「右シフトレジスタ」セルへの書き込みはビット単位のシフトを実行するため、個別の「右シフト」命令の必要がなくなりました。同時にいくつかのアクションを組み合わせた指示もありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AGCアーキテクチャは、1960年代の標準でさえ、かなりシンプルでした。複雑で強力なメインフレームの時代に作成されましたが、AGCの機能は非常に制限されていました。電力とアーキテクチャの点では、初期のマイクロプロセッサに匹敵します。その強みは、コンパクトなサイズと、リアルタイムのデータ入出力を提供する優れた機能でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下のアーキテクチャ図は、AGCの主なコンポーネントを示しています。掘り下げた部分をカラーでハイライトしました。 AGCには少数のレジスタセットと、加算のみを処理する単純な算術モジュールがありました。彼は、ROMが36Kワード、RAMが2Kワードしかありませんでした。 「書き込みバス」は、コンポーネント間でデータを転送する主な方法でした。デコード命令とシーケンスジェネレーターは、AGCの制御パルスを生成しました。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/60b/5fa/3e1/60b5fa3e19a473055f9364fac1df8e88.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AGCブロック図</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図の約半分はメモリで占められています。これは、多くの側面でAGCアーキテクチャがそのメモリを中心に開発されたという事実を反映しています。 1960年代のほとんどのコンピューターと同様に、AGCはコアメモリを使用し、ワイヤーメッシュ上に張られた小さなフェライトリング（コア）に各ビットを格納していました。各ビットには個別の物理コアが必要であるため、そのようなメモリの量は、現代の半導体のメモリよりも根本的に少なかった。コア上のメモリの特徴は、メモリからワードを読み取ると削除されることでした。そのため、アクセスするたびにこの値を書き換える必要がありました。 AGCには、固定ROMメモリ、有名な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステッチコア</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もありました。</font><font style="vertical-align: inherit;">これらはプログラムの保存に使用され、ワイヤーで物理的にステッチされていました（以下を参照）。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/ef2/724/d84/ef2724d84b9c6240b02427fc24ef3a83.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステッチされたコアのクローズアップメモリ</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NORバルブ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AGCは、IPを使用した最初のコンピューターの1つでした。</font><font style="vertical-align: inherit;">これらの最初のIPの可能性は非常に限られていた。</font><font style="vertical-align: inherit;">AGCチップ（下）には、6つのトランジスタと8つの抵抗しかありませんでした。これらを合わせて、3つの入力を持つNORゲートを実装しました。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/258/c26/1f6/258c261f6d06ff7537280d6205631ec3.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AGCからの3つの入力を持つデュアルNORバルブ。</font><font style="vertical-align: inherit;">水晶の外側の10本のワイヤは、ICの外部接点に接続されています。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NORバルブの略図を以下に示します。これは最も単純な論理ゲートです。すべての入力がゼロに等しい場合、出力は1に等しくなります。驚くかもしれませんが、コンピュータを作成するには1つのNORゲートで十分です。 NORはユニバーサルバルブです。他のロジックバルブの作成に使用できます。たとえば、すべてのNOR入力を組み合わせると、インバータが得られます。 NORの出力にインバーターを配置すると、ORバルブが得られます。 NORゲートの入力にインバーターを配置すると、ANDゲートができます。また、これらのゲートから、トリガー、加算器、カウンターなどのより複雑なロジックを構築できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NANDバルブには同じ汎用性があります。最新の回路では、技術的な理由により、NANDがNORよりも頻繁に使用されます。人気のコースで「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NANDからテトリスへ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「テトリスゲームの実装まで、NANDゲートからコンピューターを作成する方法について説明します。最初に、論理ゲートのセット（NOT、AND、OR、XOR、マルチプレクサー、デマルチプレクサー）がNANDから構築されます。次に、それらからより大きなビルディングブロックが作成されます（トリガー、加算器、カウンター、ALU、レジスタ）、およびそれらの1つはすでにコンピューターです</font><i><font style="vertical-align: inherit;">。NOR-gate</font></i><font style="vertical-align: inherit;">は、</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/508/de6/6ef/508de66ef3b9b88d05adc5f216b91be1.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての入力に0がある場合、1を生成します。少なくとも1つの入力に1がある場合、NORは0を返します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AGCでは、RSトリガー（セットリセット、セット/リセット）などのコンポーネントに遭遇することがよくあります。</font><font style="vertical-align: inherit;">この回路は2つのNORゲートで構成され、1つのデータビットを格納します。</font><font style="vertical-align: inherit;">ビット1はセット入力に保存され、ビット0はリセット入力に保存されます。つまり、パルス1がセット入力に適用され、上部バルブがオフになり、下部バルブがオンになるため、出力1がオフになります。リセット入力に供給されるパルス1は、反対のことを行います。</font><font style="vertical-align: inherit;">両方の入力に0を適用すると、トリガーは以前の状態を記憶し、ドライブの役割を果たします。</font><font style="vertical-align: inherit;">次のセクションでは、トリガーからレジスターを作成する方法を示します。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e0a/0a2/0b4/e0a0a20b41a43e4e9ceb701b27d6719b.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つのNORゲートのRSトリガー。</font><font style="vertical-align: inherit;">1つのバルブをオンにすると、もう1つのバルブがオフになります。</font><font style="vertical-align: inherit;">一方の出力の上にある線は、もう一方を補完していることを示しています。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">登録</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AGCには、メインメモリ外の値を一時的に格納するための小さなレジスタセットがあります。メインレジスタは、多くの算術演算で使用されるドライブ（A）です。また、カウンターレジスタZ、算術ブロックレジスタXおよびY、バッファーB、戻りアドレスQ、およびその他のいくつか（現代のコンピューターは、スタックを使用してサブルーチンを呼び出し、サブルーチンから戻るが、その時代にはプログラマーはスタック自体を再帰に書き込む必要があった）メモリへのアクセスのために、メモリアドレスレジスタSがあり、データのために、メモリバッファレジスタGがあります。また、AGCはメインメモリにレジスタを備えています-たとえば、入力/出力カウンター。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の図は、AGCレジスタースキームを示しています。これは、1ビットと2つのレジスターの場合の簡略化されています。各レジスタビットには、前述のスキーム（青と紫）を使用したトリガーがあります。データは、書き込みバス（赤）を介してレジスタとの間で転送されます。レジスタに書き込むために、トリガーはクリア信号（CQGまたはCZG、緑）によってリセットされます。次に、「書き込み」信号（WQGまたはWZG、オレンジ）により、書き込みバスに沿ったデータが対応するレジスタトリガーを設定できます。レジスタを読み取るために、読み取り信号（RQGまたはRZG、シアン）はトリガー出力を記録アンプを介して書き込みバスに渡し、AGCの他の部分で使用されます。完全なレジスタスキームはより複雑で、16ビットのレジスタがいくつかありますが、基本的なスキームはこれです。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2dd/574/2d6/2dd5742d6a82569618121f3a6382fefc.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AGCレジスタ操作の簡素化</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レジスター・チャートは、3つの重要なポイントを示しています。</font><font style="vertical-align: inherit;">まず、レジスタ回路はNORゲートから構築されています。</font><font style="vertical-align: inherit;">次に、データの移動は書き込みバスを中心に構築されます。</font><font style="vertical-align: inherit;">最後に、レジスタの動作は、適切なタイミングで到達する特定の制御信号に依存します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算モジュール</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどのコンピューターには、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算術</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算とブール演算を実行する算術</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">論理デバイス</font></a><font style="vertical-align: inherit;">があります。最近のコンピューターと比較して、AGCの演算モジュールは非常に制限されています。これは16ビット量の加算のみを実行するため、算術論理ではなく、算術モジュールと呼ばれます（残りの演算はさまざまなトリックによって実行されます。たとえば、減算は加算によって実行されます。引数の1つで、ビットが逆になっている、など）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の図は、AGC演算モジュールの1ビットを示しています。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">全加算器</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（赤）2ビットの合計を計算して桁上げします。転送は次の加算器に転送されます-このように組み合わせてより長いワードを追加できます（111111111111111 + 1のような場合に転送の転送を高速化するために、AGCは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">転送スキップ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">付きの加算器を使用します</font><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4a7/a6d/054/4a7a6d0548b3ea363789cbe7fb49e63c.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レジスタXおよびY（紫と緑）は、加算器に2つの入力ビットを提供します。これらは、NORバルブですでに説明されているトリガーを使用して実装されます。青いループは、制御信号に従ってXレジスタとYレジスタに値を書き込みます。スキームを使用すると、レジスタをシフトして定数と値を格納できるため、このスキームは非常に複雑ですが、このトピックについては説明しません。レジスタAの値をレジスタXに転送する制御信号A2Xに注意してください。後で彼に戻ってきます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下の写真は、AGC回路の物理的な実装を示しています。</font><font style="vertical-align: inherit;">このモジュールは、レジスタと演算モジュール用に4ビットを実装しています。</font><font style="vertical-align: inherit;">黒い長方形はフラットIPです。</font><font style="vertical-align: inherit;">各モジュールには、それぞれ60チップの2つのボードがあり、合計で240のNORゲートがあります。</font><font style="vertical-align: inherit;">演算モジュールとレジスターは、4つの同一モジュールから組み立てられ、それぞれが4ビットを処理します。</font><font style="vertical-align: inherit;">これは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロプロセッサセクションに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">似てい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/ec2/b20/51a/ec2b2051a591e1444a970d0c6eb21a3b.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算モジュールとレジスタは、4つの同一のモジュールから組み立てられます。</font><font style="vertical-align: inherit;">モジュールは、A8からA11までのスロットに取り付けられます。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令実行</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションでは、AGCが命令を実行するために実行する一連の操作について説明します。特に、ADS（ストレージに追加）命令がどのように機能するかを示します。この命令は、メモリから値を読み取り、ドライブ（レジスタA）に追加して、合計を加算器とメモリの両方に保存します。これは単一の命令ですが、その実行のためにAGCはいくつかのステップを踏み、多くの値があちこちに移動されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
命令コアは、磁気コアのメモリサブシステムにより実装されています。特に、メモリから値を読み取ると、格納されている値が消去されるため、各読み取り後に値を書き戻す必要があります。また、メモリにアクセスする際、アドレスの指定とデータの受信の間に遅延があります。その結果、各クロックサイクルは、読み取りとその後の記録に12ステップを費やします。各時間間隔（T1からT12まで）はマイクロ秒より少し長く続き、サイクル全体は11.7μs続き、メモリサイクルタイム（MCT）と呼ばれます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d96/839/08a/d9683908aea50b1f70485d0e787cdfb5.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AGCの消去可能な磁気コアメモリモジュール。 2キロシートを保存し、各ビットは個別の小さなフェライトリングを使用して保存されます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MCTは、命令を実行するためのメモリの基本単位です。一般的な命令には2サイクルのメモリが必要です。1つはメモリから命令を抽出するため、もう1つは操作を実行するためです。したがって、一般的な命令は2つのMCT（23.4μs）を必要とし、これにより毎秒43,000命令が得られます（最近のプロセッサとその数十億の命令と比較すると、これは非常に低速です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AGCは命令を処理し、それらをサブコマンドに分割します。各サブコマンドはメモリの1クロックサイクルを要します。たとえば、ADS命令は、ADS0（追加）とSTD2（次の命令を呼び出す）の2つのサブコマンドで構成されています。次の図は、ADS0命令を実行するためのAGC内のデータの動きを示しています。 12小節は左から右に進みます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/48f/cca/d82/48fccad826389951d668d809754c5fcf.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も重要な手順は次のとおりです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
T1：オペランドアドレスが命令レジスタBからメモリアドレスレジスタSにコピーされ、メモリからの読み取りが開始されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
T4：オペランドはメモリからメモリデータレジスタGに読み込まれます</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。T5：オペランドはGから加算器Yにコピーされます。ドライブAの値は加算器Xにコピーされます</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。T6：加算器は合計Uを計算し、メモリデータレジスタGにコピーします</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。T8：プログラムカウンタZは、メモリから次の命令を受信する準備として、メモリアドレスレジスタSにコピーされます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
T10：メモリGのデータレジスタからの合計がメモリに書き戻されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
T11：量UがドライブAにコピーされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは単純な加算命令ですが、多くのデータが12のタイムスロットに転送されます。</font><font style="vertical-align: inherit;">そして、これらの各アクションには、特定の制御信号が関連付けられています。</font><font style="vertical-align: inherit;">たとえば、間隔T5の信号A2Xは、ドライブAからレジスタXに値をコピーします。レジスタGをレジスタYにコピーするには、RG（Gの読み取り）とWY（Yの書き込み）の2つの制御パルスが必要です。</font><font style="vertical-align: inherit;">次のセクションでは、AGCコントロールモジュールが各命令に必要な制御信号を生成する方法について説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制御モジュール</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどのコンピュータと同様に、AGC制御モジュールは各命令をデコードし、プロセッサの残りの部分に実行する必要があることを伝える制御信号を生成します。 AGCは、信号を生成するために、NORバルブで構成される事前にプログラムされた制御モジュールを使用します。 AGCはマイクロコードを使用しません。物理的なスペースを取りすぎてしまうため、彼にはマイクロ命令と制御メモリはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AGCコントロールモジュールの中心は、クロスポイントジェネレーターと呼ばれます。サブコマンドと期間の1つを取り、この組み合わせの制御信号を生成します。これは、サブコマンドが一方向に進み、タイムセグメントが別の方向に進むラティスの形で想像できます。各コントロールポイントには、独自のコントロール信号が割り当てられています。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/823/4c6/65d/8234c665d5ef9aa344ac6b36aa34ac03.jpg"><br>
<i>         ;   6.     ,  .        ;        .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
効率性のために、最終制御モジュールは高度に最適化されています。同様の動作をする命令は、交差発生器によって結合および処理されるため、必要な回路のサイズが削減されます。たとえば、AGCには「倍精度でドライブに追加する」（DAS）という命令があります。これは、シングルワードの2つの追加にほぼ等しいため、共通部分ジェネレーターのDAS1およびADS0サブコマンドは、共通のロジックを持っています。以下の図は、時間間隔T5の交差点発生器回路を示し、ADS0サブコマンドのロジック（信号DAS1を使用）が強調表示されています。たとえば、5K信号はDAS1とT5の組み合わせから生成されます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2fa/632/0c8/2fa6320c814c37539e39b105502c520c.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、5Kおよび5L信号とは何ですか？これは別の最適化です。多くの制御パルスはしばしば一緒に供給されるので、それらを直接生成する代わりに、交差生成器は交差の中間信号を生成します。例えば、5Kは制御パルスA2XとRGを生成し、5Lは制御パルスWYを生成します。次の図は、A2X信号の生成方法を示しています。8つの異なる信号（5Kを含む）のいずれかがA2Xを生成します。同様の回路が他の制御信号を生成します。これらの最適化により、交差ジェネレーターのサイズを縮小することが可能になりましたが、それでも依然として大きなままであり、最大3つのモジュールに成長しました。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f6f/1eb/3fe/f6f1eb3fef7bf5a9501721d41fbf0384.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要約すると、制御モジュールは、命令を実行するために何をすべきかをCPUに伝える責任があると言えます。最初に、命令はサブコマンドに分解されます。交差発生器は、各時間間隔とサブコマンドに必要な制御パルスを生成し、レジスタ、演算モジュール、およびメモリに、それらが実行する必要があることを伝えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、命令は2つのサブコマンドで構成されていましたが、例外がありました。乗算や除算などの一部の命令は、多くのステップで構成されているため、多くのサブコマンドを使用する必要がありました。逆に、TCのジャンプ命令は、次の命令を呼び出すだけでよいため、1つのサブコマンドを使用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のプロセッサは、制御信号の生成に異なるアプローチを使用しました。</font><font style="vertical-align: inherit;">6502および他の多くの初期のマイクロプロセッサは、読み取り専用メモリを通じてAND / ORロジックを実装するプログラマブルロジックアレイ（PLA）を使用して命令をデコードしました。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7f2/5cc/744/7f25cc7445e19ed5166871137f09ef45.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロプロセッサ6502。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、アポロの車載制御コンピューターのエキサイティングなツアーでした。あまり伸ばさないように、ADSの追加命令といくつかの制御パルス（A2X、RG、WY）に集中しました。 NORバルブなどの原始的な要素からコンピューターを組み立てる方法のアイデアが得られたら幸いです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アーキテクチャの最も目に見える部分は、データパスです。つまり、算術モジュール、レジスタ、データバスです。 AGCレジスタは、NORゲートからの単純なトリガーに基づいています。また、AGC演算モジュールは加算のみを実行できますが、コンピューターは依然として、乗算、除算、ブール演算を含む一連の演算全体を処理できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、データパスはコンピュータの一部にすぎません。</font><font style="vertical-align: inherit;">他の重要なコンポーネントの中には、コンポーネントに必要な処理を指示する制御モジュールがあります。</font><font style="vertical-align: inherit;">AGCで使用されるアプローチは、高度に最適化されハードコードされたロジックを使用して特定のサブコマンドと時間間隔の正しい制御パルスを生成する交差ジェネレーターに基づいています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの機能を使用して、AGCはアポロミッションのガイダンス、ナビゲーション、および制御を提供し、月への着陸を可能にしました。</font><font style="vertical-align: inherit;">彼はまた、1963年に米国製ICの60％を使用して初期の集積回路産業に拍車をかけました。したがって、現代のコンピューターはAGCとその単純なNORコンポーネントに多くを負っています。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/4a0/698/fe2/4a0698fe2f8ad8f4717d966bffc3a3e4.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AGCはTektronixビンテージオシロスコープに接続されたラボで動作します</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja472776/index.html">バックアップパート7：結論</a></li>
<li><a href="../ja472778/index.html">Raspberry Piを有益に使用する5つの方法</a></li>
<li><a href="../ja472780/index.html">なぜ友達を避けるのか、またはどのようにして私の利点をすべて失ったのか</a></li>
<li><a href="../ja472782/index.html">なぜ3Dの頭痛/パート8デフォーカスと3Dの未来</a></li>
<li><a href="../ja472790/index.html">骨董品：ビジネスのコミュニケーター、i-Mate Jasjar</a></li>
<li><a href="../ja472796/index.html">YESは、FAANG *または[実用ガイド]をITスペシャリスト向けの米国/ヨーロッパでの就職活動に活用します</a></li>
<li><a href="../ja472798/index.html">タクシーアプリケーションのYandexマップ</a></li>
<li><a href="../ja472802/index.html">MIROはオープンな屋内ロボットプラットフォームです。パート2-ロボットの設計</a></li>
<li><a href="../ja472810/index.html">初心者のシステム管理者：無秩序から秩序を作る方法</a></li>
<li><a href="../ja472812/index.html">データセンターの煙テストが「発砲」した場合、サーバーを「消火」する必要がありますか？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>