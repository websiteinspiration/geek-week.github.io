<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🎤 💖 🦖 Kartesische Baumsortierung 🏺 ⏬ 🛸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein frischer Blick auf traditionelle Konzepte. Heute wird es einen solchen "Kartesier" geben, den die Schule nicht bestanden hat.
 
 
 Das Wesentliche...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kartesische Baumsortierung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/505744/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein frischer Blick auf traditionelle Konzepte. </font><font style="vertical-align: inherit;">Heute wird es einen solchen "Kartesier" geben, den die Schule nicht bestanden hat.</font></font></i><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><div style="text-align:center;"><img width="700" height="525" src="https://habrastorage.org/webt/hx/f6/fp/hxf6fphv_nedheqxyqyom6qugw4.jpeg"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Wesentliche des Algorithmus ist, dass auf der Basis des Arrays der sogenannte </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kartesische Baum erstellt wird</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Und aus dem konstruierten kartesischen Baum ist es sehr einfach, alle Elemente in aufsteigender oder absteigender Reihenfolge zu erhalten.</font></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="EDISON Software - Webentwicklung"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - Webentwicklung"></a><br clear="right">
 EDISON     .<br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img align="right" width="340" height="227" src="https://habrastorage.org/webt/84/rh/rr/84rhrrsxgdeqa8xxpf5b2dub_wk.png"></a><br clear="left">
     — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   Vivaldi</a>,             .<br>
<br>
    , , ! ;-)<div style="text-align:center;"><img width="770" height="1" src="https://habrastorage.org/webt/mw/wy/cu/mwwycuqpta7m96dxifyx9if7mu8.gif"></div></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Rahmen dieses Artikels habe ich beschlossen, auf eine detaillierte Theorie zu verzichten und werde nicht erklären, was ein kartesischer Baum ist, wie man ihn baut und welche Operationen damit möglich sind. Dies wurde bereits vor mir perfekt gemacht - es gibt ausgezeichnetes Material über Habré, wo all diese Momente erfolgreich und gründlich behandelt wurden - am Ende dieses Vortrags gibt es einen Abschnitt "Links", in dem Sie zu diesen Harastrastam gehen können. In Zukunft werde ich einige Punkte behandeln, die für diese Struktur charakteristisch sind, aber es versteht sich, dass Sie ihre Besonderheiten verstehen oder, falls Sie interessiert sind, bereit sind, sie über die folgenden Links zu studieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein kartesischer Baum ist eine Hybridstruktur, die die Eigenschaften eines Heaps und eines binären Suchbaums kombiniert. Es gibt Synonyme für diesen Baum, die im Artikel verwendet werden: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deramid</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revaux + Fest </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bromid</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reise</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Treap</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ee + h </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UAP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und sogar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Duch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erevo + an die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lehre</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir dieses Array als Beispiel: </font></font><br>
<br>
<img width="421" height="42" src="https://habrastorage.org/webt/qe/8j/nq/qe8jnql9ux0yjhtgddkd5zg35ts.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">uns an, wie der binäre Suchbaum, der Heap und der Deramid dafür aussehen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binärer Suchbaum</font></font></h3><br>
<img width="421" height="42" src="https://habrastorage.org/webt/qe/8j/nq/qe8jnql9ux0yjhtgddkd5zg35ts.png"><br>
<img align="left" width="211" height="414" src="https://habrastorage.org/webt/tq/o9/k0/tqo9k0oscidinobj1inalmaelea.png"><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erscheinungsbild des Baums hängt stark davon ab, wie sich die Elemente des Arrays ursprünglich befinden. Basierend auf zufälligen Daten wird sich herausstellen, dass ein Baum mit einer hohen Wahrscheinlichkeit unausgeglichen ist und eine viel größere Anzahl von Ebenen aufweist als die optimale. In unserem Beispiel wurden 7 Ebenen gebildet. Wenn die Elemente des Arrays beispielsweise in dieser Reihenfolge angeordnet </font><font style="vertical-align: inherit;">
wären </font><font style="vertical-align: inherit;">: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
25, 28, 29, 23, 30, 27, 24, 22, 21, 26 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, würde der Suchbaum mit der minimal möglichen Anzahl von Ebenen (= 4) ausgeglichen. Das Sortieren unter Verwendung eines ausgeglichenen Baums hätte Zeitkomplexität: </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Bei einem unausgeglichenen Baum kann er sich jedoch zu </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verschlechtern </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der vorherigen Habrastatia wurde die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sortierung nach einem binären Suchbaum sowie dessen interessante Modifikation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berücksichtigt </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">,</font></a><font style="vertical-align: inherit;"> die eine garantierte Sortierung mit zeitlicher Komplexität von </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ermöglicht</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je unausgewogener der Suchbaum ist, desto teurer ist es, ihn zu durchlaufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der anderen Seite ist das Speichern von Daten im Suchbaum aus organisatorischer Sicht sehr praktisch. Sie können mit diesen Daten viele Vorgänge ausführen, einschließlich Sortieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Elternteil in einem binären Suchbaum ist nicht unbedingt mehr als ein Kind. Gleichzeitig ist das linke Kind immer kleiner als das Elternteil, das rechte Kind ist immer größer als das Elternteil (oder gleich).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das maximale Element des Arrays beim Erstellen des Suchbaums liegt irgendwo im rechten Teilbaum. </font><font style="vertical-align: inherit;">Um dieses Maximum zu extrahieren, muss der Suchbaum vollständig umgangen werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binärer Haufen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In einem gewöhnlichen Haufen sind Eltern-Kind-Beziehungen sehr einfach organisiert und an die Elementindizes selbst gebunden. </font></font><br>
<br>
<div style="text-align:center;"><img width="589" height="270" src="https://habrastorage.org/webt/e1/tw/um/e1twumtre1o-wzh5etq-qpkun10.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Figur ist eigentlich noch kein Haufen, da ein solcher Baum, der ursprünglich auf einem zufälligen Array aufgebaut war, noch nicht sortiert ist. </font><font style="vertical-align: inherit;">Sie müssen jedes Element umgehen und es sieben. </font><font style="vertical-align: inherit;">Infolgedessen werden die Elemente im Array neu erstellt, sodass jedes übergeordnete Element größer als sein Nachkomme ist:</font></font><br>
<br>
<div style="text-align:center;"><img width="589" height="270" src="https://habrastorage.org/webt/qb/p3/tt/qbp3ttzf2za1g0xqvznq9azoxzm.png"></div> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das maximale Element befindet sich an der Wurzel des Baums. </font><font style="vertical-align: inherit;">Sein Standort ist bekannt, Sie müssen nicht danach suchen. </font><font style="vertical-align: inherit;">Wenn Sie dagegen das Maximum aus dem Heap extrahieren (und stattdessen ein anderes Element des Arrays in die Wurzel des Baums einfügen müssen), ist der Heap kein Sortierbaum mehr, sondern muss erneut gesiebt werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kartesischer Baum</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und schließlich der kartesische Baum. </font><font style="vertical-align: inherit;">Beziehungen sind so aufgebaut, dass es einerseits ein Haufen ist, wenn man sich die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Werte der</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Elemente ansieht. </font><font style="vertical-align: inherit;">Alle Eltern sind mehr als ihre Nachkommen:</font></font><br>
<br>
<div style="text-align:center;"><img width="421" height="290" src="https://habrastorage.org/webt/cq/f9/xr/cqf9xrcsibbvwoxs3ygawzrrszk.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Andererseits ist eine Struktur ein binärer Suchbaum, wenn Sie die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indizes von</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Elementen betrachten. </font><font style="vertical-align: inherit;">Aus Gründen der Übersichtlichkeit wurden die Werte der Elemente in den Knoten aus dem Bild im Baum entfernt, es wurden nur Indizes übrig gelassen. </font><font style="vertical-align: inherit;">Jeder linke Nachkomme ist kleiner als der Elternteil, jeder rechte Nachkomme ist größer als der Elternteil:</font></font><br>
<br>
<div style="text-align:center;"><img width="421" height="280" src="https://habrastorage.org/webt/in/rk/fq/inrkfq0kqfx6ha3b1q8r276xlpm.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einerseits haben wir schnellen Zugriff auf das maximale Element. Da dies ein Haufen ist, liegt das Maximum an der Wurzel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der anderen Seite können Sie das Maximum einfach aus der Struktur entfernen und mit den verbleibenden Daten weiterarbeiten. Da dies ein binärer Suchbaum ist, ist das Entfernen der Wurzel nicht teuer. In den Eltern-Kind-Beziehungen treten relativ kleine Änderungen auf, ein neues Maximum trifft die Wurzel des kartesischen Baums und Sie können weiterarbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes Element ist durch zwei Zahlen gekennzeichnet - den Wert des Elements und den Index des Elements im Array. Der Index kann als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinate </font><font style="vertical-align: inherit;">, der Wert als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und das Element selbst als Punkt auf der Koordinatenebene interpretiert werden. Wenn Eltern und Nachkommen durch Pfeile verbunden sind, erhalten wir ungefähr Folgendes:</font></font><br>
<br>
<div style="text-align:center;"><img width="435" height="404" src="https://habrastorage.org/webt/bh/rg/pv/bhrgpviw4kai2rkn_hfysb_kwv8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Abbildung in der Grafik ist vollständig isomorph zum kartesischen Baum direkt darüber.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kartesische Baumsorte :: Kartesische Baumsorte</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der endgültige Algorithmus:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I. Basierend auf einem unsortierten Array konstruieren wir einen kartesischen Baum:</font></font></b><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I.1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durchlaufen Sie die Elemente des Arrays von links nach rechts.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I.1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn dies das erste Element des Arrays ist, ist es einfach der allererste Knoten des kartesischen Baums.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I.2. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn dies nicht das erste Element des Arrays ist, betrachten Sie dies als einen kartesischen Baum, der aus einem Element besteht. </font><font style="vertical-align: inherit;">Wir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">führen die Zusammenführungsoperation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dieses Baums mit dem Baum aus, der aus den vorherigen Elementen erstellt wurde.</font></font></li>
</ul></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II. </font><font style="vertical-align: inherit;">Wir löschen das aktuelle maximale Element aus dem Baum, danach stellen wir den kartesischen Baum wieder her.</font></font></b><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das aktuelle maximale Element ist die Wurzel des Baums.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.2. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir entfernen die Wurzel aus dem Baum und übertragen das maximale Element in ein zusätzliches Array.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.3. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Entfernen der Wurzel teilte sich die Struktur in zwei kartesische Bäume.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.4. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für diese beiden Bäume führen wir die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenführungsoperation aus</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Das neue aktuelle Maximum ist eine der Wurzeln der verbundenen Bäume.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.5. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederholen Sie für ein neues Hoch die Schritte II.1-II.4 erneut.</font></font></li>
</ul></li>
</ul><br>
<br>
<div style="text-align:center;"><img width="759" height="406" src="https://habrastorage.org/webt/wu/ev/zx/wuevzx7thmypyyovaldixw5xxa0.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implementierung in C ++:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/*
 * c++ 11 code to construct a Cartesian tree. The method cartesianTreeSort
 * will sort the contents of the array.
 */</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>{</span>
    <span class="hljs-keyword">int</span> value;<font></font>
    Node *left, *right;<font></font>
    Node *parent;<font></font>
<font></font>
    Node(){<font></font>
        value = <span class="hljs-number">0</span>;<font></font>
        parent = <span class="hljs-literal">NULL</span>;<font></font>
        left = <span class="hljs-literal">NULL</span>;<font></font>
        right = <span class="hljs-literal">NULL</span>;<font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// Used by priority queue</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">compare</span>{</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Node *left, Node *right)</span></span>{
        <span class="hljs-keyword">return</span> left-&gt;value &gt; right-&gt;value;<font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartesianTree</span>{</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// last pointer to keep track of last node added</span><font></font>
    Node *root, *last;<font></font>
<font></font>
    <span class="hljs-function">Node * <span class="hljs-title">findLowestNode</span><span class="hljs-params">(Node *node, <span class="hljs-keyword">int</span> x)</span></span>{
        <span class="hljs-keyword">if</span>(node-&gt;value &lt; x)
            <span class="hljs-keyword">return</span> node;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(node-&gt;parent != <span class="hljs-literal">NULL</span>)
            <span class="hljs-keyword">return</span> findLowestNode(node-&gt;parent, x);
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
    }<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Node * <span class="hljs-title">getRoot</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">return</span> root;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>{<font></font>
        Node *new_node = <span class="hljs-keyword">new</span> Node;<font></font>
        new_node-&gt;value = x;<font></font>
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>){<font></font>
            last = new_node;<font></font>
            root = new_node;<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        Node *z = findLowestNode(last, x);<font></font>
        <span class="hljs-keyword">if</span>(z == <span class="hljs-literal">NULL</span>){<font></font>
            new_node-&gt;left = root;<font></font>
            root-&gt;parent = new_node;<font></font>
            root = new_node;<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span>{<font></font>
            new_node-&gt;left = z-&gt;right;<font></font>
            z-&gt;right = new_node;<font></font>
            new_node-&gt;parent = z;<font></font>
        }<font></font>
        last = new_node;<font></font>
    }<font></font>
<font></font>
    CartesianTree(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ar){<font></font>
        root = <span class="hljs-literal">NULL</span>;<font></font>
        last = <span class="hljs-literal">NULL</span>;
        <span class="hljs-comment">// Call addNode function for each element of the array</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : ar){<font></font>
            addNode(x);<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InorderTraversal</span><span class="hljs-params">(Node *node)</span></span>{
        <span class="hljs-comment">// To print inorder traversal of the tree</span>
        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>)
            <span class="hljs-keyword">return</span>;<font></font>
        InorderTraversal(node-&gt;left);<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; node-&gt;value &lt;&lt; <span class="hljs-string">' '</span>;<font></font>
        InorderTraversal(node-&gt;right);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Function to sort and store values in array</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cartesianTreeSort</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;sorted_ar)</span></span>{
        <span class="hljs-comment">// Initialize input array</span>
        sorted_ar.assign(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Initialize priority queue</span>
        <span class="hljs-built_in">std</span>::priority_queue&lt;Node *, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Node *&gt;, compare&gt; p_queue;<font></font>
        p_queue.push(root);<font></font>
        Node *temp = <span class="hljs-literal">NULL</span>;
        <span class="hljs-keyword">while</span>(!p_queue.empty()){<font></font>
            temp = p_queue.top();<font></font>
            p_queue.pop();<font></font>
            sorted_ar.push_back(temp-&gt;value);<font></font>
            <span class="hljs-keyword">if</span>(temp-&gt;left){<font></font>
                p_queue.push(temp-&gt;left);<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span>(temp-&gt;right){<font></font>
                p_queue.push(temp-&gt;right);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ar = {<span class="hljs-number">1</span>, <span class="hljs-number">14</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>};<font></font>
<font></font>
    <span class="hljs-function">CartesianTree <span class="hljs-title">tree</span><span class="hljs-params">(ar)</span></span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Inorder Traversal\n"</span>;<font></font>
    tree.InorderTraversal(tree.getRoot());<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">'\n'</span>;<font></font>
<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sorted;<font></font>
    tree.cartesianTreeSort(sorted);<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Sorted array is\n"</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : sorted)
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">' '</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">'\n'</span>;<font></font>
}</code></pre><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komplexität</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein kartesischer Baum mit minimalen Kosten verarbeitet die sortierten und fast sortierten (und es spielt keine Rolle, in aufsteigenden oder absteigenden) Abschnitte des Arrays. </font><font style="vertical-align: inherit;">Hier ist zum Beispiel der Prozess für ein Array in umgekehrter Reihenfolge:</font></font><br>
<br>
<div style="text-align:center;"><img width="594" height="521" src="https://habrastorage.org/webt/_6/7a/tt/_67attvixuawod4utn7wblzpzey.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der teuerste Teil des Algorithmus ist die Zusammenführungsoperation, die für jedes der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Elemente zweimal ausgeführt werden muss - zuerst beim Aufbau des Deramids und dann beim Zerlegen. Bei zufälligen Daten kostet eine einmalige Zusammenführungsoperation </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , für Elemente, die sich in geordneten Bereichen des Arrays befinden, jedoch die Kosten für die O (1) -Operation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit ist die durchschnittliche und schlechteste zeitliche Komplexität der Sortierung </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die beste ist O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach zusätzlichem Speicher sind die Dinge schlimmer - O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Wenn der kartesische Baum nur eine Art Haufen wäre, wären die Kosten O (1). </font><font style="vertical-align: inherit;">Der kartesische Baum ist aber auch ein binärer Suchbaum, weshalb für alle </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Elemente die Eltern-Kind-Beziehungen separat gespeichert werden müssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus bedeutet die Implementierung in dieser Form, dass es sich um eine externe Sortierung handelt - die sortierten Elemente werden in einem separaten Array gesammelt. </font><font style="vertical-align: inherit;">Und dies ist O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) für zusätzlichen Speicher.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verweise</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kartesischer </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/jw/w-/qu/jww-queszzqnwmoa2hm-kfwu-9o.png"> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kartesischer Baum: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 3</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serienartikel:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excel-Anwendung AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sorte austauschen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfügungssortierungen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Auswahl sortieren</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: N-Pyramiden</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Leonardo Numbers</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap-Sortierung: schwacher Heap</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bündelsorten: Kartesischer Baum</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Heap-Sortierungen: Spiegelhaufen, Mini-Heap, Sieben von unten nach oben</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap Sorts: Jung Heap</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sortierungen zusammenführen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach Verteilung sortieren</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hybridsortierung</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die heutige kartesische Baumsortierung wurde der AlgoLab-Anwendung hinzugefügt, die sie verwendet. Aktualisieren Sie die Excel-Datei mit Makros. </font><font style="vertical-align: inherit;">Ich empfehle Arrays mit einer kleinen Streuung der Werte der Elemente zu verwenden - andernfalls passt die kartesische Ebene nicht auf den Bildschirm.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de505710/index.html">WebSockets und Spring WebFlux</a></li>
<li><a href="../de505720/index.html">Spring Boot + Apache Kafka und SSL im Docker-Container</a></li>
<li><a href="../de505724/index.html">Russische faire Verwendung: Wo ist die Urheberrechtsgrenze?</a></li>
<li><a href="../de505736/index.html">Ausführen, PHPUnit, Ausführen: Wie ich die Testausführungszeit optimiert habe</a></li>
<li><a href="../de505738/index.html">Ein bisschen über Periodogramme von Zeitreihen</a></li>
<li><a href="../de505746/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 418 (1. - 7. Juni 2020)</a></li>
<li><a href="../de505752/index.html">Kommentare zur Richtigkeit der Informationen in der Datenbank von Rosreestr und FSIS USRN</a></li>
<li><a href="../en486014/index.html">SLAC Tour: US Department of Energy National Accelerator Laboratory at Stanford</a></li>
<li><a href="../en486018/index.html">Session Survey Results</a></li>
<li><a href="../en486024/index.html">Really simple graphics in R for science and journalism</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>