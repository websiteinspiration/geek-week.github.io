<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕 🚥 👩🏿‍🏫 C ++ロシア：いかがでしたか 📳 🎬 👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="プレイの最初にC ++コードが壁にぶら下がっていると言ったら、最後には間違いなくあなたを足で撃つはずです。
 
 Bjarne Stroustrup
 
 10月31日から11月1日まで、PUGは、JUG Ruグループが主催するロシア最大のプログラミング会議の1つであるC ++ Russia Pit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C ++ロシア：いかがでしたか</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/481358/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレイの最初にC ++コードが壁にぶら下がっていると言ったら、最後には間違いなくあなたを足で撃つはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bjarne Stroustrup</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
10月31日から11月1日まで、PUGは、JUG Ruグループが主催するロシア最大のプログラミング会議の1つであるC ++ Russia Piter会議を主催しました。招待講演者の中には、C ++標準化委員会のメンバー、CppConの講演者、O'Reillyの本の著者、LLVM、libc ++、Boostなどのプロジェクトのメンテナーがいます。このカンファレンスは、専門知識を深め、ライブコミュニケーションの経験を交換したい経験豊富なC ++開発者を対象としています。学生、大学院生、大学教授は非常に快適な割引を提供しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
会議のモスクワ版は来年の4月にすでに訪問することができます、そして今のところ、私たちの学生は彼らが最後のイベントで学んだ面白いことを教えてくれます。&nbsp;</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a73/7bf/78f/a737bf78fa7a626dc60d87aae2d2ce88.png"><br>
<a name="habracut"></a><br>
<i><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">会議アルバムの</font></a><font style="vertical-align: inherit;">写真</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちに関しては</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンクトペテルブルクの2人のHSE学生がこの投稿に取り組みました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リサヴァシレンコは、「応用数学とコンピュータサイエンス」プログラムの一環として「プログラミング言語」の方向性を学ぶ4年生の学部生です。</font><font style="vertical-align: inherit;">大学1年目にC ++言語に精通し、その後、業界のインターンシップでC ++言語を使用した経験を積みました。</font><font style="vertical-align: inherit;">一般的なプログラミング言語への情熱、特に関数型プログラミングへの情熱は、会議でのレポートの選択に大きな影響を与えました。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danya Smirnovは、修士課程「データプログラミングと分析」の1年生です。</font><font style="vertical-align: inherit;">在学中にC ++でオリンピアードの問題を書きましたが、どういうわけか、言語は教育活動で絶えず浮上し、その結果、主な作業言語になりました。</font><font style="vertical-align: inherit;">知識を深め、新しい機会について学ぶために、会議に参加することにしました。</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ニュースレターでは、教員のリーダーが私たちの専門分野に関連する教育イベントに関する情報を共有することがよくあります。</font><font style="vertical-align: inherit;">9月、C ++ Russiaに関する情報を確認し、リスナーとして登録することを決定しました。</font><font style="vertical-align: inherit;">これは、このような会議に参加した最初の経験です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会議の構造</font></font></h2><br>
<ul>
<li><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">報告書</font></font></h3></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2日間で、専門家は30のレポートを読み、多くのホットトピックを強調します。適用された問題を解決するための言語機能の機知に富んだアプリケーション、新しい標準による今後の言語更新、C ++設計の妥協点、およびその結果を扱う際の注意事項、興味深いプロジェクトアーキテクチャの例、言語インフラストラクチャの一部のエンジン部分も同様です。</font><font style="vertical-align: inherit;">同時に、3回の公演が行われ、ほとんどがロシア語で2回、英語で1回行われました。</font></font><br>
<br>
<ul>
<li><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディスカッションゾーン</font></font></h3></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スピーチの後、すべての未回答の質問と不完全なディスカッションは、マーカーボードを備えたスピーカーと特別に指定されたコミュニケーションエリアに転送されました。</font><font style="vertical-align: inherit;">楽しい会話のために、公演の合間に休憩をとるのに良い方法です。</font></font><br>
<br>
<ul>
<li><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライトニングトークと非公式ディスカッション</font></font></h3></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短いレポートを作成したい場合は、マーカーボードで夜のライトニングトークにサインアップして、会議のトピックに関するあらゆることについて話す時間を5分得ることができます。たとえば、C ++のサニタイザの簡単な紹介（一部は新しいものであることが判明した）や、正弦波の生成におけるバグについての話ですが、聞くことはできますが、見ることはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの形式は、「The Soul Committee」を使ったパネルディスカッションです。ステージには標準化委員会のメンバーが何人かいます、プロジェクターには暖炉があります（公式には-ソウルフルな雰囲気を作るためですが、「すべてが炎上しているから」の理由はおかしいようです）、質問-C ++の標準的および一般的なビジョンについて、熱く技術的な議論やホリバーはありません。生きている人々も委員会に座っていることがわかりました。彼らは何かを完全に確信していないか、何かを知らないかもしれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ホリバー愛好家のために、3番目のイベントであるBOFセッション「Go反対C ++」が残りました。</font><font style="vertical-align: inherit;">私たちはセッションの開始前にGo愛好家、C ++愛好家を連れて行き、トピックに関する100500枚のスライドを一緒に準備し（C ++でのパッケージの問題やGoでのジェネリックの欠如など）、彼らは彼らと聴衆の間で活発に議論し、聴衆は2つの視点を一度に理解しようとします。</font><font style="vertical-align: inherit;">ホリバーがビジネスで始まらない場合、モデレーターが介入して当事者を調整します。</font><font style="vertical-align: inherit;">このフォーマットは中毒性があります。開始から数時間後、スライドの半分だけが完成しました。</font><font style="vertical-align: inherit;">終わりは大幅に加速されなければなりませんでした。</font></font><br>
<br>
<ul>
<li><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パートナースタンド</font></font></h3></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
会議パートナーはホールで代表されました-彼らはスタンドでの現在のプロジェクトについて話し、インターンシップと雇用を提供し、クイズと小さなコンテストを開催し、そしてまた素晴らしい賞品を演奏しました。</font><font style="vertical-align: inherit;">同時に、企業によってはインタビューの初期段階を踏むことを提案することもありました。これは、レポートを聞くだけでなく、来た人にも役立つかもしれません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レポートの技術詳細</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは両方の日にレポートを聞いた。</font><font style="vertical-align: inherit;">時々、並行して実行されているレポートから1つのレポートを選択するのが困難でした。休憩中に得られた知識を共有して交換することに同意しました。</font><font style="vertical-align: inherit;">それでも、多くが失われているようです。</font><font style="vertical-align: inherit;">ここで、最も興味深いと思われるいくつかのレポートの内容についてお話します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラー最適化のプリズムを介したC ++の例外、Roman Rusyaev</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/dc/0q/rl/dc0qrlgt1peqimzact93fvh8zb0.png"><br>
<i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレゼンテーション</font></font></a></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">スライド</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
名前が示すように、Romanは、例としてLLVMを使用して例外を処理することを検討しました。同時に、Clangを使用していない人のために、レポートはコードがどのように最適化される可能性があるかについてのアイデアを提供します。これは、コンパイラの開発者と対応する標準ライブラリが互いに通信し、多くの成功したソリューションが一致する可能性があるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、例外を処理するには、多くのアクションを実行する必要があります。処理コード（存在する場合）を呼び出すか、現在のレベルでリソースを解放して、スタックをより高くスピンします。これはすべて、コンパイラが潜在的に呼び出しをスローするための追加の命令を追加するという事実につながります。したがって、実際には例外が発生しない場合でも、プログラムは不要なアクションを実行し始めます。 LLVMは、オーバーヘッドコストを何らかの形で削減するために、例外処理コードを追加する必要がない状況を判断するためのいくつかのヒューリスティックを備えています。または、「不要な」命令の数を削減できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
話者は、それらの数十について検討し、プログラムの実行を高速化するのに役立つ状況と、これらの方法が適用できない状況の両方を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、Roman Rusyaevは、例外のある作業を含むコードは常にゼロのオーバーヘッドで実行できるとは限らないと結論付け、次のヒントを示します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリを開発するときは、原則として例外を放棄する必要があります。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それでも例外が必要な場合は、可能な限りnoexcept（およびconst）修飾子を追加して、コンパイラが可能な限り最適化できるようにすることをお勧めします。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、講演者は、例外は最小限にとどめるか、完全に放棄するのが最善であるという見解を繰り返した。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レポートのスライドは次の場所にあります。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[「LLVMコンパイラー最適化のプリズムによるC ++例外」]</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジェネレーター、コルーチン、その他の脳を開く甘さ、Adi Shavit</font></font></h3><br>
<img src="https://habrastorage.org/getpro/habr/post_images/d20/0c4/4a6/d200c44a65058c3b50a29d0b551a9cc0.png"><br>
<i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレゼンテーション</font></font></a></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">からのスライド</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
C ++ 20の革新に焦点を当てたこの会議の多くのレポートの1つは、そのカラフルに設計されたプレゼンテーションだけでなく、コレクションの処理ロジック（コールバックなど）の問題の明確な指摘によっても記憶されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adi Shavitは以下を強調しています：現在利用可能なメソッドはコレクション全体を通過し、同時にいくつかの内部中間状態へのアクセスを許可しません（またはコールバックの場合は許可しますが、同じコールバック地獄などの多くの不快な副作用があります）。イテレータがあるように見えますが、すべてがそれほどスムーズではありません。共通の入口と出口ポイントがない（開始→終了対rbegin→レンドなど）、どれだけ反復するかは不明ですか？ C ++ 20以降、これらの問題は解決されました！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のオプション：範囲。イテレーターの上部にラッパーがあるため、反復の開始と終了の共通インターフェースと、構成の可能性が得られます。これらすべてにより、本格的なデータ処理パイプラインを簡単に構築できます。しかし、すべてがそれほどスムーズではありません。計算のロジックの一部は特定のイテレータの実装内にあり、認識とデバッグのコードを複雑にする可能性があります。</font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">プレゼンテーション</font></a></i></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f41/a7d/09d/f41a7d09d24a823a3397aa27a552f254.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からスライド</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
さて、この場合、コルーチンはC ++ 20（Pythonのジェネレーターと同様の動作をする関数）で追加されました。中間状態を維持しながら現在の値を返すことにより、実行を遅らせることができます。したがって、データが表示されたときに作業を行うだけでなく、特定のコルーチン内のすべてのロジックをカプセル化します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、軟膏にはフライがあります。現時点では、それらは既存のコンパイラーによって部分的にのみサポートされており、期待どおりに正確に実装されていません。たとえば、リンクと一時オブジェクトはコルーチンで使用しないでください。</font><font style="vertical-align: inherit;">さらに、コルーチンにできるものにはいくつかの制限があり、constexpr関数、コンストラクター/デストラクター、およびメインもこのリストには含まれていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、コルーチンはデータ処理ロジックの単純さで問題のかなりの部分を解決しますが、現在の実装では改良が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
材料：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ロシアのスライド- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[「ジェネレーター、コルーチン、その他の脳を広げる甘さ」]</font></font></a> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CppCon 2019からのビデオレポート</font></font></a> </li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex.Taxi、Anton PolukhinによるC ++トリック</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼の専門的な活動では、純粋に補助的なものを実装する必要がある場合があります。内部インターフェースと、いくつかのライブラリーのAPI、ロギング、または構文解析の間のラッパーです。ただし、通常は追加の最適化は必要ありません。しかし、これらのコンポーネントがRunetの最も人気のあるサービスの一部で使用されている場合はどうでしょうか。このような状況では、1時間あたりテラバイト単位のログのみを処理する必要があります。その後、ミリ秒ごとにカウントされるため、さまざまなトリックに頼らなければなりません-アントンポルキンが話しました。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく最も興味深い例は、実装へのポインター（pimpl）パターンの実装でした。&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;third_party/json.hpp&gt; //PROBLEMS!&nbsp;</span></span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Value</span> {</span>&nbsp;
    Value() = <span class="hljs-keyword">default</span>;&nbsp;<font></font>
    Value(Value&amp;&amp; other) = <span class="hljs-keyword">default</span>;&nbsp;<font></font>
    Value&amp; <span class="hljs-keyword">operator</span>=(Value&amp;&amp; other) = <span class="hljs-keyword">default</span>;&nbsp;<font></font>
    ~Value() = <span class="hljs-keyword">default</span>;&nbsp;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-title">Size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> data_.size(); }&nbsp;<font></font>
<font></font>
<span class="hljs-keyword">private</span>:&nbsp;<font></font>
    third_party::Json data_;&nbsp;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、最初に外部ライブラリのヘッダーファイルを削除します-コンパイルが高速になり、名前の競合やその他の同様のエラーから自分を保護できます。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
#includeを.cppファイルに移動しました。ラップされたAPIの前方宣言とstd :: unique_ptrが必要です。</font><font style="vertical-align: inherit;">これで、動的な割り当てと、ヒープ上の散在したデータなどの不愉快なことが起こり、保証が減少しました。</font><font style="vertical-align: inherit;">これがすべて揃っていれば、std :: alignment_storageが役立ちます。&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Value</span> {</span>&nbsp;
<span class="hljs-comment">// ...&nbsp;</span>
<span class="hljs-keyword">private</span>:&nbsp;
    <span class="hljs-keyword">using</span> JsonNative = third_party::Json;&nbsp;
    <span class="hljs-function"><span class="hljs-keyword">const</span> JsonNative* <span class="hljs-title">Ptr</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span>;&nbsp;
    <span class="hljs-function">JsonNative* <span class="hljs-title">Ptr</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;&nbsp;<font></font>
<font></font>
    <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> kImplSize = <span class="hljs-number">32</span>;&nbsp;
    <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> kImplAlign = <span class="hljs-number">8</span>;&nbsp;
    <span class="hljs-built_in">std</span>::<span class="hljs-keyword">aligned_storage_t</span>&lt;kImplSize, kImplAlign&gt; data_;&nbsp;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
唯一の問題：各ラッパーのサイズと配置を指定する必要があります-パラメータ&lt;T、SizeT、AlignmentT&gt;を使用してpimplテンプレートを作成し、任意の値を使用して、すべてを推測したチェックをデストラクタに追加します。&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs">~FastPimpl() <span class="hljs-keyword">noexcept</span> {&nbsp;<font></font>
    validate&lt;<span class="hljs-keyword">sizeof</span>(T), <span class="hljs-keyword">alignof</span>(T)&gt;();&nbsp;<font></font>
    Ptr()-&gt;~T();&nbsp;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> ActualSize, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> ActualAlignment&gt;
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validate</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>{&nbsp;
    <span class="hljs-keyword">static_assert</span>(<font></font>
        Size == ActualSize,&nbsp;<font></font>
        <span class="hljs-string">"Size and sizeof(T) mismatch"</span><font></font>
    );&nbsp;<font></font>
    <span class="hljs-keyword">static_assert</span>(<font></font>
        Alignment == ActualAlignment,&nbsp;<font></font>
        <span class="hljs-string">"Alignment and alignof(T) mismatch"</span><font></font>
    );&nbsp;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tはデストラクタの処理中に既に決定されているため、このコードは正しく解析され、コンパイル段階で、エラーの形式で入力する必要がある必要なサイズと配置の値が表示されます。</font><font style="vertical-align: inherit;">したがって、コンパイルをさらに1回開始するという犠牲を払って、ラップされたクラスの動的割り当てを取り除き、APIを.cppファイルに実装で非表示にし、さらにプロセッサによるキャッシュにより適した設計を取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロギングと解析はそれほど印象的ではないように思われたため、このレビューでは触れません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レポートのスライドは、リンク</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">「[C ++ Taxi Tricks」]から</font></a><font style="vertical-align: inherit;">入手できます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードをドライに保つための最新のテクニック、BjörnFahller</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この講演では、BjörnFahllerが、条件付きチェックの繰り返しなど、スタイルの欠陥に対処するいくつかの異なる方法を示しています。</font></font><br>
<br>
<pre><code class="cpp hljs">assert(a == IDLE || a == CONNECTED || a == DISCONNECTED);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おなじみですか？</font><font style="vertical-align: inherit;">最近の標準に登場したいくつかの強力なC ++技術を使用して、わずかなパフォーマンス損失なしで同じ機能を適切に実装できます。</font><font style="vertical-align: inherit;">比較：&nbsp;&nbsp;&nbsp;</font></font><br>
<br>
<pre><code class="cpp hljs">assert(a == any_of(IDLE, CONNECTED, DISCONNECTED));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
無制限の数のチェックを処理するには、可変長テンプレートと折り畳み式を使用するようにすぐに求められます。</font><font style="vertical-align: inherit;">複数の変数が要素enum'a state_typeと等しいかどうかをチェックするとします。</font><font style="vertical-align: inherit;">最初に頭に浮かぶのは、is_any_ofヘルパー関数を記述することです。</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">enum</span> state_type { IDLE, CONNECTED, DISCONNECTED };<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ... Ts&gt;
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_any_of</span><span class="hljs-params">(state_type s, <span class="hljs-keyword">const</span> Ts&amp; ... ts)</span> </span>{&nbsp;
    <span class="hljs-keyword">return</span> ((s == ts) || ...);&nbsp;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような中間結果は残念です。</font><font style="vertical-align: inherit;">これまでのところ、コードは読みにくくなっています。</font></font><br>
<br>
<pre><code class="cpp hljs">assert(is_any_of(state, IDLE, DISCONNECTING, DISCONNECTED));&nbsp;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプではないテンプレートパラメータは、状況を少し改善するのに役立ちます。</font><font style="vertical-align: inherit;">彼らの助けを借りて、列挙されたenum要素をテンプレートパラメータのリストに転送します。&nbsp;</font></font><br>
 <br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;state_type ... states&gt;
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_any_of</span><span class="hljs-params">(state_type t)</span> </span>{&nbsp;
    <span class="hljs-keyword">return</span> ((t == states) | ...);&nbsp;<font></font>
}<font></font>
	<font></font>
assert(is_any_of&lt;IDLE, DISCONNECTING, DISCONNECTED&gt;(state));&nbsp;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非標準のテンプレートパラメーター（C ++ 17）でautoを使用すると、このアプローチは単純に一般化され、state_type要素だけでなく、非型のテンプレートパラメーターとして使用できるプリミティブ型との比較にもなります。</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">auto</span> ... alternatives, <span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_any_of</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; t)</span> </span>{
    <span class="hljs-keyword">return</span> ((t == alternatives) | ...);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの漸進的な改善により、チェックに必要な暴走構文が実現されます。</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> ... <span class="hljs-title">Ts</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">any_of</span> :</span> <span class="hljs-keyword">private</span> <span class="hljs-built_in">std</span>::tuple&lt;Ts ...&gt; {&nbsp;
<span class="hljs-comment">//      tuple&nbsp;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::tuple&lt;Ts ...&gt;::tuple;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> ==(<span class="hljs-keyword">const</span> T&amp; t) <span class="hljs-keyword">const</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::apply(<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&amp;t](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; ... ts) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> ((ts == t) || ...);<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::tuple&lt;Ts ...&gt;&amp;&gt;(*<span class="hljs-keyword">this</span>));<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> ... <span class="hljs-title">Ts</span>&gt;
<span class="hljs-title">any_of</span>(<span class="hljs-title">Ts</span> ...) -&gt; <span class="hljs-title">any_of</span>&lt;Ts ... &gt;;</span><font></font>
&nbsp;<font></font>
assert(any_of(IDLE, DISCONNECTING, DISCONNECTED) == state);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、演繹ガイドは、コンストラクター引数のタイプを知っているコンパイラーに、必要なテンプレート構造パラメーターをプロンプトするのに役立ちます。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もっと面白い。</font><font style="vertical-align: inherit;">ビョルンは、==に加えて比較演算子の結果のコードを一般化し、次に任意の操作を一般化することを教えています。</font><font style="vertical-align: inherit;">ユースケースとともに、no_unique_address属性（C ++ 20）やラムダ関数のテンプレートパラメーター（C ++ 20）などの機能についても説明します。</font><font style="vertical-align: inherit;">（はい、ラムド構文がさらに覚えやすくなりました-これらはあらゆる種類のブラケットの4つの連続するペアです）コンストラクターのパーツとして関数を使用する最終的なソリューションは、ラムダ計算の最も伝統的なタプル式は言うまでもなく、本当に心を温めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、光沢を付けることを忘れないでください。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラムダは無料でconstexprであることを思い出してください。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全な転送を追加し、ラムダクロージャのパラメータパックに適用される醜い構文を見てください。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイラーに、条件付きnoexceptを使用した最適化のオプションを追加しましょう。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラムダの明示的な戻り値のおかげで、テンプレートでより明確なエラー出力を処理します。</font><font style="vertical-align: inherit;">これにより、型チェックの段階で、テンプレート関数を実際に呼び出す前に、コンパイラーがより多くのチェックを行うようになります。&nbsp;</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
詳細については、講義資料を参照してください。&nbsp;</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スライド：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[コードをドライに保つための最新テクニック]</font></font></a> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Githubソースコード</font></font></a> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">著者のブログ記事</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちの印象</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ロシアへの最初の参加は、その豊かさで記憶されました。 C ++ロシアは精神的な出来事であるという印象がありました。そこでは、学習とライブコミュニケーションの境界線はほとんど目立ちません。講演者の気分から、イベントのパートナーによるコンテストまで、すべてが白熱した議論につながります。会議の内容はレポートで構成されており、C ++の革新、大規模プロジェクトの実践例、イデオロギー的アーキテクチャの考慮事項など、かなり幅広いトピックをカバーしています。しかし、C ++だけでなく言語の壁を乗り越えるのに役立つ、イベントの社会的要素の注意を奪うのは不公平です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなイベントに参加する機会を与えてくれた会議の主催者に感謝します！</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ロシアの過去、現在、未来についての主催者の投稿、あなたは見ることができました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JUG Ruブログで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
お読みいただきありがとうございました。イベントの再報告がお役に立てば幸いです。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja481348/index.html">Pentest Active Directory。パート1</a></li>
<li><a href="../ja481350/index.html">プレセツク宇宙基地で働く人</a></li>
<li><a href="../ja481352/index.html">DBA：PKなしでテーブルからクローンレコードをクリアする</a></li>
<li><a href="../ja481354/index.html">TelegramBot。基本的な機能。別々に飛ぶ、別々にカツレツ。（パート2）</a></li>
<li><a href="../ja481356/index.html">ありがとう、2019</a></li>
<li><a href="../ja481360/index.html">今週の結果：ランブラーとトゥイッチが合意、電子労働がロシア連邦に導入され、Facebookが独自のOSを作成する</a></li>
<li><a href="../ja481362/index.html">Docker WebアプリのSSL証明書</a></li>
<li><a href="../ja481364/index.html">敏感な家はスマートホームに取って代わります</a></li>
<li><a href="../ja481366/index.html">RICE：プロダクトマネージャー向けの簡単な優先順位付け</a></li>
<li><a href="../ja481368/index.html">カメラブラインドテスト：iPhone、Pixel、Samsung、Huawei</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>