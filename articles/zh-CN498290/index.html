<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤪 🥃 😯 程序水文学：河流和湖泊的动态模拟 🉑 👩🏾‍⚕️ 🎒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="注意：该项目的完整源代码发布在Github [ 这里 ]。该存储库还包含有关如何阅读和使用代码的详细信息。
 实施基于粒子的水力侵蚀模拟后，我决定可以扩展该概念以模拟地表水文学的其他方面。
 
 我研究了现有的江湖程序生成方法，但发现的结果不适合我。
 
 许多方法的主要目的是使用各种算法（有时基于...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>程序水文学：河流和湖泊的动态模拟</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498290/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93d/664/fbe/93d664fbe19ce63dfa6b60d9621d07ae.png"></div><blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：该</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目</font><strong><font style="vertical-align: inherit;">的</font></strong><font style="vertical-align: inherit;">完整源代码发布在Github [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]。</font><font style="vertical-align: inherit;">该存储库还包含有关如何阅读和使用代码的详细信息。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实施基于粒子的水力侵蚀模拟后，我决定可以扩展该概念以模拟地表水文学的其他方面。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我研究了现有的江湖程序生成方法，但发现的结果不适合我。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
许多方法的主要目的是使用各种算法（有时基于先前创建的海拔图或逆问题）来创建河流系统（非常漂亮），但是它们在地形和水文之间缺乏牢固的现实关系。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，在某些资源上考虑了对整个浮雕上水模型的处理，并使用了高度复杂的流体的模拟。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我将展示一种尝试通过扩展模拟基于粒子的水力侵蚀能力的技术来克服这些问题的尝试。</font><font style="vertical-align: inherit;">我还将说明一般如何解决“浮雕上的水”的问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我的方法中，我为简单性和现实性而努力，其代价是潜在侵蚀系统的复杂性略有增加。</font><font style="vertical-align: inherit;">我建议你阅读我以前关于该系统的[文章</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻译</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对哈布雷]，因为新的模型是基于它。</font></font><br>
<a name="habracut"></a><br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://weigert.vsos.ethz.ch/wp-content/uploads/2020/04/Hydrology6.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该系统能够通过水文学快速生成非常逼真的地形。</font><font style="vertical-align: inherit;">该视频是实时渲染的。</font><font style="vertical-align: inherit;">该系统能够生成无限数量的此类景观。</font></font></i><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">说明：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我不是地质学家，所以我根据自己的知识创建了系统。</font></font></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水文学概念</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想创建一个可以模拟许多地理现象的生成系统，包括：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">河流和溪流迁移</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">天然瀑布</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">峡谷形成</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">土壤膨胀和洪泛区</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，水文和地形系统必须是动态的并且紧密相关。</font><font style="vertical-align: inherit;">基于粒子的水力侵蚀系统已经具有为此所需的基本方面：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浮雕影响水的流动</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">侵蚀和沉积影响地形</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，此系统模拟了雨水造成的侵蚀，但无法传达许多其他影响：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在流动的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">溪流中，</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水的行为有所不同。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在立式</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游泳池中，</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水的行为有所不同</font></font></li>
</ul><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我经常会提到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pools</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在模型中假设这些是二维的大规模现象。</font><font style="vertical-align: inherit;">它们大大降低了模型的复杂性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上面的大多数地理现象都可以使用流量和盆地模型来传达。</font><font style="vertical-align: inherit;">理想情况下，他们应该借鉴并增强基于粒子的系统的真实性。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简化的水文模型</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在一个或多个数据结构（图形，对象等）中存储有关流和池的信息太复杂了，这限制了我们的能力。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们的水文模型由两个图组成：</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流量</font></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><strong><font style="vertical-align: inherit;">流域图</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不要忘记将它们建模为2D系统。</font></font></blockquote><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流和池地图</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
流程图描述了地表（河流和河流）上的流动水。</font><font style="vertical-align: inherit;">它将时间平均的粒子位置存储在地图上。</font><font style="vertical-align: inherit;">旧信息正在慢慢删除。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
盆地图描述了表面上的静止水（水坑，池塘，湖泊，海洋）。</font><font style="vertical-align: inherit;">它将水深存储在地图的相应位置。</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流图和池图是与高度图相同大小的数组。</font></font></blockquote><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/869/209/77f/86920977ff555d0cf5a2e0a923d79207.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">减轻水文影响。</font><font style="vertical-align: inherit;">渲染中的水层取自水文地图。</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f1/2a1/1c2/0f12a11c2164cc93995a9f5599b1a7a9.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组合水文地图。</font><font style="vertical-align: inherit;">浅蓝色是流图；深蓝色是池图。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些地图是由沿着地形移动水的粒子生成和连接的。</font><font style="vertical-align: inherit;">添加这些水文图还为我们提供了与时间无关的信息，该信息允许粒子与其模拟分别进行交互。</font><font style="vertical-align: inherit;">粒子可以通过使用这些卡进行交互以获得影响其运动的参数。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流地图在通过缓入功能后显示，并基于此在地形上渲染。</font><font style="vertical-align: inherit;">为了获得更细/更锐利的流量（或忽略宽阔的平坦区域上的较低值），可以修改此显示或为其设置阈值。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水为颗粒</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
水以离散的物质（“颗粒”）的形式存在，该物质具有一定的体积并沿着浮雕的表面移动。</font><font style="vertical-align: inherit;">它具有几个影响其运动的参数（摩擦，蒸发速率，沉积速率等）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是用于模拟水文学的基本数据结构。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会存储</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">粒子</font><font style="vertical-align: inherit;">，而只会将其用于高度，流量和池图之间的交互。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">粒子</font><strong><font style="vertical-align: inherit;">的</font></strong><font style="vertical-align: inherit;">概念在上一篇</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font><font style="vertical-align: inherit;">和Habré </font><font style="vertical-align: inherit;">上</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">的</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻译</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]（以及无数其他资源）</font><font style="vertical-align: inherit;">中有更详细的解释</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水文循环与地图互动</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
地图通过水文循环相互影响。</font><font style="vertical-align: inherit;">水文循环包括以下步骤：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在地形上创建粒子</font></font></li>
<li><strong></strong>        (.. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">     </a>).</li>
<li>        ,                  <strong></strong>.</li>
<li>  ,           <strong></strong>.</li>
<li> ,     (    )      .</li>
<li>     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在整个系统中，只有两种算法：</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下降（下降）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">洪水（洪水）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">下降的粒子改变了流量图，而洪水的粒子改变了盆地图。</font><font style="vertical-align: inherit;">这些算法将在下面详细描述。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/a81/2cb/989a812cb5d769edbb76fd5a284d18b1.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水文模型的一维图。</font><font style="vertical-align: inherit;">粒子是在地形上创建的，并通过两种算法进行循环处理：下降和洪水。</font><font style="vertical-align: inherit;">在此过程中，流域和流域的图谱发生了变化，进而影响了粒子的运动。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实作</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下面，我将解释用于生成结果的系统的完整实现，并提供代码示例。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我只会显示相关的代码段。</font><font style="vertical-align: inherit;">可以在Github上的存储库中找到更多信息。</font><font style="vertical-align: inherit;">该代码的所有相关部分都在“ water.h”文件中。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">粒子类</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Drop粒子的结构与先前系统的结构相同。</font><font style="vertical-align: inherit;">下降和泛洪现在是结构的成员，因为它们一次仅作用于一个粒子。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Drop</span>{</span><font></font>
  <font></font>
  <span class="hljs-comment">//... constructors</span><font></font>
<font></font>
  <span class="hljs-keyword">int</span> index;                         <span class="hljs-comment">//Flat Array Index</span>
  glm::vec2 pos;                     <span class="hljs-comment">//2D Position</span>
  glm::vec2 speed = glm::vec2(<span class="hljs-number">0.0</span>);
  <span class="hljs-keyword">double</span> volume = <span class="hljs-number">1.0</span>;
  <span class="hljs-keyword">double</span> sediment = <span class="hljs-number">0.0</span>;<font></font>
<font></font>
  <span class="hljs-comment">//... parameters</span>
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> volumeFactor = <span class="hljs-number">100.0</span>; <span class="hljs-comment">//"Water Deposition Rate"</span><font></font>
<font></font>
  <span class="hljs-comment">//Hydrological Cycle Functions</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">descend</span><span class="hljs-params">(<span class="hljs-keyword">double</span>* h, <span class="hljs-keyword">double</span>* stream, <span class="hljs-keyword">double</span>* pool, <span class="hljs-keyword">bool</span>* track, glm::ivec2 dim, <span class="hljs-keyword">double</span> scale)</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flood</span><span class="hljs-params">(<span class="hljs-keyword">double</span>* h, <span class="hljs-keyword">double</span>* pool, glm::ivec2 dim)</span></span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一个参数是体积系数，它确定洪水如何将体积转移到水位。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下降算法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下降算法与简单粒子腐蚀算法几乎相同。</font><font style="vertical-align: inherit;">他收到其他输入“轨迹”-一个数组，其中写入了他访问过的所有位置。</font><font style="vertical-align: inherit;">将来需要一个数组来构建流图。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Drop::descend</span><span class="hljs-params">(<span class="hljs-keyword">double</span>* h, <span class="hljs-keyword">double</span>* stream, <span class="hljs-keyword">double</span>* pool, <span class="hljs-keyword">bool</span>* track, glm::ivec2 dim, <span class="hljs-keyword">double</span> scale)</span></span>{<font></font>
<font></font>
  glm::ivec2 ipos; <font></font>
<font></font>
  <span class="hljs-keyword">while</span>(volume &gt; minVol){<font></font>
<font></font>
    ipos = pos; <span class="hljs-comment">//Initial Position</span>
    <span class="hljs-keyword">int</span> ind = ipos.x*dim.y+ipos.y; <span class="hljs-comment">//Flat Array Index</span><font></font>
<font></font>
    <span class="hljs-comment">//Register Position</span>
    track[ind] = <span class="hljs-literal">true</span>;<font></font>
<font></font>
    <span class="hljs-comment">//...</span><font></font>
  }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过流图和池图修改参数集：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//...</span>
  <span class="hljs-comment">//Effective Parameter Set</span>
  <span class="hljs-keyword">double</span> effD = depositionRate;
  <span class="hljs-keyword">double</span> effF = friction*(<span class="hljs-number">1.0</span><span class="hljs-number">-0.5</span>*stream[ind]);
  <span class="hljs-keyword">double</span> effR = evapRate*(<span class="hljs-number">1.0</span><span class="hljs-number">-0.2</span>*stream[ind]);
<span class="hljs-comment">//...</span></code></pre><br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我发现这样的参数更改效果很好。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在以前的系统中，粒子可能脱离此循环，只有在完全蒸发或超出浮雕边界的情况下才会被破坏。</font><font style="vertical-align: inherit;">现在，这里添加了两个附加的退出条件：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//... nind is the next position after moving the particle</span><font></font>
  <font></font>
  <span class="hljs-comment">//Out-Of-Bounds</span>
  <span class="hljs-keyword">if</span>(!glm::all(glm::greaterThanEqual(pos, glm::vec2(<span class="hljs-number">0</span>))) ||<font></font>
     !glm::all(glm::lessThan((glm::ivec2)pos, dim))){<font></font>
       volume = <span class="hljs-number">0.0</span>;
       <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">//Slow-Down</span>
  <span class="hljs-keyword">if</span>(stream[nind] &gt; <span class="hljs-number">0.5</span> &amp;&amp; length(acc) &lt; <span class="hljs-number">0.01</span>)
    <span class="hljs-keyword">break</span>;<font></font>
<font></font>
  <span class="hljs-comment">//Enter Pool</span>
  <span class="hljs-keyword">if</span>(pool[nind] &gt; <span class="hljs-number">0.0</span>)
    <span class="hljs-keyword">break</span>;<font></font>
<font></font>
<span class="hljs-comment">//...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果粒子没有足够的加速度并且被其他粒子包围，或者直接进入池中，则它会以其所有剩余体积过早地完成下降，然后继续进行洪水算法。</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">溢出条件还会重置音量，以使粒子不会移入泛洪算法。</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">泛洪算法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
剩余体积的粒子可能会从其当前位置溢出。如果它停止下降（没有加速度）或进入现有池，则会发生这种情况。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
洪水算法将颗粒的体积转移到增加的水位，从而改变盆地的图。该技术是使用“测试平面”将水位增量增加到颗粒体积的一小部分。随着水位的升高，颗粒体积减小。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c28/908/ebc/c28908ebc4f1efee43232578962beed2.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">泛洪算法动画。测试平面和水位逐渐增加，减少了颗粒体积。如果发现泄漏，则剩余体积将移至泄漏点以执行下降。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在每个步骤中，我们从粒子的位置开始进行洪水填充（也就是说，我们递归检查邻居的位置），并将位于原始平面上方（当前水位）和测试平面下方的所有位置添加到“洪水集”中。这是浮雕的一部分，是游泳池的一部分。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在填充过程中，我们检查是否有泄漏。这些是淹没集中在测试平面AND原始平面以下的点。如果发现多个泄漏点，则选择最低的泄漏点。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Drop::flood</span><span class="hljs-params">(<span class="hljs-keyword">double</span>* height, <span class="hljs-keyword">double</span>* pool, glm::ivec2 dim)</span></span>{<font></font>
<font></font>
  index = (<span class="hljs-keyword">int</span>)pos.x*dim.y + (<span class="hljs-keyword">int</span>)pos.y;
  <span class="hljs-keyword">double</span> plane = height[index] + pool[index];  <span class="hljs-comment">//Testing Plane</span>
  <span class="hljs-keyword">double</span> initialplane = plane;                 <span class="hljs-comment">//Water Level</span><font></font>
<font></font>
  <span class="hljs-comment">//Flood Set</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">set</span>;
  <span class="hljs-keyword">int</span> fail = <span class="hljs-number">10</span>; <span class="hljs-comment">//Just in case...</span><font></font>
<font></font>
  <span class="hljs-comment">//Iterate while particle still has volume</span>
  <span class="hljs-keyword">while</span>(volume &gt; minVol &amp;&amp; fail){<font></font>
<font></font>
    <span class="hljs-built_in">set</span>.clear();
    <span class="hljs-keyword">bool</span> tried[dim.x*dim.y] = {<span class="hljs-literal">false</span>};<font></font>
<font></font>
    <span class="hljs-comment">//Lowest Drain</span>
    <span class="hljs-keyword">int</span> drain;
    <span class="hljs-keyword">bool</span> drainfound = <span class="hljs-literal">false</span>;<font></font>
<font></font>
    <span class="hljs-comment">//Recursive Flood-Fill Function</span>
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(<span class="hljs-keyword">int</span>)&gt; fill = [&amp;](<span class="hljs-keyword">int</span> i){<font></font>
<font></font>
      <span class="hljs-comment">//Out of Bounds</span>
      <span class="hljs-keyword">if</span>(i/dim.y &gt;= dim.x || i/dim.y &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">if</span>(i%dim.y &gt;= dim.y || i%dim.y &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
      <span class="hljs-comment">//Position has been tried</span>
      <span class="hljs-keyword">if</span>(tried[i]) <span class="hljs-keyword">return</span>;<font></font>
      tried[i] = <span class="hljs-literal">true</span>;<font></font>
<font></font>
      <span class="hljs-comment">//Wall / Boundary of the Pool</span>
      <span class="hljs-keyword">if</span>(plane &lt; height[i] + pool[i]) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
      <span class="hljs-comment">//Drainage Point</span>
      <span class="hljs-keyword">if</span>(initialplane &gt; height[i] + pool[i]){<font></font>
<font></font>
        <span class="hljs-comment">//No Drain yet</span>
        <span class="hljs-keyword">if</span>(!drainfound)<font></font>
          drain = i;<font></font>
<font></font>
        <span class="hljs-comment">//Lower Drain</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( pool[drain] + height[drain] &lt; pool[i] + height[i] )<font></font>
          drain = i;<font></font>
<font></font>
        drainfound = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span>; <span class="hljs-comment">//No need to flood from here</span><font></font>
      }<font></font>
<font></font>
      <span class="hljs-comment">//Part of the Pool</span>
      <span class="hljs-built_in">set</span>.push_back(i);<font></font>
      fill(i+dim.y);    <span class="hljs-comment">//Fill Neighbors</span><font></font>
      fill(i-dim.y);<font></font>
      fill(i+<span class="hljs-number">1</span>);<font></font>
      fill(i<span class="hljs-number">-1</span>);<font></font>
      fill(i+dim.y+<span class="hljs-number">1</span>);  <span class="hljs-comment">//Diagonals (Improves Drainage)</span>
      fill(i-dim.y<span class="hljs-number">-1</span>);<font></font>
      fill(i+dim.y<span class="hljs-number">-1</span>);<font></font>
      fill(i-dim.y+<span class="hljs-number">1</span>);<font></font>
    };<font></font>
<font></font>
    <span class="hljs-comment">//Perform Flood</span><font></font>
    fill(index);<font></font>
<font></font>
    <span class="hljs-comment">//...</span></code></pre><br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为简单起见，此处使用八向</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">填充算法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">将来，将有可能更有效地实施它。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
确定了许多洪水和泄漏点后，我们更改了水位和水池图。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果找到泄漏点，我们将粒子（及其“溢出”体积）移至泄漏点，以便其可以再次开始下降。</font><font style="vertical-align: inherit;">然后水位下降到泄漏点的高度。</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">//...</span><font></font>
<font></font>
    <span class="hljs-comment">//Drainage Point</span>
    <span class="hljs-keyword">if</span>(drainfound){<font></font>
<font></font>
      <span class="hljs-comment">//Set the Particle Position</span><font></font>
      pos = glm::vec2(drain/dim.y, drain%dim.y);<font></font>
<font></font>
      <span class="hljs-comment">//Set the New Waterlevel (Slowly)</span>
      <span class="hljs-keyword">double</span> drainage = <span class="hljs-number">0.001</span>;<font></font>
      plane = (<span class="hljs-number">1.0</span>-drainage)*initialplane + drainage*(height[drain] + pool[drain]);<font></font>
<font></font>
      <span class="hljs-comment">//Compute the New Height</span>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; s: <span class="hljs-built_in">set</span>) <span class="hljs-comment">//Iterate over Set</span>
        pool[s] = (plane &gt; height[s])?(plane-height[s]):<span class="hljs-number">0.0</span>;<font></font>
<font></font>
      <span class="hljs-comment">//Remove some sediment</span>
      sediment *= <span class="hljs-number">0.1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//...</span></code></pre><br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当水位因泄漏而下降时，我发现这在泄漏率低的情况下效果最佳。</font><font style="vertical-align: inherit;">另外，去除部分沉积岩有助于实施。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，进入填充池的新粒子会立即将其体积移动到泄漏点，因为向池中添加体积会从其中置换相同的体积。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果找不到泄漏点，则我们将计算测试平面下的体积并将其与颗粒的体积进行比较。</font><font style="vertical-align: inherit;">如果小于，则我们从颗粒中除去体积并调整水位。</font><font style="vertical-align: inherit;">然后测试平面上升。</font><font style="vertical-align: inherit;">如果较大，则测试平面降低。</font><font style="vertical-align: inherit;">重复该过程，直到粒子空间不足或发现泄漏点。</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">//...</span><font></font>
<font></font>
    <span class="hljs-comment">//Get Volume under Plane</span>
    <span class="hljs-keyword">double</span> tVol = <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; s: <span class="hljs-built_in">set</span>)<font></font>
      tVol += volumeFactor*(plane - (height[s]+pool[s]));<font></font>
<font></font>
    <span class="hljs-comment">//We can partially fill this volume</span>
    <span class="hljs-keyword">if</span>(tVol &lt;= volume &amp;&amp; initialplane &lt; plane){<font></font>
<font></font>
      <span class="hljs-comment">//Raise water level to plane height</span>
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; s: <span class="hljs-built_in">set</span>)<font></font>
        pool[s] = plane - height[s];<font></font>
<font></font>
      <span class="hljs-comment">//Adjust Drop Volume</span><font></font>
      volume -= tVol;<font></font>
      tVol = <span class="hljs-number">0.0</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//Plane was too high and we couldn't fill it</span>
    <span class="hljs-keyword">else</span> fail--;<font></font>
<font></font>
    <span class="hljs-comment">//Adjust Planes</span>
    <span class="hljs-keyword">float</span> approach = <span class="hljs-number">0.5</span>;<font></font>
    initialplane = (plane &gt; initialplane)?plane:initialplane;<font></font>
    plane += approach*(volume-tVol)/(<span class="hljs-keyword">double</span>)<span class="hljs-built_in">set</span>.size()/volumeFactor;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">//Couldn't place the volume (for some reason)- so ignore this drop.</span>
  <span class="hljs-keyword">if</span>(fail == <span class="hljs-number">0</span>)<font></font>
    volume = <span class="hljs-number">0.0</span>;<font></font>
<font></font>
} <span class="hljs-comment">//End of Flood Algorithm</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
平面的高度与池的表面积（即集合的大小）缩放的体积差异成比例地进行调整。</font><font style="vertical-align: inherit;">通过使用接近系数，可以提高飞机达到正确水位的稳定性。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">侵蚀膜</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
world类包含以普通数组形式的所有三个映射：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">World</span> {</span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generate</span><span class="hljs-params">()</span></span>;            <span class="hljs-comment">//Initialize</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">erode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cycles)</span></span>;     <span class="hljs-comment">//Erode with N Particles</span><font></font>
<font></font>
  <span class="hljs-comment">//...</span><font></font>
<font></font>
  <span class="hljs-keyword">double</span> heightmap[<span class="hljs-number">256</span>*<span class="hljs-number">256</span>] = {<span class="hljs-number">0.0</span>};
  <span class="hljs-keyword">double</span> waterstream[<span class="hljs-number">256</span>*<span class="hljs-number">256</span>] = {<span class="hljs-number">0.0</span>};
  <span class="hljs-keyword">double</span> waterpool[<span class="hljs-number">256</span>*<span class="hljs-number">256</span>] = {<span class="hljs-number">0.0</span>};<font></font>
<font></font>
};</code></pre><br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高度图是使用Perlin噪声初始化的。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
单个粒子的每个水文步骤均包含以下内容：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//...</span><font></font>
<font></font>
<span class="hljs-comment">//Spawn Particle</span>
glm::vec2 newpos = glm::vec2(rand()%(<span class="hljs-keyword">int</span>)dim.x, rand()%(<span class="hljs-keyword">int</span>)dim.y);
<span class="hljs-function">Drop <span class="hljs-title">drop</span><span class="hljs-params">(newpos)</span></span>;<font></font>
<font></font>
<span class="hljs-keyword">int</span> spill = <span class="hljs-number">5</span>;
<span class="hljs-keyword">while</span>(drop.volume &gt; drop.minVol &amp;&amp; spill != <span class="hljs-number">0</span>){<font></font>
<font></font>
  drop.descend(heightmap, waterstream, waterpool, track, dim, scale);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(drop.volume &gt; drop.minVol)<font></font>
    drop.flood(heightmap, waterpool, dim);<font></font>
<font></font>
  spill--;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
溢出参数确定粒子可以进入池中并再次离开的次数，然后再将其简单破坏。</font><font style="vertical-align: inherit;">否则，当其体积耗尽时，颗粒会死亡。</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">颗粒很少进入池中，并在下降阶段完全蒸发之前留出一到两次以上，但为防万一，我添加了这一点。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
侵蚀函数包装此代码并为N个粒子执行水文步骤，直接更改流图：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">World::erode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span></span>{<font></font>
<font></font>
  <span class="hljs-comment">//Track the Movement of all Particles</span>
  <span class="hljs-keyword">bool</span> track[dim.x*dim.y] = {<span class="hljs-literal">false</span>};<font></font>
<font></font>
  <span class="hljs-comment">//Simulate N Particles</span>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++){<font></font>
   <font></font>
    <span class="hljs-comment">//... simulate individual particle</span><font></font>
<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">//Update Path</span>
  <span class="hljs-keyword">double</span> lrate = <span class="hljs-number">0.01</span>;  <span class="hljs-comment">//Adaptation Rate</span>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dim.x*dim.y; i++)<font></font>
    waterstream[i] = (<span class="hljs-number">1.0</span>-lrate)*waterstream[i] + lrate*((track[i])?<span class="hljs-number">1.0</span>:<span class="hljs-number">0.0</span>);<font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，磁道阵列被传递给下降函数。</font><font style="vertical-align: inherit;">我发现同时跟踪几个粒子的运动和相应的变化可以改善流图的结果。</font><font style="vertical-align: inherit;">适应率决定了删除旧信息的速度。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">树木</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
只是为了好玩，我添加了树木以查看是否可以进一步改善侵蚀模拟。</font><font style="vertical-align: inherit;">它们作为矢量存储在世界教室中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
树木是在地图上随机创建的，那里没有水池和强流，地形也不是很陡峭。</font><font style="vertical-align: inherit;">他们还有机会在自己周围创建其他树木。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在创建树木的过程中，它们会在树木周围一定半径内写入植被的密度图。</font><font style="vertical-align: inherit;">高植被密度降低了下降粒子与地形之间的质量传递。</font><font style="vertical-align: inherit;">这是为了模拟根部如何将土壤固定在适当的位置。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//... descend function</span>
<span class="hljs-keyword">double</span> effD = depositionRate*max(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>-treedensity[ind]);
<span class="hljs-comment">//...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果树木在游泳池中，或者树木下方的溪流过于强大，它们就会死亡。</font><font style="vertical-align: inherit;">此外，他们有随机的死亡概率。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://weigert.vsos.ethz.ch/wp-content/uploads/2020/04/trees.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多亏了阴影和法线贴图，即使是非常简单的树精灵也可以使浮雕更加美观。</font></font></i><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可在文件“ vegetation.h”和函数“ World :: grow（）”中找到树模型。</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他详情</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用自制的OpenGL包装器将结果可视化，该包装器</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">布置</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以根据您需要的任何分布在地图上创建粒子。</font><font style="vertical-align: inherit;">在演示中，我在256×256张卡上均匀分布地创建了它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如下所示，最终的模拟高度依赖于原始浮雕的选择。</font><font style="vertical-align: inherit;">该系统能够模拟大量自然现象。</font><font style="vertical-align: inherit;">我不能只得到峡谷。</font><font style="vertical-align: inherit;">他们可能需要很长很慢的模拟。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以在系统中观察到其他现象，例如瀑布，曲折和三角洲，湖泊，土壤膨胀等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该系统还可以很好地管理流量和水池的分布，这些地方的雨水积聚在很多雨水聚集的地方，而不是在随机的地方。</font><font style="vertical-align: inherit;">因此，生成的水文与地形密切相关。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="http://weigert.vsos.ethz.ch/wp-content/uploads/2020/04/rivererosion.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在256×256网格上进行实时水文模拟。</font><font style="vertical-align: inherit;">原始浮雕相对较平滑，可以使流快速出现。</font><font style="vertical-align: inherit;">从一开始，就可以观察到池和泄漏的最简单的创建，此后便出现并保留了大流量。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比较缩小流量的效果</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要比较通过将地图链接到侵蚀系统而产生的差异，您可以在同一地图上模拟水文状况，包括并禁用各种效果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我模拟了相同的地形三遍：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于粒子的侵蚀（基本侵蚀）接收流量和池图。</font><font style="vertical-align: inherit;">池仍会影响生成</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本侵蚀，其参数由水文地图更改（结合侵蚀）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结合侵蚀与水文地图更改的参数并影响树木的侵蚀</font></font></li>
</ul><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个相当混乱的系统，出现的水文类型高度依赖于地形。</font><font style="vertical-align: inherit;">很难找到救济的“非常揭示”的例子。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/e81/65c/39ee8165c1b4a8ca4f8a987e12464de4.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本系统的浮雕渲染</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/969/6b2/fc0/9696b2fc03defb56681b7bfff7fa6740.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组合系统立面渲染</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/868/d7f/8bc/868d7f8bcd087c968833ba0a4c99619c.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有树木</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
的</font><i><font style="vertical-align: inherit;">系统的地形渲染</font></i><font style="vertical-align: inherit;">有趣的观察：将水文地图与颗粒参数结合起来实际上会使河床变窄。</font><font style="vertical-align: inherit;">特别是在平面区域中，粒子分布较少，并合并为少量更强的流动。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
减少的摩擦和蒸发成功地解决了颗粒开始偏爱现有通道的事实。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
直接观察浮雕，其他效果更明显。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a5/acd/d6b/9a5acdd6b7130655c66c716d0b713ec2.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本系统的水文图</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5df/f5a/575/5dff5a575ae295091062b6e2153694ff.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组合系统的水文图</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d0/acb/8fa/9d0acb8fa508aa24afab3a5dddacf7a5.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有树木的系统的水文图</font></font></i><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些结果是在模拟时间的正好60秒内生成的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
树木还会影响收窄。</font><font style="vertical-align: inherit;">它们增强了在陡峭区域开辟清晰道路的过程。</font><font style="vertical-align: inherit;">它们迫使流保留在已经铺设的通道中，因此降低了曲折度。</font><font style="vertical-align: inherit;">因此，树木的位置会影响水的流动。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://weigert.vsos.ethz.ch/wp-content/uploads/2020/04/Example_Hydrology2.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记录树木位置如何帮助维持溪流位置的示例。</font><font style="vertical-align: inherit;">与所有激活效果一样，这与以前相同。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">池影响</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用于创建水池的系统运行良好，并允许在同一浮雕上存在多个具有不同高度的水体。</font><font style="vertical-align: inherit;">它们也可以相互扩散并排空。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://weigert.vsos.ethz.ch/wp-content/uploads/2020/04/Pooling-1.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个视频示例，该视频显示在海拔高度差较大的较粗糙基线地形上形成水池。</font><font style="vertical-align: inherit;">上层湖泊实际上位于下层湖泊上方，并将生成的水直接排入下层湖泊。</font></font></i><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我得到了几粒种子，其中三个湖泊依次流入，但是我不想花很多时间为本文找到合适的种子。</font><font style="vertical-align: inherit;">我已经生成了太多的图片和视频。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
游泳池的高度有时会跳跃。</font><font style="vertical-align: inherit;">我认为，当水位接近泄漏水平并添加大量水时，会发生这种情况。</font><font style="vertical-align: inherit;">可以通过降低溢流功能中的泄漏率来减小此影响。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/475/469/f09/475469f09d224928863b2b2eaf48cfb8.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再过一分钟后，便会出现几个新池。</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78a/36c/76e/78a36c76ed90db36cae64c47376fc585.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在更陡的角度，盆高的差异更加明显。</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac8/bd1/897/ac8bd18976e9cb06bd8d6d1fffd23667.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水文图清楚地表明，中部盆地合并为下部盆地。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
泛洪算法的执行导致以下事实：池在地图的边界处看到“墙”。</font><font style="vertical-align: inherit;">在上面显示的图像中这很明显。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一个可能的改进可能是在世界上增加了海平面，以便这些池在海平面的地图边缘观察泄漏，否则它们只会溢出。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仿真速度</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下降和淹没的每个步骤的时间因粒子而异，但大约保留一个数量级（大约1微秒）。有了稳定的流动，粒子可以更快地在地图上移动。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
浇筑时间是最昂贵的步骤，因此浇筑时间与池的大小成正比。水池越大，您需要提高水位的面积就越大。大型池绝对是系统的瓶颈。如果您有提高速度的想法，请告诉我。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下降时间与地图的大小和许多其他参数（包括摩擦和蒸发速率）成比例变化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文中的所有视频都是实时录制的，也就是说，模拟速度通常很快。</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本文发表后不久，我对计算表面法线的方法进行了小改动，从而提高了仿真速度。</font><font style="vertical-align: inherit;">在仿真过程中，这种效果非常明显，但是由于启动和泛洪所需的时间差异很大，因此很难对其进行基准测试。</font><font style="vertical-align: inherit;">据我估计，仿真速度提高了一倍。</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更漂亮的视频</font></font></h3><br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://weigert.vsos.ethz.ch/wp-content/uploads/2020/04/Hydrology1.mp4" type="video/mp4"></video></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在不平坦的垂直地形上进行水文模拟。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://weigert.vsos.ethz.ch/wp-content/uploads/2020/04/Hydrology5.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">稍微平滑一点。</font><font style="vertical-align: inherit;">有些湖泊有些波动。</font></font></i><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://weigert.vsos.ethz.ch/wp-content/uploads/2020/04/Hydrology3.mp4" type="video/mp4"></video></div></div></div><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在平坦平坦的地形上进行水文模拟。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提速后录制了后续视频。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://weigert.vsos.ethz.ch/wp-content/uploads/2020/04/Hydrology10.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更平坦，更平滑的地形。</font></font></i><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://weigert.vsos.ethz.ch/wp-content/uploads/2020/04/Hydrology7.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频由几条相连的溪流组成。</font><font style="vertical-align: inherit;">主要河流有两个汇流点，汇入的流量较小，我们看到了它的大小。</font></font></i><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://weigert.vsos.ethz.ch/wp-content/uploads/2020/04/Hydrology9.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随着河流形成，浮雕更加不均匀。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我可以永远继续下去。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论与未来工作</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种简单的技术仍然基于粒子，但是成功地传达了许多附加效果。它提供了一种简单的方法来模拟大规模的水运动，而无需完全模拟流体动力学。此外，她还使用直观的水模型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在模拟中，我们可以观察到蜿蜒曲折的河流，瀑布，湖泊和湖泊输水，将平坦区域分成三角洲的河流等的出现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以土壤图的形式添加不同类型的土壤是很有趣的，可以从中获取侵蚀参数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您还可以轻松地更改树木系统，以创建将土壤固定到位的不同类型的树木。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
很难在几张图片和视频中传达各种生成的结果，因此您应该自己动手做，这很有趣。</font><font style="vertical-align: inherit;">我建议尝试使用原始的地图参数，包括八度音阶噪声和地图比例。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您有任何疑问或意见，可以与我联系。</font><font style="vertical-align: inherit;">我在这个项目上工作非常努力，所以我的大脑在烧结，我确定我错过了一些有趣的方面。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN498278/index.html">出版者彼得。春季促销</a></li>
<li><a href="../zh-CN498280/index.html">凤凰属的渡渡鸟的故事。渡渡鸟大倒塌IS</a></li>
<li><a href="../zh-CN498282/index.html">[说明]在Google Site平台上创建帐户和网站</a></li>
<li><a href="../zh-CN498284/index.html">如何优化英语学习</a></li>
<li><a href="../zh-CN498288/index.html">您的城市需要地铁</a></li>
<li><a href="../zh-CN498292/index.html">在PostgreSQL中节省大量资金</a></li>
<li><a href="../zh-CN498294/index.html">物体检测 认识和统治。第1部分</a></li>
<li><a href="../zh-CN498296/index.html">在系统级别进行设计。第1部分。从概念到系统</a></li>
<li><a href="../zh-CN498298/index.html">公司利用漏洞赏金来购买黑客的沉默</a></li>
<li><a href="../zh-CN498300/index.html">Blitz.Engine：资产系统</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>