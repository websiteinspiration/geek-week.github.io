<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏾 🧘🏾 😌 子供でも理解します：非同期の簡単な説明/ JavaScriptでの待機と約束 💟 👨‍👨‍👧‍👦 🧙🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！Jack Pordiによる記事「JavaScript非同期/待って約束」：5歳のように説明された」の翻訳を紹介します。
 
 自分をJavaScript開発者だと考える人は、いつか、コールバック関数、プロミス、または最近では、非同期/待機構文に遭遇しているはずです。十分に長くゲー...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>子供でも理解します：非同期の簡単な説明/ JavaScriptでの待機と約束</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474726/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！</font><font style="vertical-align: inherit;">Jack Pordiによる</font><font style="vertical-align: inherit;">記事</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「JavaScript非同期/待って約束」：5歳のように説明</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">された</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">」の</font></a><font style="vertical-align: inherit;">翻訳を紹介します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自分をJavaScript開発者だと考える人は、いつか、コールバック関数、プロミス、または最近では、非同期/待機構文に遭遇しているはずです。</font><font style="vertical-align: inherit;">十分に長くゲームに参加している場合は、ネストされたコールバック関数がJavaScriptで非同期を実現する唯一の方法であるという時期に出くわすでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私がJavaScriptで学習および記述し始めたとき、JavaScriptで非同期を実現する方法を説明する10億のチュートリアルとチュートリアルがすでにありました。</font><font style="vertical-align: inherit;">ただし、それらの多くは、コールバック関数をpromiseまたはasync / awaitのpromiseに変換する方法を簡単に説明しています。</font><font style="vertical-align: inherit;">多くの人にとって、これはおそらく彼らとうまくやってコードでそれらを使い始めるのに十分以上です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、私と同じように、（JavaScript構文だけでなく）非同期プログラミングを本当に理解したい場合は、非同期プログラミングを最初から説明する資料が不足していることに同意するかもしれません。</font></font><a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期とはどういう意味ですか？</font></font></h2><br>
<img src="https://habrastorage.org/webt/sk/ml/pc/skmlpcgi3gmhov77moxcfyengek.jpeg" alt="写真は考える人を示しています"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則として、この質問をすると、次のことから何かを聞くことができます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同時にコードを実行するいくつかのスレッドがあります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一度に複数のコードが実行されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは並行性です。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ある程度、すべてのオプションは正しいです。</font><font style="vertical-align: inherit;">しかし、すぐに忘れそうな技術的な定義を与える代わりに</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、子供でも理解できる例を挙げます</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人生の例</font></font></h2><br>
<img src="https://habrastorage.org/webt/lu/gq/ww/lugqwwbgniupu-afgs3oxavro9a.jpeg" alt="写真は野菜と包丁を示しています"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
野菜スープを調理しているとしましょう。</font><font style="vertical-align: inherit;">よくて単純な例えとして、野菜スープがタマネギとニンジンのみで構成されていると仮定します。</font><font style="vertical-align: inherit;">そのようなスープのレシピは次のようになります：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人参をみじん切りにする。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タマネギをみじん切りにする。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">鍋に水を加え、ストーブの電源を入れ、沸騰するまで待ちます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にんじんを鍋に入れて5分ほどおく。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">玉ねぎを鍋に入れてさらに10分煮る。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの手順はシンプルで理解しやすいものですが、これを読んでいて料理の仕方を本当に知っている人なら、これが最も効果的な料理方法ではないと言えるでしょう。</font><font style="vertical-align: inherit;">そしてあなたは正しいでしょう、それが理由です：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステップ3、4、および5では、実際に</font><font style="vertical-align: inherit;">シェフとして、プロセスを観察して時間を追跡する以外に何かをする</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要はあり</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ませ</font><i><b><font style="vertical-align: inherit;">ん</font></b></i><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステップ1および2では</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">積極的に何かを行う</font><i><b><font style="vertical-align: inherit;">必要</font></b></i><font style="vertical-align: inherit;">が</font><i><b><font style="vertical-align: inherit;">あり</font></b></i><font style="vertical-align: inherit;">ます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、より経験豊富なコックのレシピは次のようになります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">鍋を沸騰させます。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">鍋が沸騰するのを待っている間に、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニンジンを切り始めます。</font></font></li>
<li><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にんじんの刻み</font><b><font style="vertical-align: inherit;">を終える頃</font></b><font style="vertical-align: inherit;">には水が沸騰しているので、にんじんを加えます。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にんじんを鍋で炊き</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上げながら玉ねぎをみじん切りにする。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タマネギを加え、さらに10分調理する。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのアクションが同じままであるという事実にもかかわらず、あなたはこのオプションがはるかに速く、より効率的になることを期待する権利があります。</font><font style="vertical-align: inherit;">これはまさに非同期プログラミングの原則</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。他のいくつかの便利なことに時間を費やすことができる一方で、何かを待つ必要はありません。</font></font><br>
</b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラミング</font><font style="vertical-align: inherit;">では、サーバーからのHTTP応答を待っているのか、ユーザーからのアクションを待っているのか、それ以外の何かを待っているのにかかわらず</font><font style="vertical-align: inherit;">、プログラミングで</font><font style="vertical-align: inherit;">かなりの頻度</font><font style="vertical-align: inherit;">で</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待機する</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことがよくあります。</font><font style="vertical-align: inherit;">ただし、プロセッサの実行サイクルは貴重であり、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アクティブに使用し、何かを実行し、期待しないでください。これにより、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期プログラミングが可能になり</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それではJavaScriptに移りましょう。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、野菜スープの同じ例に従って、上記のレシピのステップを表すいくつかの関数を記述します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、時間のかからないタスクを表す同期関数を作成しましょう。</font><font style="vertical-align: inherit;">これは古き良きJavaScript関数ですが、私は関数</font></font><b><code>chopCarrots</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><code>chopOnions</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、アクティブな作業（および時間）を必要とするタスクとして</font><font style="vertical-align: inherit;">説明</font><font style="vertical-align: inherit;">しているため、長い計算を実行できることに</font><font style="vertical-align: inherit;">注意してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">完全なコードは記事の最後にあります[1]。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chopCarrots</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">/*
     ...
  */</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">" !"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chopOnions</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">/*
     ...
  */</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">" !"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addOnions</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"   !"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCarrots</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"   !"</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期関数に移る前に、JavaScriptタイプシステムが非同期を処理する方法を最初に簡単に説明します。基本的に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、非同期操作のすべての結果（エラーを含む）はpromiseにラップする必要があります</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数がpromiseを返すには、次のことができます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明示的に約束を返す、すなわち </font></font><b><code>return new Promise(…)</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暗黙的にpromiseを返します- </font></font><b><code>async</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数宣言に</font><font style="vertical-align: inherit;">キーワード</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">追加</font><font style="vertical-align: inherit;">します。</font></font><b><code>async function foo()</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">両方のオプションを使用します</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
優れた記事[2]があり、非同期関数とpromiseを返す関数の違いについて説明しています。</font><font style="vertical-align: inherit;">したがって、私の記事ではこのトピックについて詳しく説明しません。主なことを覚えておいて</font><font style="vertical-align: inherit;">ください</font><font style="vertical-align: inherit;">。非同期関数で</font><font style="vertical-align: inherit;">は</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常に</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーワード</font></font><b><code>async</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">必要</font><i><b><font style="vertical-align: inherit;">があり</font></b></i><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、野菜スープの準備のステップ3〜5を表す非同期関数は次のとおりです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">letPotKeepBoiling</span>(<span class="hljs-params">time</span>) </span>{
  <span class="hljs-keyword">return</span>; <span class="hljs-comment">//  ,     </span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boilPot</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span>; <span class="hljs-comment">//  ,      </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しになりますが、実装の詳細が邪魔にならないように削除しましたが、記事の最後に公開されています[1]。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロミスの結果を待つために、後でそれを使って何かを行うことができるように、単純にキーワードを使用できることを知っておくことが重要です</font></font><b><code>await</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFunction</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">/*  ... */</span><font></font>
}<font></font>
<font></font>
result = <span class="hljs-keyword">await</span> asyncFunction();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だから今、私たちはそれをすべて一緒にする必要があります：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeSoup</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> pot = boilPot();<font></font>
  chopCarrots();<font></font>
  chopOnions();<font></font>
  <span class="hljs-keyword">await</span> pot;<font></font>
  addCarrots();<font></font>
  <span class="hljs-keyword">await</span> letPotKeepBoiling(<span class="hljs-number">5</span>);<font></font>
  addOnions();<font></font>
  <span class="hljs-keyword">await</span> letPotKeepBoiling(<span class="hljs-number">10</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"   !"</span>);<font></font>
}<font></font>
<font></font>
makeSoup();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちょっと待って！これは動作しません！エラーが表示されます</font></font><b><code>SyntaxError: await is only valid in async functions</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。どうして？キーワードを使用して関数を宣言しない場合</font></font><b><code>async</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、デフォルトでJavaScriptはそれを同期関数として定義します-同期は待機しないことを意味します！ [3]。また、</font></font><b><code>await</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外部関数を</font><font style="vertical-align: inherit;">使用できないことも意味します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、</font></font><b><code>async</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数に</font><font style="vertical-align: inherit;">キーワード</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">追加するだけ</font><font style="vertical-align: inherit;">です</font></font><b><code>makeSoup</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeSoup</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> pot = boilPot();<font></font>
  chopCarrots();<font></font>
  chopOnions();<font></font>
  <span class="hljs-keyword">await</span> pot;<font></font>
  addCarrots();<font></font>
  <span class="hljs-keyword">await</span> letPotKeepBoiling(<span class="hljs-number">5</span>);<font></font>
  addOnions();<font></font>
  <span class="hljs-keyword">await</span> letPotKeepBoiling(<span class="hljs-number">10</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"   !"</span>);<font></font>
}<font></font>
<font></font>
makeSoup();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして出来上がり！</font><font style="vertical-align: inherit;">ニンジンのカットを開始する前に鍋が沸騰し始めるまで待機したくないため</font><font style="vertical-align: inherit;">、2行目で</font></font><b><code>boilPot</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はキーワードなしで</font><font style="vertical-align: inherit;">非同期関数を呼び出していることに注意してください</font></font><b><code>await</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><b><code>pot</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水が沸騰する前にニンジンを鍋に入れる必要がないので、5行目での</font><font style="vertical-align: inherit;">約束のみを期待</font><font style="vertical-align: inherit;">します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通話中に何が起こります</font></font><b><code>await</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">か？まあ、何も... </font><font style="vertical-align: inherit;">なんか</font><font style="vertical-align: inherit;">... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数のコンテキストでは、</font></font><b><code>makeSoup</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何かが起こること（または最終的に返される結果）を期待していると考えることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、覚えておいて</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ください</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><b><font style="vertical-align: inherit;">あなたは（あなたのプロセッサのように）ただそこに座って何かを待つことは決して望みませんが、あなたは他のものに時間を費やすことができます</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、スープを調理するだけでなく、並行して何かを調理することができます。</font></font><br>
<br>
<pre><code class="javascript hljs">makeSoup();<font></font>
makePasta();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
待っている間</font></font><b><code>letPotKeepBoiling</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、例えばパスタを作ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
見る？</font><font style="vertical-align: inherit;">async / await構文は実際にはかなり使いやすく、理解できれば同意しますか？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明白な約束はどうですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、あなたが主張するなら、私は明示的なプロミスの使用に向かいます（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">約Transl。：明示的なプロミスによって、著者はプロミスの構文を直接暗示し、暗黙的なプロミスによって構文async / awaitは暗黙的にプロミスを返すため、書く必要はありません</font></font><code>return new Promise(…)</code></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">） async / awaitメソッド</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はpromise自体に基づいているため、どちらのオプションも完全に互換性があることに注意してください</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では、明示的な約束は古いスタイルのコールバックと新しい非同期/性的構文を待つことの間にあります。あるいは、性的構文を非同期/待機することは暗黙の約束に過ぎないと考えることもできます。最後に、async / awaitコンストラクトはpromiseの後にあり、promiseはコールバック関数の後にありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイムマシンを使用して、コールバック地獄[4]に移動します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callbackHell</span>(<span class="hljs-params"></span>) </span>{<font></font>
  boilPot(<font></font>
    <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
      addCarrots();<font></font>
      letPotKeepBoiling(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
        addOnions();<font></font>
        letPotKeepBoiling(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"   !"</span>);<font></font>
        }, <span class="hljs-number">1000</span>);<font></font>
      }, <span class="hljs-number">5000</span>);<font></font>
    },<font></font>
    <span class="hljs-number">5000</span>,<font></font>
    chopCarrots(),<font></font>
    chopOnions()<font></font>
  );<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は嘘をつくつもりはありません。私がこの記事に取り組んでいたときにその場でこの例を書いたので、私が認めるよりもはるかに長い時間がかかりました。</font><font style="vertical-align: inherit;">あなた方の多くはここで何が起こっているのかさえ知らないかもしれません。</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">親愛なる友人、これらすべてのコールバック関数はひどいものではありませんか？</font><font style="vertical-align: inherit;">コールバック関数を二度と使用しないようにしましょう...</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
そして、約束されたように、明示的な約束を持つ同じ例：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeSoup</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all([
    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">reject, resolve</span>) =&gt;</span> {<font></font>
      chopCarrots();<font></font>
      chopOnions();<font></font>
      resolve();<font></font>
    }),<font></font>
    boilPot()<font></font>
  ])<font></font>
    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
      addCarrots();<font></font>
      <span class="hljs-keyword">return</span> letPotKeepBoiling(<span class="hljs-number">5</span>);<font></font>
    })<font></font>
    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
      addOnions();<font></font>
      <span class="hljs-keyword">return</span> letPotKeepBoiling(<span class="hljs-number">10</span>);<font></font>
    })<font></font>
    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"   !"</span>);<font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、promiseはまだコールバック関数に似ています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
詳細には触れませんが、最も重要なことは次のとおりです。</font></font><br>
<br>
<ul>
<li><b><code>.then</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 結果を受け取り、それを引数関数（基本的にはコールバック関数）に渡すpromisメソッドです。</font></font></li>
<li>         <b><code>.then</code></b>.  , .then    ,   ,      callback-.</li>
<li>  <b><code>.then</code></b>,       — <b><code>.catch</code></b>.       .       ,           .</li>
</ul><br>
<h2></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事から約束と非同期プログラミングについていくつかのアイデアを得たか、おそらく少なくとも他の人にこれを説明するために人生から良い例を学んだと思います。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それで、あなたはどちらの方法を使用しますか：promiseまたはasync / await？</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
答えは完全にあなた次第です。両方のアプローチは互いに完全に互換性があるため、それらを組み合わせるのはそれほど悪くはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それにもかかわらず、私は非同期/待機キャンプで100％です。なぜなら、私にとってコードははるかに明確で、非同期プログラミングの真のマルチタスクをよりよく反映しているからです。</font></font><br>
<br>
<hr><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：完全なソースコードは</font></font><u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらから</font></font></a></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入手でき</font><u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a></u><font style="vertical-align: inherit;">。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：元の記事</font></font><u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「非同期関数と </font><font style="vertical-align: inherit;">約束「を返す関数</font></font></a></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の記事の翻訳</font></font><u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期機能と機能の違いそのリターンを約束します」</font></font></a></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">" </font></a></u></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：JavaScriptはおそらく関数本体によって非同期/待機タイプを決定し、再帰的にチェックできると主張できますが、JavaScriptはコンパイル時に静的型の安全性を処理するように設計されていないことは言うまでもありません関数の種類を明示的に確認する方が開発者にとってはるかに便利です。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：私は「非同期」関数を記述しました。それらは同じインターフェースで動作することを想定しています。</font></font><b><code>setTimeout</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">コールバックはpromiseと互換性がなく、その逆も同様です。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja474716/index.html">バグC ++ 20。ベルファストでの会議の結果</a></li>
<li><a href="../ja474718/index.html">オートエレクトロニクスの安全性-ダッシュボードコントローラーのHello World</a></li>
<li><a href="../ja474720/index.html">ニジニノヴゴロドのラジオ研究所とロセフの「クリスタディン」</a></li>
<li><a href="../ja474722/index.html">「誰も何をする必要があるかを他人に言わない」：バベルの開発などに関するNicolòRibaudo</a></li>
<li><a href="../ja474724/index.html">5年間でPHPはどうなりますか：最寄りのモスクワのミタップのスピーカーに質問しました</a></li>
<li><a href="../ja474732/index.html">マイクロコントローラー用のC ++でピンのリストを操作する（例としてCortexMを使用）</a></li>
<li><a href="../ja474738/index.html">フィレットサーフェスの形状モデリング</a></li>
<li><a href="../ja474740/index.html">マウンテンビューのベストコンピュータ歴史博物館</a></li>
<li><a href="../ja474744/index.html">Uberが金融サービス市場に参入し、Uber Money部門を立ち上げる</a></li>
<li><a href="../ja474746/index.html">奥の部屋のオブジェクトストレージ、または独自のサービスプロバイダーになる方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>