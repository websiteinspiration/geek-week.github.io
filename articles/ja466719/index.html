<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏 🍤 🕰️ 超軽量速度プロファイリング：理論と実践。パート1 👨‍👦‍👦 🐾 👴🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは！見出しから、あなたは私がこれから話すことをすでに理解していました。多くのハードコアがあり
 ます。Java、C、C ++、アセンブラ、少しのLinux、少しのオペレーティングシステムのカーネルについて説明します。また、実際のケースも分析するため、記事は3つの大きなパートに分かれます（かな...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>超軽量速度プロファイリング：理論と実践。パート1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/466719/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは！</font><font style="vertical-align: inherit;">見出しから、あなたは私がこれから話すことをすでに理解していました。</font><font style="vertical-align: inherit;">多くのハードコアがあり</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。Java、C、C ++、アセンブラ、少しのLinux、少しのオペレーティングシステムのカーネルについて説明します。</font><font style="vertical-align: inherit;">また、実際のケースも分析するため、記事は3つの大きなパートに分かれます（かなりボリュームがあります）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mp/cl/er/mpclerfppp9jx5ciuziyfv-n8oa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、既存のプロファイラからすべてを絞り込もうとします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の部分では、独自の小さなプロファイラーを作成します。3番目の部分では、既存のツールはこれにあまり適していないため、プロファイリングに一般的でないものをプロファイリングする方法を説明します。</font><font style="vertical-align: inherit;">あなたがこの道を行く準備ができているなら-カットの下であなたを待っています:)</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間と理解の手段-プロファイラー</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプリングプロファイラーのしくみ</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのくらいの頻度でサンプリングする必要がありますか</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロファイラーを選択</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javaアプリケーションプロファイルを作成することをperfに教える</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンスのサンプリングレートを上げる</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは（明示的に）ハードウェアPMU / PEBSイベントを使用します</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">短い要約</font></font></a></li>
</ul> <br>
<a name="1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間と理解の手段-プロファイラー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
日常の観点からは、1秒は非常に短いです。</font><font style="vertical-align: inherit;">しかし、1秒は完全に10億ナノ秒であることはわかっています。</font><font style="vertical-align: inherit;">そして、1ナノ秒でプロセッサの約4クロックサイクルしか実行されない場合でも、1秒でコンピュータで多くのことが行われ、私たちの生活を向上または悪化させる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それ自体が速度にとって非常に重要なアプリケーションを開発しているとしましょう。一部のコードフラグメントでは、これは一般に重要です。</font><font style="vertical-align: inherit;">これらの断片は、たとえば数百マイクロ秒-十分速く実行され</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、[ </font><i><font style="vertical-align: inherit;">コードのセクション</font></i><font style="vertical-align: inherit;"> ]は、アプリケーションの成功と獲得または損失した金額に直接影響します。</font><font style="vertical-align: inherit;">例えば、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
取引所の取引を完了するために注文を送信する場合、100マイクロ秒の遅延は、取引ごとに100万ルーブル以上の取引所の費用がかかる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスク</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は私のために設定されました</font><font style="vertical-align: inherit;">：一方では、同時にすべての注文を送信する必要があり、他方では、最初と最後の差異が最小になるようにそれらを送信します。つまり、注文を取引所に送信する関数をプロファイルする必要がありました。 1つの小さなニュアンスを除いて、典型的なタスク：この関数の特徴的な実行時間は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100μsより大幅に短いです</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部で何が起こっているのかを理解するために、これらの100μsをどのようにプロファイリングするかを考えてみましょう。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このツールを選択するときに考慮すべきことは何ですか？</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関心のあるコードのセクションはめったに実行されません。つまり、100マイクロ秒は1秒に1回どこかで実行されます。</font><font style="vertical-align: inherit;">そして、これはテストベンチにあり、本番環境ではさらに少ないです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このコードは、プロジェクトの重要な部分、さらにはネットワークを介した入出力に影響を与えるため、マイクロベンチマークに分離することは困難です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして最後に、最も重要なこととして、結果のプロファイルを、実動サーバー上での動作に対応させる必要があります。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのニュアンスをすべて考慮して、関心のある方法を正しくプロファイリングするにはどうすればよいですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
概念的には、すべてのプロファイラーは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計装</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプリングの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2つのグループに分けることができます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">各グループを個別に検討してみましょう。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ツーリングプロファイラー</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイトコードを変更してタイミングレコードを挿入するため、かなりのオーバーヘッドが追加されます。したがって、このようなプロファイラーの主な欠点は、実行可能コードに大きな影響を与える可能性があることです。結果として、結果のプロファイルが本番サーバーの動作とどの程度一致するかを言うのは困難です。最適化には、動作が異なる場合と、動作しない場合と、動作しない場合があります。おそらく、他の時間スケール（秒、分、時間）では、代表的なデータが得られます。ただし、100μsのスケールでは、トリガーされた、または失敗した最適化は、プロファイルを完全に代表しないものにする可能性があります。それでは、プロファイラーの別のグループを詳しく見てみましょう。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプリングプロファイラー</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小限または中程度のオーバーヘッドを提供します。</font><font style="vertical-align: inherit;">これらのツールは、実行可能コードに直接影響を与えることはなく、その使用にはもう少し注意が必要です。</font><font style="vertical-align: inherit;">したがって、サンプリングプロファイラーについて詳しく説明します。</font><font style="vertical-align: inherit;">どのデータをどのような形式で受け取るかを見てみましょう。</font></font><br>
<br>
<a name="2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプリングプロファイラーはどのように機能しますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプリングプロファイラーがどのように機能するかを理解するために、次の例を検討して</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ください。sendToMoex</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">は他のいくつかのメソッドを呼び出します。</font><font style="vertical-align: inherit;">私たちが見ます：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">void</span> sendToMoex() {<font></font>
  a.qqq();<font></font>
  b.doo();<font></font>
  c.ccc()<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">void</span> doo() {<font></font>
  d.a();<font></font>
  d.b();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムのこのセクションの実行時にコールスタックの状態を観察し、定期的に記録すると、おおよそ次の形式で情報が得られます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gl/je/y5/gljey5esfyih7lqm1yjvpaxfese.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、コールスタックのセットです。</font><font style="vertical-align: inherit;">サンプルがかなり均等に分散していると仮定すると、同一スタックの数は、スタックの最上位にあるメソッドの相対的な実行時間を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、DaメソッドはC.cccメソッドと同じくらい実行されましたが、これはDbメソッドの2倍です。ただし、サンプルの分布が完全であるという仮定も完全に正しくなく、実行時間の見積もりは正しくありません。</font></font><br>
<br>
<a name="3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのくらいの頻度でサンプリングする必要がありますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部で何が再生されたかを理解するために、100マイクロ秒で1000サンプルを取得するとします。次に、100μsで1000サンプルを実行する必要がある場合、1秒で1000万サンプル、つまり10,000,000サンプル/秒であるという単純な比率で計算します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/x6/rw/2j/x6rw2jbbfxfouax9ncy8hkfn3nq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような速度でサンプリングする場合、コードの1回の実行で1000個のサンプルを収集し、何が速くまたは遅く働いたかを集計して理解します。その後、パフォーマンスを分析し、コードを調整します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、1秒あたり1000万サンプルの頻度は多くなります。</font><font style="vertical-align: inherit;">そして、最初からプロファイリングの速度を上げることができない場合はどうでしょうか。</font><font style="vertical-align: inherit;">1000ではなく10サンプルのみを収集したと仮定します。この場合、プロファイルされたコードの次の実行を待つ必要があります。これは1秒後に発生します（結局、プロファイルされたコードは1秒に1回実行されます）。</font><font style="vertical-align: inherit;">したがって、さらに10個のサンプルを収集します。</font><font style="vertical-align: inherit;">それらは私たちと一緒に均等に配布されるため、共通のセットに組み合わせることができます。</font><font style="vertical-align: inherit;">プロファイリングされたコードが1000/10 = 100回実行されるまで待つだけで十分です。必要な1000サンプル（各100回に10サンプル）を収集します。</font></font><br>
<br>
<a name="4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロファイラーを選択</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この理論的な知識で武装して、練習に移りましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テイク</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期プロファイラを。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Java仮想マシンのバイトコードの命令までの呼び出しスタックを収集する優れたツール（AsyncGetCallTrace仮想マシン呼び出しを使用）。 async-profilerの公称サンプリングレートは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1秒あたり1000サンプル</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純な比率を解決します：10,000,000サンプル/秒-1秒、1000サンプル/秒-X秒。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
async-profilerの標準的なサンプリング頻度では、プロファイリングに約3時間かかります。久しぶりです。理想的には、プロファイルをできるだけ速く、超光速で組み立てたいです。</font><b><font style="vertical-align: inherit;">Async-profiler</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
をオーバークロックしてみましょう</font><font style="vertical-align: inherit;">。これを行うには、readmeでフラグを見つけます。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><code>-i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、サンプリング間隔を設定します。</font><font style="vertical-align: inherit;">フラグ</font></font><code>-i1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（1ナノ秒）または一般的</font></font><code>-i0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にを設定して、プロファイラーが停止せずにサンプリングするようにします。</font><font style="vertical-align: inherit;">私は毎秒約2.5千サンプルの周波数を得ました。</font><font style="vertical-align: inherit;">この場合、プロファイリングの合計期間は約1時間になります。</font><font style="vertical-align: inherit;">もちろん、3時間ではなく、それほど速くもありません。</font><font style="vertical-align: inherit;">必要なプロファイリング速度を達成するためには、質的に異なる何かをして、新しいレベルに到達する必要があるようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大幅に高い周波数を実現するには、AsyncGetCallTrace呼び出しを中止し、</font><b><font style="vertical-align: inherit;">perf</font></b><font style="vertical-align: inherit;">を使用する必要があります</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-すべてのLinuxディストリビューションに含まれる通常のLinuxプロファイラー。</font><font style="vertical-align: inherit;">ただし、perfはJavaについて何も知らないため、Javaで動作するようにperfをトレーニングする必要があります。</font><font style="vertical-align: inherit;">それまでの間、このようなperfを恐ろしい方法で実行してみましょう。</font></font><br>
<br>
<pre><code class="java hljs">$ perf record –F <span class="hljs-number">10000</span> -p PID -g -- sleep <span class="hljs-number">1</span>
[ perf record: Woken up <span class="hljs-number">1</span> times to write data ]<font></font>
[ perf record: .. <span class="hljs-number">0.215</span> MB perf.data (<span class="hljs-number">4032</span> samples) ]</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表記についての詳細</font></font></b><div class="spoiler_text"><ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perfレコード</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、プロファイルを</font><i><font style="vertical-align: inherit;">記録</font></i><font style="vertical-align: inherit;">することを意味します。</font></font></li>
<li> <code>-F</code>   10 000 —   .</li>
<li> <code>-p</code>   ,       PID  Java-.</li>
<li> <code>-g</code>     . </li>
<li>,   <i>sleep 1</i>     1 .</li>
</ul></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜコールスタックを収集する必要があるのですか？</font><font style="vertical-align: inherit;">すべてを連続してプロファイルし、収集したデータから、関心のある部分（注文の作成と送信を担当する方法）を抽出します。</font><font style="vertical-align: inherit;">収集したサンプルが関心のあるデータに属しているマーカーは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sendToMoex</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font><b><font style="vertical-align: inherit;">呼び出しの</font></b><font style="vertical-align: inherit;">スタックフレームの存在です</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javaアプリケーションプロファイルを作成することをperfに教える</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
perf record ...コマンドを実行し、1秒待ってから、perfスクリプトを実行して、プロファイルの内容を確認しますか？</font><font style="vertical-align: inherit;">そして、私たちはあまりはっきりしない何かを見るでしょう：</font></font><br>
<br>
<pre><code class="javascript hljs">$ perf script<font></font>
<font></font>
java <span class="hljs-number">8079</span> <span class="hljs-number">2008793.746571</span>:    <span class="hljs-number">3745505</span> cycles:uppp: 
            <span class="hljs-number">7</span>fa1e88b53f8 [unknown] (<span class="hljs-regexp">/tmp/</span>perf<span class="hljs-number">-11038.</span>map)<font></font>
java <span class="hljs-number">8079</span> <span class="hljs-number">2008793.747565</span>:    <span class="hljs-number">3728336</span> cycles:uppp: 
            <span class="hljs-number">7</span>fa1e88b5372 [unknown] (<span class="hljs-regexp">/tmp/</span>perf<span class="hljs-number">-11038.</span>map)<font></font>
java <span class="hljs-number">8079</span> <span class="hljs-number">2008793.748613</span>:    <span class="hljs-number">3731147</span> cycles:uppp: 
            <span class="hljs-number">7</span>fa1e88b53ef [unknown] (<span class="hljs-regexp">/tmp/</span>perf<span class="hljs-number">-11038.</span>map)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アドレスのようですが、Javaメソッドの名前はありません。</font><font style="vertical-align: inherit;">したがって、これらのアドレスをメソッドの名前と一致させるようにperfに教える必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CおよびC ++の世界では、いわゆるデバッグ情報を使用して、アドレスと関数名を突き合わせます。</font><font style="vertical-align: inherit;">対応は実行可能ファイルの特別なセクションに保存されます。1つのメソッドはそのようなアドレスにあり、別のメソッドは他のアドレスにあります。</font><font style="vertical-align: inherit;">Perfはこの情報を取得してマッピングを行います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、仮想マシンのJITコンパイラは、この形式でデバッグ情報を生成しません。</font><font style="vertical-align: inherit;">私たちはまだ別の方法を持っています-特別なperf-mapファイルにメソッドのアドレスと名前の対応に関するデータを書き込むことです。このperf-mapファイルは、読み取ったデバッグ情報への追加として扱います。</font><font style="vertical-align: inherit;">このperf-mapファイルはtmpフォルダーにあり、次のデータ構造を持つ必要があります。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドコードの開始アドレス</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード長</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド名</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7f99a911d600</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">120</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">java.util.AbstractCollection。&lt;init&gt;</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7f99a911d9c0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">180</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">java.util.AbstractList。&lt;init&gt;</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7f99a911de80</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5c0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">java.util.Arrays.copyOf</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7f99a911ed40</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">140</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">java.util.ArrayList $ Itr.hasNext</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7f99a911f200</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3e0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">java.util.ArrayList $ Itr.next</font></font><br>
</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の列はメソッドコードの先頭のアドレス、2番目の列はその長さ、3番目の列はメソッドの名前です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、同様のファイルを生成する必要があります。</font><font style="vertical-align: inherit;">明らかに、これは手動では機能しません（JITコンパイラーがコードを配置するアドレスをどのように知るか）。そのため、perf-map-agentプロジェクトのcreate-java-perf-map.shスクリプトを使用して、JavaプロセスのPIDを渡します。</font><font style="vertical-align: inherit;">ファイルの準備ができています。内容を確認し、perf-scriptを再度実行してください。</font></font><br>
<br>
<pre><code class="javascript hljs">$ perf script<font></font>
<font></font>
java  <span class="hljs-number">8080</span> <span class="hljs-number">1895245.867498</span>:    cycles:uppp: 
	<span class="hljs-number">7</span>fb2dd10f527 Loop3.doRecursiveCall (<span class="hljs-regexp">/tmp/</span>perf<span class="hljs-number">-8079.</span>map)<font></font>
<font></font>
java  <span class="hljs-number">8080</span> <span class="hljs-number">1895245.868176</span>:    <span class="hljs-number">2127960</span> cycles:uppp: 
	<span class="hljs-number">7</span>fb2dd10f57f Loop3.doRecursiveCall (<span class="hljs-regexp">/tmp/</span>perf<span class="hljs-number">-8079.</span>map)<font></font>
<font></font>
java  <span class="hljs-number">8080</span> <span class="hljs-number">1895245.868737</span>:    <span class="hljs-number">1959990</span> cycles:uppp: 
	<span class="hljs-number">7</span>fb2dd10f627 Loop3.doRecursiveCall (<span class="hljs-regexp">/tmp/</span>perf<span class="hljs-number">-8079.</span>map)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出来上がり！ Javaメソッドの名前が表示されます。何が起こったのか：Javaについて何も知らないパフォーマンスプロファイラーに、通常のJavaアプリケーションのプロファイルを作成し、このアプリケーションのホットなJavaメソッドを確認するように教えました！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、問い合わせているプログラムの一部のパフォーマンスを分析するために、収集されたすべてのサンプルから目的のデータを除外するのに十分なコールスタックがありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールスタックを取得する方法？</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
次に、呼び出しスタックを取得するために、perfまたは仮想マシンで他のことを行う必要があります。何をする必要があるかを理解するために、一歩戻り、スタックが一般的にどのように機能するかを見てみましょう。 3つの関数f1、f2、f3があるとします。さらに、f1はf2を呼び出し、f2はf3を呼び出します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">void</span> f1() {<font></font>
    f2();<font></font>
}<font></font>
<span class="hljs-keyword">void</span> f2() {<font></font>
    f3();<font></font>
}<font></font>
<span class="hljs-keyword">void</span> f3() {<font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数が実行された時点で、</font></font><code>f3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックの状態を見てみましょう。</font></font><code>rsp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタックの先頭を指す</font><font style="vertical-align: inherit;">レジスター</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">表示され</font><font style="vertical-align: inherit;">ます。また、スタックには前のスタックフレームのアドレスが含まれています。そして、どうすればコールスタックを取得できますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なんとかしてこの領域のアドレスを取得できた場合、スタックを単純に接続されたリストとして想像し、現在の実行ポイントに到達した呼び出しのシーケンスを理解できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これには何が必要ですか？黄色の領域を指す追加のrbpレジスタが必要です。 rbpレジスターにより、perfがコールスタックを取得して、現在のポイントに至ったシーケンスを理解できることがわかります。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">System Vアプリケーションバイナリインターフェイスで</font></a><font style="vertical-align: inherit;">これらの詳細を読むことをお勧めし</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Linuxでのメソッドの呼び出し方法について説明します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0m/0w/vx/0m0wvx8wcaplslb7k5illbb4hbm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは問題が何であるかを理解しました。スタックフレームの先頭へのポインタとして、仮想マシンに元の目的でrbpレジスタを使用するように強制する必要があります。これは、JITコンパイラがrbpレジスタを使用する方法です。これを行うために、仮想マシンにはPreserveFramePointerフラグがあります。このフラグを仮想マシンに渡すと、仮想マシンは従来の目的でrbpレジスタの使用を開始します。そして、Perfはスタックをスピンできます。そして、プロファイルに実際の呼び出しスタックが表示されます。フラグは悪名高いブレンダングレッグによってJDK8u60だけで提供されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいフラグで仮想マシンを起動します。</font></font><code>create-java-perf-map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次に</font></font><code>perf record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、と</font><font style="vertical-align: inherit;">を実行</font><font style="vertical-align: inherit;">し</font></font><code>perf script</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。これで、コールスタックを使用して正確なプロファイルを作成できます。</font></font><br>
<br>
<pre><code class="javascript hljs">$ perf script<font></font>
<font></font>
java <span class="hljs-number">18657</span> <span class="hljs-number">1901247.601878</span>:     <span class="hljs-number">979583</span> cycles:uppp: 
            <span class="hljs-number">7</span>fbfd1101edc Loop3.doRecursiveCall (...)
            <span class="hljs-number">7</span>fbfd1101edc Loop3.doRecursiveCall (...)
            <span class="hljs-number">7</span>fbfd1101edc Loop3.doRecursiveCall (...)
            <span class="hljs-number">7</span>fbfd1101edc Loop3.doRecursiveCall (...)
            <span class="hljs-number">7</span>f285d007b10 Interpreter (...)
            <span class="hljs-number">7</span>f285d0004e7 call_stub (...)
                  <span class="hljs-number">67</span>d0db [unknown] (... libjvm.so)<font></font>
...<font></font>
                    <span class="hljs-number">708</span>c start_thread (... libpthread<span class="hljs-number">-2.26</span>.so)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどのLinuxディストリビューションに含まれているperfプロファイラーに、Javaアプリケーションで動作するように教えました。</font><font style="vertical-align: inherit;">したがって、今ではコードのホットセクションだけでなく、現在のホットスポットにつながった一連の呼び出しも確認できます。</font><font style="vertical-align: inherit;">perfプロファイラーがJavaについて何も知らないことを考えると、素晴らしい成果です。</font><font style="vertical-align: inherit;">私たちはこれをperfに教えました！</font></font><br>
<br>
<a name="7"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンスのサンプリングレートを上げる</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
perfを毎秒1000万サンプルにオーバークロックしてみましょう。</font><font style="vertical-align: inherit;">これで周波数が大幅に低下しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今行ったすべてのタスクを自動化するには</font></font><code>perf-java-record-stack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、perf-map-agentプロジェクトの</font><font style="vertical-align: inherit;">スクリプト</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">彼は素晴らしいペンを持っ</font></font><code>perf_record-freq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ています</font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">サンプリング周波数を設定できる</font><font style="vertical-align: inherit;">環境変数</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">まず、毎秒10万サンプルを設定して実行してみましょう。</font><font style="vertical-align: inherit;">最大許容サンプリング周波数を超えたという恐ろしいメッセージがコンソールに表示されます。</font></font><br>
<br>
<pre><code class="javascript hljs">$ PERF_RECORD_FREQ=<span class="hljs-number">100000</span> ./bin/perf-java-record-stack PID<font></font>
...<font></font>
Maximum frequency rate (<span class="hljs-number">30000</span>) reached.<font></font>
Please use -F freq option <span class="hljs-keyword">with</span> lower value or consider<font></font>
tweaking /proc/sys/kernel/perf_event_max_sample_rate.<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の場合、制限は毎秒3万サンプルでした。</font><font style="vertical-align: inherit;">Perfはすぐにどのカーネル引数を修正する必要があるかを示します</font></font><code>sysctl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これ</font><font style="vertical-align: inherit;">は、目的のファイルでecho sudo teeを使用するか、直接を使用して行い</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">そう：</font></font><br>
<br>
<pre><code class="javascript hljs">$ echo <span class="hljs-string">'1000000'</span> | <font></font>
sudo tee /proc/sys/kernel/perf_event_max_sample_rate </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とか、ぐらい：</font></font><br>
<br>
<pre><code class="javascript hljs">$ sudo sysctl kernel.perf_event_max_sample_rate=<span class="hljs-number">1000000</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、周波数の上限が1秒あたり100万サンプルになったことをカーネルに伝えています。プロファイラーを再び開始し、毎秒20万サンプルの頻度を示します。プロファイラーは15秒間動作し、100万サンプルを提供します。すべて問題ないようです。少なくとも手ごわいエラーメッセージはありません。しかし、実際に取得した頻度はどれくらいですか？毎秒70,000サンプルしかないことがわかります。何が悪かったのか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コマンドの出力を見てみましょう</font></font><code>dmesg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs">[<span class="hljs-number">84430.412898</span>] perf: interrupt took too long (<span class="hljs-number">1783</span> &gt; <span class="hljs-number">200</span>), lowering kernel.perf_event_max_sample_rate to <span class="hljs-number">89700</span><font></font>
...<font></font>
[<span class="hljs-number">84431.618452</span>] perf: interrupt took too long (<span class="hljs-number">2229</span> &gt; <span class="hljs-number">2228</span>), lowering kernel.perf_event_max_sample_rate to <span class="hljs-number">71700</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはLinuxカーネルの出力です。</font><font style="vertical-align: inherit;">サンプリングの頻度が高すぎ、時間がかかりすぎるため、カーネルが周波数を下げることがわかりました。</font><font style="vertical-align: inherit;">カーネルの別のハンドルを外す必要があることがわかりました。これは呼び出され</font></font><code>kernel.perf_cpu_time_max_percent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、カーネルがperfからの割り込みに費やすことができる時間を制御します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
毎秒20万サンプルのサンプリング周波数を注文します。</font><font style="vertical-align: inherit;">15秒後、300万サンプル-1秒あたり20万サンプルを取得します。</font></font><br>
<br>
<pre><code class="javascript hljs">$ PERF_RECORD_FREQ=<span class="hljs-number">200000</span> ./bin/perf-java-record-stack PID<font></font>
Recording events <span class="hljs-keyword">for</span> <span class="hljs-number">15</span> seconds ...<font></font>
...<font></font>
[ perf record: Captured ... (<span class="hljs-number">2.961</span><span class="hljs-number">.252</span> samples) ]
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、プロファイルを見てみましょう。</font><font style="vertical-align: inherit;">ローンチ</font></font><code>perf script</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="javascript hljs">$ perf script<font></font>
...<font></font>
java ... native_write_msr (<span class="hljs-regexp">/.../</span>vmlinux)<font></font>
java ... Loop2.main (<span class="hljs-regexp">/tmp/</span>perf<span class="hljs-number">-29621.</span>map)<font></font>
java ... native_write_msr (<span class="hljs-regexp">/.../</span>vmlinux)<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
奇妙な関数とvmlinux実行可能モジュール-Linuxカーネルが表示されます。</font><font style="vertical-align: inherit;">これは間違いなく私たちのコードではありません。</font><font style="vertical-align: inherit;">どうした？</font><font style="vertical-align: inherit;">頻度が非常に高いため、カーネルコードがサンプルに分類され始めました。</font><font style="vertical-align: inherit;">つまり、頻度を高くするほど、コードではなくLinuxカーネルに関連しないサンプルが多くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デッドエンド。</font></font><br>
<br>
<a name="8"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは（明示的に）ハードウェアPMU / PEBSイベントを使用します </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、PMU / PEBSハードウェアテクノロジー-Performance Monitoring Unit、Precise Event Based Samplingを使用してみることにしました。</font><font style="vertical-align: inherit;">イベントが所定の回数発生したという通知を受け取ることができます。</font><font style="vertical-align: inherit;">これを「期間」と呼びます。</font><font style="vertical-align: inherit;">たとえば、プロセッサによる20番目の各命令の実行に関する通知を受け取る場合があります。</font><font style="vertical-align: inherit;">例を見てみましょう。</font><font style="vertical-align: inherit;">ここでxor命令を実行すると、PMUカウンターは値18を取得します。</font><font style="vertical-align: inherit;">次に、mov命令が来ます-カウンターは19です。</font><font style="vertical-align: inherit;">そして次の命令</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add％r14、％r13</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、PMUは「ホット」と表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、新しいサイクルが始まります。それが実行</font></font><code>inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">されます-PMUが1にリセットされます。サイクルのさらにいくつかの反復が行われます。</font><font style="vertical-align: inherit;">その結果、私たちは指示に精通します</font></font><code>mov</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、PMUは19をスナップします。次のaddステートメントで、再びホットとマークします。リストを参照してください：</font></font><br>
<br>
<pre><code class="plaintext hljs">mov aaa, bbbb<font></font>
xor    %rdx, %rdx<font></font>
L_START:<font></font>
mov    $0x0(%rbx, %rdx),%r14<font></font>
add    %r14, %r13  ;  (PMU       "")<font></font>
cmp    %rdx,100000000<font></font>
jne    L_START</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
奇妙なことに気付かないのですか？ 5つの命令のサイクルですが、毎回同じ命令をホットとしてマークします。明らかに、これは真実ではありません：すべての指示は熱いです。彼らも時間を費やし、1つだけマークします。事実は、繰り返しの期間と命令数のカウンターの間に共通の因数4があるということです。4回の繰り返しごとに、同じ命令を「ホット」としてマークすることがわかります。この動作を回避するには、ループの反復回数とカウンター自体の間の公約数の確率が最小になる期間として、数値を選択する必要があります。理想的には、期間は素数、つまり自分とユニットでのみ共有してください。上記の例では、23に等しい期間を選択する必要があります。次に、このサイクルのすべての命令を「ホット」として均等にマークします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PMU / PEBSテクノロジーは、少なくとも2009年以降、最新の形式でサポートされています。つまり、ほとんどすべてのコンピューターで使用できます。</font><font style="vertical-align: inherit;">明示的に適用するには、スクリプトを変更してみましょう</font></font><code>perf-java-record-stack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">フラグ</font></font><code>-F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font><code>-e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">置き換え</font><font style="vertical-align: inherit;">ます。これは、PMU / PEBSの使用を明示的に指定します。</font></font><br>
<br>
<pre><code class="javascript hljs">...<font></font>
sudo perf record -F $PERF_RECORD_FREQ ...<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スクリプトを変換する： </font></font><br>
<br>
<pre><code class="javascript hljs">...<font></font>
sudo perf record -e cycles –c <span class="hljs-number">10007</span> ...<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたはすでに、期間が持つべき特性を知っています-私たちは素数が必要です。私たちのケースでは、これは10007の期間になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変更されたperf-java-record-stackスクリプト</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">起動し、15秒で450万サンプルを受信しました。1秒あたり約30万サンプル、3μsごとに1サンプルです。つまり、プロファイリングされたコードを1回実行すると、100μsで33個のサンプルが収集されます。この頻度では、プロファイル収集時間の合計はわずか30秒です。一杯のコーヒーも飲まないでください！実際には、すべてがもう少し複雑です。コードが1秒に1回ではなく、5秒に1回実行を開始するとどうなりますか？その後、プロファイリングの時間は最大2.5分に延長されます。これもかなりまともな結果です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、30秒で、すべての研究ニーズを完全にカバーするプロファイルを取得できます。勝利？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、汚いトリックの感覚は私を残しませんでした。</font><font style="vertical-align: inherit;">コードが5秒ごとに実行される状況に戻りましょう。</font><font style="vertical-align: inherit;">その後、プロファイリングには150秒かかり、その間に約4500万のサンプルが収集されます。</font><font style="vertical-align: inherit;">これらのうち、必要なのは1000、つまり収集されたデータの0.002％だけです。</font><font style="vertical-align: inherit;">それ以外はすべてガベージです。これは他のツールの処理を遅くし、オーバーヘッドを追加します。</font><font style="vertical-align: inherit;">はい、問題は解決されましたが、額、汚い、鈍い力で解決されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてその夜、perfの助けを借りて最初にこのような詳細なプロファイルを取得したとき、夢を見ました。</font><font style="vertical-align: inherit;">私は仕事から帰って考えていましたが、鉄がプロファイル自体を組み立てることができて、微細構造とマイクロ秒の精度までさえできれば、結果を分析するだけでいいでしょう。</font><font style="vertical-align: inherit;">私の夢は叶うの？</font><font style="vertical-align: inherit;">どう思いますか？</font></font><br>
<br>
<a name="9"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">短い要約：</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perfを使用してJavaアプリケーションのプロファイルを作成するには、perf-map-agentプロジェクトのスクリプトを使用して、シンボルに関する情報を含むファイルを生成する必要があります</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードのホットセクションだけでなくスタックに関する情報も収集するには、-XX：+ PreserveFramePointerフラグを指定して仮想マシンを実行する必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプリング頻度を増やしたい場合は、sysctl'iとkernel.perf_cpu_time_max_percentおよびkernel.perf_event_max_sample_rateに注意する必要があります。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションに関連しないカーネルからのサンプルがプロファイルに入り始めた場合は、PMU / PEBS期間を明示的に指定することを検討する必要があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事（およびそれに続く部分）は、テキスト形式で改造されたレポートの筆記録です。</font><font style="vertical-align: inherit;">プロファイリングについて読むだけでなく、聞きたい場合は</font><font style="vertical-align: inherit;">、プレゼンテーションへの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja466701/index.html">Let's Encryptはドメインの約30％に対応</a></li>
<li><a href="../ja466705/index.html">Android向けVivaldi Beta-リアルブラウザ</a></li>
<li><a href="../ja466709/index.html">モノリシックなUnixライクなOSの開発-Cライブラリ（2）</a></li>
<li><a href="../ja466711/index.html">脆弱性DaOfficeがソーシャルネットワークから任意のユーザーを削除することを許可</a></li>
<li><a href="../ja466713/index.html">1Cで外付け部品の技術を守らないことは可能ですか？または、1Cを使用して同僚を祝福する方法は？</a></li>
<li><a href="../ja466721/index.html">[エカテリンバーグ、発表] java.ural.Meetup @ 3-java.ural.Meetup @ 2からの3番目のJava mitap +ビデオレポートの発表</a></li>
<li><a href="../ja466723/index.html">Apple Text Broadcast-2019年9月10日</a></li>
<li><a href="../ja466725/index.html">ダガー2は初級（パート1）</a></li>
<li><a href="../ja466727/index.html">怠惰なアップグレード：PostgreSQL 12がパフォーマンスを向上させる方法</a></li>
<li><a href="../ja466729/index.html">本「データマイニング。Facebook、Twitter、LinkedIn、Instagram、GitHubから情報を取得する»</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>