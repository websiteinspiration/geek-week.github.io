<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋 🚾 🐙 SQLインデックスマネージャー-インデックスを最適化および維持するための無料ツール 👶🏾 🌾 🏂🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="長年SQL Server DBAとして働いており、サーバー管理を行った後、パフォーマンスを最適化しました。一般的に、私は自由な時間に宇宙と私たちの同僚のために役立つ何かをしたいと思っていました。その結果、SQL ServerとAzure向けの小さなオープンソースインデックスメンテナンスツールが手に入...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SQLインデックスマネージャー-インデックスを最適化および維持するための無料ツール</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459914/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長年SQL Server DBAとして働いており、サーバー管理を行った後、パフォーマンスを最適化しました。</font><font style="vertical-align: inherit;">一般的に、私は自由な時間に宇宙と私たちの同僚のために役立つ何かをしたいと思っていました。</font><font style="vertical-align: inherit;">その結果、</font><font style="vertical-align: inherit;">SQL ServerとAzure向けの</font><font style="vertical-align: inherit;">小さな</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オープンソース</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスメンテナンス</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ツール</font></a><font style="vertical-align: inherit;">が手に入りました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jw/8s/vk/jw8svkqqg0ybvtdgt1cdoiulxsm.png" alt="SQLインデックスマネージャー"><br>
<br>
<a name="habracut"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考え</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
優先順位に取り組むときに、人は指タイプのバッテリーに似ている場合があります-モチベーションチャージのフラッシュが1つだけあり、それだけです。そして最近まで、私はこの生命の観察の例外ではありませんでした。自分で何かを作成するためのアイデアをよく見かけましたが、優先順位が変更され、何も最後までもたらされませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQL Server、MySQL、およびOracleデータベースの開発と管理のためのソフトウェアの作成に携わっていたハリコフの会社であるDevartの仕事によって、私の動機と専門能力の開発にかなり強い影響がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らに来る前は、自分の製品を作成するための詳細についてほとんど考えていませんでしたが、その過程でSQL Serverの内部構造について多くの知識を得ました。 1年以上にわたって製品ラインのメタデータリクエストを最適化してきたため、市場でどの機能が他のどの機能よりも需要が高いかを徐々に理解し始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ある段階で、新しいニッチな製品を作るというアイデアが生まれましたが、事情により、このアイデアはうまくいきませんでした。当時、新しいプロジェクトでは、コアビジネスを損なうことなく、社内に十分な空きリソースが十分にありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに新しい場所で働いて自分でプロジェクトをやろうとしたとき、彼は常にいくつかの妥協をしなければなりませんでした。</font><font style="vertical-align: inherit;">大きな製品に機能を満載にするという当初のアイデアはすぐに機能しなくなり、次第に別の方向に変わりました-計画された機能を個別のミニツールに分割し、互いに独立して実装することでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、</font><font style="vertical-align: inherit;">SQL ServerとAzure向けの無料のインデックスメンテナンスツール</font><font style="vertical-align: inherit;">である</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL Index Managerが</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">誕生しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">主なアイデアは、RedGateとDevartから市販の代替品をベースにして、それらの機能を改善しようとすることでした。</font><font style="vertical-align: inherit;">初心者と経験豊富なユーザーの両方に、インデックスを便利に分析および保守する機能を提供するため。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
言い換えれば、すべてが常にシンプルに聞こえます...私は1つを取り、いくつかの動機付けのvidosikを見て、ラックに立ち、クールな製品を作り始めました。ただし、sys.dm_db_index_physical_statsシステムテーブル関数を使用する際には多くの落とし穴があり、インデックスの断片化に関する関連情報を取得できる唯一の場所であるため、実際にはすべてがバラバラだとは限りません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発の最初の日から、標準的なスキームの間に筋道をたどり、競合するアプリケーションの作業のデバッグ済みのロジックをコピーすると同時に、少しギャグを追加する絶好の機会でした。しかし、メタデータの要求を分析した後、私はより最適化された何かをしたかったのです。それは、大企業の官僚主義のために、彼らの製品には決して現れなかったでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RedGate SQLインデックスマネージャー（1.1.9.1378-$ 155）を分析すると、アプリケーションが非常にシンプルなアプローチを使用していることがわかります。1つのクエリでユーザーテーブルとビューのリストを取得し、2番目のクエリの後に、選択したデータベース内のすべてのインデックスのリストが返されます。</font></font><br>
<br>
<pre><code class="1c hljs">SELECT objects.name AS tableOrViewName<font></font>
     , objects.object_id AS tableOrViewId<font></font>
     , schemas.name AS schemaName<font></font>
     , CAST(ISNULL(lobs.NumLobs, <span class="hljs-number">0</span>) AS BIT) AS ContainsLobs<font></font>
     , o.is_memory_optimized<font></font>
FROM sys.objects AS objects<font></font>
JOIN sys.schemas AS schemas ON schemas.schema_id = objects.schema_id<font></font>
LEFT JOIN (<font></font>
    SELECT object_id<font></font>
         , COUNT(*) AS NumLobs<font></font>
    FROM sys.columns WITH (NOLOCK)<font></font>
    WHERE system_type_id IN (<span class="hljs-number">34</span>, <span class="hljs-number">35</span>, <span class="hljs-number">99</span>)<font></font>
        OR max_length = -<span class="hljs-number">1</span><font></font>
    GROUP BY object_id<font></font>
) AS lobs ON objects.object_id = lobs.object_id<font></font>
LEFT JOIN sys.tables AS o ON o.object_id = objects.object_id<font></font>
WHERE objects.type = 'U'<font></font>
    OR objects.type = 'V'<font></font>
<font></font>
SELECT i.object_id AS tableOrViewId<font></font>
     , i.name AS indexName<font></font>
     , i.index_id AS indexId<font></font>
     , i.allow_page_locks AS allowPageLocks<font></font>
     , p.partition_number AS partitionNumber<font></font>
     , CAST((c.numPartitions - <span class="hljs-number">1</span>) AS BIT) AS belongsToPartitionedIndex<font></font>
FROM sys.indexes AS i<font></font>
JOIN sys.partitions AS p ON p.index_id = i.index_id<font></font>
                        AND p.object_id = i.object_id<font></font>
JOIN (<font></font>
    SELECT COUNT(*) AS numPartitions<font></font>
         , object_id<font></font>
         , index_id<font></font>
    FROM sys.partitions<font></font>
    GROUP BY object_id<font></font>
           , index_id<font></font>
) AS c ON c.index_id = i.index_id<font></font>
      AND c.object_id = i.object_id<font></font>
WHERE i.index_id &gt; <span class="hljs-number">0</span> -- ignore heaps<font></font>
    AND i.is_disabled = <span class="hljs-number">0</span>
    AND i.is_hypothetical = <span class="hljs-number">0</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ループで、インデックスのセクションごとに、サイズと断片化のレベルを決定するためのリクエストが送信されます。</font><font style="vertical-align: inherit;">スキャンの最後に、エントリのしきい値よりも小さいインデックスは、クライアントで破棄されます。</font></font><br>
<br>
<pre><code class="1c hljs">EXEC sp_executesql N'<font></font>
SELECT index_id, avg_fragmentation_in_percent, page_count<font></font>
FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)'<font></font>
    , N'@databaseId int,@objectId int,@indexId int,@partitionNr int'<font></font>
    , @databaseId = <span class="hljs-number">7</span>, @objectId = <span class="hljs-number">2133582639</span>, @indexId = <span class="hljs-number">1</span>, @partitionNr = <span class="hljs-number">1</span><font></font>
<font></font>
EXEC sp_executesql N'<font></font>
SELECT index_id, avg_fragmentation_in_percent, page_count<font></font>
FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)'<font></font>
    , N'@databaseId int,@objectId int,@indexId int,@partitionNr int'<font></font>
    , @databaseId = <span class="hljs-number">7</span>, @objectId = <span class="hljs-number">2133582639</span>, @indexId = <span class="hljs-number">2</span>, @partitionNr = <span class="hljs-number">1</span><font></font>
<font></font>
EXEC sp_executesql N'<font></font>
SELECT index_id, avg_fragmentation_in_percent, page_count<font></font>
FROM sys.dm_db_index_physical_stats(@databaseId, @objectId, @indexId, @partitionNr, NULL)'<font></font>
    , N'@databaseId int,@objectId int,@indexId int,@partitionNr int'<font></font>
    , @databaseId = <span class="hljs-number">7</span>, @objectId = <span class="hljs-number">2133582639</span>, @indexId = <span class="hljs-number">3</span>, @partitionNr = <span class="hljs-number">1</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプリケーションのロジックを分析すると、多くの欠点が見つかります。たとえば、ささいなことで問題が見つかった場合、リクエストを送信する前に、現在のセクションにスキャンから空のセクションを除外する行が含まれているかどうかのチェックは行われません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、この問題は別の側面で最も深刻です。サーバーへの要求の数は、sys.partitionsからの行の総数とほぼ等しくなります。実際のデータベースには数万のセクションが含まれる可能性があるという事実を考えると、このニュアンスはサーバーへの同様のリクエストを膨大な数にする可能性があります。データベースがリモートである状況では、最も単純なリクエストであっても、それぞれのネットワーク遅延が増加するため、スキャン時間がさらに長くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RedGateとは異なり、Devartで開発された同様の製品-dbForge Index Manager for SQL Server（1.10.38-$ 99）は、1つの大きなクエリで情報を受け取り、すべてをクライアントに表示します。</font></font><br>
<br>
<pre><code class="1c hljs">SELECT SCHEMA_NAME(o.[schema_id]) AS [schema_name]<font></font>
     , o.name AS parent_name<font></font>
     , o.[type] AS parent_type<font></font>
     , i.name<font></font>
     , i.type_desc<font></font>
     , s.avg_fragmentation_in_percent<font></font>
     , s.page_count<font></font>
     , p.partition_number<font></font>
     , p.[rows]<font></font>
     , ISNULL(lob.is_lob_legacy, <span class="hljs-number">0</span>) AS is_lob_legacy<font></font>
     , ISNULL(lob.is_lob, <span class="hljs-number">0</span>) AS is_lob<font></font>
     , CASE WHEN ds.[type] = 'PS' THEN <span class="hljs-number">1</span> ELSE <span class="hljs-number">0</span> END AS is_partitioned<font></font>
FROM sys.dm_db_index_physical_stats(DB_ID(), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>) s<font></font>
JOIN sys.partitions p ON s.[object_id] = p.[object_id]<font></font>
                     AND s.index_id = p.index_id<font></font>
                     AND s.partition_number = p.partition_number<font></font>
JOIN sys.indexes i ON i.[object_id] = s.[object_id]<font></font>
                  AND i.index_id = s.index_id<font></font>
LEFT JOIN (<font></font>
    SELECT c.[object_id]<font></font>
         , index_id = ISNULL(i.index_id, <span class="hljs-number">1</span>)<font></font>
         , is_lob_legacy = MAX(CASE WHEN c.system_type_id IN (<span class="hljs-number">34</span>, <span class="hljs-number">35</span>, <span class="hljs-number">99</span>) THEN <span class="hljs-number">1</span> END)<font></font>
         , is_lob = MAX(CASE WHEN c.max_length = -<span class="hljs-number">1</span> THEN <span class="hljs-number">1</span> END)<font></font>
    FROM sys.columns c<font></font>
    LEFT JOIN sys.index_columns i ON c.[object_id] = i.[object_id]<font></font>
                                 AND c.column_id = i.column_id<font></font>
                                 AND i.index_id &gt; <span class="hljs-number">0</span>
    WHERE c.system_type_id IN (<span class="hljs-number">34</span>, <span class="hljs-number">35</span>, <span class="hljs-number">99</span>)<font></font>
        OR c.max_length = -<span class="hljs-number">1</span><font></font>
    GROUP BY c.[object_id], i.index_id<font></font>
) lob ON lob.[object_id] = i.[object_id]<font></font>
     AND lob.index_id = i.index_id<font></font>
JOIN sys.objects o ON o.[object_id] = i.[object_id]<font></font>
JOIN sys.data_spaces ds ON i.data_space_id = ds.data_space_id<font></font>
WHERE i.[type] IN (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<font></font>
    AND i.is_disabled = <span class="hljs-number">0</span>
    AND i.is_hypothetical = <span class="hljs-number">0</span>
    AND s.index_level = <span class="hljs-number">0</span><font></font>
    AND s.alloc_unit_type_desc = 'IN_ROW_DATA'<font></font>
    AND o.[type] IN ('U', 'V')</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
競合製品の同じタイプのクエリのベールに関する主な問題をなんとか取り除くことができましたが、この実装の欠点は、明らかに不要なインデックスのスキャンを制限できる追加のパラメーターがsys.dm_db_index_physical_stats関数に渡されないことです。実際、これにより、システム内のすべてのインデックスに関する情報が取得され、スキャン段階で追加のディスク負荷が発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sys.dm_db_index_physical_statsから取得したデータはバッファープールに永続的にキャッシュされないため、インデックスの断片化に関する情報を取得する際の物理的な読み取りを最小限に抑えることが、開発中の優先タスクの1つであったことに注意することが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの実験の後、スキャンを2つの部分に分割して、両方のアプローチを組み合わせることがわかりました。</font><font style="vertical-align: inherit;">まず、1つの大きなクエリで、セクションのサイズが決定され、フィルタリング範囲にないセクションが事前にフィルタリングされます。</font></font><br>
<br>
<pre><code class="1c hljs">INSERT INTO <span class="hljs-meta">#AllocationUnits (ContainerID, ReservedPages, UsedPages)</span><font></font>
SELECT [container_id]<font></font>
     , SUM([total_pages])<font></font>
     , SUM([used_pages])<font></font>
FROM sys.allocation_units WITH(NOLOCK)<font></font>
GROUP BY [container_id]<font></font>
HAVING SUM([total_pages]) BETWEEN @MinIndexSize AND @MaxIndexSize</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、空のインデックスからの不要な読み取り操作を回避するために、データを含むセクションのみを取得します。</font></font><br>
<br>
<pre><code class="1c hljs">SELECT [object_id]<font></font>
     , [index_id]<font></font>
     , [partition_id]<font></font>
     , [partition_number]<font></font>
     , [rows]<font></font>
     , [data_compression]<font></font>
INTO <span class="hljs-meta">#Partitions</span><font></font>
FROM sys.partitions WITH(NOLOCK)<font></font>
WHERE [object_id] &gt; <span class="hljs-number">255</span>
    AND [rows] &gt; <span class="hljs-number">0</span>
    AND [object_id] NOT IN (SELECT * FROM <span class="hljs-meta">#ExcludeList)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
設定に応じて、ユーザーが分析したいタイプのインデックスのみが取得されます（ヒープ、クラスター/非クラスターインデックス、および列インジケーターの操作がサポートされます）。</font></font><br>
<br>
<pre><code class="1c hljs">INSERT INTO <span class="hljs-meta">#Indexes</span><font></font>
SELECT ObjectID         = i.[object_id]<font></font>
     , IndexID          = i.index_id<font></font>
     , IndexName        = i.[name]<font></font>
     , PagesCount       = a.ReservedPages<font></font>
     , UnusedPagesCount = a.ReservedPages - a.UsedPages<font></font>
     , PartitionNumber  = p.[partition_number]<font></font>
     , RowsCount        = ISNULL(p.[rows], <span class="hljs-number">0</span>)<font></font>
     , IndexType        = i.[type]<font></font>
     , IsAllowPageLocks = i.[allow_page_locks]<font></font>
     , DataSpaceID      = i.[data_space_id]<font></font>
     , DataCompression  = p.[data_compression]<font></font>
     , IsUnique         = i.[is_unique]<font></font>
     , IsPK             = i.[is_primary_key]<font></font>
     , FillFactorValue  = i.[fill_factor]<font></font>
     , IsFiltered       = i.[has_filter]<font></font>
FROM <span class="hljs-meta">#AllocationUnits a</span>
JOIN <span class="hljs-meta">#Partitions p ON a.ContainerID = p.[partition_id]</span><font></font>
JOIN sys.indexes i WITH(NOLOCK) ON i.[object_id] = p.[object_id]<font></font>
                               AND p.[index_id] = i.[index_id] <font></font>
WHERE i.[type] IN (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<font></font>
    AND i.[object_id] &gt; <span class="hljs-number">255</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、小さな魔法が始まります。すべての小さなインデックスについて、すべてのパラメーターの完全な指標を使用してsys.dm_db_index_physical_stats関数を繰り返し呼び出すことにより、断片化のレベルを決定します。</font></font><br>
<br>
<pre><code class="1c hljs">INSERT INTO <span class="hljs-meta">#Fragmentation (ObjectID, IndexID, PartitionNumber, Fragmentation)</span><font></font>
SELECT i.ObjectID<font></font>
     , i.IndexID<font></font>
     , i.PartitionNumber<font></font>
     , r.[avg_fragmentation_in_percent]<font></font>
FROM <span class="hljs-meta">#Indexes i</span><font></font>
CROSS APPLY sys.dm_db_index_physical_stats(@DBID, i.ObjectID, i.IndexID, i.PartitionNumber, 'LIMITED') r<font></font>
WHERE i.PagesCount &lt;= @PreDescribeSize<font></font>
    AND r.[index_level] = <span class="hljs-number">0</span><font></font>
    AND r.[alloc_unit_type_desc] = 'IN_ROW_DATA'<font></font>
    AND i.IndexType IN (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、すべての可能な情報をクライアントに返し、余分なデータを除外します。</font></font><br>
<br>
<pre><code class="1c hljs">SELECT i.ObjectID<font></font>
     , i.IndexID<font></font>
     , i.IndexName<font></font>
     , ObjectName       = o.[name]<font></font>
     , SchemaName       = s.[name]<font></font>
     , i.PagesCount<font></font>
     , i.UnusedPagesCount<font></font>
     , i.PartitionNumber<font></font>
     , i.RowsCount<font></font>
     , i.IndexType<font></font>
     , i.IsAllowPageLocks<font></font>
     , u.TotalWrites<font></font>
     , u.TotalReads<font></font>
     , u.TotalSeeks<font></font>
     , u.TotalScans<font></font>
     , u.TotalLookups<font></font>
     , u.LastUsage<font></font>
     , i.DataCompression<font></font>
     , f.Fragmentation<font></font>
     , IndexStats       = STATS_DATE(i.ObjectID, i.IndexID)<font></font>
     , IsLobLegacy      = ISNULL(lob.IsLobLegacy, <span class="hljs-number">0</span>)<font></font>
     , IsLob            = ISNULL(lob.IsLob, <span class="hljs-number">0</span>)<font></font>
     , IsSparse         = CAST(CASE WHEN p.ObjectID IS <span class="hljs-literal">NULL</span> THEN <span class="hljs-number">0</span> ELSE <span class="hljs-number">1</span> END AS BIT)<font></font>
     , IsPartitioned    = CAST(CASE WHEN dds.[data_space_id] IS NOT <span class="hljs-literal">NULL</span> THEN <span class="hljs-number">1</span> ELSE <span class="hljs-number">0</span> END AS BIT)<font></font>
     , FileGroupName    = fg.[name]<font></font>
     , i.IsUnique<font></font>
     , i.IsPK<font></font>
     , i.FillFactorValue<font></font>
     , i.IsFiltered<font></font>
     , a.IndexColumns<font></font>
     , a.IncludedColumns<font></font>
FROM <span class="hljs-meta">#Indexes i</span><font></font>
JOIN sys.objects o WITH(NOLOCK) ON o.[object_id] = i.ObjectID<font></font>
JOIN sys.schemas s WITH(NOLOCK) ON s.[schema_id] = o.[schema_id]<font></font>
LEFT JOIN <span class="hljs-meta">#AggColumns a ON a.ObjectID = i.ObjectID</span><font></font>
                       AND a.IndexID = i.IndexID<font></font>
LEFT JOIN <span class="hljs-meta">#Sparse p ON p.ObjectID = i.ObjectID</span>
LEFT JOIN <span class="hljs-meta">#Fragmentation f ON f.ObjectID = i.ObjectID</span><font></font>
                          AND f.IndexID = i.IndexID<font></font>
                          AND f.PartitionNumber = i.PartitionNumber<font></font>
LEFT JOIN (<font></font>
    SELECT ObjectID      = [object_id]<font></font>
         , IndexID       = [index_id]<font></font>
         , TotalWrites   = NULLIF([user_updates], <span class="hljs-number">0</span>)<font></font>
         , TotalReads    = NULLIF([user_seeks] + [user_scans] + [user_lookups], <span class="hljs-number">0</span>)<font></font>
         , TotalSeeks    = NULLIF([user_seeks], <span class="hljs-number">0</span>)<font></font>
         , TotalScans    = NULLIF([user_scans], <span class="hljs-number">0</span>)<font></font>
         , TotalLookups  = NULLIF([user_lookups], <span class="hljs-number">0</span>)<font></font>
         , LastUsage     = (<font></font>
                                SELECT MAX(dt)<font></font>
                                FROM (<font></font>
                                    VALUES ([last_user_seek])<font></font>
                                         , ([last_user_scan])<font></font>
                                         , ([last_user_lookup])<font></font>
                                         , ([last_user_update])<font></font>
                                ) t(dt)<font></font>
                           )<font></font>
    FROM sys.dm_db_index_usage_stats WITH(NOLOCK)<font></font>
    WHERE [database_id] = @DBID<font></font>
) u ON i.ObjectID = u.ObjectID<font></font>
   AND i.IndexID = u.IndexID<font></font>
LEFT JOIN <span class="hljs-meta">#Lob lob ON lob.ObjectID = i.ObjectID</span><font></font>
                  AND lob.IndexID = i.IndexID<font></font>
LEFT JOIN sys.destination_data_spaces dds WITH(NOLOCK) ON i.DataSpaceID = dds.[partition_scheme_id]<font></font>
                                                      AND i.PartitionNumber = dds.[destination_id]<font></font>
JOIN sys.filegroups fg WITH(NOLOCK) ON ISNULL(dds.[data_space_id], i.DataSpaceID) = fg.[data_space_id] <font></font>
WHERE o.[type] IN ('V', 'U')<font></font>
    AND (<font></font>
            f.Fragmentation &gt;= @Fragmentation<font></font>
        OR<font></font>
            i.PagesCount &gt; @PreDescribeSize<font></font>
        OR<font></font>
            i.IndexType IN (<span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<font></font>
    )</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この後、ポイントクエリは大きなインデックスの断片化のレベルを決定します。</font></font><br>
<br>
<pre><code class="1c hljs">EXEC sp_executesql N'<font></font>
DECLARE @DBID INT = DB_ID()<font></font>
SELECT [avg_fragmentation_in_percent]<font></font>
FROM sys.dm_db_index_physical_stats(@DBID, @ObjectID, @IndexID, @PartitionNumber, ''LIMITED'')<font></font>
WHERE [index_level] = 0<font></font>
    AND [alloc_unit_type_desc] = ''IN_ROW_DATA'''<font></font>
    , N'@ObjectID int,@IndexID int,@PartitionNumber int'<font></font>
    , @ObjectId = <span class="hljs-number">1044198770</span>, @IndexId = <span class="hljs-number">1</span>, @PartitionNumber = <span class="hljs-number">1</span><font></font>
<font></font>
EXEC sp_executesql N'<font></font>
DECLARE @DBID INT = DB_ID()<font></font>
SELECT [avg_fragmentation_in_percent]<font></font>
FROM sys.dm_db_index_physical_stats(@DBID, @ObjectID, @IndexID, @PartitionNumber, ''LIMITED'')<font></font>
WHERE [index_level] = 0<font></font>
    AND [alloc_unit_type_desc] = ''IN_ROW_DATA'''<font></font>
    , N'@ObjectID int,@IndexID int,@PartitionNumber int'<font></font>
    , @ObjectId = <span class="hljs-number">1552724584</span>, @IndexId = <span class="hljs-number">0</span>, @PartitionNumber = <span class="hljs-number">1</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチにより、クエリを生成するときに、競合他社のアプリケーションで発生したスキャンパフォーマンスの問題を解決することができました。</font><font style="vertical-align: inherit;">これは完成するかもしれませんが、開発の過程で、製品の適用範囲を拡大できる新しいアイデアが徐々に現れました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、WAIT_AT_LOW_PRIORITYでの作業のサポートが実装されていたため、DATA_COMPRESSIONおよびFILL_FACTORを使用してインデックスを再構築できるようになりました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kd/em/xj/kdemxjo8sj0hxa4y_omvv3dph6a.png" alt="SQLインデックスマネージャーの設定"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプリケーションは、以前は計画されていなかった機能のcolumntorへのサービスなど、少しばかり大きくなりました。</font></font><br>
<br>
<pre><code class="1c hljs">SELECT *<font></font>
FROM (<font></font>
    SELECT IndexID          = [index_id]<font></font>
         , PartitionNumber  = [partition_number]<font></font>
         , PagesCount       = SUM([size_in_bytes]) / <span class="hljs-number">8192</span>
         , UnusedPagesCount = ISNULL(SUM(CASE WHEN [state] = <span class="hljs-number">1</span> THEN [size_in_bytes] END), <span class="hljs-number">0</span>) / <span class="hljs-number">8192</span>
         , Fragmentation    = CAST(ISNULL(SUM(CASE WHEN [state] = <span class="hljs-number">1</span> THEN [size_in_bytes] END), <span class="hljs-number">0</span>)<font></font>
                            * <span class="hljs-number">100</span>. / SUM([size_in_bytes]) AS FLOAT)<font></font>
    FROM sys.fn_column_store_row_groups(@ObjectID)<font></font>
    GROUP BY [index_id]<font></font>
           , [partition_number]<font></font>
) t<font></font>
WHERE Fragmentation &gt;= @Fragmentation<font></font>
    AND PagesCount BETWEEN @MinIndexSize AND @MaxIndexSize</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、dm_db_missing_indexからの情報に基づいて非クラスター化インデックスを作成する機能：</font></font><br>
<br>
<pre><code class="1c hljs">SELECT ObjectID     = d.[object_id]<font></font>
     , UserImpact   = gs.[avg_user_impact]<font></font>
     , TotalReads   = gs.[user_seeks] + gs.[user_scans]<font></font>
     , TotalSeeks   = gs.[user_seeks]<font></font>
     , TotalScans   = gs.[user_scans]<font></font>
     , LastUsage    = ISNULL(gs.[last_user_scan], gs.[last_user_seek])<font></font>
     , IndexColumns =<font></font>
                CASE<font></font>
                    WHEN d.[equality_columns] IS NOT <span class="hljs-literal">NULL</span> AND d.[inequality_columns] IS NOT <span class="hljs-literal">NULL</span><font></font>
                        THEN d.[equality_columns] + ', ' + d.[inequality_columns]<font></font>
                    WHEN d.[equality_columns] IS NOT <span class="hljs-literal">NULL</span> AND d.[inequality_columns] IS <span class="hljs-literal">NULL</span><font></font>
                        THEN d.[equality_columns]<font></font>
                    ELSE d.[inequality_columns]<font></font>
                END<font></font>
     , IncludedColumns = d.[included_columns]<font></font>
FROM sys.dm_db_missing_index_groups g WITH(NOLOCK)<font></font>
JOIN sys.dm_db_missing_index_group_stats gs WITH(NOLOCK) ON gs.[group_handle] = g.[index_group_handle]<font></font>
JOIN sys.dm_db_missing_index_details d WITH(NOLOCK) ON g.[index_handle] = d.[index_handle]<font></font>
WHERE d.[database_id] = DB_ID()</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
積極的な開発フェーズの6か月後、この製品を開発し続けたいので、計画がそこで終わらないことを嬉しく思います。</font><font style="vertical-align: inherit;">次のステップは、重複または未使用のインデックスを検索する機能を追加することと、SQL Server内で統計を処理するための本格的なサポートを実装することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、多くの有料ソリューションが市場にあるという事実に基づいて、無料のポジショニング、より最適化されたメタデータの説明、および誰かにとってさまざまな便利な小さなものの存在により、この製品は日常業務で間違いなく役立つと信じています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションの現在のバージョンは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHubから</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダウンロードでき</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><b><font style="vertical-align: inherit;">ます</font></b></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ソースがあります。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja459898/index.html">計画は経済に戻った</a></li>
<li><a href="../ja459900/index.html">Seabornライブラリを使用してDataFrameから列を視覚化する</a></li>
<li><a href="../ja459902/index.html">初心者のためのロシアの地域のインタラクティブマップ。私がした、あなたがしてはいけない間違い</a></li>
<li><a href="../ja459906/index.html">Tic Tac Toeパート3：コマンドストレージを使用した元に戻す/やり直し</a></li>
<li><a href="../ja459910/index.html">状況：企業は音声アシスタント向けのサービスの開発を急いでいません-リスクは何ですか</a></li>
<li><a href="../ja459918/index.html">pwnable.kr 03による問題解決-bof。スタックでのバッファオーバーフロー</a></li>
<li><a href="../ja459920/index.html">「非通信定理」を回避する方法は？時空を超えた情報伝達</a></li>
<li><a href="../ja459922/index.html">ベアリングの振動診断中に振動センサーの信号から高周波ノイズを除去</a></li>
<li><a href="../ja459924/index.html">Reactアプリケーションのテストの全サイクル。Auto.ruを報告する</a></li>
<li><a href="../ja459928/index.html">学生のモバイルアプリ開発への道のり</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>