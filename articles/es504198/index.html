<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÖüèæ ü¶ã ‚ò∏Ô∏è SwiftUI en los estantes: Animaci√≥n. Parte 1 üõ°Ô∏è üçª üßúüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente me encontr√© con un nuevo art√≠culo en el que los chicos intentaron reproducir un concepto interesante usando SwiftUI. 
 
 
 
 Esto es lo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SwiftUI en los estantes: Animaci√≥n. Parte 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504198/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recientemente me encontr√© con un nuevo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el que los chicos intentaron reproducir un concepto interesante usando SwiftUI. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto </font><font style="vertical-align: inherit;">es lo que hicieron: </font><font style="vertical-align: inherit;">estudi√© su c√≥digo con inter√©s, pero experiment√© cierta frustraci√≥n. No, no en el sentido de que hicieron algo mal, para nada. Simplemente no aprend√≠ de su c√≥digo pr√°cticamente nada nuevo. Su implementaci√≥n es m√°s sobre Combinar que sobre animaci√≥n. Y decid√≠ </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">construir mi lunopark</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para escribir mi art√≠culo sobre animaci√≥n en SwiftUI, implementando aproximadamente el mismo concepto, pero usando el 100% de las capacidades de la animaci√≥n incorporada, incluso si no es muy efectivo. Para estudiar, hasta el final. Para experimentar, as√≠ que con un brillo :) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto es lo que obtuve:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, para una divulgaci√≥n completa del tema, tuve que hablar con algunos detalles sobre los conceptos b√°sicos. El texto result√≥ ser voluminoso y, por lo tanto, lo divid√≠ en dos art√≠culos. Aqu√≠ est√° la primera parte, m√°s bien, un tutorial sobre animaci√≥n en general, no directamente relacionado con la animaci√≥n del arco iris, que analizar√© en detalle en el pr√≥ximo art√≠culo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este art√≠culo, hablar√© sobre los conceptos b√°sicos, sin los cuales puede confundirse f√°cilmente en ejemplos m√°s complejos. Gran parte de lo que hablar√©, de una forma u otra, ya se ha descrito en art√≠culos en ingl√©s como esta serie ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Yo, por otro lado, no me concentr√© tanto en enumerar las formas de trabajar como en describir c√≥mo funciona exactamente esto. </font><font style="vertical-align: inherit;">Y como siempre, experiment√© mucho, as√≠ que me apresur√© a compartir los resultados m√°s interesantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
advertencia: debajo del gato hay muchas im√°genes y animaciones gif.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TLDR</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El proyecto est√° disponible en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Puede ver el resultado actual con la animaci√≥n del arco iris en TransitionRainbowView (), pero no me apresurar√≠a en su lugar, pero esper√© el siguiente art√≠culo. </font><font style="vertical-align: inherit;">Adem√°s, al prepararlo, peino un poco el c√≥digo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este art√≠culo, discutiremos solo los conceptos b√°sicos y afectaremos solo los contenidos de la carpeta Bases.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introducci√≥n</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo admito, no iba a escribir este art√≠culo ahora. Ten√≠a un plan seg√∫n el cual se supon√≠a que un art√≠culo sobre animaci√≥n era el tercero o incluso el cuarto consecutivo. Sin embargo, no pude resistirme, realmente quer√≠a proporcionar un punto de vista alternativo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quiero hacer una reservaci√≥n de inmediato. No creo que se hayan cometido errores en el art√≠culo mencionado, o el enfoque utilizado es incorrecto. De ning√∫n modo. Construye un modelo de objeto del proceso (animaci√≥n) que, respondiendo a la se√±al recibida, comienza a hacer algo. Sin embargo, en cuanto a m√≠, este art√≠culo probablemente revela el trabajo con el marco Combine. S√≠, este marco es una parte importante de SwiftUI, pero se trata m√°s de estilo de reacci√≥n en general que de animaci√≥n.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mi opci√≥n ciertamente no es m√°s elegante, m√°s r√°pida y f√°cil de mantener. Sin embargo, revela mucho mejor lo que est√° bajo el cap√≥ de SwiftUI, y de hecho este fue el prop√≥sito del art√≠culo: descubrirlo primero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como dije en un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo anterior</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por SwiftUI, comenc√© mi inmersi√≥n en el mundo del desarrollo m√≥vil de inmediato con SwiftUI, ignorando UIKit. Esto, por supuesto, tiene un precio, pero hay ventajas. No estoy tratando de vivir en un nuevo monasterio de acuerdo con la antigua carta. Honestamente, todav√≠a no conozco ninguna carta, as√≠ que no tengo un rechazo a lo nuevo. Es por eso que este art√≠culo, me parece, puede ser valioso no solo para principiantes, como yo, sino tambi√©n para aquellos que estudian SwiftUI que ya tienen antecedentes en forma de desarrollo en UIKit. Me parece que muchas personas carecen de un aspecto fresco. No haga lo mismo, intente adaptar una nueva herramienta a los dibujos antiguos, pero cambie su visi√≥n de acuerdo con las nuevas posibilidades.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nosotros 1c-nicks pasamos por esto con "formas controladas". Este es un tipo de SwiftUI en el mundo de 1s, que sucedi√≥ hace m√°s de 10 a√±os. De hecho, la analog√≠a es bastante precisa, porque los formularios administrados son solo una nueva forma de dibujar una interfaz. Sin embargo, cambi√≥ por completo la interacci√≥n cliente-servidor de la aplicaci√≥n en su conjunto, y la imagen del mundo en la mente de los desarrolladores en particular. Esto no fue f√°cil, yo mismo no quise estudiarlo durante unos 5 a√±os, porque Pens√© que muchas de las oportunidades que se cortaban all√≠ eran simplemente necesarias para m√≠. Pero, como lo ha demostrado la pr√°ctica, la codificaci√≥n en formularios administrados no solo es posible, sino tambi√©n necesaria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, no hablemos m√°s de eso. </font><font style="vertical-align: inherit;">Obtuve una gu√≠a detallada e independiente que no tiene referencias u otros enlaces con el art√≠culo mencionado o el 1er pasado. </font><font style="vertical-align: inherit;">Paso a paso, profundizaremos en los detalles, caracter√≠sticas, principios y limitaciones. </font><font style="vertical-align: inherit;">Vamos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forma animada</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥mo funciona la animaci√≥n en general</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, la idea principal de la animaci√≥n es la transformaci√≥n de un cambio particular y discreto en un proceso continuo. Por ejemplo, el radio del c√≠rculo era de 100 unidades, se convirti√≥ en 50 unidades. Sin animaci√≥n, el cambio ocurrir√° instant√°neamente, con animaci√≥n, sin problemas. ¬øC√≥mo funciona? Muy simple. Para cambios suaves, necesitamos interpolar varios valores dentro del segmento "Fue ... se ha convertido". En el caso del radio, tendremos que dibujar varios c√≠rculos intermedios con un radio de 98 unidades, 95 unidades, 90 unidades ... 53 unidades y, finalmente, 50 unidades. SwiftUI puede hacer esto de manera f√°cil y natural, simplemente envuelva el c√≥digo que realiza este cambio conAnimation {...}. Parece m√°gico ... Hasta que quieras implementar algo un poco m√°s complicado que "hola mundo".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pasemos a los ejemplos. El objeto m√°s simple y m√°s comprensible para la animaci√≥n se considera animaci√≥n de formas. La forma (todav√≠a llamar√© a la estructura conforme al protocolo de forma de forma) en SwiftUI es una estructura con par√°metros que pueden ajustarse a estos l√≠mites. Aquellos. Es una estructura que tiene la funci√≥n cuerpo (en rect: CGRect) -&gt; Path. Todo lo que necesita el tiempo de ejecuci√≥n para dibujar este formulario es solicitar su esquema (el resultado de la funci√≥n es un objeto de tipo Path, de hecho, es una curva Bezier) para el tama√±o requerido (especificado como un par√°metro de funci√≥n, un rect√°ngulo de tipo CGRect).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La forma es una estructura almacenada. Al inicializarlo, almacena en los par√°metros todo lo que necesita para dibujar su contorno. El tama√±o de la selecci√≥n para este formulario puede cambiar, entonces todo lo que se necesita es obtener un nuevo valor de Ruta para el nuevo marco CGRect, y listo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comencemos a codificar ya:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">Circle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.green)<font></font>
            .frame(height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habra"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.gray)<font></font>
                )<font></font>
<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)<font></font>
            .frame(width: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>, height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habr"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.green)<font></font>
                )<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleTestView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">50</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">CircleView</span>(radius: radius)<font></font>
               .frame(height: <span class="hljs-number">200</span>)
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$radius, <span class="hljs-keyword">in</span>: <span class="hljs-number">42</span>...<span class="hljs-number">100</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.radius = <span class="hljs-number">50</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set default radius"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/pf/3j/eo/pf3jeo651jcwbhazddldv-rgxhy.gif"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, tenemos un c√≠rculo (Circle ()), cuyo radio podemos cambiar usando el control deslizante. Esto sucede sin problemas, ya que el control deslizante nos da todos los valores intermedios. Sin embargo, cuando hace clic en el bot√≥n "establecer radio predeterminado", el cambio tampoco ocurre instant√°neamente, sino de acuerdo con la instrucci√≥n withAnimation (.linear (duraci√≥n: 1)). Linealmente, sin aceleraci√≥n, estirado durante 1 segundo. ¬°Clase! ¬°Dominamos la animaci√≥n! No estamos de acuerdo :) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero, ¬øqu√© pasa si queremos implementar nuestra propia forma y animar sus cambios? ¬øEs dif√≠cil hacer esto? Vamos a revisar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hice una copia de Circle de la siguiente manera:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{
        <span class="hljs-keyword">let</span> radius = <span class="hljs-built_in">min</span>(rect.width, rect.height) / <span class="hljs-number">2</span>
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: rect.width / <span class="hljs-number">2</span>, y: rect.height / <span class="hljs-number">2</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-type">Path</span>(){path <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> rect.width &gt; rect.height{<font></font>
                path.move(to: <span class="hljs-type">CGPoint</span>(x: center.x, y: <span class="hljs-number">0</span>))
                <span class="hljs-keyword">let</span> startAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
                path.addArc(center: center, radius: radius, startAngle: startAngle, endAngle:  startAngle + <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>), clockwise: <span class="hljs-literal">false</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                path.move(to: <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: center.y))
                <span class="hljs-keyword">let</span> startAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
                path.addArc(center: center, radius: radius, startAngle: startAngle, endAngle:  startAngle + <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>), clockwise: <span class="hljs-literal">false</span>)<font></font>
            }<font></font>
            path.closeSubpath()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El radio del c√≠rculo se calcula como la mitad del ancho y la altura m√°s peque√±os del borde del √°rea de la pantalla que se nos asign√≥. </font><font style="vertical-align: inherit;">Si el ancho es mayor que la altura, comenzamos desde el medio del borde superior (Nota 1), describimos el c√≠rculo completo en el sentido de las agujas del reloj (Nota 2) y cerramos nuestro esquema al respecto. </font><font style="vertical-align: inherit;">Si la altura es mayor que el ancho, comenzamos desde la mitad del borde derecho, tambi√©n describimos el c√≠rculo completo en sentido horario y cerramos el contorno.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota 1</font></font></b>
                        <div class="spoiler_text">Apple     (  )  .  ,      (0, 0),         (x, y),  x ‚Äî  ,  y ‚Äî  . ..        y.   y ‚Äî   .  ,        .  90    , 180  ‚Äî , 270  ‚Äî .</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota 2</font></font></b>
                        <div class="spoiler_text">   1   ,   ‚Äú ‚Äù  ‚Äú ‚Äù         .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"></a>  Core Graphics (SwiftUI      ):<br>
<blockquote>In a flipped coordinate system (the default for UIView drawing methods in iOS), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.</blockquote></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos c√≥mo responder√° nuestro nuevo c√≠rculo a los cambios en el bloque withAnimation:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)<font></font>
            .frame(width: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>, height: <span class="hljs-keyword">self</span>.radius * <span class="hljs-number">2</span>)<font></font>
            .overlay(<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"Habr"</span>)<font></font>
                    .font(.largeTitle)<font></font>
                    .foregroundColor(.green)<font></font>
                )<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleTestView</span>: <span class="hljs-title">View</span> </span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">50</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
                <span class="hljs-type">HStack</span>{
                <span class="hljs-type">CircleView</span>(radius: radius)<font></font>
                    .frame(height: <span class="hljs-number">200</span>)
                <span class="hljs-type">CustomCircleView</span>(radius: radius)<font></font>
                    .frame(height: <span class="hljs-number">200</span>)<font></font>
            }<font></font>
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$radius, <span class="hljs-keyword">in</span>: <span class="hljs-number">42</span>...<span class="hljs-number">100</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.radius = <span class="hljs-number">50</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set default radius"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/ba/qp/5obaqpgty5ckwvic5uxzscqtix4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Guauu! </font><font style="vertical-align: inherit;">¬°Aprendimos a hacer nuestras propias im√°genes de forma libre y animarlas! </font><font style="vertical-align: inherit;">¬øEs tan? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Realmente no. </font><font style="vertical-align: inherit;">Todo el trabajo aqu√≠ lo realiza el modificador .frame (ancho: self.radius * 2, height: self.radius * 2). </font><font style="vertical-align: inherit;">Dentro del bloque withAnimation {...} cambiamos</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estado</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una variable, env√≠a una se√±al para reinicializar CustomCircleView () con un nuevo valor de radio, este nuevo valor cae en el modificador .frame (), y este modificador ya puede animar cambios de par√°metros. Nuestro formulario CustomCircle () reacciona a esto con animaci√≥n, porque no depende de otra cosa que no sea el tama√±o del √°rea seleccionada para ello. El cambio del √°rea ocurre con la animaci√≥n (es decir, gradualmente, la interpolaci√≥n de los valores intermedios entre ella se ha convertido), por lo tanto, nuestro c√≠rculo se dibuja con la misma animaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Simplifiquemos (¬øo a√∫n complicamos?) Nuestra forma un poco. No calcularemos el radio en funci√≥n del tama√±o del √°rea disponible, pero transferiremos el radio en la forma finalizada, es decir. convi√©rtalo en un par√°metro de estructura almacenada.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{
        <span class="hljs-comment">//let radius = min(rect.width, rect.height) / 2</span><font></font>
...<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircleView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">CustomCircle</span>(radius: radius)<font></font>
            .fill(<span class="hljs-type">Color</span>.gray)
            <span class="hljs-comment">//.frame(height: self.radius * 2)</span><font></font>
...<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/g9/ju/pp/g9juppbsuti7iazguvffuy02fiu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno, la magia se pierde irremediablemente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Excluimos el modificador frame () de nuestro CustomCircleView (), cambiando la responsabilidad del tama√±o del c√≠rculo a la forma misma, y ‚Äã‚Äãla animaci√≥n desapareci√≥. </font><font style="vertical-align: inherit;">Pero no importa; ense√±ar una forma de animar cambios en sus par√°metros no es demasiado dif√≠cil. </font><font style="vertical-align: inherit;">Para hacer esto, debe implementar los requisitos del protocolo Animatable:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomCircle</span>: <span class="hljs-title">Shape</span>, <span class="hljs-title">Animatable</span></span>{
    <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span>{
         <span class="hljs-keyword">get</span>{<font></font>
             radius<font></font>
         }<font></font>
         <span class="hljs-keyword">set</span>{
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"new radius is \(newValue)"</span>)<font></font>
            radius = newValue<font></font>
         }<font></font>
     }<font></font>
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-keyword">in</span> rect: CGRect)</span></span> -&gt; <span class="hljs-type">Path</span>{<font></font>
	...<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/f1/1-/xs/f11-xshpugfdigdwhnle4nupbek.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voila! </font><font style="vertical-align: inherit;">¬°La magia est√° de vuelta otra vez! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y ahora podemos decir con confianza que nuestra forma est√° realmente animada: puede reflejar cambios en sus par√°metros con animaci√≥n. </font><font style="vertical-align: inherit;">Le dimos al sistema una ventana donde puede llenar los valores interpolados necesarios para la animaci√≥n. </font><font style="vertical-align: inherit;">Si existe tal ventana, los cambios son animados. </font><font style="vertical-align: inherit;">Si no es as√≠, los cambios tienen lugar sin animaci√≥n, es decir. </font><font style="vertical-align: inherit;">instant√°neamente. </font><font style="vertical-align: inherit;">Nada complicado, ¬øverdad?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AnimatableModifier</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥mo animar cambios dentro de una vista</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero vayamos directamente a Ver. </font><font style="vertical-align: inherit;">Supongamos que queremos animar la posici√≥n de un elemento dentro de un contenedor. </font><font style="vertical-align: inherit;">En nuestro caso, ser√° un simple rect√°ngulo de color verde y un ancho de 10 unidades. </font><font style="vertical-align: inherit;">Animaremos su posici√≥n horizontal.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SimpleView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">ZStack</span>{
                <span class="hljs-type">Rectangle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.gray)
                <span class="hljs-type">BorderView</span>(position: position)<font></font>
            }<font></font>
            <span class="hljs-type">Slider</span>(value: <span class="hljs-keyword">self</span>.$position, <span class="hljs-keyword">in</span>: <span class="hljs-number">0</span>...<span class="hljs-number">1</span>)
            <span class="hljs-type">Button</span>(action: {<font></font>
                withAnimation(.linear(duration: <span class="hljs-number">1</span>)){
                    <span class="hljs-keyword">self</span>.position = <span class="hljs-number">0</span><font></font>
                }<font></font>
            }){<font></font>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"set to 0"</span>)<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderView</span>: <span class="hljs-title">View</span>,  <span class="hljs-title">Animatable</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Reding position: \(position)"</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.position<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.position = newValue
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"setting position: \(position)"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">let</span> borderWidth: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">init</span>(position: <span class="hljs-type">CGFloat</span>, borderWidth: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">10</span>){
        <span class="hljs-keyword">self</span>.position = position
        <span class="hljs-keyword">self</span>.borderWidth = borderWidth
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"BorderView init"</span>)<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-keyword">self</span>.borderWidth)<font></font>
                .offset(x: <span class="hljs-keyword">self</span>.getXOffset(inSize: geometry.size), y: <span class="hljs-number">0</span>)
                <span class="hljs-comment">// .borderIn(position: position)</span><font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getXOffset</span><span class="hljs-params">(inSize: CGSize)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"calculating position: \(position)"</span>)
        <span class="hljs-keyword">return</span> -inSize.width / <span class="hljs-number">2</span> + inSize.width * position<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/7l/b-/pr/7lb-pry2ta71tvntbemngt8duts.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬°Clase! </font><font style="vertical-align: inherit;">¬°Trabajos! </font><font style="vertical-align: inherit;">¬°Ahora sabemos todo sobre animaci√≥n! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Realmente no. </font><font style="vertical-align: inherit;">Si nos fijamos en la consola, veremos lo siguiente:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posici√≥n de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
c√°lculo de </font><font style="vertical-align: inherit;">init de BorderView </font><font style="vertical-align: inherit;">: 0.4595176577568054 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Posici√≥n de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
c√°lculo de </font><font style="vertical-align: inherit;">init de </font><font style="vertical-align: inherit;">BorderView: 0.468130886554718 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Posici√≥n de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
c√°lculo de </font><font style="vertical-align: inherit;">init de BorderView </font><font style="vertical-align: inherit;">: 0.0</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, cada cambio en el valor de posici√≥n utilizando el control deslizante hace que BorderView se reinicialice con el nuevo valor. Es por eso que vemos un movimiento suave de la l√≠nea verde despu√©s del control deslizante, el control deslizante simplemente informa muy a menudo un cambio en la variable y parece una animaci√≥n, pero no lo es. Usar el control deslizante es realmente conveniente cuando depura la animaci√≥n. Puede usarlo para rastrear algunos estados de transici√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En segundo lugar, vemos que la posici√≥n de c√°lculo simplemente se volvi√≥ igual a 0, y no hubo registros intermedios, como fue el caso con la animaci√≥n correcta del c√≠rculo. ¬øPor qu√©?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La cosa, como en el ejemplo anterior, est√° en el modificador. </font><font style="vertical-align: inherit;">Esta vez, el modificador .offset () obtiene el nuevo valor de sangr√≠a y anima el cambio en s√≠. </font><font style="vertical-align: inherit;">Aquellos. </font><font style="vertical-align: inherit;">de hecho, no es el cambio en el par√°metro de posici√≥n que pretend√≠amos animar, sino el cambio horizontal de la sangr√≠a en el modificador .offset () derivado de √©l. </font><font style="vertical-align: inherit;">En este caso, este es un reemplazo inofensivo, el resultado es el mismo. </font><font style="vertical-align: inherit;">Pero como han venido, profundicemos. </font><font style="vertical-align: inherit;">Hagamos nuestro propio modificador, que recibir√° la posici√≥n (de 0 a 1) en la entrada, recibir√° el tama√±o del √°rea disponible y calcular√° la sangr√≠a.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderPosition</span>: <span class="hljs-title">ViewModifier</span></span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span><font></font>
            content<font></font>
            .offset(x: <span class="hljs-keyword">self</span>.getXOffset(inSize: geometry.size), y: <span class="hljs-number">0</span>)<font></font>
            .animation(<span class="hljs-literal">nil</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getXOffset</span><span class="hljs-params">(inSize: CGSize)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-keyword">let</span> offset = -inSize.width / <span class="hljs-number">2</span> + inSize.width * position
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"at position  \(position) offset is \(offset)"</span>)
        <span class="hljs-keyword">return</span> offset<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">borderIn</span><span class="hljs-params">(position: CGFloat)</span></span> -&gt; some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">BorderPosition</span>(position: position))<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el BorderView original, respectivamente, ya no se necesita GeometryReader, as√≠ como la funci√≥n para calcular la sangr√≠a:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderView</span>: <span class="hljs-title">View</span>,  <span class="hljs-title">Animatable</span></span>{<font></font>
    ...<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-keyword">self</span>.borderWidth)<font></font>
                .borderIn(position: position)<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/hd/3i/r0/hd3ir0e-_jji7qwiasacdwpnpx4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S√≠, todav√≠a usamos el modificador .offset () dentro de nuestro modificador, pero luego agregamos el modificador .animation (nil), que bloquea nuestra propia animaci√≥n de desplazamiento. </font><font style="vertical-align: inherit;">Entiendo que en esta etapa puede decidir que es suficiente para eliminar este bloqueo, pero no llegaremos al fondo de la verdad. </font><font style="vertical-align: inherit;">Y la verdad es que nuestro truco con animatableData para BorderView no funciona. </font><font style="vertical-align: inherit;">De hecho, si mira la documentaci√≥n del protocolo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animatable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , notar√° que la implementaci√≥n de este protocolo solo es compatible con AnimatableModifier, GeometryEffect y Shape. </font><font style="vertical-align: inherit;">La vista no est√° entre ellos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El enfoque correcto es animar modificaciones</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El enfoque en s√≠ mismo, cuando le pedimos a View que anime algunos cambios, era incorrecto. </font><font style="vertical-align: inherit;">Para Ver, no puede usar el mismo enfoque que para los formularios. </font><font style="vertical-align: inherit;">En cambio, la animaci√≥n debe integrarse en cada modificador. </font><font style="vertical-align: inherit;">La mayor√≠a de los modificadores incorporados ya admiten animaci√≥n de f√°brica. </font><font style="vertical-align: inherit;">Si desea animaci√≥n para sus propios modificadores, puede usar el protocolo AnimatableModifier en lugar de ViewModifier. </font><font style="vertical-align: inherit;">Y all√≠ puede implementar lo mismo que al animar los cambios de forma, como lo hicimos anteriormente.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BorderPosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> startDate: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"reading position: \(position) at time \(Date().timeIntervalSince(startDate))"</span>)
            <span class="hljs-keyword">return</span> position<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {<font></font>
            position = newValue<font></font>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"setting position: \(position) at time \(Date().timeIntervalSince(startDate))"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
...<font></font>
    }<font></font>
    ...<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/p2/l3/ys/p2l3yslis_hirenud-lpkt8xaoa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora todo est√° bien. </font><font style="vertical-align: inherit;">Los mensajes en la consola ayudan a comprender que nuestra animaci√≥n realmente funciona, y .animation (nil) dentro del modificador no interfiere en absoluto. </font><font style="vertical-align: inherit;">Pero sigamos descubriendo exactamente c√≥mo funciona.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, necesitas entender qu√© es un modificador.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ tenemos una vista. Como dije en la parte anterior, esta es una estructura con par√°metros almacenados e instrucciones de ensamblaje. Esta instrucci√≥n, en general, no contiene una secuencia de acciones, que es el c√≥digo habitual que escribimos en un estilo no declarativo, sino una lista simple. Enumera la otra Vista, los modificadores que se les aplicaron y los contenedores en los que est√°n incluidos. Todav√≠a no estamos interesados ‚Äã‚Äãen los contenedores, pero hablemos m√°s sobre los modificadores.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un modificador es nuevamente una estructura con par√°metros almacenados y Ver instrucciones de procesamiento. </font><font style="vertical-align: inherit;">Esta es en realidad la misma instrucci√≥n que la Vista: podemos usar otros modificadores, usar contenedores (por ejemplo, us√© el GeometryReader un poco m√°s alto) e incluso otra Vista. </font><font style="vertical-align: inherit;">Pero solo tenemos contenido entrante, y necesitamos cambiarlo de alguna manera usando esta instrucci√≥n. </font><font style="vertical-align: inherit;">Los par√°metros modificadores son parte de la instrucci√≥n. </font><font style="vertical-align: inherit;">Pero lo m√°s interesante es que est√°n almacenados.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En un art√≠culo anterior, dije que la instrucci√≥n en s√≠ no se almacena, que se lanza cada vez que se actualiza la Vista. </font><font style="vertical-align: inherit;">Todo es as√≠, pero hay un matiz. </font><font style="vertical-align: inherit;">Como resultado del trabajo de esta instrucci√≥n, no obtuvimos una imagen clara, como dije antes: fue una simplificaci√≥n. </font><font style="vertical-align: inherit;">Los modificadores no desaparecen despu√©s de la operaci√≥n de esta instrucci√≥n. </font><font style="vertical-align: inherit;">Permanecen as√≠ mientras exista la Vista principal.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algunas analog√≠as primitivas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øC√≥mo describir√≠amos una tabla en un estilo declarativo? </font><font style="vertical-align: inherit;">Bueno, enumerar√≠amos 4 patas y una encimera. </font><font style="vertical-align: inherit;">Los combinar√≠an en alg√∫n tipo de contenedor, y con la ayuda de algunos modificadores prescribir√≠an c√≥mo se unen entre s√≠. </font><font style="vertical-align: inherit;">Por ejemplo, cada pata indicar√≠a la orientaci√≥n con respecto a la encimera y la posici√≥n: qu√© pata est√° fijada en qu√© esquina. </font><font style="vertical-align: inherit;">S√≠, podemos tirar las instrucciones despu√©s del montaje, pero las u√±as permanecer√°n en la mesa. </font><font style="vertical-align: inherit;">As√≠ son los modificadores. </font><font style="vertical-align: inherit;">A la salida de la funci√≥n del cuerpo, no tenemos una tabla. </font><font style="vertical-align: inherit;">Usando cuerpo, creamos elementos de tabla (vista) y sujetadores (modificadores), y lo colocamos todo en cajones. </font><font style="vertical-align: inherit;">La mesa en s√≠ est√° ensamblada por un robot. </font><font style="vertical-align: inherit;">Con qu√© sujetadores colocas en una caja en cada pata, obtendr√°s dicha mesa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La funci√≥n .modifier (BorderPosition (posici√≥n: posici√≥n)), con la que convertimos la estructura BorderPosition en un modificador, solo pone un tornillo adicional en el caj√≥n a la pata de la mesa. La estructura de BorderPosition es este tornillo. El renderizado, en el momento del renderizado, toma este cuadro, le quita un tramo (Rect√°ngulo () en nuestro caso) y obtiene secuencialmente todos los modificadores de la lista, con los valores almacenados en ellos. La funci√≥n del cuerpo de cada modificador es una instrucci√≥n sobre c√≥mo atornillar una pata a una mesa con este tornillo, y la estructura misma con propiedades almacenadas, este es ese tornillo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øPor qu√© es importante entender esto en el contexto de la animaci√≥n? Debido a que la animaci√≥n le permite cambiar los par√°metros de un modificador sin afectar a los otros, y luego volver a renderizar la imagen. Si haces lo mismo cambiando algunos</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√°metros: esto provocar√° la reinicializaci√≥n de la Vista anidada, las estructuras modificadoras, etc., a lo largo de toda la cadena. Pero la animaci√≥n no lo es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, cuando cambiamos el valor de la posici√≥n cuando presionamos un bot√≥n, cambia. Hasta el final. No se almacenan estados intermedios en la variable en s√≠, lo que no se puede decir sobre el modificador. Para cada nuevo cuadro, los valores de los par√°metros modificadores cambian de acuerdo con el progreso de la animaci√≥n actual. Si la animaci√≥n dura 1 segundo, entonces cada 1/60 de segundo (el iPhone muestra exactamente esa cantidad de cuadros por segundo), el valor de animatableData dentro del modificador cambiar√°, luego ser√° le√≠do por el render para renderizar, despu√©s de lo cual, despu√©s de otro 1/60 de segundo, ser√° cambiado nuevamente, y le√≠do nuevamente por el render.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo que es caracter√≠stico, primero obtenemos el estado final de toda la Vista, lo recordamos y solo entonces el mecanismo de animaci√≥n comienza a aplicar los valores de posici√≥n interpolados al modificador. El estado inicial no se almacena en ning√∫n lado. En alg√∫n lugar de las entra√±as de SwiftUI, solo se almacena la diferencia entre el estado inicial y el final. Esta diferencia se multiplica cada vez por la fracci√≥n del tiempo transcurrido. As√≠ es como se calcula el valor interpolado, que posteriormente se sustituye en animatableData. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferencia = </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acero </font></font><br><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">- Era </font></i><i><font style="vertical-align: inherit;">valor actual = Acero - Diferencia * (1 - Tiempo transcurrido) </font></i><i><font style="vertical-align: inherit;">
Tiempo transcurrido = Tiempo desde inicioAnimaciones / Duraci√≥nAnimaciones El</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
valor actual debe calcularse tantas veces como el n√∫mero de cuadros que necesitamos mostrar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øPor qu√© el "Was" no se usa expl√≠citamente? El hecho es que SwiftUI no almacena el estado inicial. Solo se almacena la diferencia: por lo tanto, en el caso de alg√∫n tipo de falla, simplemente puede apagar la animaci√≥n y pasar al estado actual de "convertirse". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este enfoque le permite hacer que la animaci√≥n sea reversible. Supongamos que, en alg√∫n lugar en el medio de una animaci√≥n, el usuario presion√≥ un bot√≥n nuevamente, y nuevamente cambiamos el valor de la misma variable. En este caso, todo lo que tenemos que hacer para vencer este cambio maravillosamente es tomar "Actual" dentro de la animaci√≥n en el momento del nuevo cambio como "It", recordar la nueva Diferencia y comenzar una nueva animaci√≥n basada en el nuevo "Became" y la nueva "Diferencia" . S√≠, de hecho, estas transiciones de una animaci√≥n a otra pueden ser un poco m√°s dif√≠ciles de simular inercia, pero creo que el significado es comprensible.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo interesante es que la animaci√≥n de cada cuadro solicita el valor actual dentro del modificador (usando un captador). Esto, como puede ver en los registros de servicio en el registro, es responsable del estado de "Acero". Luego, usando el setter, establecemos el nuevo estado actual para este marco. Despu√©s de eso, para el siguiente cuadro, se solicita nuevamente el valor actual del modificador, y nuevamente "se ha convertido", es decir El valor final al que se mueve la animaci√≥n. Es probable que se usen copias de las estructuras modificadoras para la animaci√≥n, y se use un captador de una estructura (un modificador real de la Vista real) para obtener el valor "Acero", y se use un definidor de otra (un modificador temporal usado para la animaci√≥n). No he encontrado una manera de asegurarme de esto, pero por indicaciones indirectas todo se ve as√≠. De todas formas,Los cambios dentro de la animaci√≥n no afectan el valor almacenado de la estructura modificadora de la Vista actual. Si tiene ideas sobre c√≥mo averiguar exactamente qu√© sucede exactamente con el getter y el setter, escr√≠balo en los comentarios, actualizar√© el art√≠culo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Varios par√°metros</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasta este momento, solo ten√≠amos un par√°metro para la animaci√≥n. </font><font style="vertical-align: inherit;">La pregunta puede surgir, pero ¬øqu√© pasa si se pasa m√°s de un par√°metro al modificador? </font><font style="vertical-align: inherit;">¬øY si ambos necesitan ser animados al mismo tiempo? </font><font style="vertical-align: inherit;">As√≠ es como con el modificador de marco (ancho: alto :) por ejemplo. </font><font style="vertical-align: inherit;">Despu√©s de todo, podemos cambiar simult√°neamente el ancho y la altura de esta Vista, y queremos que el cambio ocurra en una animaci√≥n, ¬øc√≥mo hacerlo? </font><font style="vertical-align: inherit;">Despu√©s de todo, el par√°metro AnimatableData es uno, ¬øqu√© puedo sustituir?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nos fijamos, Apple solo tiene un requisito para animatableData. El tipo de datos que sustituya debe cumplir el protocolo VectorArithmetic. Este protocolo requiere que el objeto garantice las operaciones aritm√©ticas m√≠nimas necesarias para poder formar un segmento de dos valores e interpolar los puntos dentro de este segmento. Las operaciones necesarias para esto son suma, resta y multiplicaci√≥n. La dificultad es que debemos realizar estas operaciones con un solo objeto que almacena varios par√°metros. Aquellos. debemos empacar la lista completa de nuestros par√°metros en un contenedor que ser√° un vector. Apple proporciona un objeto de este tipo y nos ofrece utilizar una soluci√≥n llave en mano para casos no muy dif√≠ciles. Se llama AnimatablePair.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cambiemos la tarea un poco. </font><font style="vertical-align: inherit;">Necesitamos un nuevo modificador que no solo mueva la barra verde, sino que tambi√©n cambie su altura. </font><font style="vertical-align: inherit;">Estos ser√°n dos par√°metros modificadores independientes. </font><font style="vertical-align: inherit;">No dar√© el c√≥digo completo de todos los cambios que deben hacerse, puede verlo en el github en el archivo SimpleBorderMove. </font><font style="vertical-align: inherit;">Solo mostrar√© el modificador en s√≠:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TwoParameterBorder</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> startDate: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">AnimatablePair</span>&lt;<span class="hljs-type">CGFloat</span>, <span class="hljs-type">CGFloat</span>&gt; {
        <span class="hljs-keyword">get</span> {
           <span class="hljs-built_in">print</span>(<span class="hljs-string">"animation read position: \(position), height: \(height)"</span>)
           <span class="hljs-keyword">return</span> <span class="hljs-type">AnimatablePair</span>(position, height)<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>.position = newValue.first
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"animating position at \(position)"</span>)
            <span class="hljs-keyword">self</span>.height = newValue.second
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"animating height at \(height)"</span>)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(position: <span class="hljs-type">CGFloat</span>, height: <span class="hljs-type">CGFloat</span>){
        <span class="hljs-keyword">self</span>.position = position
        <span class="hljs-keyword">self</span>.height = height<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span><font></font>
            content<font></font>
                .animation(<span class="hljs-literal">nil</span>)<font></font>
                .offset(x: -geometry.size.width / <span class="hljs-number">2</span> + geometry.size.width * <span class="hljs-keyword">self</span>.position, y: <span class="hljs-number">0</span>)<font></font>
                .frame(height: <span class="hljs-keyword">self</span>.height * (geometry.size.height - <span class="hljs-number">20</span>) + <span class="hljs-number">20</span>)<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vn/0q/mi/vn0qmirl31w63mzgjvijsw-f-ps.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregu√© otro control deslizante y un bot√≥n para cambiar aleatoriamente ambos par√°metros a la vez en la vista principal de SimpleView, pero no hay nada interesante, as√≠ que para el c√≥digo completo, bienvenido al github. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo funciona, realmente obtenemos un cambio constante en el par de par√°metros empaquetados en la tupla AnimatablePair. </font><font style="vertical-align: inherit;">No est√° mal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øNada confunde en esta implementaci√≥n? </font><font style="vertical-align: inherit;">Personalmente, me tens√© cuando vi este dise√±o:</font></font><br>
<br>
<pre><code class="swift hljs">        
<span class="hljs-keyword">self</span>.position = newValue.first
<span class="hljs-keyword">self</span>.height = newValue.second
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No indiqu√© en ning√∫n lugar cu√°l de estos par√°metros deber√≠a ir primero y qu√© segundo. ¬øC√≥mo decide SwiftUI qu√© valor poner primero y qu√© valor en segundo? Bueno, ¬øno coincide los nombres de los par√°metros de la funci√≥n con los nombres de los atributos de la estructura?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La primera idea fue el orden de los atributos en los par√°metros de la funci√≥n y sus tipos, como sucede con @EnvironmentObject. All√≠, simplemente colocamos los valores en el cuadro, sin asignarles ninguna etiqueta, y luego los sacamos de all√≠, tambi√©n sin indicar ninguna etiqueta. All√≠, el tipo importa, y dentro de un tipo, el orden. En qu√© orden ponen en la caja, de la misma manera y lo obtienen. Intent√© un orden diferente de los argumentos de la funci√≥n, el orden de los argumentos para inicializar la estructura, el orden de los atributos de la estructura en s√≠, generalmente golpe√≥ mi cabeza contra la pared, pero no pod√≠a confundir a SwiftUI para que comenzara a animar la posici√≥n con valores de altura y viceversa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces me di cuenta. Yo mismo indico qu√© par√°metro ser√° el primero y qu√© segundo en el getter. SwiftUI no necesita saber exactamente c√≥mo inicializamos esta estructura. Puede obtener el valor de animatableData antes del cambio, obtenerlo despu√©s del cambio, calcular la diferencia entre ellos y devolver la misma diferencia, en proporci√≥n al intervalo de tiempo transcurrido, a nuestro configurador. Por lo general, no necesita saber nada sobre el valor en s√≠ dentro de AnimatableData. Y si no confunde el orden de las variables en dos l√≠neas adyacentes, entonces todo estar√° en orden, sin importar cu√°n complicada sea la estructura del resto del c√≥digo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero vamos a verlo. Despu√©s de todo, podemos crear nuestro propio vector contenedor (oh, me encanta, crear nuestra propia implementaci√≥n de objetos existentes, tal vez lo hayas notado en un art√≠culo anterior).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ao/v4/an/aov4an8tjqou27syes6klcckwy0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Describimos la estructura elemental, declaramos soporte para el protocolo VectorArithmetic, abrimos el error sobre el protocolo no conforme, hacemos clic en corregir, y obtenemos la declaraci√≥n de todas las funciones requeridas y los par√°metros calculados. </font><font style="vertical-align: inherit;">Solo queda llenarlos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De la misma manera, llenamos nuestro objeto con los m√©todos necesarios para el protocolo AdditiveArithmetic (VectorArithmetic incluye su soporte).</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyAnimatableVector</span>: <span class="hljs-title">VectorArithmetic</span></span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> - <span class="hljs-params">(lhs: MyAnimatableVector, rhs: MyAnimatableVector)</span></span> -&gt; <span class="hljs-type">MyAnimatableVector</span> {
        <span class="hljs-type">MyAnimatableVector</span>(position: lhs.position - rhs.position, height: lhs.height - rhs.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> + <span class="hljs-params">(lhs: MyAnimatableVector, rhs: MyAnimatableVector)</span></span> -&gt; <span class="hljs-type">MyAnimatableVector</span> {
        <span class="hljs-type">MyAnimatableVector</span>(position: lhs.position + rhs.position, height: lhs.height + rhs.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scale</span><span class="hljs-params">(by rhs: Double)</span></span> {
        <span class="hljs-keyword">self</span>.position = <span class="hljs-keyword">self</span>.position * <span class="hljs-type">CGFloat</span>(rhs)
        <span class="hljs-keyword">self</span>.height = <span class="hljs-keyword">self</span>.height * <span class="hljs-type">CGFloat</span>(rhs)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> magnitudeSquared: <span class="hljs-type">Double</span>{
         <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.position * <span class="hljs-keyword">self</span>.position) + <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.height * <span class="hljs-keyword">self</span>.height)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> zero: <span class="hljs-type">MyAnimatableVector</span>{
        <span class="hljs-type">MyAnimatableVector</span>(position: <span class="hljs-number">0</span>, height: <span class="hljs-number">0</span>)<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">var</span> position: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> height: <span class="hljs-type">CGFloat</span>
}</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pienso por qu√© necesitamos + y - obviamente. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La escala es una funci√≥n de escala. </font><font style="vertical-align: inherit;">Tomamos la diferencia "Fue - se ha convertido" y la multiplicamos por la etapa actual de la animaci√≥n (de 0 a 1). </font><font style="vertical-align: inherit;">"Se convirti√≥ en + Diferencia * (1 - Etapa)" y habr√° un valor actual que deber√≠amos obtener en animatableData</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probablemente se necesite cero para inicializar nuevos objetos cuyos valores se utilizar√°n para la animaci√≥n. </font><font style="vertical-align: inherit;">La animaci√≥n usa .zero al principio, pero no pude entender exactamente c√≥mo. </font><font style="vertical-align: inherit;">Sin embargo, no creo que esto sea importante.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">magnitudeSquared es un producto escalar de un vector dado consigo mismo. </font><font style="vertical-align: inherit;">Para el espacio bidimensional, esto significa la longitud del vector al cuadrado. </font><font style="vertical-align: inherit;">Probablemente esto se usa para poder comparar dos objetos entre s√≠, no por elementos, sino como un todo. </font><font style="vertical-align: inherit;">Parece que no se utiliza con fines de animaci√≥n.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En t√©rminos generales, las funciones ‚Äú- =‚Äù ‚Äú+ =‚Äù tambi√©n se incluyen en el soporte de protocolo, pero para la estructura se pueden generar autom√°ticamente en este formulario</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> -= <span class="hljs-params">(lhs: <span class="hljs-keyword">inout</span> MyAnimatableVector, rhs: MyAnimatableVector)</span></span> {<font></font>
        lhs = lhs - rhs<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> += <span class="hljs-params">(lhs: <span class="hljs-keyword">inout</span> MyAnimatableVector, rhs: MyAnimatableVector)</span></span> {<font></font>
        lhs = lhs + rhs<font></font>
    }<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para mayor claridad, expuse toda esta l√≥gica en forma de diagrama. </font><font style="vertical-align: inherit;">
Se puede hacer clic en la imagen. </font><font style="vertical-align: inherit;">
Lo que obtenemos durante la animaci√≥n se resalta en rojo: cada siguiente tick (1/60 segundos) el temporizador da un nuevo valor de t, y nosotros, en la configuraci√≥n de nuestro modificador, obtenemos un nuevo valor de animatableData. </font><font style="vertical-align: inherit;">As√≠ es como funciona la animaci√≥n bajo el cap√≥. </font><font style="vertical-align: inherit;">Al mismo tiempo, es importante comprender que un modificador es una estructura almacenada, y se utiliza una copia del modificador actual con un nuevo estado actual para mostrar la animaci√≥n.</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/zl/ag/q4/zlagq42atcapum-br2sj00ikubu.png"></a><br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por qu√© AnimatableData solo puede ser una estructura</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un punto m√°s. No puede usar clases como un objeto AnimatableData. Formalmente, puede describir para una clase todos los m√©todos necesarios del protocolo correspondiente, pero esto no despegar√°, y he aqu√≠ por qu√©. Como sabe, una clase es un tipo de datos de referencia y una estructura es un tipo de datos basado en valores. Cuando crea una variable basada en otra, en el caso de una clase, copia un enlace a este objeto, y en el caso de una estructura, crea un nuevo objeto basado en los valores del existente. Aqu√≠ hay un peque√±o ejemplo que ilustra esta diferencia:</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TestStruct</span></span>{
        <span class="hljs-keyword">var</span> value: <span class="hljs-type">CGFloat</span>
        <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scaled</span><span class="hljs-params">(by: CGFloat)</span></span>{
            <span class="hljs-keyword">self</span>.value = <span class="hljs-keyword">self</span>.value * by<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span></span>{
        <span class="hljs-keyword">var</span> value: <span class="hljs-type">CGFloat</span>
        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scaled</span><span class="hljs-params">(by: CGFloat)</span></span>{
             <span class="hljs-keyword">self</span>.value = <span class="hljs-keyword">self</span>.value * by<font></font>
        }<font></font>
        <span class="hljs-keyword">init</span>(value: <span class="hljs-type">CGFloat</span>){
            <span class="hljs-keyword">self</span>.value = value<font></font>
        }<font></font>
    }<font></font>
        <span class="hljs-keyword">var</span> stA = <span class="hljs-type">TestStruct</span>(value: <span class="hljs-number">5</span>)
        <span class="hljs-keyword">var</span> stB = stA<font></font>
        stB.scaled(by: <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"structs: a = \(stA.value), b = \(stB.value))"</span>) <span class="hljs-comment">//structs: a = 5.0, b = 10.0)</span>
        <span class="hljs-keyword">var</span> clA = <span class="hljs-type">TestClass</span>(value: <span class="hljs-number">5</span>)
        <span class="hljs-keyword">var</span> clB = clA<font></font>
        clB.scaled(by: <span class="hljs-number">2</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"classes: a = \(clA.value), b = \(clB.value))"</span>) <span class="hljs-comment">//classes: a = 10.0, b = 10.0)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con la animaci√≥n sucede exactamente lo mismo. Tenemos un objeto AnimatableData que representa la diferencia entre "fue" y "se convirti√≥". Necesitamos calcular parte de esta diferencia para reflejar en la pantalla. Para hacer esto, debemos copiar esta diferencia y multiplicarla por un n√∫mero que represente la etapa actual de la animaci√≥n. En el caso de la estructura, esto no afectar√° la diferencia en s√≠, pero en el caso de la clase s√≠ lo har√°. El primer cuadro que dibujamos es el estado "era". Para hacer esto, necesitamos calcular Acero + Diferencia * Etapa actual - Diferencia. En el caso de la clase, en el primer cuadro multiplicamos la diferencia por 0, poni√©ndola a cero, y todos los cuadros subsiguientes se dibujan de modo que la diferencia = 0. i.e. la animaci√≥n parece estar dibujada correctamente, pero de hecho vemos una transici√≥n instant√°nea de un estado a otro, como si no hubiera animaci√≥n.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probablemente pueda escribir alg√∫n tipo de c√≥digo de bajo nivel que cree nuevas direcciones de memoria para el resultado de la multiplicaci√≥n, pero ¬øpor qu√©? </font><font style="vertical-align: inherit;">Simplemente puede usar estructuras, se crean para eso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para aquellos que desean comprender a fondo c√≥mo SwiftUI calcula los valores intermedios, por qu√© operaciones y en qu√© momento, los </font><font style="vertical-align: inherit;">mensajes se env√≠an a la consola </font><font style="vertical-align: inherit;">en el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proyecto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Adem√°s, insert√© sleep 0.1 segundos all√≠ para simular c√°lculos intensivos en recursos dentro de la animaci√≥n, divi√©rtete :)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animaci√≥n de pantalla: .transition ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasta este punto, hablamos sobre animar un cambio en un valor pasado a un modificador o forma. Estas son herramientas bastante poderosas. Pero hay otra herramienta que tambi√©n usa animaci√≥n: esta es la animaci√≥n de la aparici√≥n y desaparici√≥n de la Vista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el √∫ltimo art√≠culo, hablamos sobre el hecho de que en el estilo declarativo de if-else, esto no tiene ning√∫n control sobre el flujo de c√≥digo en tiempo de ejecuci√≥n, sino m√°s bien una vista de Schr√∂dinger. Este es un contenedor que contiene dos vistas al mismo tiempo, que decide cu√°l mostrar de acuerdo con una determinada condici√≥n. Si pierde el bloque else, se muestra EmptyView en lugar de la segunda vista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El cambio entre las dos vistas tambi√©n se puede animar. Para hacer esto, use el modificador .transition ().</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TransitionView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">let</span> views: [<span class="hljs-type">AnyView</span>] = [<span class="hljs-type">AnyView</span>(<span class="hljs-type">CustomCircleTestView</span>()), <span class="hljs-type">AnyView</span>(<span class="hljs-type">SimpleBorderMove</span>())]<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> currentViewInd = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">ZStack</span>{
                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                        }<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-type">HStack</span>{
                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">10</span>)<font></font>
                        .fill(ind == <span class="hljs-keyword">self</span>.currentViewInd ? <span class="hljs-type">Color</span>.green : <span class="hljs-type">Color</span>.gray)<font></font>
                        .overlay(<font></font>
                            <span class="hljs-type">Text</span>(<span class="hljs-string">"\(ind + Int(1))"</span>))<font></font>
                        .onTapGesture{<font></font>
                            withAnimation{<font></font>
                                <span class="hljs-keyword">self</span>.currentViewInd = ind<font></font>
                            }<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
                .frame(height: <span class="hljs-number">50</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos c√≥mo funciona. En primer lugar, de antemano, incluso en la etapa de inicializaci√≥n de la vista principal, creamos y colocamos varias Vistas en la matriz. La matriz es del tipo AnyView, porque los elementos de la matriz deben tener el mismo tipo, de lo contrario no se pueden usar en ForEach. Tipo de resultado opaco del </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anterior </font><font style="vertical-align: inherit;">, ¬ørecuerda? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuaci√≥n, prescribimos la enumeraci√≥n de los √≠ndices de esta matriz, y para cada uno de ellos mostramos la vista por este √≠ndice. Nos vemos obligados a hacer esto, y no iterar sobre Vista inmediatamente, porque para trabajar con ForEach, necesitamos asignar un identificador interno a cada elemento para que SwiftUI pueda iterar sobre el contenido de la colecci√≥n. Como alternativa, tendr√≠amos que crear un identificador proxy en cada Vista, pero ¬øpor qu√© si se pueden usar √≠ndices?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Envolvemos cada vista de la colecci√≥n en una condici√≥n y la mostramos solo si est√° activa. Sin embargo, la construcci√≥n if-else simplemente no puede existir aqu√≠, el compilador lo toma para el control de flujo, por lo que ponemos todo esto en Group para que el compilador comprenda exactamente qu√© es View, o m√°s precisamente, instrucciones para que ViewBuilder cree un contenedor de ConditionalContent opcional. &lt;Ver1, Ver2&gt;. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, al cambiar el valor de currentViewInd, SwiftUI oculta la vista activa anterior y muestra la actual. ¬øQu√© le parece esta navegaci√≥n dentro de la aplicaci√≥n?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ua/kr/gd/uakrgd2tzwv9hik_egmn1fglsfw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo lo que queda por hacer es colocar el cambio currentViewInd en el contenedor withAnimation, y cambiar entre ventanas se har√° m√°s sencillo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregue el modificador .transition, especificando .scale como par√°metro. </font><font style="vertical-align: inherit;">Esto har√° que la animaci√≥n de la aparici√≥n y desaparici√≥n de cada una de estas vistas sea diferente, utilizando la escala en lugar de la transparencia utilizada por SwiftUI por defecto.</font></font><br>
<br>
<pre><code class="swift hljs">                <span class="hljs-type">ForEach</span>(views.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){(ind: <span class="hljs-type">Int</span>) <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                                .transition(.scale)<font></font>
                        }<font></font>
                    }<font></font>
                }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/l5/ib/d-/l5ibd-y7m986miqinbv56qaslfc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que la vista aparece y desaparece con la misma animaci√≥n, solo la desaparici√≥n se desplaza en el orden inverso. </font><font style="vertical-align: inherit;">De hecho, podemos asignar animaciones individualmente para la apariencia y la desaparici√≥n de una vista. </font><font style="vertical-align: inherit;">Para esto se usa una transici√≥n asim√©trica.</font></font><br>
<br>
<pre><code class="swift hljs">                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-keyword">self</span>.views[ind]<font></font>
                               .transition(.asymmetric(<font></font>
                                    insertion: insertion: <span class="hljs-type">AnyTransition</span>.scale(scale: <span class="hljs-number">0.1</span>, anchor: .leading).combined(with: .opacity),<font></font>
                                    removal: .move(edge: .trailing)))<font></font>
                        }<font></font>
                    }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mq/xg/ji/mqxgji1ton95qn6ywl23xhl2mzm.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La misma animaci√≥n .scale se usa para aparecer en la pantalla, pero ahora hemos especificado los par√°metros para su uso. No comienza con un tama√±o cero (punto), sino con un tama√±o de 0.1 del habitual. Y la posici√≥n inicial de la peque√±a ventana no est√° en el centro de la pantalla, sino que se desplaza hacia el borde izquierdo. Adem√°s, no una transici√≥n es responsable de la apariencia, sino dos. Se pueden combinar con .combined (con :). En este caso, hemos agregado transparencia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La desaparici√≥n de la vista ahora est√° representada por otra animaci√≥n: barrer el borde derecho de la pantalla. Hice la animaci√≥n un poco m√°s lenta para que puedas echarle un vistazo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y como siempre, no puedo esperar para escribir mi propia versi√≥n de animaci√≥n de tr√°nsito. Esto es incluso m√°s simple que las formas animadas o modificadores.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpinTransitionModifier</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-keyword">let</span> angle: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> anchor: <span class="hljs-type">UnitPoint</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        content<font></font>
            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle), anchor: anchor)<font></font>
            .clipped()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">AnyTransition</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinIn</span><span class="hljs-params">(anchor: UnitPoint)</span></span> -&gt; <span class="hljs-type">AnyTransition</span> {<font></font>
        .modifier(<font></font>
            active: <span class="hljs-type">SpinTransitionModifier</span>(angle: -<span class="hljs-number">90</span>, anchor: anchor),<font></font>
            identity: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">0</span>, anchor: anchor))<font></font>
    }<font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinOut</span><span class="hljs-params">(anchor: UnitPoint)</span></span> -&gt; <span class="hljs-type">AnyTransition</span> {<font></font>
        .modifier(<font></font>
            active: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">90</span>, anchor: anchor),<font></font>
            identity: <span class="hljs-type">SpinTransitionModifier</span>(angle: <span class="hljs-number">0</span>, anchor: anchor))<font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/k-/mu/eck-muqydvucs1o59dkbnzpnw6e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para empezar, escribimos el modificador habitual en el que transferimos un cierto n√∫mero: el √°ngulo de rotaci√≥n en grados, as√≠ como el punto en relaci√≥n con el cual se produce esta rotaci√≥n. Luego, ampliamos el tipo AnyTransition con dos funciones. Podr√≠a haber sido uno, pero me pareci√≥ m√°s conveniente. Me result√≥ m√°s f√°cil asignar nombres de voz a cada uno de ellos que controlar los grados de rotaci√≥n directamente en la propia vista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El tipo AnyTransition tiene un m√©todo modificador est√°tico, en el que pasamos dos modificadores, y obtenemos un objeto AnyTransition que describe una transici√≥n suave de un estado a otro. identidad es el modificador de estado normal de la Vista animada. Activo es el estado del comienzo de la animaci√≥n para la apariencia de la vista, o el final de la animaci√≥n para la desaparici√≥n, es decir. el otro extremo del segmento, los estados dentro de los cuales se interpolar√°n.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, spinIn implica que lo usar√© para hacer que la vista aparezca desde fuera de la pantalla (o el espacio asignado para la Vista) girando en sentido horario alrededor del punto especificado. spinOut significa que la vista desaparecer√° de la misma manera, girando alrededor del mismo punto, tambi√©n en sentido horario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seg√∫n mi idea, si usas el mismo punto para la aparici√≥n y desaparici√≥n de la Vista, obtienes el efecto de rotar toda la pantalla alrededor de este punto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toda la animaci√≥n se basa en la mec√°nica de modificaci√≥n est√°ndar. Si escribe un modificador totalmente personalizado, debe implementar los requisitos del protocolo AnimatableModifier, como lo hicimos anteriormente con TwoParameterBorder, o usar los modificadores integrados que proporcionan su propia animaci√≥n predeterminada. En este caso, confi√© en la animaci√≥n incorporada .rotationEffect () dentro de mi modificador SpinTransitionModifier.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El modificador .transition () solo aclara qu√© considerar como el punto inicial y final de la animaci√≥n. Si necesitamos solicitar el estado AnimatableData antes de comenzar la animaci√≥n, para solicitar el modificador AnimatableData del estado actual, calcular la diferencia y luego animar la disminuci√≥n de 1 a 0, entonces .transition () solo cambia los datos originales. No est√° vinculado al estado de su Vista; no est√° basado en √©l. Usted especifica expl√≠citamente el estado inicial y final usted mismo, de ellos obtiene AnimatableData, calcula la diferencia y la anima. Luego, al final de la animaci√≥n, su Vista actual aparece en primer plano.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto, la identidad es un modificador que permanecer√° aplicado a su Vista al final de la animaci√≥n. De lo contrario, un error aqu√≠ conducir√≠a a saltos al final de la animaci√≥n de aparici√≥n y al comienzo de la animaci√≥n de desaparici√≥n. Por lo tanto, la transici√≥n puede considerarse como "dos en uno", aplicando un modificador espec√≠fico directamente a Ver + la capacidad de animar sus cambios cuando la Vista aparece y desaparece. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Honestamente, este mecanismo de control de animaci√≥n me parece muy fuerte, y lamento un poco que no podamos usarlo para ninguna animaci√≥n. No me negar√≠a a tal creaci√≥n de animaci√≥n cerrada sin fin. Sin embargo, hablaremos de eso en el pr√≥ximo art√≠culo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para ver mejor c√≥mo ocurre el cambio en s√≠, reemplac√© nuestra Vista de prueba con cuadrados elementales, firmados con n√∫meros y enmarcados.</font></font><br>
<br>
<pre><code class="swift hljs">                    <span class="hljs-type">Group</span>{
                        <span class="hljs-keyword">if</span> ind == <span class="hljs-keyword">self</span>.currentViewInd{
                            <span class="hljs-comment">//self.views[ind]</span>
                            <span class="hljs-type">Rectangle</span>()<font></font>
                                .fill(<span class="hljs-type">Color</span>.gray)<font></font>
                                .frame(width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)<font></font>
                                .border(<span class="hljs-type">Color</span>.black, width: <span class="hljs-number">2</span>)<font></font>
                                .overlay(<span class="hljs-type">Text</span>(<span class="hljs-string">"\(ind + 1)"</span>))<font></font>
                              .transition(.asymmetric(<font></font>
                                  insertion: .spinIn(anchor: .bottomTrailing),<font></font>
                                  removal: .spinOut(anchor: .bottomTrailing)))<font></font>
                        }<font></font>
                    }</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/4s/u9/vx4su9aoaqzuqzi2wq8uctpxe7c.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y para hacer este movimiento a√∫n mejor, elimin√© .clipped () del modificador SpinTransitionModifier:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpinTransitionModifier</span>: <span class="hljs-title">ViewModifier</span> </span>{
    <span class="hljs-keyword">let</span> angle: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">let</span> anchor: <span class="hljs-type">UnitPoint</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        content<font></font>
            .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle), anchor: anchor)
            <span class="hljs-comment">//.clipped()</span><font></font>
    }<font></font>
}</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/ml/0i/ihml0id6hnttwuhbjuv5s28jhaa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto, ahora necesitamos SpinTransitionModifier en nuestro propio modificador por completo. </font><font style="vertical-align: inherit;">Fue creado solo para combinar los dos modificadores, rotacionEfecto y recortado () en uno, para que la animaci√≥n de rotaci√≥n no vaya m√°s all√° del alcance seleccionado para nuestra Vista. </font><font style="vertical-align: inherit;">Ahora, podemos usar .rotationEffect () directamente dentro de .modifier (), no necesitamos un intermediario en forma de SpinTransitionModifier.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando la vista muere</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un punto interesante es el ciclo de vida Ver si se coloca en un if-else. </font><font style="vertical-align: inherit;">La vista, aunque iniciada y registrada como un elemento de matriz, no se almacena en la memoria. </font><font style="vertical-align: inherit;">Toda ella</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estado</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">los par√°metros se restablecen a los valores predeterminados la pr√≥xima vez que aparecen en la pantalla. Esto es casi lo mismo que la inicializaci√≥n. A pesar del hecho de que la estructura del objeto en s√≠ misma todav√≠a existe, el render lo elimin√≥ de su campo de visi√≥n, ya que no lo es. Por un lado, esto reduce el uso de memoria. Si tiene una gran cantidad de Vistas complejas en la matriz, el renderizado deber√≠a dibujarlas todas constantemente, reaccionando a los cambios, esto afect√≥ negativamente el rendimiento. Si no me equivoco, ese fue el caso antes de la actualizaci√≥n de Xcode 11.3. Ahora, las vistas inactivas se descargan de la memoria de representaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por otro lado, debemos mover todos los estados importantes m√°s all√° del alcance de esta Vista. Para esto, es mejor usar las variables @EnvironmentObject.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Volviendo al ciclo de vida, tambi√©n debe tenerse en cuenta que el modificador .onAppear {}, si est√° registrado dentro de esta Vista, funciona inmediatamente despu√©s de cambiar la condici√≥n y la apariencia de la Vista en la pantalla, incluso antes de que comience la animaci√≥n. </font><font style="vertical-align: inherit;">En consecuencia, onDisappear {} se activa despu√©s del final de la animaci√≥n de desaparici√≥n. </font><font style="vertical-align: inherit;">Tenga esto en cuenta si planea usarlos con animaci√≥n de transici√≥n.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQue sigue? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uf </font><font style="vertical-align: inherit;">Result√≥ bastante voluminoso, pero en detalle y, espero, inteligible. </font><font style="vertical-align: inherit;">Honestamente, esperaba hablar sobre la animaci√≥n del arco iris como parte de un art√≠culo, pero no pude detenerme a tiempo con los detalles. </font><font style="vertical-align: inherit;">As√≠ que espera la continuaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La siguiente parte nos espera:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uso de gradientes: lineal, circular y angular: todo ser√° √∫til</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El color no es color en absoluto: elija sabiamente.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">animaci√≥n en bucle: c√≥mo comenzar y c√≥mo parar, y c√≥mo parar de inmediato (sin animaci√≥n, cambiar la animaci√≥n, s√≠, tambi√©n hay una)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">animaci√≥n de flujo actual: prioridades, anulaciones, animaci√≥n diferente para diferentes objetos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">detalles sobre los tiempos de animaci√≥n: manejaremos los tiempos tanto en la cola como en la melena, hasta nuestra propia implementaci√≥n de timingCurve (oh, mantenme siete :))</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√≥mo averiguar el momento actual de la animaci√≥n reproducida</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si SwiftUI no es suficiente</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hablar√© de todo esto en detalle utilizando el ejemplo de creaci√≥n de animaci√≥n de arco√≠ris, como en la imagen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No tom√© el camino f√°cil, pero recog√≠ todos los rastrillos que pude alcanzar, incorporando esta animaci√≥n en los principios descritos anteriormente. </font><font style="vertical-align: inherit;">La historia sobre esto deber√≠a ser muy informativa y rica en trucos y todo tipo de hacks, sobre los cuales hubo pocos informes, y que ser√°n √∫tiles para aquellos que deciden convertirse en pioneros en SwiftUI. </font><font style="vertical-align: inherit;">Aparecer√° aproximadamente en una semana o dos. </font><font style="vertical-align: inherit;">Por cierto, puedes suscribirte para no perderte. </font><font style="vertical-align: inherit;">Pero esto, por supuesto, solo si el material le parece √∫til y se aprueba el m√©todo de presentaci√≥n. </font><font style="vertical-align: inherit;">Luego, su suscripci√≥n ayudar√° a llevar r√°pidamente nuevos art√≠culos a la cima, llev√°ndolos a un p√∫blico m√°s amplio desde el principio. </font><font style="vertical-align: inherit;">De lo contrario, escriba en los comentarios lo que est√° mal.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es504186/index.html">Paul Graham: C√≥mo escribir textos √∫tiles (completo)</a></li>
<li><a href="../es504188/index.html">Cuarentena, sistemas en l√≠nea y ciencia de datos. ¬øQui√©n piensa en la retenci√≥n de clientes?</a></li>
<li><a href="../es504190/index.html">MVCC como una forma de garantizar el aislamiento de la transacci√≥n</a></li>
<li><a href="../es504194/index.html">El resultado de una encuesta de desarrolladores en Stack Overflow 2020 (+ habraopros)</a></li>
<li><a href="../es504196/index.html">NFC: an√°lisis de la tecnolog√≠a de comunicaci√≥n de campo cercano</a></li>
<li><a href="../es504204/index.html">Talleres de IBM: Quarkus (Ultrafast Java for Microservices), Jakarta EE y OpenShift</a></li>
<li><a href="../es504208/index.html">C√≥mo automatizar un centro de servicio compartido</a></li>
<li><a href="../es504210/index.html">¬øQu√© es Deno y reemplazar√° a Node.js?</a></li>
<li><a href="../es504214/index.html">El desarrollo de DATA VAULT y la transici√≥n a BUSINESS DATA VAULT</a></li>
<li><a href="../es504216/index.html">¬øCu√°ntos a√±os tiene esta casa? C√≥mo hice un mapa de la edad de las casas en San Petersburgo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>