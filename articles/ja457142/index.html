<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🚒 🍡 🌷 RectTransformUtility、または画面の背後にあるUI要素をアニメーション化するコンポーネントの作成方法 🖖 🚉 🥢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前回の記事-Unity3d GUIで使用されるさまざまな座標について、Unity UI / RectTransformでのさまざまな座標について簡単に説明しました。ここで、RectTransformUtilityのようなUIに少し便利なことを強調します。これは、UIで何かを他の何かと比較して計算する...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>RectTransformUtility、または画面の背後にあるUI要素をアニメーション化するコンポーネントの作成方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457142/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前回の記事</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-Unity3d GUIで使用されるさまざまな</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">座標について、Unity UI / RectTransformでのさまざまな座標について簡単に説明しました。</font><font style="vertical-align: inherit;">ここで、RectTransformUtilityのようなUIに少し便利なことを強調します。</font><font style="vertical-align: inherit;">これは、UIで何かを他の何かと比較して計算するための主要なツールの1つです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡単な挑戦</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクがあります-選択した画面の端を超えてUI要素をアニメーションで削除するコンポーネントが必要です。</font><font style="vertical-align: inherit;">コンポーネントは、階層的に配置されている場所、アンカーの場所、画面のサイズ、画面の場所に紫である必要があります。</font><font style="vertical-align: inherit;">コンポーネントは、オブジェクトを4面（上、下、左、右）で一定時間クリーニングできる必要があります。</font></font><br>
<a name="habracut"></a><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考え</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
原則として、これはどのように行うことができますか？</font><font style="vertical-align: inherit;">オブジェクトの座標で画面のサイズを確認し、オブジェクトを画面の端を超えた座標に移動すると、帽子の中にあるように見えます。</font><font style="vertical-align: inherit;">しかし、いくつ</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">かありますが、UIに対する画面座標をどのようにして知ることができますか？</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
額をググったら、意味のない、役に立たないことや、答えのない質問までググってみてください。</font><font style="vertical-align: inherit;">最も似ているのは、画面の座標に存在するカーソルに追随するUI要素がある場合です。</font></font><br>
<br>
<pre><code class="java hljs">RectTransformUtility.ScreenPointToLocalPointInRectangle(canvas, <span class="hljs-keyword">new</span> Vector2(Input.mousePosition), <span class="hljs-keyword">null</span>, out topRightLocalCoord);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは、RectTransformUtilityとScreenPointToLocalPointInRectangleです。ここでは、画面上のポイントの位置に基づいて、rect（RectTransform）内のローカル座標を取得します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在の例では、マウスカーソルのローカル座標を見つけました。それらを画面の端に置き換える必要があります。</font></font><br>
<br>
<pre><code class="java hljs">RectTransformUtility.ScreenPointToLocalPointInRectangle(canvas, <span class="hljs-keyword">new</span> Vector2(Screen.width, Screen.height), <span class="hljs-keyword">null</span>, out topRightLocalCoord);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、画面の右上の点の座標を取得して、オブジェクトが画面の右側に移動するようにします。オブジェクトはこの点よりも遠いはずです+長方形の幅または指定されたインデントとしましょう。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり、最初のニュアンス：</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
キャンバス内のオブジェクトに直接適したローカル座標を取得しました。シフトする川が別の四角形にある場合、そのローカル座標はキャンバスではなく親を基準と見なされます。つまり、これらの座標自体は私たちには合いません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つの方法があります。1つ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はグローバル座標を使用する</font><b><font style="vertical-align: inherit;">方法</font></b><font style="vertical-align: inherit;">、</font><b><font style="vertical-align: inherit;">もう</font></b><font style="vertical-align: inherit;"> 1 </font><b><font style="vertical-align: inherit;">つ</font></b><font style="vertical-align: inherit;">はグローバル座標を使用する</font><b><font style="vertical-align: inherit;">方法</font></b><font style="vertical-align: inherit;">です。または、各四角形のローカル座標で画面の座標を個別に計算します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のケース、つまり</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローカル座標をグローバル座標に変換する方法を</font><b><font style="vertical-align: inherit;">検討してください</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどのgoogledメソッドはTransformPointを使用します。</font></font><br>
<br>
<pre><code class="java hljs">transform.position = myCanvas.transform.TransformPoint(pos);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ローカル座標をグローバル座標に変換します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では、RectTransformUtilityには、グローバルポジションをすぐに返すScreenPointToWorldPointInRectangleメソッドがあるため、これは一般に追加の手順です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画面の右端を超えて四角形をシフトする必要があります。これは、見つかった位置からX座標を取得し、Yは移動した四角形をそのままにして、単純に右に移動するようにします。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">new</span> Vector3(topRightCoord.x+offset, rectTransform.position.y, <span class="hljs-number">0</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果の座標はDoTweenによって提供されます。</font></font><br>
<br>
<pre><code class="java hljs">rectTransform.DOMove(<span class="hljs-keyword">new</span> Vector3(correctedTargetRight.x, rectTransform.position.y, <span class="hljs-number">0</span>), timeForHiding);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、万歳、オブジェクトは右に去ります。しかし...第</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2のニュアンス</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ここで、実際には、rectの位置がrectピボットに依存していることがわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/5p/6_/bf5p6_dcykozhdxi21bfc0y8lxi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、オブジェクトはピボットに応じて配置された状態で踊ることができます。さらに、オブジェクトが非常に大きくなり、オフセットによって画面の後ろに完全に押し出されないため、ピースが飛び出す可能性が常にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、四角形+ピボットのサイズを考慮に入れて、オフセット補正をねじ込む必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のニュアンスは、四角形のサイズでオブジェクトを移動することです。ローカル座標またはアンカー座標を知る必要があり、グローバル座標を取得します。グローバル座標を取得してローカルUI座標に変換したり、アンカー座標に固定したりすることはできないことをすぐに言っておく必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は次の松葉杖を思いつきました、私たちは四角形の開始位置を覚えて、それを最終的なグローバル位置に移動し、アンカー位置を四角形のサイズだけ右にシフトし、オブジェクトのサイズを考慮してオフセットを考慮したグローバル位置を覚えて、そしてそれをくぼみでフィードし、元に戻ることを忘れないでくださいポジション。 </font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード例</font></font></b><div class="spoiler_text"><pre><code class="java hljs"> <span class="hljs-keyword">var</span> targetRight = <span class="hljs-keyword">new</span> Vector3(topRightLocalCoord.x, rectTransform.position.y, <span class="hljs-number">0</span>);<font></font>
                rectTransform.position = targetRight;<font></font>
                rectTransform.anchoredPosition += rectTransform.sizeDelta;<font></font>
                <span class="hljs-keyword">var</span> correctedTargetRight = rectTransform.position;<font></font>
                rectTransform.localPosition = startPoint;<font></font>
                rectTransform.DOMove(<span class="hljs-keyword">new</span> Vector3(correctedTargetRight.x, rectTransform.position.y, <span class="hljs-number">0</span>), timeForHiding);</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
巨大な松葉杖のように見えますが、この松葉杖を使用すると、グローバル座標やその他の座標を同期できます。</font><font style="vertical-align: inherit;">これは、相互に移動するオブジェクトがインターフェースにあり、それらが異なる階層にある場合に役立ちます。</font><font style="vertical-align: inherit;">まあ、これまでのところ、これはグローバルから正しい座標を取得するために私が見つけた唯一の方法です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点で、松葉杖にはノーと言って、ローカル座標で画面サイズを取得するという考えに戻ります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二番目の方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の方法は、各四角形の画面サイズを個別に取得することです。これにより、キャンバスや階層に関係なく、画面の端のローカル座標がわかります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三のニュアンス</font></font></b><br>
<br>
<pre><code class="java hljs">RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, <span class="hljs-keyword">new</span> Vector2(Screen.width, Screen.height), <span class="hljs-keyword">null</span>, out topRightCoord);<font></font>
        RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-keyword">null</span>, out bottomScreenCoord);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画面全体を覆うキャンバスとは異なり、オブジェクトは画面上のどこにでも配置できます。したがって、画面の左端と右端までの距離が大幅に異なる場合があります。キャンバスの場合、右上の端だけがあり、右上を引くと左上になります。この場合、コード例に示すように、左下と右上のポイントを個別に取得する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4番目のニュアンス</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ローカル座標は、親の中心を基準にしたオフセットです。長方形がキャンバスの小さな部分を占める別の長方形に埋め込まれている場合、両方の変位を考慮した座標が必要です。まあ、すべてが単純です。</font></font><br>
<br>
<pre><code class="java hljs">((Vector3)bottomLeftCoord + rectTransform.localPosition) </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ベクトルを追加して、必要な座標を取得します。</font><font style="vertical-align: inherit;">これは、グローバル座標を使用する場合よりも混乱しますが、四角形のサイズに関連する計算を実行できるようになりました。</font><font style="vertical-align: inherit;">そして最後に、松葉杖なしで静かに補償を追加します。</font></font><br>
<br>
<pre><code class="java hljs"> (Vector3)topRightCoord + rectTransform.localPosition + (<span class="hljs-keyword">new</span> Vector3((rectTransform.sizeDelta.x * rectTransform.pivot.x) + rectTransform.sizeDelta.x, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、四角形の幅を補正し、画面を超えて四角形の幅にシフトして、右にシフトする場合の座標です。オフセットを設定する方法はありません。後で追加する予定ですが、誰かがこれを自分で書いてみることに興味があると思います。 </font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UI要素については、ローカル座標またはアンカー座標を使用することをお勧めします。それらを理解するようにしてください。</font><font style="vertical-align: inherit;">グローバル座標は、特別な場合に使用できますが、たとえば、四角形のサイズや他の多くのマイクロエピソードでうまく機能することができません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RectTransformUtilityを確認する必要があります。UIには多くの便利な機能があり、四角形の内部および周囲の位置に関連するすべての計算はそれを介して行われます。 </font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、コンポーネント自体です。誰かがそれをいじりたければ、DoTweenが必要になります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成分</font></font></b><div class="spoiler_text"><pre><code class="java hljs">using DG.Tweening;<font></font>
using UnityEngine;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Direction { DEFAULT, RIGHT, LEFT, TOP, BOTTOM }
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> CanvasType {OVERLAY, CAMERATYPE}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HideBeyondScreenComponent</span> : <span class="hljs-title">MonoBehaviour</span>
</span>{<font></font>
    [SerializeField] <span class="hljs-keyword">private</span> Direction direction;<font></font>
    [SerializeField] <span class="hljs-keyword">private</span> CanvasType canvasType;<font></font>
    [SerializeField] <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> timeForHiding = <span class="hljs-number">1</span>;<font></font>
    [SerializeField] <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> offset = <span class="hljs-number">50</span>;
    <span class="hljs-keyword">private</span> Vector3 startPoint;
    <span class="hljs-keyword">private</span> RectTransform rectTransform;
    <span class="hljs-keyword">private</span> Vector2 topRightCoord;
    <span class="hljs-keyword">private</span> Vector2 bottomLeftCoord;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span>
    </span>{<font></font>
        rectTransform = transform as RectTransform;<font></font>
        startPoint = rectTransform.localPosition;<font></font>
        Camera camera = <span class="hljs-keyword">null</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (canvasType == CanvasType.CAMERATYPE)<font></font>
            camera = Camera.main;<font></font>
<font></font>
        RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, <span class="hljs-keyword">new</span> Vector2(Screen.width, Screen.height), camera, out topRightCoord);<font></font>
        RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), camera, out bottomLeftCoord);<font></font>
        Hide();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span>
    </span>{<font></font>
        rectTransform.DOLocalMove(startPoint, timeForHiding);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Hide</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">switch</span> (direction)<font></font>
        {<font></font>
            <span class="hljs-keyword">case</span> Direction.LEFT:<font></font>
                rectTransform.DOLocalMove(<span class="hljs-keyword">new</span> Vector3(EndPosition(Direction.LEFT).x, rectTransform.localPosition.y, <span class="hljs-number">0</span>), timeForHiding);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> Direction.RIGHT:<font></font>
                rectTransform.DOLocalMove(<span class="hljs-keyword">new</span> Vector3(EndPosition(Direction.RIGHT).x, rectTransform.localPosition.y, <span class="hljs-number">0</span>), timeForHiding);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> Direction.TOP:<font></font>
                rectTransform.DOLocalMove(<span class="hljs-keyword">new</span> Vector3(rectTransform.localPosition.x, EndPosition(Direction.TOP).y, <span class="hljs-number">0</span>), timeForHiding);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> Direction.BOTTOM:<font></font>
                rectTransform.DOLocalMove(<span class="hljs-keyword">new</span> Vector3(rectTransform.localPosition.x, EndPosition(Direction.BOTTOM).y, <span class="hljs-number">0</span>), timeForHiding);
                <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> Vector3 <span class="hljs-title">NegativeCompensation</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector2((-rectTransform.sizeDelta.x - offset) + rectTransform.sizeDelta.x * rectTransform.pivot.x,<font></font>
                        (-rectTransform.sizeDelta.y - offset) + rectTransform.sizeDelta.y * rectTransform.pivot.y);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> Vector3 <span class="hljs-title">PositiveCompensation</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector2((rectTransform.sizeDelta.x * rectTransform.pivot.x) + offset,<font></font>
                                (rectTransform.sizeDelta.y * rectTransform.pivot.y) + offset);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> Vector2 <span class="hljs-title">EndPosition</span><span class="hljs-params">(Direction direction)</span>
    </span>{
        <span class="hljs-keyword">switch</span> (direction)<font></font>
        {<font></font>
            <span class="hljs-keyword">case</span> Direction.LEFT:
                <span class="hljs-keyword">return</span> ((Vector3)bottomLeftCoord + rectTransform.localPosition) + NegativeCompensation();
            <span class="hljs-keyword">case</span> Direction.RIGHT:
                <span class="hljs-keyword">return</span> (Vector3)topRightCoord + rectTransform.localPosition + PositiveCompensation();
            <span class="hljs-keyword">case</span> Direction.TOP:
                <span class="hljs-keyword">return</span> ((Vector3)topRightCoord + rectTransform.localPosition) + PositiveCompensation();
            <span class="hljs-keyword">case</span> Direction.BOTTOM:
                <span class="hljs-keyword">return</span> ((Vector3)bottomLeftCoord + rectTransform.localPosition) + NegativeCompensation();<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> startPoint;<font></font>
    }<font></font>
}</code></pre><br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja457128/index.html">状況：AdTech企業はGDPRに違反していますか？</a></li>
<li><a href="../ja457132/index.html">実際に代替品をインポートします。パート3.1。「QP OS」。オペレーティングシステムのその類のレビューの最初</a></li>
<li><a href="../ja457134/index.html">脳は知覚を加速させ、次に何が起こるかを推測します</a></li>
<li><a href="../ja457138/index.html">金曜日の投稿：女の子が大好きな質問</a></li>
<li><a href="../ja457140/index.html">アメリカの携帯電話会社でアカウントの無限の可能性のある補充を偶然発見したので</a></li>
<li><a href="../ja457144/index.html">誰も必要としないエミュレータを作成</a></li>
<li><a href="../ja457150/index.html">新しいWindowsターミナルがMicrosoftストアで入手可能に</a></li>
<li><a href="../ja457152/index.html">DEFCON 25カンファレンス。GarryKasparov。「最後の脳の戦い」パート1</a></li>
<li><a href="../ja457154/index.html">すべてのユーザー向けのレスポンシブなアプリ設計</a></li>
<li><a href="../ja457156/index.html">将来のコンピューティングシステムは何か</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>