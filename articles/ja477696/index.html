<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏿 👩🏻‍🎤 👩‍💼 TLS 1.3に基づくフロントエンドドメイン。パート2 🛰️ 🍏 😴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前書き
記事の 最初の部分では、暗号化されたSNI（eSNI）メカニズムについて簡単に説明しました。彼らはそれに基づいて、（Beeline DPIおよび禁止されたILV rutrackerを例として使用する）最新のDPIシステムによる検出を回避できること、およびこのメカニズムに基づいたドメインフロン...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>TLS 1.3に基づくフロントエンドドメイン。パート2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477696/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h3><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
最初の部分で</font><font style="vertical-align: inherit;">は、暗号化されたSNI（eSNI）メカニズムについて簡単に説明しました。彼らはそれに基づいて、（Beeline DPIおよび禁止されたILV rutrackerを例として使用する）最新のDPIシステムによる検出を回避できること、およびこのメカニズムに基づいたドメインフロントエンドの新しいバージョンを探ることができることを示しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の第2部では、RedTeamが難しい作業のスペシャリストに役立つ、より実用的なものに移ります。結局のところ、私たちの目標は、ブロックされたリソースへのアクセスを得ることではありません（そのようなありふれたことについては、古き良きVPNがあります）。幸いなことに、彼らが言うように、あらゆる好み、色、予算に対応するVPNプロバイダーは非常にたくさんあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cobalt Strike、Empireなどの最新のRedTeamツールにドメイン前面のメカニズムを適用して、最新のコンテンツフィルタリングシステムを模倣して回避するための追加の機会を提供します。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前回、OpenSSLライブラリにeSNIメカニズムを実装し、使い慣れたcurlユーティリティで正常に使用しました。しかし、彼らが言うように、1つのカールは完全ではありません。もちろん、私は高級言語で同様のものを実装したいと思っています。しかし、残念なことに、eSNIメカニズムのサポートはGOLANGでのみ完全に実装されているため、ネットワークの広大さをざっと検索すると失望します。したがって、私たちの選択はそれほど大きくありません。パッチを当てたOpenSSLライブラリを使用して純粋なCまたはC ++で書き込むか、CloudFlareから別のGOLANGフォークを使用してツールをそこに移植しようとします。原則として、より古典的ですが同時に時間がかかる別のオプションがあります。それは、PythonのeSNIサポートを実装することです。結局のところ、PythonはOpenSSLを使用してhttpsと連携します。ただし、このオプションは開発のために他の人に任せます。特に、私たちの愛するCobalt Strikeがサードパーティツールによって構築された通信チャネル（外部C2チャネル）と完全に連携できるため、この記事の最後で説明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もっと頑張って...</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goに実装されているツールの1つは、ネットワーク内でピボットするための開発です-rsockstun </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">チューナー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ちなみに、現在、MicrosoftとSymantecのツールによって、世界の安定性に違反することを目的とした非常に悪意のあるソフトウェアとして検出されています... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fg/mu/z4/fgmuz4c7bq1aazvf6su5qjbh32o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前の開発をこの場合。</font><font style="vertical-align: inherit;">しかし、ここで小さな問題が発生します。</font><font style="vertical-align: inherit;">実際には、rsockstunは最初にサーバーとの同期SSL通信チャネルの使用を意味します。</font><font style="vertical-align: inherit;">これは、接続が一度確立され、トンネル操作の全期間にわたって存在することを意味します。</font><font style="vertical-align: inherit;">そして、あなたが理解しているように、httpsプロトコルはこの動作モード用に設計されていません-新しいTCPリクエストが新しいTCP接続のフレームワーク内に存在するリクエストレスポンスモードで動作します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方式の主な欠点は、クライアントが新しいhttp要求を送信するまで、サーバーがクライアントにデータを転送できないことです。しかし、幸いにも、この問題を解決するための多くのオプションがあります-httpプロトコルを介してデータをストリーミングします（結局、お気に入りのテレビ番組を見て、httpsで実行されているポータルから音楽を聞くことができますが、ビデオとオーディオの伝送はそれではありませんストリーミングデータ以外）。 httpプロトコルを介した本格的なtcp接続の操作をエミュレートするテクノロジーの1つは、WebSocketsテクノロジーです。このテクノロジーの主な本質は、クライアントとWebサーバー間の本格的なネットワーク接続を編成することです。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの運に（フーレイフーレイ!!!）、このテクノロジーはすべてのCloudFlare料金プランにデフォルトで含まれており、eSNIとの組み合わせでうまく機能します。</font><font style="vertical-align: inherit;">これはまさに、ドメインフロントを使用し、最新のDPIから隠すようにトンネルを教えるために使用するものです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WebSocketについて少し</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず最初に、私たちは簡単かつ簡単にWebソケットについて話しますので、誰もが私たちが何を扱うかについての考えを持っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Webソケットテクノロジーを使用すると、確立されたTCP接続を切断せずに、ネットワークソケットを介して一時的にhttp接続から標準ストリーミングデータに切り替えることができます。クライアントがWebソケットに切り替えたい場合、httpリクエストにいくつかのhttpヘッダーを設定します。必要なヘッダーは、</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connection：Upgrade</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Upgrade：websocketの</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2つです</font><font style="vertical-align: inherit;">。また、websocketプロトコルバージョン（</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sec-Websockset-Version：13</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）や、base64 Webソケット識別子（</font><i><b><font style="vertical-align: inherit;">Sec-WebSocket-Key：DAGDJSiREI3 + KjDfwxm1FA ==</font></b></i><font style="vertical-align: inherit;">など）を</font><font style="vertical-align: inherit;">強制することもでき</font><font style="vertical-align: inherit;">ます。</font></font><i><b><font style="vertical-align: inherit;"></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）サーバーはhttp-code 101 Switching Protocolsで応答し、</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connection、Upgrade</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sec-WebSocket-Accept</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘッダーも設定し</font><i><b><font style="vertical-align: inherit;">ます</font></b></i><font style="vertical-align: inherit;">。切り替えプロセスは、下のスクリーンショットに明確に示されています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ci/tp/bg/citpbgee5m4fyv9-w5akwwq5t8q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、WebSocket接続は完了したと見なすことができます。これで、クライアントとサーバーの両方からのデータは、httpではなくWebSocketヘッダー（バイト0x82で始まる）で提供されます。これで、サーバーはデータを転送するためにクライアントからの要求を待つ必要がなくなりました。 tcp接続は切断されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Webソケットgolanにはいくつかのライブラリがあります。最も人気のあるものは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gorilla WebSocket</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と標準の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WebSocketです。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。後者を使用します。彼らが言うように、それはよりシンプルで、より小さく、うまくいく。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
rsockstunクライアントコードでは、net.dialまたはtls.dial呼び出しを対応するWebSocket呼び出しに置き換える必要が</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ye/dw/vy/yedwvync3yktwhl_ssd2vm8eniy.png"><br>
<br>
<img src="https://habrastorage.org/webt/mw/j3/fw/mwj3fwfivbj7aqqsbg7whlkt9ai.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あります。トンネルのクライアント部分をユニバーサルにして、直接ssl接続とWebSocksetプロトコルの両方で機能できるようにしたいと考えています。これを行うには、</font><i><b><font style="vertical-align: inherit;">connectForSocks（）</font></b></i><font style="vertical-align: inherit;">との</font><font style="vertical-align: inherit;">類推により</font><font style="vertical-align: inherit;">、別の関数</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">func connectForWsSocks（アドレス文字列、プロキシ文字列）エラー{...}を作成</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">、クライアントの起動時に指定されたサーバーアドレスがws：またはwss：（Secure WebSocketの場合）。</font></font><i><b><font style="vertical-align: inherit;"></font></b></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トンネルのサーバー側では、Webソケットを操作するための別の関数も作成します。</font><font style="vertical-align: inherit;">その中にhttpクラスのインスタンスが作成され、http接続ハンドラー（wsHandler関数）が設定されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2a/r7/cv/2ar7cvjzjc7wauwsb45ursxie2q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、すべての接続処理ロジック（パスワードによるクライアント認証、yamuxセッションの設定と終了）をWebSocket接続ハンドラーに配置します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6r/kz/ay/6rkzays7haarsd9vyhak3xe4kbw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトをコンパイルし、サーバーパーツを起動します。</font></font><br>
<br>
<pre><code class="go hljs">./rsockstun –listen ws:<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> –pass P@ssw0rd</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてクライアント部分：</font></font><br>
<br>
<pre><code class="go hljs">./rsockstun -connect ws:<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span> –pass P@ssw0rd</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ローカルホストでの作業を確認します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ci/tl/jh/citljhc7govgdkorfy6xm--c-dw.png"><br>
<br>
<img src="https://habrastorage.org/webt/cp/6m/mu/cp6mmuhm2xk5iaupu2wh0kato2s.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドメイン前線に移る</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはWebソケットの扱い方を理解しました。次に、eSNIとドメインのフロントエンドに直接移動します。前述のように、DoHとeSNIを操作するには、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CloudFlare</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からgolangの特別なブランチを取得する必要があり</font><font style="vertical-align: inherit;">ます。 eSNIをサポートするブランチ（pwu / esni）が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ローカルにクローンするか、対応するzipをダウンロードして展開します。</font></font><br>
<br>
<pre><code class="plaintext hljs">git clone -b pwu/esni https://github.com/cloudflare/tls-tris.git</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、GOROOTディレクトリをコピーし、クローンされたブランチから対応するファイルを置き換えて、メインのブランチとして設定する必要があります。</font><font style="vertical-align: inherit;">この頭痛の種から開発者を救うために、CloudFlareのスタッフは特別なスクリプト_dev / go.shを用意しました。</font><font style="vertical-align: inherit;">実行するだけです。</font><font style="vertical-align: inherit;">スクリプトとmakefileはすべて自分で行います。</font><font style="vertical-align: inherit;">楽しみのために-あなたは詳細のためにメイクファイルの中を見ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スクリプトを作成した後、プロジェクトをコンパイルするときに、スクリプトによって準備されたローカルディレクトリをGOROOTとして指定する必要があります。</font><font style="vertical-align: inherit;">私たちの場合は、次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">GOROOT="/opt/tls-tris/_dev/GOROOT/linux_amd64" go build ….</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、目的のドメインの公開eSNIキーを要求および解析する機能をトンネルに実装する必要があります。</font><font style="vertical-align: inherit;">私たちの場合、これらはCloudFlareフロントエンドサーバーからの公開eSNIキーになります。</font><font style="vertical-align: inherit;">これを行うには、3つの関数を作成します。</font></font><br>
<br>
<pre><code class="plaintext hljs">func makeDoTQuery(dnsName string) ([]byte, error)<font></font>
func parseTXTResponse(buf []byte, wantName string) (string, error)<font></font>
func QueryESNIKeysForHost(hostname string) ([]byte, error)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能の名前は、原則としてそれ自体でわかります。 tls-trisの一部であるesni_query.goファイルから入力を取得します。最初の関数は、DoHプロトコル（DNS-over-HTTPS）を使用してCloudFlare DNSサーバーへのクエリを含むネットワークパケットを作成し、2番目の関数はクエリ結果を解析してパブリックドメインキーの値を受け取り、3番目は最初の2つのコンテナです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、</font><font style="vertical-align: inherit;">ドメインのeSNIキー要求の</font><font style="vertical-align: inherit;">機能を、Webソケットの</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">connectForWsSocks</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用に新しく作成した接続関数に</font><i><b><font style="vertical-align: inherit;">導入し</font></b></i><font style="vertical-align: inherit;">ます。サーバー部分が機能する場所で、TLSパラメータを設定し、偽の「カバードメイン」の名前も設定します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s0/kk/vu/s0kkvu24eh0wc7olaeffffknrck.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、最初に、tls-trisブランチはドメイン前面を使用するように設計されていなかったことに注意してください。したがって、サーバーの偽の名前には注意を払いません（client-helloパッケージの一部として空のserverNameフィールドが送信されます）。これを修正するには、対応するFakeServerNameフィールドをTlsConfig構造に追加する必要があります。構造の標準のServerNameフィールドは使用できません。これは内部のtlsメカニズムによって使用され、元のtlsメカニズムと異なる場合、tls-handshakeはエラーで終了します。 TlsConfig構造体の説明は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tls / common.goファイルに</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">含まれてい</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;"> -修正する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pu/2l/f4/pu2lf425co5cex8zfa-h2ewdbw8.png"><br>
<br>
<img src="https://habrastorage.org/webt/q1/jk/2i/q1jk2iiwpohss6nhr1uanlnkqp8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、</font><font style="vertical-align: inherit;">TLSハンドシェイクを生成するときにFakeServerNameフィールドを使用</font><font style="vertical-align: inherit;">するには、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tls / handshake_client.go</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイル</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">変更を加える必要が</font><font style="vertical-align: inherit;">あります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fy/nq/ln/fynqlnmskvfz0exd4im58vzpwfi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで全部です！プロジェクトをコンパイルして作業を確認できます。ただし、テストを実行する前に、CloudFlareアカウントを構成する必要があります。まあ、どうやって設定するのですか-cloudflareアカウントを作成し、それにドメインをバインドするだけです。 DoH、WebSocket、ESNIに関連するすべてのチップは、デフォルトでCloudFlareに含まれています。 DNSレコードが更新された後、eSNIキー要求を実行してドメインを確認できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">dig +short txt _esni.df13tester.info </code></pre><br>
<img src="https://habrastorage.org/webt/xh/9a/6g/xh9a6gmmlc1jg-deqesdliip09a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドメインに似たものが見つかれば、すべてがうまくいき、テストに進むことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえばDigitalOceanでUbuntu VPSを起動します。 PS今回のケースでは、プロバイダーが発行したばかりのVPS IPアドレスがILVブラックリストに含まれていました。同様のことが起こっても驚かないでください。 VPNを使用してVPSにアクセスする必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイルされたrsockstunをVPSにコピーします（ちなみに、これはgolangのもう1つの魅力です-プロジェクトを自分でコンパイルして任意のLinuxで実行し、システムのビット容量のみを監視できます）。サーバー部分を実行し、</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kx/-w/th/kx-wth7rif35is4bd5_flfmkjzq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次にクライアント部分</font><font style="vertical-align: inherit;">を実行します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sf/er/7d/sfer7dpqq1lumfaxmzzxn1n_pfs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、クライアントはWebソケットを使用してCloudFlareフロントエンドサーバー経由でサーバーに正常に接続しました。トンネルがトンネルと同じように機能することを確認するには、サーバーでローカルsocks5を開いてcurlリクエストを作成します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qg/na/ti/qgnati8zvd8jc9okh4bei0kbihm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、通信チャネルでDPIが確認する内容を見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0p/ph/av/0pphavhdhhnrtfxfkzxsf7vjcxs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、トンネルチューナーがDoHメカニズムを使用して、宛先ドメインのeSNIキーのCloudflare DNSサーバーに接続します（パッケージ番号1〜19）。次に、フロントエンドサーバーに接続してTLS接続を確立し、ドメイン</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.google.comの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背後に隠します</font><font style="vertical-align: inherit;">（これは、クライアントの起動時に偽のドメインが設定されていない場合のデフォルト値です）。偽のドメインを指定するには、-fronfDomainパラメーターを使用する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zp/8l/0_/zp8l0_a_cktaz6rrrgao4qo8c2g.png"><br>
<br>
<img src="https://habrastorage.org/webt/cq/gn/wn/cqgnwnp9bzo7hzjpb8gcgvqfd6i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一つ。デフォルトでは、CloudFalreのアカウント設定はフレキシブルSSLに設定されています。つまり、クライアントからCloudflareフロントエンドサーバーへのhttpsリクエストは、暗号化されていない（http）形式でサーバーにリダイレクトされます。そのため、トンネルのサーバー部分を非SSLモード（-listen ws：0.0.0.0）で起動し、（-listen wss：0.0.0.0）では起動しませんでした。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4j/fy/5n/4jfy5nl5csmeqc6bxd7vbgdhm7a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全暗号化モードに切り替えるには</font><font style="vertical-align: inherit;">、サーバーにこの証明書が存在する場合は、</font><font style="vertical-align: inherit;">[ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font><font style="vertical-align: inherit;">[ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全]（厳密）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">選択する必要があり</font><font style="vertical-align: inherit;">ます。モードを切り替えると、httpsプロトコルを介してCloudFlareからの接続を受け入れることができるようになります。トンネルのサーバー側の自己署名証明書を生成することを忘れないでください。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ou/9x/9i/ou9x9ihogwotva8y-xwda5v12ps.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不愉快な読者は、次のように尋ねます。</font><font style="vertical-align: inherit;">実際、確かに、トンネルの主な用途は、企業のマシンやサーバーからのバックコネクトを発生させることであり、原則として常にWindowsです。</font><font style="vertical-align: inherit;">Windows用のトンネルをコンパイルするには、特定のTLSスタックを使用してどうすればよいですか？」</font><font style="vertical-align: inherit;">次に、golangがいかに便利かを示す別のチップを紹介します。</font><font style="vertical-align: inherit;">GOOS = windowsパラメータを追加するだけで、Kaliから直接Windows用にコンパイルします。</font></font><br>
<br>
<pre><code class="plaintext hljs">GOARCH=amd64 GOROOT="/opt/tls-tris/_dev/GOROOT/linux_amd64" GOOS=windows  go build -ldflags="-s -w"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または32ビットオプション：</font></font><br>
<br>
<pre><code class="plaintext hljs">GOARCH=386 GOROOT="/opt/tls-tris/_dev/GOROOT/linux_amd64" GOOS=windows  go build -ldflags="-s -w"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべて！</font><font style="vertical-align: inherit;">そして、これ以上のトラブルは必要ありません。</font><font style="vertical-align: inherit;">それは実際に動作します！</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hq/cc/qf/hqccqf4y2sim1yutlrdduo3kmom.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラフラグ–wおよび–sは、実行可能ファイルから余分なゴミを削除して数メガバイト削減するために必要です。</font><font style="vertical-align: inherit;">さらに、UPXを使用してパッケージ化し、サイズをさらに小さくすることができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論の代わりに</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、golangで記述されたチューナーの例を使用して、TLS 1.3プロトコルのかなり興味深い機能に実装された、ドメイン前面処理の新しいテクノロジーの使用を明確に示しました。同様に、あなたは、例えば、CloudFlareのサーバーを介して仕事に既存のgolangツールを適応させることができ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マーリン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、よく知られているC2、または経由Teamserverで作業するときeSNIドメイン前線を使用するようにCobaltStrikeビーコンを強制</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外部C2チャンネル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、golang上、または標準C ++使用して実装しますOpenSSLのパッチバージョン。記事の最後の部分で説明しました。一般的に、ファンタジーには制限がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トンネルとCloudFlareの例は概念の形で提示されており、このタイプのドメイン前面に面した遠い将来についてはまだ言い難いです。</font><font style="vertical-align: inherit;">現時点では、eSNIサポートはCloudFlareでのみ実装されており、理論的には、この種のフロントエンドを無効にして、たとえばSNIとeSNIが一致しない場合にtls接続を切断することを妨げるものはありません。</font><font style="vertical-align: inherit;">一般的に、将来が表示されます。</font><font style="vertical-align: inherit;">しかし今のところ、kremlin.ruのカバーの下で作業する見通しは非常に魅力的です。</font><font style="vertical-align: inherit;">そうではありませんか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更新されたトンネルコードとコンパイルされた実行可能exeファイルは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">githubの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別のプロジェクトブランチにあり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">GitHubのプロジェクトページで、考えられるすべてのトンネルの問題について書くことをお勧めします。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja477682/index.html">インフラストラクチャ内のレガシーサービス</a></li>
<li><a href="../ja477686/index.html">私たちのAIジャーニー会議</a></li>
<li><a href="../ja477688/index.html">12月のITイベントダイジェスト</a></li>
<li><a href="../ja477692/index.html">本番環境でZGCとShenandoah GCを使用した経験</a></li>
<li><a href="../ja477694/index.html">JavaScriptを何かで置き換える必要はありません-他の言語も同じ問題に直面します</a></li>
<li><a href="../ja477700/index.html">ハリウッド原則（IoC）</a></li>
<li><a href="../ja477704/index.html">CodeSide。有名なロシアAIカップ大会の新しいゲーム</a></li>
<li><a href="../ja477706/index.html">HTTPSからのダウンロード時の混合コンテンツ：見つけて克服する方法</a></li>
<li><a href="../ja477710/index.html">彼らが学校で教えていないこと：テクニカルサポートエンジニアのトレーニング方法</a></li>
<li><a href="../ja477712/index.html">オブジェクトとデータ構造</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>