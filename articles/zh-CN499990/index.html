<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👁‍🗨 🐳 🌗 地理编码 如何在10分钟内将25万个地址绑定到坐标？ 👼🏼 🔳 👣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！
 
 在本文中，我将分享我在解决大量地址小的问题方面的经验。如果您曾经使用过地理编码API或使用过在线工具，那么我认为您要等几个小时甚至更长的时间来分享我的痛苦。
 
 这与复杂的优化算法无关，而与使用数据包地理编码服务有关，该服务将地址列表作为输入并返回包含结果的文件。这样可以将处理时间...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>地理编码 如何在10分钟内将25万个地址绑定到坐标？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499990/"><img src="https://habrastorage.org/webt/6b/g3/oo/6bg3ooc_jcrhty63bg_33x8inta.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哈Ha！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我将分享我在解决大量地址小的问题方面的经验。</font><font style="vertical-align: inherit;">如果您曾经使用过地理编码API或使用过在线工具，那么我认为您要等几个小时甚至更长的时间来分享我的痛苦。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这与复杂的优化算法无关，而与使用数据包地理编码服务有关，该服务将地址列表作为输入并返回包含结果的文件。</font><font style="vertical-align: inherit;">这样可以将处理时间从几小时减少到几分钟。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先要注意的是：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背景</font></font></h3></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">批量地理编码</font></font></h3></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择数据包地址解析器提供商</font></font></h3></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python服务指南</font></font></h3></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整批次类别说明</font></font></h3></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果分析</font></font></h3></a></li>
</ul><br>
<a name="history"></a><h3><font color="#9cc2ce"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背景</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
任务到达了-“绑定到24000个地址的坐标。” </font><font style="vertical-align: inherit;">解决问题的方法只有两种：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于大学的地理编码Web应用程序；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据地理编码器的REST API编写脚本。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第一种情况下，事实证明Web应用程序在处理了数千个地址后崩溃。在同事之间分配数据集是一个被立即放弃的想法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，您需要使用地址解析器的REST API来编写自己的脚本，并保存结果（这不是完全合法的方式，您需要阅读该服务的使用条款）。出现了一个新问题-当我们在应用程序中使用地址搜索并立即获得结果时，这是一回事，但是当任务是要处理并保存超过一万个地址时，脚本的工作就会大大延迟。您可以等待一两个小时，但是一百万个地址将必须对“大量时间”进行地址解析，因此您需要寻找另一种解决方案！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了通常的地理编码服务外，大型地理定位服务提供商还提供了一个分组地理编码器（Batch Geocoder），目的是为了在一个请求中处理大量地址。</font></font><br>
<br>
<a name="batch"></a><h3><font color="#9cc2ce"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">批量地理编码</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
服务的名称说明一切-我们有一个程序包（例如，一个csv文件，其中包含以表格形式的地址列表），然后将其上传到服务器，它会为我们完成所有工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该过程如下所示：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">准备数据集，以便服务无误地接受它；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置工作结果的参数（选择列，分隔符...）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将文件上传到云；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待处理完成；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载完成的文件。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多亏了云计算能力，在1小时内用自写脚本完成的工作在1分钟内完成。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下一步是选择使用分组地理编码器的最忠实使用条款的公司。</font><font style="vertical-align: inherit;">首先，并非每个人都提供这样的服务，其他人则允许您对服务进行严格的限制。</font><font style="vertical-align: inherit;">另外，如果您的交易量很大，则需要注意额外交易的费用，以防超出免费套餐的限制。</font></font><br>
<br>
<a name="provider"></a><h3><font color="#9cc2ce"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择批处理地理编码服务提供商</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在全球地理定位服务市场中，领先地位被下列公司占据： </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谷歌地图</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HERE Technologies； </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地图框</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">汤姆汤姆 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESRI。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，您不应忘记Yandex Technologies，该公司在俄罗斯具有相当强的地位。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将以下参数作为选择提供程序的基础：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每月对地理编码服务的请求数量是免费的；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每天交易数量的限制；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">批量地理编码服务的可用性；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以在免费计划中使用数据包地址解析器。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个公司都有自己的获利模型。</font><font style="vertical-align: inherit;">根据项目的不同，一个或另一个模型可以发挥作用，反之亦然。</font></font><br>
<br>
<h4><font color="#9cc2ce"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谷歌地图</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要开始使用Google地理服务，您需要做的第一件事就是将信用卡信息添加到您的帐户中。每月限额为200虚拟美元，然后从链接的卡中支付其他交易。在此限制内，您可以使用各种服务，但每个事务的处理方式都不相同。例如，一千个地理编码请求的价格为5美元，但路由构建服务的价格却是其两倍。可以在该站点上找到更多详细信息，我们仅对地理编码服务感兴趣。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果每月200美元，那么很容易计算出免费交易数量-40,000（地理编码服务）。</font><font style="vertical-align: inherit;">服务之间没有数据包地址解析器。</font><font style="vertical-align: inherit;">这意味着您必须编写自己的脚本，结果将是每秒大约1个地址，对于24,000个地址来说，这是6个小时。</font><font style="vertical-align: inherit;">为了加快该过程，您可以尝试在Google Cloud API平台上运行该脚本，但是我决定寻找替代解决方案。</font><font style="vertical-align: inherit;">每天的交易数量没有限制，因此一次可以花费4万笔。</font></font><br>
<br>
<h4><font color="#9cc2ce"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里技术</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
过去，诺基亚地图以及更深层次的Navteq每月免费提供25万笔交易。与Google Maps类似，此数字适用于所有服务，并且每个服务的使用方式都不同。使用免费软件包时，不需要附加银行卡。如果超出限额，则每增加一千次交易，您需要支付1美元。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将数据包地址解析器作为一项单独的服务（包含在免费计划中）非常重要。根据与通常相同的模型来考虑其中的事务，也就是说，数据包地址解析器将在一次事务中感知文件中的每个地址。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据文章的标题，很明显，我使用了HERE批处理地址解析器，因为您可以将所有交易都花在地址解析器上，每月执行25万次地址解析操作。</font><font style="vertical-align: inherit;">但这不是唯一的选择，因此我们看一下其他公司拥有的东西。</font></font><br>
<br>
<h4><font color="#9cc2ce"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地图框</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用MapBox地理编码器时，每月可处理10万笔交易。</font><font style="vertical-align: inherit;">该公司遵循相同的货币化模型，但要为其他交易付费。</font><font style="vertical-align: inherit;">只有“批发商”有一个有趣的选择-您进行的交易越多，花费越少（当然，存在降价限制）。</font><font style="vertical-align: inherit;">例如，从10万到50万，额外的一千个请求将花费0.75美元，从50万到100万-0.60美元，等等，有关更多信息，请参见网站。</font><font style="vertical-align: inherit;">不幸的是，批处理地理编码器仅在付费帐户中可用。</font></font><br>
<br>
<h4><font color="#9cc2ce"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">汤姆</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该平台可以每天进行2500次交易，每月大约75,000次。</font><font style="vertical-align: inherit;">在测试和开发过程中，与竞争对手相比，每日限额看起来并不吸引人，但是额外交易的付款最为灵活。</font><font style="vertical-align: inherit;">对于额外的一千个请求，有8种付款方式，价格从$ 0.5降低到$ 0.42。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这些服务中，有一个批处理地址解析器，每个请求最多可以处理1万个地址（但是，必须考虑每日限制）。</font></font><br>
<br>
<h4><font color="#9cc2ce"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex技术</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex每日交易限额的模型，但忠诚度达25,000个请求。</font><font style="vertical-align: inherit;">如果将此数字乘以一个月中的天数，您将得到令人印象深刻的75万。</font><font style="vertical-align: inherit;">该网站以卢布的形式提供了另外一千笔交易的价格，范围从120卢布不等。</font><font style="vertical-align: inherit;">高达11卢布 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据包地址解析器不作为服务提供，因此实现某种优化将失败。</font></font><br>
<br>
<h4><font color="#9cc2ce"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESRI</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个非常诱人的免费计划，每月有100万笔交易。</font><font style="vertical-align: inherit;">该公司还向每个帐户收取50个信用（约等于5美元）。</font><font style="vertical-align: inherit;">值得注意的是，这是使用地理定位服务的最忠诚计划。</font><font style="vertical-align: inherit;">还有一个批处理地理编码服务，但是只有在ArcGIS Online平台上拥有公司帐户的情况下，您才可以使用它。</font></font><br>
<br>
<h4><font color="#9cc2ce"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到底要选择什么？</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最简单的方法是通过编译一张小表进行选择：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kg/xy/b1/kgxyb1kmzemqxqicwajfi7hggva.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，我的选择落在了这里，因为这是解决我的问题的最佳选择。</font><font style="vertical-align: inherit;">当然，我还没有完成完整的分析，理想情况下，您需要通过所有地理编码器运行数据集以评估质量。</font><font style="vertical-align: inherit;">另外，如果您有数百万个地址，则应考虑一个有偿包裹，然后需要考虑添加费用。</font><font style="vertical-align: inherit;">交易。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文的目的不是比较公司，而是解决优化大量地址的地理编码的问题。</font><font style="vertical-align: inherit;">我只是在选择服务提供商时表达了自己的想法。</font></font><br>
<br>
<a name="guide"></a><h3><font color="#9cc2ce"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python服务指南</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，您需要在门户网站上为开发人员创建一个帐户，并在项目部分中生成REST API KEY。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在您可以使用该平台了。</font><font style="vertical-align: inherit;">我将仅描述HERE数据包地理编码器具有的部分功能：数据加载，状态检查，保存结果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，让我们从导入必要的库开始：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> zipfile
<span class="hljs-keyword">import</span> io
<span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，如果没有发生错误，请创建一个类：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Batch</span>:</span><font></font>
<font></font>
    SERVICE_URL = <span class="hljs-string">"https://batch.geocoder.ls.hereapi.com/6.2/jobs"</span>
    jobId = <span class="hljs-literal">None</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, apikey=<span class="hljs-string">"your_api_key"</span></span>):</span><font></font>
        self.apikey = apikey<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也就是说，在初始化期间，该类必须为REST API传递其自己的密钥。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SERVICE_URL变量是用于批处理地理编码服务的基本URL。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并且在jobId中，将存储地址解析器当前工作的标识符。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要的一点是应要求提供正确的数据结构。</font><font style="vertical-align: inherit;">该文件必须包含两列必需的列：recId和searchText。</font><font style="vertical-align: inherit;">否则，服务将返回包含有关下载错误信息的响应。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个示例数据集：</font></font><br>
<br>
<pre><code class="plaintext hljs">   recId; searchText<font></font>
   1; -, . , 6<font></font>
   2; ,  1,  -., 72<font></font>
   3; 425 W Randolph St Chicago IL 60606<font></font>
   4; , DJ106 20-30, Sibiu 557260<font></font>
   5; 200 S Mathilda Ave Sunnyvale CA 94086<font></font>
  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用于将文件上传到云的功能：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self, filename, indelim=<span class="hljs-string">";"</span>, outdelim=<span class="hljs-string">";"</span></span>):</span><font></font>
        <font></font>
        file = open(filename, <span class="hljs-string">'rb'</span>)<font></font>
<font></font>
        params = {<font></font>
            <span class="hljs-string">"action"</span>: <span class="hljs-string">"run"</span>,
            <span class="hljs-string">"apiKey"</span>: self.apikey,
            <span class="hljs-string">"politicalview"</span>:<span class="hljs-string">"RUS"</span>,
            <span class="hljs-string">"gen"</span>: <span class="hljs-number">9</span>,
            <span class="hljs-string">"maxresults"</span>: <span class="hljs-string">"1"</span>,
            <span class="hljs-string">"header"</span>: <span class="hljs-string">"true"</span>,
            <span class="hljs-string">"indelim"</span>: indelim,
            <span class="hljs-string">"outdelim"</span>: outdelim,
            <span class="hljs-string">"outcols"</span>: <span class="hljs-string">"displayLatitude,displayLongitude,locationLabel,houseNumber,street,district,city,postalCode,county,state,country"</span>,
            <span class="hljs-string">"outputcombined"</span>: <span class="hljs-string">"true"</span>,<font></font>
        }<font></font>
<font></font>
        response = requests.post(self.SERVICE_URL, params=params, data=file)<font></font>
        self.__stats (response)<font></font>
        file.close()<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一切都非常简单，打开一个包含要读取的地址列表的文件，形成GET请求参数的字典。</font><font style="vertical-align: inherit;">一些参数值得解释：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“操作”：“运行”-开始地址处理；</font></font></li>
<li>“politicalView”: “RUS” –    .         (    );</li>
<li>“gen”: 9 –   (   );</li>
<li>“maxresults”: 1 –          ;</li>
<li>“header”: true –        ;</li>
<li>“indelim”: “;” –   ,  ;</li>
<li>“outdelim”: “;” –    ;</li>
<li>“outcols”: “” –  ,      ;</li>
<li>“outcombined”: true –                .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，只需使用请求库发送请求并显示统计信息即可。</font><font style="vertical-align: inherit;">当然，您需要在函数末尾关闭文件。</font><font style="vertical-align: inherit;">__stats函数解析服务器的响应，该响应包含正在运行的工作的ID，并且还显示有关该操作的常规信息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下一步是检查工作状态。</font><font style="vertical-align: inherit;">该请求以类似的方式形成，只需要传输操作ID。</font><font style="vertical-align: inherit;">动作参数必须包含值“状态”。</font><font style="vertical-align: inherit;">__stats函数向控制台显示完整的统计信息，以估计地址解析器的关闭时间。</font></font><br>
<br>
<pre><code class="python hljs">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">status</span> (<span class="hljs-params">self, jobId = None</span>):</span><font></font>
<font></font>
        <span class="hljs-keyword">if</span> jobId <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<font></font>
            self.jobId = jobId<font></font>
        <font></font>
        statusUrl = self.SERVICE_URL + <span class="hljs-string">"/"</span> + self.jobId<font></font>
        <font></font>
        params = {<font></font>
            <span class="hljs-string">"action"</span>: <span class="hljs-string">"status"</span>,
            <span class="hljs-string">"apiKey"</span>: self.apikey,<font></font>
        }<font></font>
        <font></font>
        response = requests.get(statusUrl, params=params)<font></font>
        self.__stats (response)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最重要的功能之一就是保存结果。</font><font style="vertical-align: inherit;">为了方便起见，最好立即解压缩来自服务器的文件。</font><font style="vertical-align: inherit;">保存文件的请求与检查状态相同，只是在最后添加/结果。</font></font><br>
<br>
<pre><code class="python hljs">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">result</span> (<span class="hljs-params">self, jobId = None</span>):</span><font></font>
<font></font>
        <span class="hljs-keyword">if</span> jobId <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<font></font>
            self.jobId = jobId<font></font>
        <font></font>
        print(<span class="hljs-string">"Requesting result data ..."</span>)<font></font>
        <font></font>
        resultUrl = self.SERVICE_URL + <span class="hljs-string">"/"</span> + self.jobId + <span class="hljs-string">"/result"</span><font></font>
        <font></font>
        params = {<font></font>
            <span class="hljs-string">"apiKey"</span>: self.apikey<font></font>
        }<font></font>
        <font></font>
        response = requests.get(resultUrl, params=params, stream=<span class="hljs-literal">True</span>)<font></font>
        <font></font>
        <span class="hljs-keyword">if</span> (response.ok):    <font></font>
            zipResult = zipfile.ZipFile(io.BytesIO(response.content))<font></font>
            zipResult.extractall()<font></font>
            print(<span class="hljs-string">"File saved successfully"</span>)<font></font>
        <font></font>
        <span class="hljs-keyword">else</span>:<font></font>
            print(<span class="hljs-string">"Error"</span>)<font></font>
            print(response.text)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解析服务响应的最终功能。</font><font style="vertical-align: inherit;">她的任务也是保存当前地理编码任务的标识符：</font></font><br>
<br>
<pre><code class="python hljs">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__stats</span> (<span class="hljs-params">self, response</span>):</span>
        <span class="hljs-keyword">if</span> (response.ok):<font></font>
            parsedXMLResponse = BeautifulSoup(response.text, <span class="hljs-string">"lxml"</span>)<font></font>
<font></font>
            self.jobId = parsedXMLResponse.find(<span class="hljs-string">'requestid'</span>).get_text()<font></font>
            <font></font>
            <span class="hljs-keyword">for</span> stat <span class="hljs-keyword">in</span> parsedXMLResponse.find(<span class="hljs-string">'response'</span>).findChildren():
                <span class="hljs-keyword">if</span>(len(stat.findChildren()) == <span class="hljs-number">0</span>):<font></font>
                    print(<span class="hljs-string">"{name}: {data}"</span>.format(name=stat.name, data=stat.get_text()))<font></font>
<font></font>
        <span class="hljs-keyword">else</span>:<font></font>
            print(response.text)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要对其进行测试，只需在脚本文件夹中运行Python解释器。</font><font style="vertical-align: inherit;">Batch类位于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geocoder.py</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件中</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt;&gt;&gt; from geocoder import Batch<font></font>
&gt;&gt;&gt; service = Batch(apikey="   REST API")<font></font>
&gt;&gt;&gt; service.start("big_data_addresses.csv", indelim=";", outdelim=";")<font></font>
<font></font>
requestid: "  Id "<font></font>
status: accepted<font></font>
totalcount: 0<font></font>
validcount: 0<font></font>
invalidcount: 0<font></font>
processedcount: 0<font></font>
pendingcount: 0<font></font>
successcount: 0<font></font>
errorcount: 0<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
伟大的工作开始了。</font><font style="vertical-align: inherit;">检查状态：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt;&gt;&gt; service.status()<font></font>
<font></font>
requestid: "  Id "<font></font>
status: completed<font></font>
jobstarted: 2020-04-27T10:09:58.000Z<font></font>
jobfinished: 2020-04-27T10:17:18.000Z<font></font>
totalcount: 249999<font></font>
validcount: 249999<font></font>
invalidcount: 0<font></font>
processedcount: 249999<font></font>
pendingcount: 0<font></font>
successcount: 249978<font></font>
errorcount: 21<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们看到数据集的处理已经完成。</font><font style="vertical-align: inherit;">在短短7分钟内，就可以对25万个地址进行编码（不包括错误-errorcount）。</font><font style="vertical-align: inherit;">保留结果即可：</font></font><br>
<br>
<pre><code class="plaintext hljs">&gt;&gt;&gt; service.result()<font></font>
Requesting result data ...<font></font>
File saved successfully<font></font>
</code></pre><br>
<a name="code"></a><h3><font color="#9cc2ce"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整批次类别说明</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为完全添加脚本没有什么坏处：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> zipfile
<span class="hljs-keyword">import</span> io
<span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Batch</span>:</span><font></font>
<font></font>
    SERVICE_URL = <span class="hljs-string">"https://batch.geocoder.ls.hereapi.com/6.2/jobs"</span>
    jobId = <span class="hljs-literal">None</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, apikey=<span class="hljs-string">"   REST API "</span></span>):</span><font></font>
        self.apikey = apikey<font></font>
        <font></font>
            <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start</span>(<span class="hljs-params">self, filename, indelim=<span class="hljs-string">";"</span>, outdelim=<span class="hljs-string">";"</span></span>):</span><font></font>
        <font></font>
        file = open(filename, <span class="hljs-string">'rb'</span>)<font></font>
<font></font>
        params = {<font></font>
            <span class="hljs-string">"action"</span>: <span class="hljs-string">"run"</span>,
            <span class="hljs-string">"apiKey"</span>: self.apikey,
            <span class="hljs-string">"politicalview"</span>:<span class="hljs-string">"RUS"</span>,
            <span class="hljs-string">"gen"</span>: <span class="hljs-number">9</span>,
            <span class="hljs-string">"maxresults"</span>: <span class="hljs-string">"1"</span>,
            <span class="hljs-string">"header"</span>: <span class="hljs-string">"true"</span>,
            <span class="hljs-string">"indelim"</span>: indelim,
            <span class="hljs-string">"outdelim"</span>: outdelim,
            <span class="hljs-string">"outcols"</span>: <span class="hljs-string">"displayLatitude,displayLongitude,locationLabel,houseNumber,street,district,city,postalCode,county,state,country"</span>,
            <span class="hljs-string">"outputcombined"</span>: <span class="hljs-string">"true"</span>,<font></font>
        }<font></font>
<font></font>
        response = requests.post(self.SERVICE_URL, params=params, data=file)<font></font>
        self.__stats (response)<font></font>
        file.close()<font></font>
    <font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">status</span> (<span class="hljs-params">self, jobId = None</span>):</span><font></font>
<font></font>
        <span class="hljs-keyword">if</span> jobId <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<font></font>
            self.jobId = jobId<font></font>
        <font></font>
        statusUrl = self.SERVICE_URL + <span class="hljs-string">"/"</span> + self.jobId<font></font>
        <font></font>
        params = {<font></font>
            <span class="hljs-string">"action"</span>: <span class="hljs-string">"status"</span>,
            <span class="hljs-string">"apiKey"</span>: self.apikey,<font></font>
        }<font></font>
        <font></font>
        response = requests.get(statusUrl, params=params)<font></font>
        self.__stats (response)<font></font>
        <font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">result</span> (<span class="hljs-params">self, jobId = None</span>):</span><font></font>
<font></font>
        <span class="hljs-keyword">if</span> jobId <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<font></font>
            self.jobId = jobId<font></font>
        <font></font>
        print(<span class="hljs-string">"Requesting result data ..."</span>)<font></font>
        <font></font>
        resultUrl = self.SERVICE_URL + <span class="hljs-string">"/"</span> + self.jobId + <span class="hljs-string">"/result"</span><font></font>
        <font></font>
        params = {<font></font>
            <span class="hljs-string">"apiKey"</span>: self.apikey<font></font>
        }<font></font>
        <font></font>
        response = requests.get(resultUrl, params=params, stream=<span class="hljs-literal">True</span>)<font></font>
        <font></font>
        <span class="hljs-keyword">if</span> (response.ok):    <font></font>
            zipResult = zipfile.ZipFile(io.BytesIO(response.content))<font></font>
            zipResult.extractall()<font></font>
            print(<span class="hljs-string">"File saved successfully"</span>)<font></font>
        <font></font>
        <span class="hljs-keyword">else</span>:<font></font>
            print(<span class="hljs-string">"Error"</span>)<font></font>
            print(response.text)<font></font>
    <font></font>
<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__stats</span> (<span class="hljs-params">self, response</span>):</span>
        <span class="hljs-keyword">if</span> (response.ok):<font></font>
            parsedXMLResponse = BeautifulSoup(response.text, <span class="hljs-string">"lxml"</span>)<font></font>
<font></font>
            self.jobId = parsedXMLResponse.find(<span class="hljs-string">'requestid'</span>).get_text()<font></font>
            <font></font>
            <span class="hljs-keyword">for</span> stat <span class="hljs-keyword">in</span> parsedXMLResponse.find(<span class="hljs-string">'response'</span>).findChildren():
                <span class="hljs-keyword">if</span>(len(stat.findChildren()) == <span class="hljs-number">0</span>):<font></font>
                    print(<span class="hljs-string">"{name}: {data}"</span>.format(name=stat.name, data=stat.get_text()))<font></font>
<font></font>
        <span class="hljs-keyword">else</span>:<font></font>
            print(response.text)<font></font>
</code></pre><br>
<a name="result"></a><h3><font color="#9cc2ce"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果分析</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，我从缓慢运行的在线应用程序转到批处理地理编码服务。</font><font style="vertical-align: inherit;">地理服务提供商的选择完全取决于您面临的任务。</font><font style="vertical-align: inherit;">我经常收到处理大量地址的请求，而本文中描述的方法有助于大大减少时间。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我希望这篇文章对您有所帮助，当然我也欢迎您提出意见和补充！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN499974/index.html">Instagram Javascript或香肠飞行路线上的3D游戏</a></li>
<li><a href="../zh-CN499978/index.html">安德鲁·安（Andrew Un）的书《机器学习的激情》第36和37章的翻译</a></li>
<li><a href="../zh-CN499982/index.html">初学者测试计划：从“输入IT”到“我是工程师！”</a></li>
<li><a href="../zh-CN499986/index.html">再一次关于嵌入式：在Embox项目中寻找错误</a></li>
<li><a href="../zh-CN499988/index.html">糖和COVID-19</a></li>
<li><a href="../zh-CN499992/index.html">为企业客户实施计费系统的设计技术（第2部分）</a></li>
<li><a href="../zh-CN499994/index.html">冠状病毒何时结束</a></li>
<li><a href="../zh-CN500000/index.html">到广播日。沟通-战争的神经</a></li>
<li><a href="../zh-CN500002/index.html">IT专家与推销员：世界一分为二</a></li>
<li><a href="../zh-CN500008/index.html">满足升频器</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>