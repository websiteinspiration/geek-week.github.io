<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🎓 🕙 🌔 Bagaimana kami di Sportmaster memilih sistem caching. Bagian 1 🎍 👨🏽‍🎓 🐳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo! Nama saya Alexey Pyankov, saya seorang pengembang di Sportmaster. Dalam posting ini saya berbicara tentang bagaimana kerja di situs web Sportmas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami di Sportmaster memilih sistem caching. Bagian 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sportmaster_lab/blog/490912/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo! Nama saya Alexey Pyankov, saya seorang pengembang di Sportmaster. Dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">posting</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ini </font><font style="vertical-align: inherit;">saya berbicara tentang bagaimana kerja di situs web Sportmaster dimulai pada 2012, inisiatif apa yang berhasil kami lakukan, dan sebaliknya, penggaruk mana yang kami kumpulkan. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hari ini saya ingin berbagi pemikiran yang mengikuti cerita lain - memilih sistem caching untuk java backend di panel admin situs. Plot ini sangat penting bagi saya - meskipun ceritanya hanya berlangsung 2 bulan, tetapi 60 hari ini kami bekerja selama 12-16 jam dan tanpa hari libur. Saya tidak pernah berpikir dan membayangkan bahwa Anda dapat bekerja begitu banyak.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena itu, saya memecah teks menjadi 2 bagian, agar tidak mengunduh secara penuh. Sebaliknya, bagian pertama akan sangat mudah - persiapan, pengenalan, beberapa pertimbangan tentang apa itu caching. Jika Anda sudah menjadi pengembang yang berpengalaman atau telah bekerja dengan cache - dari sisi teknis, kemungkinan besar tidak ada yang baru dalam artikel ini. Tetapi bagi seorang junior, ulasan kecil semacam itu bisa menentukan arah mana yang harus dilihat, jika dia menemukan dirinya di persimpangan jalan.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/c-/8-/z5/c-8-z5hphf6b0qo46ruj5mdf1vc.png"></a><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika versi baru situs web Sportmaster diluncurkan dalam produksi, data datang dengan cara, dengan kata lain, tidak terlalu nyaman. Dasarnya adalah tabel yang disiapkan untuk versi situs sebelumnya (Bitrix), yang harus diperketat di ETL, dibawa ke tampilan baru dan diperkaya dengan hal-hal kecil yang berbeda dari selusin sistem. Agar gambar atau deskripsi produk baru muncul di situs, Anda harus menunggu hingga hari berikutnya - hanya memperbarui di malam hari, 1 kali per hari.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada awalnya, ada begitu banyak kekhawatiran dari minggu-minggu pertama masuk ke dalam produksi sehingga ketidaknyamanan bagi manajer konten adalah hal yang remeh. Tetapi, segera setelah semuanya beres, pengembangan proyek berlanjut - beberapa bulan kemudian, pada awal 2015, kami mulai aktif mengembangkan panel admin. Pada 2015 dan 2016, semuanya berjalan dengan baik, kami akan merilisnya secara teratur, area admin mencakup sebagian besar persiapan data, dan kami sedang mempersiapkan fakta bahwa segera hal yang paling penting dan sulit akan dipercayakan kepada tim kami - lini produk (persiapan lengkap dan pemeliharaan data untuk semua produk). Tetapi pada musim panas 2017, tepat sebelum peluncuran lini produk, proyek ini akan berada dalam situasi yang sangat sulit - justru karena masalah caching. Saya ingin berbicara tentang episode ini di bagian kedua dari publikasi dua bagian ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi dalam posting ini saya akan mulai dari jauh, seperti beberapa pemikiran - ide tentang caching, yang akan bergulir sebelum proyek besar sebelumnya akan menjadi langkah yang baik.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika tugas cache muncul</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tugas caching tidak hanya muncul. Kami adalah pengembang, kami menulis produk perangkat lunak dan kami ingin itu menjadi permintaan. Jika produk dalam permintaan dan sukses, pengguna tiba. Dan lebih banyak datang dan lebih banyak lagi. Jadi ada banyak pengguna dan kemudian produk menjadi sangat sarat. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada tahap pertama, kami tidak memikirkan pengoptimalan dan kinerja kode. Hal utama adalah fungsionalitas, dengan cepat meluncurkan pilot dan menguji hipotesis. Dan jika beban bertambah, kami memompa besi. Kami meningkatkannya dengan faktor dua, tiga, lima, biarkan 10 kali lipat. Di suatu tempat di sini - keuangan tidak lagi memungkinkan. Dan berapa kali jumlah pengguna akan bertambah? Ini tidak hanya 2-5-10, tetapi jika berhasil, akan dari 100-1000 dan hingga 100 ribu kali. Yaitu, cepat atau lambat, tetapi harus melakukan optimasi.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Katakanlah beberapa bagian dari kode (sebut saja bagian ini fungsi) bekerja tidak sopan untuk waktu yang lama, dan kami ingin mengurangi waktu eksekusi. Fungsi - bisa berupa akses ke database, bisa jadi merupakan eksekusi dari beberapa logika yang kompleks - yang utama adalah membutuhkan waktu yang lama. Seberapa banyak Anda bisa mengurangi waktu tunggu? Dalam batas - dapat dikurangi menjadi nol, tidak ada lagi. Dan bagaimana Anda bisa mengurangi runtime menjadi nol? Jawaban: umumnya tidak termasuk eksekusi. Sebagai gantinya, segera kembalikan hasilnya. Dan bagaimana Anda tahu hasilnya? Jawab: hitung, atau lihat ke suatu tempat. Menghitung adalah waktu yang lama. Dan untuk mengintip, misalnya, untuk mengingat hasil bahwa fungsi yang dihasilkan terakhir kali ketika dipanggil dengan parameter yang sama.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artinya, implementasi fungsi tidak masalah bagi kami. </font><font style="vertical-align: inherit;">Cukup mengetahui parameter apa yang bergantung pada hasil. </font><font style="vertical-align: inherit;">Kemudian, jika nilai parameter disajikan dalam bentuk objek yang dapat digunakan sebagai kunci dalam beberapa penyimpanan, maka kita dapat menyimpan hasil perhitungan dan membacanya di waktu berikutnya. </font><font style="vertical-align: inherit;">Jika hasil baca-tulis ini lebih cepat daripada menjalankan fungsi, kami memiliki keuntungan dalam kecepatan. </font><font style="vertical-align: inherit;">Nilai keuntungan dapat mencapai 100, 1000, dan 100 ribu kali (10 ^ 5 lebih merupakan pengecualian, tetapi dalam kasus basis lag yang layak sangat mungkin).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persyaratan Caching Utama</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hal pertama yang dapat menjadi persyaratan untuk sistem caching adalah kecepatan baca yang cepat dan, pada tingkat yang sedikit lebih rendah, kecepatan menulis. Ini benar, tetapi hanya sampai kita meluncurkan sistem dalam produksi. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita mainkan kasus seperti itu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan kita menyediakan beban saat ini dengan besi dan sekarang kita secara bertahap memperkenalkan caching. Pengguna tumbuh sedikit, beban bertambah - kami menambahkan sedikit cache, kami kencangkan di sana-sini. Ini telah berlangsung selama beberapa waktu, dan sekarang fungsi-fungsi berat praktis tidak dipanggil - semua beban utama jatuh pada cache. Jumlah pengguna selama ini telah bertambah N kali.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan jika pasokan awal besi bisa 2-5 kali, maka dengan bantuan cache kita dapat mengencangkan produktivitas setiap 10 atau, dalam kasus yang baik, 100 kali, di beberapa tempat, mungkin 1000. Artinya, kami memproses pada besi yang sama Permintaan 100 kali lebih banyak. Hebat, layak mendapatkan jahe! </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi sekarang, pada satu titik, secara tidak sengaja, sistem crash dan cache crash. Tidak ada yang istimewa - lagipula, cache dipilih berdasarkan permintaan "membaca dan menulis dengan kecepatan tinggi, sisanya tidak masalah." </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengenai beban awal, cadangan besi adalah 2-5 kali, dan beban selama ini tumbuh 10-100 kali. Dengan bantuan cache, kami menghilangkan panggilan untuk fungsi-fungsi berat dan karenanya semuanya terbang. Dan sekarang, tanpa cache - berapa kali sistem kami melorot? Apa yang akan terjadi pada kita? Sistem akan jatuh.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan jika cache kita tidak macet, tetapi hanya dihapus untuk sementara waktu, itu perlu dipanaskan, dan ini akan memakan waktu. </font><font style="vertical-align: inherit;">Dan saat ini - beban utama akan jatuh pada fungsional. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kesimpulan: proyek-proyek beban tinggi dalam produk memerlukan dari sistem caching tidak hanya kecepatan tinggi membaca dan menulis, tetapi juga keamanan data dan ketahanan terhadap kegagalan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilihan tepung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam proyek dengan panel admin, pilihannya seperti ini: pertama mereka menaruh Hazelcast, karena </font><font style="vertical-align: inherit;">sudah terbiasa dengan produk ini dari pengalaman situs utama. </font><font style="vertical-align: inherit;">Tapi, di sini pilihan ini tidak berhasil - untuk profil beban kami, Hazelcast bekerja tidak hanya secara perlahan, tetapi juga sangat lambat. </font><font style="vertical-align: inherit;">Dan pada saat itu, kami sudah mendaftar untuk ketentuan penarikan ke prod. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Spoiler: bagaimana tepatnya keadaan muncul sehingga kita melewatkan kesulitan seperti itu dan mendapat situasi yang akut dan tegang - saya akan ceritakan pada bagian kedua - dan bagaimana kita berubah dan bagaimana kita keluar. </font><font style="vertical-align: inherit;">Tapi sekarang - saya hanya akan mengatakan bahwa itu sangat stres, dan "berpikir - entah bagaimana saya tidak berpikir, kocok botolnya." </font><font style="vertical-align: inherit;">"Mengocok botol" juga spoiler, tentang ini sedikit lebih jauh. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang telah kita lakukan:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami membuat daftar semua sistem yang diminta oleh google dan StackOverflow. </font><font style="vertical-align: inherit;">Sedikit di atas 30</font></font></li>
<li>   ,   .    ,      - —       ,   .      </li>
<li> ,      , ,  .   ,    – ,     .</li>
<li> 17-   ,   .  « »,   .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi ini adalah opsi ketika Anda harus memilih sistem yang "merangkak dalam kecepatan" dalam tes yang disiapkan sebelumnya. Dan jika belum ada tes seperti itu dan ingin memilih lebih cepat? </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan mensimulasikan opsi seperti itu (sulit untuk membayangkan bahwa pengembang menengah + hidup dalam ruang hampa, dan pada saat pemilihan ia belum memutuskan produk mana yang akan dicoba di tempat pertama - karena itu, diskusi lebih lanjut lebih mungkin adalah ahli teori / filosofi / tentang seorang junior). </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menentukan persyaratan, kami akan mulai memilih solusi dari kotak. Mengapa menemukan kembali roda: kami akan pergi dan mengambil sistem caching yang sudah jadi.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda baru memulai dan Anda akan google, maka plus atau minus pesanan, tetapi secara umum, pedoman akan seperti itu. </font><font style="vertical-align: inherit;">Pertama-tama, Anda menemukan Redis, itu didengar di mana-mana. </font><font style="vertical-align: inherit;">Maka Anda akan menemukan bahwa ada EhCache sebagai sistem tertua dan paling terbukti. </font><font style="vertical-align: inherit;">Kemudian akan ditulis tentang Tarantool - sebuah pembangunan domestik di mana ada aspek unik dari solusi. </font><font style="vertical-align: inherit;">Dan juga Ignite, karena sekarang sedang naik popularitas dan menikmati dukungan dari SberTech. </font><font style="vertical-align: inherit;">Pada akhirnya, ada Hazelcast, karena di dunia perusahaan sering muncul di tengah-tengah perusahaan besar. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daftar ini tidak berakhir di sana, ada lusinan sistem. </font><font style="vertical-align: inherit;">Dan kami hanya mengacaukan satu. </font><font style="vertical-align: inherit;">Ambil 5 sistem yang dipilih untuk "kontes kecantikan" dan lakukan seleksi. </font><font style="vertical-align: inherit;">Siapa yang akan menjadi pemenang?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami membaca apa yang mereka tulis di situs web resmi. </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah proyek sumber terbuka. </font><font style="vertical-align: inherit;">Ini menawarkan penyimpanan data dalam memori, kemampuan untuk menyimpan pada disk, partisi otomatis ke dalam partisi, ketersediaan tinggi dan pemulihan dari jeda jaringan. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tampaknya semuanya baik-baik saja, Anda dapat mengambilnya dan mengacaukannya - semua yang ia butuhkan adalah apa yang ia lakukan. </font><font style="vertical-align: inherit;">Tapi mari kita cari demi minat pada kandidat lain.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ehcache</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EhCache</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - “cache yang paling banyak digunakan untuk Java” (terjemahan slogan dari situs resmi). </font><font style="vertical-align: inherit;">Juga opensource. </font><font style="vertical-align: inherit;">Dan di sini kita memahami bahwa Redis bukan di bawah java, tetapi umum, dan untuk berinteraksi dengannya, Anda memerlukan pembungkus. </font><font style="vertical-align: inherit;">Dan EhCache akan lebih nyaman. </font><font style="vertical-align: inherit;">Apa lagi yang dijanjikan sistem? </font><font style="vertical-align: inherit;">Keandalan, ketelitian, fungsionalitas penuh. </font><font style="vertical-align: inherit;">Ya, dan dia yang paling umum. </font><font style="vertical-align: inherit;">Dan cache data terabyte. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Redis dilupakan, saya siap untuk memilih EhCache. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi rasa patriotisme mendorong saya untuk melihat apa yang membuat Tarantool baik.</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarantool</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarantool</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Memenuhi penunjukan "Platform Integrasi Data Real-time." Kedengarannya sangat sulit, jadi kami membaca halaman itu secara mendetail dan menemukan pernyataan yang keras: "Tembolok 100% data dalam RAM." Ini seharusnya menimbulkan pertanyaan - lagipula, mungkin ada lebih banyak data daripada memori. Dekripsi adalah bahwa di sini tersirat bahwa Tarantool tidak menjalankan serialisasi untuk menulis data ke disk dari memori. Sebagai gantinya, ia menggunakan fitur tingkat rendah dari sistem ketika memori hanya memetakan ke sistem file dengan kinerja I / O yang sangat baik. Secara umum, mereka melakukannya dengan indah dan keren. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat implementasinya: jalan raya korporat Mail.ru, Avito, Beeline, Megafon, Alfa-Bank, Gazprom ...</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika masih ada keraguan tentang Tarantool, maka pengenalan implementasi Mastercard akan membunuh saya. </font><font style="vertical-align: inherit;">Saya mengambil Tarantool. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi bagaimanapun juga ...</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menyalakan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... ada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ignite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang dinyatakan sebagai "platform komputasi dalam memori ... kecepatan dalam memori pada petabyte data." </font><font style="vertical-align: inherit;">Ada juga banyak keuntungan: cache dalam-memori terdistribusi, penyimpanan nilai-kunci tercepat dan cache, penskalaan horizontal, ketersediaan tinggi, integritas yang ketat. </font><font style="vertical-align: inherit;">Secara umum, ternyata yang tercepat adalah Ignite. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implementasi: Sberbank, American Airlines, Yahoo! </font><font style="vertical-align: inherit;">Jepang </font><font style="vertical-align: inherit;">Dan kemudian saya masih menemukan bahwa Ignite tidak hanya diterapkan di Sberbank, tetapi tim SberTech mengirimkan orang-orangnya ke tim Ignite untuk menyelesaikan produk. </font><font style="vertical-align: inherit;">Ini benar-benar menawan dan saya siap untuk mengambil Ignite. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Benar-benar tidak bisa dipahami mengapa, saya melihat poin kelima.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siaran Hazel</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya pergi ke situs web </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hazelcast</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , membacanya. </font><font style="vertical-align: inherit;">Dan ternyata solusi tercepat untuk caching terdistribusi adalah Hazelcast. </font><font style="vertical-align: inherit;">Dia adalah urutan besarnya lebih cepat dari semua solusi lain dan secara umum dia adalah pemimpin di bidang kisi data di memori. </font><font style="vertical-align: inherit;">Terhadap latar belakang ini, ambil yang lain - jangan menghargai diri sendiri. </font><font style="vertical-align: inherit;">Ini juga menggunakan penyimpanan data yang berlebihan untuk operasi berkelanjutan dari cluster tanpa kehilangan data. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya, saya siap untuk mengambil Hazelcast.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perbandingan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi jika Anda melihat, maka kelima kandidat itu begitu dicat sehingga masing-masing dari mereka adalah yang terbaik. Bagaimana memilih? Kita bisa melihat mana yang paling populer, mencari perbandingan, dan sakit kepala akan berlalu. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menemukan seperti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tinjauan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , memilih 5 sistem kami. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/r8/ix/gi/r8ixgicyh9dc4wgwv7sl_prtxsi.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini mereka disortir: di puncak Redis, di tempat kedua adalah Hazelcast, Tarantool dan Ignite mendapatkan popularitas, EhCache telah dan tetap ada. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi mari kita lihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode perhitungan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : tautan ke situs web, minat umum pada sistem, tawaran pekerjaan - hebat! Yaitu, ketika sistem saya jatuh, saya akan mengatakan: “Tidak, itu dapat diandalkan! Berikut ini banyak tawaran pekerjaan ... ". Perbandingan sederhana seperti itu tidak akan berhasil.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua sistem ini bukan hanya sistem caching. </font><font style="vertical-align: inherit;">Mereka masih memiliki banyak fungsi, termasuk ketika bukan data yang ditransfer ke klien untuk diproses, melainkan: kode yang perlu dijalankan pada data yang dipindahkan ke server, dieksekusi di sana, dan hasilnya dikembalikan. </font><font style="vertical-align: inherit;">Dan sebagai sistem terpisah untuk caching, mereka tidak begitu sering dipertimbangkan. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yah, jangan menyerah, kami menemukan perbandingan langsung sistem. </font><font style="vertical-align: inherit;">Ambil dua opsi teratas - Redis dan Hazelcast. </font><font style="vertical-align: inherit;">Kami tertarik pada kecepatan, kami dapat membandingkannya dengan parameter ini.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hz vs Redis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menemukan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perbandingan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seperti itu </font><font style="vertical-align: inherit;">: </font></font><br>
<img src="https://habrastorage.org/webt/vq/ue/l0/vquel0ijbidfqlj_iailrnfhzgg.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biru adalah Redis, merah adalah Hazelcast. </font><font style="vertical-align: inherit;">Hazelcast menang di mana-mana, dan alasannya diberikan: ini multi-utas, sangat dioptimalkan, setiap utas bekerja dengan partisi sendiri, sehingga tidak ada kunci. </font><font style="vertical-align: inherit;">Dan Redis adalah single-threaded, tidak mengambil keuntungan dari CPU multi-core modern. </font><font style="vertical-align: inherit;">Hazelcast memiliki I / O yang tidak sinkron, Redis-Jedis memiliki soket pemblokir. </font><font style="vertical-align: inherit;">Pada akhirnya, Hazelcast menggunakan protokol biner, sedangkan Redis berorientasi teks, artinya tidak efisien. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk berjaga-jaga, kami beralih ke sumber perbandingan lain. </font><font style="vertical-align: inherit;">Apa yang akan dia tunjukkan pada kita?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis vs Hz</font></font></h3> <br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perbandingan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
lain </font><font style="vertical-align: inherit;">: </font></font><br>
<img src="https://habrastorage.org/webt/70/ez/yp/70ezypii1cgalhogxc9jo7kmshk.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini, sebaliknya, merah adalah Redis. </font><font style="vertical-align: inherit;">Artinya, Redis mengungguli Hazelcast dalam kinerja. </font><font style="vertical-align: inherit;">Dalam perbandingan pertama, Hazelcast menang, di yang kedua - Redis. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mereka menjelaskan dengan sangat tepat mengapa Hazelcast menang dalam perbandingan sebelumnya. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ternyata hasil yang pertama benar-benar dicurangi: Redis diambil di kotak dasar, dan Hazelcast dipenjara karena kasus uji. </font><font style="vertical-align: inherit;">Kemudian ternyata: pertama, tidak ada yang bisa dipercaya, dan kedua, ketika kita memilih suatu sistem, kita masih perlu mengkonfigurasinya dengan benar. </font><font style="vertical-align: inherit;">Pengaturan ini mencakup lusinan, hampir ratusan parameter.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengocok botol</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan seluruh proses yang baru saja kita lakukan, saya dapat menjelaskan dengan metafora seperti itu, "Kocok botolnya." Artinya, sekarang Anda tidak bisa memprogram, sekarang yang utama adalah bisa membaca stackoverflow. Dan di tim saya ada seseorang, seorang profesional, yang bekerja begitu saja pada saat-saat kritis.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang dia lakukan? Dia melihat sesuatu yang rusak, melihat jejak tumpukan, mengambil beberapa kata-katanya (yang keahliannya dalam program), mencari di Google, menemukan stackoverflow di antara jawaban. Tanpa membaca, tanpa berpikir, di antara jawaban atas pertanyaan - ia memilih sesuatu yang paling mirip dengan kalimat "lakukan ini dan itu" (memilih jawaban seperti itu adalah bakatnya, karena tidak selalu jawaban yang mengumpulkan lebih banyak suka), ia menggunakan , terlihat: jika ada sesuatu yang berubah, maka baik-baik saja. Jika belum berubah, kami akan mundur. Dan kami ulangi mulai-periksa-cari. Dan dengan cara yang sangat intuitif, ia mencapai hal itu setelah beberapa waktu kodenya bekerja. Dia tidak tahu mengapa, dia tidak tahu apa yang telah dia lakukan, dia tidak bisa menjelaskan. Tapi! Infeksi ini berhasil. Dan "api padam." Sekarang kita mengerti apa yang telah kita lakukan. Ketika program bekerja, itu jauh lebih mudah.Dan secara signifikan menghemat waktu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode ini dijelaskan dengan sangat baik dengan contoh seperti itu. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dulu sangat populer untuk mengumpulkan perahu layar dalam botol. Pada saat yang sama, perahu layar itu besar dan rapuh, dan leher botolnya sangat sempit, Anda tidak bisa mendorongnya ke dalam. Bagaimana cara merakitnya? </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/c-/8-/z5/c-8-z5hphf6b0qo46ruj5mdf1vc.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada metode seperti itu, sangat cepat dan sangat efektif. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kapal itu terdiri dari banyak hal kecil: tongkat, tali, layar, lem. Kami memasukkan semua ini ke dalam botol. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mengambil botol dengan kedua tangan dan mulai gemetaran. Kami gemetaran, gemetar. Dan biasanya - Anda mendapatkan sampah lengkap, tentu saja. Tapi terkadang. Terkadang Anda mendapat kapal! Lebih tepatnya, sesuatu yang mirip dengan kapal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menunjukkan ini kepada seseorang: "Serge, lihat!?". Dan memang, dari jauh - seolah-olah sebuah kapal. Tapi kemudian Anda tidak bisa membiarkan ini pergi.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada cara lain. Orang-orang menggunakan yang lebih maju, peretas seperti itu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memberi orang itu tugas, dia melakukan segalanya dan pergi. Dan Anda melihat - tampaknya harus dilakukan. Dan setelah beberapa saat, ketika perlu untuk memperbaiki kode - itu mulai karena itu ... Ada baiknya dia sudah berhasil lari jauh. Ini adalah orang-orang yang, menggunakan contoh botol, akan melakukan ini: Anda tahu, di mana bagian bawahnya - belokan kaca. Dan tidak sepenuhnya jelas apakah itu transparan atau tidak. Kemudian "peretas" memotong bagian bawah ini, masukkan kapal di sana, lalu tempel bagian bawah lagi, dan seolah-olah diperlukan.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari sudut pandang pengaturan masalah, semuanya tampak benar. Tapi ini adalah contoh kapal: mengapa kapal ini secara umum, siapa yang membutuhkannya? Itu tidak membawa fungsi apa pun. Biasanya kapal semacam itu adalah hadiah bagi orang-orang berpangkat tinggi yang menaruhnya di rak di atas diri mereka, sebagai semacam simbol, sebagai tanda. Dan sekarang, jika orang seperti itu, kepala bisnis besar atau pejabat tinggi, bagaimana bendera itu berdiri seperti sampah, di mana lehernya dipotong? Akan lebih baik jika dia tidak pernah tahu tentang itu. Jadi, bagaimana kapal-kapal ini akhirnya dibuat yang bisa disajikan kepada orang penting?</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Satu-satunya tempat, kunci, yang benar-benar tidak ada yang bisa dilakukan, adalah bangunan. Dan lambung kapal hanya melewati leher. Padahal kapal itu keluar dari botol. Tapi itu bukan hanya untuk merakit kapal, itu adalah kerajinan perhiasan asli. Tuas khusus ditambahkan ke komponen, yang memungkinkan mereka untuk diangkat kemudian. Sebagai contoh, layar dilipat, dengan lembut melayang masuk, dan kemudian dengan bantuan penjepit itu adalah perhiasan, yang pasti, mereka ditarik dan diangkat. Hasilnya adalah sebuah karya seni yang dapat disajikan dengan hati nurani dan kebanggaan yang jelas.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan jika kita ingin proyek itu berhasil, harus ada setidaknya satu perhiasan di tim. </font><font style="vertical-align: inherit;">Siapa pun yang peduli dengan kualitas produk dan memperhitungkan semua aspek, tanpa mengorbankan satu pun, bahkan di saat-saat stres, ketika keadaan memerlukan hal yang mendesak sehingga merugikan yang penting. </font><font style="vertical-align: inherit;">Semua proyek sukses yang berkelanjutan, yang telah teruji oleh waktu, dibangun berdasarkan prinsip ini. </font><font style="vertical-align: inherit;">Mereka memiliki sesuatu yang sangat tepat dan unik, sesuatu yang menggunakan semua fitur yang tersedia. </font><font style="vertical-align: inherit;">Dalam contoh kapal dalam botol, dimainkan bahwa lambung kapal melewati leher.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kembali ke tugas memilih server caching kami, bagaimana metode ini dapat diterapkan? </font><font style="vertical-align: inherit;">Saya mengusulkan opsi seperti itu dari semua sistem yang ada - jangan kocok botolnya, jangan pilih, tetapi lihat apa, pada prinsipnya, mereka memiliki sesuatu yang harus dicari ketika memilih suatu sistem.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tempat mencari leher botol</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita coba untuk tidak mengguncang botol, untuk tidak memilah-milah segala sesuatu yang pada gilirannya, tapi mari kita lihat tugas apa yang muncul, jika tiba-tiba, untuk tugas Anda - untuk merancang sistem seperti itu sendiri. </font><font style="vertical-align: inherit;">Tentu saja, kami tidak akan merakit sepeda, tetapi kami akan menggunakan skema ini untuk mengarahkan diri sendiri pada poin apa yang harus diperhatikan dalam deskripsi produk. </font><font style="vertical-align: inherit;">Kami menguraikan skema seperti itu. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d3/pk/uf/d3pkufjwip_flieqquuhgk-8jlm.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika sistem terdistribusi, maka kami akan memiliki beberapa server (6). </font><font style="vertical-align: inherit;">Katakanlah empat (lebih mudah untuk ditempatkan di gambar, tetapi, tentu saja, ada beberapa jumlahnya). </font><font style="vertical-align: inherit;">Jika server berada pada node yang berbeda, itu berarti bahwa beberapa kode berputar pada mereka semua, yang bertanggung jawab untuk memastikan bahwa node-node ini membentuk sebuah cluster dan, jika terjadi break, terhubung, saling mengenali satu sama lain.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masih membutuhkan logika kode (2), yang sebenarnya tentang caching. Klien berinteraksi dengan kode ini melalui beberapa API. Kode klien (1) dapat berada dalam JVM yang sama, dan mengaksesnya melalui jaringan. Logika yang diimplementasikan di dalam adalah keputusan yang akan ditinggalkan objek dalam cache, yang akan dibuang. Kami menggunakan memori (3) untuk menyimpan cache, tetapi jika perlu, kami juga dapat menyimpan sebagian data pada disk (4).</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat di bagian mana beban akan terjadi. Sebenarnya, setiap panah dan setiap simpul akan dimuat. Pertama, antara kode klien dan api, jika itu adalah interaksi jaringan, penurunan permukaan bisa sangat terlihat. Kedua, dalam kerangka api itu sendiri - setelah ditimpa dengan logika yang kompleks, kita bisa lari ke CPU. Dan akan lebih baik jika logika tidak mendorong memori sekali lagi. Dan masih ada interaksi dengan sistem file - dalam versi yang biasa, serial / dipulihkan dan ditulis / dibaca. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interaksi lebih lanjut dengan cluster. Kemungkinan besar, itu akan berada di sistem yang sama, tetapi bisa secara terpisah. Di sini, Anda juga perlu mempertimbangkan transfer data untuk itu, kecepatan serialisasi data dan interaksi antara cluster.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, di satu sisi, kita dapat membayangkan "roda gigi apa yang akan berputar" dalam sistem cache ketika memproses permintaan dari kode kita, dan di sisi lain, kita dapat memperkirakan apa dan berapa banyak permintaan yang akan dihasilkan oleh kode kita pada sistem ini. Ini cukup untuk membuat pilihan yang kurang lebih bijaksana - untuk memilih sistem untuk use case kita. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hazelcast</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Mari kita lihat bagaimana dekomposisi ini berlaku untuk daftar kami. Misalnya, Hazelcast. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memasukkan / mengambil data dari Hazelcast, kode klien mengakses (1) api. Hz memungkinkan Anda untuk memulai server sebagai tertanam, dan dalam hal ini, mengakses api adalah panggilan metode di dalam JVM, Anda dapat membacanya secara gratis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengerjakan logika di (2), Hz bergantung pada hash dari array byte kunci serial - yaitu, serialisasi kunci akan terjadi dalam hal apa pun. Ini adalah biaya tak terelakkan untuk Hz. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Strategi penggusuran diterapkan dengan baik, tetapi untuk kasus-kasus khusus - Anda dapat menghubungkannya sendiri. Anda tidak perlu khawatir tentang bagian ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penyimpanan (4) dapat dihubungkan. Baik. Interaksi (5) untuk embedded dapat dianggap instan. Pertukaran data antar node dalam cluster (6) - ya, benar. Ini berkontribusi pada ketahanan dengan mengorbankan kecepatan. Fitur Hz dari Near-cache memungkinkan menurunkan harga - data yang diterima dari node lain dari cluster akan di-cache. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa yang dapat dilakukan dalam kondisi seperti itu untuk meningkatkan kecepatan?</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, untuk menghindari serialisasi kunci pada (2), di atas Hazelcast, masukkan cache lain untuk data terpanas. Di Sportmaster, Caffeine dipilih untuk tujuan ini. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memutar di level (6), Hz menawarkan dua jenis penyimpanan: IMap dan ReplicatedMap. </font></font><br>
<img src="https://habrastorage.org/webt/t_/_a/ie/t__aieqdprk1bzb_ac_qpuvn7ro.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlu dikatakan bagaimana Hazelcast masuk ke tumpukan teknologi Sportmaster.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada 2012, ketika kami mengerjakan pilot pertama dari situs masa depan, Hazelcast yang ternyata menjadi tautan pertama yang dikeluarkan mesin pencari. Kenalannya dimulai "pertama kali" - kami terkesan oleh fakta bahwa hanya dua jam kemudian, ketika kami memasukkan Hz ke dalam sistem, itu berhasil. Dan itu bekerja dengan baik. Sampai akhirnya kami menambahkan beberapa tes, kami senang. Dan pasokan semangat ini cukup untuk mengatasi kejutan yang dilontarkan Hz dari waktu ke waktu. Sekarang tim Sportmaster tidak punya alasan untuk menolak dari Hazelcast.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi argumen seperti "tautan pertama di mesin pencari" dan "HelloWorld yang dirakit dengan cepat", tentu saja, merupakan pengecualian dan fitur saat momen di mana pilihan itu terjadi. Tes-tes ini untuk sistem yang dipilih dimulai dengan rilis di prod, dan pada tahap ini Anda harus memperhatikan ketika memilih sistem apa pun, termasuk cache. Sebenarnya, dalam kasus kami, kami dapat mengatakan bahwa kami memilih Hazelcast secara kebetulan, tetapi kemudian ternyata kami memilih yang tepat.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk produksi, ini jauh lebih penting: pemantauan, kegagalan pemrosesan pada masing-masing node, replikasi data, biaya penskalaan. </font><font style="vertical-align: inherit;">Artinya, ada baiknya memperhatikan tugas-tugas yang akan muncul hanya ketika sistem didukung - ketika beban sepuluh kali lebih tinggi dari yang direncanakan, ketika kita secara tidak sengaja mengisi sesuatu ke arah yang salah, ketika Anda perlu meluncurkan versi baru dari kode, mengganti data dan melakukannya tanpa disadari untuk klien. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk semua persyaratan ini, Hazelcast pasti cocok.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bersambung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi Hazelcast bukan obat mujarab. </font><font style="vertical-align: inherit;">Pada 2017, kami memilih Hazelcast untuk cache di panel admin, hanya mengandalkan kesan baik dari pengalaman masa lalu. </font><font style="vertical-align: inherit;">Ini memainkan peran penting dalam lelucon yang sangat jahat, itulah sebabnya kami berada dalam situasi yang sulit dan “heroik” keluar darinya selama 60 hari. </font><font style="vertical-align: inherit;">Tetapi lebih lanjut tentang itu di bagian selanjutnya. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sementara itu ... Selamat Kode Baru!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id490892/index.html">Cara membuat kunci dan iklan untuk Yandex dan Google dari file YML secara gratis</a></li>
<li><a href="../id490894/index.html">Pikiran halus pada arsitektur situs web</a></li>
<li><a href="../id490896/index.html">Prinsip kerja untuk unit perawatan intensif anak-anak dalam bentuk tanggapan terhadap "Programmer, pak dan John Steinbeck" atau</a></li>
<li><a href="../id490906/index.html">Yandex meluncurkan versi beta Aura independen - aura.top. Apakah ini teratas?</a></li>
<li><a href="../id490908/index.html">Penyimpanan data zona</a></li>
<li><a href="../id490916/index.html">Masalah interaksi dengan tim eksternal pada proyek-proyek besar</a></li>
<li><a href="../id490918/index.html">Andrei Zaretsky, Alexander Trukhanov (lanjutan): “Kami tidak memiliki nama, tetapi ada kesombongan”</a></li>
<li><a href="../id490920/index.html">Percepat pencarian Anda di Have I Been Pwned to 49 microseconds (C ++)</a></li>
<li><a href="../id490924/index.html">Apa itu Windows PowerShell dan apa yang dimakannya? Bagian 2: Pengantar bahasa pemrograman</a></li>
<li><a href="../id490926/index.html">Unity ball lintasan 2d untuk pemula</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>