<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♨️ 👩🏾‍🤝‍👨🏿 🏦 Rendering-Optimierung für Mobile, Teil 2. Die Hauptfamilien moderner mobiler GPUs 😵 ✌🏿 🕜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Grüße, liebe Liebhaber und Profis, Grafikprogrammierer! Beginnen wir mit dem zweiten Teil unserer Artikelserie über die Renderoptimierung für Mobilger...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Rendering-Optimierung für Mobile, Teil 2. Die Hauptfamilien moderner mobiler GPUs</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/498564/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grüße, liebe Liebhaber und Profis, Grafikprogrammierer! </font><font style="vertical-align: inherit;">Beginnen wir mit dem zweiten Teil unserer Artikelserie über die Renderoptimierung für Mobilgeräte. </font><font style="vertical-align: inherit;">In diesem Teil werden wir die Hauptfamilien von GPUs betrachten, die von Spielern auf Mobilgeräten vorgestellt werden.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36d/cf7/711/36dcf7711d7ce68544c97bb8dc69ee32.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berücksichtigen Sie zunächst eine Reihe von Kriterien, anhand derer mobile GPUs klassifiziert werden können. </font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitliche oder spezialisierte Shader-Kernel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Ära der frühen mobilen Grafikkarten, bevor sich komplexe Effekte ausbreiteten, gab es einen Standpunkt, dass für Fragment-Shader die Unterstützung von Berechnungen mit reduzierter Genauigkeit ausreichend ist. In einem typischen Anzeigemodus werden tatsächlich 8 oder sogar weniger Bits für jeden Farbkanal verwendet. Diese Ansicht hat zur Verwendung spezialisierter Shader-Kerne geführt. Für die Eckpunkte verwendeten wir Kernel, die für Matrixtransformationen mit erhöhter Genauigkeit FP24 / FP32 ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Highp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><strong><font style="vertical-align: inherit;">optimiert wurden</font></strong><font style="vertical-align: inherit;"> . Für Pixel Kerne, die mit reduzierter Genauigkeit effizienter arbeiten FP16 ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mediump</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Mit diesem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Highp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie wurden nicht unterstützt. </font><font style="vertical-align: inherit;">Diese Spezialisierung ermöglicht es uns auf den ersten Blick, eine rationellere Verteilung der Transistoren auf dem Chip zu erreichen. </font><font style="vertical-align: inherit;">In der Praxis führt dies jedoch zu Schwierigkeiten bei der Entwicklung komplexer Effekte sowie bei der Verwendung hochauflösender Texturen. </font><font style="vertical-align: inherit;">Darüber hinaus kann eine Kernspezialisierung zu einem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertex / Fragment-Engpass führen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dieser Begriff bezieht sich auf die Situation, in der aufgrund der asymmetrischen Belastung der Scheitelpunkt- und Pixelkerne einige der Kerne „inaktiv“ waren.&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/307/144/547/30714454751e34703835ce904cf5f40a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Moderne Architekturen verwenden daher einheitliche Kerne. </font><font style="vertical-align: inherit;">Solche Kernel können abhängig von der Last Scheitelpunkt-, Pixel- und andere Rechenaufgaben übernehmen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/d7c/363/ffed7c363ebecf0d390a0271c1a8b014.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vektor (SIMD) oder skalarer Befehlssatz</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Geiste des oben beschriebenen Wunsches, Transistoren einzusparen, die auf Kerne spezialisiert sind, wurde ein Satz von Shader-Anweisungen entworfen. Die meisten typischen Transformationen für dreidimensionale Grafiken arbeiten mit 4 Komponentenvektoren. Daher arbeiteten frühe GPUs speziell mit solchen Operanden. Wenn der Shader-Code heterogene Skalaroperationen enthielt, die vom Optimierer nicht in Vektoroperationen gepackt werden konnten, wurde ein Teil der Rechenleistung nicht verwendet. Dieses Phänomen kann wie folgt dargestellt werden:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b7/3dd/34a/6b73dd34a79eb4376ed816a37de4a4ae.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen Shader, der die allgemeine Operation "Multiplizieren" implementiert: Multiplizieren Sie 2 Operanden und fügen Sie dann den dritten hinzu. Beim Kompilieren auf einer bedingten </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vektorarchitektur</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Vector ISA = Vector Instruction Set Architecture) erhalten wir einen Vektorbefehl </font><strong><font style="vertical-align: inherit;">vMADD</font></strong><font style="vertical-align: inherit;"> , der für 1 Takt ausgeführt wird. Bei einer bedingten Skalararchitektur erhalten wir 4 Skalarbefehle, die dank einer verbesserten Pipeline auch in einem Taktzyklus ausgeführt werden. Stellen Sie sich nun einen ausgeklügelten Shader vor, der zwei Operationen ausführt, jedoch zwei Operanden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/333/539/b2f/333539b2fb573f8f93ff518ca25f6e5c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Vektorarchitektur erhalten wir bereits 2 Befehle, für deren Ausführung 2 Taktzyklen erforderlich sind. Es werden jedoch keine </font><font style="vertical-align: inherit;">Maßnahmen </font><font style="vertical-align: inherit;">für die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.zw-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Komponenten </font><strong><font style="vertical-align: inherit;">ergriffen</font></strong><font style="vertical-align: inherit;"> , und die Verarbeitungsleistung ist im Leerlauf. Im Fall einer skalaren Architektur können dieselben Operationen in 4 skalaren </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sMADDs gepackt werden</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die im selben 1-Takt-Zyklus ausgeführt werden. Somit wird bei einer skalaren Architektur aufgrund der Verbesserung der Pipeline eine höhere Berechnungsdichte erreicht. Wie unten gezeigt wird, ist der Vektor </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jedoch immer noch relevant. Daher ist es sinnvoll, Vektorisierungstechniken für Shader-Code anzuwenden. Mit ihnen können Sie mit Vektor- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine höhere Leistung auf Grafikkarten erzielen </font><font style="vertical-align: inherit;">. Gleichzeitig beeinträchtigt dies in der Regel nicht die Leistung eines moderneren Skalars</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die ISA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf den oben genannten Merkmalen werden wir die Familien mobiler GPUs betrachten, die in unserer Zeit üblich sind. </font><font style="vertical-align: inherit;">Beginnen wir mit der häufigsten Familie. </font><font style="vertical-align: inherit;">Viele Leute wissen, dass es sich um </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Grafikkarten </font><font style="vertical-align: inherit;">der britischen Firma </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARM handelt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">ARM ist nicht direkt an der Chipherstellung beteiligt und bietet stattdessen geistiges Eigentum an. </font><font style="vertical-align: inherit;">Wie andere mobile Grafikkarten ist Mali Teil von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System on Chip (SoC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , d. H. </font><font style="vertical-align: inherit;">arbeitet mit gemeinsam genutzten </font><font style="vertical-align: inherit;">Speicher </font><font style="vertical-align: inherit;">für die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Bus.&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali utgard</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2008 wurden die ersten Vertreter der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-Utgard-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Architektur </font><strong><font style="vertical-align: inherit;">geboren</font></strong><font style="vertical-align: inherit;"> , die bis heute relevant sind. </font><font style="vertical-align: inherit;">Diese Grafikkarten werden nach dem Mali-4-Schema </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MP </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n benannt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wobei </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Modellnummer und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Anzahl der Fragmentkerne ist. </font><font style="vertical-align: inherit;">In </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader Kernspezialität, und alle Modelle kommen mit einem Scheitelpunkt nur 1 Kern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Merkmale der Mali Utgard-Architektur:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 2.0&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehlende </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Highp-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterstützung </font><font style="vertical-align: inherit;">in fragmentierten Kerneln</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vektorbefehlssatz (es ist sinnvoll, Berechnungen zu vektorisieren)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spezifikation </font><font style="vertical-align: inherit;">kompilieren </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Grafikkartentreiber </font><font style="vertical-align: inherit;">erfolgreich Fragment-Shader, die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hohe</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Präzision verwenden </font><font style="vertical-align: inherit;">(z. B. wird die Genauigkeit standardmäßig mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">präzisem Highp-Float festgelegt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Aber die Genauigkeit von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mediump wird</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tatsächlich verwendet </font><font style="vertical-align: inherit;">. Daher ist es ratsam, zusätzlich alle Shader für Handyspiele auf solchen Grafikkarten zu testen. Nach Angaben von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arbeitete </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ende 2019 </font><font style="vertical-align: inherit;">für etwa 10% der Spieler an Geräten. Und wenn Sie die entsprechenden Filter auf </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">market.yandex.ru einstellen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , können Sie sehen, dass 2019 mehr als 10 neue Telefone mit Grafikkarten dieser Architektur angekündigt wurden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/5a9/8ae/7795a98ae2da31ecf49131939087c21e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie bereit sind, diese Zielgruppe zu verlassen, reicht es aus, die Anforderungen für die OpenGL ES 3.0-Unterstützung in AndroidManifest.xml festzulegen: </font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">uses-feature</span> <span class="hljs-attr">android:glEsVersion</span>=<span class="hljs-string">"0x00030000"</span> <span class="hljs-attr">android:required</span>=<span class="hljs-string">"true"</span>⁄&gt;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neben </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gibt es derzeit keine weit verbreiteten mobilen GPUs ohne Unterstützung für OpenGL ES 3.0. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Besonders hervorzuheben ist die Verwendung hochauflösender Texturen auf dem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Zehn Bits der Mantisse mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mittlerer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Genauigkeit </font><font style="vertical-align: inherit;">reichen für eine qualitativ hochwertige Texturierung mit einer Texturauflösung von mehr als 1024 auf einer Seite nicht aus. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragmentkernen </font><font style="vertical-align: inherit;">nur </font><strong><font style="vertical-align: inherit;">mittlere</font></strong><font style="vertical-align: inherit;"> Genauigkeit </font><font style="vertical-align: inherit;">unterstützt wird </font><font style="vertical-align: inherit;">, können </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Genauigkeit der </font><strong><font style="vertical-align: inherit;">fp24-</font></strong><font style="vertical-align: inherit;"> Texturkoordinaten erhalten, wenn Sie </font><font style="vertical-align: inherit;">direkt </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variieren</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// vertex shader</span><font></font>
varying highp vec2 v_texc;<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
    v_texc = …;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">//  fragment shader</span><font></font>
...<font></font>
varying highp vec2 v_texc;<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
    gl_FragColor = texture2D(u_sampler, v_texc); <span class="hljs-comment">//  v_texc </span>
                                                 <span class="hljs-comment">//  </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Bonus für einige Architekturen können Sie mit diesem Ansatz </font><font style="vertical-align: inherit;">Texturinhalte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorab</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abrufen, bevor Sie einen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment-Shader </font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">ausführen.</font></strong><font style="vertical-align: inherit;"> Dadurch werden </font><strong><font style="vertical-align: inherit;">Verzögerungen</font></strong><font style="vertical-align: inherit;"> minimiert, </font><font style="vertical-align: inherit;">während Sie auf Ergebnisse </font><font style="vertical-align: inherit;">der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texturabtastung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> warten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Midgard</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Utgard wurde</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> durch die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Midgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Architektur ersetzt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es gibt mehrere Generationen dieser Architektur mit den Namen der Arten </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-6xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-7xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-8xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Trotz des 8-jährigen Alters kann </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Midgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als moderne Architektur bezeichnet werden, die die meisten neuen Funktionen unterstützt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unified Shader-Kernel</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 3.2 (Compute &amp; Geometry Shader, Tesselation ...)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Mali Midgard behält jedoch den Vektor </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISA bei</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Angesichts der weit verbreiteten Verwendung von Mali Midgard (etwa 25% unseres Publikums) ist eine Vektorisierung des Computing angemessen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres Merkmal von Mali Midgard ist die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forward Pixel Kill-</font></font></strong></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Technologie </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jedes Pixel wird in einem separaten Strom des Fragmentkerns berechnet. </font><font style="vertical-align: inherit;">Wenn während der Ausführung des Streams bekannt wird, dass das resultierende Pixel durch ein undurchsichtiges Pixel eines anderen Grundelements blockiert wird, wird der Stream vorzeitig beendet und die freigegebenen Ressourcen werden für andere Berechnungen verwendet.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Bifrost</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neben </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Midgard zeichnet sich die </font></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bifrost-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Architektur </font><font style="vertical-align: inherit;">durch den Übergang zur skalaren </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISA aus</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Im Vergleich zur vorherigen Architektur wurde die maximale Anzahl von Kernen erhöht (von 16 auf 32) und eine verbesserte Schnittstelle mit einer CPU unterstützt, die einen kohärenten Zugriff auf den gemeinsam genutzten Speicher ermöglicht: Änderungen am Inhalt des CPU- / GPU-Speichers werden trotz der Caches sofort für einander "sichtbar" ermöglicht es Ihnen, die Synchronisation zu vereinfachen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Von inoffiziell</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wurden viele Versuche unternommen, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Grafikkarten zurückzuentwickeln </font><font style="vertical-align: inherit;">, um </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open Source-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Treiber für </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu erstellen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Arbeiten der engagierten Menschen, die dies versuchen, ermöglichen es uns, einen Blick auf die undokumentierten Funktionen von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Grafikkarten zu werfen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PanFrost-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projekt </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">gibt</font></a><font style="vertical-align: inherit;"> es also einen Disassembler für </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Midgard / Bifrost</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mit dem Sie sich mit einer Reihe von Shader-Anweisungen vertraut machen können (es gibt keine offenen offiziellen Informationen zu diesem Thema).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/f31/751/bbdf3175137a886431a23de54239900e.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweithäufigste Familie mobiler </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Diese Grafikkarte wird auf dem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SoC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> installiert </font><font style="vertical-align: inherit;">, der unter der Marke </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Snapdragon</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der amerikanischen Firma </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualcomm bekannt ist</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Snapdragon ist in den Top-End-Smartphones unserer Zeit von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Samsung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sony</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und anderen </font><font style="vertical-align: inherit;">installiert </font><font style="vertical-align: inherit;">. Die </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aktuellen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Grafikkarten </font><font style="vertical-align: inherit;">sind Familien der Serien 3xx - 6xx. </font><font style="vertical-align: inherit;">Alle diese Serien kombinieren die folgenden Merkmale:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unified Shader-Kernel</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pseudo-TBR (große Kachelgrößen in einem herkömmlichen dedizierten GPU-Speicher)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatisches Umschalten im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sofortmodus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendern je nach Art der Szene ( </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">FlexRender</font></a><font style="vertical-align: inherit;"> )</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skalarbefehlssatz</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ab </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 4xx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird die Unterstützung für </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 3.1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und für </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 5xx - Vulkan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 3.2 eingeführt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf Adreno-Kacheln basierendes Rendering</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adreno-Grafikkarten haben eine „traditionelle“ GPU namens </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GMEM</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es gelten Volumes von 128 KB bis 1536 KB. Auf diese Weise können Sie im Vergleich zu Architekturen anderer Entwickler mobiler GPUs eine größere Kachelgröße verwenden. Bei Adreno ist die Größe der Kacheln dynamisch und hängt vom verwendeten Farbformat, dem Tiefenpuffer und der Schablone ab. Wenn Sie im </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sofortmodus arbeiten,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erfolgt das Rendern im Systemspeicher. Es gibt eine GL ES-Erweiterung, mit der Sie den bevorzugten Modus angeben können: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QCOM_binning_control</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die neuesten Empfehlungen von Qualcomm empfehlen jedoch, sich ausschließlich auf GPU-Treiber zu verlassen, die selbst den am meisten bevorzugten Modus für den von der Anwendung generierten Befehlspuffer bestimmen.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie im </font><strong><font style="vertical-align: inherit;">TBR-</font></strong><font style="vertical-align: inherit;"> Modus arbeiten</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adreno macht 2 Vertex-Pässe:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binning-Pass</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Verteilung der Grundelemente nach Bin ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bins</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ein Synonym für Kacheln)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollständiger </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scheitelpunktdurchlauf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zum Rendern nur der Grundelemente, die in den aktuellen Bin fallen</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während des </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binning-Durchgangs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berechnet Adreno nur die Scheitelpunktpositionen. </font><font style="vertical-align: inherit;">Andere Attribute werden nicht berechnet und unnötiger Code wird vom Optimierer entfernt. </font><font style="vertical-align: inherit;">In der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offiziellen Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (9.2 Scheitelpunktverarbeitung optimieren) wird empfohlen, die zur Berechnung der Positionen erforderlichen Scheitelpunktinformationen getrennt von den übrigen Daten zu speichern. </font><font style="vertical-align: inherit;">Dies macht das Zwischenspeichern von Scheitelpunktdaten effizienter.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Freedreno</font></font></h2><br>
<img src="https://habrastorage.org/getpro/habr/post_images/83e/c3d/15d/83ec3d15dc03e81e81e7d867cae2b3a3.png" align="left" width="120"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Gegensatz zu ARM und Imagination Technologies zögert Qualcomm, die Details der internen Struktur seiner GPUs mitzuteilen. </font><font style="vertical-align: inherit;">Dank der Bemühungen des Reverse Engineers Rob Clark kann jedoch viel aus dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Freedreno-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projekt </font><font style="vertical-align: inherit;">, dem Open-Source- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Treiber </font><font style="vertical-align: inherit;">für Linux </font><font style="vertical-align: inherit;">, gelernt werden </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rob Clark von Freedreno</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR von Imagination Technologies</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagination Technologies</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein britisches Fabless-Unternehmen, das für die Entwicklung von GPUs für Apple-Produkte bekannt ist. </font><font style="vertical-align: inherit;">Das Unternehmen übte diese Rolle bis zum Aufkommen des iPhone 8 / X aus, das die interne Entwicklung von Apple nutzt. </font><font style="vertical-align: inherit;">Obwohl die Empfehlungen zu Optimierungen für diese Chips, die unverändert geblieben sind, sowie Patentansprüche gegen Apple von Imagination darauf hindeuten, dass Apple die PowerVR-Architektur weiterentwickelt hat, eine ursprüngliche Entwicklung von Imagination. </font><font style="vertical-align: inherit;">Zu Beginn des </font><font style="vertical-align: inherit;">Jahres 2020 von </font><font style="vertical-align: inherit;">Apple </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zurückkehrte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die </font><font style="vertical-align: inherit;">Lizenzierung Praktiken mit Imagination Technologies. </font><font style="vertical-align: inherit;">Neben Geräten mit iOS / iPadOS sind PowerVR-Grafikkarten in einer Vielzahl von Android-Smartphones und -Tablets installiert.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9d/86d/b66/a9d86db66b2293beaf3b01d3d809573f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie die Familie der PowerVR-Grafikkarten, die immer noch unter den Benutzern zu finden sind.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR SGX</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten PowerVR SGX-Grafikkarten wurden 2009 veröffentlicht. </font><font style="vertical-align: inherit;">Es gibt mehrere Generationen dieser Architektur: Series5, Series5XT und Series5XE. </font><font style="vertical-align: inherit;">Apple hat diese GPUs bis zum iPAD 4 / iPhone 5 / iPOD Touch 5 verwendet. Die folgenden SGX-Funktionen können angeführt werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unified Shader-Kernel</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 2.0</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vektorbefehlssatz</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterstützung für 10-Bit-Lowp-Präzision in Shadern</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geringe Leistung von abhängigen Texturlesungen</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns einige davon genauer betrachten.&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geringe Genauigkeit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PowerVR SGX sind die einzigen aktuellen mobilen GPUs mit </font></font><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lowp-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hardware-Unterstützung </font><font style="vertical-align: inherit;">. Neuere PowerVR-Modelle sowie alle modernen GPUs anderer Hersteller verwenden tatsächlich eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mittlere</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Genauigkeit </font><font style="vertical-align: inherit;">. Durch die Verwendung von </font></font><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lowp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beim PowerVR SXG können Sie eine höhere Berechnungsdichte erzielen (mehr Operationen pro Zyklus). Gleichzeitig ist die Swizzle-Operation (Permutation der Vektorkomponenten) für </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lowp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Gegensatz zu anderen Präzisionen nicht frei. Diese Funktion sowie der enge Wertebereich, den lowp bietet ([-2,2]), schränken seinen Umfang ein. Gleichzeitig ist der schlecht eingestellte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiefpunkt</font></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> führt zu Artefakten in der SGX-Familie und wird nicht auf allen anderen Grafikkarten </font><strong><font style="vertical-align: inherit;">angezeigt,</font></strong><font style="vertical-align: inherit;"> auf denen tatsächlich eine </font><strong><font style="vertical-align: inherit;">mittlere</font></strong><font style="vertical-align: inherit;"> Genauigkeit verwendet wird </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aus diesem Grund sollten Sie in Betracht ziehen, die Verwendung von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lowp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Shadern zu </font><font style="vertical-align: inherit;">verweigern </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abhängige Textur liest</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie wissen, sind Texturabtastvorgänge am langsamsten, da auf die Leseergebnisse des Speichers gewartet werden muss. Im Fall von mobilem SoC handelt es sich um gemeinsam genutzten Systemspeicher mit einer CPU. Um die Anzahl der Zugriffe auf langsamen Speicher zu verringern, werden Textur-Caches verwendet. Um Ausfallzeiten zu Beginn der Rasterung mithilfe einer Textur zu vermeiden, ist es sinnvoll, die verwendeten Bereiche im Voraus zwischenzuspeichern. Wenn der Fragment-Shader die vom Vertex-Shader übergebene Texturkoordinate ohne Änderungen verwendet, kann der für das Caching erforderliche Texturabschnitt bestimmt werden, bevor der Fragment-Shader ausgeführt wird. Wenn der Fragment-Shader die Texturkoordinate ändert oder sie anhand von Daten aus einer anderen Textur berechnet, ist dies nicht immer möglich. Infolgedessen kann die Ausführung des Fragment-Shaders verlangsamt werden.PowerVR SGX-Grafikkarten sind in diesem Szenario besonders schmerzhaft. Darüber hinaus führt auch die Verwendung einer Permutation der Komponenten der Texturkoordinate (Swizzle) dazu</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abhängige Textur gelesen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Hier ist ein Beispiel für ein Shader-Programm ohne </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abhängiges Lesen der Textur</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scheitelpunktprogramm</font></font></strong><br>
<br>
<pre><code class="cpp hljs">attribute highp vec2 a_texc;<font></font>
varying highp vec2 v_texc;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
	gl_Position = …<font></font>
	v_texc = a_texc;<font></font>
}<font></font>
<font></font>
</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmentprogramm</font></font></strong><br>
<br>
<pre><code class="cpp hljs">precision mediump <span class="hljs-keyword">float</span>;<font></font>
uniform sampler u_sampler;<font></font>
varying highp vec2 v_texc;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
	gl_FragColor = texture2D( u_sampler, v_texc ); <span class="hljs-comment">//  dependent texture read</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall: </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmentprogramm</font></font></strong><br>
<br>
<pre><code class="cpp hljs">precision mediump <span class="hljs-keyword">float</span>;<font></font>
uniform sampler u_sampler;<font></font>
varying highp vec2 v_texc;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
	gl_FragColor = texture2D( u_sampler, v_texc.yx ); <span class="hljs-comment">// dependent texture read!</span><font></font>
}<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR Rogue</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PowerVR-Grafikkarten wurden in der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rogue-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Architektur weiterentwickelt </font><font style="vertical-align: inherit;">. Es gibt mehrere Generationen dieser Architektur: von Serie 6 bis Serie 9. </font><font style="vertical-align: inherit;">Alle </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR Rogue</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verfügen über folgende Funktionen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unified Shader-Kernel</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">skalare Befehlsarchitektur</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterstützung für OpenGL ES 3.0+ (bis zu 3.2 sowie die Vulkan-API für neue Lineale)&nbsp;</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR TBDR</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie alle gängigen mobilen GPUs verwendet PowerVR eine Kachel-Pipeline. Im Gegensatz zu Wettbewerbern ging Imagination jedoch noch einen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> weiter und implementierte eine </font><strong><font style="vertical-align: inherit;">verzögerte</font></strong><font style="vertical-align: inherit;"> Rasterung von Grundelementen, sodass unsichtbare Pixelschattierungen unabhängig von der Renderreihenfolge übersprungen werden konnten. Dieser Ansatz wird als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tile Based Deferred Rendering bezeichnet</font></font></strong></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und der Prozess zum Eliminieren unsichtbarer Pixel wird </font><font style="vertical-align: inherit;">als </font><font style="vertical-align: inherit;">Hidden Surface Removal (HSR) bezeichnet.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff2/2db/1dd/ff22db1dd631bb54e964aa24c96b437f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernen versteckter Oberflächen</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Es wird empfohlen, undurchsichtige Geometrie transparent zu zeichnen und nicht Z Prepass zu verwenden. Dies führt bei PowerVR-Grafikkarten in den meisten Szenarien zu unnötiger Arbeit. </font><font style="vertical-align: inherit;">Mehrere aufeinanderfolgende transparente Pixel, die sich überlappen, sind jedoch vollständig schattiert, um unter Berücksichtigung des Mischens die richtige Farbe zu erhalten. </font><font style="vertical-align: inherit;">Das letzte transparente Pixel kann verworfen werden, wenn auf ein undurchsichtiges Pixel folgt.&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offenheit Imagination Technologies</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Entwickler von PowerVR haben mehr Open-Access-Dokumentation bereitgestellt als andere GPU-Entwickler. </font><font style="vertical-align: inherit;">Die Architektur der Grafikpipeline sowie eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reihe von Anweisungen für die Rogue-Architektur werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausführlich beschrieben </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es gibt ein praktisches Tool </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVRShaderEditor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mit dem Sie </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">sofort</font></a><font style="vertical-align: inherit;"> Profilinformationen zum Shader sowie dessen zerlegte Liste für Rogue erhalten können.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aba/b9a/19e/abab9a19e78e6ff40638d5cdf971615a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz der begrenzten Präsenz von PowerVR-Grafikkarten in der Umgebung von Geräten, die auf Android basieren, ist es sinnvoll, deren Architektur für die kompetente Programmierung von Grafiken für iOS zu untersuchen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mobile GPUs im Sofortmodus</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben die häufigsten Familien mobiler Grafikkarten untersucht. </font><font style="vertical-align: inherit;">Alle diese Familien verwendeten eine Kachel-Rendering-Architektur. </font><font style="vertical-align: inherit;">Es gibt jedoch mobile Grafikkarten, die den traditionellen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sofortmodus-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ansatz verwenden. </font><font style="vertical-align: inherit;">Hier sind einige davon:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nVIdia (Tegra SoC)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Intel-Familien mit Ausnahme der neuesten Gen 11</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vivante GCxxxx (+ Arcturus GC8000)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Merkmal von mobilen Grafikkarten, die im </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sofortmodus arbeiten,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der teure FBO-Reinigungsvorgang. </font><font style="vertical-align: inherit;">Denken Sie daran, dass in der Kachelarchitektur die Vollbildbereinigung das Rendern beschleunigt, sodass der Treiber den Ladevorgang des alten Inhalts nicht zum Kachelspeicher hinzufügen kann. </font><font style="vertical-align: inherit;">Bei mobilen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUs im Sofortmodus ist die</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vollbildbereinigung ein zeitaufwändiger Vorgang, mit dem solche GPUs unter anderem „berechnen“ können. </font><font style="vertical-align: inherit;">Wenn das Hinzufügen einer Bereinigung nicht beschleunigt, sondern das Rendern verlangsamt, arbeiten wir höchstwahrscheinlich mit einer </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU im Sofortmodus</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vergessen wir natürlich nicht zu erwähnen, dass das </font><font style="vertical-align: inherit;">Ändern eines Ziels bei </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUs im</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sofortmodus ein „bedingt freies“ Verfahren ist.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verteilung verschiedener Familien mobiler GPUs auf unsere Player</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier sind die Statistiken zu mobilen GPUs, die Ende 2019 von unseren Spielern gesammelt wurden:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/184/634/e7f1846345e5e8bf798bbf207a11885d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachfolgend öffnen wir das Segment „Sonstige“</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a3/f61/604/8a3f61604361a8c8e426ae0ae8920f05.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf diesen Daten betrachten wir die Verteilung der GPU hinsichtlich ihrer Hauptmerkmale.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b41/b97/3d5/b41b973d5d8d01e817a558d838396d63.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vektor-ALUs (arithmetische Logikeinheit) sind veraltet und werden durch skalare ersetzt. Heutzutage ist der Großteil der mobilen GPUs mit einem Vektorbefehlssatz der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali Midgard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der als durchschnittlich in der Leistung angesehen werden kann. weil Die Vektorisierung verlangsamt in der Regel die Ausführung auf skalaren ALUs nicht. Es lohnt sich, die Vektorisierung als eine tatsächliche Technik zur Optimierung von Shadern für Mobilgeräte zu betrachten.&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Spezialisierte Shader-Kernel sind veraltet und werden durch einheitliche ersetzt. Der Vertex-Engpass am Skelettnetz ist nicht mehr beängstigend. Spezialisierte Kernel werden nur für die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-4xx (Utgard) -Familie verwendet</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Denken Sie daran, dass diese GPUs nur </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenGL ES 2.0 unterstützen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Unser Publikum hat ungefähr 3,5% von ihnen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich verwendet die überwiegende Mehrheit der mobilen GPUs den Kachelansatz. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Sofortmodus ist</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> marginalisiert und wird zusammen mit den Grafikkarten, die ihn verwenden, schnell herausgedrückt. </font><font style="vertical-align: inherit;">Der Anteil der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im </font><strong><font style="vertical-align: inherit;">Sofortmodus</font></strong><font style="vertical-align: inherit;"> an unseren Playern beträgt ca. 0,7%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nützliche Links:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">developer.arm.com/solutions/graphics</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">developer.qualcomm.com/software/adreno-gpu-sdk/tools</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.imgtec.com/developers/powervr-sdk-tools/documentation/</font></font></a></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen Dank für Ihre Aufmerksamkeit! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im nächsten Artikel aus der Reihe werden wir Techniken zur Optimierung von Shadern für Mobile betrachten.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de498548/index.html">Erstellen Sie Ihr eigenes Paket für Laravel Nova: OptimalImage</a></li>
<li><a href="../de498552/index.html">Welche Fehler machen Manager an einem entfernten Standort?</a></li>
<li><a href="../de498556/index.html">Hans Peter Lun und die Geburt des Hash-Algorithmus</a></li>
<li><a href="../de498560/index.html">Webkomponenten in einem realen Projekt</a></li>
<li><a href="../de498562/index.html">Im Gegensatz zur Quarantäne: Wie wir unsere Praktika auf ein Remote-Format übertragen haben</a></li>
<li><a href="../de498566/index.html">Resilience Engineering: Notizen von der REDeploy-Konferenz</a></li>
<li><a href="../de498568/index.html">Im AM2 Am2901 Multi-Chip-Mikroprozessor aus den 1970er Jahren</a></li>
<li><a href="../de498572/index.html">Freaky Rabatte? Aktien von CRM-Anbietern anlässlich des Übergangs zu udalenka</a></li>
<li><a href="../de498574/index.html">Warum habe ich mich entschieden, Spiele oder eine nostalgische Reise für Null zu entwickeln?</a></li>
<li><a href="../de498576/index.html">Wie wir das Feld für die Eingabe neuer Nachrichten in unseren Messenger (Gem4me) entwickelt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>