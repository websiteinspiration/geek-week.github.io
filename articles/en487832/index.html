<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ö∞Ô∏è üëàüèæ üòπ Minecraft Creation in One Week in C ++ and Vulkan ü¶Å üë®‚Äçüë®‚Äçüë¶ üî¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I set myself the task of recreating Minecraft from scratch in one week using my own engine in C ++ and Vulkan. I was inspired by Hopson , who did the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Minecraft Creation in One Week in C ++ and Vulkan</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487832/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I set myself the task of recreating Minecraft from scratch in one week using my own engine in C ++ and Vulkan. </font><font style="vertical-align: inherit;">I was inspired by </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hopson</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , who did the same with C ++ and OpenGL. </font><font style="vertical-align: inherit;">In turn, he was inspired by </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shane Beck</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , who was inspired by Minecraft, the source of inspiration for which was Infiniminer, the creation of which, presumably, was inspired by real mining.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/8b2/50c/aa18b250ce4120bd3a0dc94c01a63621.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The GitHub repository for this project is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Each day has its own git tag. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, I did not plan to literally recreate Minecraft. </font><font style="vertical-align: inherit;">This project was supposed to be an educational one. </font><font style="vertical-align: inherit;">I wanted to learn about using Vulkan in something more complicated than </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vulkan-tutorial.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or the demo of Sasha Willem. </font><font style="vertical-align: inherit;">Therefore, the main emphasis is on the design of the Vulkan engine, and not on the design of the game.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tasks</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Development on Vulkan is much slower than on OpenGL, so I couldn‚Äôt incorporate many of the features of this Minecraft into the game. </font><font style="vertical-align: inherit;">There are no mobs, no crafting, no red stone, no block physics, etc. </font><font style="vertical-align: inherit;">From the very beginning, the objectives of the project were as follows:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creating a terrain rendering system</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mashing</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lighting</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creating a terrain generator system</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relief</font></font></li>
</ul><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trees</font></font></li>
</ul><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomes</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adding the ability to change terrain and move blocks</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I needed to find a way to implement all this without adding a GUI to the game, because I could not find any GUI libraries that work with Vulkan and were easy to integrate.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Libraries</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, I was not going to write a Vulkan application from scratch. </font><font style="vertical-align: inherit;">To speed up the development process, I will use ready-made libraries whenever possible. </font><font style="vertical-align: inherit;">Namely:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VulkanWrapper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - my own C ++ wrapper for the Vulkan API</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GLFW</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - for windows and user input</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VulkanMemoryAllocator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - for allocating Vulkan memory</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GLM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - for math vectors and matrices</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - for signals / slots and ECS</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stb</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - for image loading utilities</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FastNoise</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - for generating 3D noise</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Day 1</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the first day, I prepared a Vulkan boilerplate and an engine skeleton. </font><font style="vertical-align: inherit;">Most of the code was a boilerplate and I could just copy it from </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vulkan-tutorial.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It also included a trick with storing vertex data as part of a vertex shader. </font><font style="vertical-align: inherit;">This meant that I didn't even have to tune the memory allocation. </font><font style="vertical-align: inherit;">Just a simple conveyor that can do only one thing: draw a triangle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The engine is simple enough to support the renderer of triangles. </font><font style="vertical-align: inherit;">It has one window and a game loop to which systems can be connected. </font><font style="vertical-align: inherit;">The GUI is limited by the frame rate displayed in the window title. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The project is divided into two parts: </font></font><code>VoxelEngine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>VoxelGame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/875/3cd/190/8753cd190975239ad550e8c0c8b27d00.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Day 2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I integrated the Vulkan Memory Allocator library. </font><font style="vertical-align: inherit;">This library takes care of most of the Vulkan memory allocation boilerplate: memory types, device memory heaps, and secondary allocation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now that I had a memory allocation, I created classes for meshes and vertex buffers. </font><font style="vertical-align: inherit;">I changed the renderer of the triangles so that it uses the class of meshes, and not the arrays built into the shader. </font><font style="vertical-align: inherit;">Currently, mesh data is transferred to the GPU by manually rendering the triangles.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/627/28d/0fc/62728d0fce9015f2be4dad88f18c7b7a.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Little has changed</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Day 3</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I added a graph rendering system. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This post was</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> taken as a basis for creating this class </font><font style="vertical-align: inherit;">, but the class is very simplified. My rendering graph contains only the essentials for handling synchronization with Vulkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The rendering graph allows me to set </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nodes</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">edges</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nodes are the work performed by the GPU. Ribs are data dependencies between nodes. Each node receives its own instruction buffer, in which it writes. The graph is engaged in double buffering command buffers and synchronizing them with previous frames. Edges are used to automatically insert conveyor barriers before and after a node writes to each instruction buffer. Pipeline barriers synchronize the use of all resources and transfer ownership between queues. In addition, edges insert semaphores between nodes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nodes and edges form a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">directed acyclic graph</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Then the rendering graph performs </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">topological sorting.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nodes, which leads to the creation of a flat list of nodes sorted so that each node goes after all the nodes on which it depends. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The engine has three types of nodes. </font></font><code>AcquireNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">receives an image from a buffer chain (swapchain), </font></font><code>TransferNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transfers data from the CPU to the GPU, and </font></font><code>PresentNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">provides an image of a buffer chain to be displayed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each node can implement </font></font><code>preRender</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>postRender</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which are executed in each frame. </font></font><code>AcquireNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gets an image of a chain of buffers during </font></font><code>preRender</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>PresentNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">provides this image on time </font></font><code>postRender</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I refactored the triangle renderer so that it uses a rendering graph system, rather than processing everything myself. There is an edge between </font></font><code>AcquireNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>TriangleRenderer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as well as between </font></font><code>TriangleRenderer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>PresentNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This ensures that the image of the buffer chain is correctly synchronized during its use during the frame.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12b/d88/6ba/12bd886ba9b41891ae1e2d0ff47b9929.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I swear inside the engine has changed</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Day 4</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I created a camera and a 3D rendering system. So far, the camera receives its own persistent buffer and descriptor pool. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I slowed down that day because I was trying to find the right configuration for 3D rendering with Vulkan. Most online material focuses on rendering using OpenGL, which uses slightly different coordinate systems from Vulkan. In OpenGL, the Z axis of the clip space is specified as </font></font><code>[-1, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the top edge of the screen is at </font></font><code>Y = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In Vulkan, the Z axis is specified as </font></font><code>[0, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the top edge of the screen is at </font></font><code>Y = -1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Due to these small differences, the standard GLM projection matrices do not work correctly because they are designed for OpenGL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GLM has an option</font></font><code>GLM_FORCE_DEPTH_ZERO_TO_ONE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, eliminating the problem with the Z axis. After that, the problem with the Y axis can be eliminated by simply changing the sign of </font></font><code>(1, 1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the projection matrix </font><font style="vertical-align: inherit;">element </font><font style="vertical-align: inherit;">(GLM uses indexing from 0). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we flip the Y axis, then we need to flip the vertex data, because before that, the negative direction of the Y axis pointed up.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/05d/464/8d905d4643a189400471c7e8d4fbd3f6.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now in 3D!</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Day 5</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I added user input and the ability to move the camera with the mouse. </font><font style="vertical-align: inherit;">The input system is too complicated, but it eliminates the oddities of GLFW input. </font><font style="vertical-align: inherit;">In particular, I had the problem of changing the position of the mouse while blocking it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keyboard and mouse input is essentially a thin wrapper on top of GLFW, opened through signal handlers </font></font><code>entt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Just for comparison - about the same thing Hopson did on day 1 of his project.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Your browser does not support HTML5 video.</font></font><source src="https://vazgriz.com/wp-content/uploads/2020/01/voxels.webm" type="video/webm"></video></div></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Day 6</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I started adding code to generate and render voxel blocks. </font><font style="vertical-align: inherit;">Writing the meshing code was easy because I did it before and knew abstractions that allowed me to make fewer mistakes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the abstractions was a template class </font></font><code>ChunkData&lt;T, chunkSize&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that defines a cube of type the </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size </font></font><code>chunkSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of each side. </font><font style="vertical-align: inherit;">This class stores data in a 1D array and processes indexing data with a 3D coordinate. </font><font style="vertical-align: inherit;">The size of each block is 16 x 16 x 16, so the internal data is a simple array of length 4096. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another is to provide an abstraction iterator positions by generating coordinates </font></font><code>(0, 0, 0)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to</font></font><code>(15, 15, 15)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">These two classes ensure that iterations with block data are performed in a linear order to increase cache locality. </font><font style="vertical-align: inherit;">The 3D coordinate is still available for other operations that need it. </font><font style="vertical-align: inherit;">For instance:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (glm::ivec3 pos : Chunk::Positions()) {<font></font>
    <span class="hljs-keyword">auto</span>&amp; data = chunkData[pos];<font></font>
    glm::ivec3 offset = ...;<font></font>
    <span class="hljs-keyword">auto</span>&amp; neighborData = chunkData[pos + offset];<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I have several static arrays that specify the offsets that are commonly used in the game. </font><font style="vertical-align: inherit;">For example, it </font></font><code>Neighbors6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defines 6 neighbors with which the cube has common faces.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;glm::ivec3, 6&gt; Neighbors6 = {<font></font>
        glm::ivec3(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),    <span class="hljs-comment">//right</span><font></font>
        glm::ivec3(<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),   <span class="hljs-comment">//left</span><font></font>
        glm::ivec3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),    <span class="hljs-comment">//top</span><font></font>
        glm::ivec3(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>),   <span class="hljs-comment">//bottom</span><font></font>
        glm::ivec3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),    <span class="hljs-comment">//front</span><font></font>
        glm::ivec3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)    <span class="hljs-comment">//back</span><font></font>
    };</code></pre><br>
<code>Neighbors26</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- these are all neighbors with whom the cube has a common face, edge or vertex. </font><font style="vertical-align: inherit;">That is, it is a 3x3x3 grid without a central cube. </font><font style="vertical-align: inherit;">There are also similar arrays for other sets of neighbors and for 2D sets of neighbors. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is an array defining the data needed to create one face of the cube. </font><font style="vertical-align: inherit;">The directions of each face in this array correspond to the directions in the array </font></font><code>Neighbors6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;FaceArray, 6&gt; NeighborFaces = {<font></font>
    <span class="hljs-comment">//right face</span><font></font>
    FaceArray {<font></font>
        glm::ivec3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<font></font>
        glm::ivec3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),<font></font>
        glm::ivec3(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),<font></font>
        glm::ivec3(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<font></font>
    },<font></font>
    ...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thanks to this, the mesh creation code is very simple. It simply bypasses the data of the blocks and adds a face when the block is solid, but its neighbor is not. The code simply checks every face of every cube in a block. This is similar to the "naive" method described </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (glm::ivec3 pos : Chunk::Positions()) {<font></font>
    Block block = chunk.blocks()[pos];<font></font>
    <span class="hljs-keyword">if</span> (block.type == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; Chunk::Neighbors6.size(); i++) {<font></font>
        glm::ivec3 offset = Chunk::Neighbors6[i];<font></font>
        glm::ivec3 neighborPos = pos + offset;<font></font>
<font></font>
        <span class="hljs-comment">//<span class="hljs-doctag">NOTE:</span> bounds checking omitted</span><font></font>
<font></font>
        <span class="hljs-keyword">if</span> (chunk.blocks()[neighborPos].type == <span class="hljs-number">0</span>) {<font></font>
            Chunk::FaceArray&amp; faceArray = Chunk::NeighborFaces[i];<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> j = <span class="hljs-number">0</span>; j &lt; faceArray.size(); j++) {<font></font>
                m_vertexData.push_back(pos + faceArray[j]);<font></font>
                m_colorData.push_back(glm::i8vec4(pos.x * <span class="hljs-number">16</span>, pos.y * <span class="hljs-number">16</span>, pos.z * <span class="hljs-number">16</span>, <span class="hljs-number">0</span>));<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I replaced </font></font><code>TriangleRenderer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with </font></font><code>ChunkRenderer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. I also added a depth buffer so that the block mesh can render correctly. It was necessary to add one more edge to the rendering graph between </font></font><code>TransferNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>ChunkRenderer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This edge transfers ownership of the resources of the queue family between the transfer queue and the graphics queue. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then I changed the engine so that it could correctly handle window change events. In OpenGL, this is done simply, but rather confusingly in Vulkan. Since the chain of buffers must be created explicitly and have a constant size, when you resize the window, you need to recreate it. You must recreate all resources that depend on the buffer chain.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All commands that depend on the buffer chain (and now these are all drawing commands) must complete execution before destroying the old buffer chain. </font><font style="vertical-align: inherit;">This means that the entire GPU will be idle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You need to change the graphics pipeline to provide a dynamic viewport and resizing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A buffer chain cannot be created if the window size is 0 on the X or Y axis. Including when the window is minimized. </font><font style="vertical-align: inherit;">That is, when this happens, the whole game is paused and continues only when the window unfolds. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now the mesh is a simple three-dimensional chessboard. </font><font style="vertical-align: inherit;">The RGB colors of the mesh are set according to its XYZ position multiplied by 16.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Your browser does not support HTML5 video.</font></font><source src="https://vazgriz.com/wp-content/uploads/2020/01/voxels2.webm" type="video/webm"></video></div></div></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Day 7</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I made the game process not one, but several blocks at a time. Multiple blocks and their meshes are managed by the ECS library </font></font><code>entt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Then I refactored the block renderer so that it rendered all the blocks that are in ECS. I still have only one block, but I </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">could</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> add new ones if necessary. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I refactored the mesh so that its data could be updated after it was created. This will allow me to update the block mesh in the future when I add the ability to add and remove cubes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When you add or remove a cube, the number of vertices in the mesh can potentially increase or decrease. The previously selected vertex buffer can only be used if the new mesh is the same size or smaller. But if the mesh is larger, then new vertex buffers must be created.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The previous vertex buffer cannot be deleted immediately. There may be instruction buffers executed from previous frames that are specific to a particular object </font></font><code>VkBuffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The engine must keep a buffer until these command buffers are complete. That is, if we draw a mesh in a frame </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the GPU can use this buffer before the frame starts </font></font><code>i + 2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The buffer cannot be removed from the CPU until the GPU has finished using it. So I changed the rendering graph so that it tracks the lifetime of the resources. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the rendering graph node wants to use a resource (buffer or image), then it must call the method </font></font><code>sync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inside the method </font></font><code>preRender</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This method gets a pointer </font></font><code>shared_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to a resource. This</font></font><code>shared_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ensures that the resource will not be deleted while command buffers are executed. </font><font style="vertical-align: inherit;">(In terms of performance, this solution is not very good. More on this later.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now the block mesh is regenerated in each frame.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Your browser does not support HTML5 video.</font></font><source src="https://vazgriz.com/wp-content/uploads/2020/01/voxels3.webm" type="video/webm"></video></div></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's all that I did in a week - prepared the basics of rendering the world with multiple voxel blocks and will continue to work in the second week.</font></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en487812/index.html">Testing Polish LED Spectrum Led E27</a></li>
<li><a href="../en487814/index.html">Speed ‚Äã‚Äãand reliability are higher, and the price is lower. New Kingston KC2000 Solid State Drives</a></li>
<li><a href="../en487822/index.html">AvitoTech On Tour: Android meetup in Nizhny Novgorod</a></li>
<li><a href="../en487824/index.html">Overview of LED lamps Spectrum Led GU10 from Europe</a></li>
<li><a href="../en487826/index.html">Overview of LED lamps from Poland Spectrum Led E14</a></li>
<li><a href="../en487834/index.html">Security Week 07: Android Bluetooth Stack Vulnerability</a></li>
<li><a href="../en487836/index.html">Interactive upload of files to the server using RxJS</a></li>
<li><a href="../en487838/index.html">Data Validation: A Different Approach</a></li>
<li><a href="../en487842/index.html">2 SIM for a country router - is it a lot or a little?</a></li>
<li><a href="../en487844/index.html">The smell reveals</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>