<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌙 🍫 🖼️ Unveränderliche Datenstrukturen auf dem neuesten Stand der Technik 🤜 👨🏼‍⚖️ 🤜🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seit Jahren diskutieren Experten in C ++ die Semantik von Werten, Unveränderlichkeit und gemeinsamer Nutzung von Ressourcen durch Kommunikation. Über ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Unveränderliche Datenstrukturen auf dem neuesten Stand der Technik</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/487100/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seit Jahren diskutieren Experten in C ++ die Semantik von Werten, Unveränderlichkeit und gemeinsamer Nutzung von Ressourcen durch Kommunikation. </font><font style="vertical-align: inherit;">Über eine neue Welt ohne Mutexe und Rassen, ohne Befehls- und Beobachtermuster. </font><font style="vertical-align: inherit;">In der Tat ist nicht alles so einfach. </font><font style="vertical-align: inherit;">Das Hauptproblem liegt immer noch in unseren Datenstrukturen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6o/pu/18/6opu18ei6gi5dbo8dvcsgopyebq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unveränderliche Datenstrukturen ändern ihre Werte nicht. Um etwas mit ihnen zu tun, müssen Sie neue Werte erstellen. Die alten Werte bleiben an derselben Stelle, sodass sie ohne Probleme und Sperren aus verschiedenen Streams gelesen werden können. Infolgedessen können Ressourcen rationaler und geordneter geteilt werden, da alte und neue Werte gemeinsame Daten verwenden können. Dank dessen sind sie viel schneller miteinander zu vergleichen und speichern die Betriebsgeschichte kompakt mit der Möglichkeit der Stornierung. All dies passt perfekt zu Multithread- und interaktiven Systemen: Solche Datenstrukturen vereinfachen die Architektur von Desktop-Anwendungen und ermöglichen eine bessere Skalierung von Diensten. Unveränderliche Strukturen sind das Erfolgsgeheimnis von Clojure und Scala, und sogar die JavaScript-Community nutzt sie jetzt, da sie über die Bibliothek Immutable.js verfügen.geschrieben in den Eingeweiden der Firma Facebook.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter dem Schnitt - Video und Übersetzung des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juan Puente-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berichts </font><font style="vertical-align: inherit;">von der C ++ Russia 2019 Moskauer Konferenz. </font><font style="vertical-align: inherit;">Juan spricht über </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , eine Bibliothek unveränderlicher Strukturen für C ++. </font><font style="vertical-align: inherit;">In der Post:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">architektonische Vorteile der Immunität;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellung eines effektiven persistenten Vektortyps basierend auf RRB-Bäumen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse der Architektur am Beispiel eines einfachen Texteditors.</font></font></li>
</ul><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/dbFfpTp3EhA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Tragödie der wertebasierten Architektur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Bedeutung unveränderlicher Datenstrukturen zu verstehen, diskutieren wir die Semantik von Werten. Dies ist eine sehr wichtige Funktion von C ++. Ich halte sie für einen der Hauptvorteile dieser Sprache. Bei alledem ist es sehr schwierig, die Semantik von Werten so zu verwenden, wie wir es möchten. Ich glaube, dass dies die Tragödie der wertorientierten Architektur ist und der Weg zu dieser Tragödie mit guten Absichten gepflastert ist. Angenommen, wir müssen interaktive Software schreiben, die auf einem Datenmodell mit einer Darstellung eines vom Benutzer bearbeitbaren Dokuments basiert. Wenn Architektur basierend auf den Werten im Zentrum dieses Modells einfach und bequem Arten von Werten verwendet , </font><font style="vertical-align: inherit;">dass es bereits in der Sprache: </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>tuple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font><code>struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Anwendungslogik wird aus Funktionen erstellt, die Dokumente nach Wert erfassen und eine neue Version eines Dokuments nach Wert zurückgeben. Dieses Dokument kann sich innerhalb der Funktion ändern (wie unten beschrieben), aber die Semantik der Werte in C ++, die auf das Argument nach Wert und den Rückgabetyp nach Wert angewendet wird, stellt sicher, dass keine Nebenwirkungen auftreten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/7e/0y/fh7e0ybdwuqnh3iona30quev4ja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktion ist sehr einfach zu analysieren und zu testen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cb/5c/4x/cb5c4xq-hps1x76mn-fmweshklu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da wir mit Werten arbeiten, werden wir versuchen, das Rückgängigmachen der Aktion zu implementieren. Dies kann schwierig sein, aber mit unserem Ansatz ist es eine triviale Aufgabe: Wir haben </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit verschiedenen Zuständen verschiedene Kopien des Dokuments.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d-/vh/nd/d-vhndh9j8leugdcjoyf3b4yhqq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben auch eine Benutzeroberfläche, und um deren Reaktionsfähigkeit sicherzustellen, muss die Zuordnung der Benutzeroberfläche in einem separaten Thread erfolgen. Das Dokument wird per Nachricht an einen anderen Stream gesendet, und die Interaktion erfolgt auch auf der Grundlage von Nachrichten und nicht über die gemeinsame Nutzung des Status mithilfe von </font></font><code>mutexes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn die Kopie vom zweiten Stream empfangen wird, können Sie dort alle erforderlichen Vorgänge ausführen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/to/xx/kc/toxxkcwck44iayev1hywf-wqllk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Speichern eines Dokuments auf der Festplatte ist häufig sehr langsam, insbesondere wenn das Dokument groß ist. Daher wird die Verwendung </font></font><code>std::async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieser Operation asynchron ausgeführt. Wir verwenden ein Lambda, setzen ein Gleichheitszeichen ein, um eine Kopie zu erhalten, und jetzt können Sie ohne andere primitive Arten der Synchronisation speichern.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ve/ey/jj/veeyjjijubbrc49-ghusxnuft4e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir weiter an, wir haben auch einen Schallkontrollfluss. Wie gesagt, ich habe viel mit Musiksoftware gearbeitet, und Sound ist eine weitere Darstellung unseres Dokuments. Es muss sich in einem separaten Stream befinden. Daher ist für diesen Stream auch eine Kopie des Dokuments erforderlich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Ergebnis haben wir ein sehr schönes, aber nicht zu realistisches Schema erhalten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dj/w2/hu/djw2hu7q55lbi2nmgmwok1i_cb0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es müssen ständig Dokumente kopiert werden, der Aktionsverlauf für das Abbrechen dauert Gigabyte, und für jedes Rendern der Benutzeroberfläche müssen Sie eine tiefe Kopie des Dokuments erstellen. Im Allgemeinen sind alle Interaktionen zu kostspielig.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uq/sv/8-/uqsv8-sx3hphtcm9wvozi1z83fs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was macht der C ++ - Entwickler in dieser Situation? Anstatt ein Dokument nach Wert zu akzeptieren, akzeptiert die Anwendungslogik jetzt einen Link zum Dokument und aktualisiert es bei Bedarf. In diesem Fall müssen Sie nichts zurückgeben. Aber jetzt geht es nicht um Werte, sondern um Objekte und Orte. Dies führt zu neuen Problemen: Wenn eine Verbindung zum Status mit gemeinsamem Zugriff besteht, benötigen Sie diese </font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies ist äußerst kostspielig, daher wird unsere Benutzeroberfläche in Form eines äußerst komplexen Baums aus verschiedenen Widgets dargestellt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle diese Elemente sollten aktualisiert werden, wenn sich ein Dokument ändert. Daher ist ein Warteschlangenmechanismus für Änderungssignale erforderlich. Darüber hinaus besteht die Historie des Dokuments nicht mehr aus einer Reihe von Zuständen, sondern aus einer Implementierung des Teammusters. Die Operation muss zweimal in die eine und in die andere Richtung ausgeführt werden und sicherstellen, dass alles symmetrisch ist. Das Speichern in einem separaten Thread ist bereits zu schwierig, daher muss dies abgebrochen werden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dl/lr/sj/dllrsjhkvqxxckjx1r69lflqck4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Benutzer sind bereits an das Sanduhrbild gewöhnt, daher ist es in Ordnung, wenn sie etwas warten. Eine andere Sache ist beängstigend - das Pasta-Monster regiert jetzt unseren Code.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ab wann ging es bergab? </font><font style="vertical-align: inherit;">Wir haben unseren Code sehr gut gestaltet und mussten dann aufgrund des Kopierens Kompromisse eingehen. </font><font style="vertical-align: inherit;">In C ++ muss das Kopieren jedoch nur für veränderbare Daten als Wert übergeben werden. </font><font style="vertical-align: inherit;">Wenn das Objekt unveränderlich ist, kann der Zuweisungsoperator so implementiert werden, dass nur der Zeiger auf die interne Darstellung und nichts weiter kopiert wird.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich eine Datenstruktur vor, die uns helfen könnte. </font><font style="vertical-align: inherit;">Im folgenden Vektor sind alle Methoden als markiert </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sodass sie unveränderlich sind. </font><font style="vertical-align: inherit;">Bei der Ausführung </font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird der Vektor nicht aktualisiert, sondern es wird ein neuer Vektor zurückgegeben, zu dem die übertragenen Daten hinzugefügt werden. </font><font style="vertical-align: inherit;">Leider können wir bei diesem Ansatz keine eckigen Klammern verwenden, da diese definiert sind. </font><font style="vertical-align: inherit;">Stattdessen können Sie die Funktion verwenden</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies gibt eine neue Version mit einem aktualisierten Element zurück. Unsere Datenstruktur hat jetzt eine Eigenschaft, die in der funktionalen Programmierung als Persistenz bezeichnet wird. Dies bedeutet nicht, dass wir diese Datenstruktur auf der Festplatte speichern, sondern dass beim Aktualisieren der alte Inhalt nicht gelöscht wird. Stattdessen wird ein neuer Zweig unserer Welt erstellt, dh die Struktur. Dank dessen können wir vergangene Werte mit gegenwärtigen vergleichen - dies geschieht mit Hilfe von zwei </font></font><code>assert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};
<span class="hljs-keyword">const</span> auto v1 = v0.push_back(<span class="hljs-number">15</span>);
<span class="hljs-keyword">const</span> auto v2 = v1.push_back(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> auto v3 = v2.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">42</span>);<font></font>
<font></font>
assert(v2.size() == v0.size() + <span class="hljs-number">2</span>);<font></font>
assert(v3[<span class="hljs-number">0</span>] - v1[<span class="hljs-number">0</span>] == <span class="hljs-number">27</span>);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Änderungen können jetzt direkt überprüft werden, sie sind keine versteckten Eigenschaften der Datenstruktur mehr. Diese Funktion ist besonders in interaktiven Systemen nützlich, in denen wir ständig Daten ändern müssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine weitere wichtige Eigenschaft ist das strukturelle Teilen. Jetzt kopieren wir nicht alle Daten für jede neue Version der Datenstruktur. Auch mit </font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht alle Daten werden kopiert, sondern nur ein kleiner Teil davon. Alle unsere Gabeln haben gemeinsamen Zugriff auf eine kompakte Ansicht, die proportional zur Anzahl der Änderungen und nicht zur Anzahl der Kopien ist. Daraus folgt auch, dass der Vergleich sehr schnell ist: Wenn alles in einem Speicherblock, in einem Zeiger gespeichert ist, können Sie einfach die Zeiger vergleichen und nicht die darin enthaltenen Elemente untersuchen, wenn sie gleich sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da ein solcher Vektor meiner Meinung nach äußerst nützlich ist, habe ich ihn in einer separaten Bibliothek implementiert: Dies ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - eine Bibliothek unveränderlicher Strukturen, ein Open-Source-Projekt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Schreiben wollte ich, dass die Verwendung den C ++ - Entwicklern vertraut ist. </font><font style="vertical-align: inherit;">Es gibt viele Bibliotheken, die die Konzepte der funktionalen Programmierung in C ++ implementieren, aber es entsteht der Eindruck, dass die Entwickler für Haskell und nicht für C ++ schreiben. </font><font style="vertical-align: inherit;">Dies schafft Unannehmlichkeiten. </font><font style="vertical-align: inherit;">Außerdem habe ich gute Leistungen erzielt. </font><font style="vertical-align: inherit;">Benutzer verwenden C ++, wenn die verfügbaren Ressourcen begrenzt sind. </font><font style="vertical-align: inherit;">Schließlich wollte ich, dass die Bibliothek anpassbar ist. </font><font style="vertical-align: inherit;">Diese Anforderung hängt mit der Leistungsanforderung zusammen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf der Suche nach einem magischen Vektor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im zweiten Teil des Berichts werden wir untersuchen, wie dieser unveränderliche Vektor strukturiert ist. Der einfachste Weg, die Prinzipien einer solchen Datenstruktur zu verstehen, besteht darin, mit einer regulären Liste zu beginnen. Wenn Sie mit der funktionalen Programmierung ein wenig vertraut sind (am Beispiel von Lisp oder Haskell), wissen Sie, dass Listen die häufigsten unveränderlichen Datenstrukturen sind. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rn/ou/d6/rnoud6a8vaqpet2jg-n18be85fk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir zunächst an, wir haben eine Liste mit einem einzelnen Knoten </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn Sie neue Elemente zum Anfang der Liste hinzufügen, werden neue Knoten erstellt, von denen jeder einen Zeiger auf einen vorhandenen Knoten hat. Daher haben wir im Beispiel auf der Folie nicht drei Kopien einer Liste, sondern drei Elemente im Speicher, dh </font></font><code>v1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie </font></font><code>v0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zeigen unterschiedliche Elemente an. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bm/nf/bh/bmnfbhtdmbu_kdm_xlpuxleld2w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können auch eine Gabelung der Realität erstellen, dh eine neue Liste erstellen, die das gleiche Ende, aber einen anderen Anfang hat.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solche Datenstrukturen wurden lange untersucht: Chris Okasaki schrieb die grundlegende Arbeit von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Purely Functional Data Structures</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Darüber hinaus ist die von Ralf Hinze und Ross Paterson vorgeschlagene </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finger Tree-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datenstruktur sehr interessant </font><font style="vertical-align: inherit;">. Für C ++ funktionieren solche Datenstrukturen jedoch nicht gut. Sie verwenden kleine Knoten, und wir wissen, dass kleine Knoten in C ++ einen Mangel an Caching-Effizienz bedeuten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus stützen sie sich häufig auf Eigenschaften, die C ++ nicht besitzt, wie z. B. Faulheit. Daher ist die Arbeit von Phil Bagwell an unveränderlichen Datenstrukturen für uns viel nützlicher - ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der Anfang der 2000er Jahre geschrieben wurde, sowie die Arbeit von Rich Hickey - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Autor von Clojure. Rich Hickey hat eine Liste erstellt, die eigentlich keine Liste ist, sondern auf modernen Datenstrukturen basiert: Vektoren und Hash-Maps. Diese Datenstrukturen weisen eine Caching-Effizienz auf und interagieren gut mit modernen Prozessoren, für die es unerwünscht ist, mit kleinen Knoten zu arbeiten. Solche Strukturen können in C ++ verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie baue ich einen Immunvektor auf? Im Herzen jeder Struktur, die auch nur aus der Ferne einem Vektor ähnelt, muss sich ein Array befinden. Das Array verfügt jedoch nicht über eine strukturelle Freigabe. Um ein Element des Arrays zu ändern, ohne die Persistenz-Eigenschaft zu verlieren, müssen Sie das gesamte Array kopieren. Um dies nicht zu tun, kann das Array in separate Teile aufgeteilt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir jetzt ein Vektorelement aktualisieren, müssen wir nur ein Stück und nicht den gesamten Vektor kopieren. Aber solche Teile selbst sind keine Datenstruktur, sie müssen auf die eine oder andere Weise kombiniert werden. Legen Sie sie in ein anderes Array. Erneut tritt das Problem auf, dass das Array sehr groß sein kann und das erneute Kopieren zu lange dauert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir teilen dieses Array in Teile, platzieren sie erneut in einem separaten Array und wiederholen diesen Vorgang, bis nur noch ein Root-Array vorhanden ist. Die resultierende Struktur wird als Restbaum bezeichnet. Dieser Baum wird durch die Konstante M = 2B, dh den Verzweigungsfaktor, beschrieben. Dieser Verzweigungsindikator sollte eine Zweierpotenz sein, und wir werden sehr bald herausfinden, warum. In dem Beispiel auf der Folie werden Blöcke mit vier Zeichen verwendet, in der Praxis werden jedoch Blöcke mit 32 Zeichen verwendet. Es gibt Experimente, mit denen Sie die optimale Blockgröße für eine bestimmte Architektur finden können. Auf diese Weise können Sie das beste Verhältnis zwischen strukturellem gemeinsamem Zugriff und Zugriffszeit erzielen: Je niedriger der Baum, desto weniger Zugriffszeit.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entwickler, die dies in C ++ schreiben, denken wahrscheinlich: Aber alle baumbasierten Strukturen sind sehr langsam! Bäume wachsen mit zunehmender Anzahl von Elementen in ihnen, und aus diesem Grund werden die Zugriffszeiten verkürzt. Deshalb bevorzugen Programmierer </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eher als </font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ich beeile mich, Sie zu beruhigen: Unser Baum wächst sehr langsam. Ein Vektor, der alle möglichen Werte eines 32-Bit-Int enthält, ist nur 7 Ebenen hoch. Es kann experimentell gezeigt werden, dass bei dieser Datengröße das Verhältnis des Caches zum Lastvolumen die Leistung erheblich beeinflusst als die Tiefe des Baums. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie ein Zugriff auf ein Element eines Baumes durchgeführt wird. Angenommen, Sie müssen sich Element 17 zuwenden. Wir nehmen eine binäre Darstellung des Index und teilen ihn in Gruppen von der Größe eines Verzweigungsfaktors auf.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c1/gz/o1/c1gzo1qqm9pycpehqerzzkvwvwm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In jeder Gruppe verwenden wir den entsprechenden Binärwert und gehen so den Baum hinunter. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir als nächstes an, wir müssen diese Datenstruktur ändern, dh die Methode ausführen </font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/l8/xi/3y/l8xi3yorosfghnwt9gmcijtk83a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dazu müssen Sie zuerst den Block kopieren, in dem sich das Element befindet, und dann jeden internen Knoten auf dem Weg zum Element kopieren. Einerseits müssen ziemlich viele Daten kopiert werden, gleichzeitig ist ein erheblicher Teil dieser Daten üblich, dies kompensiert deren Volumen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Übrigens gibt es eine viel ältere Datenstruktur, die der von mir beschriebenen sehr ähnlich ist. Dies sind Speicherseiten mit einem Seitentabellenbaum. Ihre Geschäftsführung erfolgt ebenfalls per Anruf </font></font><code>fork</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir, unsere Datenstruktur zu verbessern. Angenommen, wir müssen zwei Vektoren verbinden. Die bisher beschriebene Datenstruktur weist dieselben Einschränkungen auf </font></font><code>std::vector:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie leere Zellen ganz rechts. Da die Struktur perfekt ausbalanciert ist, können sich diese leeren Zellen nicht in der Mitte des Baums befinden. Wenn es also einen zweiten Vektor gibt, den wir mit dem ersten kombinieren möchten, müssen wir die Elemente in leere Zellen kopieren, wodurch leere Zellen im zweiten Vektor erstellt werden, und am Ende müssen wir den gesamten zweiten Vektor kopieren. Eine solche Operation hat die Rechenkomplexität O (n), wobei n die Größe des zweiten Vektors ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden versuchen, ein besseres Ergebnis zu erzielen. Es gibt eine modifizierte Version unserer Datenstruktur, die als Relaxed Radix Balanced Tree bezeichnet wird. In dieser Struktur können Knoten, die sich nicht ganz links befinden, leere Zellen haben. Daher ist es in solchen unvollständigen (oder entspannten) Knoten erforderlich, die Größe des Teilbaums zu berechnen. Jetzt können Sie eine komplexe, aber logarithmische Verknüpfungsoperation ausführen. Diese Operation mit konstanter Zeitkomplexität ist O (log (32)). Da die Bäume flach sind, ist die Zugriffszeit konstant, wenn auch relativ lang. Aufgrund der Tatsache, dass wir eine solche Vereinigungsoperation haben, wird eine entspannte Version dieser Datenstruktur als konfluent bezeichnet: Zusätzlich zu ihrer Beständigkeit und Sie können sie teilen, können zwei solcher Strukturen zu einer kombiniert werden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qr/rj/hz/qrrjhzfbr-22n0cdr-vvhke1pvq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dem Beispiel, mit dem wir bisher gearbeitet haben, ist die Datenstruktur sehr ordentlich, aber in der Praxis sehen die Implementierungen in Clojure und anderen funktionalen Sprachen anders aus. Sie erstellen Container für jeden Wert, dh jedes Element im Vektor befindet sich in einer separaten Zelle, und Blattknoten enthalten Zeiger auf diese Elemente. Dieser Ansatz ist jedoch äußerst ineffizient. In C ++ wird normalerweise nicht jeder Wert in einen Container eingefügt. Daher ist es besser, wenn sich diese Elemente direkt in Knoten befinden. Dann tritt ein anderes Problem auf: Unterschiedliche Elemente haben unterschiedliche Größen. Wenn das Element dieselbe Größe wie der Zeiger hat, sieht unsere Struktur wie folgt aus:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/78/s4/_k/78s4_kqqdc_fi8_ydkopktou0m4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Elemente jedoch groß sind, verliert die Datenstruktur die von uns gemessenen Eigenschaften (Zugriffszeit O (log (32) ()), da das Kopieren eines der Blätter jetzt länger dauert. Daher habe ich diese Datenstruktur so geändert, dass sie mit zunehmender Größe zunimmt Die Anzahl der darin enthaltenen Elemente verringerte die Anzahl dieser Elemente in den Blattknoten. Im Gegenteil, wenn die Elemente klein sind, können sie jetzt mehr passen. Die neue Version des Baums wird als Einbetten eines radixausgeglichenen Baums bezeichnet. Sie wird nicht durch eine Konstante beschrieben, sondern durch zwei: eine von ihnen beschreibt interne Knoten und das zweite Blatt. Durch die Implementierung des Baums in C ++ kann die optimale Größe des Blattelements in Abhängigkeit von der Größe der Zeiger und der Elemente selbst berechnet werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Baum funktioniert bereits recht gut, kann aber noch verbessert werden. Schauen Sie sich eine Funktion ähnlich einer Funktion an </font></font><code>iota</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = v.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es nimmt eine Eingabe entgegen </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am Ende des Vektors für jede Ganzzahl zwischen </font></font><code>first</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ausgeführt </font></font><code>last</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und gibt zurück, was passiert ist. Alles ist in Ordnung mit der Richtigkeit dieser Funktion, aber es funktioniert ineffizient. Jeder Aufruf </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kopiert den Block ganz links unnötig: Der nächste Aufruf drückt ein anderes Element und die Kopie wird erneut wiederholt, und die von der vorherigen Methode kopierten Daten werden gelöscht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können eine andere Implementierung dieser Funktion ausprobieren, bei der wir die Persistenz innerhalb der Funktion aufgeben. Kann </font></font><code>transient vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einer veränderlichen API verwendet werden, die mit der regulären API kompatibel ist </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Innerhalb einer solchen Funktion </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ändert </font><font style="vertical-align: inherit;">jeder Aufruf </font><font style="vertical-align: inherit;">die Datenstruktur.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    auto t = v.transient();<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        t.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> t.persistent();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Implementierung ist effizienter und ermöglicht es Ihnen, neue Elemente auf dem richtigen Weg wiederzuverwenden. Am Ende der Funktion wird ein Aufruf </font></font><code>.persistent()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getätigt, der unveränderlich zurückgibt </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mögliche Nebenwirkungen bleiben von außerhalb der Funktion unsichtbar. Das Original </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">war und bleibt unveränderlich, nur die innerhalb der Funktion erstellten Daten werden geändert. Wie bereits erwähnt, besteht ein wichtiger Vorteil dieses Ansatzes darin, dass Sie </font></font><code>std::back_inserter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardalgorithmen verwenden können, für die veränderbare APIs erforderlich sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie ein anderes Beispiel.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        <font></font>
            .push_back(<span class="hljs-string">'i'</span>)        <font></font>
            .push_back(<span class="hljs-string">'!'</span>);       <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion akzeptiert nicht und gibt zurück </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber eine Aufrufkette wird im Inneren ausgeführt </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Hier kann wie im vorherigen Beispiel unnötiges Kopieren innerhalb des Anrufs auftreten </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Beachten Sie, dass der erste Wert, der ausgeführt </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird, der benannte Wert ist und der Rest ein r-Wert ist, dh anonyme Links. Wenn Sie die Referenzzählung verwenden, kann die Methode </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf Referenzzähler für Knoten verweisen, denen im Baum Speicher zugewiesen ist. Und im Fall von r-Wert wird klar, dass kein anderer Teil des Programms auf diese Knoten zugreift, wenn die Anzahl der Verknüpfungen eins ist. Hier ist die Leistung genau die gleiche wie im Fall von </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        ⟵ named <span class="hljs-keyword">value</span>: v<font></font>
            .push_back(<span class="hljs-string">'i'</span>)        ⟵ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span>
            .push_back(<span class="hljs-string">'!'</span>);       ⟵ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dem Compiler zu helfen, können wir ihn außerdem ausführen </font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da er an </font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keiner anderen Stelle in der Funktion verwendet wird. Wir hatten einen wichtigen Vorteil, der nicht in der </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variante enthalten war: Wenn wir den zurückgegebenen Wert eines anderen say_hi an die Funktion say_hi übergeben, gibt es keine zusätzlichen Kopien. Im Fall von c </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt es Grenzen, an denen übermäßiges Kopieren auftreten kann. Mit anderen Worten, wir haben eine dauerhafte, unveränderliche Datenstruktur, deren Leistung von der tatsächlichen Menge des gemeinsam genutzten Zugriffs zur Laufzeit abhängt. Wenn keine Freigabe erfolgt, entspricht die Leistung der einer veränderlichen Datenstruktur. Dies ist eine äußerst wichtige Eigenschaft. Das Beispiel, das ich Ihnen oben bereits gezeigt habe, kann mit einer Methode umgeschrieben werden </font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = std::move(v).push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bisher haben wir über Vektoren gesprochen, und zusätzlich gibt es auch Hash-Maps. Sie widmen sich einem sehr nützlichen Bericht von Phil Nash: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der heilige Gral. Ein Hash-Array hat Trie für C ++ zugeordnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es beschreibt Hash-Tabellen, die nach denselben Prinzipien implementiert wurden, über die ich gerade gesprochen habe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich bin sicher, dass viele von Ihnen Zweifel an der Leistung solcher Strukturen haben. Arbeiten sie in der Praxis schnell? Ich habe viele Tests durchgeführt und kurz gesagt lautet meine Antwort ja. Wenn Sie mehr über die Testergebnisse erfahren möchten, werden diese in meinem Artikel für die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internationale Konferenz für funktionale Programmierung 2017 veröffentlicht</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich denke, es ist besser, nicht die absoluten Werte zu diskutieren, sondern die Auswirkungen dieser Datenstruktur auf das Gesamtsystem. </font><font style="vertical-align: inherit;">Natürlich ist die Aktualisierung unseres Vektors langsamer, da Sie mehrere Datenblöcke kopieren und Speicher für andere Daten zuweisen müssen. </font><font style="vertical-align: inherit;">Das Umgehen unseres Vektors erfolgt jedoch fast mit der gleichen Geschwindigkeit wie bei einem normalen. </font><font style="vertical-align: inherit;">Für mich war es sehr wichtig, dies zu erreichen, da das Lesen von Daten viel häufiger durchgeführt wird als das Ändern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund der langsameren Aktualisierung muss nichts kopiert werden, nur die Datenstruktur wird kopiert. </font><font style="vertical-align: inherit;">Daher wird die für die Aktualisierung des Vektors aufgewendete Zeit sozusagen für alle im System durchgeführten Kopien amortisiert. </font><font style="vertical-align: inherit;">Wenn Sie diese Datenstruktur in einer Architektur anwenden, die der zu Beginn des Berichts beschriebenen ähnlich ist, steigt die Leistung daher erheblich.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ewig</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde nicht unbegründet sein und meine Datenstruktur anhand eines Beispiels demonstrieren. </font><font style="vertical-align: inherit;">Ich habe einen kleinen Texteditor geschrieben. </font><font style="vertical-align: inherit;">Dies ist ein interaktives Tool namens </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , bei dem Dokumente durch unveränderliche Vektoren dargestellt werden. </font><font style="vertical-align: inherit;">Ich habe eine Kopie der gesamten Wikipedia in Esperanto auf meiner Festplatte gespeichert, sie wiegt 1 Gigabyte (zuerst wollte ich die englische Version herunterladen, aber sie ist zu groß). </font><font style="vertical-align: inherit;">Welchen Texteditor Sie auch verwenden, ich bin sicher, dass ihm diese Datei nicht gefallen wird. </font><font style="vertical-align: inherit;">Und wenn Sie diese Datei in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> herunterladen </font><font style="vertical-align: inherit;">, können Sie sie sofort bearbeiten, da der Download asynchron ist. </font><font style="vertical-align: inherit;">Die Dateinavigation funktioniert, nichts hängt, nein </font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, keine Synchronisation. </font><font style="vertical-align: inherit;">Wie Sie sehen können, benötigt die heruntergeladene Datei 20 Millionen Codezeilen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir uns mit den wichtigsten Eigenschaften dieses Tools befassen, sollten wir uns mit einem lustigen Detail befassen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eb/kt/eq/ebkteqmtvnbkncoxlb91z0g6qpy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Anfang der Zeile, die am unteren Rand des Bildes weiß hervorgehoben ist, sehen Sie zwei Bindestriche. Diese Benutzeroberfläche ist Emacs-Benutzern höchstwahrscheinlich vertraut. Bindestriche bedeuten, dass das Dokument in keiner Weise geändert wurde. Wenn Sie Änderungen vornehmen, werden anstelle von Bindestrichen Sternchen angezeigt. Wenn Sie </font><font style="vertical-align: inherit;">diese Änderungen jedoch </font><font style="vertical-align: inherit;">im Gegensatz zu anderen Editoren in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> löschen (nicht rückgängig machen, sondern nur löschen), werden anstelle von Sternchen wieder Bindestriche angezeigt, da </font><font style="vertical-align: inherit;">alle vorherigen Versionen des Textes </font><font style="vertical-align: inherit;">in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gespeichert sind. Dank dessen wird kein spezielles Flag benötigt, um anzuzeigen, ob das Dokument geändert wurde: Das Vorhandensein von Änderungen wird durch Vergleich mit dem Originaldokument festgestellt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie eine weitere interessante Eigenschaft des Tools: Kopieren Sie den gesamten Text und fügen Sie ihn einige Male in die Mitte des vorhandenen Textes ein. </font><font style="vertical-align: inherit;">Wie Sie sehen können, geschieht dies sofort. </font><font style="vertical-align: inherit;">Das Verbinden von Vektoren ist hier eine logarithmische Operation, und der Logarithmus von mehreren Millionen ist keine so lange Operation. </font><font style="vertical-align: inherit;">Wenn Sie versuchen, dieses große Dokument auf Ihrer Festplatte zu speichern, dauert es viel länger, da der Text nicht mehr als Vektor dargestellt wird, der aus der vorherigen Version dieses Vektors stammt. </font><font style="vertical-align: inherit;">Beim Speichern auf der Festplatte erfolgt eine Serialisierung, sodass die Persistenz verloren geht.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zurück zur wertbasierten Architektur</font></font></h2><br>
<img src="https://habrastorage.org/webt/wf/o7/b7/wfo7b78ha0wnqjzcjjeky_esh0g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir damit, wie Sie nicht zu dieser Architektur zurückkehren können: Verwenden Sie den üblichen Controller, das Modell und die Ansicht im Java-Stil, die am häufigsten für interaktive Anwendungen in C ++ verwendet werden. Es ist nichts falsch mit ihnen, aber sie sind nicht für unser Problem geeignet. Einerseits ermöglicht das Model-View-Controller-Muster die Trennung von Aufgaben, andererseits ist jedes dieser Elemente ein Objekt, sowohl aus objektorientierter Sicht als auch aus Sicht von C ++, dh es handelt sich um veränderbare Speicherbereiche Bedingung. View kennt sich mit Model aus; Das ist viel schlimmer - Model kennt View indirekt, da es mit ziemlicher Sicherheit einen Rückruf gibt, über den die View benachrichtigt wird, wenn sich das Modell ändert. Selbst mit der besten Implementierung objektorientierter Prinzipien erhalten wir viele gegenseitige Abhängigkeiten.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/07/so/xq/07soxqkandixucwhzk6mvfr1e84.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Anwendung wächst und neues Modell, Controller und Ansicht hinzugefügt werden, tritt eine Situation auf, in der Sie zum Ändern eines Programmsegments alle damit verbundenen Teile, alle Ansichten kennen müssen, über die Warnungen empfangen </font></font><code>callback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden usw. Infolgedessen alle Das bekannte Pasta-Monster beginnt, diese Abhängigkeiten zu durchschauen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ist eine andere Architektur möglich? Es gibt einen alternativen Ansatz für das Model-View-Controller-Muster namens "Unidirectional Data Flow Architecture". Dieses Konzept wurde nicht von mir erfunden, es wird ziemlich oft in der Webentwicklung verwendet. Auf Facebook wird dies als Flux-Architektur bezeichnet, in C ++ jedoch noch nicht.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/z6/p2/tyz6p2hutpnjwusi0edhbcwvo0s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elemente einer solchen Architektur sind uns bereits bekannt: Aktion, Modell und Ansicht, aber die Bedeutung von Blöcken und Pfeilen ist unterschiedlich. Blöcke sind Werte, keine Objekte und keine Regionen mit veränderlichen Zuständen. Dies gilt auch für View. Außerdem sind Pfeile keine Links, da es ohne Objekte keine Links geben kann. Hier sind die Pfeile Funktionen. Zwischen Aktion und Modell gibt es eine Aktualisierungsfunktion, die das aktuelle Modell, dh den aktuellen Status der Welt, akzeptiert, und Aktion, die ein Ereignis darstellt, z. B. einen Mausklick oder ein Ereignis einer anderen Abstraktionsebene, z. B. das Einfügen eines Elements oder Symbols in ein Dokument. Die Aktualisierungsfunktion aktualisiert das Dokument und gibt den neuen Status der Welt zurück. Das Modell stellt eine Verbindung zum Rendern der Ansichtsfunktion her, die das Modell übernimmt und die Ansicht zurückgibt. Dies erfordert ein Framework, in dem View als Werte dargestellt werden kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Webentwicklung macht React dies, aber in C ++ gibt es noch nichts Vergleichbares, obwohl wer weiß, wenn es Leute gibt, die mich dafür bezahlen wollen, dass ich so etwas schreibe, kann es bald erscheinen. In der Zwischenzeit können Sie die API für den Sofortmodus verwenden, mit der Sie mit der Zeichenfunktion einen Wert als Nebeneffekt erstellen können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich sollte die Ansicht über einen Mechanismus verfügen, mit dem der Benutzer oder andere Ereignisquellen eine Aktion senden können. Es gibt eine einfache Möglichkeit, dies zu implementieren. Es wird unten dargestellt:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">application <span class="hljs-title">update</span>(<span class="hljs-params">application state, action ev</span>)</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fname</span>)</span><font></font>
{<font></font>
    auto term  = terminal{};<font></font>
    auto state = application{load_buffer(fname), key_map_emacs};<font></font>
    <span class="hljs-keyword">while</span> (!state.done) {<font></font>
        draw(state);<font></font>
        auto act = term.next();<font></font>
        state = update(state, act);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Ausnahme des asynchronen Speicherns und Ladens ist dies der Code, der in dem gerade dargestellten Editor verwendet wird. Hier gibt es ein Objekt </font></font><code>terminal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit dem Sie über die Befehlszeile lesen und schreiben können. Ferner </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist dies der Wert von Model, speichert er den gesamten Zustand der Anwendung. Wie Sie oben auf dem Bildschirm sehen können, gibt es eine Funktion, die eine neue Version zurückgibt </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Der Zyklus innerhalb der Funktion wird ausgeführt, bis die Anwendung geschlossen werden muss, dh bis </font></font><code>!state.done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In der Schleife wird ein neuer Zustand gezeichnet, dann wird das nächste Ereignis angefordert. Schließlich wird der Status in einer lokalen Variablen gespeichert </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die Schleife beginnt erneut. Dieser Code hat einen sehr wichtigen Vorteil: Während der Ausführung des Programms existiert nur eine veränderbare Variable, es handelt sich um ein Objekt </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Clojure-Entwickler nennen diese Single-Atom-Architektur: Es gibt einen einzigen Punkt in der gesamten Anwendung, über den alle Änderungen vorgenommen werden. </font><font style="vertical-align: inherit;">Die Anwendungslogik beteiligt sich in keiner Weise an der Aktualisierung dieses Punktes, dies macht einen speziell dafür entworfenen Zyklus. </font><font style="vertical-align: inherit;">Dank dessen besteht die Anwendungslogik vollständig aus reinen Funktionen, wie Funktionen </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit diesem Ansatz zum Schreiben von Anwendungen ändert sich die Denkweise über Software. </font><font style="vertical-align: inherit;">Die Arbeit beginnt nun nicht mit dem UML-Diagramm der Schnittstellen und Operationen, sondern mit den Daten selbst. </font><font style="vertical-align: inherit;">Es gibt einige Ähnlichkeiten mit datenorientiertem Design. </font><font style="vertical-align: inherit;">Richtiges, datenorientiertes Design wird normalerweise verwendet, um maximale Leistung zu erzielen. Hier streben wir neben der Geschwindigkeit nach Einfachheit und Korrektheit. </font><font style="vertical-align: inherit;">Die Betonung ist etwas anders, aber es gibt wichtige Ähnlichkeiten in der Methodik.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> index = <span class="hljs-keyword">int</span>;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> coord<font></font>
{<font></font>
    index row = {};<font></font>
    index col = {};<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">using</span> line = immer::flex_vector&lt;<span class="hljs-keyword">char</span>&gt;;
<span class="hljs-keyword">using</span> text = immer::flex_vector&lt;line&gt;;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> file<font></font>
{<font></font>
    immer::box&lt;std::<span class="hljs-keyword">string</span>&gt; name;<font></font>
    text content;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> snapshot<font></font>
{<font></font>
    text content;<font></font>
    coord cursor;<font></font>
};<font></font>
 <font></font>
<span class="hljs-keyword">struct</span> buffer<font></font>
{<font></font>
    file <span class="hljs-keyword">from</span>;<font></font>
    text content;<font></font>
    coord cursor;<font></font>
    coord scroll;<font></font>
    std::optional&lt;coord&gt; selection_start;<font></font>
    immer::vector&lt;snapshot&gt; history;<font></font>
    std::optional&lt;std::size_t&gt; history_pos;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> application<font></font>
{<font></font>
    buffer current;<font></font>
    key_map keys;<font></font>
    key_seq input;<font></font>
    immer::vector&lt;text&gt; clipboard;<font></font>
    immer::vector&lt;message&gt; messages;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> action { key_code key; coord size; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oben sind die wichtigsten Datentypen unserer Anwendung aufgeführt. Der Hauptteil der Anwendung besteht aus </font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flex_vector, und flex_vector ist </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer, für den Sie eine Verknüpfungsoperation ausführen können. Als nächstes </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">folgt der Vektor, in dem er gespeichert ist </font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wie Sie sehen können, ist dies eine sehr einfache Darstellung des Textes. </font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gespeichert, mit deren Hilfe </font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Name, dh eine Adresse im Dateisystem, und tatsächlich </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wie </font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein anderer Typ verwendet, ein einfacher, aber sehr nützlicher : </font></font><code>box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies ist ein Einzelelementcontainer. Sie können einen Heap einfügen und ein Objekt verschieben, wobei das Kopieren möglicherweise zu ressourcenintensiv ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer wichtiger Typ : </font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Basierend auf diesem Typ ist eine Abbruchfunktion aktiv. Es enthält ein Dokument (im Formular</font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) und Cursorposition (Koordinate). Auf diese Weise können Sie den Cursor an die Position zurücksetzen, an der er sich während der Bearbeitung befand. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der nächste Typ ist </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies ist ein Begriff von vim und emacs, wie dort offene Dokumente genannt werden. Darin </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">befindet sich eine Datei, aus der der Text heruntergeladen wurde, sowie der Inhalt des Textes. Auf diese Weise können Sie nach Änderungen im Dokument suchen. Um einen Teil des Textes hervorzuheben, gibt es eine optionale Variable </font></font><code>selection_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die den Beginn der Auswahl angibt. Der Vektor von </font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist die Geschichte des Textes. Beachten Sie, dass wir das Teammuster nicht verwenden. Der Verlauf besteht nur aus Status. Wenn die Stornierung gerade abgeschlossen wurde, benötigen wir einen Positionsindex in der Statushistorie </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der nächste Typ : </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es enthält ein offenes Dokument (Puffer) </font></font><code>key_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und</font></font><code>key_seq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für Tastaturkürzel sowie einen Vektor aus </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für die Zwischenablage und einen weiteren Vektor für Nachrichten, die am unteren Bildschirmrand angezeigt werden. </font><font style="vertical-align: inherit;">Bisher wird es in der Debütversion der Anwendung nur einen Thread und eine Art von Aktion geben, die Eingaben </font></font><code>key_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>coord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Höchstwahrscheinlich denken viele von Ihnen bereits darüber nach, wie diese Vorgänge implementiert werden sollen. </font><font style="vertical-align: inherit;">Wenn nach Wert genommen und nach Wert zurückgegeben, sind die Operationen in den meisten Fällen recht einfach. </font><font style="vertical-align: inherit;">Der Code meines Texteditors ist auf </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github veröffentlicht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sodass Sie sehen können, wie er tatsächlich aussieht. </font><font style="vertical-align: inherit;">Jetzt werde ich nur auf den Code eingehen, der die Stornierungsfunktion implementiert.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stornieren</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das korrekte Schreiben einer Stornierung ohne die entsprechende Infrastruktur ist nicht so einfach. In meinem Editor habe ich es nach dem Vorbild von Emacs implementiert, also zunächst ein paar Worte zu seinen Grundprinzipien. Der Befehl return fehlt hier und dank dessen können Sie keine Arbeit verlieren. Wenn eine Rücksendung erforderlich ist, werden Änderungen am Text vorgenommen, und alle Stornierungsaktionen werden wieder Teil des Stornierungsverlaufs.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s0/4z/j_/s04zj_sia6mzw8reywkbznlhlem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Prinzip ist oben dargestellt. Die rote Raute zeigt hier eine Position in der Geschichte: Wenn eine Stornierung gerade nicht abgeschlossen wurde, ist die rote Raute immer ganz am Ende. Wenn Sie abbrechen, verschiebt der Diamant einen Status zurück, aber gleichzeitig wird am Ende der Warteschlange ein weiterer Status hinzugefügt - derselbe, den der Benutzer derzeit sieht (S3). Wenn Sie erneut abbrechen und zum Status S2 zurückkehren, wird der Status S2 am Ende der Warteschlange hinzugefügt. Wenn der Benutzer jetzt eine Änderung vornimmt, wird diese als neuer Status von S5 am Ende der Warteschlange hinzugefügt und eine Raute wird dorthin verschoben. Wenn Sie nun vergangene Aktionen rückgängig machen, werden die vorherigen rückgängig gemachten Aktionen zuerst gescrollt. Um ein solches Stornierungssystem zu implementieren, reicht der folgende Code aus:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">buffer <span class="hljs-title">record</span>(<span class="hljs-params">buffer before, buffer after</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">if</span> (before.content != after.content) {<font></font>
        after.history = after.history.push_back({before.content, before.cursor});<font></font>
        <span class="hljs-keyword">if</span> (before.history_pos == after.history_pos)<font></font>
            after.history_pos = std::nullopt;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> after;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">buffer <span class="hljs-title">undo</span>(<span class="hljs-params">buffer buf</span>)</span><font></font>
{<font></font>
    auto idx = buf.history_pos.value_or(buf.history.size());<font></font>
    <span class="hljs-keyword">if</span> (idx &gt; <span class="hljs-number">0</span>) {<font></font>
        auto restore = buf.history[--idx];<font></font>
        buf.content = restore.content;<font></font>
        buf.cursor = restore.cursor;<font></font>
        buf.history_pos = idx;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> buf;<font></font>
  }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt zwei Aktionen </font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">während einer Operation durchgeführt. Dies ist sehr praktisch, da wir nicht wissen müssen, ob das Dokument bearbeitet wurde. Die Funktion ist für die Anwendungslogik transparent. Nach jeder Aktion prüft die Funktion, ob sich das Dokument geändert hat. Wenn eine Änderung aufgetreten ist, werden der </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhalt und die Cursorposition für </font><font style="vertical-align: inherit;">ausgeführt </font></font><code>history</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn die Aktion nicht zu einer Änderung geführt hat </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dh die empfangene Eingabe wird </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht durch die Abbruchaktion verursacht), wird </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Wert zugewiesen </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Bei Bedarf </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prüfen wir </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn es keine Bedeutung hat, betrachten wir es </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als am Ende der Geschichte. Wenn der Stornierungsverlauf nicht leer ist (d. H.</font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht ganz am Anfang der Geschichte), wird eine Stornierung durchgeführt. </font><font style="vertical-align: inherit;">Der aktuelle Inhalt und der Cursor werden ersetzt und geändert </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Unwiderruflichkeit des Abbruchvorgangs wird durch die Funktion erreicht </font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die auch während des Abbruchvorgangs aufgerufen wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben also eine Operation </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die 10 Codezeilen einnimmt und die ohne Änderungen (oder mit minimalen Änderungen) in fast jeder anderen Anwendung verwendet werden kann.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitreise</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Über Zeitreisen. Wie wir jetzt sehen werden, ist dies ein Thema im Zusammenhang mit der Stornierung. Ich werde die Arbeit eines Frameworks demonstrieren, das jeder Anwendung mit einer ähnlichen Architektur nützliche Funktionen hinzufügt. Das Framework heißt hier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig-debug</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Diese Version von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enthält einige Debugging-Funktionen. Jetzt können Sie über den Browser den Debugger öffnen, in dem Sie den Status der Anwendung überprüfen können.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dy/ba/7x/dyba7xjocwgjjmqvayinlfwx0y4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sehen, dass die letzte Aktion die Größe geändert hat, weil ich ein neues Fenster geöffnet habe und mein Fenstermanager die Größe des bereits geöffneten Fensters automatisch geändert hat. Für die automatische Serialisierung in JSON musste ich natürlich Anmerkungen für struct aus der speziellen Reflection-Bibliothek hinzufügen. Der Rest des Systems ist jedoch ziemlich universell und kann mit jeder ähnlichen Anwendung verbunden werden. Jetzt können Sie im Browser alle abgeschlossenen Aktionen sehen. Natürlich gibt es einen Anfangszustand, der keine Aktion hat. Dies ist der Status vor dem Download. Darüber hinaus kann ich durch Doppelklicken die Anwendung in den vorherigen Zustand zurückversetzen. Dies ist ein sehr nützliches Debugging-Tool, mit dem Sie das Auftreten einer Fehlfunktion in der Anwendung verfolgen können.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie interessiert sind, können Sie meinen Bericht über CPPCON 19, Die wertvollsten Werte, anhören. Dort werde ich diesen Debugger im Detail untersuchen. </font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/_oBx_NbLghY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus wird dort die wertebasierte Architektur näher erläutert. </font><font style="vertical-align: inherit;">Darin erkläre ich Ihnen auch, wie Sie Aktionen implementieren und hierarchisch organisieren. </font><font style="vertical-align: inherit;">Dies stellt die Modularität des Systems sicher und ermöglicht es Ihnen, nicht alles in einer großen Aktualisierungsfunktion zu behalten. </font><font style="vertical-align: inherit;">Darüber hinaus wird in diesem Bericht auf Asynchronität und das Herunterladen von Dateien mit mehreren Threads eingegangen. </font><font style="vertical-align: inherit;">Es gibt eine andere Version dieses Berichts, in der eine halbe Stunde zusätzliches Material postmoderne unveränderliche Datenstrukturen enthält.</font></font><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/y_m0ce1rzRI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke, es ist Zeit, Bilanz zu ziehen. Ich werde Andy Wingo zitieren - er ist ein ausgezeichneter Entwickler, er hat viel Zeit für V8 und Compiler im Allgemeinen aufgewendet, schließlich ist er damit beschäftigt, Guile zu unterstützen und das Schema für GNU zu implementieren. Kürzlich schrieb er auf seinem Twitter: „Um eine leichte Beschleunigung des Programms zu erreichen, messen wir jede kleine Änderung und lassen nur diejenigen übrig, die ein positives Ergebnis liefern. Aber wir erreichen wirklich eine signifikante Beschleunigung, blind, investieren viel Mühe, haben kein 100% iges Vertrauen und werden nur von der Intuition geleitet. Was für eine seltsame Zweiteilung. "</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint mir, dass C ++ - Entwickler im ersten Genre erfolgreich sind. </font><font style="vertical-align: inherit;">Geben Sie uns ein geschlossenes System, und wir werden mit unseren Werkzeugen alles ausdrücken, was daraus möglich ist. </font><font style="vertical-align: inherit;">Aber im zweiten Genre sind wir es nicht gewohnt zu arbeiten. </font><font style="vertical-align: inherit;">Natürlich ist der zweite Ansatz riskanter und führt oft zu einer Verschwendung großer Anstrengungen. </font><font style="vertical-align: inherit;">Andererseits kann ein Programm durch einfaches Umschreiben oft einfacher und schneller gemacht werden. </font><font style="vertical-align: inherit;">Ich hoffe, ich habe es geschafft, Sie davon zu überzeugen, zumindest diesen zweiten Ansatz zu versuchen.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juan Puente sprach auf der C ++ Russia 2019 in Moskau und sprach über Datenstrukturen, mit denen Sie interessante Dinge tun können. </font><font style="vertical-align: inherit;">Ein Teil der Magie dieser Strukturen liegt in der </font><font style="vertical-align: inherit;">Auswahl von </font><font style="vertical-align: inherit;">Kopien - darüber werden </font><font style="vertical-align: inherit;">Anton Polukhin und Roman Rusyaev </font><font style="vertical-align: inherit;">auf der kommenden Konferenz </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sprechen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Folgen Sie den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmaktualisierungen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf der Website.</font></font></blockquote></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de487100/">https://habr.com/ru/post/de487100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de487090/index.html">Eine neue Stufe der Windows-Optimierung</a></li>
<li><a href="../de487092/index.html">Modellierung von Geschäftsprozessen als Teil eines Projekts zur Implementierung eines ERP-Systems</a></li>
<li><a href="../de487094/index.html">Wiederaufbereitungsereignisse von Kafka erhalten</a></li>
<li><a href="../de487096/index.html">Schnipsel. So vereinfachen Sie die Arbeit mit der Dokumentation</a></li>
<li><a href="../de487098/index.html">Zeichnen mit Ameisen: prozedurale Bilder unter Verwendung von Algorithmen zur Optimierung von Ameisenkolonien</a></li>
<li><a href="../de487106/index.html">RunUO-Prüfung des PVS-Studio-Analysators</a></li>
<li><a href="../de487108/index.html">Mobiles Spielerprofil: MyTracker Research</a></li>
<li><a href="../de487110/index.html">Slurm SRE. Ein komplettes Experiment mit Experten von Booking.com und Google.com</a></li>
<li><a href="../de487112/index.html">Rand des Wahnsinns: Der Grundkreis</a></li>
<li><a href="../de487116/index.html">Warum Discord von Go nach Rust migriert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>