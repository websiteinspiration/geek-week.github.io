<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåô üç´ üñºÔ∏è Unver√§nderliche Datenstrukturen auf dem neuesten Stand der Technik ü§ú üë®üèº‚Äç‚öñÔ∏è ü§úüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seit Jahren diskutieren Experten in C ++ die Semantik von Werten, Unver√§nderlichkeit und gemeinsamer Nutzung von Ressourcen durch Kommunikation. √úber ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Unver√§nderliche Datenstrukturen auf dem neuesten Stand der Technik</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/487100/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seit Jahren diskutieren Experten in C ++ die Semantik von Werten, Unver√§nderlichkeit und gemeinsamer Nutzung von Ressourcen durch Kommunikation. </font><font style="vertical-align: inherit;">√úber eine neue Welt ohne Mutexe und Rassen, ohne Befehls- und Beobachtermuster. </font><font style="vertical-align: inherit;">In der Tat ist nicht alles so einfach. </font><font style="vertical-align: inherit;">Das Hauptproblem liegt immer noch in unseren Datenstrukturen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6o/pu/18/6opu18ei6gi5dbo8dvcsgopyebq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unver√§nderliche Datenstrukturen √§ndern ihre Werte nicht. Um etwas mit ihnen zu tun, m√ºssen Sie neue Werte erstellen. Die alten Werte bleiben an derselben Stelle, sodass sie ohne Probleme und Sperren aus verschiedenen Streams gelesen werden k√∂nnen. Infolgedessen k√∂nnen Ressourcen rationaler und geordneter geteilt werden, da alte und neue Werte gemeinsame Daten verwenden k√∂nnen. Dank dessen sind sie viel schneller miteinander zu vergleichen und speichern die Betriebsgeschichte kompakt mit der M√∂glichkeit der Stornierung. All dies passt perfekt zu Multithread- und interaktiven Systemen: Solche Datenstrukturen vereinfachen die Architektur von Desktop-Anwendungen und erm√∂glichen eine bessere Skalierung von Diensten. Unver√§nderliche Strukturen sind das Erfolgsgeheimnis von Clojure und Scala, und sogar die JavaScript-Community nutzt sie jetzt, da sie √ºber die Bibliothek Immutable.js verf√ºgen.geschrieben in den Eingeweiden der Firma Facebook.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter dem Schnitt - Video und √úbersetzung des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juan Puente-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berichts </font><font style="vertical-align: inherit;">von der C ++ Russia 2019 Moskauer Konferenz. </font><font style="vertical-align: inherit;">Juan spricht √ºber </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , eine Bibliothek unver√§nderlicher Strukturen f√ºr C ++. </font><font style="vertical-align: inherit;">In der Post:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">architektonische Vorteile der Immunit√§t;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellung eines effektiven persistenten Vektortyps basierend auf RRB-B√§umen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse der Architektur am Beispiel eines einfachen Texteditors.</font></font></li>
</ul><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/dbFfpTp3EhA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Trag√∂die der wertebasierten Architektur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Bedeutung unver√§nderlicher Datenstrukturen zu verstehen, diskutieren wir die Semantik von Werten. Dies ist eine sehr wichtige Funktion von C ++. Ich halte sie f√ºr einen der Hauptvorteile dieser Sprache. Bei alledem ist es sehr schwierig, die Semantik von Werten so zu verwenden, wie wir es m√∂chten. Ich glaube, dass dies die Trag√∂die der wertorientierten Architektur ist und der Weg zu dieser Trag√∂die mit guten Absichten gepflastert ist. Angenommen, wir m√ºssen interaktive Software schreiben, die auf einem Datenmodell mit einer Darstellung eines vom Benutzer bearbeitbaren Dokuments basiert. Wenn Architektur basierend auf den Werten im Zentrum dieses Modells einfach und bequem Arten von Werten verwendet , </font><font style="vertical-align: inherit;">dass es bereits in der Sprache: </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>tuple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font><code>struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Anwendungslogik wird aus Funktionen erstellt, die Dokumente nach Wert erfassen und eine neue Version eines Dokuments nach Wert zur√ºckgeben. Dieses Dokument kann sich innerhalb der Funktion √§ndern (wie unten beschrieben), aber die Semantik der Werte in C ++, die auf das Argument nach Wert und den R√ºckgabetyp nach Wert angewendet wird, stellt sicher, dass keine Nebenwirkungen auftreten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/7e/0y/fh7e0ybdwuqnh3iona30quev4ja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktion ist sehr einfach zu analysieren und zu testen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cb/5c/4x/cb5c4xq-hps1x76mn-fmweshklu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da wir mit Werten arbeiten, werden wir versuchen, das R√ºckg√§ngigmachen der Aktion zu implementieren. Dies kann schwierig sein, aber mit unserem Ansatz ist es eine triviale Aufgabe: Wir haben </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit verschiedenen Zust√§nden verschiedene Kopien des Dokuments.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d-/vh/nd/d-vhndh9j8leugdcjoyf3b4yhqq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben auch eine Benutzeroberfl√§che, und um deren Reaktionsf√§higkeit sicherzustellen, muss die Zuordnung der Benutzeroberfl√§che in einem separaten Thread erfolgen. Das Dokument wird per Nachricht an einen anderen Stream gesendet, und die Interaktion erfolgt auch auf der Grundlage von Nachrichten und nicht √ºber die gemeinsame Nutzung des Status mithilfe von </font></font><code>mutexes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn die Kopie vom zweiten Stream empfangen wird, k√∂nnen Sie dort alle erforderlichen Vorg√§nge ausf√ºhren. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/to/xx/kc/toxxkcwck44iayev1hywf-wqllk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Speichern eines Dokuments auf der Festplatte ist h√§ufig sehr langsam, insbesondere wenn das Dokument gro√ü ist. Daher wird die Verwendung </font></font><code>std::async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieser Operation asynchron ausgef√ºhrt. Wir verwenden ein Lambda, setzen ein Gleichheitszeichen ein, um eine Kopie zu erhalten, und jetzt k√∂nnen Sie ohne andere primitive Arten der Synchronisation speichern.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ve/ey/jj/veeyjjijubbrc49-ghusxnuft4e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir weiter an, wir haben auch einen Schallkontrollfluss. Wie gesagt, ich habe viel mit Musiksoftware gearbeitet, und Sound ist eine weitere Darstellung unseres Dokuments. Es muss sich in einem separaten Stream befinden. Daher ist f√ºr diesen Stream auch eine Kopie des Dokuments erforderlich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Ergebnis haben wir ein sehr sch√∂nes, aber nicht zu realistisches Schema erhalten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dj/w2/hu/djw2hu7q55lbi2nmgmwok1i_cb0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es m√ºssen st√§ndig Dokumente kopiert werden, der Aktionsverlauf f√ºr das Abbrechen dauert Gigabyte, und f√ºr jedes Rendern der Benutzeroberfl√§che m√ºssen Sie eine tiefe Kopie des Dokuments erstellen. Im Allgemeinen sind alle Interaktionen zu kostspielig.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uq/sv/8-/uqsv8-sx3hphtcm9wvozi1z83fs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was macht der C ++ - Entwickler in dieser Situation? Anstatt ein Dokument nach Wert zu akzeptieren, akzeptiert die Anwendungslogik jetzt einen Link zum Dokument und aktualisiert es bei Bedarf. In diesem Fall m√ºssen Sie nichts zur√ºckgeben. Aber jetzt geht es nicht um Werte, sondern um Objekte und Orte. Dies f√ºhrt zu neuen Problemen: Wenn eine Verbindung zum Status mit gemeinsamem Zugriff besteht, ben√∂tigen Sie diese </font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies ist √§u√üerst kostspielig, daher wird unsere Benutzeroberfl√§che in Form eines √§u√üerst komplexen Baums aus verschiedenen Widgets dargestellt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle diese Elemente sollten aktualisiert werden, wenn sich ein Dokument √§ndert. Daher ist ein Warteschlangenmechanismus f√ºr √Ñnderungssignale erforderlich. Dar√ºber hinaus besteht die Historie des Dokuments nicht mehr aus einer Reihe von Zust√§nden, sondern aus einer Implementierung des Teammusters. Die Operation muss zweimal in die eine und in die andere Richtung ausgef√ºhrt werden und sicherstellen, dass alles symmetrisch ist. Das Speichern in einem separaten Thread ist bereits zu schwierig, daher muss dies abgebrochen werden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dl/lr/sj/dllrsjhkvqxxckjx1r69lflqck4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Benutzer sind bereits an das Sanduhrbild gew√∂hnt, daher ist es in Ordnung, wenn sie etwas warten. Eine andere Sache ist be√§ngstigend - das Pasta-Monster regiert jetzt unseren Code.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ab wann ging es bergab? </font><font style="vertical-align: inherit;">Wir haben unseren Code sehr gut gestaltet und mussten dann aufgrund des Kopierens Kompromisse eingehen. </font><font style="vertical-align: inherit;">In C ++ muss das Kopieren jedoch nur f√ºr ver√§nderbare Daten als Wert √ºbergeben werden. </font><font style="vertical-align: inherit;">Wenn das Objekt unver√§nderlich ist, kann der Zuweisungsoperator so implementiert werden, dass nur der Zeiger auf die interne Darstellung und nichts weiter kopiert wird.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich eine Datenstruktur vor, die uns helfen k√∂nnte. </font><font style="vertical-align: inherit;">Im folgenden Vektor sind alle Methoden als markiert </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sodass sie unver√§nderlich sind. </font><font style="vertical-align: inherit;">Bei der Ausf√ºhrung </font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird der Vektor nicht aktualisiert, sondern es wird ein neuer Vektor zur√ºckgegeben, zu dem die √ºbertragenen Daten hinzugef√ºgt werden. </font><font style="vertical-align: inherit;">Leider k√∂nnen wir bei diesem Ansatz keine eckigen Klammern verwenden, da diese definiert sind. </font><font style="vertical-align: inherit;">Stattdessen k√∂nnen Sie die Funktion verwenden</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies gibt eine neue Version mit einem aktualisierten Element zur√ºck. Unsere Datenstruktur hat jetzt eine Eigenschaft, die in der funktionalen Programmierung als Persistenz bezeichnet wird. Dies bedeutet nicht, dass wir diese Datenstruktur auf der Festplatte speichern, sondern dass beim Aktualisieren der alte Inhalt nicht gel√∂scht wird. Stattdessen wird ein neuer Zweig unserer Welt erstellt, dh die Struktur. Dank dessen k√∂nnen wir vergangene Werte mit gegenw√§rtigen vergleichen - dies geschieht mit Hilfe von zwei </font></font><code>assert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">const</span> auto v0 = vector&lt;<span class="hljs-keyword">int</span>&gt;{};
<span class="hljs-keyword">const</span> auto v1 = v0.push_back(<span class="hljs-number">15</span>);
<span class="hljs-keyword">const</span> auto v2 = v1.push_back(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> auto v3 = v2.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">42</span>);<font></font>
<font></font>
assert(v2.size() == v0.size() + <span class="hljs-number">2</span>);<font></font>
assert(v3[<span class="hljs-number">0</span>] - v1[<span class="hljs-number">0</span>] == <span class="hljs-number">27</span>);</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ñnderungen k√∂nnen jetzt direkt √ºberpr√ºft werden, sie sind keine versteckten Eigenschaften der Datenstruktur mehr. Diese Funktion ist besonders in interaktiven Systemen n√ºtzlich, in denen wir st√§ndig Daten √§ndern m√ºssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine weitere wichtige Eigenschaft ist das strukturelle Teilen. Jetzt kopieren wir nicht alle Daten f√ºr jede neue Version der Datenstruktur. Auch mit </font></font><code>.push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und</font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht alle Daten werden kopiert, sondern nur ein kleiner Teil davon. Alle unsere Gabeln haben gemeinsamen Zugriff auf eine kompakte Ansicht, die proportional zur Anzahl der √Ñnderungen und nicht zur Anzahl der Kopien ist. Daraus folgt auch, dass der Vergleich sehr schnell ist: Wenn alles in einem Speicherblock, in einem Zeiger gespeichert ist, k√∂nnen Sie einfach die Zeiger vergleichen und nicht die darin enthaltenen Elemente untersuchen, wenn sie gleich sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da ein solcher Vektor meiner Meinung nach √§u√üerst n√ºtzlich ist, habe ich ihn in einer separaten Bibliothek implementiert: Dies ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - eine Bibliothek unver√§nderlicher Strukturen, ein Open-Source-Projekt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Schreiben wollte ich, dass die Verwendung den C ++ - Entwicklern vertraut ist. </font><font style="vertical-align: inherit;">Es gibt viele Bibliotheken, die die Konzepte der funktionalen Programmierung in C ++ implementieren, aber es entsteht der Eindruck, dass die Entwickler f√ºr Haskell und nicht f√ºr C ++ schreiben. </font><font style="vertical-align: inherit;">Dies schafft Unannehmlichkeiten. </font><font style="vertical-align: inherit;">Au√üerdem habe ich gute Leistungen erzielt. </font><font style="vertical-align: inherit;">Benutzer verwenden C ++, wenn die verf√ºgbaren Ressourcen begrenzt sind. </font><font style="vertical-align: inherit;">Schlie√ülich wollte ich, dass die Bibliothek anpassbar ist. </font><font style="vertical-align: inherit;">Diese Anforderung h√§ngt mit der Leistungsanforderung zusammen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf der Suche nach einem magischen Vektor</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im zweiten Teil des Berichts werden wir untersuchen, wie dieser unver√§nderliche Vektor strukturiert ist. Der einfachste Weg, die Prinzipien einer solchen Datenstruktur zu verstehen, besteht darin, mit einer regul√§ren Liste zu beginnen. Wenn Sie mit der funktionalen Programmierung ein wenig vertraut sind (am Beispiel von Lisp oder Haskell), wissen Sie, dass Listen die h√§ufigsten unver√§nderlichen Datenstrukturen sind. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rn/ou/d6/rnoud6a8vaqpet2jg-n18be85fk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir zun√§chst an, wir haben eine Liste mit einem einzelnen Knoten </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn Sie neue Elemente zum Anfang der Liste hinzuf√ºgen, werden neue Knoten erstellt, von denen jeder einen Zeiger auf einen vorhandenen Knoten hat. Daher haben wir im Beispiel auf der Folie nicht drei Kopien einer Liste, sondern drei Elemente im Speicher, dh </font></font><code>v1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie </font></font><code>v0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zeigen unterschiedliche Elemente an. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bm/nf/bh/bmnfbhtdmbu_kdm_xlpuxleld2w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen auch eine Gabelung der Realit√§t erstellen, dh eine neue Liste erstellen, die das gleiche Ende, aber einen anderen Anfang hat.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solche Datenstrukturen wurden lange untersucht: Chris Okasaki schrieb die grundlegende Arbeit von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Purely Functional Data Structures</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dar√ºber hinaus ist die von Ralf Hinze und Ross Paterson vorgeschlagene </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finger Tree-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datenstruktur sehr interessant </font><font style="vertical-align: inherit;">. F√ºr C ++ funktionieren solche Datenstrukturen jedoch nicht gut. Sie verwenden kleine Knoten, und wir wissen, dass kleine Knoten in C ++ einen Mangel an Caching-Effizienz bedeuten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus st√ºtzen sie sich h√§ufig auf Eigenschaften, die C ++ nicht besitzt, wie z. B. Faulheit. Daher ist die Arbeit von Phil Bagwell an unver√§nderlichen Datenstrukturen f√ºr uns viel n√ºtzlicher - ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der Anfang der 2000er Jahre geschrieben wurde, sowie die Arbeit von Rich Hickey - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Autor von Clojure. Rich Hickey hat eine Liste erstellt, die eigentlich keine Liste ist, sondern auf modernen Datenstrukturen basiert: Vektoren und Hash-Maps. Diese Datenstrukturen weisen eine Caching-Effizienz auf und interagieren gut mit modernen Prozessoren, f√ºr die es unerw√ºnscht ist, mit kleinen Knoten zu arbeiten. Solche Strukturen k√∂nnen in C ++ verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie baue ich einen Immunvektor auf? Im Herzen jeder Struktur, die auch nur aus der Ferne einem Vektor √§hnelt, muss sich ein Array befinden. Das Array verf√ºgt jedoch nicht √ºber eine strukturelle Freigabe. Um ein Element des Arrays zu √§ndern, ohne die Persistenz-Eigenschaft zu verlieren, m√ºssen Sie das gesamte Array kopieren. Um dies nicht zu tun, kann das Array in separate Teile aufgeteilt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir jetzt ein Vektorelement aktualisieren, m√ºssen wir nur ein St√ºck und nicht den gesamten Vektor kopieren. Aber solche Teile selbst sind keine Datenstruktur, sie m√ºssen auf die eine oder andere Weise kombiniert werden. Legen Sie sie in ein anderes Array. Erneut tritt das Problem auf, dass das Array sehr gro√ü sein kann und das erneute Kopieren zu lange dauert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir teilen dieses Array in Teile, platzieren sie erneut in einem separaten Array und wiederholen diesen Vorgang, bis nur noch ein Root-Array vorhanden ist. Die resultierende Struktur wird als Restbaum bezeichnet. Dieser Baum wird durch die Konstante M = 2B, dh den Verzweigungsfaktor, beschrieben. Dieser Verzweigungsindikator sollte eine Zweierpotenz sein, und wir werden sehr bald herausfinden, warum. In dem Beispiel auf der Folie werden Bl√∂cke mit vier Zeichen verwendet, in der Praxis werden jedoch Bl√∂cke mit 32 Zeichen verwendet. Es gibt Experimente, mit denen Sie die optimale Blockgr√∂√üe f√ºr eine bestimmte Architektur finden k√∂nnen. Auf diese Weise k√∂nnen Sie das beste Verh√§ltnis zwischen strukturellem gemeinsamem Zugriff und Zugriffszeit erzielen: Je niedriger der Baum, desto weniger Zugriffszeit.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entwickler, die dies in C ++ schreiben, denken wahrscheinlich: Aber alle baumbasierten Strukturen sind sehr langsam! B√§ume wachsen mit zunehmender Anzahl von Elementen in ihnen, und aus diesem Grund werden die Zugriffszeiten verk√ºrzt. Deshalb bevorzugen Programmierer </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eher als </font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ich beeile mich, Sie zu beruhigen: Unser Baum w√§chst sehr langsam. Ein Vektor, der alle m√∂glichen Werte eines 32-Bit-Int enth√§lt, ist nur 7 Ebenen hoch. Es kann experimentell gezeigt werden, dass bei dieser Datengr√∂√üe das Verh√§ltnis des Caches zum Lastvolumen die Leistung erheblich beeinflusst als die Tiefe des Baums. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, wie ein Zugriff auf ein Element eines Baumes durchgef√ºhrt wird. Angenommen, Sie m√ºssen sich Element 17 zuwenden. Wir nehmen eine bin√§re Darstellung des Index und teilen ihn in Gruppen von der Gr√∂√üe eines Verzweigungsfaktors auf.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c1/gz/o1/c1gzo1qqm9pycpehqerzzkvwvwm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In jeder Gruppe verwenden wir den entsprechenden Bin√§rwert und gehen so den Baum hinunter. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir als n√§chstes an, wir m√ºssen diese Datenstruktur √§ndern, dh die Methode ausf√ºhren </font></font><code>.set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/l8/xi/3y/l8xi3yorosfghnwt9gmcijtk83a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dazu m√ºssen Sie zuerst den Block kopieren, in dem sich das Element befindet, und dann jeden internen Knoten auf dem Weg zum Element kopieren. Einerseits m√ºssen ziemlich viele Daten kopiert werden, gleichzeitig ist ein erheblicher Teil dieser Daten √ºblich, dies kompensiert deren Volumen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úbrigens gibt es eine viel √§ltere Datenstruktur, die der von mir beschriebenen sehr √§hnlich ist. Dies sind Speicherseiten mit einem Seitentabellenbaum. Ihre Gesch√§ftsf√ºhrung erfolgt ebenfalls per Anruf </font></font><code>fork</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir, unsere Datenstruktur zu verbessern. Angenommen, wir m√ºssen zwei Vektoren verbinden. Die bisher beschriebene Datenstruktur weist dieselben Einschr√§nkungen auf </font></font><code>std::vector:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie leere Zellen ganz rechts. Da die Struktur perfekt ausbalanciert ist, k√∂nnen sich diese leeren Zellen nicht in der Mitte des Baums befinden. Wenn es also einen zweiten Vektor gibt, den wir mit dem ersten kombinieren m√∂chten, m√ºssen wir die Elemente in leere Zellen kopieren, wodurch leere Zellen im zweiten Vektor erstellt werden, und am Ende m√ºssen wir den gesamten zweiten Vektor kopieren. Eine solche Operation hat die Rechenkomplexit√§t O (n), wobei n die Gr√∂√üe des zweiten Vektors ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden versuchen, ein besseres Ergebnis zu erzielen. Es gibt eine modifizierte Version unserer Datenstruktur, die als Relaxed Radix Balanced Tree bezeichnet wird. In dieser Struktur k√∂nnen Knoten, die sich nicht ganz links befinden, leere Zellen haben. Daher ist es in solchen unvollst√§ndigen (oder entspannten) Knoten erforderlich, die Gr√∂√üe des Teilbaums zu berechnen. Jetzt k√∂nnen Sie eine komplexe, aber logarithmische Verkn√ºpfungsoperation ausf√ºhren. Diese Operation mit konstanter Zeitkomplexit√§t ist O (log (32)). Da die B√§ume flach sind, ist die Zugriffszeit konstant, wenn auch relativ lang. Aufgrund der Tatsache, dass wir eine solche Vereinigungsoperation haben, wird eine entspannte Version dieser Datenstruktur als konfluent bezeichnet: Zus√§tzlich zu ihrer Best√§ndigkeit und Sie k√∂nnen sie teilen, k√∂nnen zwei solcher Strukturen zu einer kombiniert werden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qr/rj/hz/qrrjhzfbr-22n0cdr-vvhke1pvq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dem Beispiel, mit dem wir bisher gearbeitet haben, ist die Datenstruktur sehr ordentlich, aber in der Praxis sehen die Implementierungen in Clojure und anderen funktionalen Sprachen anders aus. Sie erstellen Container f√ºr jeden Wert, dh jedes Element im Vektor befindet sich in einer separaten Zelle, und Blattknoten enthalten Zeiger auf diese Elemente. Dieser Ansatz ist jedoch √§u√üerst ineffizient. In C ++ wird normalerweise nicht jeder Wert in einen Container eingef√ºgt. Daher ist es besser, wenn sich diese Elemente direkt in Knoten befinden. Dann tritt ein anderes Problem auf: Unterschiedliche Elemente haben unterschiedliche Gr√∂√üen. Wenn das Element dieselbe Gr√∂√üe wie der Zeiger hat, sieht unsere Struktur wie folgt aus:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/78/s4/_k/78s4_kqqdc_fi8_ydkopktou0m4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Elemente jedoch gro√ü sind, verliert die Datenstruktur die von uns gemessenen Eigenschaften (Zugriffszeit O (log (32) ()), da das Kopieren eines der Bl√§tter jetzt l√§nger dauert. Daher habe ich diese Datenstruktur so ge√§ndert, dass sie mit zunehmender Gr√∂√üe zunimmt Die Anzahl der darin enthaltenen Elemente verringerte die Anzahl dieser Elemente in den Blattknoten. Im Gegenteil, wenn die Elemente klein sind, k√∂nnen sie jetzt mehr passen. Die neue Version des Baums wird als Einbetten eines radixausgeglichenen Baums bezeichnet. Sie wird nicht durch eine Konstante beschrieben, sondern durch zwei: eine von ihnen beschreibt interne Knoten und das zweite Blatt. Durch die Implementierung des Baums in C ++ kann die optimale Gr√∂√üe des Blattelements in Abh√§ngigkeit von der Gr√∂√üe der Zeiger und der Elemente selbst berechnet werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Baum funktioniert bereits recht gut, kann aber noch verbessert werden. Schauen Sie sich eine Funktion √§hnlich einer Funktion an </font></font><code>iota</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = v.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es nimmt eine Eingabe entgegen </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am Ende des Vektors f√ºr jede Ganzzahl zwischen </font></font><code>first</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ausgef√ºhrt </font></font><code>last</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und gibt zur√ºck, was passiert ist. Alles ist in Ordnung mit der Richtigkeit dieser Funktion, aber es funktioniert ineffizient. Jeder Aufruf </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kopiert den Block ganz links unn√∂tig: Der n√§chste Aufruf dr√ºckt ein anderes Element und die Kopie wird erneut wiederholt, und die von der vorherigen Methode kopierten Daten werden gel√∂scht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen eine andere Implementierung dieser Funktion ausprobieren, bei der wir die Persistenz innerhalb der Funktion aufgeben. Kann </font></font><code>transient vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einer ver√§nderlichen API verwendet werden, die mit der regul√§ren API kompatibel ist </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Innerhalb einer solchen Funktion </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√§ndert </font><font style="vertical-align: inherit;">jeder Aufruf </font><font style="vertical-align: inherit;">die Datenstruktur.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    auto t = v.transient();<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        t.push_back(i);<font></font>
    <span class="hljs-keyword">return</span> t.persistent();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Implementierung ist effizienter und erm√∂glicht es Ihnen, neue Elemente auf dem richtigen Weg wiederzuverwenden. Am Ende der Funktion wird ein Aufruf </font></font><code>.persistent()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get√§tigt, der unver√§nderlich zur√ºckgibt </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. M√∂gliche Nebenwirkungen bleiben von au√üerhalb der Funktion unsichtbar. Das Original </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">war und bleibt unver√§nderlich, nur die innerhalb der Funktion erstellten Daten werden ge√§ndert. Wie bereits erw√§hnt, besteht ein wichtiger Vorteil dieses Ansatzes darin, dass Sie </font></font><code>std::back_inserter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardalgorithmen verwenden k√∂nnen, f√ºr die ver√§nderbare APIs erforderlich sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie ein anderes Beispiel.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        <font></font>
            .push_back(<span class="hljs-string">'i'</span>)        <font></font>
            .push_back(<span class="hljs-string">'!'</span>);       <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion akzeptiert nicht und gibt zur√ºck </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber eine Aufrufkette wird im Inneren ausgef√ºhrt </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Hier kann wie im vorherigen Beispiel unn√∂tiges Kopieren innerhalb des Anrufs auftreten </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Beachten Sie, dass der erste Wert, der ausgef√ºhrt </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird, der benannte Wert ist und der Rest ein r-Wert ist, dh anonyme Links. Wenn Sie die Referenzz√§hlung verwenden, kann die Methode </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf Referenzz√§hler f√ºr Knoten verweisen, denen im Baum Speicher zugewiesen ist. Und im Fall von r-Wert wird klar, dass kein anderer Teil des Programms auf diese Knoten zugreift, wenn die Anzahl der Verkn√ºpfungen eins ist. Hier ist die Leistung genau die gleiche wie im Fall von </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">say_hi</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">char</span>&gt; v</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> v.push_back(<span class="hljs-string">'h'</span>)        ‚üµ named <span class="hljs-keyword">value</span>: v<font></font>
            .push_back(<span class="hljs-string">'i'</span>)        ‚üµ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span>
            .push_back(<span class="hljs-string">'!'</span>);       ‚üµ r-<span class="hljs-keyword">value</span> <span class="hljs-keyword">value</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dem Compiler zu helfen, k√∂nnen wir ihn au√üerdem ausf√ºhren </font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da er an </font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keiner anderen Stelle in der Funktion verwendet wird. Wir hatten einen wichtigen Vorteil, der nicht in der </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variante enthalten war: Wenn wir den zur√ºckgegebenen Wert eines anderen say_hi an die Funktion say_hi √ºbergeben, gibt es keine zus√§tzlichen Kopien. Im Fall von c </font></font><code>transient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt es Grenzen, an denen √ºberm√§√üiges Kopieren auftreten kann. Mit anderen Worten, wir haben eine dauerhafte, unver√§nderliche Datenstruktur, deren Leistung von der tats√§chlichen Menge des gemeinsam genutzten Zugriffs zur Laufzeit abh√§ngt. Wenn keine Freigabe erfolgt, entspricht die Leistung der einer ver√§nderlichen Datenstruktur. Dies ist eine √§u√üerst wichtige Eigenschaft. Das Beispiel, das ich Ihnen oben bereits gezeigt habe, kann mit einer Methode umgeschrieben werden </font></font><code>move(v)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">myiota</span>(<span class="hljs-params">vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">for</span> (auto i = first; i &lt; last; ++i)<font></font>
        v = std::move(v).push_back(i);<font></font>
    <span class="hljs-keyword">return</span> v;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bisher haben wir √ºber Vektoren gesprochen, und zus√§tzlich gibt es auch Hash-Maps. Sie widmen sich einem sehr n√ºtzlichen Bericht von Phil Nash: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der heilige Gral. Ein Hash-Array hat Trie f√ºr C ++ zugeordnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es beschreibt Hash-Tabellen, die nach denselben Prinzipien implementiert wurden, √ºber die ich gerade gesprochen habe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich bin sicher, dass viele von Ihnen Zweifel an der Leistung solcher Strukturen haben. Arbeiten sie in der Praxis schnell? Ich habe viele Tests durchgef√ºhrt und kurz gesagt lautet meine Antwort ja. Wenn Sie mehr √ºber die Testergebnisse erfahren m√∂chten, werden diese in meinem Artikel f√ºr die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internationale Konferenz f√ºr funktionale Programmierung 2017 ver√∂ffentlicht</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich denke, es ist besser, nicht die absoluten Werte zu diskutieren, sondern die Auswirkungen dieser Datenstruktur auf das Gesamtsystem. </font><font style="vertical-align: inherit;">Nat√ºrlich ist die Aktualisierung unseres Vektors langsamer, da Sie mehrere Datenbl√∂cke kopieren und Speicher f√ºr andere Daten zuweisen m√ºssen. </font><font style="vertical-align: inherit;">Das Umgehen unseres Vektors erfolgt jedoch fast mit der gleichen Geschwindigkeit wie bei einem normalen. </font><font style="vertical-align: inherit;">F√ºr mich war es sehr wichtig, dies zu erreichen, da das Lesen von Daten viel h√§ufiger durchgef√ºhrt wird als das √Ñndern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund der langsameren Aktualisierung muss nichts kopiert werden, nur die Datenstruktur wird kopiert. </font><font style="vertical-align: inherit;">Daher wird die f√ºr die Aktualisierung des Vektors aufgewendete Zeit sozusagen f√ºr alle im System durchgef√ºhrten Kopien amortisiert. </font><font style="vertical-align: inherit;">Wenn Sie diese Datenstruktur in einer Architektur anwenden, die der zu Beginn des Berichts beschriebenen √§hnlich ist, steigt die Leistung daher erheblich.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ewig</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde nicht unbegr√ºndet sein und meine Datenstruktur anhand eines Beispiels demonstrieren. </font><font style="vertical-align: inherit;">Ich habe einen kleinen Texteditor geschrieben. </font><font style="vertical-align: inherit;">Dies ist ein interaktives Tool namens </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , bei dem Dokumente durch unver√§nderliche Vektoren dargestellt werden. </font><font style="vertical-align: inherit;">Ich habe eine Kopie der gesamten Wikipedia in Esperanto auf meiner Festplatte gespeichert, sie wiegt 1 Gigabyte (zuerst wollte ich die englische Version herunterladen, aber sie ist zu gro√ü). </font><font style="vertical-align: inherit;">Welchen Texteditor Sie auch verwenden, ich bin sicher, dass ihm diese Datei nicht gefallen wird. </font><font style="vertical-align: inherit;">Und wenn Sie diese Datei in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> herunterladen </font><font style="vertical-align: inherit;">, k√∂nnen Sie sie sofort bearbeiten, da der Download asynchron ist. </font><font style="vertical-align: inherit;">Die Dateinavigation funktioniert, nichts h√§ngt, nein </font></font><code>mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, keine Synchronisation. </font><font style="vertical-align: inherit;">Wie Sie sehen k√∂nnen, ben√∂tigt die heruntergeladene Datei 20 Millionen Codezeilen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir uns mit den wichtigsten Eigenschaften dieses Tools befassen, sollten wir uns mit einem lustigen Detail befassen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eb/kt/eq/ebkteqmtvnbkncoxlb91z0g6qpy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Anfang der Zeile, die am unteren Rand des Bildes wei√ü hervorgehoben ist, sehen Sie zwei Bindestriche. Diese Benutzeroberfl√§che ist Emacs-Benutzern h√∂chstwahrscheinlich vertraut. Bindestriche bedeuten, dass das Dokument in keiner Weise ge√§ndert wurde. Wenn Sie √Ñnderungen vornehmen, werden anstelle von Bindestrichen Sternchen angezeigt. Wenn Sie </font><font style="vertical-align: inherit;">diese √Ñnderungen jedoch </font><font style="vertical-align: inherit;">im Gegensatz zu anderen Editoren in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> l√∂schen (nicht r√ºckg√§ngig machen, sondern nur l√∂schen), werden anstelle von Sternchen wieder Bindestriche angezeigt, da </font><font style="vertical-align: inherit;">alle vorherigen Versionen des Textes </font><font style="vertical-align: inherit;">in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gespeichert sind. Dank dessen wird kein spezielles Flag ben√∂tigt, um anzuzeigen, ob das Dokument ge√§ndert wurde: Das Vorhandensein von √Ñnderungen wird durch Vergleich mit dem Originaldokument festgestellt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie eine weitere interessante Eigenschaft des Tools: Kopieren Sie den gesamten Text und f√ºgen Sie ihn einige Male in die Mitte des vorhandenen Textes ein. </font><font style="vertical-align: inherit;">Wie Sie sehen k√∂nnen, geschieht dies sofort. </font><font style="vertical-align: inherit;">Das Verbinden von Vektoren ist hier eine logarithmische Operation, und der Logarithmus von mehreren Millionen ist keine so lange Operation. </font><font style="vertical-align: inherit;">Wenn Sie versuchen, dieses gro√üe Dokument auf Ihrer Festplatte zu speichern, dauert es viel l√§nger, da der Text nicht mehr als Vektor dargestellt wird, der aus der vorherigen Version dieses Vektors stammt. </font><font style="vertical-align: inherit;">Beim Speichern auf der Festplatte erfolgt eine Serialisierung, sodass die Persistenz verloren geht.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zur√ºck zur wertbasierten Architektur</font></font></h2><br>
<img src="https://habrastorage.org/webt/wf/o7/b7/wfo7b78ha0wnqjzcjjeky_esh0g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir damit, wie Sie nicht zu dieser Architektur zur√ºckkehren k√∂nnen: Verwenden Sie den √ºblichen Controller, das Modell und die Ansicht im Java-Stil, die am h√§ufigsten f√ºr interaktive Anwendungen in C ++ verwendet werden. Es ist nichts falsch mit ihnen, aber sie sind nicht f√ºr unser Problem geeignet. Einerseits erm√∂glicht das Model-View-Controller-Muster die Trennung von Aufgaben, andererseits ist jedes dieser Elemente ein Objekt, sowohl aus objektorientierter Sicht als auch aus Sicht von C ++, dh es handelt sich um ver√§nderbare Speicherbereiche Bedingung. View kennt sich mit Model aus; Das ist viel schlimmer - Model kennt View indirekt, da es mit ziemlicher Sicherheit einen R√ºckruf gibt, √ºber den die View benachrichtigt wird, wenn sich das Modell √§ndert. Selbst mit der besten Implementierung objektorientierter Prinzipien erhalten wir viele gegenseitige Abh√§ngigkeiten.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/07/so/xq/07soxqkandixucwhzk6mvfr1e84.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Anwendung w√§chst und neues Modell, Controller und Ansicht hinzugef√ºgt werden, tritt eine Situation auf, in der Sie zum √Ñndern eines Programmsegments alle damit verbundenen Teile, alle Ansichten kennen m√ºssen, √ºber die Warnungen empfangen </font></font><code>callback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden usw. Infolgedessen alle Das bekannte Pasta-Monster beginnt, diese Abh√§ngigkeiten zu durchschauen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ist eine andere Architektur m√∂glich? Es gibt einen alternativen Ansatz f√ºr das Model-View-Controller-Muster namens "Unidirectional Data Flow Architecture". Dieses Konzept wurde nicht von mir erfunden, es wird ziemlich oft in der Webentwicklung verwendet. Auf Facebook wird dies als Flux-Architektur bezeichnet, in C ++ jedoch noch nicht.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/z6/p2/tyz6p2hutpnjwusi0edhbcwvo0s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elemente einer solchen Architektur sind uns bereits bekannt: Aktion, Modell und Ansicht, aber die Bedeutung von Bl√∂cken und Pfeilen ist unterschiedlich. Bl√∂cke sind Werte, keine Objekte und keine Regionen mit ver√§nderlichen Zust√§nden. Dies gilt auch f√ºr View. Au√üerdem sind Pfeile keine Links, da es ohne Objekte keine Links geben kann. Hier sind die Pfeile Funktionen. Zwischen Aktion und Modell gibt es eine Aktualisierungsfunktion, die das aktuelle Modell, dh den aktuellen Status der Welt, akzeptiert, und Aktion, die ein Ereignis darstellt, z. B. einen Mausklick oder ein Ereignis einer anderen Abstraktionsebene, z. B. das Einf√ºgen eines Elements oder Symbols in ein Dokument. Die Aktualisierungsfunktion aktualisiert das Dokument und gibt den neuen Status der Welt zur√ºck. Das Modell stellt eine Verbindung zum Rendern der Ansichtsfunktion her, die das Modell √ºbernimmt und die Ansicht zur√ºckgibt. Dies erfordert ein Framework, in dem View als Werte dargestellt werden kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Webentwicklung macht React dies, aber in C ++ gibt es noch nichts Vergleichbares, obwohl wer wei√ü, wenn es Leute gibt, die mich daf√ºr bezahlen wollen, dass ich so etwas schreibe, kann es bald erscheinen. In der Zwischenzeit k√∂nnen Sie die API f√ºr den Sofortmodus verwenden, mit der Sie mit der Zeichenfunktion einen Wert als Nebeneffekt erstellen k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schlie√ülich sollte die Ansicht √ºber einen Mechanismus verf√ºgen, mit dem der Benutzer oder andere Ereignisquellen eine Aktion senden k√∂nnen. Es gibt eine einfache M√∂glichkeit, dies zu implementieren. Es wird unten dargestellt:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">application <span class="hljs-title">update</span>(<span class="hljs-params">application state, action ev</span>)</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* fname</span>)</span><font></font>
{<font></font>
    auto term  = terminal{};<font></font>
    auto state = application{load_buffer(fname), key_map_emacs};<font></font>
    <span class="hljs-keyword">while</span> (!state.done) {<font></font>
        draw(state);<font></font>
        auto act = term.next();<font></font>
        state = update(state, act);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Ausnahme des asynchronen Speicherns und Ladens ist dies der Code, der in dem gerade dargestellten Editor verwendet wird. Hier gibt es ein Objekt </font></font><code>terminal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit dem Sie √ºber die Befehlszeile lesen und schreiben k√∂nnen. Ferner </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist dies der Wert von Model, speichert er den gesamten Zustand der Anwendung. Wie Sie oben auf dem Bildschirm sehen k√∂nnen, gibt es eine Funktion, die eine neue Version zur√ºckgibt </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Der Zyklus innerhalb der Funktion wird ausgef√ºhrt, bis die Anwendung geschlossen werden muss, dh bis </font></font><code>!state.done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In der Schleife wird ein neuer Zustand gezeichnet, dann wird das n√§chste Ereignis angefordert. Schlie√ülich wird der Status in einer lokalen Variablen gespeichert </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die Schleife beginnt erneut. Dieser Code hat einen sehr wichtigen Vorteil: W√§hrend der Ausf√ºhrung des Programms existiert nur eine ver√§nderbare Variable, es handelt sich um ein Objekt </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Clojure-Entwickler nennen diese Single-Atom-Architektur: Es gibt einen einzigen Punkt in der gesamten Anwendung, √ºber den alle √Ñnderungen vorgenommen werden. </font><font style="vertical-align: inherit;">Die Anwendungslogik beteiligt sich in keiner Weise an der Aktualisierung dieses Punktes, dies macht einen speziell daf√ºr entworfenen Zyklus. </font><font style="vertical-align: inherit;">Dank dessen besteht die Anwendungslogik vollst√§ndig aus reinen Funktionen, wie Funktionen </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit diesem Ansatz zum Schreiben von Anwendungen √§ndert sich die Denkweise √ºber Software. </font><font style="vertical-align: inherit;">Die Arbeit beginnt nun nicht mit dem UML-Diagramm der Schnittstellen und Operationen, sondern mit den Daten selbst. </font><font style="vertical-align: inherit;">Es gibt einige √Ñhnlichkeiten mit datenorientiertem Design. </font><font style="vertical-align: inherit;">Richtiges, datenorientiertes Design wird normalerweise verwendet, um maximale Leistung zu erzielen. Hier streben wir neben der Geschwindigkeit nach Einfachheit und Korrektheit. </font><font style="vertical-align: inherit;">Die Betonung ist etwas anders, aber es gibt wichtige √Ñhnlichkeiten in der Methodik.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> index = <span class="hljs-keyword">int</span>;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> coord<font></font>
{<font></font>
    index row = {};<font></font>
    index col = {};<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">using</span> line = immer::flex_vector&lt;<span class="hljs-keyword">char</span>&gt;;
<span class="hljs-keyword">using</span> text = immer::flex_vector&lt;line&gt;;<font></font>
<font></font>
<span class="hljs-keyword">struct</span> file<font></font>
{<font></font>
    immer::box&lt;std::<span class="hljs-keyword">string</span>&gt; name;<font></font>
    text content;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> snapshot<font></font>
{<font></font>
    text content;<font></font>
    coord cursor;<font></font>
};<font></font>
 <font></font>
<span class="hljs-keyword">struct</span> buffer<font></font>
{<font></font>
    file <span class="hljs-keyword">from</span>;<font></font>
    text content;<font></font>
    coord cursor;<font></font>
    coord scroll;<font></font>
    std::optional&lt;coord&gt; selection_start;<font></font>
    immer::vector&lt;snapshot&gt; history;<font></font>
    std::optional&lt;std::size_t&gt; history_pos;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> application<font></font>
{<font></font>
    buffer current;<font></font>
    key_map keys;<font></font>
    key_seq input;<font></font>
    immer::vector&lt;text&gt; clipboard;<font></font>
    immer::vector&lt;message&gt; messages;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">struct</span> action { key_code key; coord size; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oben sind die wichtigsten Datentypen unserer Anwendung aufgef√ºhrt. Der Hauptteil der Anwendung besteht aus </font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flex_vector, und flex_vector ist </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer, f√ºr den Sie eine Verkn√ºpfungsoperation ausf√ºhren k√∂nnen. Als n√§chstes </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">folgt der Vektor, in dem er gespeichert ist </font></font><code>line</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wie Sie sehen k√∂nnen, ist dies eine sehr einfache Darstellung des Textes. </font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gespeichert, mit deren Hilfe </font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Name, dh eine Adresse im Dateisystem, und tats√§chlich </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wie </font></font><code>file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein anderer Typ verwendet, ein einfacher, aber sehr n√ºtzlicher : </font></font><code>box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies ist ein Einzelelementcontainer. Sie k√∂nnen einen Heap einf√ºgen und ein Objekt verschieben, wobei das Kopieren m√∂glicherweise zu ressourcenintensiv ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer wichtiger Typ : </font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Basierend auf diesem Typ ist eine Abbruchfunktion aktiv. Es enth√§lt ein Dokument (im Formular</font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) und Cursorposition (Koordinate). Auf diese Weise k√∂nnen Sie den Cursor an die Position zur√ºcksetzen, an der er sich w√§hrend der Bearbeitung befand. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der n√§chste Typ ist </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies ist ein Begriff von vim und emacs, wie dort offene Dokumente genannt werden. Darin </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">befindet sich eine Datei, aus der der Text heruntergeladen wurde, sowie der Inhalt des Textes. Auf diese Weise k√∂nnen Sie nach √Ñnderungen im Dokument suchen. Um einen Teil des Textes hervorzuheben, gibt es eine optionale Variable </font></font><code>selection_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die den Beginn der Auswahl angibt. Der Vektor von </font></font><code>snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist die Geschichte des Textes. Beachten Sie, dass wir das Teammuster nicht verwenden. Der Verlauf besteht nur aus Status. Wenn die Stornierung gerade abgeschlossen wurde, ben√∂tigen wir einen Positionsindex in der Statushistorie </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der n√§chste Typ : </font></font><code>application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es enth√§lt ein offenes Dokument (Puffer) </font></font><code>key_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und</font></font><code>key_seq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr Tastaturk√ºrzel sowie einen Vektor aus </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr die Zwischenablage und einen weiteren Vektor f√ºr Nachrichten, die am unteren Bildschirmrand angezeigt werden. </font><font style="vertical-align: inherit;">Bisher wird es in der Deb√ºtversion der Anwendung nur einen Thread und eine Art von Aktion geben, die Eingaben </font></font><code>key_code</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>coord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√∂chstwahrscheinlich denken viele von Ihnen bereits dar√ºber nach, wie diese Vorg√§nge implementiert werden sollen. </font><font style="vertical-align: inherit;">Wenn nach Wert genommen und nach Wert zur√ºckgegeben, sind die Operationen in den meisten F√§llen recht einfach. </font><font style="vertical-align: inherit;">Der Code meines Texteditors ist auf </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github ver√∂ffentlicht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sodass Sie sehen k√∂nnen, wie er tats√§chlich aussieht. </font><font style="vertical-align: inherit;">Jetzt werde ich nur auf den Code eingehen, der die Stornierungsfunktion implementiert.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stornieren</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das korrekte Schreiben einer Stornierung ohne die entsprechende Infrastruktur ist nicht so einfach. In meinem Editor habe ich es nach dem Vorbild von Emacs implementiert, also zun√§chst ein paar Worte zu seinen Grundprinzipien. Der Befehl return fehlt hier und dank dessen k√∂nnen Sie keine Arbeit verlieren. Wenn eine R√ºcksendung erforderlich ist, werden √Ñnderungen am Text vorgenommen, und alle Stornierungsaktionen werden wieder Teil des Stornierungsverlaufs.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s0/4z/j_/s04zj_sia6mzw8reywkbznlhlem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Prinzip ist oben dargestellt. Die rote Raute zeigt hier eine Position in der Geschichte: Wenn eine Stornierung gerade nicht abgeschlossen wurde, ist die rote Raute immer ganz am Ende. Wenn Sie abbrechen, verschiebt der Diamant einen Status zur√ºck, aber gleichzeitig wird am Ende der Warteschlange ein weiterer Status hinzugef√ºgt - derselbe, den der Benutzer derzeit sieht (S3). Wenn Sie erneut abbrechen und zum Status S2 zur√ºckkehren, wird der Status S2 am Ende der Warteschlange hinzugef√ºgt. Wenn der Benutzer jetzt eine √Ñnderung vornimmt, wird diese als neuer Status von S5 am Ende der Warteschlange hinzugef√ºgt und eine Raute wird dorthin verschoben. Wenn Sie nun vergangene Aktionen r√ºckg√§ngig machen, werden die vorherigen r√ºckg√§ngig gemachten Aktionen zuerst gescrollt. Um ein solches Stornierungssystem zu implementieren, reicht der folgende Code aus:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">buffer <span class="hljs-title">record</span>(<span class="hljs-params">buffer before, buffer after</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">if</span> (before.content != after.content) {<font></font>
        after.history = after.history.push_back({before.content, before.cursor});<font></font>
        <span class="hljs-keyword">if</span> (before.history_pos == after.history_pos)<font></font>
            after.history_pos = std::nullopt;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> after;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">buffer <span class="hljs-title">undo</span>(<span class="hljs-params">buffer buf</span>)</span><font></font>
{<font></font>
    auto idx = buf.history_pos.value_or(buf.history.size());<font></font>
    <span class="hljs-keyword">if</span> (idx &gt; <span class="hljs-number">0</span>) {<font></font>
        auto restore = buf.history[--idx];<font></font>
        buf.content = restore.content;<font></font>
        buf.cursor = restore.cursor;<font></font>
        buf.history_pos = idx;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> buf;<font></font>
  }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt zwei Aktionen </font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w√§hrend einer Operation durchgef√ºhrt. Dies ist sehr praktisch, da wir nicht wissen m√ºssen, ob das Dokument bearbeitet wurde. Die Funktion ist f√ºr die Anwendungslogik transparent. Nach jeder Aktion pr√ºft die Funktion, ob sich das Dokument ge√§ndert hat. Wenn eine √Ñnderung aufgetreten ist, werden der </font></font><code>push_back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhalt und die Cursorposition f√ºr </font><font style="vertical-align: inherit;">ausgef√ºhrt </font></font><code>history</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn die Aktion nicht zu einer √Ñnderung gef√ºhrt hat </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dh die empfangene Eingabe wird </font></font><code>buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht durch die Abbruchaktion verursacht), wird </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Wert zugewiesen </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Bei Bedarf </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√ºfen wir </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn es keine Bedeutung hat, betrachten wir es </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als am Ende der Geschichte. Wenn der Stornierungsverlauf nicht leer ist (d. H.</font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht ganz am Anfang der Geschichte), wird eine Stornierung durchgef√ºhrt. </font><font style="vertical-align: inherit;">Der aktuelle Inhalt und der Cursor werden ersetzt und ge√§ndert </font></font><code>history_pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Unwiderruflichkeit des Abbruchvorgangs wird durch die Funktion erreicht </font></font><code>record</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die auch w√§hrend des Abbruchvorgangs aufgerufen wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben also eine Operation </font></font><code>undo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die 10 Codezeilen einnimmt und die ohne √Ñnderungen (oder mit minimalen √Ñnderungen) in fast jeder anderen Anwendung verwendet werden kann.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitreise</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úber Zeitreisen. Wie wir jetzt sehen werden, ist dies ein Thema im Zusammenhang mit der Stornierung. Ich werde die Arbeit eines Frameworks demonstrieren, das jeder Anwendung mit einer √§hnlichen Architektur n√ºtzliche Funktionen hinzuf√ºgt. Das Framework hei√üt hier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig-debug</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Diese Version von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ewig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enth√§lt einige Debugging-Funktionen. Jetzt k√∂nnen Sie √ºber den Browser den Debugger √∂ffnen, in dem Sie den Status der Anwendung √ºberpr√ºfen k√∂nnen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dy/ba/7x/dyba7xjocwgjjmqvayinlfwx0y4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sehen, dass die letzte Aktion die Gr√∂√üe ge√§ndert hat, weil ich ein neues Fenster ge√∂ffnet habe und mein Fenstermanager die Gr√∂√üe des bereits ge√∂ffneten Fensters automatisch ge√§ndert hat. F√ºr die automatische Serialisierung in JSON musste ich nat√ºrlich Anmerkungen f√ºr struct aus der speziellen Reflection-Bibliothek hinzuf√ºgen. Der Rest des Systems ist jedoch ziemlich universell und kann mit jeder √§hnlichen Anwendung verbunden werden. Jetzt k√∂nnen Sie im Browser alle abgeschlossenen Aktionen sehen. Nat√ºrlich gibt es einen Anfangszustand, der keine Aktion hat. Dies ist der Status vor dem Download. Dar√ºber hinaus kann ich durch Doppelklicken die Anwendung in den vorherigen Zustand zur√ºckversetzen. Dies ist ein sehr n√ºtzliches Debugging-Tool, mit dem Sie das Auftreten einer Fehlfunktion in der Anwendung verfolgen k√∂nnen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie interessiert sind, k√∂nnen Sie meinen Bericht √ºber CPPCON 19, Die wertvollsten Werte, anh√∂ren. Dort werde ich diesen Debugger im Detail untersuchen. </font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/_oBx_NbLghY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus wird dort die wertebasierte Architektur n√§her erl√§utert. </font><font style="vertical-align: inherit;">Darin erkl√§re ich Ihnen auch, wie Sie Aktionen implementieren und hierarchisch organisieren. </font><font style="vertical-align: inherit;">Dies stellt die Modularit√§t des Systems sicher und erm√∂glicht es Ihnen, nicht alles in einer gro√üen Aktualisierungsfunktion zu behalten. </font><font style="vertical-align: inherit;">Dar√ºber hinaus wird in diesem Bericht auf Asynchronit√§t und das Herunterladen von Dateien mit mehreren Threads eingegangen. </font><font style="vertical-align: inherit;">Es gibt eine andere Version dieses Berichts, in der eine halbe Stunde zus√§tzliches Material postmoderne unver√§nderliche Datenstrukturen enth√§lt.</font></font><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/y_m0ce1rzRI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke, es ist Zeit, Bilanz zu ziehen. Ich werde Andy Wingo zitieren - er ist ein ausgezeichneter Entwickler, er hat viel Zeit f√ºr V8 und Compiler im Allgemeinen aufgewendet, schlie√ülich ist er damit besch√§ftigt, Guile zu unterst√ºtzen und das Schema f√ºr GNU zu implementieren. K√ºrzlich schrieb er auf seinem Twitter: ‚ÄûUm eine leichte Beschleunigung des Programms zu erreichen, messen wir jede kleine √Ñnderung und lassen nur diejenigen √ºbrig, die ein positives Ergebnis liefern. Aber wir erreichen wirklich eine signifikante Beschleunigung, blind, investieren viel M√ºhe, haben kein 100% iges Vertrauen und werden nur von der Intuition geleitet. Was f√ºr eine seltsame Zweiteilung. "</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint mir, dass C ++ - Entwickler im ersten Genre erfolgreich sind. </font><font style="vertical-align: inherit;">Geben Sie uns ein geschlossenes System, und wir werden mit unseren Werkzeugen alles ausdr√ºcken, was daraus m√∂glich ist. </font><font style="vertical-align: inherit;">Aber im zweiten Genre sind wir es nicht gewohnt zu arbeiten. </font><font style="vertical-align: inherit;">Nat√ºrlich ist der zweite Ansatz riskanter und f√ºhrt oft zu einer Verschwendung gro√üer Anstrengungen. </font><font style="vertical-align: inherit;">Andererseits kann ein Programm durch einfaches Umschreiben oft einfacher und schneller gemacht werden. </font><font style="vertical-align: inherit;">Ich hoffe, ich habe es geschafft, Sie davon zu √ºberzeugen, zumindest diesen zweiten Ansatz zu versuchen.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juan Puente sprach auf der C ++ Russia 2019 in Moskau und sprach √ºber Datenstrukturen, mit denen Sie interessante Dinge tun k√∂nnen. </font><font style="vertical-align: inherit;">Ein Teil der Magie dieser Strukturen liegt in der </font><font style="vertical-align: inherit;">Auswahl von </font><font style="vertical-align: inherit;">Kopien - dar√ºber werden </font><font style="vertical-align: inherit;">Anton Polukhin und Roman Rusyaev </font><font style="vertical-align: inherit;">auf der kommenden Konferenz </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sprechen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Folgen Sie den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmaktualisierungen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf der Website.</font></font></blockquote></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de487100/">https://habr.com/ru/post/de487100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de487090/index.html">Eine neue Stufe der Windows-Optimierung</a></li>
<li><a href="../de487092/index.html">Modellierung von Gesch√§ftsprozessen als Teil eines Projekts zur Implementierung eines ERP-Systems</a></li>
<li><a href="../de487094/index.html">Wiederaufbereitungsereignisse von Kafka erhalten</a></li>
<li><a href="../de487096/index.html">Schnipsel. So vereinfachen Sie die Arbeit mit der Dokumentation</a></li>
<li><a href="../de487098/index.html">Zeichnen mit Ameisen: prozedurale Bilder unter Verwendung von Algorithmen zur Optimierung von Ameisenkolonien</a></li>
<li><a href="../de487106/index.html">RunUO-Pr√ºfung des PVS-Studio-Analysators</a></li>
<li><a href="../de487108/index.html">Mobiles Spielerprofil: MyTracker Research</a></li>
<li><a href="../de487110/index.html">Slurm SRE. Ein komplettes Experiment mit Experten von Booking.com und Google.com</a></li>
<li><a href="../de487112/index.html">Rand des Wahnsinns: Der Grundkreis</a></li>
<li><a href="../de487116/index.html">Warum Discord von Go nach Rust migriert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>