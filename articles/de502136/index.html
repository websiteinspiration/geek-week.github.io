<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗄️ 🌱 😯 Datenkomprimierung in Apache Ignite. Sberbank Erfahrung 👍🏿 🧜🏼 🤚🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei der Arbeit mit großen Datenmengen kann das Problem des unzureichenden Speicherplatzes manchmal akut werden. Eine Möglichkeit, dieses Problem zu lö...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Datenkomprimierung in Apache Ignite. Sberbank Erfahrung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/502136/"><img src="https://habrastorage.org/webt/cl/nj/sz/clnjsz90dmzkkj3wr4vuusu_-nu.png" align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Arbeit mit großen Datenmengen kann das Problem des unzureichenden Speicherplatzes manchmal akut werden. </font><font style="vertical-align: inherit;">Eine Möglichkeit, dieses Problem zu lösen, ist die Komprimierung, aufgrund derer Sie es sich auf demselben Gerät leisten können, das Speichervolumen zu erhöhen. </font><font style="vertical-align: inherit;">In diesem Artikel werden wir uns ansehen, wie die Datenkomprimierung in Apache Ignite funktioniert. </font><font style="vertical-align: inherit;">In diesem Artikel werden nur die im Produkt implementierten Methoden zur Festplattenkomprimierung beschrieben. </font><font style="vertical-align: inherit;">Andere Methoden der Datenkomprimierung (über das Netzwerk, im Speicher), sowohl implementiert als auch nicht, bleiben außerhalb des Bereichs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Persistenzmodus aktiviert ist, beginnt Ignite aufgrund der Änderung von Daten in Caches mit dem Schreiben auf die Festplatte:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cache-Inhalt</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Write Ahead Log (im Folgenden als WAL bezeichnet)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Mechanismus namens WAL-Verdichtung existiert seit langem, um WALs zu komprimieren. </font><font style="vertical-align: inherit;">Mit dem kürzlich veröffentlichten Apache Ignite 2.8 wurden zwei weitere Mechanismen zum Komprimieren von Daten auf der Festplatte eingeführt: die Komprimierung von Festplattenseiten zum Komprimieren des Inhalts von Caches und die Komprimierung von WAL-Seiten-Snapshots zum Komprimieren einiger WAL-Datensätze. </font><font style="vertical-align: inherit;">Mehr zu all diesen drei Mechanismen weiter unten.</font></font><a name="habracut"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komprimierung der Festplattenseite</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie es funktioniert</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst werden wir kurz darauf eingehen, wie Ignite Daten speichert. Für die Speicherung wird der Seitenspeicher verwendet. Die Seitengröße wird am Anfang des Knotens festgelegt und kann zu einem späteren Zeitpunkt nicht mehr geändert werden. Außerdem muss die Seitengröße eine Zweierpotenz und ein Vielfaches der Größe des Dateisystemblocks sein. Seiten werden nach Bedarf von der Festplatte in den RAM geladen. Die Datengröße auf der Festplatte kann die Menge des zugewiesenen RAM überschreiten. Wenn im RAM nicht genügend Speicherplatz zum Laden von Seiten von der Festplatte vorhanden ist, werden alte, nicht verwendete Seiten aus dem RAM verdrängt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Daten werden in der folgenden Form auf der Festplatte gespeichert: Für jede Partition jeder Cache-Gruppe wird eine separate Datei erstellt. In dieser Datei werden die Seiten in aufsteigender Reihenfolge des Index nacheinander verschoben. Die vollständige Seitenkennung enthält die Cache-Gruppenkennung, die Partitionsnummer und den Seitenindex in der Datei. Somit können wir anhand der vollständigen Seitenkennung die Datei und den Versatz in der Datei für jede Seite eindeutig identifizieren. Weitere Informationen zum Seitenspeicher finden Sie in einem Artikel im Apache Ignite Wiki: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ignite Persistent Store - unter der Haube</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Mechanismus zur Komprimierung von Festplattenseiten funktioniert, wie der Name schon sagt, auf Seitenebene. </font><font style="vertical-align: inherit;">Wenn dieser Mechanismus aktiviert ist, wird die Arbeit mit Daten im RAM unverändert ohne Komprimierung ausgeführt. Zum Zeitpunkt des Speicherns von Seiten vom RAM auf die Festplatte werden sie jedoch komprimiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Komprimieren jeder Seite einzeln ist jedoch keine Lösung für das Problem. Sie müssen die Größe der resultierenden Datendateien irgendwie reduzieren. </font><font style="vertical-align: inherit;">Wenn die Seitengröße nicht mehr festgelegt wird, können wir keine Seiten mehr einzeln in eine Datei schreiben, da dies zu einer Reihe von Problemen führen kann:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können den Seitenindex nicht verwenden, um den Versatz zu berechnen, an dem er sich in der Datei befindet.</font></font></li>
<li> ,    ,          .    ,     .    ,         .</li>
<li>           ,      ,        ,      .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese Probleme nicht auf eigener Ebene zu lösen, verwendet die Komprimierung von Festplattenseiten in Apache Ignite einen Dateisystemmechanismus namens Sparse-Dateien. Eine Sparse-Datei ist eine Datei, in der einige mit Nullen gefüllte Bereiche als Löcher markiert werden können. In diesem Fall werden Blöcke des Dateisystems zum Speichern dieser Löcher nicht zugewiesen, wodurch Speicherplatz gespart wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist logisch, dass zum Freigeben des Dateisystemblocks die Lochgröße größer oder gleich dem Dateisystemblock sein muss, wodurch die Seitengröße von Apache Ignite zusätzlich eingeschränkt wird: Damit die Komprimierung zumindest einen gewissen Effekt erzielt, muss die Seitengröße streng größer als die Dateisystemblockgröße sein . Wenn die Seitengröße der Größe des Blocks entspricht, können wir niemals einen einzelnen Block freigeben, da zum Freigeben eines einzelnen Blocks eine komprimierte Seite erforderlich ist, die 0 Byte belegt. Wenn die Seitengröße der Größe von 2 oder 4 Blöcken entspricht, können wir bereits mindestens einen Block freigeben, wenn unsere Seite auf mindestens 50% bzw. 75% komprimiert ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher die endgültige Beschreibung des Mechanismus: Beim Schreiben einer Seite auf die Festplatte wird versucht, die Seite zu komprimieren. Wenn die Größe der komprimierten Seite die Freigabe eines oder mehrerer Blöcke des Dateisystems ermöglicht, wird die Seite in komprimierter Form geschrieben und anstelle der freigegebenen Blöcke ein "Loch" gestanzt (ein Systemaufruf </font></font><code>fallocate()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit dem Flag "Lochloch" wird ausgeführt). Wenn die Größe der komprimierten Seite keine Freigabe von Blöcken zulässt, wird die Seite unverändert in unkomprimierter Form gespeichert. Alle Seitenversätze werden ebenso berücksichtigt wie ohne Komprimierung, indem der Seitenindex mit der Seitengröße multipliziert wird. Es ist keine Selbstverlagerung von Seiten erforderlich. Seitenversätze sowie ohne Komprimierung fallen an die Grenzen von Dateisystemblöcken.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-l/0f/3x/-l0f3xzxozvrxefbiauxdivslv0.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der aktuellen Implementierung kann Ignite nur mit spärlichen Dateien unter Linux arbeiten, sodass die Komprimierung von Festplattenseiten nur aktiviert werden kann, wenn Ignite unter diesem Betriebssystem verwendet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Komprimierungsalgorithmen, die für die Komprimierung von Festplattenseiten verwendet werden können: ZSTD, LZ4, Snappy. </font><font style="vertical-align: inherit;">Darüber hinaus gibt es einen Betriebsmodus (SKIP_GARBAGE), in dem nur eine nicht verwendete Stelle auf der Seite verworfen wird, ohne die verbleibenden Daten zu komprimieren, wodurch die CPU im Vergleich zu den oben aufgeführten Algorithmen entlastet werden kann.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auswirkungen auf die Leistung </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider habe ich die Leistung an realen Ständen nicht gemessen, da wir diesen Mechanismus nicht in der Produktion einsetzen wollen, aber theoretisch können wir spekulieren, wo wir verlieren und wo wir gewinnen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dazu müssen wir uns daran erinnern, wie Seiten beim Zugriff gelesen und geschrieben werden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ein Lesevorgang ausgeführt wird, wird er zuerst im RAM gesucht. Wenn die Suche fehlschlägt, wird die Seite mit demselben Stream, der liest, von der Festplatte in den RAM geladen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie einen Schreibvorgang ausführen, wird die Seite im RAM als fehlerhaft markiert, während das physische Speichern der Seite auf der Festplatte unmittelbar im Stream, der die Aufzeichnung durchführt, nicht erfolgt. </font><font style="vertical-align: inherit;">Alle verschmutzten Seiten werden später im Checkpoint-Prozess in separaten Streams auf der Festplatte gespeichert.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit ist die Auswirkung auf Leseoperationen:</font></font><br>
<br>
<ul>
<li> (disk IO),        .</li>
<li> (CPU),           sparse .       IO       sparse  (    sparse  ,  ,  ).</li>
<li> (CPU),     .</li>
<li>    .</li>
<li>    (    ):</li>
<li> (disk IO),        .</li>
<li> (CPU,  disk IO),     sparse .</li>
<li> (CPU),     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Welche Skala wird überwiegen? </font><font style="vertical-align: inherit;">Es hängt alles stark von der Umgebung ab, aber ich bin geneigt zu glauben, dass die Komprimierung von Festplattenseiten die Leistung auf den meisten Systemen eher beeinträchtigt. </font><font style="vertical-align: inherit;">Darüber hinaus zeigen Tests auf anderen DBMS, die einen ähnlichen Ansatz mit Dateien mit geringer Dichte verwenden, einen Leistungsabfall, wenn die Komprimierung aktiviert ist.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So aktivieren und konfigurieren Sie</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie oben erwähnt, die Mindestversion von Apache Ignite, die die Komprimierung von Festplattenseiten unterstützt: 2.8 und nur das Linux-Betriebssystem. </font><font style="vertical-align: inherit;">Das Einschalten und Einstellen erfolgt wie folgt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Klassenpfad muss über ein Zündkomprimierungsmodul verfügen. </font><font style="vertical-align: inherit;">Standardmäßig befindet es sich in der Apache Ignite-Distribution im Verzeichnis libs / optional und ist nicht im Klassenpfad enthalten. </font><font style="vertical-align: inherit;">Sie können das Verzeichnis einfach um eine Ebene nach oben in die Bibliothek verschieben. Wenn es dann über ignite.sh gestartet wird, wird es automatisch aktiviert.</font></font></li>
<li>Persistence    (  <code>DataRegionConfiguration.setPersistenceEnabled(true))</code>.</li>
<li>         (    <code>DataStorageConfiguration.setPageSize()</code> ).</li>
<li>  ,            ()   ( <code>CacheConfiguration.setDiskPageCompression() , CacheConfiguration.setDiskPageCompressionLevel()</code>).</li>
</ul><br>
<h3>WAL compaction</h3><br>
<h4>  </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist WAL und warum wird es benötigt? Ganz kurz: Dies ist ein Journal, in das alle Ereignisse fallen, die sich aufgrund des Seitenrepositorys ändern. Er wird vor allem für die Möglichkeit einer Genesung im Falle eines Sturzes benötigt. Vor dem Übertragen der Kontrolle an einen Benutzer muss jeder Vorgang das Ereignis zuerst in die WAL schreiben, damit er im Falle eines Sturzes das Protokoll durchspielen und alle Vorgänge wiederherstellen kann, für die der Benutzer eine erfolgreiche Antwort erhalten hat, auch wenn diese Vorgänge keine Zeit hatten, sich im Seitenspeicher auf der Festplatte wiederzugeben (siehe oben) Es wurde beschrieben, dass das eigentliche Schreiben in den Seitenspeicher in einem Prozess ausgeführt wird, der als Prüfpunkt bezeichnet wird (mit einer gewissen Verzögerung in separaten Threads).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einträge in der WAL sind in logische und physische Einträge unterteilt. Logische sind Schlüssel und Werte selbst. Physisch - reflektiert Seitenänderungen im Seitenspeicher. Wenn logische Datensätze in einigen anderen Fällen nützlich sein können, werden physische Datensätze nur für die Wiederherstellung im Falle eines Sturzes benötigt, und Datensätze werden erst ab dem Zeitpunkt des letzten erfolgreichen Prüfpunkts benötigt. Hier werden wir nicht auf Details eingehen und erklären, warum dies so funktioniert, aber jeder Interessierte kann auf den bereits erwähnten Artikel im Apache Ignite Wiki verweisen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ignite Persistent Store - unter der Haube</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein logischer Datensatz enthält häufig mehrere physische Datensätze. Das heißt, ein Cache-Put-Vorgang wirkt sich beispielsweise auf mehrere Seiten im Seitenspeicher aus (eine Seite mit den Daten selbst, Seiten mit Indizes, Seiten mit freien Listen). Bei einigen synthetischen Tests stellte sich heraus, dass die physischen Aufzeichnungen bis zu 90% der WAL-Datei ausmachten. Darüber hinaus benötigen sie eine sehr kurze Zeit (standardmäßig beträgt das Intervall zwischen den Kontrollpunkten 3 Minuten). Es wäre logisch, diese Daten zu entfernen, nachdem sie ihre Relevanz verloren haben. Dies ist genau das, was der WAL-Komprimierungsmechanismus ausführt, physische Datensätze entfernt und die verbleibenden logischen Datensätze mit zip komprimiert, während die Dateigröße sehr stark abnimmt (manchmal zehnmal).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Physikalisch besteht eine WAL aus mehreren Segmenten (Standard 10) mit fester Größe (Standard 64 MB), die in einem Kreis überschrieben werden. </font><font style="vertical-align: inherit;">Sobald das aktuelle Segment gefüllt ist, wird das nächste Segment dem aktuellen Segment zugewiesen und das gefüllte Segment in einem separaten Stream in das Archiv kopiert. </font><font style="vertical-align: inherit;">Die WAL-Komprimierung funktioniert bereits mit Archivsegmenten. </font><font style="vertical-align: inherit;">Außerdem überwacht es in einem separaten Stream die Ausführung des Prüfpunkts und startet die Komprimierung durch Archivsegmente, für die keine physischen Datensätze mehr benötigt werden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zk/95/jo/zk95jo7dnthiox2sv0ezywhrj2a.png"><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auswirkungen auf die Leistung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da die WAL-Komprimierung als separater Thread ausgeführt wird, sollte kein direkter Einfluss auf die ausgeführten Vorgänge bestehen. </font><font style="vertical-align: inherit;">Die CPU (Komprimierung) und die Festplatte (Lesen jedes WAL-Segments aus dem Archiv und Schreiben komprimierter Segmente) werden jedoch zusätzlich im Hintergrund belastet. Wenn das System also an seine Grenzen stößt, führt dies auch zu einer Verschlechterung der Leistung.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So aktivieren und konfigurieren Sie</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können die WAL-Komprimierung mit der Eigenschaft </font></font><code>WalCompactionEnabled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>DataStorageConfiguration (DataStorageConfiguration.setWalCompactionEnabled(true)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">aktivieren </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mithilfe der DataStorageConfiguration.setWalCompactionLevel () -Methode können Sie außerdem das Komprimierungsverhältnis festlegen, wenn Sie mit dem Standardwert (BEST_SPEED) nicht zufrieden sind.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WAL-Seiten-Snapshot-Komprimierung</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie es funktioniert</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben bereits herausgefunden, dass Einträge in WAL in logische und physische Einträge unterteilt sind. Für jede Änderung jeder Seite im Seitenspeicher wird ein physischer WAL-Datensatz generiert. Physische Datensätze sind wiederum in zwei Unterarten unterteilt: Seitenschnappschussdatensatz und Delta-Datensatz. Jedes Mal, wenn wir etwas auf einer Seite ändern und es von einem sauberen in einen schmutzigen Zustand ändern, wird eine vollständige Kopie dieser Seite in der WAL (Page Snapshot Record) gespeichert. Selbst wenn wir nur ein Byte in der WAL geändert haben, wird ein Datensatz mit einer Größe gespeichert, die geringfügig größer als die Seitengröße ist. Wenn wir auf einer bereits verschmutzten Seite etwas ändern, wird in der WAL ein Delta-Datensatz gebildet, der nur die Änderungen gegenüber dem vorherigen Status der Seite widerspiegelt, nicht jedoch die gesamte Seite. Da das Zurücksetzen des Status von Seiten von Dirty auf Clean während des Checkpoint-Vorgangs durchgeführt wird,Unmittelbar nach dem Start des Prüfpunkts bestehen fast alle physischen Datensätze nur aus Schnappschüssen von Seiten (da alle Seiten unmittelbar nach dem Start des Prüfpunkts leer sind). Wenn Sie sich dem nächsten Prüfpunkt nähern, wächst der Anteil des Delta-Datensatzes und wird zu Beginn des nächsten Prüfpunkts erneut zurückgesetzt. Messungen an einigen synthetischen Tests zeigten, dass der Anteil der Seitenschnappschüsse am Gesamtvolumen der physischen Datensätze 90% erreicht.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee hinter der WAL-Seiten-Snapshot-Komprimierung besteht darin, Seiten-Snapshots mit einem handelsüblichen Seitenkomprimierungswerkzeug zu komprimieren (siehe Komprimierung von Festplattenseiten). Gleichzeitig werden Datensätze in WAL nacheinander im Nur-Anhängen-Modus gespeichert, und es besteht keine Notwendigkeit, Datensätze an die Grenzen von Dateisystemblöcken zu binden. Daher benötigen wir hier im Gegensatz zum Komprimierungsmechanismus für Festplattenseiten absolut keine Dateien mit geringer Dichte, sodass dieser Mechanismus nicht nur auf dem Betriebssystem funktioniert Linux Außerdem ist es uns egal, wie stark wir die Seite komprimieren konnten. Selbst wenn wir 1 Byte freigegeben haben, ist dies bereits ein positives Ergebnis und wir können komprimierte Daten in WAL speichern, im Gegensatz zur Komprimierung von Festplattenseiten, bei der eine komprimierte Seite nur gespeichert wird, wenn mehr als 1 Dateisystemblock freigegeben wird.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seiten sind gut komprimierbare Daten, ihr Anteil am gesamten WAL-Volumen ist sehr hoch. Ohne Änderung des Formats der WAL-Datei können wir die Größe erheblich reduzieren. </font><font style="vertical-align: inherit;">Die Komprimierung logischer Datensätze würde unter anderem eine Änderung des Formats und einen Verlust der Kompatibilität erfordern, beispielsweise für externe Verbraucher, die an logischen Datensätzen interessiert sein könnten, ohne die Dateigröße wesentlich zu verringern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für die Komprimierung von Festplattenseiten für die Komprimierung von WAL-Seitenschnappschüssen können die Komprimierungsalgorithmen ZSTD, LZ4, Snappy sowie der Modus SKIP_GARBAGE verwendet werden.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auswirkungen auf die Leistung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist nicht schwer zu bemerken, dass die direkte Einbeziehung der WAL-Seiten-Snapshot-Komprimierung nur die Streams betrifft, die Daten in den Seitenspeicher schreiben, dh die Streams, die die Daten in den Caches ändern. Das Lesen aus physischen WAL-Aufzeichnungen erfolgt nur einmal, zum Zeitpunkt des Anhebens des Knotens nach dem Sturz (und nur im Fall eines Sturzes während des Kontrollpunkts). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies wirkt sich wie folgt auf den Datenfluss aus: Wir erhalten einen negativen Effekt (CPU) aufgrund der Notwendigkeit, die Seite jedes Mal vor dem Schreiben auf die Festplatte zu komprimieren, und einen positiven Effekt (Festplatten-E / A), indem wir die Menge der aufgezeichneten Daten reduzieren. Dementsprechend ist hier alles einfach. Wenn die Systemleistung auf der CPU liegt, kommt es zu einer leichten Verschlechterung. Wenn bei der Festplatten-E / A eine Erhöhung auftritt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Indirekt wirkt sich die Reduzierung der Größe von WALs auch auf (positiv) Streams aus, die WAL-Segmente in das Archiv und die WAL-Komprimierungsströme ablegen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reale Leistungstests in unserer Umgebung mit synthetischen Daten zeigten einen geringen Anstieg (Durchsatz um 10 bis 15% erhöht, Latenz um 10 bis 15% verringert).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So aktivieren und konfigurieren Sie</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Mindestversion von Apache Ignite ist 2.8. </font><font style="vertical-align: inherit;">Das Einschalten und Einstellen erfolgt wie folgt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Klassenpfad muss über ein Zündkomprimierungsmodul verfügen. </font><font style="vertical-align: inherit;">Standardmäßig befindet es sich in der Apache Ignite-Distribution im Verzeichnis libs / optional und ist nicht im Klassenpfad enthalten. </font><font style="vertical-align: inherit;">Sie können das Verzeichnis einfach um eine Ebene nach oben in die Bibliothek verschieben. Wenn es dann über ignite.sh gestartet wird, wird es automatisch aktiviert.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Persistenz muss aktiviert sein (Aktiviert durch </font></font><code>DataRegionConfiguration.setPersistenceEnabled(true)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li>
<li>        <code>DataStorageConfiguration.setWalPageCompression()</code>,     ( DISABLED).</li>
<li>        <code>DataStorageConfiguration.setWalPageCompression()</code>,         javadoc  .</li>
</ul><br>
<h3></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die in Apache Ignite beschriebenen Datenkomprimierungsmechanismen können unabhängig voneinander verwendet werden, aber jede Kombination davon ist auch gültig. </font><font style="vertical-align: inherit;">Das Verständnis der Prinzipien ihrer Arbeit bestimmt, wie sie zu Ihren Aufgaben in Ihrer Umgebung passen und was Sie opfern müssen, wenn Sie sie verwenden. </font><font style="vertical-align: inherit;">Die Komprimierung von Festplattenseiten dient zum Komprimieren des Hauptspeichers und kann eine mittlere Komprimierung ermöglichen. </font><font style="vertical-align: inherit;">Die WAL-Seiten-Snapshot-Komprimierung führt zu einem durchschnittlichen Komprimierungsgrad bereits vorhandener WAL-Dateien, während die Leistung wahrscheinlich sogar verbessert wird. </font><font style="vertical-align: inherit;">Die WAL-Komprimierung wirkt sich nicht positiv auf die Leistung aus, minimiert jedoch die Größe der WAL-Dateien durch Löschen physischer Datensätze.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de502122/index.html">Thanos - Skalierbarer Prometheus</a></li>
<li><a href="../de502124/index.html">2019 Venture-Ergebnisse für die Ukraine</a></li>
<li><a href="../de502126/index.html">So verbessern Sie Ihren Lebenslauf für Englischprogrammierer</a></li>
<li><a href="../de502132/index.html">So übertragen Sie den OpenVZ 6-Container ohne Kopfschmerzen auf den KVM-Server</a></li>
<li><a href="../de502134/index.html">Genug, um Angst vor subjektiv schönen Entscheidungen im Code zu haben - Sie sind keine Roboter</a></li>
<li><a href="../de502146/index.html">Online Roundtable "Ich möchte gamedev"</a></li>
<li><a href="../de502148/index.html">Verwenden von Komponenten von Drittanbietern im Speicher am Beispiel von Qsan</a></li>
<li><a href="../de502150/index.html">Skalieren eines Hochlastnetzwerks mit Nutanix: Funktionen und Herausforderungen anhand eines persönlichen Falls</a></li>
<li><a href="../de502154/index.html">Effektiv Autotests schreiben - Subkutane Tests</a></li>
<li><a href="../de502156/index.html">Rambler gegen NGINX Fall: Kriminelle Risiken der Digitalisierung Roundtable 16. Mai</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>