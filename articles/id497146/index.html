<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â™ï¸ ğŸ¤˜ğŸ¾ ğŸ·ï¸ Kriptografi terapan. Bagaimana kami mengembalikan bitcoin sebesar 300 ribu dolar ğŸ›’ ğŸ´ ğŸ‘‚ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya akan berbagi dengan Anda satu cerita. Sekitar dua puluh tahun yang lalu, saya menerima gelar dalam bidang fisika, tetapi terlibat dalam rekayasa ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kriptografi terapan. Bagaimana kami mengembalikan bitcoin sebesar 300 ribu dolar</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dcmiran/blog/497146/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya akan berbagi dengan Anda satu cerita. Sekitar dua puluh tahun yang lalu, saya menerima gelar dalam bidang fisika, tetapi terlibat dalam rekayasa terbalik dan pembacaan sandi. Perusahaan kami AccessData bekerja pada akhir 90-an dan awal 2000-an. Kemudian pemerintah AS secara bertahap mencabut pembatasan pada ekspor kriptografi, namun, perlindungan kata sandi di sebagian besar program masih agak tidak berguna. Kami mengambil program kantor, saya melakukan reverse engineering dan menemukan algoritma enkripsi, dan kemudian merusak perlindungan kriptografi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu adalah aliran teka-teki matematika yang menarik, tapi tidak terlalu sulit. Sepanjang waktu saya menulis tentang empat puluh cracker kata sandi. Kami menjualnya kepada pengguna rumahan, administrator sistem, dan lembaga penegak hukum lokal dan federal. Saya harus pergi ke pusat pelatihan penegakan hukum federal di Glinko beberapa kali untuk menjelaskan kepada orang-orang dari Secret Service, FBI dan </font></font><abbr title="Biro Alkohol, Tembakau, Senjata Api dan Bahan Peledak"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ATF</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dasar </font><abbr title=" , ,     "><font style="vertical-align: inherit;">-</font></abbr><font style="vertical-align: inherit;"> dasar kriptografi dan bagaimana menggunakan produk kami.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya terutama ingat dua proyek. Yang pertama adalah Microsoft Word 97. Sebelum muncul, file dienkripsi menggunakan XOR byte teks yang jelas dan string 16 byte yang dihasilkan dari kata sandi. Bytes paling umum dalam file Word biasanya 0x00, 0xFF, atau 0x20 (spasi), jadi kami hanya memilih karakter yang paling umum di setiap kolom dan memeriksa 3 hingga </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> opsi. Pemulihan kunci biasanya terjadi secara instan, tetapi agar orang tidak berpikir bahwa mereka telah membuang-buang uang, kami memasukkan animasi kecil yang mirip dengan adegan peretas Hollywood dengan banyak karakter acak, dari mana kata sandi yang benar secara bertahap muncul.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microsoft Word 97 telah mengubah segalanya. Mungkin MSDN juga mengungkapkan format enkripsi, tetapi perusahaan kecil kami tidak mampu berlangganan. Dan bukan fakta bahwa kita akan diizinkan untuk menulis program peretasan setelah menerima informasi. Untuk memahami, dalam SoftICE saya mengatur breakpoint segera setelah memasukkan kata sandi, dan kemudian perlahan-lahan naik tumpukan sampai saya menemukan suatu algoritma. Ini sebelum rilis IDA Pro, jadi saya memiliki lusinan halaman cetakan dengan kode assembler bergaris-garis dengan spidol merah di dinding saya. Saya sangat senang ketika saya akhirnya menemukan jawabannya. Pada saat itu, Microsoft hanya diizinkan mengekspor kriptografi 40-bit, sehingga perusahaan patuh menerapkan kriptografi yang diizinkan secara ketat: mereka berulang kali mengacak kata sandi dalam MD5 menggunakan "garam" (byte yang dipilih secara acak dari file),untuk mendapatkan kunci 40-bit, maka garam ditambahkan ke dalamnya dan hash lagi. Memeriksa kata sandi pada komputer pada waktu itu membutuhkan sekitar setengah detik. Kami harus menggunakan serangan kamus karena hampir tidak mungkin untuk memecahkan kata sandi dengan kekerasan. Akibatnya, kami menulis cracker kata sandi untuk perusahaan dan agensi besar. Program ini mengeksekusi bruteforce dari ruang kunci 40-bit menggunakan instruksi MMX Pentium yang mewah ini. Saya mendengar bahwa dia pernah bekerja selama sembilan bulan sebelum saya mengambil kata sandi.Program ini mengeksekusi bruteforce dari ruang kunci 40-bit menggunakan instruksi MMX Pentium yang mewah ini. Saya mendengar bahwa dia pernah bekerja selama sembilan bulan sebelum saya mengambil kata sandi.Program ini mengeksekusi bruteforce dari ruang kunci 40-bit menggunakan instruksi MMX Pentium yang mewah ini. Saya mendengar bahwa dia pernah bekerja selama sembilan bulan sebelum saya mengambil kata sandi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proyek lain yang sangat menyenangkan adalah arsip zip. Phil Katz, pencipta PKZIP, membuat keputusan yang tidak biasa pada waktu itu untuk mendokumentasikan format file-nya dan memasukkan dokumentasi ini dalam paket perangkat lunak, yang menjadikan ZIP format favorit untuk pengembang. Roger Schlafly mengembangkan stream cipher untuk mengenkripsi arsip. Standar zip dengan cepat menjadi yang paling populer di bawah Windows, dan banyak format lain, seperti file java .jar dan dokumen OpenOffice, sebenarnya file zip dengan struktur direktori tertentu di dalamnya. Versi open source dari program ini disebut InfoZIP, itu adalah dasar dari hampir semua pengarsip zip berpemilik, seperti WinZip. Ketika saya mulai meretas WinZip, ia menguasai 95% pasar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eli Biham dan Paul Kocher menerbitkan deskripsi serangan dengan plaintext yang diketahui (teks sebelum enkripsi), tetapi dalam kasus kami, plaintext yang dikenal </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diarsipkan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Untuk mendapatkan kode Huffman di awal file terkompresi, Anda pada dasarnya membutuhkan seluruh file. Serangan itu praktis tidak berguna untuk penegakan hukum. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zip cipher berisi 96 bit keadaan internal, dibagi menjadi tiga blok 32-bit yang disebut </font></font><code>key0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>key1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan</font></font><code>key2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Yang pertama dan ketiga adalah keadaan internal dua salinan CRC32, register geser linier dengan umpan balik (model matematika sederhana yang memungkinkan Anda untuk membuat urutan pseudorandom). Singkatnya, untuk memperbarui keadaan dengan byte data baru, Anda menggeser semuanya ke bawah dengan satu byte (membuang byte yang lebih rendah), dan kemudian melakukan XOR dengan konstanta dari tabel konversi yang diindeks oleh byte data setelah XOR dengan byte yang lebih rendah. </font></font><code>key1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah keadaan internal generator congruent terpotong terpotong (TLCG). Untuk memperbarui keadaan internalnya, kami menambahkan byte data, dikalikan dengan konstanta, yang akan kami panggil</font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan tambahkan satu. Cipher bekerja sebagai berikut: masukkan byte data dalam CRC32 pertama, lalu ambil byte bawah dan masukkan dalam TLCG, lalu ambil byte atas dari sana dan masukkan dalam CRC32 kedua, kemudian ambil state dan square (kurang-lebih), lalu keluarkan byte kedua menghasilkan aliran byte. Untuk menginisialisasi 96 bit status internal, Anda mulai dengan status dikenal dan mengenkripsi kata sandi, dan kemudian mengenkripsi sepuluh byte garam. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PKZIP mendapatkan byte garamnya, mengalokasikan memori tanpa menginisialisasi, sehingga berisi bit bahan dari program atau gambar yang sedang berjalan, atau dokumen, apa pun. Ini berfungsi dengan baik pada Windows, tetapi pada banyak sistem Unix, memori diinisialisasi secara otomatis ketika dialokasikan. InfoZIP memilih byte garam menggunakan fungsi</font></font><code>rand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahasa C. Dia menginisialisasi keadaan generator angka acak dengan membuat cap waktu XOR pada ID proses, dan kemudian menghasilkan sepuluh byte per file. Dalam hal ini, mengetahui cap waktu dan pengidentifikasi proses, dimungkinkan, secara teoritis, untuk memulihkan byte header, yang, pada gilirannya, memungkinkan untuk melakukan serangan oleh Biham dan Kocher. Tampaknya penulis InfoZIP tahu tentang serangan ini karena mereka melangkah lebih jauh - dan mengenkripsi header menggunakan kata sandi. Dengan demikian, penyerang hanya memiliki dua kali plaintext terenkripsi, dan serangan itu tidak akan berhasil.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya perhatikan ini, karena kata sandi sama di kedua pass, byte pertama dari stream sama di masing-masing pass. Dengan cara yang sama seperti ketika sakelar lampu diaktifkan dua kali, sakelar tetap berada di tempat ia berada di awal, ketika byte diulangi XOR dengan byte stream yang sama, tetap tidak tersentuh. Ini memungkinkan saya untuk mengembangkan serangan yang sangat kuat </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya pada ciphertext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : setelah menerima lima file terenkripsi dalam arsip, saya bisa menampilkan keadaan internal fungsi</font></font><code>rand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tanpa harus melihat cap waktu atau mengetahui proses ID. Lalu saya bisa menghasilkan tajuk tidak terenkripsi asli. Karena hanya beberapa bit di setiap bagian cipher memengaruhi bagian selanjutnya, saya juga bisa menebak beberapa bit status dan memeriksa apakah mendekode byte berikutnya dua kali memberikan jawaban yang saya harapkan. Ketika saya bergerak maju, saya harus menebak semakin sedikit bagian dari kunci itu. Setiap file tambahan juga diizinkan untuk mengecualikan lebih banyak bahan kunci potensial; pada saat itu, butuh beberapa jam di satu desktop. Saya menerbitkan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebuah artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tentang ini dan mendapat kesempatan untuk mempresentasikannya di Jepang pada konferensi Fast Software Encryption 2001.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Segera saya meninggalkan AccessData, bekerja untuk sebuah startup di jaringan saraf selama setahun, menghabiskan tiga tahun belajar untuk gelar master dalam ilmu komputer di Universitas Auckland dengan Chris Kaloud, memulai studi doktoral saya dengan fisikawan matematika John Baez di University of California Riverside, bekerja selama enam tahun Sebagai bagian dari tim Keamanan Terapan Google, ia menyelesaikan doktornya dan beberapa tahun kemudian menjadi CTO dari startup baru.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekitar setengah tahun yang lalu, secara tak terduga saya menerima pesan di LinkedIn dari seorang pria Rusia. Dia membaca artikel yang saya tulis 19 tahun lalu dan ingin tahu apakah serangan itu akan berhasil pada arsip yang hanya berisi dua file. Analisis cepat menunjukkan bahwa itu membutuhkan sejumlah besar daya komputasi dan uang. Karena hanya ada dua file, pada setiap tahap pemilihan ada banyak kesalahan positif. Hasilnya adalah </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.773</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kunci yang mungkin untuk pengujian, hampir 10 sextillion. Saya menghitung bahwa cluster besar pada GPU akan bekerja selama satu tahun, dan biayanya sekitar 100 ribu dolar. Dia memukul saya, mengatakan bahwa dia setuju untuk menghabiskan begitu banyak uang untuk mengembalikan kunci.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faktanya adalah bahwa pada Januari 2016, dia membeli bitcoin sekitar $ 10-15 ribu dan meletakkan kunci dalam file zip terenkripsi. Sekarang harganya lebih dari $ 300 ribu, dan dia tidak bisa mengingat kata sandi. Untungnya, dia masih memiliki laptop asli, dan dia tahu persis waktu enkripsi. Karena InfoZip mengeluarkan entropi berdasarkan stempel waktu, ini berjanji untuk secara signifikan mengurangi jumlah opsi kunci yang mungkin "menjadi hanya" 10 trilyun - dan membuat serangan itu cukup layak dalam beberapa bulan di pertanian GPU rata-rata. Kami menandatangani kontrak dan saya mulai bekerja. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menghabiskan beberapa waktu untuk memulihkan serangan yang dijelaskan dalam artikel. Yang membuatku kecewa, ada beberapa detail rumit yang aku lewatkan dalam artikel itu, tetapi aku menyelesaikannya lagi. Dan kemudian saya menemukan bahwa saya telah membuat kesalahan besar dalam mengevaluasi jumlah perhitungan!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam serangan awal saya, saya menebak byte tinggi dari tombol key1 Â· c, key1 Â· c </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , key1 Â· c </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan key1 Â· c </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pada saat saya menebak byte keempat ini, saya tahu keadaan lengkap dari sisa cipher; Saya hanya perlu mengkonversi empat byte ini ke key1 asli, dan hanya itu. Saya akan pergi ke ruang negara 32-bit untuk key1 dan memeriksa masing-masing untuk melihat apakah itu memberikan byte tinggi yang benar. Namun, di sini harus memeriksa kunci trilyun; jika Anda perlu melakukan 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tes pada masing-masing, itu akan memakan waktu beberapa ratus ribu tahun.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Samar-samar saya ingat bahwa beberapa pekerjaan telah dilakukan pada kriptanalisis TLCG melalui pengurangan basis kisi, jadi saya menggali artikel aslinya. Jadi itu! Itu hanya perlu untuk menentukan kisi-kisi dengan vektor basis yang diberikan oleh </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan tingkat konstan dari TLCG, dan kemudian membuat pengurangan basis kisi. Pada basis dikurangi, saya bisa mengembalikan keadaan asli dari byte tinggi dengan hanya mengalikan matriks.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setidaknya itulah idenya. Butuh lima byte untuk mendapatkan satu-satunya hasil yang benar, dan pada waktu itu saya hanya memiliki empat serangan. Proses yang dijelaskan dalam artikel ini jarang memberikan jawaban yang benar. Namun, saya tahu bahwa jawabannya harus dekat dengan yang benar, sehingga saya bisa membahas semua nilai yang mungkin dari key1 dan memeriksa perbedaan antara jawaban yang nyata dan yang benar. Perbedaannya selalu menjadi salah satu dari 36 vektor! Dengan pengoptimalan ini, saya dapat mengurangi pencarian menjadi hanya 36 opsi, bukan empat miliar. Kami masih dalam bisnis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, kami dihadapkan dengan masalah mentransfer data antara mesin dengan GPU. Mitra bisnis saya, Nash Foster, terlibat dalam implementasi GPU. Dia menasihati saya seberapa cepat berbagai operasi dilakukan, dan menulis sebagian besar struktur pendukung untuk aplikasi dengan kode saya untuk cracking kripto. Bagaimana cara mendapatkan petabyte kunci kandidat ini untuk pengujian GPU? Mereka akan menganggur hampir sepanjang waktu, melemparkan inti mereka untuk mengantisipasi pekerjaan. Terpikir oleh saya bahwa pada setiap tahap serangan saya banyak bit diperiksa, dan kemudian hanya satu dari sekitar 65 ribu kandidat yang diselamatkan. Jika saya bisa menemukan cara </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk output</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bit-bit ini didasarkan pada informasi yang tersedia, dan tidak hanya memaksa mereka, saya akan menghemat banyak pekerjaan dan, yang lebih penting, banyak lalu lintas jaringan. Masalahnya di sini adalah algoritma yang terlalu rumit, mewakili campuran bidang terbatas dengan cincin bilangan bulat, tetapi mereka tidak cocok satu sama lain.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya memikirkan serangan cryptanalytic lain yang saya tahu. Salah satunya adalah serangan "bertemu di tengah". Dia tampak kandidat yang menjanjikan. Serangan diterapkan ke blok cipher ketika ia menggunakan satu bagian dari bahan utama untuk melakukan bagian pertama dari enkripsi, dan bagian lainnya untuk bagian kedua. Ini diterapkan pada cipher zip, tetapi bahan kuncinya jauh melebihi jumlah bit di tengah. Kemudian terpikir oleh saya, bagaimana jika kita menggunakan linearitas CRC32: jika kita melakukan operasi XOR pada dua output CRC32 terakhir, maka hasilnya akan terlepas dari key2! Alih-alih menghitung negara perantara dari cipher dan menyimpannya dalam sebuah tabel, saya akan menghitung XOR dari dua negara perantara dan menyimpannya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menulis pertemuan diferensial "pertemuan di tengah" dan meluncurkannya di laptop saya. Panggung, yang dulunya memakan waktu beberapa jam, sekarang selesai hanya dalam beberapa detik. Tahap selanjutnya, yang bisa memakan waktu seminggu di farm GPU, berakhir dalam beberapa jam pada satu CPU yang kuat. Saya tidak bisa mengoptimalkan serangan tahap ketiga cukup untuk mempengaruhi kecepatan keseluruhan, tetapi tidak perlu untuk memindahkan data sepenuhnya: kami hanya menghitung kandidat untuk setiap GPU di komputer dengan kartu-kartu ini. Nash menulis kode GPU yang bekerja dengan kecepatan luar biasa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Serangan itu berlangsung sepuluh hari dan berakhir dengan kegagalan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hati saya hancur. Apakah kita kehilangan salah satu kunci yang mungkin? Kami kembali dan melihat pengidentifikasi proses maksimum pada laptopnya dan menemukan bahwa itu beberapa bit lebih dari yang kami harapkan, dan karena itu ada sedikit lebih banyak sumber benih yang mungkin untuk </font></font><code>rand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Saya juga memeriksa ulang semua kode kami. Mungkin kita melewatkan sesuatu? Mungkin versi pada CPU bekerja entah bagaimana berbeda dari pada GPU? Akhirnya, saya menemukan bahwa versi pada GPU tidak dapat menemukan kunci yang benar ketika berada di urutan kedua dalam daftar kandidat, tetapi hanya yang pertama. Mengaduk-aduk kode, kami menemukan bahwa kami bingung indeks blok dengan indeks aliran ketika menghitung offset dalam struktur data.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memperbaiki kesalahan, menjalankan kembali kode dan menemukan kunci yang benar dalam sehari. </font><font style="vertical-align: inherit;">Klien kami sangat puas dan memberi kami bonus besar karena menemukan kunci begitu cepat dan menghemat begitu banyak uang di luar perkiraan awal kami. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang saya sedang mencari pekerjaan. </font><font style="vertical-align: inherit;">Jika Anda memiliki masalah yang menarik dengan analisis teknis atau optimasi, beri tahu saya.</font></font><br>
<br>
<hr><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><div style="text-align:center;"><img src="https://habrastorage.org/webt/eo/dx/cq/eodxcqr_jt4-i2h7pybvhg_n7gq.jpeg"></div></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id497132/index.html">Inisiatif #SaveFirst untuk Mendukung Proyek Penting Sosial</a></li>
<li><a href="../id497136/index.html">"Save Concord" atau laporan dari pengujian sistem radar Rusia untuk mencari benda asing di landasan</a></li>
<li><a href="../id497140/index.html">Dekripsi data dalam CAN bus sedan VW Polo</a></li>
<li><a href="../id497142/index.html">Bagaimana kami menambahkan dukungan Harmony OS ke aplikasi Android inDriver</a></li>
<li><a href="../id497144/index.html">Wedge by wedge: penggunaan virus PIV5 untuk membuat vaksin melawan MERS-CoV dan kemungkinan terhadap SARS-CoV-2</a></li>
<li><a href="../id497148/index.html">Membuat aplikasi desktop menggunakan Golang dan Fyne</a></li>
<li><a href="../id497152/index.html">Di mana Product Heart Lives: Metrik untuk Mengukur Kebahagiaan</a></li>
<li><a href="../id497162/index.html">Ebbinghaus curve: cara meretas memori Anda dan mengingat hingga 95% dari informasi</a></li>
<li><a href="../id497164/index.html">Pertama dan kedua puluh lima</a></li>
<li><a href="../id497166/index.html">Upaya untuk memahami multidimensionalitas teori-M</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>