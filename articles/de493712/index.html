<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚟 🤐 👩🏾‍🎤 Neue TypeScript-Funktionen für verbesserte Benutzerfreundlichkeit 🔫 😚 🦎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TypeScript ist in vielerlei Hinsicht nicht mehr wie eine Programmiersprache, sondern ein leistungsstarkes Tool zum Flusen und Dokumentieren von Code, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Neue TypeScript-Funktionen für verbesserte Benutzerfreundlichkeit</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/493712/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScript ist in vielerlei Hinsicht nicht mehr wie eine Programmiersprache, sondern ein leistungsstarkes Tool zum Flusen und Dokumentieren von Code, mit dem Sie bessere JavaScript-Programme schreiben können.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine der bemerkenswertesten Stärken von TypeScript ist die Unterstützung einiger der neuesten Funktionen, die in der ECMAScript-Spezifikation beschrieben sind. Wenn ein Entwickler auf eine neue Version von TypeScript aktualisiert, bedeutet dies, dass er über neue JavaScript-Funktionen verfügt. Darüber hinaus bedeutet die Verwendung dieser Funktionen keine potenziellen Kompatibilitätsprobleme. TypeScript führt nicht nur die neuesten JavaScript-Funktionen ein, sondern zeichnet sich auch dadurch aus, dass die Entwickler der Sprache der TS-Programmierer-Community ständig etwas Neues präsentieren, um die Benutzerfreundlichkeit zu verbessern. Dies umfasst beispielsweise Hilfstools für das Code-Refactoring, Tools zum Umbenennen von Entitäten und zum Auffinden von Stellen, an denen sie in Programmen verwendet werden.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ik/dc/io/ikdcio3bkdkuvgg4h-lplk9lvpm.jpeg"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Material, dessen Übersetzung wir heute veröffentlichen, wird einige interessante neue Funktionen von TypeScript diskutieren. </font><font style="vertical-align: inherit;">Eine vollständige Liste der TypeScript-Innovationen finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unveränderliche Objekte und Arrays</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um unveränderliche Arrays zu erstellen, die während der Kompilierung in Form von normalen Variablen und Funktionsparametern verwendet werden, können Sie in TypeScript Hilfstypen </font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verwenden </font></font><code>ReadonlyArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ihre Verwendung kann jedoch zu einem Gefühl der Heterogenität bei der Typanmerkung führen, insbesondere wenn Arrays </font></font><code>[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach Angabe eines Typs </font><font style="vertical-align: inherit;">mit Zeichen deklariert werden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">TypeScript 3.4 bietet eine neue Möglichkeit, Parameter zu kennzeichnen, die schreibgeschützte Arrays sind. </font><font style="vertical-align: inherit;">Sofort gab es eine neue Möglichkeit, Variablen zu deklarieren, die unveränderlich sein sollten.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbesserung der Benutzerfreundlichkeit mit schreibgeschützten Parametern</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die Parameter von Funktionen deklarieren, mit denen Sie als schreibgeschützte Arrays arbeiten müssen, können Sie jetzt das Schlüsselwort verwenden </font></font><code>readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Im folgenden Beispiel sind die Signaturen der beiden Methoden identisch:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">s: ReadonlyArray&lt;string&gt;</span>) </span>{ <span class="hljs-comment">/* ... */</span> }<font></font>
&nbsp;<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">s: readonly string[]</span>) </span>{ <span class="hljs-comment">/* ... */</span> }
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In beiden Fällen führt jeder Versuch, das Array zu ändern (z. B. mithilfe seiner Methode </font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), zu einem Fehler. </font><font style="vertical-align: inherit;">Diese Innovation macht einen generischen Hilfstyp überflüssig, wodurch der Code leichter zu lesen ist. </font><font style="vertical-align: inherit;">Objekttypen können auch als schreibgeschützte Entitäten gekennzeichnet werden, benötigen jedoch weiterhin einen Hilfstyp </font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbesserung der Verwendbarkeit unveränderlicher Variablen mit dem Konstrukt as const</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Typ einer Variablen, die mit einem Schlüsselwort deklariert wurde, </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann nicht geändert werden. Dieses Konzept existiert in JavaScript. Es wird auch in TypeScript übernommen, um eine strengere Arbeit mit Typen zu organisieren. Bei der Arbeit mit Objektdatentypen wie Objekten oder Arrays stellt sich jedoch heraus, dass solche Strukturen nicht wirklich unveränderlich sind. Die Verwendung eines Schlüsselworts </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedeutet, dass eine bestimmte Instanz eines Objekts oder Arrays beim Arbeiten mit einer Konstanten unverändert bleibt. Der Inhalt dieses Objekts oder Arrays kann jedoch leicht geändert werden. Ohne die Regeln für die Arbeit mit const-Entitäten zu verletzen, können Sie dem Array mithilfe der Methode neue Werte hinzufügen und </font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Werte der Eigenschaften von Objekten ändern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden von </font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und</font></font><code>ReadonlyArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können TypeScript mitteilen, dass das System Entitäten so behandeln soll, als wären sie wirklich unveränderlich. </font><font style="vertical-align: inherit;">Dies bedeutet, dass jedes Mal, wenn im Code versucht wird, eine solche Entität zu ändern, eine Fehlermeldung ausgegeben wird.</font></font><br>
<br>
<pre><code class="javascript hljs">interface Person {&nbsp;
&nbsp;&nbsp;<span class="hljs-attr">name</span>: string;&nbsp;<font></font>
}<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> person = {&nbsp;
&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">'Will'</span>&nbsp;
} <span class="hljs-keyword">as</span> Readonly&lt;Person&gt;;<font></font>
person.name = <span class="hljs-string">'Diana'</span>; <span class="hljs-comment">// !</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In TypeScript 3.4 erschien unter anderem das Konzept der const assertion (Konstante Anweisung), das die Verwendung eines Konstrukts vorsieht </font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist eine vereinfachte Methode zum Deklarieren von Konstanten, die unveränderliche Objekte und Arrays enthalten. </font><font style="vertical-align: inherit;">Solche Deklarationen werden erstellt, indem </font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am Ende der Deklaration eine Konstante </font><font style="vertical-align: inherit;">hinzugefügt wird </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Methode hat einen zusätzlichen Vorteil: Wenn Sie sie verwenden, müssen Sie den Typ in der Anweisung nicht explizit angeben </font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> person = {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">'Will'</span>&nbsp;
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<font></font>
&nbsp;<font></font>
person.name = <span class="hljs-string">'Diana'</span>; <span class="hljs-comment">// !</span><font></font>
&nbsp;<font></font>
<span class="hljs-comment">//      as const</span>
<span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;&nbsp;<font></font>
array.push(<span class="hljs-number">4</span>); <span class="hljs-comment">// !</span>
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hilfstyp Auslassen</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In TypeScript gibt es mehrere Hilfstypen, mit denen vorhandene Typen einfach neuen zugeordnet oder ein Typ basierend auf anderen Typen bedingt festgelegt werden kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dem Hilfstyp </font></font><code>Partial</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">können alle Eigenschaften des Objekts als optional markiert werden. </font><font style="vertical-align: inherit;">Wie sich herausstellte, habe ich vor der Veröffentlichung von TypeScript 3.5 in meinen Projekten ständig einen interessanten Mechanismus verwendet. </font><font style="vertical-align: inherit;">Dies ist das gleiche, was die Verwendung des Hilfstyps jetzt ermöglicht </font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mit diesem Typ können Sie, wie der Name schon sagt, etwas von anderen Typen ausschließen. </font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akzeptiert den Typ und die Kombination von Schlüsseln und gibt dann einen neuen Typ zurück, von dem die durch die Schlüssel beschriebenen Eigenschaften ausgeschlossen sind. </font><font style="vertical-align: inherit;">Vorbei sind die Zeiten, in denen ich </font></font><code>Pick</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es </font></font><code>Exclude</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für die unabhängige Implementierung von Funktionen verwenden musste</font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     TypeScript 3.5</span><font></font>
type Omit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;<font></font>
&nbsp;<font></font>
interface A {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propA?: string;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propB?: string;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propC?: string;&nbsp;<font></font>
}<font></font>
&nbsp;<font></font>
type B = Omit&lt;A, <span class="hljs-string">'propA'</span> | <span class="hljs-string">'propC'</span>&gt;;&nbsp;
<span class="hljs-keyword">const</span> b: B = { <span class="hljs-attr">propA</span>: <span class="hljs-string">'hi'</span> }; <span class="hljs-comment">// ;</span>
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neue JavaScript-Funktionen, die von TypeScript unterstützt werden</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Vorschläge für neue JavaScript-Funktionen die 4. Koordinierungsstufe erreichen, werden sie als Teil der nächsten Version der Sprache betrachtet. </font><font style="vertical-align: inherit;">Dies bedeutet jedoch nicht, dass solche Funktionen sofort in JavaScript verwendet werden können, da ihre Unterstützung in geeigneten Umgebungen implementiert werden sollte. </font><font style="vertical-align: inherit;">Die Anwendung sollte Zugriff auf solche Möglichkeiten haben, wo immer ihr normaler Betrieb angenommen wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Unterstützung für neue JavaScript-Funktionen wird dem TypeScript-Compiler regelmäßig hinzugefügt. </font><font style="vertical-align: inherit;">In der Regel kann Code, der diese Funktionen implementiert, in JavaScript-Code konvertiert werden, der mit allen Browsern kompatibel ist, die das in angegebene Projekterstellungsziel unterstützen </font></font><code>tsconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Auf null und undefiniert prüfen</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript-Entwickler sind mit dem Konzept von Wahrheit und Falschheit vertraut. Wenn für die Wahrheit Überprüfung kann 6 Werte identifiziert werden, die immer falsch sind: </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>«»</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>NaN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und, natürlich, </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In den meisten Fällen muss der Entwickler nur herausfinden, ob der Wert wahr oder falsch ist. In einigen Fällen müssen Sie jedoch nur herausfinden, ob der untersuchte Wert ein realer Wert ist </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Zum Beispiel, wenn zwischen Code unterschieden werden muss </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ||     ,  index  0</span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index || <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 1 &lt;-- </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code funktioniert, indem er </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf den Wert gesetzt </font><font style="vertical-align: inherit;">wird, </font><font style="vertical-align: inherit;">auf den geschrieben wird </font></font><code>index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, in allen Fällen, außer wenn der Wert </font></font><code>index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gleich ist </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Damit dieser Code in jeder Situation ordnungsgemäß funktioniert, muss er mithilfe eines komplexeren Testschemas neu geschrieben werden, um den tatsächlichen Werttyp zu ermitteln.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   ,    </span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index !== <span class="hljs-literal">null</span> &amp;&amp; index !== <span class="hljs-literal">undefined</span> ? : <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 0</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt funktioniert der Code, erfordert jedoch die Verwendung komplexerer Überprüfungen. </font><font style="vertical-align: inherit;">Der neue Operator zum Überprüfen des Werts auf </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(es sieht aus wie zwei Fragezeichen - </font></font><code>??</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) vereinfacht solche Überprüfungen, indem er den Wert im linken Teil zurückgibt, wenn er nicht gleich </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ist </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Andernfalls wird zurückgegeben, was sich auf der rechten Seite befindet.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// !</span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index ?? <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 0</span>
getValueOrOne(<span class="hljs-number">2</span>); <span class="hljs-comment">// 2</span>
getValueOrOne(); <span class="hljs-comment">// 1</span>
</code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Optionale Sequenzen</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine weitere neue JavaScript-Funktion in TypeScript 3.7 ist der Operator zum Organisieren optionaler Sequenzen ( </font></font><code>?.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Ich habe einen solchen Operator zum ersten Mal in der Programmiersprache Groovy getroffen. Seitdem wollte ich, dass es auch in JavaScript angezeigt wird. Mit diesem Operator können Sie den Zugriff auf die eingebetteten Eigenschaften von Objekten organisieren, ohne deren Existenz ständig überprüfen zu müssen. Wenn dieser Operator beim Zugriff auf eine Eigenschaft auf einen Wert stößt </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, gibt er diesen Wert einfach zurück, ohne einen Fehler auszulösen </font></font><code>TypeError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> value = foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz;<font></font>
&nbsp;<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> value = foo?.bar?.baz;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der optionale Sequenzoperator kombiniert mit dem Operator zum Überprüfen der Werte </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bietet dem Entwickler noch mehr Möglichkeiten, um beispielsweise entweder den Wert einer verschachtelten Eigenschaft des Objekts oder, falls eine solche Eigenschaft nicht vorhanden ist, einen Standardwert in die Variable zu schreiben. </font><font style="vertical-align: inherit;">So sieht es aus:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> value = foo?.bar?.baz ?? <span class="hljs-string">'default value'</span>;
</code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Private Klassenfelder</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScript hat seit dem Aufkommen dieser Sprache ein eigenes Konzept von privaten Klassenfeldern, die mit einem Zugriffsmodifikator deklariert wurden </font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dieses Konzept erschien in TypeScript, noch bevor Klassen im ECMAScript-Standard beschrieben wurden. In TypeScript bezieht sich dieses Konzept jedoch auf die Mechanismen, die während der Codekompilierung funktionieren. Der Compiler gibt einen Fehler aus, wenn auf das private Feld der Klasse nicht über die eigenen Methoden der Klasse zugegriffen wird. In JavaScript besteht jetzt die Möglichkeit, private Eigenschaften und Methoden einer Klasse zu deklarieren. Diese Funktion unterscheidet sich jedoch sowohl semantisch als auch syntaktisch von der in TypeScript noch vorhandenen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Private Felder in JavaScript werden nicht mit einem Zugriffsmodifikator deklariert </font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Stattdessen werden sie deklariert, indem am Anfang ihres Namens ein Symbol eingefügt wird </font></font><code>#</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fan</span> </span>{&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;#on = <span class="hljs-literal">false</span>;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;private name = <span class="hljs-string">'fan'</span>;<font></font>
&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;turnOn() {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.#on = <span class="hljs-literal">true</span>;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;isTurnedOn() {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.#on;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> fan = <span class="hljs-keyword">new</span> Fan();&nbsp;<font></font>
fan.isTurnedOn(); <span class="hljs-comment">// false&nbsp;&nbsp;</span><font></font>
fan.turnOn();&nbsp;<font></font>
fan.isTurnedOn(); <span class="hljs-comment">// true</span><font></font>
&nbsp;<font></font>
fan.on; <span class="hljs-comment">//  </span>
fan.#on; <span class="hljs-comment">// </span>
fan.name; <span class="hljs-comment">//   ,    JS</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript unterstützt jetzt private Felder. Der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorschlag</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für private Methoden befindet sich in der dritten Genehmigungsphase. </font><font style="vertical-align: inherit;">Derzeit können der Modifikator </font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und das Zeichen </font></font><code>#</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Feldnamen nicht zusammen verwendet werden. </font><font style="vertical-align: inherit;">Beide Ansätze können sich während der Entwicklung als nützlich erweisen. Welche Sie wählen müssen, hängt vom Programmierer ab. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Podcast, in dem die neue Syntax zum Deklarieren privater Felder erläutert wird.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍Verwenden Sie das Schlüsselwort await auf der obersten Codeebene</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Asynchrone Programmiermechanismen erweitern die Funktionen von JavaScript und TypeScript erheblich. In diesem Bereich tauchten zunächst Versprechen auf - ein Design </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit dem Sie saubereren asynchronen Code schreiben können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einer der Fälle, in denen Versprechen verwendet werden und nicht, </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist ein asynchroner Methodenaufruf außerhalb der asynchronen Funktion. Zum Beispiel auf der obersten Ebene des Modul- oder Anwendungscodes. Um dieses Problem zu umgehen, können Sie vorschlagen, einen asynchronen, sofort aufgerufenen Funktionsausdruck (IIFE, sofort aufgerufener Funktionsausdruck) zu erstellen und asynchronen Code in einem solchen Ausdruck auszuführen.</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-keyword">async</span> () =&gt; {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/users/sitepen'</span>);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Check out the blog at <span class="hljs-subst">${data.blog}</span>`</span>);&nbsp;<font></font>
})();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScript unterstützt jetzt die Fähigkeit von JavaScript, Schlüsselwörter </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf der obersten Codeebene zu verwenden. </font><font style="vertical-align: inherit;">Dies bedeutet, dass await außerhalb der mit dem Schlüsselwort deklarierten Funktionen verwendet werden kann </font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist sehr gut beim Schreiben von kompaktem und klarem Code. </font><font style="vertical-align: inherit;">Die Ausdrücke </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf der obersten Ebene des Codes werden zwar dafür kritisiert, dass sie das Laden von Modulen verlangsamen und eine Situation schaffen können, in der ein bestimmtes Modul das Laden der gesamten Anwendung verlangsamen kann, da das System auf den Abschluss des asynchronen Vorgangs warten und dann den gesamten Code des Moduls ausführen muss.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/users/sitepen'</span>);&nbsp;
<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> { ...data };
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweiterte TypeScript-Experimentierumgebung</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies kann nicht als neue TypeScript-Funktion bezeichnet werden. Da es sich jedoch um TypeScript als Tool handelt, kann </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScript Playground</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als effektives Tool zum schnellen Überprüfen von TypeScript-Konstrukten und zum Anzeigen des JavaScript-Codes bezeichnet werden, in den diese Konstrukte umgewandelt werden. </font><font style="vertical-align: inherit;">Die meisten Beispiele hier wurden speziell in TypeScript Playground getestet. </font><font style="vertical-align: inherit;">Diese Umgebung unterstützt jetzt die Möglichkeit, eine bestimmte Version von TypeScript auszuwählen (einschließlich der Unterstützung von Beta-Versionen). </font><font style="vertical-align: inherit;">Es enthält mehrere Beispiele, die Anfängern den Einstieg in TypeScript erleichtern.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassung</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScript ist ein Tool, mit dem Sie besseren und aussagekräftigeren JavaScript-Code schreiben können. </font><font style="vertical-align: inherit;">Mit den TypeScript-Hilfstools können komplexe Aufgaben wie das Umgestalten und Umbenennen von Entitäten, die in gewöhnlichem JavaScript viel komplizierter sind, auf einfache Weise gelöst werden. </font><font style="vertical-align: inherit;">TypeScript führt ständig neue Mechanismen wie </font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ein </font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In der Sprache kann man eine kontinuierliche Verbesserung der Unterstützung komplexer Typen beobachten. </font><font style="vertical-align: inherit;">TypeScript implementiert schnell die neuesten JavaScript-Funktionen. </font><font style="vertical-align: inherit;">Aus diesem Grund entscheiden sich viele Menschen für TypeScript und nehmen es als Werkzeug, Sprache und Ökosystem wahr. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Liebe Leser! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welche neuen TypeScript-Funktionen finden Sie am interessantesten?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de493700/index.html">Verwenden von Malware in Azure, um Zugriff auf Microsoft 365-Mandanten zu erhalten</a></li>
<li><a href="../de493702/index.html">Massiver Übergang zur Fernarbeit: technische Probleme und Sicherheitsbedrohungen</a></li>
<li><a href="../de493704/index.html">Verwenden von TypeScript in JavaScript ohne Schreiben von TypeScript</a></li>
<li><a href="../de493706/index.html">Kennen Sie Ihren Feind: Erstellen Sie eine Node.js-Hintertür</a></li>
<li><a href="../de493708/index.html">Anatomie meines Heimat-Kubernetes-Clusters</a></li>
<li><a href="../de493714/index.html">Sicherheits-Spickzettel: Nodejs</a></li>
<li><a href="../de493716/index.html">Typinferenz mit TypeScript unter Verwendung des Konstrukts as const und des Schlüsselworts infer</a></li>
<li><a href="../de493718/index.html">Diskussion: Standard-UNIX-Dienstprogramme, die nur wenige verwendet haben und derzeit verwenden</a></li>
<li><a href="../de493720/index.html">Der perfekte Sturm: Wie Technologie die Food-Service-Branche verändert</a></li>
<li><a href="../de493724/index.html">RPA | Prozessrobotisierung mit den Augen eines Analysten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>