<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚾️ 📱 ❎ ブレーキとの戦争。React Nativeでのコンポーネントレンダリング数の最適化 👙 ◾️ 👆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！私の名前はKamo Spertsyanです。Profi.ruでReact Native開発に従事しています。React Nativeテクノロジーを使用して製品の機能を迅速に提供し、開発速度に重点を置くと決めた場合、パフォーマンスの問題が発生する可能性があります。少なくともそれが私...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ブレーキとの戦争。React Nativeでのコンポーネントレンダリング数の最適化</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492390/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、ハブル！私の名前はKamo Spertsyanです。Profi.ruでReact Native開発に従事しています。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React Nativeテクノロジー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">使用し</font></a><font style="vertical-align: inherit;">て製品の機能を迅速に提供し、開発速度に重点を置くと</font><font style="vertical-align: inherit;">決めた場合</font><font style="vertical-align: inherit;">、パフォーマンスの問題が発生する可能性があります。少なくともそれが私たちに起こったことです。 6か月間の活発な開発の後、アプリケーションのパフォーマンスはクリティカルレベルを下回りました-すべてが非常に遅くなりました。したがって、最適化を採用しました。起動時のすべての「ブレーキ」、画面間の遷移、画面のレンダリング、ユーザーアクションへの反応を削除しました。その結果、3か月でユーザーエクスペリエンスがネイティブレベルに戻りました。この記事では、React Nativeでアプリケーションを最適化し、複数のコンポーネントのレンダリングの問題を解決した方法についてお話します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tv/qy/9b/tvqy9bo_jyqc4cz044_gneepvmw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントの無意味な再描画の数を最小限に抑えるのに役立つ推奨事項をまとめました。</font><font style="vertical-align: inherit;">明確にするために、例では「悪い」実装と「良い」実装を比較しています。</font><font style="vertical-align: inherit;">この記事は、すでにアプリケーションのパフォーマンスの低下に直面している人や、将来的にこれを許可したくない人に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reduxと組み合わせたReact Nativeを使用します。</font><font style="vertical-align: inherit;">ヒントのいくつかは、このライブラリに関連しています。</font><font style="vertical-align: inherit;">また、この例では、Redux-thunkライブラリを使用して、ネットワークでの作業をシミュレートしています。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンスについていつ考えるか</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、アプリケーションの作業の最初から覚えておく価値があります。ただし、アプリケーションの速度が既に低下している場合-絶望しないでください。すべてを修正できます。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰もが知っていることですが、念のため、弱いデバイスでのパフォーマンスを確認することをお勧めします。強力なデバイスで開発している場合、エンドユーザーの「ブレーキ」に気付かない可能性があります。あなたが案内されるデバイスを自分で決めてください。</font><font style="vertical-align: inherit;">最適化後の結果と比較するために、制御プロットの</font><font style="vertical-align: inherit;">時間または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">測定</font><font style="vertical-align: inherit;">します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
React Nativeをそのまま使用すると、FPSアプリケーションをDeveloper Tools→Show perf monitorで測定できます。</font><font style="vertical-align: inherit;">基準値は60フレーム/秒です。</font><font style="vertical-align: inherit;">このインジケーターが低いほど、アプリケーションは「スローダウン」します。ユーザーのアクションに応答しないか、遅延して応答します。</font><font style="vertical-align: inherit;">FPSへの主な影響の1つはレンダリングの数であり、その「重大度」はコンポーネントの複雑さに依存します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">説明の例</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ニュースのリストを使用して、シンプルなアプリケーションの例に関するすべての推奨事項を示します。</font><font style="vertical-align: inherit;">アプリケーションには</font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ニュースと一緒に</font><font style="vertical-align: inherit;">配置さ</font><font style="vertical-align: inherit;">れた</font><font style="vertical-align: inherit;">1つの画面があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ニュースアイテムは</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、見出し（</font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）と本文（</font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">の2つの小さな</font><font style="vertical-align: inherit;">コンポーネント</font><font style="vertical-align: inherit;">で構成される</font><font style="vertical-align: inherit;">コンポーネント</font><font style="vertical-align: inherit;">です</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">全体の例は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で見ることができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">さらに、特定の例については、リポジトリのさまざまなブランチへのリンクがあります。</font><font style="vertical-align: inherit;">リポジトリは、例をより深く探求したい読者の便宜のために使用されます。</font><font style="vertical-align: inherit;">リポジトリ内のコードと以下の例は、完全であると主張するものではありません-デモ目的でのみ必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下では、すべてのコンポーネントがリンクと小道具とともに概略的に示されています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d9/ng/z6/d9ngz6hldmphbkjky1a-7-38nlq.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各コンポーネントのrenderメソッドで、そのコンポーネントに関する固有の情報の出力をコンソールに追加しました。 </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_{no}<font></font>
ITEM_TITLE_{no}<font></font>
ITEM_BODY_{no}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここ</font></font><code>{no}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で、ニュースのシリアル番号は、同じニュースの複数のレンダリングと異なるニュースのレンダリングを区別するためのものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各</font></font><code>refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニュースリストで</font><font style="vertical-align: inherit;">テストするために</font><font style="vertical-align: inherit;">、追加のニュースが最初に追加されます。</font><font style="vertical-align: inherit;">同時に、次のメッセージがコンソールに表示されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">--------------[ REFRESHING ]--------------</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのレコードは、特定のコンポーネントに問題があるかどうかを理解し、後でそれを最適化することが可能であったかどうかを判断するのに役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正しく実装されている場合、起動後のログといくつかの更新は次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_4<font></font>
ITEM_TITLE_4<font></font>
ITEM_BODY_4</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の起動時に、画面自体と2つの初期ニュースが描画されます。</font><font style="vertical-align: inherit;">ボードを更新すると、データが実際に変更されたため、画面が再度レンダリングされます。</font><font style="vertical-align: inherit;">より多くのニュースが表示されます。</font><font style="vertical-align: inherit;">データに変更がなかったため、以前のニュースはすべて再描画されません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネントはいつレンダリングされますか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ReactおよびReact Nativeでは、コンポーネントをレンダリングするための2つの条件があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼の小道具/状態を変更し、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">親コンポーネントのレンダリング。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数はコンポーネントで再定義できます。関数</font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は新しい小道具と状態を入力として受け取り、コンポーネントをレンダリングする必要があるかどうかを通知します。多くの場合、不要な再レンダリングを回避するには、</font><font style="vertical-align: inherit;">PropsオブジェクトとStateオブジェクトの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浅い比較</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で十分です。たとえば、これは、子コンポーネントに影響を与えない場合に、親コンポーネントが変更されたときに不要なレンダリングを排除します。毎回手動でサーフェス比較を記述しないようにするために、</font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このチェックをカプセル化</font><font style="vertical-align: inherit;">するコンポーネントを継承できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コネクトリンク機能を使用すると、Reduxライブラリはグローバル状態に「接続」される新しいコンポーネントを作成します。この状態への変更はメソッドをトリガーします</font></font><code>mapStateToProps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい小道具を返します。</font><font style="vertical-align: inherit;">次に、コンポーネントが宣言されているかどうかに関係なく、新旧の小道具の比較が始まり</font></font><code>PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、これらのニュアンスを考慮してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我々はなり</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ましょう</font><font style="vertical-align: inherit;">部品</font><font style="vertical-align: inherit;">を通過</font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">継承を</font></font><code>React.Component</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、および</font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-から</font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全なサンプルコード</font></font></a><br>
<br>
<pre><code class="plaintext hljs">export class NewsItemTitle extends React.Component<font></font>
export class NewsItemBody extends React.PureComponent</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つのボードの更新後のログは次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ニュースと見出しのコンポーネントが再描画されていることがわかります。</font><font style="vertical-align: inherit;">それらを順番に検討します。</font></font><br>
<br>
<code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して宣言されてい</font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">小道具として、このコンポーネントは識別子を受け取ります。これにより、その後にニュースを受け取り</font></font><code>mapStateToProps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="plaintext hljs">const mapStateToProps = (state, ownProps) =&gt; ({<font></font>
  item: state.newsMap[ownProps.itemKey],<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ボードを更新すると、すべてのニュースが再度ダウンロードされるため、オブジェクトが</font></font><code>item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更新され、その後、さまざまなメモリセルが参照されます。つまり、含まれているすべてのフィールドが同じであっても、それらは異なるオブジェクトになります。したがって、以前と新しいState'ovコンポーネントの比較はを返します</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。実際にはデータが変更されていないにもかかわらず、コンポーネントは再レンダリングされます。</font></font><br>
<br>
<code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はから継承</font></font><code>React.Component</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">されるため、親コンポーネントがレンダリングされるたびに再レンダリングされます。これは、新旧の小道具の値に関係なく発生します。</font></font><br>
<br>
<code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から継承されている</font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、新旧の小道具を比較します。ニュース1と2では、それらの値は同等であるため、コンポーネントはニュース3 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
に対して</font><font style="vertical-align: inherit;">のみレンダリングされます。</font><font style="vertical-align: inherit;">レンダリングを最適化するには</font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として宣言してください</font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">の場合</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、関数を再定義する</font><font style="vertical-align: inherit;">必要が</font><font style="vertical-align: inherit;">あります</font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="plaintext hljs">shouldComponentUpdate(nextProps) {<font></font>
  return !shallowEqual(this.props.item, nextProps.item);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全なコード例は、</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ここで</font></font><code>shallowEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reduxのが提供するオブジェクトの表面の比較のための機能です。</font><font style="vertical-align: inherit;">次のように書くことができます：</font></font><br>
<br>
<pre><code class="plaintext hljs">shouldComponentUpdate(nextProps) {<font></font>
  return (<font></font>
    this.props.item.title !== nextProps.item.title ||<font></font>
    this.props.item.body !== nextProps.item.body<font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この後のログは次のようになります。 </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意</font></font></b><div class="spoiler_text"> <code>shouldComponentUpdate</code>  <code>NewsItem</code> ,  <code>NewsItemTitle</code>   .        . <code>NewsItemTitle</code>    -         <code>NewsItem</code>,     .<br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React.memoと機能コンポーネント</font></font></h2><br><font style="vertical-align: inherit;"></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能コンポーネントで</font><font style="vertical-align: inherit;">
オーバーライド</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">ことは</font><font style="vertical-align: inherit;">できません。</font><font style="vertical-align: inherit;">ただし、これは、機能コンポーネントを最適化するために、コンポーネントをクラス1に書き直す必要があるという意味ではありません。</font><font style="vertical-align: inherit;">そのような場合のために、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React.memo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモ化機能が</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">提供されてい</font></a><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">コンポーネント入力とオプションの比較関数を受け入れます</font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">呼び出されると、</font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新旧の小道具が取得さ</font><font style="vertical-align: inherit;">れ、</font><font style="vertical-align: inherit;">比較の結果が返されます。</font><font style="vertical-align: inherit;">プロップが等しい場合に</font><font style="vertical-align: inherit;">返す必要</font><font style="vertical-align: inherit;">がある</font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もの</font><font style="vertical-align: inherit;">との違い</font><font style="vertical-align: inherit;">、およびその逆。</font><font style="vertical-align: inherit;">
たとえば、</font><font style="vertical-align: inherit;">メモは次のようになります。</font></font><code>areEqual</code><font style="vertical-align: inherit;"></font><code>true</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="plaintext hljs">areEqual(prevProps, nextProps) {<font></font>
  return shallowEqual(prevProps, nextProps);<font></font>
}<font></font>
export OptimizedNewsItemTitle = React.memo(NewsItemTitle, areEqual)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは合格しない場合</font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font></font><code>React.memo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、小道具の表面的な比較が行われますので、私たちの例を簡略化することができます。</font></font><br>
<br>
<pre><code class="plaintext hljs">export OptimizedNewsItemTitle = React.memo(NewsItemTitle)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小道具のラムダ関数</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントイベントを処理するために、関数を小道具に渡すことができます。</font><font style="vertical-align: inherit;">最も顕著な例は実装</font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">多くの場合、匿名のラムダ関数がこれに使用されます。</font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレビューのみを表示したい</font><font style="vertical-align: inherit;">とし</font><font style="vertical-align: inherit;">ます。プレビューをクリックすると、テキスト全体が表示されます。</font><font style="vertical-align: inherit;">レンダリング時にこれを行うには、</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、</font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我々は以下の小道具を渡します。</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;NewsItemBody<font></font>
  ...<font></font>
  onPress={() =&gt; this.props.expandBody()}<font></font>
  ...<font></font>
/&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッド</font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">削除された</font><font style="vertical-align: inherit;">場合、この実装でのログは次のようになります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ニュース体1と2は、そのデータが変更されていないものの、レンダリングされているが、</font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あります</font></font><code>PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、レンダリングごと</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に小道具</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">値が</font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しく作成されるためです。</font><font style="vertical-align: inherit;">技術的に</font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、レンダリングするたびに、メモリ内の新しい領域を指すため、小道具の表面的な比較で</font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はfalse </font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">返されます。</font><font style="vertical-align: inherit;">この問題は、次のエントリによって修正されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;NewsItemBody<font></font>
  ...<font></font>
  onPress={this.props.expandBody}<font></font>
  ...<font></font>
/&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ログ： </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全なコード例</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
残念ながら、無名関数は、そのようなレコードのメソッドまたはクラスフィールドとして常に書き換えられるとは限りません。最も一般的なケースは、ラムダ関数内で、それが宣言されている関数のスコープ変数が使用される場合です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例でこのケースを考えます。総合一覧から1つのニュースの画面に切り替えるために、ニュースの本文をクリックする処理を追加します。</font></font><code>renderItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネント</font><font style="vertical-align: inherit;">メソッド</font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">const renderItem = ({item}) =&gt; (<font></font>
  &lt;NewsItem<font></font>
    itemKey={item}<font></font>
    onBodyPress={() =&gt; this.onItemBodyPress(item)}<font></font>
  /&gt;<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のニュースに移動するために必要な</font></font><code>onBodyPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数</font></font><code>item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">スコープから消えるため、クラスでは</font><font style="vertical-align: inherit;">
匿名関数</font><font style="vertical-align: inherit;">を宣言できません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題の最も簡単な解決策は、</font></font><code>onBodyPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネント</font><font style="vertical-align: inherit;">プロップのシグネチャを変更</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して、呼び出されたときに必要なパラメーターが関数に渡されるようにすることです。</font><font style="vertical-align: inherit;">この場合、これはニュースIDです。</font></font><br>
<br>
<pre><code class="plaintext hljs">const renderItem = ({item}) =&gt; (<font></font>
  &lt;NewsItem<font></font>
    itemKey={item}<font></font>
    onBodyPress={item =&gt; this.onItemBodyPress(item)}<font></font>
  /&gt;<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、コンポーネントクラスメソッドで無名関数を既に取り出すことができます。</font></font><br>
<br>
<pre><code class="plaintext hljs">const renderItem = ({item}) =&gt; (<font></font>
  &lt;NewsItem<font></font>
    itemKey={item}<font></font>
    onBodyPress={this.onItemBodyPress}<font></font>
  /&gt;<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、このようなソリューションでは、コンポーネントを変更する必要があります</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">class NewsItemComponent extends React.Component {<font></font>
render() {<font></font>
  ...<font></font>
  return (<font></font>
      ...<font></font>
      &lt;NewsItemBody<font></font>
        ...<font></font>
        onPress={() =&gt; this.props.onBodyPress(this.props.item)}<font></font>
        ...<font></font>
      /&gt;<font></font>
      ...<font></font>
  );<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして再び、示された問題に戻ります-親のレンダリングごとに新しいラムダ関数を子コンポーネントに渡します。</font><font style="vertical-align: inherit;">ようやくレベルが下がりました。</font><font style="vertical-align: inherit;">ログ：</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ルートでこの問題を取り除くには、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">useCallback</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フックを使用できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">引数を渡して関数呼び出しをメモすることができます。</font><font style="vertical-align: inherit;">関数の引数が変更されない場合、呼び出しの結果</font></font><code>useCallback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はメモリの同じ領域を指します。</font><font style="vertical-align: inherit;">この例では、同じニュースを再描画しても、prop </font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネント</font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は変更されません。</font><font style="vertical-align: inherit;">フックは機能コンポーネントでのみ使用できるため、コンポーネントの最終的な外観は</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">function NewsItemComponent(props) {<font></font>
  ...<font></font>
  const {itemKey, onBodyPress} = props.item;<font></font>
  const onPressBody = useCallback(() =&gt; onBodyPress(itemKey), [itemKey, onBodyPress]);<font></font>
  return (<font></font>
    &lt;View&gt;<font></font>
      ...<font></font>
      &lt;NewsItemBody<font></font>
        ...<font></font>
        onPress={onPressBody}<font></font>
        ...<font></font>
      /&gt;<font></font>
    &lt;/View&gt;<font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてログ： </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全なサンプルコード</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列とオブジェクト</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptでは、関数は配列とともにオブジェクトとして表されます。</font><font style="vertical-align: inherit;">したがって、前のブロックの例は、propsで新しいオブジェクトを作成する特殊なケースです。</font><font style="vertical-align: inherit;">これは非常に一般的であるため、別の段落で説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロップで新しい関数、配列、またはオブジェクトを作成すると、コンポーネントが再レンダーされます。</font><font style="vertical-align: inherit;">次の例でこのルールを検討してください。</font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つの値を組み合わせたスタイルで</font><font style="vertical-align: inherit;">渡し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;NewsItemBody<font></font>
  ...<font></font>
  style={[styles.body, styles.item]}<font></font>
  ...<font></font>
/&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、ログには追加のコンポーネントレンダラーが表示されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するには、結合します別のスタイルを選択することができます</font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、</font></font><code>item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あるいは、例えば、配列の宣言を移動する</font></font><code>[styles.body, styles.item]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバル変数に。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全なサンプルコード</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アレイレデューサー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用に関連する「ブレーキ」の別の一般的なソースを検討してください</font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">サーバーからのアイテムの長いリストを含む古典的なアプリケーションは、ページネーションを実装します。</font><font style="vertical-align: inherit;">つまり、限られた要素のセットを最初のページの形式でロードし、現在の要素のリストが終了すると、次のページをロードします。</font><font style="vertical-align: inherit;">アイテムリストのレデューサーは次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">const newsIdList = (state = [], action) =&gt; {<font></font>
  if (action.type === 'GOT_NEWS') {<font></font>
    return action.news.map(item =&gt; item.key);<font></font>
  } else if (action.type === 'GOT_OLDER_NEWS') {<font></font>
    return [...state, ...action.news.map(item =&gt; item.key)];<font></font>
  }<font></font>
  return state;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の各ページがアプリケーションのスタイルで読み込まれると、識別子の新しい配列が作成されます。</font><font style="vertical-align: inherit;">この配列を後でpropsに渡すと</font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、コンポーネントのレンダリングログは次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
ITEM_&lt;1..20&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..20&gt;<font></font>
ITEM_&lt;1..30&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、テストアプリケーションにいくつかの変更を加えました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ページサイズを10ニュースに設定します。</font></font></li>
<li>   <code>item</code>   <code>NewsItem</code>  <code>FlatList</code>-,        connect. <code>NewsItem</code>    <code>React.Component</code>    .</li>
<li>     .</li>
<li>       .       №1     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例では、次の各ページが読み込まれると、すべての古い要素が再びレンダリングされ、次に古い要素と新しいページの要素が再びレンダリングされることが示されています。数学愛好家向け：ページサイズが等しい</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、</font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i番目のページが</font><font style="vertical-align: inherit;">読み込まれると、</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい要素</font><font style="vertical-align: inherit;">だけがレンダリング</font><font style="vertical-align: inherit;">されるのでは</font><font style="vertical-align: inherit;">なく</font><font style="vertical-align: inherit;">、要素がレンダリングされます</font></font><code>(i - 1) * X + i * X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「わかりました」とあなたは言います。「新しいページを追加した後にすべての要素が描画される理由がわかります。リデューサーは新しい配列、新しいメモリ領域などを返しました。しかし、なぜ新しい要素を追加する前に古いリストをレンダリングする必要があるのですか？」 「いい質問」とお答えします。これは、コンポーネントの状態に</font></font><code>VirtualizedList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基づい</font><font style="vertical-align: inherit;">て作業した結果です</font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">彼らは別の記事を引き出すので、私は詳細には触れません。</font><font style="vertical-align: inherit;">気になる人は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とソース</font><font style="vertical-align: inherit;">を詳しく調べることをお勧めします</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような非最適性を取り除く方法は？</font><font style="vertical-align: inherit;">リデューサーを書き換えて、ページごとに新しい配列を返さないようにしますが、既存の配列に要素を追加します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意！</font><font style="vertical-align: inherit;">アンチパターン！</font></font></b><div class="spoiler_text">          .     ,    , ,  <code>PureComponent</code>,          .      ,             .      .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"> Redux</a>.<br>
</div></div><br>
<pre><code class="plaintext hljs">const newsIdList = (state = [], action) =&gt; {<font></font>
  if (action.type === 'GOT_NEWS') {<font></font>
    return action.news.map(item =&gt; item.key);<font></font>
  } else if (action.type === 'GOT_OLDER_NEWS') {<font></font>
    action.news.forEach(item =&gt; state.push(item.key));<font></font>
    return state;<font></font>
    // return [...state, ...action.news.map(item =&gt; item.key)];<font></font>
  }<font></font>
  return state;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、ログは次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..20&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..30&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいページに要素を追加する</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
、古い要素のレンダリングを</font><font style="vertical-align: inherit;">削除しましたが</font><font style="vertical-align: inherit;">、リストを更新した</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">後</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も古い要素が描画され</font><font style="vertical-align: inherit;">ます。次のページのレンダリングの数が等しくなりました</font></font><code>i * X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。計算式は簡単になりましたが、ここで止めることはしません。</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい要素</font><font style="vertical-align: inherit;">だけがあり</font><font style="vertical-align: inherit;">、</font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいレンダリング</font><font style="vertical-align: inherit;">だけが必要</font><font style="vertical-align: inherit;">です。すでにおなじみのトリックを使用して、小道具を変更していないニュースレンダーを削除します。戻り接続</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;11..20&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;21..30&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いいね！今、私たちは自分自身に満足することができます。最適化する場所はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全なコード例</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
注意深い読者は、</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ログ</font><font style="vertical-align: inherit;">への接続を適用した後</font><font style="vertical-align: inherit;">、リデューサーの実装方法に関係なく、最後の例のようになることを示します。そして、それは正しいでしょう-レンダリングする前にニュースコンポーネントが小道具をチェックする場合、古い配列がレデューサーによって使用されているか、それが新しいものを作成するかは問題ではありません。新しい要素のみが描画され、一度だけ描画されます。ただし、新しい配列を作成する代わりに古い配列を変更することで、</font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用されて</font><font style="vertical-align: inherit;">いるコンポーネントの不必要なレンダリング</font></font><code>VirtualizedList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や、propsの等価チェックの不必要な繰り返しから解放されます</font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。要素の数が多いと、パフォーマンスも向上します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レデューサーで可変配列とオブジェクトを使用する場合は、細心の注意が必要です。</font><font style="vertical-align: inherit;">この例ではこれは正当化されていますが、たとえばnormal </font></font><code>PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がある場合、要素を可変配列に追加すると、コンポーネントはレンダリングされません。</font><font style="vertical-align: inherit;">配列の更新前と更新後は同じメモリ領域を指しているため、実際にはその小道具は変更されていません。</font><font style="vertical-align: inherit;">これにより、予期しない結果が生じる可能性があります。</font><font style="vertical-align: inherit;">説明されている例が</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">原則に</font></a><font style="vertical-align: inherit;">違反して</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">いるのも当然</font></a><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、何か他のもの...</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレゼンテーションレベルのライブラリを使用する場合は、それらがどのように実装されているかを詳細に理解することをお勧めします。</font><font style="vertical-align: inherit;">このアプリケーションでは</font></font><code>Swipeable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ライブラリの</font><font style="vertical-align: inherit;">コンポーネントを使用</font><font style="vertical-align: inherit;">しています</font></font><code>react-native-gesture-handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">リストからカードをスワイプするときに、追加のアクションのブロックを実装できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードでは、次のようになります。</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;Swipeable<font></font>
  ...<font></font>
  renderRightActions={this.renderRightActions}<font></font>
  ...<font></font>
&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッド、</font></font><code>renderRightActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>renderLeftActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スワイプ後に表示されるコンポーネントを返します。必要なコンテンツに合わせるために、コンポーネントの変更中にパネルの高さを決定して変更しました。これはリソースを大量に消費するプロセスですが、スワイプアニメーション中に発生した場合、ユーザーには干渉がありません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/wz/n1/vg/wzn1vghiy6-wjclqcy8itdy1fns.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は</font><font style="vertical-align: inherit;">、メインコンポーネントのレンダリング時に</font><font style="vertical-align: inherit;">コンポーネント</font></font><code>Swipeable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がメソッド</font></font><code>renderRightActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">呼び出すこと</font><font style="vertical-align: inherit;">です。すべての計算と、スワイプ前には表示されないアクションバーのレンダリングさえ、事前に発生します。したがって、これらのアクションはすべて、リスト内のすべてのカードに対して同時に実行されます。これにより、ボードをスクロールするときに大きな「ブレーキ」がかかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題は以下の方法で解決されました。アクションパネルがメインコンポーネントと一緒に描画され、スワイプの結果ではない場合、メソッド</font></font><code>renderRightActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メインコンポーネントのサイズを</font><font style="vertical-align: inherit;">空に返し</font><font style="vertical-align: inherit;">ます。それ以外の場合は、以前のように追加のアクションのパネルを描画します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サポートライブラリが期待どおりに機能するとは限らないため、この例を示します。</font><font style="vertical-align: inherit;">これらがプレゼンテーションレベルのライブラリである場合は、不要なリソースを浪費していないことを確認することをお勧めします。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事で説明した問題を解消した後、React Nativeでのアプリケーションを大幅に高速化しました。</font><font style="vertical-align: inherit;">現在では、ネイティブに実装された同様のパフォーマンスと区別することは困難です。</font><font style="vertical-align: inherit;">過剰なレンダリングは、個々の画面の読み込みとユーザーアクションへの反応の両方を遅くしました。</font><font style="vertical-align: inherit;">何よりも、それは数十のコンポーネントが一度に描画されるリストで顕著でした。</font><font style="vertical-align: inherit;">すべてを最適化したわけではありませんが、アプリケーションのメイン画面が遅くなることはなくなりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の要点を以下に簡単に示します。</font></font><br>
<br>
<ol>
<li> React Native      :  Props/State-     .</li>
<li>,   <code>React.PureComponent</code>,     ,       .</li>
<li>    ,    <code>shouldComponentUpdate</code>      <code>React.Memo</code>   .</li>
<li>-        .      ,         (shallow compare).               ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレゼンテーションレベルのライブラリをサポートすると、リソースが予期せず浪費される可能性があります。</font><font style="vertical-align: inherit;">それらのアプリケーションでは注意する価値があります。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで全部です。</font><font style="vertical-align: inherit;">この情報がお役に立てば幸いです。</font><font style="vertical-align: inherit;">私はどんなフィードバックでも喜んでいます！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有用な情報源</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React + Reduxでのレンダリングについて</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScriptでのオブジェクトの比較</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React.memo（）を使用してReact機能コンポーネントのパフォーマンスを向上させる</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DiscordがReact NativeでネイティブiOSパフォーマンスを実現する方法</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja492374/index.html">実験：OOPの世界からのRedux</a></li>
<li><a href="../ja492376/index.html">記事やドキュメントをすばやく正確に理解させる方法</a></li>
<li><a href="../ja492378/index.html">Reactjs、JSSを使用したMaterial-UI。ショートガイド</a></li>
<li><a href="../ja492384/index.html">ハックザボックス-郵便配達員ウォークスルー RedisとWebMin</a></li>
<li><a href="../ja492386/index.html">IT部門が世界の食料消費を減らす方法</a></li>
<li><a href="../ja492392/index.html">IntelliJ IDEAのヒントとコツ：3.各フォルダーのコードスタイルのカスタマイズ</a></li>
<li><a href="../ja492394/index.html">暗い宇宙。パート2</a></li>
<li><a href="../ja492396/index.html">なぜインジケーターLEDを台無しにしたのか、何を変更する必要があるのか</a></li>
<li><a href="../ja492398/index.html">デバイスをリモート作業、ポッドキャスティング、ビデオ、ストリーミング用に構成します</a></li>
<li><a href="../ja492404/index.html">Flutter + Arduino nano 33 BLEセンス=非常にシンプルなBLEセンサー</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>