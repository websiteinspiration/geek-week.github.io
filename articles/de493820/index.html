<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∫ üöè üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë© Kubernetes Load Balancing und Skalierung langlebiger Verbindungen üë©üèª‚Äç‚úàÔ∏è ‚èèÔ∏è üëèüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel hilft Ihnen zu verstehen, wie der Lastausgleich in Kubernetes funktioniert, was beim Skalieren langlebiger Verbindungen passiert und wa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kubernetes Load Balancing und Skalierung langlebiger Verbindungen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/493820/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/445/275/8af/4452758afb53f8b3161ace47d8c6ea49.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel hilft Ihnen zu verstehen, wie der Lastausgleich in Kubernetes funktioniert, was beim Skalieren langlebiger Verbindungen passiert und warum Sie den Ausgleich auf der Clientseite in Betracht ziehen sollten, wenn Sie HTTP / 2, gRPC, RSockets, AMQP oder andere langlebige Protokolle verwenden.&nbsp;</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein bisschen dar√ºber, wie der Verkehr in Kubernetes umverteilt wird&nbsp;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes bietet zwei praktische Abstraktionen f√ºr die Einf√ºhrung von Anwendungen: Dienste und Bereitstellungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bereitstellungen beschreiben, wie und wie viele Kopien Ihrer Anwendung zu einem bestimmten Zeitpunkt ausgef√ºhrt werden sollen. </font><font style="vertical-align: inherit;">Jede Anwendung wird wie unter (Pod) bereitgestellt und erh√§lt eine IP-Adresse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Feature-Services √§hneln einem Load Balancer. </font><font style="vertical-align: inherit;">Sie sind so konzipiert, dass sie den Verkehr auf mehrere Herde verteilen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mal sehen, wie es aussieht</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der folgenden Abbildung sehen Sie drei Instanzen derselben Anwendung und einen Load Balancer:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80f/58d/4f9/80f58d4f9cd1e34a88aa7b8a33c0a82f.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Load Balancer hei√üt Service, ihm wird eine IP-Adresse zugewiesen. </font><font style="vertical-align: inherit;">Jede eingehende Anfrage wird an einen der Pods umgeleitet:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63e/7ef/b73/63e7efb73e75ce67fcd47f74b03aa04d.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Bereitstellungsskript bestimmt die Anzahl der Anwendungsinstanzen. </font><font style="vertical-align: inherit;">Sie m√ºssen fast nie direkt unter bereitstellen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/121/8c3/a961218c382f2343f72bdcf639f20222.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedem Pod wird eine eigene IP-Adresse zugewiesen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c0/699/ef3/3c0699ef3d5a60d5b08f7afdfdedac29.png"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist n√ºtzlich, Dienste als eine Reihe von IP-Adressen zu betrachten. </font><font style="vertical-align: inherit;">Bei jedem Zugriff auf den Dienst wird eine der IP-Adressen aus der Liste ausgew√§hlt und als Zieladresse verwendet. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist wie folgt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine Curl-Anfrage 10.96.45.152 an den Service:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60a/52c/539/60a52c539ed6d1791cbafa794db2c4a9.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Dienst w√§hlt eine der drei Pod-Adressen als Ziel aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a8/ac4/e23/2a8ac4e23e79da06ee64c01e071b9089.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Datenverkehr wird zu einem bestimmten Pod umgeleitet:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/f2c/38e/7ecf2c38ef0af62d07d169c120ca5def.png"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihre Anwendung aus einem Frontend und einem Backend besteht, verf√ºgen Sie jeweils √ºber einen Service und eine Bereitstellung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Frontend die Anforderung an das Backend erf√ºllt, muss es nicht genau wissen, wie viele Herde das Backend bedient: Es kann einen, zehn oder einhundert geben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au√üerdem wei√ü das Frontend nichts √ºber die Adressen der Herde, die das Backend bedienen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Frontend eine Anfrage an das Backend sendet, verwendet es die IP-Adresse des Backend-Dienstes, die sich nicht √§ndert. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So sieht es aus</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter 1 fordert die interne Backend-Komponente an. </font><font style="vertical-align: inherit;">Anstatt eine bestimmte f√ºr das Backend auszuw√§hlen, wird eine Serviceanforderung ausgef√ºhrt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ff/50c/a99/1ff50ca9970854efe8af15ac2a7d1791.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Dienst w√§hlt einen der Backend-Pods als Zieladresse aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/dd9/9ad/530dd99add6451742a891d69ef06d03b.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Verkehr geht von Herd 1 zu Herd 5, der vom Dienst ausgew√§hlt wurde:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ea/bdb/808/2eabdb8086fefc2c48d171f3c0e2c87e.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter 1 wei√ü es nicht genau, wie viele solcher Herde wie unter 5 hinter dem Dienst versteckt sind:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/665/f5e/edc/665f5eedc580d007fd9db6ced40f86d1.png"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber wie genau verteilt der Dienst Anfragen? </font><font style="vertical-align: inherit;">Scheint Round-Robin-Balancing verwendet zu werden? </font><font style="vertical-align: inherit;">Lass es uns richtig machen.&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Balancing in Kubernetes Services</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes-Dienste existieren nicht. Es gibt keinen Prozess f√ºr den Dienst, dem eine IP-Adresse und ein Port zugewiesen wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen dies √ºberpr√ºfen, indem Sie zu einem beliebigen Knoten im Cluster gehen und den Befehl netstat -ntlp ausf√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen nicht einmal die dem Dienst zugewiesene IP-Adresse finden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die IP-Adresse des Dienstes befindet sich in der Steuerungsschicht, im Controller und wird in der Datenbank - etcd. Dieselbe Adresse wird von einer anderen Komponente verwendet - kube-proxy. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kube-Proxy empf√§ngt eine Liste von IP-Adressen f√ºr alle Dienste und bildet eine Reihe von Iptables-Regeln f√ºr jeden Knoten des Clusters. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Regeln lauten: "Wenn die IP-Adresse des Dienstes angezeigt wird, m√ºssen wir die Zieladresse der Anforderung √§ndern und an einen der Pods senden."</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die IP-Adresse des Dienstes wird nur als Einstiegspunkt verwendet und von keinem Prozess bedient, der diese IP-Adresse und diesen Port abh√∂rt. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns das an</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .&nbsp;</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich einen Cluster aus drei Knoten vor. </font><font style="vertical-align: inherit;">Auf jedem Knoten befinden sich Pods:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/605/ed6/e82/605ed6e82d24139c7122fd0886fb3f5f.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strickherde in Beige sind Teil des Service. </font><font style="vertical-align: inherit;">Da der Dienst nicht als Prozess vorhanden ist, ist er ausgegraut:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/175/57b/919/17557b91988036bf15bdb5fd02b25c44.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste fragt nach dem Service und sollte auf einen der zugeh√∂rigen Herde fallen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13d/49c/2df/13d49c2dff1c5a15bfced3347ad4bc6c.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber der Dienst existiert nicht, es gibt keinen Prozess. </font><font style="vertical-align: inherit;">Wie funktioniert es?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7e/362/c43/a7e362c43d31ac5ba0368cbbfceae398.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor die Anforderung den Knoten verl√§sst, durchl√§uft sie die iptables-Regeln:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29d/eea/0ef/29deea0efafef803b87c66a7c17cc9cc.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die iptables-Regeln wissen, dass kein Dienst vorhanden ist, und ersetzen die IP-Adresse durch eine der IP-Adressen der diesem Dienst zugeordneten Pods:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4e/ec6/0ad/a4eec60ad28fbf16b085d9b8697dce81.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anfrage erh√§lt eine g√ºltige IP-Adresse als Zieladresse und wird normalerweise verarbeitet:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/653/ef7/4b8/653ef74b8f34567652c2e0a00c89d9a7.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abh√§ngig von der Netzwerktopologie erreicht die Anforderung schlie√ülich den Herd:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/696/c59/873/696c5987341d20780825ff2a4f6f7d12.png"></div></li>
</ol><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K√∂nnen iptables die Last ausgleichen?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nein, iptables werden zum Filtern verwendet und wurden nicht zum Ausgleichen entwickelt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist jedoch m√∂glich, eine Reihe von Regeln zu schreiben, die wie ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pseudo-Balancer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funktionieren </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und genau das macht Kubernetes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie drei Pods haben, schreibt kube-proxy die folgenden Regeln:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hlen Sie die erste mit einer Wahrscheinlichkeit von 33%, andernfalls fahren Sie mit der n√§chsten Regel fort.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hlen Sie die zweite mit einer Wahrscheinlichkeit von 50%, andernfalls fahren Sie mit der n√§chsten Regel fort.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hlen Sie die dritte unter.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein solches System f√ºhrt dazu, dass jedes Sub mit einer Wahrscheinlichkeit von 33% ausgew√§hlt wird.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08e/d59/2bc/08ed592bc03dd1f9740f29985451aaca.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt keine Garantie daf√ºr, dass unter 2 die n√§chste Datei nach Datei 1 ausgew√§hlt wird. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : iptables verwendet ein statistisches Modul f√ºr die zuf√§llige Verteilung. </font><font style="vertical-align: inherit;">Somit basiert der Ausgleichsalgorithmus auf einer zuf√§lligen Auswahl. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem Sie nun verstanden haben, wie Services funktionieren, schauen wir uns interessantere Arbeitsszenarien an.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langlebige Verbindungen in Kubernetes werden standardm√§√üig nicht skaliert</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede HTTP-Anforderung vom Front-End zum Back-End wird von einer separaten TCP-Verbindung bedient, die ge√∂ffnet und geschlossen wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Frontend 100 Anforderungen pro Sekunde an das Backend sendet, werden 100 verschiedene TCP-Verbindungen ge√∂ffnet und geschlossen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen die Verarbeitungszeit der Anforderung reduzieren und die Last verringern, wenn Sie eine TCP-Verbindung √∂ffnen und f√ºr alle nachfolgenden HTTP-Anforderungen verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das HTTP-Protokoll enth√§lt eine Funktion namens HTTP Keep-Alive oder Wiederverwendung der Verbindung. In diesem Fall wird eine TCP-Verbindung zum Senden und Empfangen vieler HTTP-Anforderungen und -Antworten verwendet:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a65/cef/c9f/a65cefc9f558265089c48cdf96a1d049.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktion ist standardm√§√üig nicht aktiviert: Sowohl der Server als auch der Client m√ºssen entsprechend konfiguriert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Setup selbst ist f√ºr die meisten Programmiersprachen und -umgebungen einfach und zug√§nglich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier einige Links zu Beispielen in verschiedenen Sprachen:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://medium.com/%40onufrienkos/keep-alive-connection-on-inter-service-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Node.js am Leben bleiben</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.baeldung.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Fr√ºhlingsstiefel am Leben bleiben</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://blog.insightdatascience.com/learning-about-the-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Python am Leben bleiben</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://docs.microsoft.com/en-us/dotnet/api/system.net."><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In .NET am Leben bleiben</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert, wenn wir Keep-Alive in Kubernetes verwenden? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, dass sowohl die Frontend- als auch die Backend-Unterst√ºtzung am Leben bleiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben eine Kopie des Frontends und drei Kopien des Backends. Das Frontend stellt die erste Anfrage und √∂ffnet eine TCP-Verbindung zum Backend. Die Anfrage erreicht den Dienst, einer der Backend-Pods wird als Zieladresse ausgew√§hlt. Es sendet eine Antwort an das Backend und das Frontend empf√§ngt sie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Gegensatz zur √ºblichen Situation wird die TCP-Verbindung, wenn sie nach dem Empfang der Antwort geschlossen wird, jetzt f√ºr die folgenden HTTP-Anforderungen ge√∂ffnet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert, wenn das Frontend mehr Backend-Anfragen sendet? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese Anforderungen weiterzuleiten, wird eine offene TCP-Verbindung verwendet. Alle Anforderungen werden an dieselbe im Backend gesendet, wo die erste Anforderung eingegangen ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sollten iptables den Verkehr nicht umverteilen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nicht in diesem Fall. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn eine TCP-Verbindung erstellt wird, werden die iptables-Regeln durchlaufen, die eine bestimmte f√ºr das Backend ausw√§hlen, in das der Datenverkehr geleitet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da alle folgenden Anforderungen √ºber eine bereits offene TCP-Verbindung ausgef√ºhrt werden, werden iptables-Regeln nicht mehr aufgerufen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mal sehen, wie es aussieht</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das erste Sub sendet eine Anfrage an den Dienst:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d1/235/11b/0d123511bd0e4e5d3806fdd7917e0bd7.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie wissen bereits, was als n√§chstes passieren wird. </font><font style="vertical-align: inherit;">Der Dienst existiert nicht, aber es gibt iptables-Regeln, die die Anforderung verarbeiten:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d1/235/11b/0d123511bd0e4e5d3806fdd7917e0bd7.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einer der Backend-Pods wird als Zieladresse ausgew√§hlt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ae/5c0/e5b/9ae5c0e5bd3478f20d1546951a298dfd.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anfrage erreicht den Herd. </font><font style="vertical-align: inherit;">Zu diesem Zeitpunkt wird eine permanente TCP-Verbindung zwischen den beiden Pods hergestellt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b23/154/129/b23154129408fd401651880d3b94d816.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede n√§chste Anfrage vom ersten Pod geht √ºber eine bereits hergestellte Verbindung:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/e1c/232/f90e1c232dbc399d39aaff47045b9aa8.gif"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen haben Sie eine schnellere Antwort und eine h√∂here Bandbreite erhalten, aber die F√§higkeit zur Skalierung des Backends verloren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst wenn Sie zwei Pods im Backend mit einer konstanten Verbindung haben, wird der Datenverkehr immer zu einem von ihnen geleitet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kann das behoben werden? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da Kubernetes nicht wei√ü, wie dauerhafte Verbindungen ausgeglichen werden k√∂nnen, liegt diese Aufgabe in Ihrer Verantwortung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dienste sind eine Reihe von IP-Adressen und Ports, die als Endpunkte bezeichnet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ihre Anwendung kann eine Liste der Endpunkte vom Dienst abrufen und entscheiden, wie Anforderungen zwischen ihnen verteilt werden sollen. Sie k√∂nnen mit Round-Robin eine dauerhafte Verbindung zu jedem Herd herstellen und Anforderungen zwischen diesen Verbindungen ausgleichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oder wenden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ausgefeiltere Ausgleichsalgorithmen an</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der clientseitige Code, der f√ºr den Ausgleich verantwortlich ist, sollte dieser Logik folgen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rufen Sie die Liste der Endpunkte vom Dienst ab.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ñffnen Sie f√ºr jeden Endpunkt eine dauerhafte Verbindung.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie eine Anfrage stellen m√ºssen, verwenden Sie eine der offenen Verbindungen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisieren Sie regelm√§√üig die Liste der Endpunkte, erstellen Sie neue oder schlie√üen Sie alte dauerhafte Verbindungen, wenn sich die Liste √§ndert.</font></font></li>
</ol><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So wird es aussehen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt die erste Anforderung an den Dienst zu senden, k√∂nnen Sie Anforderungen auf der Clientseite ausgleichen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98f/91a/0c9/98f91a0c9ecae76bd8f286ba3a282ff1.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie m√ºssen Code schreiben, der fragt, welche Pods Teil des Dienstes sind:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/040/203/cb5/040203cb52d6b22bb8179a6870d2485f.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobald Sie die Liste erhalten haben, speichern Sie sie auf der Clientseite und stellen Sie damit eine Verbindung zu den Pods her:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e5/741/3e7/4e57413e7b01b017cf57fab312b28089.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie selbst sind f√ºr den Lastausgleichsalgorithmus verantwortlich:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/bc6/7ad/8d9bc67ad511790b477c8509c91fffb0.gif"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Frage ist nun: Gilt dieses Problem nur f√ºr HTTP Keep-Alive?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clientseitiger Lastausgleich</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTP ist nicht das einzige Protokoll, das dauerhafte TCP-Verbindungen verwenden kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihre Anwendung eine Datenbank verwendet, wird die TCP-Verbindung nicht jedes Mal ge√∂ffnet, wenn Sie eine Anforderung ausf√ºhren oder ein Dokument aus der Datenbank abrufen m√ºssen.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stattdessen wird eine permanente TCP-Verbindung zur Datenbank ge√∂ffnet und verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihre Datenbank in Kubernetes bereitgestellt wird und der Zugriff als Dienst bereitgestellt wird, treten dieselben Probleme wie im vorherigen Abschnitt beschrieben auf. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Datenbankreplikat wird mehr als der Rest geladen. </font><font style="vertical-align: inherit;">Kube-Proxy und Kubernetes helfen nicht, Verbindungen auszugleichen. </font><font style="vertical-align: inherit;">Sie sollten sich darum k√ºmmern, Abfragen in Ihrer Datenbank auszugleichen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je nachdem, mit welcher Bibliothek Sie eine Verbindung zur Datenbank herstellen, stehen Ihnen m√∂glicherweise verschiedene Optionen zur L√∂sung dieses Problems zur Verf√ºgung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das folgende Beispiel zeigt den Zugriff auf einen MySQL-Datenbankcluster von Node.js aus:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mysql'</span>);
<span class="hljs-keyword">var</span> poolCluster = mysql.createPoolCluster();<font></font>
<font></font>
<span class="hljs-keyword">var</span> endpoints = <span class="hljs-comment">/* retrieve endpoints from the Service */</span><font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> [index, endpoint] <span class="hljs-keyword">of</span> endpoints) {<font></font>
&nbsp; poolCluster.add(<span class="hljs-string">`mysql-replica-<span class="hljs-subst">${index}</span>`</span>, endpoint);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Make queries to the clustered MySQL database</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt unz√§hlige andere Protokolle, die dauerhafte TCP-Verbindungen verwenden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WebSockets und gesicherte WebSockets</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gRPC</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RSockets</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMQP</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie sollten bereits mit den meisten dieser Protokolle vertraut sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber wenn diese Protokolle so beliebt sind, warum gibt es keine standardisierte Ausgleichsl√∂sung? Warum ist eine √Ñnderung der Clientlogik erforderlich? Gibt es eine native Kubernetes-L√∂sung? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kube-Proxy und iptables dienen zum Schlie√üen der meisten Standardbereitstellungsszenarien f√ºr Kubernetes. Dies dient der Bequemlichkeit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie einen Webdienst verwenden, der eine REST-API bereitstellt, haben Sie Gl√ºck. In diesem Fall werden keine permanenten TCP-Verbindungen verwendet. Sie k√∂nnen einen beliebigen Kubernetes-Dienst verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobald Sie jedoch dauerhafte TCP-Verbindungen verwenden, m√ºssen Sie herausfinden, wie Sie die Last gleichm√§√üig auf die Backends verteilen k√∂nnen. Kubernetes enth√§lt f√ºr diesen Fall keine vorgefertigten L√∂sungen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nat√ºrlich gibt es Optionen, die helfen k√∂nnen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausgleich langlebiger Verbindungen in Kubernetes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes bietet vier Arten von Diensten an:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clusterip</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NodePort</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lastenausgleicher</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kopflos</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten drei Dienste basieren auf der virtuellen IP-Adresse, die vom kube-proxy zum Erstellen von iptables-Regeln verwendet wird. </font><font style="vertical-align: inherit;">Die grundlegende Grundlage aller Dienste ist jedoch ein kopfloser Dienst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dem kopflosen Dienst ist keine IP-Adresse zugeordnet, und er bietet nur einen Mechanismus zum Abrufen einer Liste von IP-Adressen und Ports der zugeordneten Herde (Endpunkte). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Dienste basieren auf dem kopflosen Dienst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der ClusterIP-Dienst ist ein kopfloser Dienst mit einigen Erg√§nzungen:&nbsp;</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwaltungsschicht weist ihr eine IP-Adresse zu.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kube-Proxy bildet die notwendigen iptables-Regeln.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise k√∂nnen Sie kube-proxy ignorieren und die Liste der vom kopflosen Dienst empfangenen Endpunkte direkt verwenden, um die Last in Ihrer Anwendung auszugleichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber wie kann man allen in einem Cluster bereitgestellten Anwendungen eine √§hnliche Logik hinzuf√ºgen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihre Anwendung bereits bereitgestellt ist, scheint eine solche Aufgabe unm√∂glich zu sein. </font><font style="vertical-align: inherit;">Es gibt jedoch eine Alternative.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Service Mesh wird Ihnen helfen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie haben wahrscheinlich bereits bemerkt, dass die clientseitige Lastausgleichsstrategie Standard ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Anwendung gestartet wird, gilt Folgendes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruft eine Liste der IP-Adressen vom Dienst ab.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ñffnet und verwaltet einen Verbindungspool.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisiert den Pool regelm√§√üig und f√ºgt Endpunkte hinzu oder entfernt sie.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobald die Anwendung eine Anfrage stellen m√∂chte, gilt Folgendes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hlt eine verf√ºgbare Verbindung unter Verwendung einer Logik aus (z. B. Round-Robin).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erf√ºllt die Anfrage.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Schritte funktionieren f√ºr WebSockets, gRPC und AMQP. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen diese Logik in eine separate Bibliothek aufteilen und in Ihren Anwendungen verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stattdessen k√∂nnen jedoch Service-Grids wie Istio oder Linkerd verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Service Mesh erg√§nzt Ihre Anwendung mit einem Prozess, der:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sucht automatisch nach IP-Adressen von Diensten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberpr√ºft Verbindungen wie WebSockets und gRPC.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleicht Anforderungen mit dem richtigen Protokoll aus.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Service Mesh hilft bei der Verwaltung des Datenverkehrs innerhalb des Clusters, ist jedoch recht ressourcenintensiv. </font><font style="vertical-align: inherit;">Andere Optionen verwenden Bibliotheken von Drittanbietern wie Netflix Ribbon oder programmierbare Proxys wie Envoy.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was passiert, wenn Sie Ausgleichsprobleme ignorieren?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen den Lastausgleich nicht verwenden und bemerken keine √Ñnderungen. Schauen wir uns einige Arbeitsszenarien an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie mehr Clients als Server haben, ist dies kein so gro√ües Problem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, es gibt f√ºnf Clients, die eine Verbindung zu zwei Servern herstellen. Auch wenn kein Ausgleich besteht, werden beide Server verwendet:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3eb/2a3/ebf/3eb2a3ebfd09862d4200744170daec7e.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verbindungen k√∂nnen ungleich verteilt sein: M√∂glicherweise sind vier Clients mit demselben Server verbunden, aber es besteht eine gute Chance, dass beide Server verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Problematischer ist das umgekehrte Szenario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie weniger Clients und mehr Server haben, werden Ihre Ressourcen m√∂glicherweise nicht ausreichend genutzt und es tritt ein potenzieller Engpass auf. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, es gibt zwei Clients und f√ºnf Server. </font><font style="vertical-align: inherit;">Bestenfalls gibt es zwei permanente Verbindungen zu zwei von f√ºnf Servern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Andere Server sind inaktiv:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee5/0d2/eaf/ee50d2eaf1dbefd5933dd9ec5221bd58.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn diese beiden Server die Verarbeitung von Clientanforderungen nicht verarbeiten k√∂nnen, hilft die horizontale Skalierung nicht.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes-Dienste funktionieren in den meisten Standard-Webanwendungsszenarien. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobald Sie jedoch mit Anwendungsprotokollen arbeiten, die dauerhafte TCP-Verbindungen verwenden, wie z. B. Datenbanken, gRPC oder WebSockets, sind Dienste nicht mehr geeignet. </font><font style="vertical-align: inherit;">Kubernetes bietet keine internen Mechanismen zum Ausgleichen persistenter TCP-Verbindungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass Sie Anwendungen mit der M√∂glichkeit des Balancierens auf der Clientseite schreiben m√ºssen. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úbersetzung vorbereitet von einem Team </font></font></i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes aaS aus der Mail.ru</font></font></i></a><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font></i><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was gibt es sonst noch zu diesem Thema zu lesen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drei Ebenen der automatischen Skalierung in Kubernetes und deren effektive Verwendung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .&nbsp;</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes im Geiste der Piraterie mit einer Implementierungsvorlage</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   Kubernetes  </a>.</li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de493808/index.html">Asynchronen Code mit Corutin linearisieren</a></li>
<li><a href="../de493810/index.html">F√ºnf Jahre intensive Entwicklung des Marktes f√ºr Dokumentenerkennung</a></li>
<li><a href="../de493814/index.html">Wie wir Interviews in Barcelona f√ºhren</a></li>
<li><a href="../de493816/index.html">Git Guide Teilenummer 1: Alles, was Sie √ºber das .git-Verzeichnis wissen m√ºssen</a></li>
<li><a href="../de493818/index.html">Git Guide Teil Nummer 2: Die goldene Regel und andere Grundlagen der Rebase</a></li>
<li><a href="../de493822/index.html">Probleme und Funktionen der UEFI-Implementierung auf verschiedenen Plattformen</a></li>
<li><a href="../de493826/index.html">Teilen und erobern: Verbesserung der Elektrolyse von Wasser</a></li>
<li><a href="../de493828/index.html">Wie die Benutzeroberfl√§che Geschichten in Videospielen erz√§hlt</a></li>
<li><a href="../de493830/index.html">Welche Fragen stellt der Junior iOS-Entwickler bei den ersten Interviews?</a></li>
<li><a href="../de493832/index.html">Coronavirus COVID-19-Verteilungs-Dashboard (React + Chart.js + BootstrapTable)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>