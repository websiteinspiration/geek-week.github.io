<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺 🚏 👩‍❤️‍💋‍👩 Kubernetes Load Balancing und Skalierung langlebiger Verbindungen 👩🏻‍✈️ ⏏️ 👏🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel hilft Ihnen zu verstehen, wie der Lastausgleich in Kubernetes funktioniert, was beim Skalieren langlebiger Verbindungen passiert und wa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kubernetes Load Balancing und Skalierung langlebiger Verbindungen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/493820/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/445/275/8af/4452758afb53f8b3161ace47d8c6ea49.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel hilft Ihnen zu verstehen, wie der Lastausgleich in Kubernetes funktioniert, was beim Skalieren langlebiger Verbindungen passiert und warum Sie den Ausgleich auf der Clientseite in Betracht ziehen sollten, wenn Sie HTTP / 2, gRPC, RSockets, AMQP oder andere langlebige Protokolle verwenden.&nbsp;</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein bisschen darüber, wie der Verkehr in Kubernetes umverteilt wird&nbsp;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes bietet zwei praktische Abstraktionen für die Einführung von Anwendungen: Dienste und Bereitstellungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bereitstellungen beschreiben, wie und wie viele Kopien Ihrer Anwendung zu einem bestimmten Zeitpunkt ausgeführt werden sollen. </font><font style="vertical-align: inherit;">Jede Anwendung wird wie unter (Pod) bereitgestellt und erhält eine IP-Adresse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Feature-Services ähneln einem Load Balancer. </font><font style="vertical-align: inherit;">Sie sind so konzipiert, dass sie den Verkehr auf mehrere Herde verteilen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mal sehen, wie es aussieht</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der folgenden Abbildung sehen Sie drei Instanzen derselben Anwendung und einen Load Balancer:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80f/58d/4f9/80f58d4f9cd1e34a88aa7b8a33c0a82f.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Load Balancer heißt Service, ihm wird eine IP-Adresse zugewiesen. </font><font style="vertical-align: inherit;">Jede eingehende Anfrage wird an einen der Pods umgeleitet:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63e/7ef/b73/63e7efb73e75ce67fcd47f74b03aa04d.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Bereitstellungsskript bestimmt die Anzahl der Anwendungsinstanzen. </font><font style="vertical-align: inherit;">Sie müssen fast nie direkt unter bereitstellen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/121/8c3/a961218c382f2343f72bdcf639f20222.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedem Pod wird eine eigene IP-Adresse zugewiesen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c0/699/ef3/3c0699ef3d5a60d5b08f7afdfdedac29.png"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist nützlich, Dienste als eine Reihe von IP-Adressen zu betrachten. </font><font style="vertical-align: inherit;">Bei jedem Zugriff auf den Dienst wird eine der IP-Adressen aus der Liste ausgewählt und als Zieladresse verwendet. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist wie folgt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine Curl-Anfrage 10.96.45.152 an den Service:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60a/52c/539/60a52c539ed6d1791cbafa794db2c4a9.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Dienst wählt eine der drei Pod-Adressen als Ziel aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a8/ac4/e23/2a8ac4e23e79da06ee64c01e071b9089.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Datenverkehr wird zu einem bestimmten Pod umgeleitet:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/f2c/38e/7ecf2c38ef0af62d07d169c120ca5def.png"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihre Anwendung aus einem Frontend und einem Backend besteht, verfügen Sie jeweils über einen Service und eine Bereitstellung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Frontend die Anforderung an das Backend erfüllt, muss es nicht genau wissen, wie viele Herde das Backend bedient: Es kann einen, zehn oder einhundert geben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Außerdem weiß das Frontend nichts über die Adressen der Herde, die das Backend bedienen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Frontend eine Anfrage an das Backend sendet, verwendet es die IP-Adresse des Backend-Dienstes, die sich nicht ändert. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So sieht es aus</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter 1 fordert die interne Backend-Komponente an. </font><font style="vertical-align: inherit;">Anstatt eine bestimmte für das Backend auszuwählen, wird eine Serviceanforderung ausgeführt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ff/50c/a99/1ff50ca9970854efe8af15ac2a7d1791.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Dienst wählt einen der Backend-Pods als Zieladresse aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/dd9/9ad/530dd99add6451742a891d69ef06d03b.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Verkehr geht von Herd 1 zu Herd 5, der vom Dienst ausgewählt wurde:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ea/bdb/808/2eabdb8086fefc2c48d171f3c0e2c87e.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter 1 weiß es nicht genau, wie viele solcher Herde wie unter 5 hinter dem Dienst versteckt sind:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/665/f5e/edc/665f5eedc580d007fd9db6ced40f86d1.png"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber wie genau verteilt der Dienst Anfragen? </font><font style="vertical-align: inherit;">Scheint Round-Robin-Balancing verwendet zu werden? </font><font style="vertical-align: inherit;">Lass es uns richtig machen.&nbsp;</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Balancing in Kubernetes Services</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes-Dienste existieren nicht. Es gibt keinen Prozess für den Dienst, dem eine IP-Adresse und ein Port zugewiesen wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können dies überprüfen, indem Sie zu einem beliebigen Knoten im Cluster gehen und den Befehl netstat -ntlp ausführen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können nicht einmal die dem Dienst zugewiesene IP-Adresse finden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die IP-Adresse des Dienstes befindet sich in der Steuerungsschicht, im Controller und wird in der Datenbank - etcd. Dieselbe Adresse wird von einer anderen Komponente verwendet - kube-proxy. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kube-Proxy empfängt eine Liste von IP-Adressen für alle Dienste und bildet eine Reihe von Iptables-Regeln für jeden Knoten des Clusters. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Regeln lauten: "Wenn die IP-Adresse des Dienstes angezeigt wird, müssen wir die Zieladresse der Anforderung ändern und an einen der Pods senden."</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die IP-Adresse des Dienstes wird nur als Einstiegspunkt verwendet und von keinem Prozess bedient, der diese IP-Adresse und diesen Port abhört. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns das an</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .&nbsp;</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich einen Cluster aus drei Knoten vor. </font><font style="vertical-align: inherit;">Auf jedem Knoten befinden sich Pods:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/605/ed6/e82/605ed6e82d24139c7122fd0886fb3f5f.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strickherde in Beige sind Teil des Service. </font><font style="vertical-align: inherit;">Da der Dienst nicht als Prozess vorhanden ist, ist er ausgegraut:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/175/57b/919/17557b91988036bf15bdb5fd02b25c44.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste fragt nach dem Service und sollte auf einen der zugehörigen Herde fallen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13d/49c/2df/13d49c2dff1c5a15bfced3347ad4bc6c.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber der Dienst existiert nicht, es gibt keinen Prozess. </font><font style="vertical-align: inherit;">Wie funktioniert es?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7e/362/c43/a7e362c43d31ac5ba0368cbbfceae398.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor die Anforderung den Knoten verlässt, durchläuft sie die iptables-Regeln:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29d/eea/0ef/29deea0efafef803b87c66a7c17cc9cc.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die iptables-Regeln wissen, dass kein Dienst vorhanden ist, und ersetzen die IP-Adresse durch eine der IP-Adressen der diesem Dienst zugeordneten Pods:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4e/ec6/0ad/a4eec60ad28fbf16b085d9b8697dce81.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anfrage erhält eine gültige IP-Adresse als Zieladresse und wird normalerweise verarbeitet:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/653/ef7/4b8/653ef74b8f34567652c2e0a00c89d9a7.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abhängig von der Netzwerktopologie erreicht die Anforderung schließlich den Herd:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/696/c59/873/696c5987341d20780825ff2a4f6f7d12.png"></div></li>
</ol><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Können iptables die Last ausgleichen?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nein, iptables werden zum Filtern verwendet und wurden nicht zum Ausgleichen entwickelt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist jedoch möglich, eine Reihe von Regeln zu schreiben, die wie ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pseudo-Balancer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funktionieren </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und genau das macht Kubernetes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie drei Pods haben, schreibt kube-proxy die folgenden Regeln:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wählen Sie die erste mit einer Wahrscheinlichkeit von 33%, andernfalls fahren Sie mit der nächsten Regel fort.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wählen Sie die zweite mit einer Wahrscheinlichkeit von 50%, andernfalls fahren Sie mit der nächsten Regel fort.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wählen Sie die dritte unter.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein solches System führt dazu, dass jedes Sub mit einer Wahrscheinlichkeit von 33% ausgewählt wird.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08e/d59/2bc/08ed592bc03dd1f9740f29985451aaca.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt keine Garantie dafür, dass unter 2 die nächste Datei nach Datei 1 ausgewählt wird. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : iptables verwendet ein statistisches Modul für die zufällige Verteilung. </font><font style="vertical-align: inherit;">Somit basiert der Ausgleichsalgorithmus auf einer zufälligen Auswahl. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem Sie nun verstanden haben, wie Services funktionieren, schauen wir uns interessantere Arbeitsszenarien an.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langlebige Verbindungen in Kubernetes werden standardmäßig nicht skaliert</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jede HTTP-Anforderung vom Front-End zum Back-End wird von einer separaten TCP-Verbindung bedient, die geöffnet und geschlossen wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Frontend 100 Anforderungen pro Sekunde an das Backend sendet, werden 100 verschiedene TCP-Verbindungen geöffnet und geschlossen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können die Verarbeitungszeit der Anforderung reduzieren und die Last verringern, wenn Sie eine TCP-Verbindung öffnen und für alle nachfolgenden HTTP-Anforderungen verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das HTTP-Protokoll enthält eine Funktion namens HTTP Keep-Alive oder Wiederverwendung der Verbindung. In diesem Fall wird eine TCP-Verbindung zum Senden und Empfangen vieler HTTP-Anforderungen und -Antworten verwendet:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a65/cef/c9f/a65cefc9f558265089c48cdf96a1d049.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktion ist standardmäßig nicht aktiviert: Sowohl der Server als auch der Client müssen entsprechend konfiguriert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Setup selbst ist für die meisten Programmiersprachen und -umgebungen einfach und zugänglich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier einige Links zu Beispielen in verschiedenen Sprachen:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://medium.com/%40onufrienkos/keep-alive-connection-on-inter-service-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Node.js am Leben bleiben</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.baeldung.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Frühlingsstiefel am Leben bleiben</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://blog.insightdatascience.com/learning-about-the-"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Python am Leben bleiben</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://docs.microsoft.com/en-us/dotnet/api/system.net."><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In .NET am Leben bleiben</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert, wenn wir Keep-Alive in Kubernetes verwenden? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, dass sowohl die Frontend- als auch die Backend-Unterstützung am Leben bleiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben eine Kopie des Frontends und drei Kopien des Backends. Das Frontend stellt die erste Anfrage und öffnet eine TCP-Verbindung zum Backend. Die Anfrage erreicht den Dienst, einer der Backend-Pods wird als Zieladresse ausgewählt. Es sendet eine Antwort an das Backend und das Frontend empfängt sie. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Gegensatz zur üblichen Situation wird die TCP-Verbindung, wenn sie nach dem Empfang der Antwort geschlossen wird, jetzt für die folgenden HTTP-Anforderungen geöffnet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert, wenn das Frontend mehr Backend-Anfragen sendet? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese Anforderungen weiterzuleiten, wird eine offene TCP-Verbindung verwendet. Alle Anforderungen werden an dieselbe im Backend gesendet, wo die erste Anforderung eingegangen ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sollten iptables den Verkehr nicht umverteilen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nicht in diesem Fall. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn eine TCP-Verbindung erstellt wird, werden die iptables-Regeln durchlaufen, die eine bestimmte für das Backend auswählen, in das der Datenverkehr geleitet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da alle folgenden Anforderungen über eine bereits offene TCP-Verbindung ausgeführt werden, werden iptables-Regeln nicht mehr aufgerufen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mal sehen, wie es aussieht</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das erste Sub sendet eine Anfrage an den Dienst:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d1/235/11b/0d123511bd0e4e5d3806fdd7917e0bd7.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie wissen bereits, was als nächstes passieren wird. </font><font style="vertical-align: inherit;">Der Dienst existiert nicht, aber es gibt iptables-Regeln, die die Anforderung verarbeiten:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d1/235/11b/0d123511bd0e4e5d3806fdd7917e0bd7.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einer der Backend-Pods wird als Zieladresse ausgewählt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ae/5c0/e5b/9ae5c0e5bd3478f20d1546951a298dfd.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anfrage erreicht den Herd. </font><font style="vertical-align: inherit;">Zu diesem Zeitpunkt wird eine permanente TCP-Verbindung zwischen den beiden Pods hergestellt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b23/154/129/b23154129408fd401651880d3b94d816.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede nächste Anfrage vom ersten Pod geht über eine bereits hergestellte Verbindung:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/e1c/232/f90e1c232dbc399d39aaff47045b9aa8.gif"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen haben Sie eine schnellere Antwort und eine höhere Bandbreite erhalten, aber die Fähigkeit zur Skalierung des Backends verloren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst wenn Sie zwei Pods im Backend mit einer konstanten Verbindung haben, wird der Datenverkehr immer zu einem von ihnen geleitet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kann das behoben werden? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da Kubernetes nicht weiß, wie dauerhafte Verbindungen ausgeglichen werden können, liegt diese Aufgabe in Ihrer Verantwortung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dienste sind eine Reihe von IP-Adressen und Ports, die als Endpunkte bezeichnet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ihre Anwendung kann eine Liste der Endpunkte vom Dienst abrufen und entscheiden, wie Anforderungen zwischen ihnen verteilt werden sollen. Sie können mit Round-Robin eine dauerhafte Verbindung zu jedem Herd herstellen und Anforderungen zwischen diesen Verbindungen ausgleichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oder wenden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ausgefeiltere Ausgleichsalgorithmen an</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der clientseitige Code, der für den Ausgleich verantwortlich ist, sollte dieser Logik folgen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rufen Sie die Liste der Endpunkte vom Dienst ab.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Öffnen Sie für jeden Endpunkt eine dauerhafte Verbindung.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie eine Anfrage stellen müssen, verwenden Sie eine der offenen Verbindungen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisieren Sie regelmäßig die Liste der Endpunkte, erstellen Sie neue oder schließen Sie alte dauerhafte Verbindungen, wenn sich die Liste ändert.</font></font></li>
</ol><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So wird es aussehen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt die erste Anforderung an den Dienst zu senden, können Sie Anforderungen auf der Clientseite ausgleichen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98f/91a/0c9/98f91a0c9ecae76bd8f286ba3a282ff1.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie müssen Code schreiben, der fragt, welche Pods Teil des Dienstes sind:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/040/203/cb5/040203cb52d6b22bb8179a6870d2485f.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobald Sie die Liste erhalten haben, speichern Sie sie auf der Clientseite und stellen Sie damit eine Verbindung zu den Pods her:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e5/741/3e7/4e57413e7b01b017cf57fab312b28089.png"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie selbst sind für den Lastausgleichsalgorithmus verantwortlich:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/bc6/7ad/8d9bc67ad511790b477c8509c91fffb0.gif"></div></li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Frage ist nun: Gilt dieses Problem nur für HTTP Keep-Alive?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clientseitiger Lastausgleich</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HTTP ist nicht das einzige Protokoll, das dauerhafte TCP-Verbindungen verwenden kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihre Anwendung eine Datenbank verwendet, wird die TCP-Verbindung nicht jedes Mal geöffnet, wenn Sie eine Anforderung ausführen oder ein Dokument aus der Datenbank abrufen müssen.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stattdessen wird eine permanente TCP-Verbindung zur Datenbank geöffnet und verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihre Datenbank in Kubernetes bereitgestellt wird und der Zugriff als Dienst bereitgestellt wird, treten dieselben Probleme wie im vorherigen Abschnitt beschrieben auf. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Datenbankreplikat wird mehr als der Rest geladen. </font><font style="vertical-align: inherit;">Kube-Proxy und Kubernetes helfen nicht, Verbindungen auszugleichen. </font><font style="vertical-align: inherit;">Sie sollten sich darum kümmern, Abfragen in Ihrer Datenbank auszugleichen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je nachdem, mit welcher Bibliothek Sie eine Verbindung zur Datenbank herstellen, stehen Ihnen möglicherweise verschiedene Optionen zur Lösung dieses Problems zur Verfügung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das folgende Beispiel zeigt den Zugriff auf einen MySQL-Datenbankcluster von Node.js aus:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mysql'</span>);
<span class="hljs-keyword">var</span> poolCluster = mysql.createPoolCluster();<font></font>
<font></font>
<span class="hljs-keyword">var</span> endpoints = <span class="hljs-comment">/* retrieve endpoints from the Service */</span><font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> [index, endpoint] <span class="hljs-keyword">of</span> endpoints) {<font></font>
&nbsp; poolCluster.add(<span class="hljs-string">`mysql-replica-<span class="hljs-subst">${index}</span>`</span>, endpoint);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Make queries to the clustered MySQL database</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt unzählige andere Protokolle, die dauerhafte TCP-Verbindungen verwenden:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WebSockets und gesicherte WebSockets</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP / 2</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gRPC</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RSockets</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMQP</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie sollten bereits mit den meisten dieser Protokolle vertraut sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber wenn diese Protokolle so beliebt sind, warum gibt es keine standardisierte Ausgleichslösung? Warum ist eine Änderung der Clientlogik erforderlich? Gibt es eine native Kubernetes-Lösung? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kube-Proxy und iptables dienen zum Schließen der meisten Standardbereitstellungsszenarien für Kubernetes. Dies dient der Bequemlichkeit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie einen Webdienst verwenden, der eine REST-API bereitstellt, haben Sie Glück. In diesem Fall werden keine permanenten TCP-Verbindungen verwendet. Sie können einen beliebigen Kubernetes-Dienst verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobald Sie jedoch dauerhafte TCP-Verbindungen verwenden, müssen Sie herausfinden, wie Sie die Last gleichmäßig auf die Backends verteilen können. Kubernetes enthält für diesen Fall keine vorgefertigten Lösungen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich gibt es Optionen, die helfen können.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausgleich langlebiger Verbindungen in Kubernetes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes bietet vier Arten von Diensten an:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clusterip</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NodePort</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lastenausgleicher</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kopflos</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ersten drei Dienste basieren auf der virtuellen IP-Adresse, die vom kube-proxy zum Erstellen von iptables-Regeln verwendet wird. </font><font style="vertical-align: inherit;">Die grundlegende Grundlage aller Dienste ist jedoch ein kopfloser Dienst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dem kopflosen Dienst ist keine IP-Adresse zugeordnet, und er bietet nur einen Mechanismus zum Abrufen einer Liste von IP-Adressen und Ports der zugeordneten Herde (Endpunkte). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle Dienste basieren auf dem kopflosen Dienst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der ClusterIP-Dienst ist ein kopfloser Dienst mit einigen Ergänzungen:&nbsp;</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwaltungsschicht weist ihr eine IP-Adresse zu.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kube-Proxy bildet die notwendigen iptables-Regeln.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf diese Weise können Sie kube-proxy ignorieren und die Liste der vom kopflosen Dienst empfangenen Endpunkte direkt verwenden, um die Last in Ihrer Anwendung auszugleichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber wie kann man allen in einem Cluster bereitgestellten Anwendungen eine ähnliche Logik hinzufügen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihre Anwendung bereits bereitgestellt ist, scheint eine solche Aufgabe unmöglich zu sein. </font><font style="vertical-align: inherit;">Es gibt jedoch eine Alternative.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Service Mesh wird Ihnen helfen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie haben wahrscheinlich bereits bemerkt, dass die clientseitige Lastausgleichsstrategie Standard ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Anwendung gestartet wird, gilt Folgendes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruft eine Liste der IP-Adressen vom Dienst ab.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Öffnet und verwaltet einen Verbindungspool.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisiert den Pool regelmäßig und fügt Endpunkte hinzu oder entfernt sie.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobald die Anwendung eine Anfrage stellen möchte, gilt Folgendes:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wählt eine verfügbare Verbindung unter Verwendung einer Logik aus (z. B. Round-Robin).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erfüllt die Anfrage.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Schritte funktionieren für WebSockets, gRPC und AMQP. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können diese Logik in eine separate Bibliothek aufteilen und in Ihren Anwendungen verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stattdessen können jedoch Service-Grids wie Istio oder Linkerd verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Service Mesh ergänzt Ihre Anwendung mit einem Prozess, der:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sucht automatisch nach IP-Adressen von Diensten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überprüft Verbindungen wie WebSockets und gRPC.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleicht Anforderungen mit dem richtigen Protokoll aus.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Service Mesh hilft bei der Verwaltung des Datenverkehrs innerhalb des Clusters, ist jedoch recht ressourcenintensiv. </font><font style="vertical-align: inherit;">Andere Optionen verwenden Bibliotheken von Drittanbietern wie Netflix Ribbon oder programmierbare Proxys wie Envoy.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was passiert, wenn Sie Ausgleichsprobleme ignorieren?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können den Lastausgleich nicht verwenden und bemerken keine Änderungen. Schauen wir uns einige Arbeitsszenarien an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie mehr Clients als Server haben, ist dies kein so großes Problem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, es gibt fünf Clients, die eine Verbindung zu zwei Servern herstellen. Auch wenn kein Ausgleich besteht, werden beide Server verwendet:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3eb/2a3/ebf/3eb2a3ebfd09862d4200744170daec7e.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verbindungen können ungleich verteilt sein: Möglicherweise sind vier Clients mit demselben Server verbunden, aber es besteht eine gute Chance, dass beide Server verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Problematischer ist das umgekehrte Szenario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie weniger Clients und mehr Server haben, werden Ihre Ressourcen möglicherweise nicht ausreichend genutzt und es tritt ein potenzieller Engpass auf. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, es gibt zwei Clients und fünf Server. </font><font style="vertical-align: inherit;">Bestenfalls gibt es zwei permanente Verbindungen zu zwei von fünf Servern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Andere Server sind inaktiv:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee5/0d2/eaf/ee50d2eaf1dbefd5933dd9ec5221bd58.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn diese beiden Server die Verarbeitung von Clientanforderungen nicht verarbeiten können, hilft die horizontale Skalierung nicht.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kubernetes-Dienste funktionieren in den meisten Standard-Webanwendungsszenarien. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobald Sie jedoch mit Anwendungsprotokollen arbeiten, die dauerhafte TCP-Verbindungen verwenden, wie z. B. Datenbanken, gRPC oder WebSockets, sind Dienste nicht mehr geeignet. </font><font style="vertical-align: inherit;">Kubernetes bietet keine internen Mechanismen zum Ausgleichen persistenter TCP-Verbindungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass Sie Anwendungen mit der Möglichkeit des Balancierens auf der Clientseite schreiben müssen. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übersetzung vorbereitet von einem Team </font></font></i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes aaS aus der Mail.ru</font></font></i></a><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font></i><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was gibt es sonst noch zu diesem Thema zu lesen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drei Ebenen der automatischen Skalierung in Kubernetes und deren effektive Verwendung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .&nbsp;</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes im Geiste der Piraterie mit einer Implementierungsvorlage</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   Kubernetes  </a>.</li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de493808/index.html">Asynchronen Code mit Corutin linearisieren</a></li>
<li><a href="../de493810/index.html">Fünf Jahre intensive Entwicklung des Marktes für Dokumentenerkennung</a></li>
<li><a href="../de493814/index.html">Wie wir Interviews in Barcelona führen</a></li>
<li><a href="../de493816/index.html">Git Guide Teilenummer 1: Alles, was Sie über das .git-Verzeichnis wissen müssen</a></li>
<li><a href="../de493818/index.html">Git Guide Teil Nummer 2: Die goldene Regel und andere Grundlagen der Rebase</a></li>
<li><a href="../de493822/index.html">Probleme und Funktionen der UEFI-Implementierung auf verschiedenen Plattformen</a></li>
<li><a href="../de493826/index.html">Teilen und erobern: Verbesserung der Elektrolyse von Wasser</a></li>
<li><a href="../de493828/index.html">Wie die Benutzeroberfläche Geschichten in Videospielen erzählt</a></li>
<li><a href="../de493830/index.html">Welche Fragen stellt der Junior iOS-Entwickler bei den ersten Interviews?</a></li>
<li><a href="../de493832/index.html">Coronavirus COVID-19-Verteilungs-Dashboard (React + Chart.js + BootstrapTable)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>