<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äç‚úàÔ∏è üèØ üèª New TypeScript features for enhanced usability üåæ üê± üëçüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TypeScript, in many respects, is no longer more like a programming language, but a powerful tool for linting and documenting code that helps you write...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>New TypeScript features for enhanced usability</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/493712/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScript, in many respects, is no longer more like a programming language, but a powerful tool for linting and documenting code that helps you write better JavaScript programs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of TypeScript's most notable strengths is its support for some of the latest features described in the ECMAScript specification. When a developer upgrades to a new version of TypeScript, it means that he has new JavaScript features. Moreover, the use of these features does not mean potential compatibility issues. TypeScript, in addition to introducing the latest JavaScript features, is also notable for the fact that the creators of the language constantly present to the TS-programmer community something new, designed to increase the usability. This includes, for example, auxiliary tools for code refactoring, tools for renaming entities and for finding places where they are used in programs.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/webt/ik/dc/io/ikdcio3bkdkuvgg4h-lplk9lvpm.jpeg"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The material, the translation of which we publish today, will discuss some interesting fresh features of TypeScript. </font><font style="vertical-align: inherit;">For a complete list of TypeScript innovations, take a look </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immutable objects and arrays</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to make immutable arrays used in the form of ordinary variables and function parameters during compilation, in TypeScript, you can use auxiliary types </font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>ReadonlyArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">However, their use can cause a feeling of heterogeneity in type annotation, especially when declaring arrays using characters </font></font><code>[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after specifying a type. </font><font style="vertical-align: inherit;">TypeScript 3.4 introduces a new way to label parameters that are read-only arrays. </font><font style="vertical-align: inherit;">Immediately there appeared a new way of declaring variables that should be immutable.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Improving usability with read-only parameters</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When declaring the parameters of functions that you need to work with as read-only arrays, you can now use the keyword </font></font><code>readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In the following example, the signatures of the two methods are identical:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">s: ReadonlyArray&lt;string&gt;</span>) </span>{ <span class="hljs-comment">/* ... */</span> }<font></font>
&nbsp;<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">s: readonly string[]</span>) </span>{ <span class="hljs-comment">/* ... */</span> }
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In both cases, any attempt to modify the array (for example, using its method </font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) will result in an error. </font><font style="vertical-align: inherit;">This innovation eliminates the need for an auxiliary generic type, which means that code is easier to read. </font><font style="vertical-align: inherit;">Object types can also be labeled as read-only entities, but they still need a helper type </font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Improving the usability of immutable variables using the as const construct</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The type of a variable declared using a keyword </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cannot be changed. This concept exists in JavaScript. It is also adopted in TypeScript for the sake of organizing more stringent work with types. But when working with object data types, such as objects or arrays, it turns out that such structures are not truly immutable. Using a keyword </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">means that a specific instance of an object or array will remain unchanged when working with a constant, however the contents of this object or array can be easily changed. For example, without violating the rules for working with const entities, you can add new values ‚Äã‚Äãto the array using the method </font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, you can change the values ‚Äã‚Äãof the properties of objects. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using </font></font><code>Readonly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>ReadonlyArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you can tell TypeScript that the system should treat entities as if they were truly immutable. </font><font style="vertical-align: inherit;">This means that every time an attempt is made in the code to change such an entity, an error message will be issued.</font></font><br>
<br>
<pre><code class="javascript hljs">interface Person {&nbsp;
&nbsp;&nbsp;<span class="hljs-attr">name</span>: string;&nbsp;<font></font>
}<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> person = {&nbsp;
&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">'Will'</span>&nbsp;
} <span class="hljs-keyword">as</span> Readonly&lt;Person&gt;;<font></font>
person.name = <span class="hljs-string">'Diana'</span>; <span class="hljs-comment">// !</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In TypeScript 3.4, among other innovations, the concept of const assertion (constant statement), which provides for the use of a construct, appeared </font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is a simplified method for declaring constants containing immutable objects and arrays. </font><font style="vertical-align: inherit;">Such declarations are built by adding </font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a constant to the end of the declaration. </font><font style="vertical-align: inherit;">This method has an additional advantage, which is that when you use it, you do not need to explicitly specify the type in the statement </font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> person = {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">name</span>: <span class="hljs-string">'Will'</span>&nbsp;
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<font></font>
&nbsp;<font></font>
person.name = <span class="hljs-string">'Diana'</span>; <span class="hljs-comment">// !</span><font></font>
&nbsp;<font></font>
<span class="hljs-comment">//      as const</span>
<span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;&nbsp;<font></font>
array.push(<span class="hljs-number">4</span>); <span class="hljs-comment">// !</span>
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Helper type Omit</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are several helper types in TypeScript that make it easy to map existing types to new ones, or conditionally set a type based on other types. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The auxiliary type </font></font><code>Partial</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allows marking all properties of the object as optional. </font><font style="vertical-align: inherit;">Before the release of TypeScript 3.5, as it turned out, I constantly used one interesting mechanism in my projects. </font><font style="vertical-align: inherit;">This is the same as the use of the auxiliary type now allows to achieve </font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This type, as its name implies, allows you to exclude something from other types. </font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accepts the type and combination of keys, and then returns a new type from which the properties described by the keys are excluded. </font><font style="vertical-align: inherit;">Gone are the days when I had to use </font></font><code>Pick</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it </font></font><code>Exclude</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for the independent implementation of functionality</font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     TypeScript 3.5</span><font></font>
type Omit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;<font></font>
&nbsp;<font></font>
interface A {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propA?: string;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propB?: string;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;propC?: string;&nbsp;<font></font>
}<font></font>
&nbsp;<font></font>
type B = Omit&lt;A, <span class="hljs-string">'propA'</span> | <span class="hljs-string">'propC'</span>&gt;;&nbsp;
<span class="hljs-keyword">const</span> b: B = { <span class="hljs-attr">propA</span>: <span class="hljs-string">'hi'</span> }; <span class="hljs-comment">// ;</span>
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New JavaScript Features Supported by TypeScript</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When suggestions for new JavaScript features reach 4 stages of coordination, they are considered to be part of the next version of the language. </font><font style="vertical-align: inherit;">True, this does not mean that such capabilities can be immediately used in JavaScript, since their support should be implemented in appropriate environments. </font><font style="vertical-align: inherit;">The application should have access to such opportunities wherever its normal operation is supposed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Support for new JavaScript features is regularly added to the TypeScript compiler. </font><font style="vertical-align: inherit;">Typically, code that implements these features can be converted to JavaScript code that is compatible with all browsers that support the project build goal specified in </font></font><code>tsconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñç Check for null and undefined</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript developers are familiar with the concept of truth and falsity. When checking for the truth can be identified 6 values, which are always false: </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>¬´¬ª</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>NaN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and, of course, </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Most often, the developer just needs to find out if the value is true or false, but in some cases you just need to find out if the value being investigated is a real value </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. For example, in the case if it is necessary to distinguish between code </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ||     ,  index  0</span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index || <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 1 &lt;-- </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This code will work by setting </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the value written to </font></font><code>index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, in all cases except those when the value </font></font><code>index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is equal </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In order for this code to work correctly in any situation, it needs to be rewritten using a more complex test scheme to find out the real type of value.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   ,    </span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index !== <span class="hljs-literal">null</span> &amp;&amp; index !== <span class="hljs-literal">undefined</span> ? : <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 0</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now the code works, but it requires the use of more complex checks. </font><font style="vertical-align: inherit;">The new operator for checking the value on </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(it looks like two question marks - </font></font><code>??</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) simplifies such checks by returning the value located in its left part, if it is not equal to </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Otherwise, it returns what is on its right side.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// !</span>
<span class="hljs-keyword">const</span> getValueOrOne = <span class="hljs-function">(<span class="hljs-params">x?: number</span>) =&gt;</span> index ?? <span class="hljs-number">1</span>;&nbsp;<font></font>
getValueOrOne(<span class="hljs-number">0</span>); <span class="hljs-comment">// 0</span>
getValueOrOne(<span class="hljs-number">2</span>); <span class="hljs-comment">// 2</span>
getValueOrOne(); <span class="hljs-comment">// 1</span>
</code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñç Optional sequences</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another new JavaScript feature available in TypeScript 3.7 is the operator for organizing optional sequences ( </font></font><code>?.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). I first met such an operator in the Groovy programming language. Since then, I wanted it to appear in JavaScript as well. This operator allows you to organize access to the embedded properties of objects without the need for constant checking of their existence. If, when accessing a property, this operator encounters a value </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it will simply return this value without throwing an error </font></font><code>TypeError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> value = foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz;<font></font>
&nbsp;<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> value = foo?.bar?.baz;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The optional sequence operator combined with the operator of checking the values ‚Äã‚Äãon </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gives the developer even more possibilities, allowing, for example, to write to the variable either the value of some nested property of the object, or, if such a property does not exist, some standard value. </font><font style="vertical-align: inherit;">Here's what it looks like:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> value = foo?.bar?.baz ?? <span class="hljs-string">'default value'</span>;
</code></pre><br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñç Private class fields</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScript, since the advent of this language, has its own concept of private class fields declared with an access modifier </font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This concept appeared in TypeScript even before classes were described in the ECMAScript standard. But in TypeScript, this concept refers to the mechanisms that work during code compilation. The compiler will throw an error if the private field of the class is accessed not from the class‚Äôs own methods. Now in JavaScript there is an opportunity to declare private properties and methods of a class. But this feature is both semantically and syntactically different from what still existed in TypeScript. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Private fields in JavaScript are not declared using an access modifier </font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Instead, they are declared by putting a symbol at the beginning of their names </font></font><code>#</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fan</span> </span>{&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;#on = <span class="hljs-literal">false</span>;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;private name = <span class="hljs-string">'fan'</span>;<font></font>
&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;turnOn() {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.#on = <span class="hljs-literal">true</span>;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;&nbsp;isTurnedOn() {&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.#on;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> fan = <span class="hljs-keyword">new</span> Fan();&nbsp;<font></font>
fan.isTurnedOn(); <span class="hljs-comment">// false&nbsp;&nbsp;</span><font></font>
fan.turnOn();&nbsp;<font></font>
fan.isTurnedOn(); <span class="hljs-comment">// true</span><font></font>
&nbsp;<font></font>
fan.on; <span class="hljs-comment">//  </span>
fan.#on; <span class="hljs-comment">// </span>
fan.name; <span class="hljs-comment">//   ,    JS</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript now supports private fields, the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proposal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for private methods is in the third stage of approval. </font><font style="vertical-align: inherit;">Currently, the modifier </font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the character </font></font><code>#</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the field name cannot be used together. </font><font style="vertical-align: inherit;">Both approaches can come in handy during development, and which one to choose depends on the programmer. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here's a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> podcast that discusses the new syntax for declaring private fields.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñçUsing the await keyword at the top level of code</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Asynchronous programming mechanisms greatly expand the capabilities of JavaScript and TypeScript. At first promises appeared in this area, then - a design </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that allows you to write cleaner asynchronous code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the cases where promises are used, and not, </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is an asynchronous method call outside the asynchronous function. For example, at the top level of the module or application code. As a workaround in this situation, you can propose creating an asynchronous immediately called function expression (IIFE, Immediately Invoked Function Expression) and executing asynchronous code inside such an expression.</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-keyword">async</span> () =&gt; {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/users/sitepen'</span>);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Check out the blog at <span class="hljs-subst">${data.blog}</span>`</span>);&nbsp;<font></font>
})();<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScript now supports JavaScript's ability to use keywords </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the top level of code. </font><font style="vertical-align: inherit;">This means that await can be used outside of the functions declared with the keyword </font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is very good at writing compact and clear code. </font><font style="vertical-align: inherit;">True, the expressions </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the top level of the code are criticized for the fact that they can slow down the loading of modules and create a situation in which a certain module can slow down the loading of the entire application, since the system has to wait for the completion of the asynchronous operation, and then execute all the code of the module.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.github.com/users/sitepen'</span>);&nbsp;
<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> { ...data };
</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enhanced TypeScript experimentation environment</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This cannot be called a new TypeScript feature, but given that we are talking about TypeScript as a tool, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeScript Playground</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can be called an effective tool for quickly checking any TypeScript constructs and viewing the JavaScript code into which these constructs turn into. </font><font style="vertical-align: inherit;">Most of the examples here are tested specifically in TypeScript Playground. </font><font style="vertical-align: inherit;">Now this environment supports the ability to select a specific version of TypeScript (including support for beta versions). </font><font style="vertical-align: inherit;">It includes several examples that will help beginners get started with TypeScript.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summary</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TypeScript is a tool that helps you write better and more expressive JavaScript code. </font><font style="vertical-align: inherit;">TypeScript helper tools make it easy to solve complex tasks, such as refactoring and renaming entities, which are much more complicated in ordinary JavaScript. </font><font style="vertical-align: inherit;">TypeScript is constantly introducing new mechanisms, such as </font></font><code>Omit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>as const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In the language, one can observe a continuous improvement in support of complex types. </font><font style="vertical-align: inherit;">TypeScript quickly implements the latest JavaScript features. </font><font style="vertical-align: inherit;">That is why many people choose TypeScript, perceiving it as a tool, language and ecosystem. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dear readers! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What new TypeScript features do you find most interesting?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en493700/index.html">Using malware in Azure to gain access to Microsoft 365 tenants</a></li>
<li><a href="../en493702/index.html">Massive transition to remote work: technical problems and threats to security</a></li>
<li><a href="../en493704/index.html">Using TypeScript in JavaScript without writing TypeScript</a></li>
<li><a href="../en493706/index.html">Know your enemy: create a Node.js backdoor</a></li>
<li><a href="../en493708/index.html">Anatomy of my home Kubernetes cluster</a></li>
<li><a href="../en493714/index.html">Security Cheat Sheets: Nodejs</a></li>
<li><a href="../en493716/index.html">Type inference with TypeScript using the as const construct and the infer keyword</a></li>
<li><a href="../en493718/index.html">Discussion: standard UNIX utilities that few have used and are currently using</a></li>
<li><a href="../en493720/index.html">The perfect storm: how technology is changing the food service industry</a></li>
<li><a href="../en493724/index.html">RPA | Process robotization through the eyes of an analyst</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>