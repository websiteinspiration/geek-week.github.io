<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔷 👩🏾‍💼 ⚾️ Model komputasi paralel 👩🏻‍🚀 🚽 🍋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Perkenalan. Korutinisme kompetitif
 Artikel sebelumnya tentang topik pemrograman otomatis hanya "bunga". "Berry" dari pemrograman otomatis, mis. un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Model komputasi paralel</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486622/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Perkenalan. </font><font style="vertical-align: inherit;">Korutinisme kompetitif</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel sebelumnya tentang topik pemrograman otomatis hanya "bunga". "Berry" dari pemrograman otomatis, mis. untuk apa yang perlu Anda lakukan, adalah model komputasi paralel berdasarkan model mesin negara. Jadi, mari kita pergi ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Standar C ++ termasuk dukungan yang telah lama ditunggu-tunggu untuk multithreading [1]. Tetapi kami tidak akan mengaguminya atau mengkritik fakta ini, karena bekerja dengan utas terbebani oleh begitu banyak kondisi, peringatan, dan fitur yang tanpa contoh nyata yang mengungkapkan masalah multithreading, diskusi tentang pemrograman multithread tidak hanya akan tergesa-gesa, tetapi juga cukup bias. Oleh karena itu, selanjutnya terutama bukan tentang arus, tetapi tentang automata, mengingat, tentu saja, yang pertama.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahasa C ++ jauh dari yang pertama, dilengkapi dengan konstruksi paralelisme. Kembali pada 60-an abad terakhir, N. Wirth mengusulkan perpanjangan paralel dari bahasa ALGOL [2]. Namun, 60 tahun ke depan belum menjelaskan apa yang harus dianggap sebagai algoritma paralel dan apa yang harus menjadi model komputasi paralel. Rupanya, ekstensi yang terlambat dari bahasa C ++ juga terhubung dengan ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baik konstruksi lama dari bahasa ALGOL, dan analog mereka yang lebih modern dalam bahasa C ++, hanyalah metode paralelisasi struktural yang tidak memperkenalkan model algoritmik paralel. Untuk membenarkan hal ini, dapat dikatakan bahwa upaya yang dilakukan selama masa lalu untuk membuat model perhitungan formal telah gagal. Cukuplah untuk mengatakan bahwa jaring Petri yang sama tidak membenarkan harapan tinggi yang diberikan pada mereka.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akibatnya, "spiral" perkembangan paralelisme tampaknya telah kembali ke sumbernya, hanya mengalami "perkembangan terminologis". </font><font style="vertical-align: inherit;">Mantan coroutine sepele tiba-tiba menjadi maju "coroutine" (menelusuri kertas dari coroutine Inggris), dan kebingungan dengan konsep paralel dan bersamaan di segmen bahasa Inggris pemrograman paralel kadang-kadang menyebabkan hal-hal paradoks. </font><font style="vertical-align: inherit;">Misalnya, edisi pertama buku [1] berbeda dari edisi kedua dengan mengganti istilah "paralel" dengan "kompetitif" dan "multithreaded" dengan "paralel". </font><font style="vertical-align: inherit;">Jadi pikirkan ini dalam situasi “siapa adalah siapa”.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Model perhitungan otomat paralel</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin tidak ada yang akan membantah bahwa langkah kualitatif berikutnya dalam pengembangan pemrograman dihubungkan dengan transisi ke model komputasi paralel. Tetapi apakah ini akan terjadi sebagai akibat dari perkembangan evolusioner dari model komputasi yang ada atau apakah itu akan menjadi model yang secara fundamental berbeda adalah masalah yang masih dibahas. Dan jika para teoretikus masih berdebat, maka bagian programmer yang termotivasi secara praktis sudah menggunakan metode struktural untuk memparalelkan program.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pemisahan tugas dan peningkatan produktivitas dianggap sebagai satu-satunya alasan untuk menggunakan konkurensi. Setidaknya, bagi mereka atau kombinasinya pada akhirnya mengurangi atau mencoba mengurangi semua yang lain [1]. Tetapi ada alasan yang jarang dibicarakan, tetapi karena itu umumnya bermanfaat untuk terlibat dalam pemrograman paralel. Memang, kecepatan dapat ditingkatkan dengan metode perangkat keras murni, dan pemisahan tugas dengan paralelisme terhubung dengan cara yang sama seperti pekerjaan sehari-hari karyawan bank dengan daftar tugas resmi mereka. Dan hanya algoritma paralel yang merupakan strategi yang memungkinkan kita untuk mengalahkan kompleksitas tugas dan meningkatkan keandalan program. Dan semua ini bertentangan dengan pendapat yang berlaku tentang pemrograman multi-threaded, yang mengubah setiap program paralel menjadi produk perangkat lunak yang kompleks dan tidak dapat diandalkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suatu sistem paralel, yang terdiri dari banyak komponen paralel yang berfungsi dan secara aktif berinteraksi, objek, agen, dll., Mengimplementasikan suatu algoritma yang ditentukan dalam banyak hal bukan oleh algoritma dari masing-masing komponen (walaupun mereka, tentu saja), tetapi dengan jumlah komponen, jumlah dan jenis koneksi di antara mereka. Untuk mengendalikan kompleksitas ini dan memahami algoritma sistem paralel, Anda tidak hanya perlu model komputasi paralel, tetapi model yang, antara lain, dan bahkan di atas semua itu, memiliki teori yang tepat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tesis yang “sering merupakan program paralel lebih sulit untuk dipahami ..., dan, oleh karena itu, jumlah kesalahan meningkat,” secara sederhana, masih bisa diperdebatkan. </font><font style="vertical-align: inherit;">Ya, algoritma program paralel bisa sangat sulit untuk dipahami, tetapi jika ada teori maka dapat "dihitung" secara formal menggunakan algoritma komponen. </font><font style="vertical-align: inherit;">Dan dari sudut pandang mendesain, menerapkan dan memelihara komponen algoritma jauh lebih sederhana daripada algoritma sistem secara keseluruhan. </font><font style="vertical-align: inherit;">Saat merancang komponen yang lebih sederhana, kami jelas akan membuat lebih sedikit kesalahan daripada mendesain sistem dalam satu bagian. </font><font style="vertical-align: inherit;">Selain itu, komponen yang didebug dapat menjadi bagian dari sistem lain, mengurangi kompleksitas, meningkatkan keandalan dan meminimalkan biaya desain.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Konkurensi serial</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel [3] menggambarkan paralelisme dari model terpisah dari mesin keadaan terbatas. Salurannya di tingkat pelaksanaan transisi menentukan eksekusi paralel fungsi / metode yang terkait dengannya - predikat dan tindakan. Pada saat yang sama, tidak ada batasan pada predikat paralelisme. Ketika bekerja, mereka tidak saling bertentangan, karena tidak mempengaruhi isi memori. Tindakan, yang bekerja secara paralel, dapat memiliki input dan output data yang sama, serta mengubahnya secara independen satu sama lain. Dan semua ini bisa menjadi sumber ketidakpastian dalam nilai data output.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengoperasian tindakan yang benar dalam situasi yang dijelaskan di atas memberikan memori bayangan. </font><font style="vertical-align: inherit;">Dengan menyimpan nilai-nilai baru di dalamnya, seseorang dapat menggunakan data yang sama bahkan dalam satu tindakan, baik sebagai input dan output. </font><font style="vertical-align: inherit;">Contohnya adalah model generator pulsa persegi panjang, digambarkan sebagai y =! Y, di mana y adalah output dari generator. </font><font style="vertical-align: inherit;">Kode C ++-nya di lingkungan VKPa ditunjukkan pada Listing 1, dan hasil program ditunjukkan pada Gambar. </font><font style="vertical-align: inherit;">1.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar 1. Generator pulsa persegi panjang</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSWGenerator</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FSWGenerator(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FSWGenerator(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FSWGenerator(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FSWGenerator.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_SWGenerator[] = {<font></font>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FSWGenerator::FSWGenerator(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_SWGenerator, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{<font></font>
    pTAppCore = pInfo;<font></font>
}<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FSWGenerator::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<span class="hljs-comment">// setting output signals</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FSWGenerator::y1</span><span class="hljs-params">()</span> </span>{<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, !<span class="hljs-keyword">bool</span>(pVarY-&gt;GetDataSrc()));<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
 <img src="https://habrastorage.org/webt/3f/ue/ni/3fueni68ys5fwldckqdbodllckm.jpeg" alt="gambar"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. 1. Simulasi pengoperasian generator pulsa persegi panjang di VKPA.</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dalam kasus ini, mesin memiliki satu keadaan dengan transisi tanpa syarat (transisi dengan tanda hubung di tempat kondisi input) dalam bentuk loop yang ditandai oleh aksi y1, yang mengimplementasikan inversi dari variabel output, yang membentuk pulsa persegi dalam dinamika. Dalam kerangka model otomat, frekuensi sinyal pulsa dapat dikontrol dengan menetapkan nilai kebijaksanaan waktu diskrit ruang otomat ke mana otomat dimuat.</font></font><br>
<br>
<i> 1.          ,   .              .        .         .<br>
</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemampuan untuk mengontrol waktu diskrit dari otomat dan keberadaan banyak ruang otomat bukan satu-satunya, tetapi penting, sifat khas dari lingkungan VKPa. </font><font style="vertical-align: inherit;">Dengan menggunakannya, Anda dapat mengoptimalkan kinerja program paralel. </font><font style="vertical-align: inherit;">Misalnya, mesin yang menerapkan visualisasi data dan dialog pengguna harus ditempatkan di ruang otomat lambat, dan proses aplikasi harus didistribusikan di antara ruang otomat sesuai dengan prioritas dan kecepatan yang diinginkan, dll. </font><font style="vertical-align: inherit;">dll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kerangka model otomat, nilai output generator mudah terkait dengan keadaan model saat ini. </font><font style="vertical-align: inherit;">Kode untuk model generator, yang sudah memiliki dua status, yang masing-masing mencerminkan keadaan output generator, ditunjukkan pada Listing 2.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 2. Generator gelombang persegi pada status</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_SWGenState[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSWGenState</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    FSWGenState(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_SWGenState, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) {};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FSWGenState.h"</span></span>
<span class="hljs-comment">// state machine transition table</span><font></font>
LArc TBL_SWGenState[] = {<font></font>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam model baru, status menggantikan variabel output, dan ini, seperti dapat dilihat, secara dramatis menyederhanakan model generator. </font><font style="vertical-align: inherit;">Akibatnya, kami mendapat mesin "telanjang", yang hanya diwakili oleh tabel konversi. </font><font style="vertical-align: inherit;">Untuk memantau status saat ini "s1" di VKPa, variabel dari tipe fsa (status) dengan nama SWGenState. (S1) dibuat untuk mesin dengan nama SWGenState. </font><font style="vertical-align: inherit;">Dibutuhkan nilai true dalam status s1, dan false ketika mesin dalam kondisi berbeda. </font><font style="vertical-align: inherit;">Selanjutnya, variabel ini sudah digunakan dengan cara menampilkan data lingkungan VKPA (lihat tren sinyal pada Gambar. 2). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xv/it/jp/xvitjpkfffsmaodeyax2cmeotkq.jpeg" alt="gambar"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. </font><font style="vertical-align: inherit;">2. Memodelkan generator keadaan</font></font><br>
</i><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Model kontrol komputasi paralel</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lebih lanjut, bergerak menuju penciptaan model proses paralel, adalah logis untuk menggunakan banyak mesin negara yang berfungsi dan berinteraksi secara simultan, yaitu. jaringan automata. Dalam kasus ini, masalah memilih model waktu jaringan muncul, yang bisa sama untuk semua mesin atau, dalam batasnya, masing-masing untuk masing-masing. Dalam VKPa, pilihan dibuat untuk satu kali (untuk detail lebih lanjut tentang jaringan sinkron automata, lihat [5]).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pilihan waktu tunggal memungkinkan Anda untuk membuat aljabar automata yang memiliki operasi komposisi dan penguraian automata. Menggunakan yang pertama, Anda dapat menemukan otomat yang dihasilkan, yang memberikan ide yang akurat tentang pengoperasian sistem paralel. Dan di sini ada baiknya mengingat tesis di atas tentang "kompleksitas pemahaman" dari program paralel. Kehadiran operasi komposisi memungkinkan kita untuk memecahkan "masalah pemahaman" dari program paralel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, otomat yang dihasilkan untuk jaringan sejumlah besar komponen bisa sangat produktif. Tetapi, untungnya, pemahaman tentang operasi subsistem atau jaringan dari sejumlah kecil komponen lebih sering diperlukan, di mana menemukan otomat yang dihasilkan tidak menyebabkan masalah besar. Contoh model RS-flip-flop berikut menunjukkan ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Model pemicu RS adalah contoh sistem paralel sederhana. Ini sangat menarik dengan adanya umpan balik silang. Masukan, atau, dengan cara lain, rantai siklik, loop, loop aljabar, dll. saat ini merupakan masalah serius untuk model struktural sistem paralel. Dalam kasus umum, itu diizinkan dengan memasukkan ke dalam celah celah elemen memori. Ini adalah solusi standar yang diusulkan oleh teori automata [4]. Output yang sama direkomendasikan pada orang MATLAB. Lingkungan VKPa berbeda karena tidak memerlukan pengenalan elemen tambahan untuk implementasi loop. Catatan, dan ini sangat penting, sirkuit nyata juga tidak membutuhkannya (lihat sirkuit RS-flip-flop).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam gbr. </font><font style="vertical-align: inherit;">Gambar 3 menyajikan model paling sederhana dari elemen AND-NOT, yang terdiri dari rangkaian pemicu RS. </font><font style="vertical-align: inherit;">Itu tidak memperhitungkan penundaan elemen akun, serta tipenya (keterlambatan transportasi atau inersia). </font><font style="vertical-align: inherit;">Namun, itu masih mengandung setidaknya satu beat beat. </font><font style="vertical-align: inherit;">Ini adalah waktu transisi dari satu negara ke negara lain. </font><font style="vertical-align: inherit;">Listing 3 menunjukkan kode model </font></font><br>
<br>
<img src="https://habrastorage.org/webt/os/8b/am/os8bam0skdc-jwtctewqmbwupci.jpeg" alt="gambar"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">3. Model elemen DAN TIDAK</font></font></i><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar 3. Model elemen DAN TIDAK</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FIne</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FIne(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FIne(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FIne(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarX1;				<span class="hljs-comment">//  </span>
    CVar *pVarX2;				<span class="hljs-comment">//  </span>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameY;         <span class="hljs-comment">//   </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y2</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">bool</span> bX1, bX2, bY;<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FIne.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_Ine[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12^x1"</span>,	<span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12^x2"</span>,	<span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12x1x2"</span>,	<span class="hljs-string">"y2"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x1x2"</span>,   <span class="hljs-string">"y2"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"^x1"</span>,    <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"^x2"</span>,    <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FIne::FIne(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_Ine, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{ }<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FIne::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"x1"</span>, CLocVar::vtBool, <span class="hljs-string">" 1- "</span>);<font></font>
    pVarX2 = CreateLocVar(<span class="hljs-string">"x2"</span>, CLocVar::vtBool, <span class="hljs-string">" 2- "</span>);<font></font>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameY = CreateLocVar(<span class="hljs-string">"strNameY"</span>, CLocVar::vtString, <span class="hljs-string">"name of external output variable(y)"</span>);		<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX1) {<font></font>
        str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameX2) {<font></font>
        str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>); }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameY) {<font></font>
        str = pVarStrNameY-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>){pVarY = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);}<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">bool</span>(pVarX1-&gt;GetDataSrc()); }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">bool</span>(pVarX2-&gt;GetDataSrc()); }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarY; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y1</span><span class="hljs-params">()</span> </span>{ pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">1</span>); }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y2</span><span class="hljs-params">()</span> </span>{ pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0.0</span>); }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y12</span><span class="hljs-params">()</span> </span>{ FInit(); }
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam gbr. Gambar 4 memperlihatkan diagram flip-flop RS dan modelnya dalam bentuk mesin keadaan terbatas. Panah pada model menunjukkan koneksi antara automata jaringan. Di sini, di satu sisi, keadaan model mencerminkan keadaan keluaran elemen, dan, di sisi lain, mereka juga digunakan sebagai sinyal untuk mengatur hubungan informasi antara proses paralel. Bentuk model ini (dengan sinkronisasi melalui status) yang membuatnya cukup mudah untuk menemukan otomat yang dihasilkan dari jaringan. Itu ditunjukkan dalam gambar. 5 (untuk prosedur menemukan otomat yang dihasilkan, lihat [6] untuk lebih jelasnya).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bandingkan algoritma [yang dihasilkan] dari program paralel RS-flip-flop dan algoritma operasi elemen AND-NOT yang terpisah. Perbedaannya mencolok. Dalam hal ini, algoritma komponen dibuat oleh "handle", dan algoritma sistem paralel dibuat secara implisit - oleh "kecerdasan buatan" dari jaringan. Ini adalah perbedaan kualitatif antara program paralel dan yang berurutan: mengubah hanya komunikasi (setidaknya satu), kita akan mendapatkan algoritma kerja yang sama sekali berbeda. Dan itu pasti tidak akan menjadi pemicu RS lagi. Dan, omong-omong, robot lain yang dihasilkan. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/kb/zi/fc/kbzifcjk_ycehmabwwtsuh_gyfc.jpeg" alt="gambar"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. 4. Skema RS-FF dan model jaringan </font></font><br>
</i><br>
<img src="https://habrastorage.org/webt/_v/ht/2n/_vht2nka0gtsreim8qhjplh_njq.jpeg" alt="gambar"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar. 5. Model jaringan mesin yang dihasilkan RS-trigger</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Analisis otomat yang dihasilkan pada Gambar. 5 memberikan "pemahaman" berikut tentang program paralel (dan pemicu sebenarnya, tentu saja). Pertama, ketika beralih dari satu negara ke negara lain, pemicunya tentu akan melalui keadaan "terlarang" dari output (dan apa yang buku teks katakan tentang ini?). Kedua, jika pemicu didorong ke dalam satu keadaan keluaran (dalam keadaan "s1w1"), dan kemudian dua unit diumpankan ke input, itu akan memasuki mode pembangkitan, mis. pergantian siklik antara status “s1w1” dan “s0w0” dan (dan apakah Anda pernah mendengar tentang pemicu generasi?).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transisi melalui keadaan terlarang juga terjadi pada pemicu nyata, tetapi mode pembuatan tidak mungkin karena perbedaan keterlambatan elemen nyata. Ara. Gambar 6 menunjukkan mode pembuatan model pemicu pemicu, yang ada selama unit pada input disimpan. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan 2. Deskripsi khas operasi pemicu RS diberikan dalam sebagian besar kasus dalam bentuk tabel kebenaran. Tetapi untuk melakukannya, memahami bahwa pemicu adalah skema berurutan, itu, pada kenyataannya, sengaja menyesatkan mereka yang mempelajari topik ini. Yah, tidak ada pemicu yang tidak dapat memiliki "negara terlarang"! Tetapi untuk beberapa alasan hanya sedikit yang memutuskan untuk menemukan kebenaran ini dan, terutama, membahas masalah generasinya (lihat, misalnya, [7]).</font></font><br>
</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ara. Gambar 7 menunjukkan pergantian model pemicu antara kondisi stabilnya. Di sini, satu keadaan input pemicu mempertahankan keadaan saat ini dari output pemicu, dan ketika input ini atau itu diatur ke nol, ia beralih ke status berlawanan. Pada saat yang sama, ketika pelatuk diaktifkan, outputnya pada saat yang sama dengan satu ukuran terpisah pada saat yang sama mengambil status tunggal (dilarang oleh siapa?). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cs/fl/a0/csfla0xnbcpz0ngewn6izuj_cps.jpeg" alt="gambar"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ara. 6. Mode pembuatan RS-trigger </font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/nc/w5/74/ncw574s_lxpj2qq4oh1krswiclk.jpeg" alt="gambar"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar. 7. Mengganti RS-trigger antar state</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan model pemicu RS lainnya, yang terdiri dari satu keadaan dan satu tindakan, yaitu. </font><font style="vertical-align: inherit;">mirip dengan model pada Listing 1. Kodenya ditunjukkan pada Listing 4. Model ini, seperti model generator, tidak memiliki predikat dan nilai sinyal tanpa transformasi menengah apa pun merupakan input untuk tindakan y1. </font><font style="vertical-align: inherit;">Apakah ini baik atau buruk? </font><font style="vertical-align: inherit;">Di satu sisi, sepertinya itu bagus, karena </font><font style="vertical-align: inherit;">kode menjadi lebih sederhana, tetapi di sisi lain ... tidak juga. </font><font style="vertical-align: inherit;">Dan kita akan mengerti alasannya sekarang.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 4. Model elemen NAND dari satu tindakan</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FTwoOperators</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FTwoOperators(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FTwoOperators(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FTwoOperators(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarX1;				<span class="hljs-comment">//  </span>
    CVar *pVarX2;				<span class="hljs-comment">//  </span>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameY;         <span class="hljs-comment">//   </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">bool</span> bX1, bX2, bY;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FTwoOperators.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_TwoOperators[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12"</span>, <span class="hljs-string">"--"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,  <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FTwoOperators::FTwoOperators(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_TwoOperators, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{ }<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FTwoOperators::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"x1"</span>, CLocVar::vtBool, <span class="hljs-string">" 1- "</span>);<font></font>
    pVarX2 = CreateLocVar(<span class="hljs-string">"x2"</span>, CLocVar::vtBool, <span class="hljs-string">" 2- "</span>);<font></font>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameY = CreateLocVar(<span class="hljs-string">"strNameY"</span>, CLocVar::vtString, <span class="hljs-string">"name of external output variable(y)"</span>);		<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX1) {<font></font>
        str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameX2) {<font></font>
        str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>); }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameY) {<font></font>
        str = pVarStrNameY-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarY = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FTwoOperators::x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarY; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTwoOperators::y1</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// reading input signals</span>
    bX1 = <span class="hljs-keyword">bool</span>(pVarX1-&gt;GetDataSrc());<font></font>
    bX2 = <span class="hljs-keyword">bool</span>(pVarX2-&gt;GetDataSrc());
<span class="hljs-comment">// setting output signals</span><font></font>
    bY = !(bX1&amp;&amp;bX2);<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, bY);<font></font>
}<font></font>
<span class="hljs-comment">// initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTwoOperators::y12</span><span class="hljs-params">()</span> </span>{ FInit(); }
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita menguji model baru dalam mode "memori bayangan", maka kita tidak akan melihat perbedaan dalam operasinya dari yang sebelumnya, yaitu, dan, beralih, itu akan melalui negara terlarang dan secara teratur memasuki mode generasi. Jika kita mengatur pekerjaan dengan data dalam mode biasa, kita akan mendapatkan hasil yang ditunjukkan pada Gambar. 8 dan ara. 9. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/to/mc/ib/tomcibxvaq2mae2kxxqc5clwits.jpeg" alt="gambar"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar. 8. Kegagalan mode pembuatan model pemicu RS </font></font></i><br>
 <br>
<img src="https://habrastorage.org/webt/pu/qt/5y/puqt5yws1udobr_volkpcm7r4dm.jpeg" alt="gambar"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. 9. Melewati status terlarang oleh</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
model </font><i><font style="vertical-align: inherit;">pemicu RS</font></i><font style="vertical-align: inherit;"> Mengapa model pertama, terlepas dari mode bekerja dengan memori, menunjukkan hasil yang stabil, dan yang kedua - mengubah perilaku? Alasannya adalah predikat. Model kedua tidak memiliki predikat, dan ini sangat penting untuk perilakunya. Tetapi bagaimana dan mengapa ada / tidaknya predikat mempengaruhi algoritma operasi program paralel?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Model program elemen AND-NOT, seperti program otomat, memiliki dua saluran input dan satu saluran output. Mereka harus mencocokkan dua predikat dan satu aksi. Program pertama sepenuhnya konsisten dengan ini. Kernel VKPa, yang menginterpretasikan deskripsi otomat, pertama-tama mengeksekusi semua predikat tidak hanya otomat tertentu, tetapi juga seluruh ruang otomat, dan baru kemudian memulai semua tindakan. Dalam hal ini, dalam urutan apa pun tindakan dijalankan, mensimulasikan paralelisme, dan dalam mode apa pun mereka bekerja dengan memori, hasil predikat pada siklus jam saat ini dari otomat tidak bergantung pada mereka (tindakan). Karena itu, program pertama menghasilkan hasil yang sama.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Program kedua, meskipun bekerja langsung dengan saluran input mesin, membaca sinyal input sebagai bagian dari tindakan. </font><font style="vertical-align: inherit;">Tindakan, bekerja dengan input data dalam mode memori bayangan, menulis nilai baru ke memori bayangan dan dengan demikian bekerja dengan data yang valid pada awal siklus clock diskrit. </font><font style="vertical-align: inherit;">Dalam mode biasa, mereka "mengambil" nilai-nilai instan yang ditetapkan pada saat perubahan mereka, dan dengan demikian algoritma menjadi tergantung pada saat-saat perubahan memori. </font><font style="vertical-align: inherit;">Ketergantungan serupa ditunjukkan oleh program kedua. </font><font style="vertical-align: inherit;">Dan bahkan jika metode predikat diperkenalkan ke dalam model kedua, ini tidak akan berpengaruh pada hasil kerjanya. </font><font style="vertical-align: inherit;">Yang penting di sini bukan fakta keberadaan metode predikat, tetapi fitur pekerjaan mereka dalam kerangka model pemrograman otomat.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Kesimpulan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menggunakan program paralel RS-trigger sebagai contoh, kami memeriksa beberapa properti yang melekat dalam program paralel mana pun. </font><font style="vertical-align: inherit;">Kami akan terus mempertimbangkan aspek umum tertentu dari fungsi program paralel sebagai contoh sirkuit logis (digital). </font><font style="vertical-align: inherit;">Pilihan topik pemodelan sirkuit digital di sini tidak disengaja. </font><font style="vertical-align: inherit;">Bahkan, dalam "bentuk halus" mereka mewakili karya proses paralel. </font><font style="vertical-align: inherit;">Ini membuat analisis nuansa konkurensi, ras, sinkronisasi, jalan buntu, dll. </font><font style="vertical-align: inherit;">dll. transparan, jelas dan sederhana.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada saat yang sama, tidak peduli bagaimana Anda menyebut pemrograman - "kompetitif" atau paralel, apakah Anda menggunakan "coroutine", coroutine, utas atau mesin untuk pemrograman, hasil dari program [paralel] harus sama di semua implementasi. </font><font style="vertical-align: inherit;">Model otomatis program paralel dalam kerangka CPSU mengejar ini dan hanya tujuan ini.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apapun asumsi yang akan dibuat mengenai implementasi inti dari interpretasi automata lingkungan VKPa, semua ini akan menjadi "spekulasi", karena hasil kerja program otomatis tidak boleh dikaitkan dengan penerapan model komputasi. Ini bisa berupa perangkat lunak (seperti sekarang) atau perangkat keras (seperti yang saya harapkan di masa depan), diimplementasikan pada satu inti atau pada perangkat mereka, dalam versi single-threaded atau multi-threaded, dll. dll. semua ini tidak akan mempengaruhi hasil program otomatis paralel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan, sepertinya, tujuannya tercapai. </font><font style="vertical-align: inherit;">Model pemicu RS, sebagai salah satu tes yang mungkin dari sistem paralelisme [8], meyakinkan kami akan hal ini ... Seperti yang telah ditunjukkan kehidupan, semua program paralel lainnya, asalkan lingkungan telah berhasil melewati implementasi paralelisme uji pemicu RS, bekerja dengan benar, andal, dan stabil. . </font><font style="vertical-align: inherit;">Omong-omong, MATLAB yang sama "RS-trigger test" tidak lulus, dan ini sudah mengatakan banyak ...</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">literatur</font></font></b><div class="spoiler_text">1.  .    ++  .    . .  .  .. – .:  , 2012. – 672 . <br>
2.  .    : .  . – .: , 1981. – 360 .<br>
3.    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/ru/post/484588</a> . . . (  07.01.2020).<br>
4.  ..   . .: , 1962.<br>
5.  .., - ..    . – 2- ., .  . – .:  , 1988. – 480 .<br>
6.  ..    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cloud.mail.ru/public/HwsK/T95PMM8Ed</a> . . . (  01.02.2020).<br>
7.  .    . 2-  . – .: , 2004. – 432.<br>
8.  ..   ? “ ”, №10/97, .116-119. [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.osp.ru/pcworld/1997/10/158015</a> . . . (  01.02.2020).<br>
</div></div></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id486622/">https://habr.com/ru/post/id486622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id486598/index.html">Eksperimen Mikrokontroler di Notebook Jupyter</a></li>
<li><a href="../id486602/index.html">Intisari Bahan Masyarakat Intisari (16 Januari - 1 Februari)</a></li>
<li><a href="../id486604/index.html">Tidak, sistem tipe dinamis pada dasarnya tidak lebih terbuka</a></li>
<li><a href="../id486608/index.html">Asisten Esensial dalam Kecerdasan Badan Intelijen Paling Efektif di Dunia (Bagian 2)</a></li>
<li><a href="../id486614/index.html">Mengapa eSIM dibutuhkan Cara kerjanya dan mengapa mereka banyak bicara tentang itu</a></li>
<li><a href="../id486626/index.html">Svelte: mengenal Tindakan</a></li>
<li><a href="../id486628/index.html">Memperbaiki jarak antara kutu pada sumbu di gnuplot</a></li>
<li><a href="../id486630/index.html">"Jangan berkedip di mata": bagaimana teknologi pencahayaan layar pembaca elektronik diatur</a></li>
<li><a href="../id486632/index.html">Model Pemrograman Reaktif Mental untuk Pengawas</a></li>
<li><a href="../id486634/index.html">Pembaruan MSVC Backend di Visual Studio 2019 versi 16.3 dan 16.4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>