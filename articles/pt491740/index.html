<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🔧 🏫 🤚🏼 Internet das coisas no Yandex.Cloud: como os serviços de funções do Yandex IoT Core e Yandex Cloud são organizados 🐻 👩🏿‍🤝‍👩🏼 🥖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em outubro do ano passado, foi realizada a primeira conferência em nuvem Yandex Yandex Scale. Anunciou o lançamento de muitos novos serviços, incluind...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Internet das coisas no Yandex.Cloud: como os serviços de funções do Yandex IoT Core e Yandex Cloud são organizados</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/491740/"><img src="https://habrastorage.org/webt/wf/_u/zo/wf_uzobkj9vxp2ddkzxzux7lhbo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em outubro do ano passado, foi realizada a primeira conferência em nuvem Yandex Yandex Scale. Anunciou o lançamento de muitos novos serviços, incluindo o Yandex IoT Core, que permite trocar dados com milhões de dispositivos IoT. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste artigo, falarei sobre por que o Yandex IoT Core é necessário e como ele funciona, bem como como ele pode interagir com outros serviços Yandex. Você aprenderá sobre a arquitetura, os meandros da interação dos componentes e os recursos da implementação da funcionalidade - tudo isso o ajudará a otimizar o uso desses serviços.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, vamos relembrar as principais vantagens das nuvens públicas e do PaaS - reduzindo o tempo e os custos de desenvolvimento, bem como os custos de suporte e infraestrutura, que também são relevantes para projetos de IoT. Mas existem alguns recursos úteis menos óbvios que você pode acessar na nuvem. Esse dimensionamento eficaz e tolerância a falhas são aspectos importantes ao trabalhar com dispositivos, especialmente em projetos de infraestrutura de informações críticas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escala eficaz é a capacidade de aumentar ou diminuir livremente o número de dispositivos sem enfrentar problemas técnicos e observar uma mudança previsível no custo do sistema após as alterações.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tolerância a falhas é a confiança de que os serviços são projetados e implantados de forma a garantir o desempenho mais alto possível, mesmo no caso de uma falha de alguns recursos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos entrar em detalhes.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arquitetura de script IoT</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro de tudo, vamos ver como é a arquitetura geral do script da IoT. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z_/po/yk/z_poykwjdwprirjgwkxmkvjnq0o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Duas partes grandes podem ser distinguidas:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O primeiro é a entrega de dados para o armazenamento e a entrega de comandos para os dispositivos. </font><font style="vertical-align: inherit;">Quando você constrói um sistema de IoT, essa tarefa deve ser resolvida em qualquer caso, independentemente do projeto que você faz.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O segundo está trabalhando com os dados recebidos. </font><font style="vertical-align: inherit;">Tudo é semelhante a qualquer outro projeto baseado na análise e visualização de conjuntos de dados. </font><font style="vertical-align: inherit;">Você tem um repositório com uma matriz inicial de informações, trabalhando com a qual permitirá realizar sua tarefa.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira parte é aproximadamente a mesma em todos os sistemas de IoT: ela é baseada em princípios gerais e se encaixa em um cenário comum adequado para a maioria dos sistemas de IoT. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A segunda parte é quase sempre única em termos de funções executadas, embora seja construída sobre componentes padrão. Ao mesmo tempo, sem um sistema de interação de alta qualidade, tolerante a falhas e escalável com hardware, a eficácia da parte analítica da arquitetura é reduzida a quase zero, porque simplesmente não há nada a analisar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É por isso que a equipe do Yandex.Cloud decidiu, em primeiro lugar, concentrar-se na criação de um ecossistema conveniente de serviços que entregaria dados de maneira rápida, eficiente e confiável, dos dispositivos aos armazenamentos, e vice-versa - enviar comandos aos dispositivos.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tq/k8/ug/tqk8ugcmjnp3-s3cscc4ldhmuou.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para resolver esses problemas, estamos trabalhando na funcionalidade e integração dos serviços Yandex IoT Core, Yandex Functions e armazenamento de dados na nuvem: </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O serviço Yandex IoT Core é um broker MQTT escalonável e seguro para falhas de vários inquilinos com um conjunto de funções úteis adicionais.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O serviço Yandex Cloud Functions é um representante da direção promissora sem servidor e permite que você execute seu código como uma função em um ambiente seguro, tolerante a falhas e escalável automaticamente sem criar e manter máquinas virtuais.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Yandex Object Storage é um armazenamento eficaz de grandes matrizes de dados e é muito adequado para registros de arquivamento "históricos".</font></font></li>
<li>          ,    ,      Yandex Managed Service for ClickHouse,     «»  .       «»      ,       ,     ,             .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se os serviços de armazenamento e análise de dados são serviços de "uso geral" já escritos sobre muito, o Yandex IoT Core e sua interação com o Yandex Cloud Functions geralmente causam muitas perguntas, especialmente para pessoas que estão começando a entender a Internet sobre coisas e tecnologias em nuvem. </font><font style="vertical-align: inherit;">E como esses serviços oferecem tolerância a falhas e redimensionamento do trabalho com dispositivos, veremos primeiro o que eles têm sob o capô.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o Yandex IoT Core funciona</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Yandex IoT Core é um serviço de plataforma especializado para troca de dados bidirecional entre a nuvem e os dispositivos que executam o protocolo MQTT. De fato, esse protocolo se tornou o padrão para a transferência de dados para a IoT. Ele usa o conceito de filas nomeadas (tópicos), onde, por um lado, é possível gravar dados e, por outro lado, recebê-los de forma assíncrona, assinando os eventos dessa fila. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O serviço Yandex IoT Core é multilocatário, o que significa uma única entidade acessível a todos os usuários. Ou seja, todos os dispositivos e todos os usuários interagem com a mesma instância de serviço.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso permite, por um lado, garantir uniformidade de trabalho para todos os usuários, por outro lado, escala eficaz e tolerância a falhas, a fim de manter uma conexão com um número ilimitado de dispositivos e processar uma quantidade ilimitada de dados em volume e velocidade. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daqui resulta que o serviço deve ter mecanismos de redundância e capacidade de gerenciar de forma flexível os recursos utilizados - para responder às alterações de carga. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, a multilocação exige uma lógica especial de compartilhamento de direitos de acesso aos tópicos do MQTT. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos ver como isso é implementado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como muitos outros serviços Yandex.Cloud, o Yandex IoT Core é logicamente dividido em duas partes - Plano de Controle e Plano de Dados:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8a/u0/f3/8au0f3pzmwa1v-hhsxikvo_l_0m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Data Plane é responsável pela lógica de operação sob o protocolo MQTT e o Control Plane é responsável por delimitar os direitos de acesso a determinados tópicos e usa o registro e o dispositivo de entidades lógicas para esse fim. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eu/b1/1n/eub11nm0nlmhprrhfqzohfwcyow.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada usuário do Yandex.Cloud pode ter vários registros, cada um dos quais pode conter seu próprio subconjunto de dispositivos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O acesso aos tópicos é fornecido da seguinte maneira: Os </font></font><br>
<br>
<img src="https://habrastorage.org/webt/df/wc/hd/dfwchdy-bdwxs56mkgykrcs0ia4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dispositivos podem enviar dados apenas para o tópico de eventos e o evento de registro:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/events</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
e assine apenas mensagens do seu tópico de comandos e do tópico de comandos do registro:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/commands</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O registro pode enviar dados para todos os tópicos de comandos do dispositivo e para o tópico de comandos do registro:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device2</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/commands</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
e assine mensagens de todos os tópicos de eventos do dispositivo e o tópico de eventos do registro:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device2</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/events</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para trabalhar com todas as entidades descritas acima, o Data Plane possui um protocolo gRPC e um protocolo REST, com base no qual o acesso é implementado por meio do console da GUI do Yandex.Cloud e da interface da linha de comandos da CLI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quanto ao Data Plane, ele suporta o protocolo MQTT versão 3.1.1. </font><font style="vertical-align: inherit;">No entanto, existem vários recursos:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao conectar, certifique-se de usar o TLS.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somente conexão TCP é suportada. </font><font style="vertical-align: inherit;">O WebSocket ainda não está disponível.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A autorização está disponível por login e senha (em que o login é o ID do dispositivo ou registro, e as senhas são definidas pelo usuário) e usando certificados.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O sinalizador Reter não é suportado, ao usar o qual o broker do MQTT salva a mensagem marcada com o sinalizador e a envia na próxima vez que você assina o tópico.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Sessão Persistente não é suportada, na qual o broker do MQTT salva informações sobre o cliente (dispositivo ou registro) para facilitar a reconexão.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com a assinatura e publicação, apenas os dois primeiros níveis de serviço são suportados:</font></font><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoS0 - No máximo uma vez. </font><font style="vertical-align: inherit;">Não há garantia de entrega, mas não há devolução da mesma mensagem.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoS1 - pelo menos uma vez. </font><font style="vertical-align: inherit;">A entrega é garantida, mas há uma chance de receber novamente a mesma mensagem.</font></font></li>
</ol></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para simplificar a conexão com o Yandex IoT Core, adicionamos regularmente novos exemplos para diferentes plataformas e idiomas ao nosso repositório no GitHub, e também descrevemos scripts na documentação. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A arquitetura do serviço é assim: A </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6g/ig/4o/6gig4ofj7dksmbn18wvq5swkpuo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lógica de negócios do serviço inclui quatro partes:</font></font><br>
<br>
<ol>
<li> Device management —     .   Control Plane.</li>
<li> MQTT Broker —  MQTT-.  Data Plane.</li>
<li> Triggers —     Yandex Cloud Functions.  Data Plane.</li>
<li> Shards —      MQTT-    .  Data Plane.</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toda interação com o "mundo exterior" passa por balanceadores de carga. Além disso, de acordo com a filosofia de alimentação de cães, o Yandex Load Balancer é usado, disponível para todos os usuários do Yandex.Cloud. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada parte da lógica de negócios consiste em vários conjuntos de três máquinas virtuais - uma em cada zona de disponibilidade (nos Esquemas A, B e C). Máquinas virtuais são exatamente iguais a todos os usuários do Yandex.Cloud. Quando a carga aumenta, o dimensionamento ocorre com a ajuda de todo o conjunto - três máquinas são adicionadas ao mesmo tempo na estrutura de uma parte da lógica de negócios. Isso significa que, se um conjunto de três máquinas MQTT Broker não puder manipular a carga, outro conjunto de três máquinas MQTT Broker será incluído, enquanto a configuração de outras partes da lógica de negócios permanecerá a mesma.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E apenas o Logbroker não está disponível ao público. É um serviço para operação eficiente e à prova de falhas com fluxos de dados. Ele é baseado no Apache Kafka, mas possui muitas outras funções úteis: implementa processos de recuperação de desastres (incluindo exatamente a semântica única quando você tem uma garantia de entrega de mensagens sem duplicação) e processos de serviço (como replicação entre centros, distribuição de dados para clusters de cálculo) e também possui um mecanismo para distribuição uniforme e não duplicada de dados entre os assinantes de fluxo - uma espécie de balanceador de carga. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os recursos de gerenciamento de dispositivos no Plano de controle estão descritos acima. Mas com o Data Plane, tudo é muito mais interessante.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada instância do MQTT Broker funciona independentemente e não sabe nada sobre outras instâncias. Todos os dados recebidos (publicação dos clientes) são enviados pelos corretores para a Logbroker, de onde são coletados pelos Shards and Triggers. E é nos shards que a sincronização ocorre entre instâncias de corretores. Os shards conhecem todos os clientes MQTT e a distribuição de suas assinaturas (assinatura) entre instâncias de intermediários MQTT e determinam para onde enviar os dados recebidos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, o cliente MQTT A é inscrito no tópico do intermediário A e o cliente MQTT B é inscrito no mesmo tópico do intermediário B. Se o cliente MQTT C publica no mesmo tópico, mas no intermediário C, o shard transfere dados de intermediário C para os corretores A e B, como resultado dos quais os dados serão recebidos pelos clientes MQTT A e MQTT B.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ia/dv/dz/iadvdzgd2cs6o1r3stjkqfhsq6y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A última parte da lógica de negócios, Triggers, também recebe todos os dados recebidos dos clientes MQTT e, se isso estiver configurado pelo usuário, transfere-os para os acionadores do serviço Yandex Cloud Functions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você pode ver, o Yandex IoT Core possui uma arquitetura e lógica de trabalho bastante complicadas, difíceis de repetir em instalações locais. </font><font style="vertical-align: inherit;">Isso permite que ele resista à perda de até duas das três zonas de disponibilidade e elabore um número ilimitado de conexões e volumes de dados ilimitados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, toda essa lógica está oculta do usuário "por baixo do capô", mas do lado de fora tudo parece muito simples - como se você estivesse trabalhando com um único broker MQTT.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acionadores e funções da nuvem Yandex</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Yandex Cloud Functions é um representante dos serviços "sem servidor" (sem servidor) no Yandex.Cloud. A principal essência desses serviços é que o usuário não gasta seu tempo configurando, implantando e dimensionando o ambiente para executar código, mas apenas lida com a coisa mais valiosa para ele - escrever o próprio código que executa a tarefa necessária. No caso de funções, esse é o chamado código sem estado atômico que pode ser acionado por algum evento. "Atômico" e "sem estado" significam que esse código deve executar uma tarefa relativamente pequena, mas integral, enquanto o código não deve usar nenhuma variável para armazenar valores entre as chamadas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem várias maneiras de chamar funções: uma chamada HTTP direta, uma chamada de timer (cron) ou uma assinatura de evento. Como o último, o serviço já suporta a inscrição em filas de mensagens (fila de mensagens Yandex), eventos gerados pelo serviço de armazenamento de objetos e (mais valioso para o cenário da IoT) a assinatura de mensagens no Yandex IoT Core.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apesar de você poder trabalhar com o Yandex IoT Core usando qualquer cliente compatível com MQTT, o Yandex Cloud Functions é uma das maneiras mais ótimas e convenientes de receber e processar dados. A razão para isso é muito simples. Uma função pode ser chamada em todas as mensagens recebidas de qualquer dispositivo, e as funções serão executadas paralelamente umas às outras (devido à atomicidade e à abordagem sem estado), e o número de suas chamadas mudará naturalmente à medida que o número de mensagens recebidas dos dispositivos for alterado. Assim, o usuário pode ignorar completamente os problemas de configuração da infraestrutura e, além disso, diferentemente das mesmas máquinas virtuais, o pagamento ocorrerá apenas pelo trabalho realmente executado.Isso permitirá que você economize significativamente em baixa carga e obtenha um custo claro e previsível com o crescimento.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O mecanismo para chamar funções em eventos (assinar eventos) é chamado de gatilho (Trigger). Sua essência está representada no diagrama: Um </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5u/yv/bn/5uyvbnyviueygxt4ykzdh9n2nug.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
serviço que gera eventos para chamar funções os coloca em uma fila no Logbroker. No caso do Yandex IoT Core, os gatilhos do Data Plane fazem isso. Além disso, esses eventos são realizados pelo pré-processador, que está procurando um registro no banco de dados para esse evento, indicando a função a ser chamada. Se uma entrada desse tipo for encontrada, o pré-processador coloca as informações sobre a chamada de função (ID da função e parâmetros de chamada) na fila no serviço Fila de Mensagens Yandex, de onde o manipulador de chamadas as coleta. O manipulador, por sua vez, envia uma solicitação HTTP para chamar a função para o serviço Yandex Cloud Functions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao mesmo tempo, novamente, de acordo com a filosofia dogfooding, o serviço Yandex Message Queue, acessível a todos os usuários, é usado e as funções são chamadas exatamente da mesma maneira que qualquer outro usuário pode chamar suas funções. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Digamos algumas palavras sobre a fila de mensagens Yandex. Apesar de esse, como o Logbroker, ser um serviço de fila, há uma diferença significativa entre eles. Ao processar mensagens de filas, o manipulador informa a fila que terminou e a mensagem pode ser excluída. Esse é um importante mecanismo de confiabilidade em tais serviços, mas complica a lógica de trabalhar com mensagens.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A Fila de mensagens Yandex permite "paralelizar" o processamento de cada mensagem na fila. Em outras palavras, a mensagem da fila que está sendo processada atualmente não bloqueia a possibilidade de outro "encadeamento" pegar o próximo evento da fila para processamento. Isso é chamado simultaneidade no nível da mensagem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E o LogBroker opera em grupos de mensagens e, até que todo o grupo seja processado, o próximo grupo não poderá ser escolhido para processamento. Essa abordagem é chamada simultaneidade no nível da partição. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E é precisamente o uso da fila de mensagens Yandex que permite processar de forma rápida e eficiente em paralelo muitas solicitações para chamar uma função para eventos de um serviço específico.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apesar de os acionadores serem uma unidade independente separada, eles fazem parte do serviço Yandex Cloud Functions. Nós apenas temos que descobrir exatamente como as funções são chamadas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fb/ew/ke/fbewkedbrp6eyri7zkubwiu6dzu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todas as solicitações para chamar funções (externas e internas) se enquadram no balanceador de carga, que as distribui para roteadores em diferentes zonas de acesso (AZ), várias partes são implantadas em cada zona. Ao receber uma solicitação, o roteador vai primeiro ao serviço Gerenciador de Identidade e Acesso (IAM) para garantir que a origem da solicitação tenha direitos para chamar essa função. Ele então vira para o agendador e pergunta em qual trabalhador executar a função. Worker é uma máquina virtual com um tempo de execução personalizado de funções isoladas. Além disso, o roteador, tendo recebido do agendador o endereço do trabalhador no qual executar a função, envia um comando para esse trabalhador para iniciar a função com determinados parâmetros.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De onde vem o trabalhador? É aqui que toda a magia sem servidor acontece. Agendadores, analisando a carga (o número e a duração das funções), gerenciam (iniciam e param) máquinas virtuais com um tempo de execução específico. NodeJS e Python agora são suportados. E aqui um parâmetro é extremamente importante - a velocidade das funções de inicialização. A equipe de desenvolvimento de serviços fez um ótimo trabalho e agora a máquina virtual inicia no máximo 250 ms, enquanto usa o ambiente mais seguro para isolar funções uma da outra - a virtualização QEMU, que executa todo o Yandex. Ao mesmo tempo, se já houver um trabalhador ativo para a solicitação recebida, a função será iniciada quase instantaneamente.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E, de acordo com a mesma abordagem de dogfooding, o Load Balancer usa um serviço público acessível a todos os usuários, e o trabalhador, o planejador e o roteador são máquinas virtuais comuns, iguais a todos os usuários. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, a tolerância a falhas do serviço é implementada no nível do balanceador de carga e redundância dos principais componentes do sistema (roteador e planejador), e o dimensionamento ocorre devido à implantação ou redução do número de trabalhadores. </font><font style="vertical-align: inherit;">Além disso, cada zona de acessibilidade funciona de forma independente, o que permite sobreviver à perda de até duas das três zonas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links Úteis</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Concluindo, desejo fornecer alguns links que permitirão estudar os serviços com mais detalhes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Núcleo de IoT do Yandex: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloud.yandex.ru/services/iot-core</font></font></a> </li>
<li> Yandex Cloud Functions: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cloud.yandex.ru/services/functions</a> </li>
<li> Yandex Message Queue: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cloud.yandex.ru/services/message-queue</a> </li>
<li> Yandex Managed Service for ClickHouse: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cloud.yandex.ru/services/managed-clickhouse</a> </li>
<li> Yandex Load Balancer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cloud.yandex.ru/services/load-balancer</a> </li>
<li> Yandex Object Storage: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cloud.yandex.ru/services/storage</a> </li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt491724/index.html">O livro "Laravel. Guia completo. 2ª edição</a></li>
<li><a href="../pt491726/index.html">Expandir colunas aninhadas - listas usando a linguagem R (pacote tidyr e funções da família unnest)</a></li>
<li><a href="../pt491728/index.html">Princípio DRY com o Laravel</a></li>
<li><a href="../pt491732/index.html">Existe vida após o Scratch ou como introduzir uma criança no Python</a></li>
<li><a href="../pt491736/index.html">TMS1000: o primeiro microcontrolador disponível comercialmente</a></li>
<li><a href="../pt491742/index.html">Sherbet: teclado ergonômico para jogos</a></li>
<li><a href="../pt491744/index.html">Hackers iranianos exploraram vulnerabilidades na VPN</a></li>
<li><a href="../pt491746/index.html">A história da síntese da fala: a era das soluções elétricas</a></li>
<li><a href="../pt491748/index.html">Tecnologias que ajudam os cegos a aprender inglês</a></li>
<li><a href="../pt491750/index.html">Escrevemos melhor a pesquisa por substring do que nos livros didáticos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>