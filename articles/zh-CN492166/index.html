<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👢 🕳️ 😡 Android上的小部件。难得的功能 👩🏻‍🔧 🤘🏽 🤼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！我叫Alexander Khakimov，我是FINCH的一名Android开发人员。
 
 碰巧您的设计是针对iOS的，而您不得不将其改编成适用于android的软件吗？如果是这样，您的设计师是否经常使用小部件？不幸的是，对于许多开发人员来说，小部件很少见，因为很少有人使用它。
 
 在本...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Android上的小部件。难得的功能</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492166/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈Ha！</font><font style="vertical-align: inherit;">我叫Alexander Khakimov，我是FINCH的一名Android开发人员。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
碰巧您的设计是针对iOS的，而您不得不将其改编成适用于android的软件吗？</font><font style="vertical-align: inherit;">如果是这样，您的设计师是否经常使用小部件？</font><font style="vertical-align: inherit;">不幸的是，对于许多开发人员来说，小部件很少见，因为很少有人使用它。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我将详细介绍如何创建一个小部件，值得关注并分享我的案例。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小部件创建</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要创建小部件，您需要了解以下内容：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小部件组件的功能。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在屏幕网格中显示小部件的功能。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">功能部件更新。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将分别分析每个项目。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小部件组件的功能</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
任何至少使用过RemoteViews的开发人员都对此项目很熟悉。</font><font style="vertical-align: inherit;">如果您是其中之一，请继续进行下一个步骤。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RemoteViews旨在描述和管理属于另一个应用程序中的进程的View层次结构。</font><font style="vertical-align: inherit;">使用层次结构管理，您可以更改属于另一个应用程序的View的属性或调用方法。</font><font style="vertical-align: inherit;">RemoteViews包含标准android.widget组件库中的有限组件集。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在内部视图小部件中工作的过程是独立的（通常是主屏幕），因此，要更改小部件的UI，请使用在我们的应用程序中工作的BroadcastReceiver扩展-AppWidgetProvider。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在屏幕的“网格”中显示小部件的功能</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，如果您查看</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">官方指南</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这一点并不那么复杂</font><font style="vertical-align: inherit;">：</font></font><br>
 <blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个小部件都必须定义一个minWidth和minHeight，以指示默认情况下它应消耗的最小空间量。</font><font style="vertical-align: inherit;">当用户将小部件添加到其主屏幕时，它通常会占用比您指定的最小宽度和高度更多的空间。</font><font style="vertical-align: inherit;">Android主屏幕为用户提供了可用空间的网格，可以在其中放置小部件和图标。</font><font style="vertical-align: inherit;">该网格可能因设备而异。</font><font style="vertical-align: inherit;">例如，许多手机都提供4x4网格，而平板电脑可以提供更大的8x7网格。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
翻译成俄文：每个小部件都必须设置自己的最小宽度和高度，以表示默认情况下将占用的最小空间。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6r/p-/ux/6rp-uxyfekjzwlpantqmxkdfaio.png" alt="图片"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Android Studio中创建时的窗口小部件设置示例</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
添加到主屏幕的窗口小部件通常会占用比您设置的屏幕的最小宽度和高度更多的空间。 Android主屏幕为用户提供了可用空间的网格，可以在其中放置小部件和图标。该网格可能因设备而异；例如，许多手机提供4x4网格，而平板电脑可以提供8x4大型网格。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由此可见，设备的网格可以是任何东西，并且单元的大小可能会有所不同，具体取决于网格的大小。</font><font style="vertical-align: inherit;">因此，在设计小部件的内容时应牢记这些功能。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于给定的列数和行数，小部件的最小宽度和高度可以使用以下公式计算：</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
minSideSizeDp = 70×n-30，其中n是行数或列数</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。目前，您可以设置的最大最小网格为4x4。</font><font style="vertical-align: inherit;">这样可以确保您的窗口小部件将显示在所有设备上。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 功能部件更新</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于AppWidgetProvider本质上是BroadcastReceiver的扩展，因此您可以像使用常规BroadcastReceiver一样对其进行相同的操作。 AppWidgetProvider只需解析onReceive中接收到的Intent中的相应字段，然后使用接收到的附加函数调用拦截方法。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
困难之处在于更新内容的频率-整个问题在于iOS和Android上的小部件的内部操作有所不同。事实是，当小部件对用户可见时，iOS小部件上的数据会更新。在Android中，此类事件不存在。我们无法确定用户何时看到窗口小部件。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于Android上的小部件，建议的更新方法是计时器更新。</font><font style="vertical-align: inherit;">计时器设置由窗口小部件参数updatePeriodMillis设置。</font><font style="vertical-align: inherit;">不幸的是，此设置不允许每30分钟更新一次小部件。</font><font style="vertical-align: inherit;">下面我将更详细地讨论这一点。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小工具箱</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
进一步，我们将讨论在FINCH的大型彩票申请中的案例，以及Stoloto申请参加州彩票的案例。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该应用程序的任务是简化彩票的选择和彩票的购买并使用户透明。</font><font style="vertical-align: inherit;">因此，小部件所需的功能非常简单：向用户显示要购买的推荐游戏，然后点按以转到相应的游戏。</font><font style="vertical-align: inherit;">游戏列表在服务器上确定并定期更新。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的例子中，小部件设计包括两个状态：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于授权用户</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于未经授权的用户</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
授权用户需要显示其个人资料数据：内部钱包的状态，等待抽奖的彩票数量以及丢失的彩金。</font><font style="vertical-align: inherit;">对于这些元素中的每一个，都提供了到应用程序内部屏幕的过​​渡，与其他元素不同。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rp/d2/6i/rpd26ixtdxfjopibvmgaaczfkco.png" alt="图片"><br>
<br>
<img src="https://habrastorage.org/webt/dk/yy/qx/dkyyqxqcnopxezwhknrmqbuedgu.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可能已经注意到，授权用户的另一个功能是“刷新”按钮，但稍后会介绍更多。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了实现两种状态的显示，同时考虑到设计，我使用RemoteAdapter作为RemoteViewsService的实现来生成内容卡。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在有一些代码，以及里面的所有内容。</font><font style="vertical-align: inherit;">如果您已经有过使用窗口小部件的经验，那么您将知道窗口小部件数据的任何更新均以onUpdate方法开始：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onUpdate</span><span class="hljs-params">(
        context: <span class="hljs-type">Context</span>,
        appWidgetManager: <span class="hljs-type">AppWidgetManager</span>,
        appWidgetIds: <span class="hljs-type">IntArray</span>
    )</span></span> {<font></font>
        injector.openScope(<span class="hljs-keyword">this</span>, *arrayOf(<span class="hljs-keyword">this</span>))
        <span class="hljs-comment">// update each of the widgets with the remote adapter</span><font></font>
        appWidgetIds<font></font>
            .forEach {<font></font>
                updateWidget(context, appWidgetManager, it)<font></font>
          }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们正在为小部件的每个实例编写更新。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateWidget</span><span class="hljs-params">(
        context: <span class="hljs-type">Context</span>,
        appWidgetManager: <span class="hljs-type">AppWidgetManager</span>,
        appWidgetId: <span class="hljs-type">Int</span>
    )</span></span> {
<span class="hljs-comment">// remoteViews   widgetId</span>
        <span class="hljs-keyword">val</span> remoteViews = RemoteViews(<font></font>
            context.packageName,<font></font>
            R.layout.app_widget_layout<font></font>
...<font></font>
<span class="hljs-comment">//        </span><font></font>
...<font></font>
<span class="hljs-comment">//    remoteViews</span><font></font>
updateRemoteAdapter(context, remoteViews, appWidgetId)<font></font>
 <font></font>
<span class="hljs-comment">//   remoteViews </span><font></font>
appWidgetManager.updateAppWidget(appWidgetId, remoteViews)<font></font>
<span class="hljs-comment">// collection view  </span><font></font>
appWidgetManager.notifyAppWidgetViewDataChanged(<font></font>
            appWidgetId,<font></font>
            R.id.lvWidgetItems<font></font>
        )<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更新适配器。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateRemoteAdapter</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, remoteViews: <span class="hljs-type">RemoteViews</span>, appWidgetId: <span class="hljs-type">Int</span>)</span></span> {
<span class="hljs-comment">//   RemoteViewsService   RemoteAdapter   </span>
        <span class="hljs-keyword">val</span> adapterIntent = Intent(context, StolotoAppWidgetRemoteViewsService::<span class="hljs-keyword">class</span>.java).apply {<font></font>
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)<font></font>
        }<font></font>
        remoteViews.setRemoteAdapter(R.id.lvWidgetItems, adapterIntent)<font></font>
// actionIntent  pendingIntent      <font></font>
        <span class="hljs-keyword">val</span> actionIntent = Intent(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java).apply {<font></font>
            action = WIDGET_CLICK_ACTION<font></font>
            putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)<font></font>
        }<font></font>
        <span class="hljs-keyword">val</span> pendingIntent = PendingIntent.getBroadcast(<font></font>
            context, <span class="hljs-number">0</span>, actionIntent,<font></font>
            PendingIntent.FLAG_UPDATE_CURRENT<font></font>
        )<font></font>
<span class="hljs-comment">// pendingIntent      </span><font></font>
        remoteViews.setPendingIntentTemplate(R.id.lvWidgetItems, pendingIntent)<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们正在编写服务的实现。</font><font style="vertical-align: inherit;">在其中，对我们来说重要的是指出要使用哪种RemoteViewsService.RemoteViewsFactory接口的实现来生成内容。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StolotoAppWidgetRemoteViewsService</span> : <span class="hljs-type">RemoteViewsService</span></span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onGetViewFactory</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>)</span></span>: RemoteViewsFactory =<font></font>
        StolotoAppWidgetRemoteViewsFactory(<font></font>
            <span class="hljs-keyword">this</span>.applicationContext,<font></font>
            intent<font></font>
        )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这实际上是适配器的薄包装。</font><font style="vertical-align: inherit;">多亏了他，我们才能将我们的数据与远程集合视图相关联。</font><font style="vertical-align: inherit;">RemoteViewsFactory提供了为数据集中的每个项目生成RemoteView的方法。</font><font style="vertical-align: inherit;">构造函数没有要求-我要做的就是在其中传递上下文。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，简要介绍一下主要方法：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onCreate-创建适配器。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getLoadingView-该方法建议返回视图，系统将在创建视图时显示该视图，而不是列表项。</font><font style="vertical-align: inherit;">如果您在此处未创建任何内容，则系统将使用某些默认视图。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getViewAt-该方法建议创建列表项。</font><font style="vertical-align: inherit;">这是RemoteViews的标准用法。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">收到更新列表中数据的请求时，将调用onDataSetChanged。</font><font style="vertical-align: inherit;">那些。</font><font style="vertical-align: inherit;">在这种方法中，我们为列表准备数据。</font><font style="vertical-align: inherit;">通过执行繁重的长代码，该方法变得更加清晰。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当删除使用适配器的最后一个列表（一个适配器可以被多个列表使用）时，将调用onDestroy。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RemoteViewsFactory处于活动状态，而列表的所有实例均处于活动状态，因此我们可以在其中存储当前数据，例如，当前项目的列表。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定义将显示的数据列表：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> widgetItems = ArrayList&lt;WidgetItem&gt;()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建适配器时，我们开始加载数据。</font><font style="vertical-align: inherit;">在这里，您可以安全地执行任何困难的任务，包括安静地进入网络以阻止流量。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
        updateDataSync()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当调用命令更新数据时，我们也调用updateDataSync（）</font></font><br>
<br>
<pre><code class="kotlin hljs">   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDataSetChanged</span><span class="hljs-params">()</span></span> {<font></font>
        updateDataSync()<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在updateDataSync内部，一切也很简单。</font><font style="vertical-align: inherit;">我们清除了当前的物品清单。</font><font style="vertical-align: inherit;">下载个人资料和游戏数据。</font></font><br>
<br>
<pre><code class="kotlin hljs"> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateDataSync</span><span class="hljs-params">()</span></span> {<font></font>
        widgetItems.clear()<font></font>
        updateProfileSync()<font></font>
        updateGamesSync()<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里比较有趣</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateProfileSync</span><span class="hljs-params">()</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于仅向授权用户显示个人资料对我们很重要，因此在这种情况下，我们仅需要下载个人资料信息：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> isUserFullAuth = isUserFullAuthInteractor<font></font>
            .execute()<font></font>
            .blockingGet()<font></font>
        <span class="hljs-keyword">if</span> (isUserFullAuth) {
            <span class="hljs-keyword">val</span> profile = getWidgetProfileInteractor<font></font>
                .execute()<font></font>
                .onErrorReturn {<font></font>
                    WidgetProfile()<font></font>
<span class="hljs-comment">//           </span><font></font>
                }<font></font>
                .blockingGet()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WidgetProfile模型是从不同来源组装而成的，因此其收货逻辑及其默认值的排列方式为负的钱包值表示数据不正确或收货有问题。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于业务逻辑，缺少钱包数据至关重要，因此，如果钱包不正确，将不会创建配置文件模型并将其添加到项目列表中。</font></font><br>
<br>
<pre><code class="kotlin hljs">  <span class="hljs-keyword">if</span> (profile.walletAmount &gt;= <span class="hljs-number">0L</span>) {<font></font>
                widgetItems.add(<font></font>
                    WidgetItem.Profile(<font></font>
                        wallet = profile.walletAmount.toMoneyFormat(),<font></font>
                        waitingTickets = <span class="hljs-keyword">if</span> (profile.waitingTicketsCount &gt;= <span class="hljs-number">0</span>) profile.waitingTicketsCount.toString() <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>,<font></font>
                        unpaidPrizeAmount = <span class="hljs-keyword">if</span> (profile.unpaidPrizeAmount &gt;= <span class="hljs-number">0</span>) profile.unpaidPrizeAmoount.toMoneyFormat() <span class="hljs-keyword">else</span> <span class="hljs-string">""</span><font></font>
                    )<font></font>
                )<font></font>
            }<font></font>
        }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
updateGamesSync（）方法使用getWidgetGamesInteractor，并将与该小部件相关的一组游戏添加到widgetItems列表中。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在继续生成卡片之前，请更详细地考虑WidgetItem模型。</font><font style="vertical-align: inherit;">它通过kotlin密封类实现，从而使模型更灵活，并且使用起来更方便。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetItem</span> </span>{<font></font>
 <font></font>
    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Profile</span></span>(
        <span class="hljs-keyword">val</span> wallet: String,
        <span class="hljs-keyword">val</span> waitingTickets: String,
        <span class="hljs-keyword">val</span> unpaidPrizeAmount: String<font></font>
    ) : WidgetItem()<font></font>
 <font></font>
    <span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span></span>(
        <span class="hljs-keyword">val</span> id: String,
        <span class="hljs-keyword">val</span> iconId: <span class="hljs-built_in">Int</span>,
        <span class="hljs-keyword">val</span> prizeValue: String,
        <span class="hljs-keyword">val</span> date: String<font></font>
    ) : WidgetItem()<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建RemoteViews并通过FillInIntent确定它们的响应</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getViewAt</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span>: RemoteViews {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> item = widgetItems[position]) {
            <span class="hljs-keyword">is</span> WidgetItem.Profile -&gt; {<font></font>
              RemoteViews(<font></font>
                        context.packageName,<font></font>
                        R.layout.item_widget_user_profile<font></font>
                    ).apply {<font></font>
                        setTextViewText(R.id.tvWidgetWalletMoney, item.wallet)<font></font>
                        setTextViewText(R.id.tvWidgetUnpaidCount, item.unpaidPrizeAmount)<font></font>
                        setTextViewText(R.id.tvWidgetWaitingCount, item.waitingTickets)<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileWallet, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_USER_WALLET<font></font>
                            )<font></font>
                        )<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileUnpaid, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_UNPAID_PRIZE<font></font>
                            )<font></font>
                        )<font></font>
                        setOnClickFillInIntent(<font></font>
                            R.id.llWidgetProfileWaiting, Intent().putExtra(<font></font>
                                StolotoAppWidgetProvider.KEY_PROFILE_OPTIONS,<font></font>
                                StolotoAppWidgetProvider.VALUE_WAITING_TICKETS<font></font>
                            )<font></font>
                        )<font></font>
                    }<font></font>
 <font></font>
            <span class="hljs-keyword">is</span> WidgetItem.Game -&gt; {<font></font>
                RemoteViews(<font></font>
                    context.packageName,<font></font>
                    R.layout.item_widget_game<font></font>
                ).apply {<font></font>
                    setImageViewResource(R.id.ivWidgetGame, item.iconId)<font></font>
                    setTextViewText(R.id.tvWidgetGamePrize, item.prizeValue)<font></font>
                    setTextViewText(R.id.tvWidgetGameDate, item.date)<font></font>
                    setOnClickFillInIntent(<font></font>
                        R.id.llWidgetGame, Intent().putExtra(<font></font>
                            StolotoAppWidgetProvider.KEY_GAME_CLICK, item.id<font></font>
                        )<font></font>
                    )<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
setOnClickFillInIntent方法分配指定的viewId意图，该意图将与父PendingIntent结合使用，以确定在单击带有该viewId的视图时的行为。</font><font style="vertical-align: inherit;">这样，我们可以响应WidgetProvider中的用户点击。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手动小部件更新</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们为小部件设置了半小时的更新时间。您可以更频繁地更新它，例如，通过与WorkManager跳舞，但是为什么要加载网络和电池？在开发的早期阶段，这种行为似乎是足够的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当“企业”注意到用户查看窗口小部件时，一切都改变了，无关的数据显示在上面：“在iPhone上，我打开窗口小部件，并且我的配置文件中有最新鲜的数据。” </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种情况很常见：iOS会为每个小部件显示生成新的卡片，因为这会产生特殊的屏幕，而Android原则上不会为小部件产生此类事件。我不得不考虑到某些彩票每15分钟举行一次，因此小部件应提供最新信息-您想参加某种抽奖，但已经过去了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了摆脱这种不愉快的情况并以某种方式解决更新数据的问题，我提出并实施了经过时间考验的解决方案-“更新”按钮。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将此按钮添加到带有列表的布局布局中，并在调用updateWidget时初始化其行为。</font></font><br>
<br>
<pre><code class="kotlin hljs">...
<span class="hljs-comment">// Intent   AppWidgetManager.ACTION_APPWIDGET_UPDATE</span>
<span class="hljs-keyword">val</span> intentUpdate = Intent(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java)<font></font>
intentUpdate.action = AppWidgetManager.ACTION_APPWIDGET_UPDATE<font></font>
<font></font>
//    <font></font>
<span class="hljs-keyword">val</span> ids = AppWidgetManager.getInstance(context)<font></font>
   .getAppWidgetIds(ComponentName(context, StolotoAppWidgetProvider::<span class="hljs-keyword">class</span>.java))<font></font>
intentUpdate.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, ids)<font></font>
<font></font>
//  intent  PendingIntent,  PendingIntent.getBroadcast()<font></font>
<span class="hljs-keyword">val</span> pendingUpdate = PendingIntent.getBroadcast(<font></font>
   context,<font></font>
   appWidgetId,<font></font>
   intentUpdate,<font></font>
   PendingIntent.FLAG_UPDATE_CURRENT<font></font>
)<font></font>
//  pendingIntent      ‘’<font></font>
remoteViews.setOnClickPendingIntent(R.id.ivWidgetRefresh, pendingUpdate)<font></font>
…</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初的发展显示出令人沮丧的景象：从按下“更新”按钮到实际更新，可能需要几秒钟的时间。</font><font style="vertical-align: inherit;">尽管小部件是由我们的应用程序生成的，但实际上它是在系统的控制之下，并通过广播与我们的应用程序进行通信。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
那些。</font><font style="vertical-align: inherit;">当您单击窗口小部件的“更新”按钮时，链开始：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在onReceive提供程序的“操作”中获取Intent。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppWidgetManager.ACTION_APPWIDGET_UPDATE。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为intent-e中指定的所有widgetsId调用onUpdate。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在线获取新数据。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">刷新本地数据并显示新的列表卡。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，更新窗口小部件看起来不是很好，因为通过单击按钮，我们观察了同一窗口小部件几秒钟。</font><font style="vertical-align: inherit;">目前尚不清楚数据是否已更新。</font><font style="vertical-align: inherit;">如何解决视觉反应问题？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我添加了isWidgetLoading标志，可通过交互器进行全局访问。</font><font style="vertical-align: inherit;">此参数的作用非常简单-加载小部件数据时不要显示刷新按钮。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其次，我将工厂中的数据加载过程分为三个阶段：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadingStep</span> </span>{<font></font>
   START,<font></font>
   MIDDLE,<font></font>
   END<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
开始-开始下载。</font><font style="vertical-align: inherit;">在此阶段，所有适配器视图和全局下载标志的状态更改为“正在加载”。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MIDDLE-主数据加载阶段。</font><font style="vertical-align: inherit;">它们下载后，全局下载标志置于“已加载”状态，并且已下载的数据显示在适配器中。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
END-下载结束。</font><font style="vertical-align: inherit;">在此步骤中，适配器不需要更改适配器数据。</font><font style="vertical-align: inherit;">需要此步骤才能正确处理WidgetProvider中视图的更新阶段。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们详细了解按钮更新在提供程序中的外观：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">if</span> (isFullAuthorized &amp;&amp; !widgetLoadingStateInteractor.isWidgetLoading) {<font></font>
   remoteViews.setViewVisibility(R.id.ivWidgetRefresh, View.VISIBLE)<font></font>
...<font></font>
<span class="hljs-comment">//     ,    </span><font></font>
...   <font></font>
} <span class="hljs-keyword">else</span> {<font></font>
   remoteViews.setViewVisibility(<font></font>
       R.id.ivWidgetRefresh,<font></font>
       <span class="hljs-keyword">if</span> (isFullAuthorized) View.INVISIBLE <span class="hljs-keyword">else</span> View.GONE <span class="hljs-comment">//       .</span><font></font>
   )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在让我们看一下适配器中发生的情况：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateDataSync</span><span class="hljs-params">()</span></span> {
   <span class="hljs-keyword">when</span> (loadingStep) {<font></font>
       START -&gt; {<font></font>
           widgetItems.forEach { it.isLoading = <span class="hljs-literal">true</span> }<font></font>
           widgetLoadingStateInteractor.isWidgetLoading = <span class="hljs-literal">true</span><font></font>
           loadingStep = MIDDLE<font></font>
           widgetManager.updateWidgets()<font></font>
       }<font></font>
       MIDDLE -&gt; {<font></font>
           widgetItems.clear()<font></font>
           updateProfileSync()<font></font>
           updateGamesSync()<font></font>
           widgetLoadingStateInteractor.isWidgetLoading = <span class="hljs-literal">false</span><font></font>
           loadingStep = END<font></font>
           widgetManager.updateWidgets()<font></font>
       }<font></font>
       END -&gt; {<font></font>
           loadingStep = START<font></font>
       }<font></font>
   }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/bq/ah/hg/bqahhgnwugy10345-bcegnupxo8.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
工作逻辑： </font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在START和MIDDLE步骤的最后，我调用updateWidgets方法以更新提供程序管理的视图状态。</font></font></li>
<li>   START     «»   ,    MIDDLE.</li>
<li>         MIDDLE,    «».</li>
<li>   MIDDLE,          END. </li>
<li>      ,   END,    «».        ,    END   loadingStep  START.</li>
</ol><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种实现的帮助下，我在“业务”看到小部件上的实际数据的需求与过于频繁地“拉”更新的需求之间达成了折衷。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我希望这篇文章对您有用。</font><font style="vertical-align: inherit;">如果您有创建Android小部件的经验，请在评论中告诉我们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
祝好运</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN492150/index.html">完全实施。Di-in-js</a></li>
<li><a href="../zh-CN492154/index.html">ExoMars的发射推迟到2022年的下一个发射窗口</a></li>
<li><a href="../zh-CN492156/index.html">减去。想。做</a></li>
<li><a href="../zh-CN492162/index.html">眼接口。Yandex中的报告</a></li>
<li><a href="../zh-CN492164/index.html">通向天堂或未来城市的门户</a></li>
<li><a href="../zh-CN492168/index.html">开源软件最大门户网站的后端开发的前端工作：共享经验</a></li>
<li><a href="../zh-CN492172/index.html">Linux文件系统的精简备份。如何在20秒内创建三TB的MySQL DBMS的工作副本</a></li>
<li><a href="../zh-CN492174/index.html">无线DIY土壤水分监测仪</a></li>
<li><a href="../zh-CN492178/index.html">七千像素的路径：显示器分辨率的演变和我们的要求</a></li>
<li><a href="../zh-CN492182/index.html">Microsoft Teams的信息安全基础知识</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>