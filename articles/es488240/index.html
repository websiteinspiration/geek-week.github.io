<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçà üç∏ ‚òòÔ∏è Un ciclo interminable que no fue: la historia del bicho del Santo Grial üêè üß† üßõüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hab√≠a una vez un juego para GBA llamado Hello Kitty Collection: Miracle Fashion Maker. Fue un lindo juego basado en la famosa franquicia de Sanrio Hel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Un ciclo interminable que no fue: la historia del bicho del Santo Grial</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488240/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hab√≠a una vez un juego para GBA llamado Hello Kitty Collection: Miracle Fashion Maker. Fue un lindo juego basado en la famosa franquicia de Sanrio Hello Kitty y desarrollado por Imagineer. Pero bajo la apariencia de un nombre aparentemente inocente era un problema insidioso. Por alguna raz√≥n, este sencillo juego no se ejecut√≥ en ning√∫n emulador de GBA. Pero esto por s√≠ solo no ser√≠a suficiente para llamar al problema un error del Santo Grial. Como todos los errores del Santo Grial, este error en s√≠ mismo era completamente confuso. La explicaci√≥n era simple: en alg√∫n momento de la secuencia de lanzamiento del juego, cay√≥ en un ciclo del que nunca </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sali√≥</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , esperando que un cierto valor se lea desde una memoria que </font><em><font style="vertical-align: inherit;">no existe</font></em><font style="vertical-align: inherit;"> . Aunque hay errores similares en muchos juegos, por ejemplo, en la introducci√≥n popular</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Legend of Zelda: The Minish Cap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , conf√≠an en un comportamiento especial causado por la lectura de direcciones de memoria no v√°lidas. </font><font style="vertical-align: inherit;">Pero este ciclo parec√≠a violar tal comportamiento. </font><font style="vertical-align: inherit;">Sin embargo, el juego funcion√≥ en equipos reales. </font><font style="vertical-align: inherit;">Adem√°s, se produjo exactamente el mismo error al cargar una partida guardada en Sonic Pinball Party despu√©s de un reinicio en fr√≠o. </font><font style="vertical-align: inherit;">¬øPodr√≠a la expectativa de estas direcciones de memoria no v√°lidas ser de alguna manera err√≥nea? </font><font style="vertical-align: inherit;">Pero si es as√≠, ¬øc√≥mo?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/c85/547/1b0c8554787a8e54e1ac5c21c78d639c.png"></div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero esto es ilegal, ¬øverdad?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espera un minuto: si est√°s intentando acceder a una memoria no v√°lida, entonces el juego solo necesita bloquearse, ¬øverdad? Debe ocurrir una operaci√≥n no resuelta, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segfault</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> u otro error. ¬øDerecha? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno, es m√°s como s√≠. Pero no realmente. Al menos no en el GBA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la arquitectura de los procesadores ARM que se usaron en GBA, este estado err√≥neo se denomina cancelaci√≥n de datos y ocurre solo cuando intenta acceder a la memoria para la cual el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">administrador de memoria</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">ha</font></a><font style="vertical-align: inherit;"> asignado el permiso de lectura </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cuando se produce la cancelaci√≥n de datos, el procesador completa lo que estaba haciendo y pasa al </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector de excepci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asignado a excepciones de cancelaci√≥n de datos. Luego, el sistema operativo puede elegir una de las soluciones: eliminar el proceso actual, asignar memoria de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falla de p√°gina</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dejar que el proceso maneje la situaci√≥n, ya que algunos emuladores JIT lo hacen con "fastmem", o realizar otras acciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øC√≥mo maneja el GBA el aborto de datos? La entrada del vector de excepci√≥n para la anulaci√≥n de datos se encuentra en la ROM de arranque de la consola GBA (o, como tambi√©n se le llama, en el BIOS). Si el GBA encuentra aborto de datos, entonces trata de ir al controlador DACS </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si existe, de lo contrario se produce el bloqueo. </font><font style="vertical-align: inherit;">Ning√∫n juego comercial tiene controladores DACS. </font><font style="vertical-align: inherit;">Entonces, ¬øpor qu√© este juego no se congela? </font><font style="vertical-align: inherit;">Todo es muy simple: GBA nunca genera aborto de datos. </font><font style="vertical-align: inherit;">No tiene un administrador de memoria (MMU) (o incluso una unidad de protecci√≥n de memoria, como en DS), por lo que simplemente sigue funcionando y lee la memoria no v√°lida.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El bus de memoria entra en escena.</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f75/dd9/55f/f75dd955f33d3a974b417f401fe054a6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øQu√© es la memoria no v√°lida en general? ¬øC√≥mo se ve ella? Este es el principal inconveniente. Esta es una situaci√≥n dif√≠cil: lo que lee el c√≥digo depende en gran medida de lo que hizo recientemente la CPU o, m√°s precisamente, de lo que hizo recientemente el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bus de memoria</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En resumen, al acceder a una memoria no v√°lida, la CPU lee lo que fue el √∫ltimo en el bus de memoria. Para entender lo que sigue de esto, debe aprender un poco sobre el bus de memoria y c√≥mo funciona.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un bus de memoria es parte de un circuito electr√≥nico que conecta la CPU a todos los componentes de memoria de la plataforma. En el GBA, varios dispositivos est√°n conectados al bus de memoria: RAM de trabajo, memoria de video y el bus de cartucho. Cuando la CPU intenta acceder a la memoria, le dice al bus de memoria a qu√© direcci√≥n necesita acceder, y luego se activa el componente correspondiente a esa direcci√≥n. Luego, el componente coloca el valor en esta direcci√≥n en el bus, que puede tomar varios </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ciclos </font><font style="vertical-align: inherit;">, y luego la CPU finalmente puede leer el valor del bus. En el caso del GBA, si no hay ning√∫n equipo asociado con la direcci√≥n, entonces no se escribe ning√∫n valor en el bus, y la CPU lee cualquier valor colocado en </font><em><font style="vertical-align: inherit;">√∫ltimo lugar</font></em><font style="vertical-align: inherit;"> en el bus</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La situaci√≥n puede variar de varias maneras, por ejemplo, si la lectura fue de 16 bits y la CPU intenta realizar una lectura de 32 bits, pero en general siempre ser√° un valor del bus. </font><font style="vertical-align: inherit;">Los desarrolladores llaman a esta caracter√≠stica "bus abierto". </font><font style="vertical-align: inherit;">Anteriormente, escrib√≠ c√≥mo afecta a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">otros juegos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, parece que todo no se ve tan mal ... ¬øverdad?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, ¬øpuedes guardar en cach√© el √∫ltimo acceso a la memoria? ¬øY luego traerlo de nuevo? En el caso general, este enfoque funcionar√°, pero existen ciertas dificultades. Primero, debe asegurarse de que todas las operaciones de acceso a la memoria est√©n en el orden correcto. Esto es m√°s complicado de lo que parece, porque la CPU accede a la memoria con cada instrucci√≥n para obtener la siguiente instrucci√≥n en la tuber√≠a. Y, de hecho, en el caso general *, la memoria atascada en el bus es la √∫ltima instrucci√≥n recibida. Esto simplifica el proceso, ya que solo necesita obtener este √∫ltimo valor preseleccionado. Pero dado que el √∫ltimo valor preseleccionado depende solo de d√≥nde estamos ejecutando actualmente desde la memoria, siempre debe ser el mismo. Incluso si la direcci√≥n recibida cambia mientras no es v√°lida,siempre obtendr√°s el mismo recuerdo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uh ... para. </font><font style="vertical-align: inherit;">Pero este ciclo existe y no se puede salir si este valor est√° preseleccionado. </font><font style="vertical-align: inherit;">¬øEntonces qu√© est√° pasando? </font><font style="vertical-align: inherit;">Si recibe constantemente las siguientes instrucciones, ¬øqu√© sucede entre estas operaciones? </font><font style="vertical-align: inherit;">Trat√© de ejecutar tales bucles sin fin en las ROM de prueba para verificar si, por ejemplo, el valor podr√≠a ir mal. </font><font style="vertical-align: inherit;">Esto definitivamente puede suceder si el valor no se ha actualizado recientemente, pero el valor se actualiza en cada instrucci√≥n, por lo que no tiene tiempo para corromperse. </font><font style="vertical-align: inherit;">Mis pruebas nunca salieron del bucle. </font><font style="vertical-align: inherit;">Hice algo diferente que en estos juegos, aunque recre√© el ciclo exactamente. </font><font style="vertical-align: inherit;">¬øQu√© hice mal?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pok√©mon Esmeralda y ACE, que ocurren solo en hierro</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avance r√°pido en el tiempo, en enero de 2020. El informe de error en la fiesta de Sonic Pinball en ese momento ten√≠a aproximadamente tres a√±os y medio. En otros emuladores, fue conocido por muchos a√±os. Me he quedado sin teor√≠as de trabajo. A finales de este mes, un usuario con el apodo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merrp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se uni√≥ a la comunidad Discord del emulador mGBA y dijo que Pok√©mon Emerald tiene una nueva falla de ejecuci√≥n de c√≥digo arbitrario (ACE) que solo funciona en hardware. Adem√°s, esta falla probablemente sea utilizada por los corredores de velocidad, que pueden querer practicar el emulador. Obviamente, este error se ha convertido en un objetivo atractivo para corregir el error, aunque ser√≠a mejor si me enterara antes de la versi√≥n 0.8.0. Comenc√© a investigar el problema t√©cnico y confirme la observaci√≥n de merrp de que solo funciona en hardware. En todos los emuladores que prob√©, el juego colgaba con una pantalla negra. Pero merrp me inform√≥ que se cuelga de la lectura de la memoria no v√°lida en un bucle, y me di cuenta de que lo m√°s probable es que no pueda solucionar el error en el futuro cercano. Este es nuevamente </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el mismo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> error.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta vez, aprender sobre las funciones de bucle me dio una ventaja. Gracias al </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proyecto de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> descompilaci√≥n </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">pokeemerald,</font></a><font style="vertical-align: inherit;"> pude hacer f√°cilmente cambios espec√≠ficos en la funci√≥n para tratar de descubrir c√≥mo se las arregl√≥ para salir del c√≠rculo. Una versi√≥n simplificada de este bucle se parece a esto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint16_t</span> type = <span class="hljs-comment">/* ... */</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int32_t</span> i = <span class="hljs-number">0</span>; table[type][i] != <span class="hljs-number">0xFFFF</span>; ++i) {
	<span class="hljs-keyword">uint16_t</span> value = table[type][i] &amp; <span class="hljs-number">0xFE00</span>;
	<span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">0x7E00</span>) {
		<span class="hljs-keyword">break</span>;<font></font>
	}<font></font>
	<span class="hljs-comment">/* ... */</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El bucle realiza una tarea bastante simple. Hay una tabla de valores bidimensional. En cada fila de esta tabla de columnas, el </font></font><code>type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bucle primero intenta determinar si el valor es un cierto valor centinela. Si es as√≠, el ciclo termina. De lo contrario, aplica una m√°scara al valor y comprueba si es mayor que el valor que se est√° comprobando. De lo contrario, baja el ciclo. En un caso particular de una falla, el valor </font></font><code>type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">va m√°s all√° de los l√≠mites de la tabla, lo que lleva a la aparici√≥n de un puntero no v√°lido. Esto significa que cuando intentas acceder</font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para este elemento de esta columna inexistente, siempre accederemos a memoria no v√°lida. Aunque el desplazamiento de la tabla aumenta con cada iteraci√≥n del bucle antes de volver a la memoria real, puede necesitar cientos de millones de repeticiones. Por lo tanto, es obvio que no lo hace. Entonces, ¬øc√≥mo sale un programa de un ciclo?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para investigar esto, cambi√© el ciclo y mir√© lo que suceder√≠a si saliera instant√°neamente del ciclo. </font><font style="vertical-align: inherit;">Todo result√≥ ser bastante simple: en este momento, ACE trabaj√≥ tanto en el hardware como en el emulador, y nada se colg√≥. </font><font style="vertical-align: inherit;">Entonces, en cambio, trat√© de establecer el color de la pantalla en el valor que lee el programa cuando sale del bucle y se congela para que el color no cambie. </font><font style="vertical-align: inherit;">Recopil√© el c√≥digo y lo ejecut√© en un GBA real. </font><font style="vertical-align: inherit;">Despu√©s de unos segundos de congelaci√≥n en una pantalla negra, se convirti√≥ en un hermoso tono azul.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/eq/e_/md/eqe_md60cly8igmztq2_kd2yigc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MUY AZUL</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pero el emulador todav√≠a colgaba en una pantalla negra. </font><font style="vertical-align: inherit;">¬øQu√© valor leer√° si ley√≥ el valor recibido anteriormente? </font><font style="vertical-align: inherit;">En cambio, se convirti√≥ en un turquesa oscuro.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/sh/hf/6j/shhf6jyqkem0ulhbpzjuhc9hmi4.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fu.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Es decir, el programa, antes de que lograra salir del ciclo, seguramente lo aprob√≥ al menos una vez. </font><font style="vertical-align: inherit;">Tambi√©n result√≥ que el tiempo requerido para escapar del ciclo con hierro var√≠a. </font><font style="vertical-align: inherit;">Esto usualmente tom√≥ de 2 a 30 segundos. </font><font style="vertical-align: inherit;">Que esta pasando?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nueva teor√≠a de trabajo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces not√© la diferencia entre mi ROM de prueba y el Pok√©mon Esmeralda cuando colg√≥. Pok√©mon tocaba m√∫sica. Sonic Pinball Party tambi√©n toc√≥ m√∫sica. Hello Kitty no toc√≥ m√∫sica, pero me dio una idea. ¬øQu√© sucede si se produce una interrupci√≥n entre la captaci√≥n previa y la carga de datos? ¬øEl programa comienza a buscar previamente el vector de interrupci√≥n antes de acceder a la memoria no v√°lida? R√°pidamente cre√© un dise√±o para esta situaci√≥n en mGBA, activ√© las interrupciones en la ROM de prueba y, por supuesto, se sali√≥ del circuito. Luego prob√© la misma ROM de prueba en hardware y ... no sali√≥ del circuito. Y as√≠ surgi√≥ la teor√≠a. Al final, me di cuenta de algo. Estoy seguro de que not√≥ un asterisco arriba, as√≠ que s√≠, puede haber un evento entre la captaci√≥n previa y el acceso a la memoria,pero solo si, entre la captaci√≥n previa y el acceso a la memoria no v√°lida, el bus de memoria env√≠a una solicitud no a la CPU, sino a otra cosa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dije que el bus de memoria est√° controlado por la CPU. En su mayor parte, esto es cierto, pero hay otros equipos importantes que tambi√©n tienen acceso al bus de memoria sin pasar por el procesador. Este proceso se llama </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acceso directo a la memoria</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Habl√© sobre DMA en un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo anterior</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as√≠ que ahora no entrar√© en los principios de su trabajo. Si vuelve a leer el art√≠culo, puede notar que dije que la CPU principal se detiene mientras DMA se est√° ejecutando. Esto significa que mientras DMA se est√° ejecutando, el valor en el bus ahora ser√° el √∫ltimo acceso a la memoria de DMA. Esto es principalmente importante si el DMA va m√°s all√° de la memoria real a una regi√≥n no v√°lida; sin embargo, duplica el √∫ltimo buen valor.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hace tiempo que se sabe que si carga memoria no v√°lida en DMA, obtendr√° el √∫ltimo valor de DMA, pero lo implement√© en mGBA durante mucho tiempo y ya lo olvid√©. Cuando vi esto en el c√≥digo de acceso para memoria no v√°lida al estudiar el error, algo hizo clic en mi cabeza. ¬øQu√© pasa si el valor DMA permanece en el bus para una instrucci√≥n? Si la primera instrucci√≥n despu√©s de DMA termina de cargar la memoria no v√°lida antes de que obtenga el siguiente valor, en teor√≠a esto deber√≠a conducir a recargar el valor de DMA. Adem√°s, reproducir m√∫sica en GBA generalmente usa DMA para transmitir la salida de audio. Para la correcta implementaci√≥n de esto, se requiere un emulador de precisi√≥n t√°ctil que pueda bloquear la CPU en el medio de la ejecuci√≥n de la instrucci√≥n, entre el inicio de la instrucci√≥n y el acceso a la memoria, y la emulaci√≥n de consola GBA en el emulador mGBA no es precisa al tacto.Y esto es algo para m√≠.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recuerda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Afortunadamente, logr√© solucionar este problema. </font><font style="vertical-align: inherit;">La soluci√≥n es imperfecta, pero ahora puedo comparar la direcci√≥n de CPU esperada para la instrucci√≥n despu√©s de DMA con la direcci√≥n de CPU actual para una carga no v√°lida y usar una sola direcci√≥n en lugar del valor preseleccionado para este valor de DMA.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La decisi√≥n tan esperada</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encend√≠ las operaciones de DMA para H-blank en la ROM de prueba y las sincronic√© con V-blank para que los tiempos fueran estables, lo ejecut√© en hardware y ... ¬°esta vez funcion√≥! La ROM de prueba sali√≥ constantemente del bucle despu√©s del mismo n√∫mero de iteraciones cuando se ley√≥ el valor DMA desde el bus. ¬°Yo ten√≠a raz√≥n! Para la correcta implementaci√≥n de esto en mGBA, se requirieron varios intentos, pero ahora el programa sale del ciclo con los mismos resultados que en el hardware. Finalmente obtuve un tono de azul en mGBA. Hello Kitty ha arrancado. Ahorrar en la fiesta de Sonic Pinball ha ganado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo hice.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este fue probablemente el tiempo m√°s largo que pas√© en un solo error. En el transcurso de tres a√±os, invert√≠ tanto tiempo en depurarlo que perd√≠ la cuenta, y estoy seguro de que otros desarrolladores tambi√©n enfrentaron situaciones similares en sus emuladores. Sin esta idea, me podr√≠a haber llevado otro a√±o, o incluso m√°s, pero la pantalla negra, en la que no sucedi√≥ nada excepto tocar m√∫sica, se convirti√≥ en ese domin√≥ que condujo al colapso de todo el problema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora que se encuentra la soluci√≥n, se puede implementar en otros emuladores de GBA, poniendo fin a este error. El error se solucionar√° en mGBA 0.9.0, que, espero, se lanzar√° este a√±o, y ya se ha solucionado en las versiones de prueba. Finalmente puedes jugar Hello Kitty Collection: Miracle Fashion Maker. A menos que, por supuesto, lo desees, no me corresponde juzgarte.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34c/74c/fce/34c74cfce5ebbb092c5a55c9293ec0cb.png" alt="imagen"></div><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si intenta ejecutar memoria que no tiene permisos de ejecuci√≥n, esto se llama aborto de captaci√≥n previa.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DACS (abreviatura de Depuraci√≥n y Sistema de comunicaci√≥n) es parte del kit de desarrollo GBA.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estos ciclos inactivos mientras se lee desde el bus a veces se llaman estados de espera.</font></font></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es488224/index.html">Ex editor en jefe de TJ sobre cartas del FSB: habr√° una historia de "Durov 2.0", pero Habr se convertir√° en el protagonista</a></li>
<li><a href="../es488228/index.html">Los 10 mejores lugares e ideas para una cita geek el 14 de febrero</a></li>
<li><a href="../es488230/index.html">Introducci√≥n a SSD. Parte 3. Factor de forma</a></li>
<li><a href="../es488232/index.html">tecnolog√≠a aprox .: QATOK # 2</a></li>
<li><a href="../es488234/index.html">Usando QubesOS para Windows 7</a></li>
<li><a href="../es488242/index.html">Integraci√≥n del proyecto VueJS + TS con SonarQube</a></li>
<li><a href="../es488244/index.html">C√≥mo reducir la sobrecarga al manejar excepciones en C ++</a></li>
<li><a href="../es488246/index.html">VoiceOver en iOS: cada control se comporta de manera diferente</a></li>
<li><a href="../es488250/index.html">A la pregunta de Linux (L)</a></li>
<li><a href="../es488252/index.html">C√≥mo reducir el costo de desarrollar nuevos productos usando SLS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>