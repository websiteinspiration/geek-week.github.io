<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍈 🍸 ☘️ Un ciclo interminable que no fue: la historia del bicho del Santo Grial 🐏 🧠 🧛🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Había una vez un juego para GBA llamado Hello Kitty Collection: Miracle Fashion Maker. Fue un lindo juego basado en la famosa franquicia de Sanrio Hel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Un ciclo interminable que no fue: la historia del bicho del Santo Grial</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488240/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Había una vez un juego para GBA llamado Hello Kitty Collection: Miracle Fashion Maker. Fue un lindo juego basado en la famosa franquicia de Sanrio Hello Kitty y desarrollado por Imagineer. Pero bajo la apariencia de un nombre aparentemente inocente era un problema insidioso. Por alguna razón, este sencillo juego no se ejecutó en ningún emulador de GBA. Pero esto por sí solo no sería suficiente para llamar al problema un error del Santo Grial. Como todos los errores del Santo Grial, este error en sí mismo era completamente confuso. La explicación era simple: en algún momento de la secuencia de lanzamiento del juego, cayó en un ciclo del que nunca </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">salió</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , esperando que un cierto valor se lea desde una memoria que </font><em><font style="vertical-align: inherit;">no existe</font></em><font style="vertical-align: inherit;"> . Aunque hay errores similares en muchos juegos, por ejemplo, en la introducción popular</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Legend of Zelda: The Minish Cap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , confían en un comportamiento especial causado por la lectura de direcciones de memoria no válidas. </font><font style="vertical-align: inherit;">Pero este ciclo parecía violar tal comportamiento. </font><font style="vertical-align: inherit;">Sin embargo, el juego funcionó en equipos reales. </font><font style="vertical-align: inherit;">Además, se produjo exactamente el mismo error al cargar una partida guardada en Sonic Pinball Party después de un reinicio en frío. </font><font style="vertical-align: inherit;">¿Podría la expectativa de estas direcciones de memoria no válidas ser de alguna manera errónea? </font><font style="vertical-align: inherit;">Pero si es así, ¿cómo?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/c85/547/1b0c8554787a8e54e1ac5c21c78d639c.png"></div><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero esto es ilegal, ¿verdad?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espera un minuto: si estás intentando acceder a una memoria no válida, entonces el juego solo necesita bloquearse, ¿verdad? Debe ocurrir una operación no resuelta, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segfault</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> u otro error. ¿Derecha? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno, es más como sí. Pero no realmente. Al menos no en el GBA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la arquitectura de los procesadores ARM que se usaron en GBA, este estado erróneo se denomina cancelación de datos y ocurre solo cuando intenta acceder a la memoria para la cual el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">administrador de memoria</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">ha</font></a><font style="vertical-align: inherit;"> asignado el permiso de lectura </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cuando se produce la cancelación de datos, el procesador completa lo que estaba haciendo y pasa al </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector de excepción</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asignado a excepciones de cancelación de datos. Luego, el sistema operativo puede elegir una de las soluciones: eliminar el proceso actual, asignar memoria de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falla de página</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dejar que el proceso maneje la situación, ya que algunos emuladores JIT lo hacen con "fastmem", o realizar otras acciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cómo maneja el GBA el aborto de datos? La entrada del vector de excepción para la anulación de datos se encuentra en la ROM de arranque de la consola GBA (o, como también se le llama, en el BIOS). Si el GBA encuentra aborto de datos, entonces trata de ir al controlador DACS </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si existe, de lo contrario se produce el bloqueo. </font><font style="vertical-align: inherit;">Ningún juego comercial tiene controladores DACS. </font><font style="vertical-align: inherit;">Entonces, ¿por qué este juego no se congela? </font><font style="vertical-align: inherit;">Todo es muy simple: GBA nunca genera aborto de datos. </font><font style="vertical-align: inherit;">No tiene un administrador de memoria (MMU) (o incluso una unidad de protección de memoria, como en DS), por lo que simplemente sigue funcionando y lee la memoria no válida.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El bus de memoria entra en escena.</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f75/dd9/55f/f75dd955f33d3a974b417f401fe054a6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Qué es la memoria no válida en general? ¿Cómo se ve ella? Este es el principal inconveniente. Esta es una situación difícil: lo que lee el código depende en gran medida de lo que hizo recientemente la CPU o, más precisamente, de lo que hizo recientemente el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bus de memoria</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En resumen, al acceder a una memoria no válida, la CPU lee lo que fue el último en el bus de memoria. Para entender lo que sigue de esto, debe aprender un poco sobre el bus de memoria y cómo funciona.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un bus de memoria es parte de un circuito electrónico que conecta la CPU a todos los componentes de memoria de la plataforma. En el GBA, varios dispositivos están conectados al bus de memoria: RAM de trabajo, memoria de video y el bus de cartucho. Cuando la CPU intenta acceder a la memoria, le dice al bus de memoria a qué dirección necesita acceder, y luego se activa el componente correspondiente a esa dirección. Luego, el componente coloca el valor en esta dirección en el bus, que puede tomar varios </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ciclos </font><font style="vertical-align: inherit;">, y luego la CPU finalmente puede leer el valor del bus. En el caso del GBA, si no hay ningún equipo asociado con la dirección, entonces no se escribe ningún valor en el bus, y la CPU lee cualquier valor colocado en </font><em><font style="vertical-align: inherit;">último lugar</font></em><font style="vertical-align: inherit;"> en el bus</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La situación puede variar de varias maneras, por ejemplo, si la lectura fue de 16 bits y la CPU intenta realizar una lectura de 32 bits, pero en general siempre será un valor del bus. </font><font style="vertical-align: inherit;">Los desarrolladores llaman a esta característica "bus abierto". </font><font style="vertical-align: inherit;">Anteriormente, escribí cómo afecta a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">otros juegos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, parece que todo no se ve tan mal ... ¿verdad?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, ¿puedes guardar en caché el último acceso a la memoria? ¿Y luego traerlo de nuevo? En el caso general, este enfoque funcionará, pero existen ciertas dificultades. Primero, debe asegurarse de que todas las operaciones de acceso a la memoria estén en el orden correcto. Esto es más complicado de lo que parece, porque la CPU accede a la memoria con cada instrucción para obtener la siguiente instrucción en la tubería. Y, de hecho, en el caso general *, la memoria atascada en el bus es la última instrucción recibida. Esto simplifica el proceso, ya que solo necesita obtener este último valor preseleccionado. Pero dado que el último valor preseleccionado depende solo de dónde estamos ejecutando actualmente desde la memoria, siempre debe ser el mismo. Incluso si la dirección recibida cambia mientras no es válida,siempre obtendrás el mismo recuerdo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uh ... para. </font><font style="vertical-align: inherit;">Pero este ciclo existe y no se puede salir si este valor está preseleccionado. </font><font style="vertical-align: inherit;">¿Entonces qué está pasando? </font><font style="vertical-align: inherit;">Si recibe constantemente las siguientes instrucciones, ¿qué sucede entre estas operaciones? </font><font style="vertical-align: inherit;">Traté de ejecutar tales bucles sin fin en las ROM de prueba para verificar si, por ejemplo, el valor podría ir mal. </font><font style="vertical-align: inherit;">Esto definitivamente puede suceder si el valor no se ha actualizado recientemente, pero el valor se actualiza en cada instrucción, por lo que no tiene tiempo para corromperse. </font><font style="vertical-align: inherit;">Mis pruebas nunca salieron del bucle. </font><font style="vertical-align: inherit;">Hice algo diferente que en estos juegos, aunque recreé el ciclo exactamente. </font><font style="vertical-align: inherit;">¿Qué hice mal?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pokémon Esmeralda y ACE, que ocurren solo en hierro</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avance rápido en el tiempo, en enero de 2020. El informe de error en la fiesta de Sonic Pinball en ese momento tenía aproximadamente tres años y medio. En otros emuladores, fue conocido por muchos años. Me he quedado sin teorías de trabajo. A finales de este mes, un usuario con el apodo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merrp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se unió a la comunidad Discord del emulador mGBA y dijo que Pokémon Emerald tiene una nueva falla de ejecución de código arbitrario (ACE) que solo funciona en hardware. Además, esta falla probablemente sea utilizada por los corredores de velocidad, que pueden querer practicar el emulador. Obviamente, este error se ha convertido en un objetivo atractivo para corregir el error, aunque sería mejor si me enterara antes de la versión 0.8.0. Comencé a investigar el problema técnico y confirme la observación de merrp de que solo funciona en hardware. En todos los emuladores que probé, el juego colgaba con una pantalla negra. Pero merrp me informó que se cuelga de la lectura de la memoria no válida en un bucle, y me di cuenta de que lo más probable es que no pueda solucionar el error en el futuro cercano. Este es nuevamente </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el mismo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> error.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta vez, aprender sobre las funciones de bucle me dio una ventaja. Gracias al </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proyecto de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> descompilación </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">pokeemerald,</font></a><font style="vertical-align: inherit;"> pude hacer fácilmente cambios específicos en la función para tratar de descubrir cómo se las arregló para salir del círculo. Una versión simplificada de este bucle se parece a esto:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint16_t</span> type = <span class="hljs-comment">/* ... */</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int32_t</span> i = <span class="hljs-number">0</span>; table[type][i] != <span class="hljs-number">0xFFFF</span>; ++i) {
	<span class="hljs-keyword">uint16_t</span> value = table[type][i] &amp; <span class="hljs-number">0xFE00</span>;
	<span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">0x7E00</span>) {
		<span class="hljs-keyword">break</span>;<font></font>
	}<font></font>
	<span class="hljs-comment">/* ... */</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El bucle realiza una tarea bastante simple. Hay una tabla de valores bidimensional. En cada fila de esta tabla de columnas, el </font></font><code>type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bucle primero intenta determinar si el valor es un cierto valor centinela. Si es así, el ciclo termina. De lo contrario, aplica una máscara al valor y comprueba si es mayor que el valor que se está comprobando. De lo contrario, baja el ciclo. En un caso particular de una falla, el valor </font></font><code>type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">va más allá de los límites de la tabla, lo que lleva a la aparición de un puntero no válido. Esto significa que cuando intentas acceder</font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para este elemento de esta columna inexistente, siempre accederemos a memoria no válida. Aunque el desplazamiento de la tabla aumenta con cada iteración del bucle antes de volver a la memoria real, puede necesitar cientos de millones de repeticiones. Por lo tanto, es obvio que no lo hace. Entonces, ¿cómo sale un programa de un ciclo?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para investigar esto, cambié el ciclo y miré lo que sucedería si saliera instantáneamente del ciclo. </font><font style="vertical-align: inherit;">Todo resultó ser bastante simple: en este momento, ACE trabajó tanto en el hardware como en el emulador, y nada se colgó. </font><font style="vertical-align: inherit;">Entonces, en cambio, traté de establecer el color de la pantalla en el valor que lee el programa cuando sale del bucle y se congela para que el color no cambie. </font><font style="vertical-align: inherit;">Recopilé el código y lo ejecuté en un GBA real. </font><font style="vertical-align: inherit;">Después de unos segundos de congelación en una pantalla negra, se convirtió en un hermoso tono azul.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/eq/e_/md/eqe_md60cly8igmztq2_kd2yigc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MUY AZUL</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pero el emulador todavía colgaba en una pantalla negra. </font><font style="vertical-align: inherit;">¿Qué valor leerá si leyó el valor recibido anteriormente? </font><font style="vertical-align: inherit;">En cambio, se convirtió en un turquesa oscuro.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/sh/hf/6j/shhf6jyqkem0ulhbpzjuhc9hmi4.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fu.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Es decir, el programa, antes de que lograra salir del ciclo, seguramente lo aprobó al menos una vez. </font><font style="vertical-align: inherit;">También resultó que el tiempo requerido para escapar del ciclo con hierro varía. </font><font style="vertical-align: inherit;">Esto usualmente tomó de 2 a 30 segundos. </font><font style="vertical-align: inherit;">Que esta pasando?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nueva teoría de trabajo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces noté la diferencia entre mi ROM de prueba y el Pokémon Esmeralda cuando colgó. Pokémon tocaba música. Sonic Pinball Party también tocó música. Hello Kitty no tocó música, pero me dio una idea. ¿Qué sucede si se produce una interrupción entre la captación previa y la carga de datos? ¿El programa comienza a buscar previamente el vector de interrupción antes de acceder a la memoria no válida? Rápidamente creé un diseño para esta situación en mGBA, activé las interrupciones en la ROM de prueba y, por supuesto, se salió del circuito. Luego probé la misma ROM de prueba en hardware y ... no salió del circuito. Y así surgió la teoría. Al final, me di cuenta de algo. Estoy seguro de que notó un asterisco arriba, así que sí, puede haber un evento entre la captación previa y el acceso a la memoria,pero solo si, entre la captación previa y el acceso a la memoria no válida, el bus de memoria envía una solicitud no a la CPU, sino a otra cosa.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dije que el bus de memoria está controlado por la CPU. En su mayor parte, esto es cierto, pero hay otros equipos importantes que también tienen acceso al bus de memoria sin pasar por el procesador. Este proceso se llama </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acceso directo a la memoria</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Hablé sobre DMA en un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artículo anterior</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , así que ahora no entraré en los principios de su trabajo. Si vuelve a leer el artículo, puede notar que dije que la CPU principal se detiene mientras DMA se está ejecutando. Esto significa que mientras DMA se está ejecutando, el valor en el bus ahora será el último acceso a la memoria de DMA. Esto es principalmente importante si el DMA va más allá de la memoria real a una región no válida; sin embargo, duplica el último buen valor.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hace tiempo que se sabe que si carga memoria no válida en DMA, obtendrá el último valor de DMA, pero lo implementé en mGBA durante mucho tiempo y ya lo olvidé. Cuando vi esto en el código de acceso para memoria no válida al estudiar el error, algo hizo clic en mi cabeza. ¿Qué pasa si el valor DMA permanece en el bus para una instrucción? Si la primera instrucción después de DMA termina de cargar la memoria no válida antes de que obtenga el siguiente valor, en teoría esto debería conducir a recargar el valor de DMA. Además, reproducir música en GBA generalmente usa DMA para transmitir la salida de audio. Para la correcta implementación de esto, se requiere un emulador de precisión táctil que pueda bloquear la CPU en el medio de la ejecución de la instrucción, entre el inicio de la instrucción y el acceso a la memoria, y la emulación de consola GBA en el emulador mGBA no es precisa al tacto.Y esto es algo para mí.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recuerda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Afortunadamente, logré solucionar este problema. </font><font style="vertical-align: inherit;">La solución es imperfecta, pero ahora puedo comparar la dirección de CPU esperada para la instrucción después de DMA con la dirección de CPU actual para una carga no válida y usar una sola dirección en lugar del valor preseleccionado para este valor de DMA.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La decisión tan esperada</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encendí las operaciones de DMA para H-blank en la ROM de prueba y las sincronicé con V-blank para que los tiempos fueran estables, lo ejecuté en hardware y ... ¡esta vez funcionó! La ROM de prueba salió constantemente del bucle después del mismo número de iteraciones cuando se leyó el valor DMA desde el bus. ¡Yo tenía razón! Para la correcta implementación de esto en mGBA, se requirieron varios intentos, pero ahora el programa sale del ciclo con los mismos resultados que en el hardware. Finalmente obtuve un tono de azul en mGBA. Hello Kitty ha arrancado. Ahorrar en la fiesta de Sonic Pinball ha ganado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo hice.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este fue probablemente el tiempo más largo que pasé en un solo error. En el transcurso de tres años, invertí tanto tiempo en depurarlo que perdí la cuenta, y estoy seguro de que otros desarrolladores también enfrentaron situaciones similares en sus emuladores. Sin esta idea, me podría haber llevado otro año, o incluso más, pero la pantalla negra, en la que no sucedió nada excepto tocar música, se convirtió en ese dominó que condujo al colapso de todo el problema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora que se encuentra la solución, se puede implementar en otros emuladores de GBA, poniendo fin a este error. El error se solucionará en mGBA 0.9.0, que, espero, se lanzará este año, y ya se ha solucionado en las versiones de prueba. Finalmente puedes jugar Hello Kitty Collection: Miracle Fashion Maker. A menos que, por supuesto, lo desees, no me corresponde juzgarte.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34c/74c/fce/34c74cfce5ebbb092c5a55c9293ec0cb.png" alt="imagen"></div><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si intenta ejecutar memoria que no tiene permisos de ejecución, esto se llama aborto de captación previa.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DACS (abreviatura de Depuración y Sistema de comunicación) es parte del kit de desarrollo GBA.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estos ciclos inactivos mientras se lee desde el bus a veces se llaman estados de espera.</font></font></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es488224/index.html">Ex editor en jefe de TJ sobre cartas del FSB: habrá una historia de "Durov 2.0", pero Habr se convertirá en el protagonista</a></li>
<li><a href="../es488228/index.html">Los 10 mejores lugares e ideas para una cita geek el 14 de febrero</a></li>
<li><a href="../es488230/index.html">Introducción a SSD. Parte 3. Factor de forma</a></li>
<li><a href="../es488232/index.html">tecnología aprox .: QATOK # 2</a></li>
<li><a href="../es488234/index.html">Usando QubesOS para Windows 7</a></li>
<li><a href="../es488242/index.html">Integración del proyecto VueJS + TS con SonarQube</a></li>
<li><a href="../es488244/index.html">Cómo reducir la sobrecarga al manejar excepciones en C ++</a></li>
<li><a href="../es488246/index.html">VoiceOver en iOS: cada control se comporta de manera diferente</a></li>
<li><a href="../es488250/index.html">A la pregunta de Linux (L)</a></li>
<li><a href="../es488252/index.html">Cómo reducir el costo de desarrollar nuevos productos usando SLS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>