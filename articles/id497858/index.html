<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¼ ğŸ‘©ğŸ¿â€ğŸ­ ğŸ‘©ğŸ½â€ğŸ”§ Persyaratan memori besar di Android - apa yang harus dilakukan? ğŸˆ¶ ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘©ğŸ» ğŸ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo pembaca yang budiman. 
 
 Hari ini kami menyampaikan sedikit materi tentang penggunaan memori yang kompeten di Android . 
 
 
 
 Selamat membaca!...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Persyaratan memori besar di Android - apa yang harus dilakukan?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/497858/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo pembaca yang budiman. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hari ini kami menyampaikan sedikit materi tentang penggunaan memori yang kompeten di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/f4/0y/g6/f40yg6u5swe9eljh-fifu43qxak.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selamat membaca!</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel ini berfokus pada teknik dasar untuk mengelola penggunaan memori dalam aplikasi - misalnya, browser, editor foto, dan pemirsa PDF - di mana permintaan memori besar dibuat.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, sedikit teori</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagian besar aplikasi Android berjalan di atas runtime ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ART</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), yang telah menggantikan mesin virtual Dalvik yang sudah usang. </font><font style="vertical-align: inherit;">ART dan Dalvik serupa dengan Java Virtual Machine (JVM), yang dengannya mereka berbagi prinsip desain yang serupa. </font><font style="vertical-align: inherit;">Mereka menggunakan dua ruang terpisah untuk menyimpan data aplikasi: tumpukan dan tumpukan. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stack-memory</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Stack-memory di Java digunakan untuk menyimpan variabel lokal (tipe primitif dan referensi objek). </font><font style="vertical-align: inherit;">Setiap utas Java memiliki tumpukan terpisah. </font><font style="vertical-align: inherit;">Memori tumpukan relatif kecil dibandingkan dengan memori tumpukan. </font><font style="vertical-align: inherit;">Ukuran tumpukan Java Dalvik biasanya 32 KB untuk kode Java dan 1 MB untuk kode asli (C ++ / JNI). </font><font style="vertical-align: inherit;">Tumpukan terpadu untuk Java dan C ++ telah muncul dalam ART, ukurannya sekitar 1 MB.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika aplikasi memilih seluruh memori stack hingga batasnya, kesalahan terjadi </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StackOverflowError</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Alasan paling mungkin batas tumpukan dapat dicapai adalah rekursi tak terbatas atau pemanggilan metode yang terlalu dalam. Referensi ke memori tumpukan selalu dibuat dalam urutan LIFO (last come - first served). Setiap kali suatu metode dipanggil, frame baru didorong ke stack dengan variabel lokal dari metode ini. Ketika metode selesai, frame-nya dikeluarkan dari stack, dan setiap nilai yang dihasilkan kemungkinan dikirim kembali ke stack. Jadi, masalah pertama (rekursi tak terbatas) adalah bug yang mudah untuk diperbaiki, tetapi yang kedua membutuhkan beberapa refactoring, yang terdiri dari penggelaran pemanggilan metode rekursif dan mengubahnya menjadi satu lingkaran. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tumpukan memori</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heap memory di Java digunakan oleh mesin virtual untuk mengalokasikan objek. </font><font style="vertical-align: inherit;">Setiap kali sebuah objek dibuat, itu terjadi di heap. </font><font style="vertical-align: inherit;">Mesin virtual, seperti JVM atau ART, secara teratur mengumpulkan sampah, menghapus semua objek yang tidak lagi dirujuk, dan dengan demikian membebaskan memori untuk mengalokasikan objek baru. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memastikan kegunaan, Android dengan ketat membatasi ukuran tumpukan untuk setiap aplikasi yang berjalan. </font><font style="vertical-align: inherit;">Batas ukuran tumpukan bervariasi dari perangkat ke perangkat dan tergantung pada berapa banyak RAM pada perangkat itu. </font><font style="vertical-align: inherit;">Jika aplikasi Anda mencapai ukuran tumpukan maksimum dan mencoba mengalokasikan lebih banyak memori, kesalahan dihasilkan </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OutOfMemoryError</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan aplikasi berakhir. </font><font style="vertical-align: inherit;">Mari kita lihat beberapa contoh untuk membantu menghindari situasi ini.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis memori tumpukan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alat paling penting untuk memahami masalah memori dalam aplikasi Anda dan memahami bagaimana memori digunakan adalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">profiler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memori yang </font><font style="vertical-align: inherit;">tersedia di Android Studio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alat ini memvisualisasikan berapa banyak memori yang dikonsumsi aplikasi Anda dari waktu ke waktu. </font><font style="vertical-align: inherit;">Anda dapat mengambil snapshot dari tumpukan Java dalam aplikasi yang sedang berjalan, merekam operasi alokasi memori, dan melacak tumpukan atau sejarah alokasi memori ini dalam UI yang kuat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sesi profiler memori khas akan terlihat seperti ini:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami melihat alokasi memori dan saluran pengumpul sampah yang paling sering untuk mengidentifikasi kemungkinan masalah kinerja.</font></font></li>
<li>,      ,    ,  ,  ,    . ,        . ,  ,      <code>PdfActivity</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PSPDFKit</a>   .</li>
<li>           ,   .   ,          .        â€“ ,         ,      .</li>
</ul><br>
<h4> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengumpul sampah modern adalah karya seni teknologi yang kompleks, hasil penelitian dan pengembangan selama bertahun-tahun, di mana ratusan orang berpartisipasi, dari akademisi hingga pengembang profesional. Namun, tetap harus waspada untuk mencegah kebocoran memori. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi teladan untuk mendeteksi kebocoran memori adalah perpustakaan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LeakCanary</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Secara otomatis mengeluarkan notifikasi ketika di unit uji Anda (pengembangan pengembangan), memberi Anda tingkat jejak kebocoran di UI program ini. Anda dapat (dan harus) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengintegrasikannya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hari ini, terutama karena itu tidak sulit!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sangat mudah untuk memprovokasi kebocoran memori ketika bekerja dengan siklus kehidupan yang kompleks atau fragmen Android. </font><font style="vertical-align: inherit;">Ini sering terjadi pada titik di mana pengembang memegang referensi kuat untuk </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konteks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI atau objek khusus UI lainnya di tugas latar belakang atau dalam variabel statis. </font><font style="vertical-align: inherit;">Salah satu cara untuk memprovokasi penundaan tersebut adalah dengan aktif memutar perangkat saat menguji aplikasi Anda.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kosongkan memori sebagai respons terhadap peristiwa</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android mungkin memerlukan aplikasi untuk mengalokasikan memori, atau memaksanya untuk berhenti ketika memori perlu dibebaskan untuk melakukan tugas yang lebih penting. Sebelum ini terjadi, sistem akan memungkinkan Anda untuk memberikan semua memori yang tidak Anda butuhkan. Dalam aktivitas Anda, Anda perlu mengimplementasikan antarmuka </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ComponentCallbacks2</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dalam hal ini, setiap kali sistem Anda kehabisan memori, panggilan akan dilakukan ke metode Anda </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">onTrimMemory()</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan Anda akan dapat membebaskan memori atau menonaktifkan fitur yang tidak akan berfungsi dalam kondisi kekurangan memori seperti itu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, panggilan balik seperti itu ditangani dalam aplikasi PSPDFKit. </font><font style="vertical-align: inherit;">Aplikasi PSPDFKit dirancang dengan perhitungan penggunaan aktif memori untuk caching, sehingga aplikasi berjalan semulus mungkin. </font><font style="vertical-align: inherit;">Awalnya, tidak diketahui berapa banyak memori yang tersedia pada perangkat, sehingga PSPDFKit beradaptasi dengan situasi dan membatasi penggunaan memori ketika menerima pemberitahuan bahwa tidak ada cukup memori. </font><font style="vertical-align: inherit;">Oleh karena itu, aplikasi yang terintegrasi dengan PSPDFKit bekerja bahkan pada perangkat berteknologi rendah, tetapi dengan kinerja yang berkurang karena fakta bahwa caching dinonaktifkan.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tumpukan besar</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu solusi front-end untuk mengatasi kebutuhan memori yang tinggi adalah dengan meminta sejumlah besar Dalvik untuk aplikasi Anda. Untuk melakukan ini, Anda dapat menambahkan </font></font><code>android:largeHeap="true"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tag &lt;aplikasi&gt; dalam file </font></font><code>AndroidManifest.xml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika properti </font></font><code>largeHeap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diatur ke nilai </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Android akan membuat semua proses untuk aplikasi Anda dengan tumpukan besar. Pengaturan ini hanya dimaksudkan untuk aplikasi yang, menurut sifatnya, tidak dapat bekerja tanpanya, yaitu, mereka menggunakan sumber daya yang banyak yang harus secara bersamaan masuk ke memori.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sangat tidak disarankan untuk menggunakan tumpukan besar jika Anda hanya ingin menaikkan plafon untuk kemungkinan penggunaan memori. </font><font style="vertical-align: inherit;">Penggunaan memori harus selalu dioptimalkan, karena bahkan tumpukan besar aplikasi Anda mungkin tidak cukup ketika bekerja pada perangkat yang lemah dengan memori kecil.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Periksa berapa banyak memori yang dapat digunakan aplikasi Anda</font></font></h4> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak ada salahnya untuk memeriksa seberapa besar tumpukan aplikasi Anda dan untuk secara dinamis menyesuaikan kode Anda dan kemampuan yang tersedia untuk batas memori ini. </font><font style="vertical-align: inherit;">Anda dapat memeriksa ukuran tumpukan maksimum langsung saat runtime menggunakan metode </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">getMemoryClass()</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">getLargeMemoryClass()</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ketika tumpukan besar diaktifkan). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android bahkan mendukung perangkat dengan RAM hanya 512 MB. </font><font style="vertical-align: inherit;">Pastikan untuk tidak mengabaikan perangkat berteknologi rendah! </font><font style="vertical-align: inherit;">Menggunakan metode</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">isLowRamDevice()</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat memeriksa apakah aplikasi Anda berjalan pada perangkat seperti itu di mana tidak tersedia cukup memori. </font><font style="vertical-align: inherit;">Perilaku yang tepat dari metode ini bergantung pada perangkat, tetapi biasanya mengembalikan true pada perangkat dengan kurang dari 1 GB RAM. </font><font style="vertical-align: inherit;">Anda perlu memastikan bahwa aplikasi Anda berfungsi dengan baik pada perangkat ini, dan menonaktifkan semua fitur yang menggunakan banyak memori. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baca lebih lanjut tentang cara Android bekerja pada perangkat dengan sedikit memori, Anda dapat membaca di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">Kiat pengoptimalan tambahan juga disediakan di sini.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gunakan struktur data yang dioptimalkan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam banyak kasus, aplikasi menggunakan terlalu banyak memori karena alasan sederhana sehingga tidak menggunakan struktur data yang paling tepat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Koleksi Java tidak dapat menyimpan tipe primitif yang efisien dan perlu mengemas kunci dan nilainya. Misalnya, </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HashMap</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan kunci integer harus diganti dengan yang dioptimalkan </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SparseArray</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pada akhirnya, Anda selalu dapat menggunakan array mentah alih-alih koleksi, dan ini adalah ide bagus jika koleksi Anda tidak dapat diubah ukurannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Struktur data lain yang tidak efisien dalam hal penggunaan memori termasuk berbagai serialisasi. Ya, memang, format XML atau JSON nyaman digunakan, Anda dapat mengurangi penggunaan memori jika Anda bekerja dengan format biner yang lebih efisien, misalnya, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buffer protokol</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua contoh ini, dengan struktur data yang dioptimalkan untuk menghemat memori, hanyalah petunjuk. </font><font style="vertical-align: inherit;">Seperti refactoring, Anda harus terlebih dahulu menemukan sumber masalah, dan kemudian beralih ke optimasi kinerja tersebut.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cegah pengocokan memori</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mesin virtual Java / Android mengalokasikan objek dengan sangat cepat. </font><font style="vertical-align: inherit;">Pengumpulan sampah juga sangat cepat. </font><font style="vertical-align: inherit;">Namun, ketika mengalokasikan sejumlah besar objek dalam waktu singkat, Anda mungkin menghadapi masalah yang disebut "memory churn". </font><font style="vertical-align: inherit;">Dalam hal ini, mesin virtual tidak akan punya waktu untuk mengalokasikan objek pada kecepatan ini, dan pengumpul sampah akan membuangnya, dan aplikasi akan mulai melambat, dan dalam kasus-kasus ekstrem bahkan akan menggunakan semua memori.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah utama pada wilayah Android dalam hal ini adalah bahwa kami tidak mengontrol kapan pengumpulan sampah akan terjadi. </font><font style="vertical-align: inherit;">Secara potensial, ini dapat menyebabkan masalah: misalnya, pengumpul sampah bekerja tepat pada saat animasi dibuka di layar dan kami melebihi ambang 16 ms, yang memastikan tampilan frame yang mulus. </font><font style="vertical-align: inherit;">Oleh karena itu, penting untuk mencegah alokasi memori yang berlebihan dalam kode. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh situasi yang mengarah ke pengocokan memori adalah alokasi objek besar, misalnya, Cat di dalam metode </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">onDraw()</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presentasi. </font><font style="vertical-align: inherit;">Dalam hal ini, banyak objek dibuat dengan cepat, dan pengumpulan sampah dapat dimulai, yang dapat mempengaruhi kinerja tampilan ini. </font><font style="vertical-align: inherit;">Seperti yang dinyatakan di atas, Anda harus selalu memantau penggunaan memori untuk menghindari situasi seperti itu.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memori akses acak (RAM) pada perangkat seluler dapat menjadi sumber daya yang sangat terbatas. </font><font style="vertical-align: inherit;">Memastikan penggunaan memori yang efisien dalam aplikasi sangat penting jika aplikasi Anda bekerja dengan objek yang relatif besar, misalnya, grafik raster (pemirsa PDF, browser web, editor foto) atau file media besar (editor audio atau video). </font><font style="vertical-align: inherit;">Dengan mengikuti tip-tip ini, Anda akan belajar cara membuat aplikasi berkualitas tinggi yang akan bekerja pada tingkat yang dapat diterima, bahkan pada perangkat yang paling kuat.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id497838/index.html">Berita dari dunia OpenStreetMap No. 507 (03/31 / 2020-06.04.2020)</a></li>
<li><a href="../id497840/index.html">SOC di situs jarak jauh. Apa yang layak dipikirkan?</a></li>
<li><a href="../id497842/index.html">Banana Pi R64 Router terbaik untuk OpenWrt, atau tidak?</a></li>
<li><a href="../id497850/index.html">Bagaimana saya memperbaiki mesin arcade</a></li>
<li><a href="../id497856/index.html">Boost Converter: DCM vs CCM. Atau mengapa tidak takut untuk mengambilnya sendiri</a></li>
<li><a href="../id497860/index.html">Menghasilkan pola desain di ES6 + pada contoh Game of Thrones</a></li>
<li><a href="../id497862/index.html">Mengapa tidak menghapus semua elemen array dengan menugaskannya kembali ke []?</a></li>
<li><a href="../id497864/index.html">(S) SDLC, atau Cara membuat pengembangan lebih aman. Bagian 1</a></li>
<li><a href="../id497866/index.html">Bersihkan Kode SIL</a></li>
<li><a href="../id497870/index.html">Virus komputer: kisah dari mata-mata rumah yang tidak berbahaya hingga pencuri kartu bank</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>