<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏼 🌳 🔄 推定分布カウント-ほとんどの場合、ソートを再発明 🚦 👨🏾‍✈️ 👩🏿‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="多かれ少なかれ互いに異なる種類の数は、100を超えることが保証されています。その中には、相互に最小限の違いがあるアルゴリズムのサブグループがあり、いくつかの一般的な主な考え方に一致しています。実際、年ごとに、異なる人々が同じ分類を新たに思い付き、基本的な詳細は異なります。
 
 このようなアルゴリズ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>推定分布カウント-ほとんどの場合、ソートを再発明</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/478654/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img align="left" width="280" height="430" src="https://habrastorage.org/webt/sd/nz/sa/sdnzsaij33eps-i9dygobdrznxe.png"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多かれ少なかれ互いに異なる種類の数は、100を超えることが保証されています。その中には、相互に最小限の違いがあるアルゴリズムのサブグループがあり、いくつかの一般的な主な考え方に一致しています。実際、年ごとに、異なる人々が同じ分類を新たに思い付き、基本的な詳細は異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなアルゴリズムのアイデアは、他のアイデアよりも頻繁に見つかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各要素は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置される配列の</font><i><font style="vertical-align: inherit;">ほぼその場所に</font></i><font style="vertical-align: inherit;">入力さ</font><i><font style="vertical-align: inherit;">れ</font></i><font style="vertical-align: inherit;">ます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほぼ規則正しい</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列で</font><font style="vertical-align: inherit;">あることが</font><font style="vertical-align: inherit;">わかります。挿入による並べ替えが適用される（ほとんど順序付けされた配列を処理するのに最も効果的）か、ローカルの順序付けされていない領域が同じアルゴリズムによって再帰的に処理されます。</font></font><a name="habracut"></a><br>
<br>
<blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="EDISONソフトウェア-ウェブ開発"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISONソフトウェア-ウェブ開発"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事はEDISONのサポートを得て作成されました。EDISONは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチブランドの店舗の洋服をオンラインで試すプログラム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">川と船の間のLED伝送システムまで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、さまざまなタスクのための幅広いソリューションを開発しています</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムの理論が大好きです！</font><font style="vertical-align: inherit;">;-)</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素を配置するおおよその位置を見積もるには、配列の平均要素とどの程度異なるかを調べる必要があります。</font><font style="vertical-align: inherit;">これを行うには、最小要素と最大要素の値、そして配列のサイズを知っている必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソートされた配列は、本当にランダムなデータを持っているはずです。</font><font style="vertical-align: inherit;">この方法のすべての発明者は、同じ式になります。</font></font><br>
<br>
<div style="text-align:center;"><img width="460" height="81" src="https://habrastorage.org/webt/ik/qi/gt/ikqigtqyoqd41k5z3mfrjiwqwey.png"></div><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -素子アレイにおける近似場所</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minが</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置されるべきで</font><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最大</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最小値と最大値の要素を配列に- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aの</font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -配列の要素数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ここでは、一般的な考え方です。</font><font style="vertical-align: inherit;">このアルゴリズムが何度も生まれたバリエーションを見てみましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キングソロモンの並べ替え::ソロモンの並べ替え</font></font></h2><br>
<div style="text-align:center;"><img width="608" height="294" src="https://habrastorage.org/webt/ds/ry/ga/dsrygazdx_xtt2hwbvvwjhd0bbo.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッド（およびその美しい名前）は</font><font style="vertical-align: inherit;">ユーザー</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって提案されました</font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V2008n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">約5年前。</font><font style="vertical-align: inherit;">すべての時間があります。「石を投げる時間と石を集める時間」（伝道の書からのソロモン王の言葉）-そしてアルゴリズムでは、まさにこれが起こります。</font><font style="vertical-align: inherit;">まず、数式を使用して、配列の目的の場所に要素を散布します。</font><font style="vertical-align: inherit;">式は正確ではなくおおよその場所を与えるため、値が互いに近いいくつかの要素は、一度にいくつかの位置を装います。</font><font style="vertical-align: inherit;">これらのローカル要素グループは、挿入によってソートされ、最終的な順序で組み立てられます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">補間ソート</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「太陽の下で新しいことは何もない」と同じ著者を再度引用する。</font><font style="vertical-align: inherit;">ウィキペディアでは、ソロモンのソートを連想させる、補間によるソートについて説明しています。</font><font style="vertical-align: inherit;">それぞれの「石の山」は、小さな重要な要素が配置された小さな追加の動的配列です。</font><font style="vertical-align: inherit;">主な違いは、「石を散在させた」後、これらのローカルの並べ替えられていない要素のグループが、挿入ではなく、補間によって（再帰的にまたはループで）並べ替えられることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
順序付けられた配列は、特定の未知の関数の既知の値の有限セットと見なすことができる離散データセットです。</font><font style="vertical-align: inherit;">実際、計算数学の観点からの近似分布-これは補間です。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript補間ソート-ループバック</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-built_in">Array</span>.prototype.interpolationSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<font></font>
 <font></font>
 <span class="hljs-keyword">var</span> divideSize = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();
 <span class="hljs-keyword">var</span> end = <span class="hljs-keyword">this</span>.length;<font></font>
 divideSize[<span class="hljs-number">0</span>] = end;<font></font>
 <font></font>
 <span class="hljs-keyword">while</span>(divideSize.length &gt; <span class="hljs-number">0</span>) {divide(<span class="hljs-keyword">this</span>);}<font></font>
<font></font>
 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">divide</span>(<span class="hljs-params">A</span>) </span>{<font></font>
  <font></font>
  <span class="hljs-keyword">var</span> size = divideSize.pop();
  <span class="hljs-keyword">var</span> start = end - size;
  <span class="hljs-keyword">var</span> min = A[start];
  <span class="hljs-keyword">var</span> max = A[start];
  <span class="hljs-keyword">var</span> temp = <span class="hljs-number">0</span>;<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = start + <span class="hljs-number">1</span>; i &lt; end; i++) {
   <span class="hljs-keyword">if</span>(A[i] &lt; min) {<font></font>
    min = A[i];<font></font>
   } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span>(A[i] &gt; max) {max = A[i];}<font></font>
   }<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(min == max) {<font></font>
   <font></font>
   end = end - size;<font></font>
   <font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
<font></font>
   <span class="hljs-keyword">var</span> p = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">var</span> bucket = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(size);<font></font>
   <font></font>
   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {bucket[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();}<font></font>
   <font></font>
   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = start; i &lt; end; i++) {<font></font>
    p = <span class="hljs-built_in">Math</span>.floor(((A[i] - min) / (max - min)) * (size - <span class="hljs-number">1</span>));<font></font>
    bucket[p].push(A[i]);<font></font>
   }<font></font>
   <font></font>
   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
    <span class="hljs-keyword">if</span>(bucket[i].length &gt; <span class="hljs-number">0</span>) {
     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; bucket[i].length; j++) {A[start++] = bucket[i][j];}<font></font>
     divideSize.push(bucket[i].length);<font></font>
    }<font></font>
   }<font></font>
  }<font></font>
 }<font></font>
};</code></pre></div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript補間ソート-再帰バージョン</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-built_in">Array</span>.prototype.bucketSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<font></font>
 <font></font>
 <span class="hljs-keyword">var</span> start = <span class="hljs-number">0</span>;
 <span class="hljs-keyword">var</span> size = <span class="hljs-keyword">this</span>.length;
 <span class="hljs-keyword">var</span> min = <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>];
 <span class="hljs-keyword">var</span> max = <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>];<font></font>
 <font></font>
 <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; size; i++) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[i] &lt; min) {<font></font>
   min = <span class="hljs-keyword">this</span>[i];<font></font>
  } <span class="hljs-keyword">else</span> {
   <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>[i] &gt; max) {max = <span class="hljs-keyword">this</span>[i];}<font></font>
  }<font></font>
 }<font></font>
 <font></font>
 <span class="hljs-keyword">if</span>(min != max) {<font></font>
  <font></font>
  <span class="hljs-keyword">var</span> bucket = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(size);<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {bucket[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();}<font></font>
  <font></font>
  <span class="hljs-keyword">var</span> interpolation = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<font></font>
   interpolation = <span class="hljs-built_in">Math</span>.floor(((<span class="hljs-keyword">this</span>[i] - min) / (max - min)) * (size - <span class="hljs-number">1</span>));<font></font>
   bucket[interpolation].push(<span class="hljs-keyword">this</span>[i]);<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
   <span class="hljs-keyword">if</span>(bucket[i].length &gt; <span class="hljs-number">1</span>) {bucket[i].bucketSort();} <span class="hljs-comment">//Recursion</span>
   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; bucket[i].length; j++) {<span class="hljs-keyword">this</span>[start++] = bucket[i][j];}<font></font>
  }<font></font>
  <font></font>
 }<font></font>
};</code></pre></div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒストグラムの並べ替え::ヒストグラムの並べ替え</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、ローカルのソートされていないグループに属する要素の数をカウントする、補間によるソートの最適化です。</font><font style="vertical-align: inherit;">この数により、ソートされていないアイテムを（個別の小さな配列にグループ化する代わりに）結果の配列に直接挿入できます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScriptバーの並べ替え</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-built_in">Array</span>.prototype.histogramSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<font></font>
 <font></font>
 <span class="hljs-keyword">var</span> end = <span class="hljs-keyword">this</span>.length;
 <span class="hljs-keyword">var</span> sortedArray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(end);
 <span class="hljs-keyword">var</span> interpolation = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(end);
 <span class="hljs-keyword">var</span> hitCount = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(end);
 <span class="hljs-keyword">var</span> divideSize = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();<font></font>
 <font></font>
 divideSize[<span class="hljs-number">0</span>] = end;<font></font>
 <font></font>
 <span class="hljs-keyword">while</span>(divideSize.length &gt; <span class="hljs-number">0</span>) {distribute(<span class="hljs-keyword">this</span>);}<font></font>
 <font></font>
 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">distribute</span>(<span class="hljs-params">A</span>) </span>{<font></font>
 <font></font>
  <span class="hljs-keyword">var</span> size = divideSize.pop();
  <span class="hljs-keyword">var</span> start = end - size;
  <span class="hljs-keyword">var</span> min = A[start];
  <span class="hljs-keyword">var</span> max = A[start];<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = start + <span class="hljs-number">1</span>; i &lt; end; i++) {
   <span class="hljs-keyword">if</span> (A[i] &lt; min) {<font></font>
    min = A[i];<font></font>
   } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (A[i] &gt; max) {max = A[i];}<font></font>
   }<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-keyword">if</span> (min == max) {<font></font>
   <font></font>
   end = end - size;<font></font>
   <font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
   <font></font>
   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = start; i &lt; end; i++){hitCount[i] = <span class="hljs-number">0</span>;}<font></font>
   <font></font>
   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = start; i &lt; end; i++) {<font></font>
    interpolation[i] = start + <span class="hljs-built_in">Math</span>.floor(((A[i] - min) / (max - min)) * (size - <span class="hljs-number">1</span>));<font></font>
    hitCount[interpolation[i]]++;<font></font>
   }<font></font>
   <font></font>
   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = start; i &lt; end; i++) {
    <span class="hljs-keyword">if</span>(hitCount[i] &gt; <span class="hljs-number">0</span>){divideSize.push(hitCount[i]);}<font></font>
   }<font></font>
   hitCount[end - <span class="hljs-number">1</span>] = end - hitCount[end - <span class="hljs-number">1</span>];<font></font>
<font></font>
   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = end - <span class="hljs-number">1</span>; i &gt; start; i--) {<font></font>
    hitCount[i - <span class="hljs-number">1</span>] = hitCount[i] - hitCount[i - <span class="hljs-number">1</span>];<font></font>
   }<font></font>
   <font></font>
   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = start; i &lt; end; i++) {<font></font>
    sortedArray[hitCount[interpolation[i]]] = A[i];<font></font>
    hitCount[interpolation[i]]++;<font></font>
   }<font></font>
<font></font>
   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = start; i &lt; end; i++) {A[i] = sortedArray[i];}<font></font>
<font></font>
  }<font></font>
 }<font></font>
};</code></pre></div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">補間タグの並べ替え</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オーバーヘッドをさらに最適化するために、ここでは、並べ替えられていないグループ内の同様の要素の数を覚えておらず、True / Falseフラグでこれらのグループの開始をマークすることを提案します。</font><font style="vertical-align: inherit;">Trueはサブグループが既に並べ替えられていることを意味し、Falseはまだ並べ替えられていないことを意味します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScriptタグ付き補間ソート</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-built_in">Array</span>.prototype.InterpolaionTagSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<font></font>
<font></font>
 <span class="hljs-keyword">var</span> end = <span class="hljs-keyword">this</span>.length; 
 <span class="hljs-keyword">if</span>(end &gt; <span class="hljs-number">1</span>) { 
  <span class="hljs-keyword">var</span> start = <span class="hljs-number">0</span> ; 
  <span class="hljs-keyword">var</span> Tag = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(end); <span class="hljs-comment">//Algorithm step-1 </span>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; end; i++) {Tag[i] = <span class="hljs-literal">false</span>;} <font></font>
  Divide(<span class="hljs-keyword">this</span>); <font></font>
 }<font></font>
 <font></font>
 <span class="hljs-comment">//Algorithm step-2</span>
 <span class="hljs-keyword">while</span>(end &gt; <span class="hljs-number">1</span>) {
  <span class="hljs-keyword">while</span>(Tag[--start] == <span class="hljs-literal">false</span>){} <span class="hljs-comment">//Find the next bucket's start</span>
  Divide(<span class="hljs-keyword">this</span>); <font></font>
 } <font></font>
<font></font>
 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Divide</span>(<span class="hljs-params">A</span>) </span>{   <font></font>
  <font></font>
  <span class="hljs-keyword">var</span> min = A[start]; 
  <span class="hljs-keyword">var</span> max = A[start];<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = start + <span class="hljs-number">1</span>; i &lt; end; i++) { 
   <span class="hljs-keyword">if</span>(A[i] &lt; min) {<font></font>
    min = A[i];<font></font>
   } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span>(A[i] &gt; max ) {max = A[i];}<font></font>
   }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(min == max) {<font></font>
   <font></font>
   end = start;<font></font>
   <font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
   <font></font>
   <span class="hljs-comment">//Algorithm step-3 Start to be the next bucket's end                                         </span>
   <span class="hljs-keyword">var</span> interpolation = <span class="hljs-number">0</span>; 
   <span class="hljs-keyword">var</span> size = end - start; 
   <span class="hljs-keyword">var</span> Bucket = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(size);<span class="hljs-comment">//Algorithm step-4         </span><font></font>
<font></font>
   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {Bucket[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();}  <font></font>
   <font></font>
   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = start; i &lt; end; i++) {  <font></font>
    interpolation = <span class="hljs-built_in">Math</span>.floor(((A[i] - min) / (max - min)) * (size - <span class="hljs-number">1</span>));<font></font>
    Bucket[interpolation].push(A[i]); <font></font>
   } <font></font>
<font></font>
   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
    <span class="hljs-keyword">if</span>(Bucket[i].length &gt; <span class="hljs-number">0</span>) {<span class="hljs-comment">//Algorithm step-5      </span>
     Tag[start] = <span class="hljs-literal">true</span>; 
     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; Bucket[i].length; j++) {A[start++] = Bucket[i][j];} <font></font>
    }  <font></font>
   }  <font></font>
  }<font></font>
 }<span class="hljs-comment">//Algorithm step-6 </span>
};</code></pre></div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">補間タグの並べ替え（インプレース）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列内の要素の値が繰り返されておらず、均等に分散されていない場合（大まかに言えば、並べ替えられた形式のデータが算術的な進行のようなものである場合）、要素を中間配列に移動せずに、1つのパスで並べ替え、その場で並べ替えることができます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScriptのラベル（配置済み）を使用して補間で並べ替え</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-built_in">Array</span>.prototype.InPlaceTagSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<font></font>
<font></font>
 <span class="hljs-keyword">var</span> n = <span class="hljs-keyword">this</span>.length;
 <span class="hljs-keyword">var</span> Tag = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);<font></font>
<font></font>
 <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++) {Tag[i] = <span class="hljs-literal">false</span>;}<font></font>
<font></font>
 <span class="hljs-keyword">var</span> min = <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>];
 <span class="hljs-keyword">var</span> max = <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>];<font></font>
<font></font>
 <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; n; i++) {
  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>[i] &lt; min) {<font></font>
   min = <span class="hljs-keyword">this</span>[i];<font></font>
  } <span class="hljs-keyword">else</span> {
   <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>[i] &gt; max) {max = <span class="hljs-keyword">this</span>[i];}<font></font>
  }<font></font>
 } <font></font>
 <font></font>
 <span class="hljs-keyword">var</span> p = <span class="hljs-number">0</span>;
 <span class="hljs-keyword">var</span> temp = <span class="hljs-number">0</span>;<font></font>
<font></font>
 <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++) {
  <span class="hljs-keyword">while</span>(Tag[i] == <span class="hljs-literal">false</span>) { <font></font>
   p = <span class="hljs-built_in">Math</span>.floor(((<span class="hljs-keyword">this</span>[i] - min) / (max - min)) * (n - <span class="hljs-number">1</span>));<font></font>
   temp = <span class="hljs-keyword">this</span>[i];
   <span class="hljs-keyword">this</span>[i] = <span class="hljs-keyword">this</span>[p]; 
   <span class="hljs-keyword">this</span>[p] = temp;<font></font>
   Tag[p] = <span class="hljs-literal">true</span>;<font></font>
  } <font></font>
 } <font></font>
};</code></pre></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラッシュソート::フラッシュソート</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
むかしむかし</font><font style="vertical-align: inherit;">、生物物理学のノイベール教授が1998年に発明したソーティングについて</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">書き</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
教授は、要素をいくつかの個別のクラスに分散することを提案しました（クラスメンバーシップは要素のサイズによって決まります）。</font><font style="vertical-align: inherit;">これを念頭に置くと、式は次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img width="408" height="68" src="https://habrastorage.org/webt/t4/m0/35/t4m0350wkzaul4zp1xy6eoturik.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サイズ（配列サイズ）の代わりに、式は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列の要素を分散するクラスの数を</font><font style="vertical-align: inherit;">示します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">式は、要素がスローされる配列のキーを計算しませんが、要素が属するクラス番号を計算します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このソートは、追加のメモリについてより経済的であるという点で悪くありません。</font><font style="vertical-align: inherit;">要素の再配布が行われます。</font><font style="vertical-align: inherit;">クラスのローカライズのみが個別に保存されます（別の角度から見ると、特定のクラスに属する要素の数は個別に保存されます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、残りは同じ曲です。</font></font><br>
<br>
<div style="text-align:center;"><img width="684" height="190" src="https://habrastorage.org/webt/i_/4i/h0/i_4ih0amqa60afawupd2mykc4wo.gif"></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaでのFlash Sort</font></font></b><div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment">/**
 * FlashSort.java - integer version 
 * Translation of Karl-Dietrich Neubert's algorithm into Java by   
 * Rosanne Zhang
 */</span><font></font>
   <font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlashSort</span> </span>{<font></font>
<font></font>
 <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>   n;
 <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>   m;
 <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] a;
 <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] l;<font></font>
    <font></font>
 <span class="hljs-comment">/* constructor 
 @param size of the array to be sorted */</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flashSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>{<font></font>
<font></font>
  n = size;<font></font>
  generateRandomArray();<font></font>
<font></font>
  <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<font></font>
  partialFlashSort();<font></font>
  <span class="hljs-keyword">long</span> mid = System.currentTimeMillis();<font></font>
  insertionSort();<font></font>
  <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<font></font>
<font></font>
  <span class="hljs-comment">// print the time result</span>
  System.out.println(<span class="hljs-string">"Partial flash sort time     : "</span> + (mid - start));<font></font>
  System.out.println(<span class="hljs-string">"Straight insertion sort time: "</span> + (end - mid));<font></font>
 }<font></font>
<font></font>
 <span class="hljs-comment">/* Entry point */</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<font></font>
  <font></font>
  <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (args.length == <span class="hljs-number">0</span>) {<font></font>
   usage();<font></font>
   System.exit(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">try</span> {<font></font>
   size = Integer.parseInt(args[<span class="hljs-number">0</span>]); <font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">catch</span> (NumberFormatException nfe) {<font></font>
   usage();<font></font>
   System.exit(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  FlashSort.flashSort(size);<font></font>
 }<font></font>
<font></font>
 <span class="hljs-comment">/* Print usage */</span><font></font>
<font></font>
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">usage</span><span class="hljs-params">()</span> </span>{<font></font>
  System.out.println();<font></font>
  System.out.println(<span class="hljs-string">"Usage: java FlashSort n "</span>);<font></font>
  System.out.println(<span class="hljs-string">"       n is size of array to sort"</span>);<font></font>
 }<font></font>
<font></font>
 <span class="hljs-comment">/* Generate the random array */</span>
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generateRandomArray</span><span class="hljs-params">()</span> </span>{<font></font>
  <font></font>
  a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
   a[i] = (<span class="hljs-keyword">int</span>)(Math.random() * <span class="hljs-number">5</span> * n);<font></font>
  }<font></font>
<font></font>
  m = n / <span class="hljs-number">20</span>;<font></font>
<font></font>
  l = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];   <font></font>
 }<font></font>
<font></font>
 <span class="hljs-comment">/* Partial flash sort */</span><font></font>
<font></font>
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">partialFlashSort</span><span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">int</span> anmin = a[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">int</span> nmax  = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i &lt; n; i++) {
   <span class="hljs-keyword">if</span> (a[i] &lt; anmin) anmin=a[i];
   <span class="hljs-keyword">if</span> (a[i] &gt; a[nmax]) nmax=i;            <font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(anmin == a[nmax]) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  <span class="hljs-keyword">double</span> c1 = ((<span class="hljs-keyword">double</span>)m - <span class="hljs-number">1</span>) / (a[nmax] - anmin);<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
   k= (<span class="hljs-keyword">int</span>) (c1 * (a[i] - anmin));<font></font>
   l[k]++;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>; k &lt; m; k++) {<font></font>
   l[k] += l[k - <span class="hljs-number">1</span>];<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">int</span> hold = a[nmax];<font></font>
  a[nmax] = a[<span class="hljs-number">0</span>];<font></font>
  a[<span class="hljs-number">0</span>] = hold;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> nmove = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">int</span> flash;<font></font>
  j = <span class="hljs-number">0</span>;<font></font>
  k = m - <span class="hljs-number">1</span>;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(nmove &lt; n - <span class="hljs-number">1</span>) {<font></font>
   <font></font>
   <span class="hljs-keyword">while</span>(j &gt; (l[k] - <span class="hljs-number">1</span>)) {<font></font>
    j++;<font></font>
    k = (<span class="hljs-keyword">int</span>) (c1 * (a[j] - anmin));<font></font>
   }<font></font>
<font></font>
   flash = a[j];<font></font>
<font></font>
   <span class="hljs-keyword">while</span>(!(j == l[k])) {<font></font>
	   <font></font>
    k = (<span class="hljs-keyword">int</span>) (c1 * (flash - anmin));<font></font>
<font></font>
    hold = a[l[k] - <span class="hljs-number">1</span>];<font></font>
    a[l[k] - <span class="hljs-number">1</span>] = flash;<font></font>
    flash = hold;<font></font>
<font></font>
    l[k]--;<font></font>
    nmove++;<font></font>
<font></font>
   }<font></font>
  }<font></font>
 }<font></font>
<font></font>
 <span class="hljs-comment">/* Straight insertion sort */</span>
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">()</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> i, j, hold;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i = a.length - <span class="hljs-number">3</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<font></font>
<font></font>
   <span class="hljs-keyword">if</span>(a[i + <span class="hljs-number">1</span>] &lt; a[i]) {<font></font>
    <font></font>
	hold = a[i];<font></font>
    j = i;<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (a[j + <span class="hljs-number">1</span>] &lt; hold) {<font></font>
     a[j] = a[j + <span class="hljs-number">1</span>];<font></font>
     j++;<font></font>
    }<font></font>
<font></font>
    a[j] = hold;<font></font>
   }<font></font>
  }<font></font>
 }<font></font>
<font></font>
 <span class="hljs-comment">/* For checking sorting result and the distribution */</span>
 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] ary)</span> </span>{<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; ary.length; i++) {<font></font>
   <font></font>
   <span class="hljs-keyword">if</span>((i + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> ==<span class="hljs-number">0</span>) {<font></font>
    System.out.println(ary[i]);<font></font>
   } <span class="hljs-keyword">else</span> {<font></font>
    System.out.print(ary[i] + <span class="hljs-string">" "</span>);<font></font>
   }<font></font>
   <font></font>
   System.out.println();<font></font>
  }<font></font>
 }<font></font>
}</code></pre></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">近似ソート:: Proxmapソート</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この種はここで言及されたものの中で最も古いものであり、1980年にカリフォルニア大学のThomas Standish教授によって導入されました。</font><font style="vertical-align: inherit;">見た目はかなり違うようですが、よく見ると全て同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒット</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの概念</font><font style="vertical-align: inherit;">、つまり配列の一部の要素に値が近い特定の数で</font><font style="vertical-align: inherit;">動作し</font><font style="vertical-align: inherit;">ます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列要素がヒットであるかどうかを判別するには、要素に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">近似関数</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を適用します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Standish教授は実数の配列をソートしました。</font><font style="vertical-align: inherit;">近似関数は、実数を整数に切り捨てることでした。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、たとえば、配列に要素2.8、2、2.1、2.6などが含まれている場合です。</font><font style="vertical-align: inherit;">その後、これらの数字のヒットはデュースになります。</font></font><br>
<br>
<div style="text-align:center;"><img width="619" height="389" src="https://habrastorage.org/webt/-o/i_/cc/-oi_ccg-cbvv2pxdb9cb2-fbdpg.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的な手順：</font></font><br>
<br>
<ol>
<li>     , ,     .</li>
<li>        ,   .</li>
<li>     ,    ( )  .</li>
<li>  ,    .</li>
<li>  ,        .    ,      (   ),     .      (   ).</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
近似関数として、配列内のデータの一般的な性質に基づいて任意のものを割り当てることができます。</font><font style="vertical-align: inherit;">この並べ替えの最新の実装では、ヒットは通常、小数部分をかじるのではなく、お気に入りの式を使用して決定されます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript近似ソート</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-built_in">Array</span>.prototype.ProxmapSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<font></font>
	<font></font>
 <span class="hljs-keyword">var</span> start = <span class="hljs-number">0</span>;
 <span class="hljs-keyword">var</span> end = <span class="hljs-keyword">this</span>.length;
 <span class="hljs-keyword">var</span> A2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(end);
 <span class="hljs-keyword">var</span> MapKey = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(end);
 <span class="hljs-keyword">var</span> hitCount = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(end);<font></font>
  <font></font>
 <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = start; i &lt; end; i++) {hitCount[i] = <span class="hljs-number">0</span>;}<font></font>
  <font></font>
 <span class="hljs-keyword">var</span> min = <span class="hljs-keyword">this</span>[start];
 <span class="hljs-keyword">var</span> max = <span class="hljs-keyword">this</span>[start];
 <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = start+<span class="hljs-number">1</span>; i &lt; end; i++){
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[i] &lt; min) {<font></font>
	  min = <span class="hljs-keyword">this</span>[i];<font></font>
  } <span class="hljs-keyword">else</span> {
   <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>[i] &gt; max) {max = <span class="hljs-keyword">this</span>[i];}<font></font>
  }<font></font>
 }<font></font>
 <font></font>
 <span class="hljs-comment">//Optimization 1.Save the MapKey[i].</span>
 <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = start; i &lt; end; i++) {<font></font>
  MapKey[i] = <span class="hljs-built_in">Math</span>.floor(((<span class="hljs-keyword">this</span>[i] - min ) / (max - min)) * (end - <span class="hljs-number">1</span>));<font></font>
  hitCount[MapKey[i]]++;<font></font>
 }<font></font>
<font></font>
 <span class="hljs-comment">//Optimization 2.ProxMaps store in the hitCount.</span>
 hitCount[end<span class="hljs-number">-1</span>] = end - hitCount[end - <span class="hljs-number">1</span>];
 <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = end<span class="hljs-number">-1</span>; i &gt; start; i--){<font></font>
  hitCount[i<span class="hljs-number">-1</span>] = hitCount[i] - hitCount[i - <span class="hljs-number">1</span>];<font></font>
 }<font></font>
<font></font>
 <span class="hljs-comment">//insert A[i]=this[i] to A2 correct position</span>
 <span class="hljs-keyword">var</span> insertIndex = <span class="hljs-number">0</span>;
 <span class="hljs-keyword">var</span> insertStart = <span class="hljs-number">0</span>;
 <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = start; i &lt; end; i++){<font></font>
  insertIndex = hitCount[MapKey[i]];<font></font>
  insertStart = insertIndex;<font></font>
  <span class="hljs-keyword">while</span>(A2[insertIndex] != <span class="hljs-literal">null</span>) {insertIndex++;}
  <span class="hljs-keyword">while</span>(insertIndex &gt; insertStart &amp;&amp; <span class="hljs-keyword">this</span>[i] &lt; A2[insertIndex - <span class="hljs-number">1</span>]) {<font></font>
   A2[insertIndex] = A2[insertIndex - <span class="hljs-number">1</span>];<font></font>
   insertIndex--;<font></font>
  }<font></font>
  A2[insertIndex] = <span class="hljs-keyword">this</span>[i];<font></font>
 }<font></font>
 <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = start; i &lt; end; i++) {<span class="hljs-keyword">this</span>[i] = A2[i];}<font></font>
};</code></pre></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハッシュソート挿入ソート::ハッシュソート</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、私たち</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> habrayuzer </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">によって提案された</font></a><font style="vertical-align: inherit;">アルゴリズムでレビューを終えます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bobbyKdas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6年前。</font><font style="vertical-align: inherit;">これは、分散と挿入に加えて、マージも追加されるハイブリッドアルゴリズムです。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかのステップでハーフサブアレイのサイズが最小サイズに到達するまで、配列は再帰的に半分に分割されます（作成者の要素数は500以下）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再帰の最低レベルでは、おなじみのアルゴリズムが各サブアレイに適用されます。同じ式を使用して、ローカル配列のソートされていないセクションの挿入によるソートで、サブアレイ内で近似分布が発生します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブアレイの2つの半分を注文した後、それらはマージされます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元の配列が2つの半分から結合されている場合、再帰レベルを最上部まで上っていくと、ポイント3（並べ替えられた半分のサブ配列のマージ）が繰り返されます。</font></font></li>
</ol><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javaのハッシュ挿入で並べ替え</font></font></b><div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword">import</span> java.util.Arrays;
<span class="hljs-keyword">import</span> java.util.Date;
<span class="hljs-keyword">import</span> java.util.Random;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSort</span> </span>{<font></font>
<font></font>
 <span class="hljs-comment">//   </span>
 <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> SOURCELEN = <span class="hljs-number">1000000</span>;
 <span class="hljs-keyword">int</span> source[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[SOURCELEN];<font></font>
 <font></font>
 <span class="hljs-comment">//       </span>
 <span class="hljs-keyword">int</span> quick[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[SOURCELEN];<font></font>
 <font></font>
 <span class="hljs-comment">//    </span>
 <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> SORTBLOCK = <span class="hljs-number">500</span>;
 <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> k = <span class="hljs-number">3</span>;<font></font>
 <font></font>
 <span class="hljs-comment">// </span>
 <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> TMPLEN = (SOURCELEN &lt; SORTBLOCK * k) ? SORTBLOCK * k : SOURCELEN;
 <span class="hljs-keyword">int</span> tmp[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[TMPLEN];<font></font>
 <font></font>
 <span class="hljs-comment">//   </span>
 <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MIN_VAL = <span class="hljs-number">10</span>;
 <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX_VAL = <span class="hljs-number">1000000</span>;<font></font>
<font></font>
 <span class="hljs-keyword">int</span> minValue = <span class="hljs-number">0</span>;
 <span class="hljs-keyword">int</span> maxValue = <span class="hljs-number">0</span>; 
 <span class="hljs-keyword">double</span> hashKoef = <span class="hljs-number">0</span>;<font></font>
 <font></font>
 <span class="hljs-comment">//     </span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">randomize</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span> i;<font></font>
  Random rnd = <span class="hljs-keyword">new</span> Random();
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;SOURCELEN; i++) {
   <span class="hljs-keyword">int</span> rndValue = MIN_VAL + ((<span class="hljs-keyword">int</span>)(rnd.nextDouble()*((<span class="hljs-keyword">double</span>)MAX_VAL-MIN_VAL))); <font></font>
   source[i] = rndValue;<font></font>
  }<font></font>
 }<font></font>
<font></font>
 <span class="hljs-comment">//         -</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> startIndex, <span class="hljs-keyword">int</span> endIndex)</span> </span>{
  <span class="hljs-keyword">int</span> i;<font></font>
  minValue = source[startIndex];<font></font>
  maxValue = source[startIndex];<font></font>
  <span class="hljs-keyword">for</span>(i=startIndex+<span class="hljs-number">1</span>; i&lt;=endIndex; i++) {
   <span class="hljs-keyword">if</span>( source[i] &gt; maxValue) {<font></font>
    maxValue = source[i];<font></font>
   }<font></font>
   <span class="hljs-keyword">if</span>( source[i] &lt; minValue) {<font></font>
    minValue = source[i];<font></font>
   }   <font></font>
  }<font></font>
  hashKoef = ((<span class="hljs-keyword">double</span>)(k-<span class="hljs-number">1</span>)*<span class="hljs-number">0.9</span>)*((<span class="hljs-keyword">double</span>)(endIndex-startIndex)/((<span class="hljs-keyword">double</span>)maxValue-(<span class="hljs-keyword">double</span>)minValue));<font></font>
 } <font></font>
 <font></font>
 <span class="hljs-comment">// (  - )     </span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stickParts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> startIndex, <span class="hljs-keyword">int</span> mediana, <span class="hljs-keyword">int</span> endIndex)</span> </span>{
  <span class="hljs-keyword">int</span> i=startIndex;
  <span class="hljs-keyword">int</span> j=mediana+<span class="hljs-number">1</span>;
  <span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;
  <span class="hljs-comment">//      -   </span>
  <span class="hljs-keyword">while</span>(i&lt;=mediana &amp;&amp; j&lt;=endIndex) {
   <span class="hljs-keyword">if</span>(source[i]&lt;source[j]) {<font></font>
    tmp[k] = source[i];<font></font>
    i++;<font></font>
   } <span class="hljs-keyword">else</span> {<font></font>
    tmp[k] = source[j];<font></font>
    j++;<font></font>
   }<font></font>
   k++;<font></font>
  }<font></font>
  <span class="hljs-comment">//     -     </span>
  <span class="hljs-keyword">if</span>( i&gt;mediana ) {
   <span class="hljs-keyword">while</span>(j&lt;=endIndex) {<font></font>
    tmp[k] = source[j];<font></font>
    j++;<font></font>
    k++;<font></font>
   }<font></font>
  }<font></font>
  <span class="hljs-comment">//     -     </span>
  <span class="hljs-keyword">if</span>(j&gt;endIndex) {
   <span class="hljs-keyword">while</span>(i&lt;=mediana) {<font></font>
    tmp[k] = source[i];<font></font>
    i++;<font></font>
    k++;<font></font>
   }<font></font>
  }<font></font>
  <font></font>
  System.arraycopy(tmp, <span class="hljs-number">0</span>, source, startIndex, endIndex-startIndex+<span class="hljs-number">1</span>);<font></font>
 }<font></font>
 <font></font>
 <span class="hljs-comment">//       </span>
 <span class="hljs-comment">//        </span>
 <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">shiftRight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>{
  <span class="hljs-keyword">int</span> endpos = index;
  <span class="hljs-keyword">while</span>( tmp[endpos] != <span class="hljs-number">0</span>) {<font></font>
   endpos++;<font></font>
   <span class="hljs-keyword">if</span>(endpos == TMPLEN) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-keyword">while</span>(endpos != index ) {<font></font>
   tmp[endpos] = tmp[endpos-<span class="hljs-number">1</span>];<font></font>
   endpos--;<font></font>
  }<font></font>
      <font></font>
  tmp[endpos] = <span class="hljs-number">0</span>;<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<font></font>
 } <font></font>
<font></font>
 <span class="hljs-comment">//-   </span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(((<span class="hljs-keyword">double</span>)value - (<span class="hljs-keyword">double</span>)minValue)*hashKoef);<font></font>
 }<font></font>
 <font></font>
 <span class="hljs-comment">//       </span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> value)</span> </span>{
  <span class="hljs-keyword">int</span> _index = index;
  <span class="hljs-comment">//  ,   </span>
  <span class="hljs-comment">//            -</span>
  <span class="hljs-keyword">while</span>(tmp[_index] != <span class="hljs-number">0</span> &amp;&amp; tmp[_index] &lt;= value) { _index++; }
  <span class="hljs-comment">//       ,   </span>
  <span class="hljs-keyword">if</span>( tmp[_index] != <span class="hljs-number">0</span>) {<font></font>
   shiftRight(_index);<span class="hljs-comment">//     </span><font></font>
  }<font></font>
  tmp[_index] = value;<span class="hljs-comment">//  -  </span><font></font>
 }<font></font>
 <font></font>
 <span class="hljs-comment">//       </span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">extract</span><span class="hljs-params">(<span class="hljs-keyword">int</span> startIndex, <span class="hljs-keyword">int</span> endIndex)</span> </span>{
  <span class="hljs-keyword">int</span> j=startIndex;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;(SORTBLOCK*k); i++) {
   <span class="hljs-keyword">if</span>(tmp[i] != <span class="hljs-number">0</span>) {<font></font>
    source[j] = tmp[i];<font></font>
    j++;<font></font>
   }<font></font>
  }<font></font>
 } <font></font>
 <font></font>
 <span class="hljs-comment">//  </span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearTMP</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">if</span>( tmp.length &lt; SORTBLOCK*k) {<font></font>
   Arrays.fill(tmp, <span class="hljs-number">0</span>);<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
   Arrays.fill(tmp, <span class="hljs-number">0</span>, SORTBLOCK*k, <span class="hljs-number">0</span>);<font></font>
  }<font></font>
 }<font></font>
 <font></font>
 <span class="hljs-comment">// </span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hashingSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> startIndex, <span class="hljs-keyword">int</span> endIndex)</span> </span>{<font></font>
  <font></font>
  <span class="hljs-comment">//1.         </span><font></font>
  findMinMax(startIndex, endIndex);<font></font>
  <font></font>
  <span class="hljs-comment">//2.   </span><font></font>
  clearTMP();<font></font>
  <font></font>
  <span class="hljs-comment">//3.       -</span>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=startIndex; i&lt;=endIndex; i++) {<font></font>
   insertValue(hash(source[i]), source[i]);<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">//4.        </span><font></font>
  extract(startIndex, endIndex);<font></font>
 }<font></font>
 <font></font>
 <span class="hljs-comment">//         </span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortPart</span><span class="hljs-params">(<span class="hljs-keyword">int</span> startIndex, <span class="hljs-keyword">int</span> endIndex)</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">//    500,   -</span>
  <span class="hljs-keyword">if</span>((endIndex - startIndex) &lt;= SORTBLOCK ) {<font></font>
     hashingSort(startIndex, endIndex);<font></font>
     <span class="hljs-keyword">return</span>;<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">//  &gt; 500        </span>
  <span class="hljs-keyword">int</span> mediana = startIndex + (endIndex - startIndex) / <span class="hljs-number">2</span>;<font></font>
  sortPart(startIndex, mediana);<span class="hljs-comment">//   </span>
  sortPart(mediana+<span class="hljs-number">1</span>, endIndex);<span class="hljs-comment">//   </span>
  stickParts(startIndex, mediana, endIndex);<span class="hljs-comment">//   -  </span><font></font>
 }<font></font>
 <font></font>
 <span class="hljs-comment">//      </span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">()</span> </span>{<font></font>
  sortPart(<span class="hljs-number">0</span>, SOURCELEN-<span class="hljs-number">1</span>);<font></font>
 }   <font></font>
 <font></font>
 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<font></font>
  HashSort hs = <span class="hljs-keyword">new</span> HashSort();<font></font>
  hs.randomize();<font></font>
  hs.sort();<font></font>
 }<font></font>
<font></font>
}</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
式自体はハッシュ関数と呼ばれ、近似分布の補助配列はハッシュテーブルと呼ばれます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">補間とヒストグラム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラッシュ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロキシマップ</font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/jw/w-/qu/jww-queszzqnwmoa2hm-kfwu-9o.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソロモン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハッシュテーブル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラッシュ</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シリーズ記事：</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExcelアプリケーションAlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交換ソート</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">挿入ソート</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">選択順に並べ替え</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マージソート</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分布で並べ替え</font></font></a><ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おおよその分布でソートをカウントする</font></font></b></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アメリカの旗の並べ替え</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビット単位の並べ替えのサフィックスツリー</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分布ソートの比較</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハイブリッドソーティング</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
近似ソートがAlgoLab Excelアプリケーションに表示されました（この場合、ソートされていない初期配列では、ランダムな小数部が整数に追加されています）。</font><font style="vertical-align: inherit;">SolomonとFlashは長い間存在していますが、補間、ハッシュ、およびヒストグラムはまだ実装されていません。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja478640/index.html">オープンソースの自動運転車</a></li>
<li><a href="../ja478642/index.html">MOXA Nport-インサイドルック</a></li>
<li><a href="../ja478646/index.html">JetQuad：垂直離着陸を備えた航空機</a></li>
<li><a href="../ja478650/index.html">ドーン3D</a></li>
<li><a href="../ja478652/index.html">DNSパケット構造</a></li>
<li><a href="../ja478658/index.html">親切に目を覚ますには？新しい夜明けプラス光目覚まし時計</a></li>
<li><a href="../ja478660/index.html">エンジニアはCERNで粒子トラップを最適化</a></li>
<li><a href="../ja478666/index.html">YM3812のUSBサウンドカード</a></li>
<li><a href="../ja478670/index.html">攻撃者がテレグラムで通信を読み取る方法。そして、どうすればそれを防ぐことができますか</a></li>
<li><a href="../ja478672/index.html">AIテストとスタートアップ：Adam Carmi（Applitools）へのインタビュー</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>