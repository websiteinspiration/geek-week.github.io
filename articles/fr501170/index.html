<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💰 👵🏻 👊🏿 La meilleure façon de travailler avec le DOM 👩‍💼 🎅🏿 🥥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendant que j'écrivais sur Solid , j'ai eu l'opportunité d'estimer le nombre de tentatives d'optimisation des performances sur les graphes (benchmarks...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>La meilleure façon de travailler avec le DOM</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501170/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendant que j'écrivais sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solid</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , j'ai eu l'opportunité d'estimer le nombre de tentatives d'optimisation des performances sur les graphes (benchmarks). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DOM est un développement de goulot d'étranglement frontal. </font><font style="vertical-align: inherit;">Différentes solutions peuvent conduire à des résultats similaires. </font><font style="vertical-align: inherit;">De nouvelles bibliothèques apparaissent chaque semaine, incorporant les meilleures des précédentes, pour faire la combinaison parfaite. </font><font style="vertical-align: inherit;">Après un certain temps, mes yeux commencent à fuir une telle variété de solutions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ne vous méprenez pas. </font><font style="vertical-align: inherit;">J'adore voir de nouvelles idées prendre vie, mais elles ont toutes des défauts et entraînent parfois une perte de commodité ou de productivité. </font><font style="vertical-align: inherit;">Je comprends les conséquences d'une telle décision, mais je veux partager mes observations. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelle est la façon la plus rapide de travailler avec le DOM:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dom virtuel</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Littéraux de modèle balisés </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observables à grain fin</font></font></li>
</ul><a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparaison</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JS Frameworks Benchmark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le meilleur projet open source pour comparer les performances des frameworks d'interface utilisateur JavaScript. </font><font style="vertical-align: inherit;">Il est préférable d'exécuter les tests localement au lieu d'utiliser les résultats officiels. </font><font style="vertical-align: inherit;">Les résultats peuvent varier selon la machine. </font><font style="vertical-align: inherit;">Comme je teste sur une machine faible, les performances chuteront sensiblement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je prendrai les meilleures approches dans le rendu d'un arbre DOM pour illustrer la redondance de certaines solutions. </font><font style="vertical-align: inherit;">Je vais le faire en utilisant la capacité de Solid à prendre en charge différentes options de rendu afin d'imposer des coûts à mesure que les variables changent et de le comparer avec des résultats similaires d'autres cadres. </font><font style="vertical-align: inherit;">Jetons-y un œil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Variétés de solide:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solid</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - version du framework avec ES2015 proxy setter en plus des fonctions de suivi des changements intégrées dans les modèles de nœuds DOM clonés. </font><font style="vertical-align: inherit;">Ceci est réalisé en précompilant les modèles JSX </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Code)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">signaux solides</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - cette version est la même que la précédente, mais des signaux bruts sont utilisés à la place des proxys. </font><font style="vertical-align: inherit;">Cela complique l'utilisation de la bibliothèque, mais à la fin, nous obtenons un ensemble plus petit et de meilleures performances </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Code)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allumé en continu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - cette version n'utilise pas la précompilation JSX lors de l'exécution </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Code)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solid-h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Cette version utilise HyperScript pour créer `document.createElement` à la volée. </font><font style="vertical-align: inherit;">Le reste utilise la même implémentation que Solid </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Code)</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autres bibliothèques:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">domc</a> — -,       DOM     DSL (domain specific language)   HTML,    index.html<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"> (Code)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">surplus</a> —       JSX     `document.createElement`. Solid     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"> (Code)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ivi </a> —     Inferno,      DOM.   HyperScript Helpers-esque  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"> (Code)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">lit-html</a> —      ,  c  .     Tagged Template Literals   DOM-<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"> (Code)</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inferno</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le plus rapide des clones React et l'une des bibliothèques Virtual DOM les plus rapides. </font><font style="vertical-align: inherit;">Utilise des directives JSX spéciales pour de meilleures performances </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Code)</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certains de vos frameworks préférés peuvent ne pas être ici, mais cette liste affiche des versions optimisées de toutes les techniques que vous verrez dans les frameworks les plus populaires. </font><font style="vertical-align: inherit;">Vous pouvez le considérer comme un indicateur pour évaluer les capacités maximales de votre bibliothèque. </font><font style="vertical-align: inherit;">Si vous souhaitez comparer les performances des frameworks populaires, je recommande ce tableau. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À titre de comparaison, je voudrais ajouter Web Assembly. </font><font style="vertical-align: inherit;">Malheureusement, au moment d'écrire ces lignes, les enregistrements WASM étaient une implémentation vanille sans abstractions de haut niveau. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Plus tard, ils ont ajouté wasm-bindgen au framework - environ Translator)</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">résultats</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HyperScript (inferno, ivi, solid-h)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HyperScript affiche le balisage comme une composition de fonctions (comme h ou React.createElement). </font><font style="vertical-align: inherit;">Par exemple:</font></font><br>
<br>
<pre><code class="javascript hljs">h(<span class="hljs-string">'div'</span>, {<span class="hljs-attr">id</span>: <span class="hljs-string">'my-element'</span>}, [<font></font>
  h(<span class="hljs-string">'span'</span>, <span class="hljs-string">'Hello'</span>),<font></font>
  h(<span class="hljs-string">'span'</span>, <span class="hljs-string">'John'</span>)<font></font>
])<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les frameworks DOM virtuels ont cette propriété. Même s'ils utilisent JSX ou d'autres moteurs de modèle DSL - sous le capot, ils sont toujours convertis en méthodes de rendu élément par élément. Ceci est utilisé pour construire une arborescence DOM virtuelle pour chaque cycle de rendu. Mais, comme illustré ici, les fonctions rendues peuvent être utilisées pour créer un graphe de dépendances réactives, comme dans le cas de Solid. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1t/lp/av/1tlpavyaaxibat0dsnz84dlgcv4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, les bibliothèques avec un DOM virtuel sont beaucoup plus rapides. Solid perd des performances en raison de la création excessive d'un graphe réactif. Notez la différence dans les repères # 1, # 2, # 7, # 8, # 9. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uf/jo/ne/ufjonerq7jqkd4r31x3sfwtcy7o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mémoire est moins convaincante. Inferno et cette version de Solid affichent à peu près le même résultat. Alors qu'ivi utilise plus de mémoire.</font></font><br>
<blockquote>   ,  Solid,  ,    VDOM. Solid            ,     DOM,     DOM. Solid  JSX    DOM .               ,  . Solid  fine grained evaluation    .  -  .<br>
 — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"></a><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les cadres de suivi des mises à jour réactifs affichent de meilleurs résultats lors de la mise à jour des lignes. </font><font style="vertical-align: inherit;">Ce graphique expliquerait la popularité du VDOM ces dernières années. </font><font style="vertical-align: inherit;">Il suffit de dire que si vous utilisez HyperScript avec cette mise à jour, vous feriez mieux de basculer vers Virtual DOM.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modèles de chaînes (domc, lit-html, solid-lit)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque bibliothèque ici a quelque chose en commun. Ils sont rendus sur la base de modèles d'éléments de clonage, exécutés au moment de l'exécution et n'utilisent pas de VDOM. Mais ils ont encore des différences. DomC et lit-html utilisent des différences descendantes similaires à Virtual DOM, tandis que Solid utilise un graphique réactif. Lit-html divise les modèles en parties. DomC et Solid compile le modèle dans des chemins distincts lors de l'exécution et les met à jour. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/h3/iu/lv/h3iulvmkhg6y1og6dslnc3pt8i8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette catégorie a la gamme de performances la plus large. DomC est le plus rapide et lit-html est le plus lent. Solid Lit est au milieu. DomC démontre que la simplicité du code conduit aux meilleures performances. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DomC s'affaisse uniquement dans la section # 4 car il calcule la différence de nœuds, ce qui devient plus compliqué à mesure que la profondeur augmente. C'est assez rapide, mais vous devez valider les résultats sur les mégadonnées.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solid Lit est plus productif que Solid HyperScript. La compilation instantanée en runtime supprime les inconvénients de la création d'un graphe réactif, permettant au framework de rattraper ivi, la bibliothèque VDOM la plus rapide (voir le tableau complet à la fin de l'article). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/0m/h1/vo/0mh1vo1qzvthbjsvsol1mpopdgg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DomC a montré de bons résultats en termes de consommation de mémoire. Cela est dû au clonage des éléments du modèle. Il est à noter que la génération de code lors de l'exécution peut avoir des coûts de performances minimes par rapport à la compilation au stade de la construction. C'est peut-être une comparaison injuste pour lit-html car le framework n'utilise pas cette technique. Mais il est juste de dire que lit-html ou des bibliothèques similaires comme hyperHTML ou lighterHTML ne sont pas le meilleur moyen d'implémenter des littéraux de modèle balisés. Et vous pouvez obtenir de bons résultats même en exécution sans VDOM.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSX précompilé (solide, signaux solides, surplus)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces bibliothèques utilisent JSX, qui se compile dans un DOM ou un graphe réactif au stade de la construction. </font><font style="vertical-align: inherit;">Les modèles peuvent être n'importe quoi, mais JSX fournit une arborescence de syntaxe propre qui améliore l'expérience du développeur. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q5/ik/c7/q5ikc7iohyy8m5lyydzhijzylaq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce groupe a des résultats similaires, mais la différence est très importante. </font><font style="vertical-align: inherit;">Tous les </font><font style="vertical-align: inherit;">trois utilisent la même bibliothèque pour gérer </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> état </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En utilisant l'exemple Solid Signals, vous pouvez voir que les fonctions de suivi avec le clonage des éléments de modèle donnent de meilleures performances. </font><font style="vertical-align: inherit;">L'implémentation standard de Solid est surchargée à l'aide des proxys ES2015, ce qui aggrave le résultat sur tous les graphiques. </font><font style="vertical-align: inherit;">Surplus utilise `document.createElement`, ce qui dégrade les performances sur les tests où les lignes # 1, # 2, # 7, # 8 sont créées.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fv/7_/by/fv7_bynjjqiyp8u_ss3l0cqsmtc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La consommation de mémoire a des résultats similaires. </font><font style="vertical-align: inherit;">Dans ce cas, les proxys ajoutent plus de complexité que les éléments de modèle de clonage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La conclusion ici est que les proxys dégradent les performances et plus de bibliothèques devraient cloner les modèles. </font><font style="vertical-align: inherit;">D'un autre côté, vous pouvez considérer une petite perte de performance due aux procurations comme un investissement. </font><font style="vertical-align: inherit;">L'exemple Solid a la plus petite quantité de code parmi d'autres exemples - seulement 66 lignes, il a 13% moins d'espaces non blancs que Svelte - une bibliothèque qui se targue de son minimalisme.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meilleur de sa catégorie (domc, ivi, signaux solides, vanillajs)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenons maintenant les gagnants de chaque catégorie et comparons-les avec l'exemple brutal, efficace et écrit à la main en JavaScript vanille. Chaque implémentation représente l'une des solutions de suivi d'état les plus populaires. Vous pouvez même faire une analogie entre ces bibliothèques et les Big Three: Solid → Vue, DomC → Angular, ivi → React. Vous obtiendrez ce résultat si vous supprimez tout ce qui est superflu, à l'exception du rendu, et que vous vous débarrassez du code 60-200kb. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sy/lj/9c/sylj9c8bd1xzzwehg0o-z7mvyei.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DomC et Solid sont proches en termes de performances, ivi est nettement en retard, mais DomC, dans l'ensemble, est plus rapide. Sa complexité par rapport à vanillaJS est sensiblement moindre, mais elle est moins efficace avec des mises à jour partielles. Seul ce critère n'est pas indicatif. Quiconque pense que le VDOM est lent ou a des complications inutiles devrait le vérifier par lui-même.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La plupart des bibliothèques n'auront jamais ce genre de performances. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mz/zp/bx/mzzpbxqifmdadvbjm3ydk3pxy2a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DomC est également leader dans le graphique avec la mémoire. </font><font style="vertical-align: inherit;">Le solide à grain fin surpasse le VDOM ivi en termes de consommation de mémoire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fait intéressant, ces bibliothèques ne sont pas bien pires que vanillaJS, quelle que soit la méthode. </font><font style="vertical-align: inherit;">Ils sont tous très rapides.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taille du paquet</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, je voudrais aborder la taille du paquet. </font><font style="vertical-align: inherit;">De nombreux tests réels se concentrent uniquement sur ces mesures. </font><font style="vertical-align: inherit;">Oui, la taille de l'ensemble est importante et a une corrélation directe avec les performances, mais quelle est la différence? </font><font style="vertical-align: inherit;">Je soupçonne que la complexité du code est plus importante que la taille.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-t/m7/yb/-tm7ybrxshulxxcbcufybomwzjq.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme d'habitude, les résultats dans de tels graphiques ne sont jamais complètement convaincants. Le processus lui-même et les conclusions que nous tirons sont importants. Dans ce cas, nous voyons que le DOM lui-même est un gros goulot d'étranglement en matière de performances. À tel point qu'il n'y a pas de technique sans équivoque pour le contourner. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ll/7v/qa/ll7vqadwntgwoae6oepqwwbsalc.jpeg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Christoper Lambert comme The Highlander</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Non, ce n'est pas si simple. Ni le DOM ni le VDOM ne sont lents. Mais je crois qu'ils se valent. J'avoue que la rhétorique du VDOM Performance React m'a conduit à ces réflexions. L'ignorance des opinions sur ce sujet est exaspérante.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'affirmation selon laquelle la VDOM est lente est due à une mauvaise sensibilisation. Rendre VDOM et calculer la différence d'état est une complication par rapport à ne pas le faire. Mais son absence est-elle évolutive? Et comment faire des changements de données?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vois qu'il y a une exception dans chaque règle. En général, la précompilation combinée avec Fine-Grained dans des cadres réactifs est la solution la plus rapide. Mais DomC affiche de hautes performances sans lui. Les méthodes JS natives, telles que le clonage d'éléments de modèle avec des littéraux de modèle étiquetés, peuvent être la meilleure solution pour implémenter lit-html de grandes sociétés (Google). Mais c'est l'un des cadres les plus lents de ce tableau et même pas la meilleure mise en œuvre de ces technologies. Svelte est considérée comme la bibliothèque la plus rapide de la communauté, mais elle ne pouvait même pas rivaliser étroitement avec les solutions présentées.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si la programmation réactive gagne, cela ne signifie pas que toutes les bibliothèques réactives sont rapides ou que les métriques signifient tout. </font><font style="vertical-align: inherit;">Malgré la comparaison approfondie de cet article, je pense qu'en réalité, il existe des bibliothèques rapides et des bibliothèques plus lentes. </font><font style="vertical-align: inherit;">Même si nous trouvons une super technologie, nous ferons toujours face à ses limites. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résultats des tests de toutes les bibliothèques dans une seule table:</font></font></b><br>
<br>
<img src="https://habrastorage.org/webt/gg/3u/oq/gg3uoqckygryprsownwet3r12jq.png"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr501158/index.html">Rendre Android View Binding pratique avec Kotlin</a></li>
<li><a href="../fr501162/index.html">Comparaison de scènes de rap russe en utilisant les techniques de R et de Text Mining. Noize Mc et Kasta contre Pharaon et Morgenshtern</a></li>
<li><a href="../fr501164/index.html">Visualisation des topologies de réseau, ou pourquoi d'autre ingénieur réseau Python # 2</a></li>
<li><a href="../fr501166/index.html">oVirt en 2 heures. Partie 1. Plateforme de virtualisation de basculement ouverte</a></li>
<li><a href="../fr501168/index.html">Les aides-soignants se sauvent - sauvegardent-ils, sauvegardent-ils, s'épuisent-ils?</a></li>
<li><a href="../fr501172/index.html">Mon ordinateur Mikrosh: continuez la semaine de la nostalgie</a></li>
<li><a href="../fr501178/index.html">Comment regarder du porno affecte la productivité du travail et des études</a></li>
<li><a href="../fr501180/index.html">[Post-Question] Avez-vous besoin d'un mouvement informatique pour FAITS sur le coronavirus et les «effets secondaires»</a></li>
<li><a href="../fr501182/index.html">oVirt en 2 heures. Partie 2. Installation du gestionnaire et des hôtes</a></li>
<li><a href="../fr501184/index.html">Comment configurer Apollo pour fonctionner avec GraphQL dans Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>