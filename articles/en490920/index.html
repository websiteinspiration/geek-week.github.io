<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úä üëü üòá Accelerate your search in Have I Been Pwned to 49 microseconds (C ++) üì∑ ‚õàÔ∏è ü•à</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have long known about the Have I Been Pwned (HIBP) site . True, until recently, he had never been there. I always had two passwords. One of them was...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Accelerate your search in Have I Been Pwned to 49 microseconds (C ++)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490920/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/rg/hn/furghncw9u08teobuskqawx2y7u.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I have long known about the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Have I Been Pwned (HIBP) site</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . True, until recently, he had never been there. I always had two passwords. One of them was repeatedly used for garbage mail and a couple of accounts on strange sites. But I had to refuse it, because the mail was hacked. And to be honest, I‚Äôm grateful to the hacker because this event made me review my passwords - the way I use and store them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, I changed passwords on all accounts where there was a compromised password. Then I wondered if the leaked password was in the HIBP database. I did not want to enter the password on the site, so I downloaded the database (</font></font><code>pwned-passwords-sha1-ordered-by-count-v5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">The base is very impressive. </font><font style="vertical-align: inherit;">This is a 22.8 GB text file with a set of SHA-1 hashes, one in each line with a counter, how many times the password with this hash occurred in leaks. </font><font style="vertical-align: inherit;">I figured out the SHA-1 of my cracked password and tried to find it.</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contents</font></font></h1><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[G] rep</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trie structure</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binary search</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sorting</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why merge back?</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallelism</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Don't be a selfish bastard</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B3</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insertion Sort</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separate or not?</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HIBP Tree Properties</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Output file</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmarks</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">okon - library and CLI</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links and discussion</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks for reading</font></font></a></li>
</ul><br>
<a name="1"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[G] rep</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have a text file with a hash in each line. </font><font style="vertical-align: inherit;">Probably the best place to go is grep. </font></font><br>
<br>
<code>grep -m 1 '^XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX' pwned-passwords-sha1-ordered-by-count-v5.txt</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My password was at the top of the list with a frequency of more than 1,500 times, so it really sucks. </font><font style="vertical-align: inherit;">Accordingly, the search results returned almost instantly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But not everyone has weak passwords. </font><font style="vertical-align: inherit;">I wanted to check how long it would take to find the worst case scenario - the last hash in the file: </font></font><br>
<br>
<code>time grep -m 1 '^4541A1E4605EEBF3F4C166329C18502DF75D348A' pwned-passwords-sha1-ordered-by-count-v5.txt</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Result: </font></font><code>33,35s user 23,39s system 41% cpu 2:15,35 total</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is sad. </font><font style="vertical-align: inherit;">After all, since my mail was hacked, I wanted to check the presence of all my old and new passwords in the database. </font><font style="vertical-align: inherit;">But a two-minute grep simply does not allow you to comfortably do this. </font><font style="vertical-align: inherit;">Of course, I could write a script, run it and go for a walk, but this is not an option. </font><font style="vertical-align: inherit;">I wanted to find a better solution and learn something.</font></font><br>
<br>
<a name="2"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trie structure</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first idea was to use a trie data structure. The structure seems ideal for storing SHA-1 hashes. The alphabet is small, so the nodes will also be small, as will the resulting file. Maybe it even fits in RAM? Key search should be very fast. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So I implemented this structure. Then he took the first 1,000,000 hashes of the source database to build the resulting file and check if everything is in the created file. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yes, I could find everything in the file, so the structure worked well. The problem was different.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The resulting file was released in size 2283686592B (2.2 GB). This is not good. Let's count and see what happens. A node is a simple structure of sixteen 32-bit values. The values ‚Äã‚Äãare "pointers" to the following nodes with the specified SHA-1 hash symbol. So, one node takes 16 * 4 bytes = 64 bytes. It seems to be a little? But if you think about it, one node represents one character in a hash. Thus, in the worst case, the SHA-1 hash will take 40 * 64 bytes = 2560 bytes. This is much worse than, for example, a textual representation of a hash that takes up only 40 bytes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The trie structure has the advantage of reusing nodes. If you have two words </font></font><code>aaa</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>abb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then the node for the first characters is reused, because the characters are the same - </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's get back to our problem. </font><font style="vertical-align: inherit;">Let's calculate how many nodes are stored in the resulting file: </font></font><code>file_size / node_size = 2283686592 / 64 = 35682603</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's see how many nodes will be created in the worst case from a million hashes: </font></font><code>1000000 * 40 = 40000000</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, the trie structure reuses only </font></font><code>40000000 - 35682603 = 4317397</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nodes, which is 10.8% of the worst-case scenario. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With such indicators, the resulting file for the entire HIBP database would take 1421513361920 bytes (1.02 TB). </font><font style="vertical-align: inherit;">I don‚Äôt even have enough hard drive to check the speed of key search. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That day, I found out that the trie structure is not suitable for relatively random data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look for another solution.</font></font><br>
<br>
<a name="3"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binary search</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SHA-1 hashes have two nice features: they are comparable to each other and they are all the same size. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thanks to this, we can process the original HIBP database and create a file from the sorted SHA-1 values. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But how to sort a 22 GB file? </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Question. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why sort the source file? </font><font style="vertical-align: inherit;">HIBP returns a file with strings already sorted by hashes. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Answer. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I just did not think about it. </font><font style="vertical-align: inherit;">At that moment I did not know about the sorted file.</font></font></i> <br>
<br>
<a name="4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sorting</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sorting all the hashes in RAM is not an option; I don't have much RAM. </font><font style="vertical-align: inherit;">The solution was this:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Split a large file into smaller ones that fit in RAM.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Download data from small files, sort in RAM and write back to files.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combine all small, sorted files into one big one.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With a large sorted file, you can search our hash using a binary search. </font><font style="vertical-align: inherit;">Hard drive access matters. </font><font style="vertical-align: inherit;">Let's calculate how many hits are required in a binary search: </font></font><code>log2(555278657) = 29.0486367039</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is, 30 hits. </font><font style="vertical-align: inherit;">Not so bad. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the first stage, optimization can be performed. </font><font style="vertical-align: inherit;">Convert text hashes to binary data. </font><font style="vertical-align: inherit;">This will reduce the size of the resulting data by half: from 22 to 11 GB. </font><font style="vertical-align: inherit;">Fine.</font></font><br>
<br>
<a name="5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why merge back?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At that moment, I realized that you can do smarter. </font><font style="vertical-align: inherit;">What if you do not combine small files into one large one, but conduct a binary search in sorted small files in RAM? </font><font style="vertical-align: inherit;">The problem is how to find the desired file in which to look for the key. </font><font style="vertical-align: inherit;">The solution is very simple. </font><font style="vertical-align: inherit;">New approach:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create 256 files with the names "00" ... "FF".</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When reading hashes from a large file, write hashes that begin with ‚Äú00 ..‚Äù to a file called ‚Äú00‚Äù, hashes that begin with ‚Äú01 ..‚Äù - to a file ‚Äú01‚Äù and so on.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Download data from small files, sort in RAM and write back to files.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything is very simple. </font><font style="vertical-align: inherit;">In addition, another optimization option appears. </font><font style="vertical-align: inherit;">If the hash is stored in the file ‚Äú00‚Äù, then we know that it begins with ‚Äú00‚Äù. </font><font style="vertical-align: inherit;">If the hash is stored in the file "F2", then it begins with "F2". </font><font style="vertical-align: inherit;">Thus, when writing hashes to small files, we can omit the first byte of each hash! </font><font style="vertical-align: inherit;">This is 5% of all data. </font><font style="vertical-align: inherit;">555 MB is saved in total.</font></font><br>
<br>
<a name="6"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallelism</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Separation into smaller files provides another opportunity for optimization. </font><font style="vertical-align: inherit;">Files are independent of each other, so we can sort them in parallel. </font><font style="vertical-align: inherit;">We remember that all your processors like to sweat at the same time;)</font></font><br>
<br>
<a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Don't be a selfish bastard</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When I implemented the above solution, I realized that other people probably had a similar problem. Probably many others also download and search the HIBP database. So I decided to share my work. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before that, I once again revised my approach and found a couple of problems that I would like to fix before posting the code and tools on Github. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Firstly, as an end user, I would not want to use a tool that creates many strange files with strange names, in which it is not clear what is stored, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, this can be solved by combining the files "00" .. "FF" in one big file.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unfortunately, having one large file for sorting poses a new problem. </font><font style="vertical-align: inherit;">What if I want to insert a hash in this file? </font><font style="vertical-align: inherit;">Just one hash. </font><font style="vertical-align: inherit;">This is only 20 bytes. </font><font style="vertical-align: inherit;">Oh, the hash starts with "000000000 ..". </font><font style="vertical-align: inherit;">Okay. </font><font style="vertical-align: inherit;">Let's free up space for it by moving 11 GB of other hashes ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You understand what the problem is. </font><font style="vertical-align: inherit;">Inserting data in the middle of a file is not the fastest operation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another drawback of this approach is that you need to store the first bytes again - it is 555 MB of data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And last but not least, a binary search on data stored on a hard drive is much slower than accessing RAM. </font><font style="vertical-align: inherit;">I mean, this is 30 disk reads versus 0 disk reads.</font></font><br>
<br>
<a name="8"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B3</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Again. </font><font style="vertical-align: inherit;">What we have and what we want to achieve. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have 11 GB of binary values. </font><font style="vertical-align: inherit;">All values ‚Äã‚Äãare comparable and have the same size. </font><font style="vertical-align: inherit;">We want to find out if a particular key is present in the stored data, and also want to change the database. </font><font style="vertical-align: inherit;">And so that everything works quickly. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/18c/851/d23/18c851d23c6bbe290fcccb763c6f09eb.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
B-tree? </font><font style="vertical-align: inherit;">Right </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The B-tree allows you to minimize access to the disk when searching, modifying, etc. It has much more features, but we need these two.</font></font><br>
<br>
<a name="9"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insertion Sort</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first step is to convert the data from the HIBP source file to the B-tree. This means that you need to extract all the hashes in turn and insert them into the structure. The usual insertion algorithm is suitable for this. But in our case, you can do better. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inserting a lot of raw data into a B-tree is a well-known scenario. Wise people have invented a better approach for this than the usual insert. First of all, you need to sort the data. This can be done as described above (split the file into smaller ones and sort them in RAM). Then insert the data into the tree.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the usual algorithm, if you find the leaf node where you want to insert the value and it is filled, then you create a new node (on the right) and evenly distribute the values ‚Äã‚Äãbetween the two nodes, left and right (plus one value goes to the parent node but it‚Äôs not important here). In short, the values ‚Äã‚Äãin the left node are always less than the values ‚Äã‚Äãin the right. The fact is that when you insert the sorted data, you know that smaller values ‚Äã‚Äãwill no longer be inserted into the tree, so no more values ‚Äã‚Äãwill go to the left node. The left node remains half empty all the time. Moreover, if you insert enough values, you may find that the right node is full, so you need to move half the values ‚Äã‚Äãto the new right node. The split node remains half empty, as in the previous case. Etc‚Ä¶</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, after all the inserts, you get a tree in which almost all the nodes are half empty. </font><font style="vertical-align: inherit;">This is not a very efficient use of space. </font><font style="vertical-align: inherit;">We can do better.</font></font><br>
<br>
<a name="10"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separate or not?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the case of inserting sorted data, you can make a small modification to the insertion algorithm. </font><font style="vertical-align: inherit;">If the node into which you want to paste the value is full, do not break it. </font><font style="vertical-align: inherit;">Just create a new, empty node and paste the value into the parent node. </font><font style="vertical-align: inherit;">Then, when you insert the following values ‚Äã‚Äã(which are larger than the previous ones), you insert them into a fresh, empty node. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To preserve the properties of the B-tree, after all insertions, it is necessary to sort out the rightmost nodes in each layer of the tree (except the root) and evenly divide the values ‚Äã‚Äãof this extreme node and its left neighbor. </font><font style="vertical-align: inherit;">So you get the smallest possible tree.</font></font><br>
<br>
<a name="11"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HIBP Tree Properties</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When designing a B-tree, you need to choose its order. </font><font style="vertical-align: inherit;">It shows how many values ‚Äã‚Äãcan be stored in one node, as well as how many children the node can have. </font><font style="vertical-align: inherit;">By manipulating this parameter, we can manipulate the height of the tree, the binary size of the node, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In HIBP, we have </font></font><code>555278657</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hashes. </font><font style="vertical-align: inherit;">Suppose we want a tree three in height (so we need no more than three read operations to check for the presence of a hash). </font><font style="vertical-align: inherit;">We need to find a value of M such that </font></font><code>logM(555278657) &lt; 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">I chose 1024. This is not the smallest possible value, but it leaves it possible to insert more hashes and preserve the height of the tree.</font></font><br>
<br>
<a name="12"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Output file</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The HIBP source file has a size of 22.8 GB. </font><font style="vertical-align: inherit;">The output file with the B-tree is 12.4 GB. </font><font style="vertical-align: inherit;">It takes about 11 minutes to create it on my machine (Intel Core i7-6700, 3.4 GHz, 16 GB RAM), hard disk (not SSD).</font></font><br>
<br>
<a name="13"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmarks</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The B-tree option shows a pretty good result:</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">| </font><font style="vertical-align: inherit;">| </font><font style="vertical-align: inherit;">time [Œºs] | </font><font style="vertical-align: inherit;">% |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
| -----------------: | ------------: | ------------: |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
| </font><font style="vertical-align: inherit;">okon | </font><font style="vertical-align: inherit;">49 | </font><font style="vertical-align: inherit;">100 |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
| </font><font style="vertical-align: inherit;">grep '^ hash' | </font><font style="vertical-align: inherit;">135'350'000 | </font><font style="vertical-align: inherit;">276'224'489 |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
| </font><font style="vertical-align: inherit;">grep | </font><font style="vertical-align: inherit;">135'480'000 | </font><font style="vertical-align: inherit;">276'489'795 |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
| </font><font style="vertical-align: inherit;">C ++ line by line | </font><font style="vertical-align: inherit;">135'720'201 | </font><font style="vertical-align: inherit;">276'980'002 |</font></font></pre><br>
<a name="14"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">okon - library and CLI</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As I said, I wanted to share my work with the world. I implemented a library and command line interface for processing the HIBP database and quickly searching for hashes. The search is so fast that it can, for example, be integrated into a password manager and give feedback to the user each time a key is pressed. There are many possible uses. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The library has a C interface, so it can be used almost everywhere. CLI is a CLI. You can simply build and run (: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The code is in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Disclaimer: okon does not yet provide an interface for inserting values ‚Äã‚Äãinto the created B-tree. </font><font style="vertical-align: inherit;">It can only process the HIBP file, create a B-tree and search in it. </font><font style="vertical-align: inherit;">These functions work quite well, so I decided to share the code and continue working on the insert and other possible functions.</font></font><br>
<br>
<a name="15"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links and discussion</font></font></h1><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trie structure</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B-tree</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Website Have I Been Pwned</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code repository</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r / cpp</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r / security</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacker news</font></font></a></li>
</ul><br>
<a name="16"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks for reading</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(:</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en490906/index.html">Yandex rolled out a beta of an independent Aura - aura.top. Is it top?</a></li>
<li><a href="../en490908/index.html">Zone data storage</a></li>
<li><a href="../en490912/index.html">How we at Sportmaster chose a caching system. Part 1</a></li>
<li><a href="../en490916/index.html">Problems of interaction with external teams on large projects</a></li>
<li><a href="../en490918/index.html">Andrei Zaretsky, Alexander Trukhanov (continued): ‚ÄúWe did not have a name, but there was arrogance‚Äù</a></li>
<li><a href="../en490924/index.html">What is Windows PowerShell and what does it eat? Part 2: Introduction to the programming language</a></li>
<li><a href="../en490926/index.html">Unity ball trajectory 2d for beginners</a></li>
<li><a href="../en490932/index.html">[Forecast] Motornet - a data exchange network for robotic vehicles</a></li>
<li><a href="../en490936/index.html">Create ML on iOS</a></li>
<li><a href="../en490938/index.html">We write thousands of log files at a time</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>