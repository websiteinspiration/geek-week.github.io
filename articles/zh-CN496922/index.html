<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌲 ✊🏼 👲 关于作业NeoQUEST-2020示例的反向客户端-服务器apk指南 ♎️ 🕑 👃🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，我们有了一个丰富的程序（一次将有很多网络安全领域！）：考虑对Android应用程序进行反编译，拦截流量以获取URL，在没有源代码的情况下重建apk，使用密码分析器等等： 
 
 根据传说NeoQUEST-2020，英雄发现了必须用于获取密钥的旧机器人零件。让我们开始吧！
 
 1.逆转apk
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>关于作业NeoQUEST-2020示例的反向客户端-服务器apk指南</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/neobit/blog/496922/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/f0/7j/vf/f07jvfe9r6534tbgp9bwdruryvy.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今天，我们有了一个丰富的程序（一次将有很多网络安全领域！）：考虑对Android应用程序进行反编译，拦截流量以获取URL，在没有源代码的情况下重建apk，使用密码分析器等等： </font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据传说</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NeoQUEST-2020</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，英雄发现了必须用于获取密钥的旧机器人零件。</font><font style="vertical-align: inherit;">让我们开始吧！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.逆转apk</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，在我们设法从半拆卸式机器人中提取一点点东西之前，这是一个</font><font style="vertical-align: inherit;">可以以某种方式帮助我们获取密钥</font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apk应用程序</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。让我们做最明显的事情：运行apk并查看其功能。毫无疑问，它不仅具有简约的应用程序界面，而且是一个自定义FileDroid文件客户端，可让您从远程服务器下载文件。好吧，看起来很简单。我们将电话连接到Internet，尝试进行下载（立即为key.txt-好吧，如果呢？）-服务器未成功丢失文件。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/b4/kf/z3/b4kfz3wd44ev6ckfy664ba0ugho.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就复杂性而言，我们进入下一个事件-我们使用</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">JADX</font></a><font style="vertical-align: inherit;">反编译apk</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并分析应用程序的源代码，幸运的是，这些源代码完全没有被混淆。我们当前的任务是了解远程服务器提供哪些文件下载，并从中选择带有密钥的文件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们从com.ctf.filedroid.MainActivity类开始，该类包含onClick（）方法，这对我们来说是最有趣的，其中处理“下载”按钮的单击。在此方法内部，两次调用ConnectionHandler类：首先，调用ConnectionHandler.getToken（）方法，然后才调用通过用户请求的文件名的ConnectionHandler.getEncryptedFile（）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m5/66/by/m566byk1sozhodekerf1ggpf1hc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是的，也就是说，首先我们需要一个令牌！我们将进一步研究获得它的过程。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ConnectionHandler.getToken（）方法接受两行输入，然后发送GET请求，并将这些行作为“ crc”和“ sign”参数传递。作为响应，服务器以JSON格式发送数据，我们的应用程序从该数据中提取访问令牌并使用它来下载文件。当然，这一切都很好，但是“ crc”和“ sign”是什么？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yn/gy/lg/yngylgy7dstfocghhk0w_eufgcg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了理解这一点，我们进一步走向Checks类，请提供badHash（）和badSign（）方法。第一个从classes.dex和resources.arsc计算校验和，将这两个值连接起来并包装在Base64中（注意标志10 = NO_WRAP | URL_SAFE，它将派上用场）。那第二种方法呢？并且他对应用程序签名的SHA-256指纹进行了相同的处理。嗯，看来FileDroid并不是真的很想重建:(</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lj/yj/xo/ljyjxoxvrlc8q3pjfxyrerya5ho.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好的，假设我们收到了令牌。下一步是什么？我们将其传递给ConnectionHandler.getEncryptedFile（）方法的输入，该方法将请求的文件的名称附加到令牌上并生成另一个GET请求，这次使用“ token”和“ file”参数。作为响应的服务器（根据方法的名称判断）发送一个加密的文件，该文件存储在/ sdcard /中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，归纳一下小计：我们有两个新闻，而且...都是不好的。首先，FileDroid并不真正支持我们修改apk的热情（检查校验和和签名），其次，从服务器接收的文件承诺将被加密。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好的，当问题出现时，我们将解决它们，现在的主要问题是我们仍然不知道需要下载哪个文件。但是，在研究ConnectionHandler类时，我们不禁注意到，在getToken（）和getEncryptedFile（）方法之间，FileDroid开发人员忘记了另一个非常诱人的方法，称为getListing（）名称。因此，服务器支持此类功能。。。这似乎就是您所需要的！</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fk/xz/v1/fkxzv1ac9ictxo7gy67ku_u44nq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要获得列表，我们将需要众所周知的“ crc”和“ sign”-没问题，我们已经知道它们来自何处。</font><font style="vertical-align: inherit;">我们读取值，发送GET请求，然后...停止。</font><font style="vertical-align: inherit;">我们将在哪里发送GET请求？</font><font style="vertical-align: inherit;">最好先获取远程服务器URL。</font><font style="vertical-align: inherit;">嗯，我们回到MainActivity.onClick（），看看如何生成netPath参数来调用getToken（）和getEncryptedFile（）方法：</font></font><br>
<br>
<pre><code class="coffeescript hljs">Method getSecureMethod = <font></font>
wat.class.getDeclaredMethod("getSecure", <span class="hljs-keyword">new</span> Class[]{String.class});<font></font>
<font></font>
// . . .<font></font>
<font></font>
// netPath --&gt; ConnectionHandler.getToken()<font></font>
(String) getSecureMethod.invoke((Object) <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> Object[]{"fnks"})<font></font>
<font></font>
// netPath --&gt; ConnectionHandler. getEncryptedFile()<font></font>
(String) getSecureMethod.invoke((Object) <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> Object[]{"qdkm"})
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
奇怪的字母组合“ fnks”和“ qdmk”迫使我们转向wat.getSecure（）方法的反编译结果。</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">剧透：JADX的结果一般。</font></font></s><br>
<br>
<img src="https://habrastorage.org/webt/-r/ih/gi/-rihgizr3f3kvj0uge_1ekoaxsa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
经过仔细检查，很明显，该方法的所有这些不太令人满意的内容都可以用这种普通的开关盒代替：</font></font><br>
<br>
<pre><code class="coffeescript hljs"><span class="hljs-regexp">//</span> . . .
<span class="hljs-keyword">switch</span>(CODE)<font></font>
{<font></font>
    case «qdkm»: <font></font>
        r<span class="hljs-number">.2</span> = com.ctf.filedroid.x37AtsW8g.rlieh786d(<span class="hljs-number">2</span>);
        <span class="hljs-keyword">break</span>;<font></font>
    case «tkog»: <font></font>
        r2 = com.ctf.filedroid.x37AtsW8g.rlieh786d(<span class="hljs-number">1</span>);
        <span class="hljs-keyword">break</span>;<font></font>
    case «fnks»: <font></font>
        String r2 = com.ctf.filedroid.x37AtsW8g.rlieh786d(<span class="hljs-number">0</span>);
	<span class="hljs-keyword">break</span>;<font></font>
}<font></font>
java.lang.StringBuilder r1 = <span class="hljs-keyword">new</span> java.lang.StringBuilder <font></font>
r1.&lt;init&gt;(r2) <font></font>
java.lang.String r0 = r1.toString() <font></font>
java.lang.String r1 = radon(r0)<font></font>
<span class="hljs-keyword">return</span> r1 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于“ fnks”和“ qdmk”已用于获取令牌并下载文件，因此“ tkog”应提供请求在服务器上列出可用文件所需的URL。</font><font style="vertical-align: inherit;">似乎希望可以廉价地获得所需的路径。首先，让我们看看URL如何存储在应用程序中。</font><font style="vertical-align: inherit;">我们打开com.ctf.filedroid.x37AtsW8g.rlieh786d（）函数，看到每个URL被保存为一个编码的字节数组，该函数本身从这些字节中形成一个字符串并返回它。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yt/4e/xz/yt4exza37qeytal-i9snbrlo4co.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好。</font><font style="vertical-align: inherit;">但是随后，该行传递给函数com.ctf.filedroid.wat.radon（），该函数的实现提交给本地库libae3d8oe1.so。</font><font style="vertical-align: inherit;">反向arm64？</font><font style="vertical-align: inherit;">不错的尝试，FileDroid，但又来一次吗？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.获取服务器URL</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们尝试从另一端着手：拦截流量，获取明文形式的URL（并且，还包括校验和和签名值！），将它们与com.ctf.filedroid.x37AtsW8g.rlieh786d（）的字节数组进行匹配-可以加密是否是通常的Caesar或XOR密码？..那么恢复第三个URL并执行列表将并不困难。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要重定向流量，您可以使用任何方便的代理（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Charles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fiddler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BURP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等等。）。我们在移动设备上配置转发，安装适当的证书，验证拦截是否成功，然后启动FileFroid。我们正在尝试下载一个任意文件，然后请参阅“ NetworkError”。此错误是由于存在证书固定引起的（请参阅com.ctf.filedroid.ConnectionHandler.sendRequest方法）：文件客户端验证应用程序中“有线”的证书对应于与其交互的服务器。现在很清楚为什么要控制应用程序资源的完整性！</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8y/su/ya/8ysuya2vqxuwxdzrmt9xsuajq7o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，在拦截的流量中，我们至少可以看到文件客户端访问的服务器的域名，这意味着解密URL的希望仍然存在！</font></font><br>
<br>
<img src="https://habrastorage.org/webt/im/2w/8l/im2w8l7u7b0optrada1cuhbxcge.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们返回com.ctf.filedroid.x37AtsW8g.rlieh786d（）函数，并注意前几十个字节在所有数组中都重合：</font></font><br>
<br>
<pre><code class="coffeescript hljs">cArr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> char[]{<span class="hljs-string">'K'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'Y'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'Q'</span>, <span class="hljs-string">'J'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'0'</span>, <span class="hljs-string">'t'</span>, <span class="hljs-string">'W'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'w'</span>, <span class="hljs-string">'k'</span>, <span class="hljs-string">'N'</span>, <span class="hljs-string">'j'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'K'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'U'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">'Q'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'P'</span>, <span class="hljs-string">'h'</span>, <span class="hljs-string">'V'</span>, <span class="hljs-string">'J'</span>, <span class="hljs-string">'Q'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'L'</span>, <span class="hljs-string">'U'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'p'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'i'</span>, . . .};<font></font>
<font></font>
cArr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> char[]{<span class="hljs-string">'K'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'Y'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'Q'</span>, <span class="hljs-string">'J'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'0'</span>, <span class="hljs-string">'t'</span>, <span class="hljs-string">'W'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'w'</span>, <span class="hljs-string">'k'</span>, <span class="hljs-string">'N'</span>, <span class="hljs-string">'j'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'K'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'U'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">'Q'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'P'</span>, <span class="hljs-string">'h'</span>, <span class="hljs-string">'V'</span>, <span class="hljs-string">'J'</span>, <span class="hljs-string">'Q'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'L'</span>, <span class="hljs-string">'U'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'p'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'j'</span>, . . .};<font></font>
<font></font>
cArr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> char[]{<span class="hljs-string">'K'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'Y'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'Q'</span>, <span class="hljs-string">'J'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'0'</span>, <span class="hljs-string">'t'</span>, <span class="hljs-string">'W'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'w'</span>, <span class="hljs-string">'k'</span>, <span class="hljs-string">'N'</span>, <span class="hljs-string">'j'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'K'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'U'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">'Q'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'P'</span>, <span class="hljs-string">'h'</span>, <span class="hljs-string">'V'</span>, <span class="hljs-string">'J'</span>, <span class="hljs-string">'Q'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'L'</span>, <span class="hljs-string">'U'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'p'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'j'</span>, . . ., <span class="hljs-string">'='</span>};
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，第三个数组的最后一个字节暗示它并非没有base64。</font><font style="vertical-align: inherit;">让我们尝试用URL的已知部分解码并戳出结果字节：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8o/mh/1m/8omh1mtmtqzkcdy7mpqyemyiuzw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
似乎没有人对ARMag3dd0n如此满意！</font><font style="vertical-align: inherit;">事情很小：用找到的密钥顺序解码base64 URL和xorim。</font><font style="vertical-align: inherit;">但是...如果不是XOR，而是一个自制的置换密码，即使尝试100次也无法获得？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.用Frida重建apk</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为本文的一部分，我们将考虑使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frida</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">框架</font><font style="vertical-align: inherit;">，这</font><font style="vertical-align: inherit;">是一种更轻松（并且我们认为更漂亮）的解决方案方法</font><font style="vertical-align: inherit;">，该方法将允许我们在运行时使用所需的参数执行任意apk应用程序方法。</font><font style="vertical-align: inherit;">为此，您需要具有root权限的电话或仿真器。</font><font style="vertical-align: inherit;">我们假设以下行动计划：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在PC和测试电话上安装Frida组件。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">恢复与令牌或列表请求匹配的URL，然后下载文件（使用Frida）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检索原始应用程序的校验和和签名值。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获取存储在服务器上的文件列表，并标识所需的文件。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载并解密文件。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们将阐明植根电话和apk之间的关系。我们安装了该应用程序，然后运行它，但是文件客户端并不想完全启动，它只会闪烁并关闭。我们通过logcat检查消息-是的，是的，FileDroid已经感觉到某些东西不对劲并且可以抵抗。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vn/8s/2b/vn8s2bzyijssy664hsdgcxqnawc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们再次转到MainActivity类，发现在onCreate（）中调用了doChecks（）方法，并且该日志</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ws/xl/i6/wsxli6hxrjmgqnnkuh6b5a7h8my.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font><font style="vertical-align: inherit;">日志中显示以下错误：</font><font style="vertical-align: inherit;">此外，onResume（）还检查Frida的典型端口是否打开：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-k/df/kv/-kdfkvyea8g0p6y-dkwxpk3flo4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的文件客户端有点不耐烦进行调试，root和Frida本身。我们的计划中绝对不包括这种反对，因此我们使用</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">apktool</font></a><font style="vertical-align: inherit;">实用程序获取了应用程序的smali代码</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在任何文本编辑器中打开MainActivity.smali文件，找到onCreate（）方法并将doChecks（）调用转换为无害的注释：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z6/r2/ra/z6r2rautxzhef-0prc9odxmj2ek.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后我们剥夺了suicide（）方法真正关闭该应用程序的机会：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/iu/ti/q6/iutiq6k6idg5_6h7wd1he2mjyem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，让我们再次使用apktool和sign构建我们稍有改进的应用程序通过执行以下命令（可能需要管理员权限）来执行以下操作：</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-built_in">cd</span> <span class="hljs-string">"C:\Program Files\Java\jdk-14\bin"</span>
.\keytool -genkey -v -keystore filedroid.keystore -<span class="hljs-built_in">alias</span> filedroid_alias -keyalg RSA -keysize 2048 -validity 10000<font></font>
.\jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore  filedroid.keystore filedroid_patched.apk filedroid_alias<font></font>
.\jarsigner -verify -verbose -certs filedroid_patched.apk<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们在手机上重新安装该应用程序，然后运行它-欢呼，下载顺利进行，日志很干净！</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qm/u4/k2/qmu4k2ta7zji47msjnyhhq8ibqi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们继续在PC和移动设备上安装Frida框架：</font></font><br>
<br>
<pre><code class="bash hljs">$ sudo pip3 install frida-tools<font></font>
$ wget https://github.com/frida/frida/releases/download/$(frida --version)/frida-server-$(frida --version)-android-arm.xz<font></font>
$ unxz frida-server-$(frida --version)-android-arm.xz<font></font>
$ adb push frida-server-$(frida --version)-android-arm /data/<span class="hljs-built_in">local</span>/tmp/frida-server
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在移动设备上启动Frida框架服务器：</font></font><br>
<br>
<pre><code class="bash hljs">$ adb shell su - <span class="hljs-string">"chmod 755 /data/local/tmp/frida-server"</span>
$ adb shell su - <span class="hljs-string">"/data/local/tmp/frida-server &amp;"</span>  
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们正在准备一个简单的get-urls.js脚本，它将为所有受支持的请求服务器调用wat.getSecure（）：</font></font><br>
<br>
<pre><code class="actionscript hljs">Java.perform(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> 
</span>{
     <span class="hljs-keyword">const</span> wat = Java.use(<span class="hljs-string">'com.ctf.filedroid.wat'</span>);<font></font>
	console.log(wat.getSecure(<span class="hljs-string">"fnks"</span>));<font></font>
	console.log(wat.getSecure(<span class="hljs-string">"qdmk"</span>));<font></font>
	console.log(wat.getSecure(<span class="hljs-string">"tkog"</span>));<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们在移动设备上启动FileDroid，并使用脚本将相应的过程“粘贴”： </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pc/ir/if/pcirifn_grrejaapwi7s-7hg-xe.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.获取服务器上的文件列表</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最终，远程服务器离我们越来越近了！</font><font style="vertical-align: inherit;">现在我们知道服务器以下列方式支持请求：</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filedroid.neoquest.ru/api/verifyme?crc=</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> {crc}＆sign = {sign}</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filedroid.neoquest.ru/api/list_post_apocalyptic_collection?crc=</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> {crc}＆sign = {sign}</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filedroid.neoquest.ru/api/file?file=</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> {file}和令牌= {token}</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了获得可用文件的列表，仍然需要计算原始应用程序的校验和和签名值，然后将它们编码为base64。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
python3中的此类脚本将允许您执行以下操作：</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扰流板</font></font></b>
                        <div class="spoiler_text"><pre><code class="coffeescript hljs"><span class="hljs-keyword">import</span> hashlib
<span class="hljs-keyword">import</span> binascii
<span class="hljs-keyword">import</span> base64
<span class="hljs-keyword">from</span> asn1crypto <span class="hljs-keyword">import</span> cms, x509
<span class="hljs-keyword">from</span> zipfile <span class="hljs-keyword">import</span> ZipFile<font></font>
<font></font>
<font></font>
def get_info(apk):<font></font>
    with ZipFile(apk, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> zipObj:<font></font>
        classes = zipObj.read(<span class="hljs-string">"classes.dex"</span>)<font></font>
        resources = zipObj.read(<span class="hljs-string">"resources.arsc"</span>)<font></font>
        cert = zipObj.read(<span class="hljs-string">"META-INF/CERT.RSA"</span>)<font></font>
        crc = <span class="hljs-string">"%s%s"</span> % (get_crc(classes), get_crc(resources))
        <span class="hljs-keyword">return</span> get_full_crc(classes, resources).decode(<span class="hljs-string">"utf-8"</span>), get_sign(cert).decode(<span class="hljs-string">"utf-8"</span>)<font></font>
<font></font>
<font></font>
def get_crc(file):<font></font>
    crc = binascii.crc32(file) &amp; <span class="hljs-number">0xffffffff</span>
    <span class="hljs-keyword">return</span> crc<font></font>
<font></font>
<font></font>
def get_full_crc(classes, resources):<font></font>
    crc = <span class="hljs-string">"%s%s"</span> % (get_crc(classes), get_crc(resources))
    <span class="hljs-keyword">return</span> base64.urlsafe_b64encode(bytes(crc, <span class="hljs-string">"utf-8"</span>))<font></font>
<font></font>
<font></font>
def get_sign(file):<font></font>
    pkcs7 = cms.ContentInfo.load(file)<font></font>
    data = pkcs7[<span class="hljs-string">'content'</span>][<span class="hljs-string">'certificates'</span>][<span class="hljs-number">0</span>].chosen.dump()<font></font>
    sha256 = hashlib.sha256()<font></font>
    sha256.update(data)<font></font>
    <span class="hljs-keyword">return</span> base64.urlsafe_b64encode(sha256.digest())  <font></font>
<font></font>
get_info(<span class="hljs-string">'filedroid.apk'</span>)
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您也可以手动。我们认为class.dex和resources.arsc中的CRC32是任何方便的工具（例如，对于Linux-标准crc32实用程序），我们分别获得值1276945813和2814166583，将它们连接起来（将出现12769458132814166583）并在base64中进行编码，例如，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wb/ba/km/wbbakmhm-8jmtyyudjhofelaz8s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了执行类似的步骤来对应用程序进行签名，请在JADX窗口中转到“ APK签名”部分，复制“ SHA-256指纹”值，并将其在base64中编码为字节数组：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/s9/zg/wxs9zgvtahyytsnvxis-k8lq8wg.png"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要说明：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在原始apk中，base64编码是通过URL_SAFE标志执行的，即 </font><font style="vertical-align: inherit;">分别使用“-”和“ _”代替字符“ +”和“ /”。</font><font style="vertical-align: inherit;">有必要确保通过自编码也可以观察到这一点。</font><font style="vertical-align: inherit;">为此，在联机编码时，可以使用64 script.jp64.jp64.jp64.jpcrqvqcdvcdb将使用“ ABCDEFGHIJKLMNOPQRSTUVWXYZabc script64”替换为“ ABCDEFGHIJKLMNOPQRSTUVWXYZabcde fghijklmnopqrstuvwxyz0123456789 +/-”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，我们具备成功列出文件的所有要素：</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filedroid.neoquest.ru/api/list_post_apocalyptic_collection?crc=</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> {crc}＆sign = {sign}</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crc：MTI3Njk0NTgxMzI4MTQxNjY1ODM =</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">符号：HeiTSPWdCuhpbmVxqLxW-uhrozfG_QWpTv9ygn45eHY =</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们执行GET请求-并为我们的清单加油！</font><font style="vertical-align: inherit;">而且，其中一个文件的名称不言自明-“如果您要转义，请打开”-似乎我们需要它。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bk/k4/vz/bkk4vzawktgg1ilhn1x06q90ahq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，我们请求一次性访问令牌并下载文件：</font></font><br>
<br>
<pre><code class="coffeescript hljs"><span class="hljs-keyword">import</span> requests<font></font>
<font></font>
response = requests.get(<span class="hljs-string">'https://filedroid.neoquest.ru/api/verifyme'</span>, <font></font>
    		params={    <span class="hljs-string">'crc'</span>: <span class="hljs-string">'MTI3Njk0NTgxMzI4MTQxNjY1ODM='</span>, 
<span class="hljs-string">'sign'</span>: HeiTSPWdCuhpbmVxqLxW-uhrozfG_QWpTv9ygn45eHY=},<font></font>
verify=False)<font></font>
    <font></font>
token = response.json()[<span class="hljs-string">'token'</span>]
<span class="hljs-built_in">print</span>(token)<font></font>
response = requests.get(<span class="hljs-string">'https://filedroid.neoquest.ru/api/file'</span>, <font></font>
params={<span class="hljs-string">'token'</span>: token, <span class="hljs-string">'file'</span>: <span class="hljs-string">'0p3n1fuw4nt2esk4p3.jpg'</span>}, verify=False)<font></font>
<font></font>
with open(<span class="hljs-string">"0p3n1fuw4nt2esk4p3.jpg"</span>, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> fd:<font></font>
        fd.write(response.content)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们打开下载的文件，并回忆起我们留给以后的一种小情况：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kt/dc/rz/ktdcrzjrng635moxnmt5_phu2nu.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.添加少量加密...</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
嗯，为时过早，我们推迟了FileDroid。让我们回到JADX，看看文件客户端开发人员是否对我们有用。是的，在代码清理显然不受欢迎的情况下就是这种情况：未使用的cryptoFile（）方法在ConnectionHandler类中静静地等待我们的注意。我们有什么？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
加密</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AES</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CBC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，sinhroposylka占据前16个字节...惰性-进步的引擎，最好再次使用Frida并毫不费力地解密我们的0p3n1fuw4nt2esk4p3.jpg。但是只是通过作为加密密钥吗？选项不多，但是考虑到存在另一个“被遗忘”的savePlainFile（字符串文件，字符串令牌）方法，选择是显而易见的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
准备以下crypto.js脚本（作为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">令牌）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 指示实际值，例如'HoHknc572mVpZESSQN1Xa7S9zOidxX1PMbykdoM1EXI ='）：</font></font><br>
<br>
<pre><code class="coffeescript hljs">Java.perform(function () {<font></font>
    const JavaString = Java.use(<span class="hljs-string">'java.lang.String'</span>);<font></font>
    const file_name = JavaString.$<span class="hljs-keyword">new</span>(<span class="hljs-string">'0p3n1fuw4nt2esk4p3.jpg'</span>);<font></font>
    const ConnectionHandler = Java.use(<span class="hljs-string">'com.ctf.filedroid.ConnectionHandler'</span>);<font></font>
    const result = ConnectionHandler.savePlainFile(file_name, &lt;token&gt;);<font></font>
    <span class="hljs-built_in">console</span>.log(result);<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将加密文件0p3n1fuw4nt2esk4p3.jpg放在/ sdcard /上，运行FileDroid并使用Frida注入crypto.js脚本。</font><font style="vertical-align: inherit;">脚本运行后，plainfile.jpg文件将出现在/ sdcard /上。</font><font style="vertical-align: inherit;">我们打开它，...就解决了！</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fb/3-/ah/fb3-ahlzcqlnfjsromkmbz9eil0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这项艰巨的任务要求参与者同时具备多个信息安全领域的知识和技能，我们很高兴大多数竞争对手都能成功应对！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们希望那些在没有足够时间或知识之前没有收到密钥的人现在可以成功地通过任何CTF中的类似任务：)</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN496910/index.html">构建和自定义CDN</a></li>
<li><a href="../zh-CN496912/index.html">Windows上的ThinkPad E480英特尔VS Windows上的ThinkPad E495 AMD是否有任何区别？</a></li>
<li><a href="../zh-CN496914/index.html">最短的十进制程序</a></li>
<li><a href="../zh-CN496916/index.html">远程教学，协商和咨询-第3部分：Yealink会议服务器和4个特别优惠</a></li>
<li><a href="../zh-CN496920/index.html">使用ASP.NET Core和Arduino打造智能家居</a></li>
<li><a href="../zh-CN496924/index.html">Web组件路由</a></li>
<li><a href="../zh-CN496936/index.html">让我们在Kubernetes中使用cert-manager加密SSL证书</a></li>
<li><a href="../zh-CN496938/index.html">超级计算机，基因组测序和击败冠状病毒的前景</a></li>
<li><a href="../zh-CN496940/index.html">通用汽车工程师如何测试电子产品</a></li>
<li><a href="../zh-CN496942/index.html">4月13日至19日在莫斯科举行的数字活动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>