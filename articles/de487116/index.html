<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏿 🙋🏽 📤 Warum Discord von Go nach Rust migriert 🦆 😣 🤷🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust wird zu einer erstklassigen Sprache in einer Vielzahl von Bereichen. Wir bei Discord setzen es erfolgreich sowohl auf Server- als auch auf Client...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Warum Discord von Go nach Rust migriert</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487116/"><img src="https://habrastorage.org/getpro/habr/post_images/84a/0f1/d61/84a0f1d6126d5fd59b9c708f19c84692.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rust wird zu einer erstklassigen Sprache in einer Vielzahl von Bereichen. </font><font style="vertical-align: inherit;">Wir bei Discord setzen es erfolgreich sowohl auf Server- als auch auf Clientseite ein. </font><font style="vertical-align: inherit;">Zum Beispiel auf der Clientseite in der Videokodierungspipeline für Go Live und auf der Serverseite für die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elixir NIF-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktionen (Native Implemented Functions). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben kürzlich die Leistung eines einzelnen Dienstes dramatisch verbessert und ihn von Go to Rust umgeschrieben. </font><font style="vertical-align: inherit;">In diesem Artikel wird erläutert, warum es für uns sinnvoll war, den Service neu zu schreiben, wie wir ihn durchgeführt haben und wie stark sich die Produktivität verbessert hat.</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Read State Tracking Service (Status lesen)</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Unternehmen basiert auf einem Produkt. Beginnen wir also mit einem Kontext, den wir genau von Go to Rust übertragen haben. Dies ist ein Read States-Dienst. Ihre einzige Aufgabe ist es, zu verfolgen, welche Kanäle und Nachrichten Sie lesen. Auf die Lesezustände wird jedes Mal zugegriffen, wenn Sie eine Verbindung zu Discord herstellen, wenn Sie eine Nachricht senden und wenn Sie die Nachricht lesen. Kurz gesagt, Zustände werden kontinuierlich gelesen und befinden sich auf einem „heißen Pfad“. Wir möchten sicherstellen, dass Discord immer schnell ist, daher sollte die Statusprüfung schnell sein.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Implementierung des Service on Go erfüllte nicht alle Anforderungen. </font><font style="vertical-align: inherit;">Die meiste Zeit funktionierte es schnell, aber alle paar Minuten gab es starke Verzögerungen, die für die Benutzer spürbar waren. </font><font style="vertical-align: inherit;">Nachdem wir die Situation untersucht hatten, stellten wir fest, dass die Verzögerungen auf die Hauptmerkmale von Go zurückzuführen waren: das Speichermodell und den Garbage Collector (GC).</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum gehen, erfüllt unsere Leistungsziele nicht</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu erklären, warum Go unsere Leistungsziele nicht erreicht, müssen zunächst Datenstrukturen, Skalierung, Zugriffsmuster und Servicearchitektur erörtert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Speichern von Statusinformationen verwenden wir eine Datenstruktur, die als "Status lesen" bezeichnet wird. In Discord gibt es Milliarden davon: einen Status für jeden Benutzer pro Kanal. Jeder Zustand hat mehrere Zähler, die atomar aktualisiert und oft auf Null zurückgesetzt werden müssen. Einer der Zähler ist beispielsweise die Nummer </font></font><code>@mention</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Kanal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Atomzähler schnell zu aktualisieren, verfügt jeder Read States-Server über einen LRU-Cache (Least Recent Used). Jeder Cache hat Millionen von Benutzern und zig Millionen von Zuständen. Der Cache wird hunderttausend Mal pro Sekunde aktualisiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus Sicherheitsgründen wird der Cache mit dem Cassandra-Datenbankcluster synchronisiert. </font><font style="vertical-align: inherit;">Wenn ein Schlüssel aus dem Cache gedrückt wird, geben wir die Status dieses Benutzers in die Datenbank ein. </font><font style="vertical-align: inherit;">In Zukunft planen wir, die Datenbank bei jeder Statusaktualisierung innerhalb von 30 Sekunden zu aktualisieren. </font><font style="vertical-align: inherit;">Dies sind Zehntausende von Datensätzen in der Datenbank pro Sekunde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgende Grafik zeigt die Antwortzeit und die CPU-Auslastung im Spitzenzeitintervall für den Go </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><sup><font style="vertical-align: inherit;">1-</font></sup></a><font style="vertical-align: inherit;"> Dienst</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><sup><font style="vertical-align: inherit;"></font></sup></a><a name="1_1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es ist ersichtlich, dass Verzögerungen und Laststöße auf der CPU ungefähr alle zwei Minuten auftreten.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/90d/37b/89f/90d37b89f25eab54420107e63c086c44.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Woher kommt also das Wachstum der Verzögerungen alle zwei Minuten?</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Go wird der Speicher nicht sofort freigegeben, wenn eine Taste aus dem Cache gedrückt wird. Stattdessen wird der Garbage Collector regelmäßig ausgeführt und sucht nach nicht verwendeten Speicherbereichen. Dies ist eine Menge Arbeit, die ein Programm verlangsamen kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist sehr wahrscheinlich, dass regelmäßige Verlangsamungen unseres Dienstes mit der Speicherbereinigung verbunden sind. Wir haben jedoch einen sehr effizienten Go-Code mit minimaler Speicherzuweisung geschrieben. Es sollte nicht mehr viel Müll übrig sein. Was ist da los? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Durchsuchen des Go-Quellcodes haben wir erfahren, dass Go </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mindestens alle zwei Minuten mit der</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speicherbereinigung beginnt </font><font style="vertical-align: inherit;">. Unabhängig von der Größe des Heapspeichers erzwingt Go den Start, wenn der GC zwei Minuten lang nicht gestartet wurde.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben beschlossen, dass Sie diese Spitzen mit großen Verzögerungen vermeiden können, wenn Sie GC häufiger ausführen. Daher legen wir einen Endpunkt im Service fest, um den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GC-Prozentwert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im laufenden Betrieb zu ändern </font><font style="vertical-align: inherit;">. Leider hat die Konfiguration von GC Percent nichts beeinflusst. Wie konnte das passieren? Es stellt sich heraus, dass GC nicht öfter starten wollte, weil wir nicht oft genug Speicher zugewiesen haben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir begannen weiter zu graben. Es stellte sich heraus, dass solche großen Verzögerungen nicht aufgrund der großen Menge an freigegebenem Speicher auftreten, sondern weil der Garbage Collector den gesamten LRU-Cache durchsucht, um den gesamten Speicher zu überprüfen. Dann haben wir beschlossen, dass das Scan-Volumen abnimmt, wenn wir den LRU-Cache verringern. Aus diesem Grund haben wir dem Dienst einen weiteren Parameter hinzugefügt, um die Größe des LRU-Cache zu ändern, und die Architektur geändert, wodurch die LRU auf jedem Server in viele separate Caches aufgeteilt wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so geschah es. Bei kleineren Caches werden Spitzenverzögerungen reduziert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider hat der Kompromiss mit der Verringerung des LRU-Cache das 99. Perzentil erhöht (dh der Durchschnittswert für eine Stichprobe von 99% der Verzögerungen hat sich erhöht, mit Ausnahme der Spitzenverzögerungen). Dies liegt daran, dass durch Verringern des Caches die Wahrscheinlichkeit verringert wird, dass sich der Lesestatus des Benutzers im Cache befindet. Wenn es nicht hier ist, müssen wir uns an die Datenbank wenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach einer großen Anzahl von Lasttests für verschiedene Cache-Größen haben wir eine akzeptable Einstellung gefunden. </font><font style="vertical-align: inherit;">Obwohl nicht ideal, war es eine zufriedenstellende Lösung, so dass wir den Service für eine lange Zeit verlassen haben, um so zu arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gleichzeitig haben wir Rust sehr erfolgreich in anderen Discord-Systemen implementiert und daher gemeinsam beschlossen, Frameworks und Bibliotheken für neue Dienste nur in Rust zu schreiben. </font><font style="vertical-align: inherit;">Und dieser Dienst schien ein ausgezeichneter Kandidat für die Portierung nach Rust zu sein: Er ist klein und autonom, und wir hofften, dass Rust diese Ausbrüche mit Verzögerungen beheben und den Dienst letztendlich für Benutzer angenehmer machen würde </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup></a><a name="2_2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherverwaltung in Rust</font></font></h1><br>
<blockquote><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rust ist unglaublich schnell und effizient mit Speicher: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da keine Laufzeitumgebung und kein Garbage Collector vorhanden sind,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eignet es sich für Hochleistungsdienste, eingebettete Anwendungen und lässt sich problemlos in andere Sprachen integrieren. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup></a><a name="3_3"></a></i></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rust hat keinen Müllsammler, deshalb haben wir beschlossen, dass es keine solchen Verzögerungen wie Go geben würde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Speicherverwaltung verwendet er einen ziemlich einzigartigen Ansatz mit der Idee, Speicher zu "besitzen". </font><font style="vertical-align: inherit;">Kurz gesagt, Rust verfolgt, wer das Recht hat, aus dem Speicher zu lesen und in den Speicher zu schreiben. </font><font style="vertical-align: inherit;">Er weiß, wann ein Programm Speicher verwendet, und gibt ihn sofort frei, sobald kein Speicher mehr benötigt wird. </font><font style="vertical-align: inherit;">Rust erzwingt Speicherregeln zur Kompilierungszeit, wodurch die Möglichkeit von Speicherfehlern zur Laufzeit praktisch ausgeschlossen wird. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup></a><a name="4_4"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie müssen den Speicher nicht manuell verfolgen. </font><font style="vertical-align: inherit;">Der Compiler wird sich darum kümmern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn in der Rust-Version der Lesestatus aus dem LRU-Cache ausgeschlossen wird, wird der Speicher sofort freigegeben. </font><font style="vertical-align: inherit;">Dieser Speicher sitzt nicht und wartet nicht auf den Garbage Collector. </font><font style="vertical-align: inherit;">Rust weiß, dass es nicht mehr verwendet wird und gibt es sofort frei. </font><font style="vertical-align: inherit;">Zur Laufzeit gibt es keinen Prozess zum Scannen des freizugebenden Speichers.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchroner Rost</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gab jedoch ein Problem mit dem Rust-Ökosystem. Zum Zeitpunkt der Implementierung unseres Dienstes gab es im stabilen Zweig von Rust keine anständigen asynchronen Funktionen. Für einen Netzwerkdienst ist die asynchrone Programmierung ein Muss. Die Community hat mehrere Bibliotheken entwickelt, jedoch mit einer nicht trivialen Verbindung und sehr dummen Fehlermeldungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Glücklicherweise hat das Rust-Team hart daran gearbeitet, die asynchrone Programmierung zu vereinfachen, und sie war bereits auf dem instabilen Kanal (Nightly) verfügbar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Discord hatte nie Angst, vielversprechende neue Technologien zu lernen. Zum Beispiel waren wir einer der ersten Benutzer von Elixir, React, React Native und Scylla. Wenn eine Technologie vielversprechend aussieht und uns einen Vorteil verschafft, sind wir bereit, uns den unvermeidlichen Schwierigkeiten bei der Implementierung und der Instabilität fortschrittlicher Tools zu stellen. Dies ist einer der Gründe, warum wir so schnell ein Publikum von 250 Millionen Benutzern mit weniger als 50 Programmierern im Bundesstaat erreicht haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Einführung neuer asynchroner Funktionen aus dem instabilen Rust-Kanal ist ein weiteres Beispiel für unsere Bereitschaft, eine neue, vielversprechende Technologie einzuführen. Das Engineering-Team entschied sich, die erforderlichen Funktionen zu implementieren, ohne auf deren Unterstützung in der stabilen Version zu warten. Zusammen mit anderen Vertretern der Gemeinschaft haben wir alle aufgetretenen Probleme überwunden und jetzt </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asynchrones Rust</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in einem stabilen Zweig gehalten. </font><font style="vertical-align: inherit;">Unser Tarif hat sich ausgezahlt.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung, Stresstest und Start</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nur den Code neu zu schreiben war einfach. Wir haben mit einer groben Sendung begonnen und sie dann auf Orte reduziert, an denen es Sinn machte. Zum Beispiel hat Rust ein exzellentes Typsystem mit umfassender Unterstützung für Generika (für die Arbeit mit Daten aller Art), so dass wir den Go-Code leise weggeworfen haben, was den Mangel an Generika kompensierte. Darüber hinaus berücksichtigt das Rust-Speichermodell die Speichersicherheit in verschiedenen Threads, sodass wir die Schutzgoroutinen weggeworfen haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Belastungstests zeigten sofort ein hervorragendes Ergebnis. Die Serviceleistung von Rust war genauso hoch wie die der Go-Version, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jedoch ohne diese Verzögerungen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Normalerweise haben wir die Rust-Version praktisch nicht optimiert. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber selbst mit den einfachsten Optimierungen konnte Rust eine sorgfältig abgestimmte Version von Go übertreffen.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein beredter Beweis dafür, wie einfach es ist, effektive Rust-Programme zu schreiben, anstatt tief in Go einzusteigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber wir haben die einfache Leistung quo nicht erfüllt. </font><font style="vertical-align: inherit;">Nach ein wenig Profilerstellung und Optimierung haben </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir Go in jeder Hinsicht übertroffen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Verzögerung, CPU und Speicher - in der Rust-Version wurde alles besser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rostleistungsoptimierungen enthalten:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wechseln zu BTreeMap anstelle von HashMap im LRU-Cache, um die Speichernutzung zu optimieren.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ersetzen der ursprünglichen Metrikbibliothek durch eine Version mit Unterstützung für modernes Parallelitäts-Rust.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verringern Sie die Anzahl der Kopien im Speicher.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zufrieden entschieden wir uns, den Service bereitzustellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Start verlief ziemlich reibungslos, da wir Stresstests durchgeführt haben. </font><font style="vertical-align: inherit;">Wir haben den Service mit einem Testknoten verbunden, mehrere Grenzfälle entdeckt und behoben. </font><font style="vertical-align: inherit;">Bald darauf rollten sie eine neue Version in den gesamten Serverpark. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ergebnisse sind unten gezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das lila Diagramm ist Go, das blaue Diagramm ist Rust.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/yb/-v/mi/yb-vmise0bioz33f8yfrockjr_0.png"></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erhöhen Sie die Cache-Größe</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem der Dienst mehrere Tage erfolgreich funktioniert hatte, haben wir beschlossen, den LRU-Cache erneut zu vergrößern. </font><font style="vertical-align: inherit;">Wie oben erwähnt, war dies in der Go-Version nicht möglich, da sich die Zeit für die Speicherbereinigung erhöhte. </font><font style="vertical-align: inherit;">Da wir keine Speicherbereinigung mehr durchführen, können Sie die Cache-Zählung erhöhen, um die Leistung noch weiter zu steigern. </font><font style="vertical-align: inherit;">Daher haben wir den Speicher auf den Servern erhöht, die Datenstruktur für eine geringere Speichernutzung (zum Spaß) optimiert und die Cache-Größe auf 8 Millionen Lesezustandszustände erhöht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgenden Ergebnisse sprechen für sich. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass die durchschnittliche Zeit jetzt in Mikrosekunden und die maximale Verzögerung </font></font><code>@mention</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Millisekunden gemessen wird.</font></font></b><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93f/55a/500/93f55a500413c691a4e711e4c90ceada.png"></div><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ökosystementwicklung</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich hat Rust ein wunderbares Ökosystem, das schnell wächst. </font><font style="vertical-align: inherit;">Eine neue Version der von uns verwendeten asynchronen Laufzeit ist beispielsweise Tokio 0.2. </font><font style="vertical-align: inherit;">Wir haben aktualisiert und ohne unser Zutun die Belastung der CPU automatisch reduziert. </font><font style="vertical-align: inherit;">In der folgenden Grafik können Sie sehen, wie sich die Last seit dem 16. Januar verringert hat.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5f/128/490/e5f12849036cfea0b9e9246a1e321ed0.png"></div><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abschließende Gedanken</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Discord verwendet Rust derzeit in vielen Teilen des Software-Stacks: für GameSDK, zum Aufnehmen und Codieren von Videos in Go Live, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elixir NIF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mehreren Backend-Diensten und vielem mehr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie ein neues Projekt oder eine neue Softwarekomponente starten, ziehen wir definitiv die Verwendung von Rust in Betracht. Natürlich nur dort, wo es Sinn macht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neben der Leistung bietet Rust Entwicklern viele weitere Vorteile. Zum Beispiel vereinfachen die Typensicherheit und der Leihprüfer das Refactoring erheblich, wenn sich die Produktanforderungen ändern oder neue Sprachfunktionen eingeführt werden. Das Ökosystem und die Werkzeuge sind ausgezeichnet und entwickeln sich schnell. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unterhaltsame Tatsache: Das Rust-Team verwendet auch Discord zur Koordinierung. Es gibt sogar eine sehr nützliche</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rust Community Server</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wo wir manchmal chatten.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><div style="text-align:center;"><img src="https://habrastorage.org/webt/br/pc/l_/brpcl_fl4bwj8fcmaeodxotfw5s.png"></div></a><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fußnoten</font></font></h4><br>
<font color="gray"><ol>
<li><a name="1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diagramme aus Go Version 1.9.2. </font><font style="vertical-align: inherit;">Wir haben die Versionen 1.8, 1.9 und 1.10 ohne Verbesserungen ausprobiert. </font><font style="vertical-align: inherit;">Die erste Migration von Go nach Rust wurde im Mai 2019 abgeschlossen. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[zurückgeben]</font></font></a><br>
</li>
<li><a name="2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus Gründen der Übersichtlichkeit empfehlen wir nicht, alles in Rust ohne Grund neu zu schreiben. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[zurückgeben]</font></font></a><br>
</li>
<li><a name="3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zitat aus der offiziellen Seite. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[zurückgeben]</font></font></a><br>
</li>
<li><a name="4"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich, bis Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsicher verwenden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[zurückgeben]</font></font></a></li>
</ol></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de487116/">https://habr.com/ru/post/de487116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de487100/index.html">Unveränderliche Datenstrukturen auf dem neuesten Stand der Technik</a></li>
<li><a href="../de487106/index.html">RunUO-Prüfung des PVS-Studio-Analysators</a></li>
<li><a href="../de487108/index.html">Mobiles Spielerprofil: MyTracker Research</a></li>
<li><a href="../de487110/index.html">Slurm SRE. Ein komplettes Experiment mit Experten von Booking.com und Google.com</a></li>
<li><a href="../de487112/index.html">Rand des Wahnsinns: Der Grundkreis</a></li>
<li><a href="../de487118/index.html">Loki - Sammeln von Protokollen nach dem Prometheus-Ansatz</a></li>
<li><a href="../de487120/index.html">Wie man Kätzchen verteilt</a></li>
<li><a href="../de487122/index.html">Google JavaScript Style Guide Übersetzung</a></li>
<li><a href="../de487124/index.html">Interview mit Borey Yangel über Yandex Selbstfahrer und Alices Schöpfungsgeschichte</a></li>
<li><a href="../de487126/index.html">Wie Unternehmensentwicklungsteams GitLab und Mattermost ChatOps verwenden, um die Entwicklung zu beschleunigen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>