<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔇 🍼 🤴🏽 etcd 3.4.3：存储可靠性和安全性研究 ⚱️ 🧢 🖖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="注意佩雷夫。：本文的内容并不完全是我们博客的典型内容。但是，众所周知，etcd位于Kubernetes的心脏地带，这就是为什么由独立研究人员在可靠性领域进行的这项研究对于运行此系统的工程师来说很有趣。此外，有趣的是，即使在如此“低”的水平下，已经在生产中证明自己的开源项目也将如何得到改进。
 
 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>etcd 3.4.3：存储可靠性和安全性研究</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/487534/"><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意佩雷夫。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：本文的内容并不完全是我们博客的典型内容。但是，众所周知，etcd位于Kubernetes的心脏地带，这就是为什么由独立研究人员在可靠性领域进行的这项研究对于运行此系统的工程师来说很有趣。此外，有趣的是，即使在如此“低”的水平下，已经在生产中证明自己的开源项目也将如何得到改进。</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/xd/av/d3/xdavd35rjqklgnrnd-0wulkpayo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
键值（KV）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等保管库</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是基于Raft共识算法的分布式数据库。在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2014年进行</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的分析</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">中</font></a><font style="vertical-align: inherit;">，我们发现etcd 0.4.1默认情况下受到所谓的过时读取的影响</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（由于同步延迟-大约翻译，读操作返回的旧值不相关）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我们决定返回etcd（这次-版本3.4.3），以便再次详细评估其在可靠性和安全性方面的潜力。</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们发现具有成对的“键值”的操作严格可序列化，并且观察者</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（手表）的过程</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传递给顺序键中的每个更改。</font><font style="vertical-align: inherit;">但是，</font><font style="vertical-align: inherit;">etcd中的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">锁定</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从根本上讲是不安全的，并且由于错误而加剧了与它们相关的风险，因此，</font><font style="vertical-align: inherit;">在等待锁定之后</font><font style="vertical-align: inherit;">就不会检查</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">租约</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的相关性</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在项目博客</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上的报告中阅读etcd开发人员的评论</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这项研究是由</font><font style="vertical-align: inherit;">Linux基金会一部分</font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud Native Computing Foundation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（CNCF）赞助的。</font><font style="vertical-align: inherit;">它的执行完全符合</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jepsen的道德政策</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.背景</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Etc KV信息库是一个分布式系统，旨在用作协调基础。像</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zookeeper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consul</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一样</font><font style="vertical-align: inherit;">，etcd </font><font style="vertical-align: inherit;">以键值映射的形式</font><font style="vertical-align: inherit;">存储少量很少更新的状态（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下最大为8 GB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">，并在整个数据仓库中</font><font style="vertical-align: inherit;">提供</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">严格可序列化的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">读取，写入和微事务，以及诸如</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">锁</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，跟踪之</font><font style="vertical-align: inherit;">类的协调原语</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（手表）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和领导者选择。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenStack</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等许多分布式系统都</font><font style="vertical-align: inherit;">使用etcd存储集群元数据，协调数据的协调视图，选择领导者等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2014年，我们已经对</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etcd 0.4.1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行了评估</font><font style="vertical-align: inherit;">。然后我们发现默认情况下，由于优化，它倾向于过时读取。尽管</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关Raft原理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">工作</font></a><font style="vertical-align: inherit;">讨论了将读取操作分成线程并通过共识系统传递以确保可行性的必要性，但是etcd本地读取任何领导者，而无需检查较新领导者的最新状态。 etcd开发团队实现了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可选的quorum标志</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且在etcd 3.0版API中</font><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出现</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">了</font></a><font style="vertical-align: inherit;">除跟踪操作以外的所有操作的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线性化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
etcd 3.0 API集中在键和值不透明的KV平面地图上</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不透明</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字节数组。使用范围查询，您可以模拟层次结构键。用户可以读取，写入和删除密钥，以及监视单个密钥或密钥范围的更新流程。 etcd工具包由租约（生命周期有限的可变对象，通过客户端的心跳请求将其保持在活动状态），锁（绑定到租约的专用命名对象）和领导者的选择提供了补充。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在3.0版中，etcd提供了有限的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事务API</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于具有许多键的原子操作。</font><font style="vertical-align: inherit;">在此模型中，事务是具有谓词，真分支和假分支的条件表达式。</font><font style="vertical-align: inherit;">谓词可以是多个关键比较的结合：根据一个关键的版本，全局修订版etcd或当前关键值，相等或各种不等式。</font><font style="vertical-align: inherit;">正确和错误的分支可以包括多个读取和写入操作。</font><font style="vertical-align: inherit;">所有这些都根据谓词估计的结果自动应用。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1保证文件的一致性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
截至2019年10月，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">etcd </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">文档</font></a><font style="vertical-align: inherit;">指出：“所有API调用均显示出一致的一致性-分布式系统上可用的最强形式的一致性保证。”事实并非如此：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一致的一致性</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">严格比</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">线性</font></a><font style="vertical-align: inherit;">化性弱</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且线性度在分布式系统中绝对是可以实现的。此外，文档指出“在读取操作期间，etcd不能保证传输[在群集的任何成员上可用的[最新（由查询完成后的外部时钟测量）]值”。这也是一个过于保守的说法：如果etcd提供了线性化能力，则读取操作始终与线性化顺序中的最新提交状态相关联。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该文档还声称etcd保证可</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序列化隔离</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：所有操作（甚至影响几个键的操作）都以某种常规顺序执行。作者将可序列化隔离描述为“分布式系统中可用的最强隔离级别”。这（取决于您所说的“隔离级别”的意思）也不是正确的。严格的可序列化性强于简单的可序列化性，而前者在分布式系统中也可以实现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该文档说，etcd中的所有操作（跟踪除外）默认情况下都是线性的。在这种情况下，线性化被定义为与弱同步全局时钟的一致性。应该注意的是，这样的定义不仅与</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">线性化</font></a><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">定义</font></a><font style="vertical-align: inherit;">不兼容</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Herlihy＆Wing还暗示了因果关系的违规：处于繁忙时间的节点将尝试读取尚未开始的操作结果。我们假设etcd仍然不是时间机器，并且由于它是基于Raft算法的，因此应该使用公认的线性化定义。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于etcd中的KV操作是可序列化和线性化的，因此我们认为实际上etcd默认提供</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">严格的序列化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这是有道理的，因为所有键etcd都在单个状态机中，并且Raft提供了对该状态机上所有操作的完整排序。实际上，整个etcd数据集是单个线性化对象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可选标志</font></font><code>serializable</code> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">降低</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">读取操作的级别从严格到常规可序列化的一致性，允许读取过时的提交状态。</font><font style="vertical-align: inherit;">请注意，该标志</font></font><code>serializable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会影响故事的可序列化性。</font><font style="vertical-align: inherit;">KV操作etcd在所有情况下都可以序列化。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.测试开发</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要创建</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试套件，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用了适当的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jepsen库</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。分析了etcd 3.4.3版本（截至19年10月的最新版本），适用于由5个节点组成的Debian Stretch集群。我们在这些群集中实现了许多故障，包括网络分区，隔离单个节点，将群集分为多数和少数以及将多数重叠的非过渡性分区。他们“丢弃”并暂停了节点的随机子集，还故意禁用了领导者。引入了几百秒和几毫秒的时间失真（数百秒）（快速的“闪烁”）。由于etcd支持动态更改组件数，因此我们在测试期间随机添加和删除了节点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
测试负载包括用于检查KV操作的寄存器，集和事务测试，以及锁和手表的专用负载。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1寄存器</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了评估KV操作期间etcd的可靠性，开发了一种</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">寄存器测试</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">在该</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">测试</font></a><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">对单元键</font><font style="vertical-align: inherit;">执行</font><font style="vertical-align: inherit;">了</font><font style="vertical-align: inherit;">随机的读取，写入，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比较和设置</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用比较/安装寄存器模型和版本信息，使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knossos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线性化工具</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">评估</font></a><font style="vertical-align: inherit;">结果</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2套</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了量化陈旧的读取，开发</font><font style="vertical-align: inherit;">了</font><font style="vertical-align: inherit;">一种</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">测试</font></a><font style="vertical-align: inherit;">使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比较并设置</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事务</font><font style="vertical-align: inherit;">从单个键读取一组整数，然后向该组添加值。</font><font style="vertical-align: inherit;">在测试期间，我们还对整个装置进行了并行读取。</font><font style="vertical-align: inherit;">在完成测试后，结果进行了分析案件的发生时的元件，这是众所周知的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存在于所述集合，在读取结果不存在。</font><font style="vertical-align: inherit;">这些案例用于量化过时的读取和丢失的更新。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.3追加测试</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了验证严格的可序列化性，开发了一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加测试</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">在此期间并行读取事务并将值添加到由唯一的整数集组成的列表中。每个列表都存储在一个etcd密钥中，并且在每个事务中进行添加，读取</font><font style="vertical-align: inherit;">在一个事务</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中需要更改的每个密钥，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后</font><font style="vertical-align: inherit;">在第二个事务</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中写入这些密钥并执行读取操作</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是受保护的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以确保自首次读取以来未更改任何记录的密钥。</font><font style="vertical-align: inherit;">在测试结束时，我们绘制了基于实时优先级的事务之间的关系以及读取和添加操作的关系。</font><font style="vertical-align: inherit;">检查此图是否存在循环，可以确定操作是否严格可序列化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管etcd防止事务多次写入同一密钥，但是您可以创建每个密钥最多包含一条记录的事务。</font><font style="vertical-align: inherit;">我们还确保同一事务中的读取操作反映了同一事务中先前的写入操作。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.4锁</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为协调服务，etcd承诺</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对分布式锁定提供</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内置</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">支持</font></a><font style="vertical-align: inherit;">。我们以两种方式研究了这些锁。最初，生成了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随机的锁定和解锁请求</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，获得了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个锁定</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">租约，并</font></a><font style="vertical-align: inherit;">使用Java客户端中的内置</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">etc</font></a><font style="vertical-align: inherit;">客户端</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">将其保持打开状态</font></a><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code> keepalive</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直到</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">释放</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为止</font><font style="vertical-align: inherit;">。我们用Knossos测试了结果，看它们是否构成了锁服务的线性化实现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了进行更实际的测试（并量化锁定失败的频率），</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">在对内存中的集合进行更新时</font></a><font style="vertical-align: inherit;">，我们使用了locks和etcd来组织</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">互斥。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并搜索此集中丢失的更新。</font><font style="vertical-align: inherit;">该测试使我们可以直接确认使用etcd作为互斥量的系统是否可以安全地更新内部状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
锁定测试的第三版涉及</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保护租赁密钥，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以修改存储在etcd中的集合。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.5追踪</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了验证手表是否提供有关每次按键更新的信息，在测试中创建了一个按键，并</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">盲目分配了</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">唯一的整数值。</font><font style="vertical-align: inherit;">同时，客户一次共享</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此密钥</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几秒钟。</font><font style="vertical-align: inherit;">每次启动手表后，客户都从上次停止的版本开始。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此过程结束时，我们</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确保</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个客户观察到相同的密钥更改序列。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.结果</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1从第0版修订开始</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
跟踪密钥时，客户可以指定</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始修订版</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即“（从此开始（包括）跟踪的可选修订版”）。如果用户希望使用某个键查看每个操作，则可以指定etcd的第一个修订版。这是什么审核？</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据模型</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">词汇表</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未提供此问题的答案；版本被描述为单调递增的64位计数器，但是不清楚etcd是从0还是从1开始。可以合理地假设倒数是从头开始的（以防万一）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
las，这是错误的。请求第0个修订版会导致etcd从</font><i><font style="vertical-align: inherit;">服务器上</font></i><font style="vertical-align: inherit;">的</font><i><font style="vertical-align: inherit;">当前修订版加一个</font></i><font style="vertical-align: inherit;">开始广播更新。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但不是最开始的。</font><font style="vertical-align: inherit;">第一个修订版的请求给出了所有更改。</font><font style="vertical-align: inherit;">这种现象</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有记录在任何地方</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们认为，实际上，这种微妙之处不太可能导致生产中出现问题，因为大多数集群都不会停留在第一版上。</font><font style="vertical-align: inherit;">另外，etcd会随时间压缩故事，因此，在实际应用中，无论如何，从第一版</font><font style="vertical-align: inherit;">开始</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很可能</font><font style="vertical-align: inherit;">不需要读取所有版本。</font><font style="vertical-align: inherit;">这种行为是合理的，但不会损害文档中的相应描述。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2神话般的锁</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">锁定的API文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指出，锁定的密钥“可以与事务结合使用，以确保仅在拥有锁定时才在etcd中进行更新”。很奇怪，但是它不能为锁本身提供任何保证，并且没有说明它们的用途。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，在其他材料中，维护者etcd仍共享有关锁使用的信息。例如，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etcd 3.2发行公告</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述了</font></font><code>etcdctl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于阻止磁盘上文件共享更改</font><font style="vertical-align: inherit;">的应用程序</font><font style="vertical-align: inherit;">。另外，在GitHub上的一个问题中，有关</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">锁</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">特定用途的</font></a><font style="vertical-align: inherit;">问题中</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">，</font></a><font style="vertical-align: inherit;">一位etcd开发人员回答了以下问题：</font></font><br>
<br>
<blockquote>     etcd  ,   (  )        ,     (        etcd), - :<br>
<br>
<ol>
<li>    etcd;</li>
<li>  - ( ,     etcd);</li>
<li>    .</li>
</ol></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就是这样的例子</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>  etcdctl</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：锁是用来保护团队的</font></font><code>put</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但并未将锁键绑定到更新。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
las，这是不安全的，因为它允许多个客户端同时持有相同的锁。进程的暂停，网络崩溃或分区使问题更加严重，但是，在完全正常的群集中也可能发生此问题，而没有任何外部故障。例如，在此</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试运行中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进程号3成功设置了锁定，并且甚至在进程3有机会删除它之前，进程1也并行获得了相同的锁：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ko/hy/lz/kohylznbfb8bh5a2m1l88kysrg4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在短TTL的租约中，互斥体违规最为明显：仅经过数分钟的测试（即使在健康的群集中），TTL，1、2和3秒也无法提供互斥。进程中止和网络分区导致出现问题的速度甚至更快。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的一种锁测试变体中，etcd互斥锁用于保护一组整数的联合更新（如etcd文档所建议的）。每次更新都会读取当前的内存样本值，大约一秒钟后，会在添加唯一元素的情况下将该集合写回。使用具有2秒TTL的租约，五个并行进程以及一个每五秒钟暂停的进程，我们能够稳定地损失大约18％的已确认更新。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
etcd中的内部锁定机制加剧了这个问题。如果一个客户端等待另一个客户端对其进行解锁，丢失其租约，并且在释放该锁之后，则服务器</font><font style="vertical-align: inherit;">在通知该客户端现在该锁位于其后，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">检查租约</font></a><font style="vertical-align: inherit;">以确保其仍然有效。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
包括额外的租约检查，以及选择更长的TTL和仔细设置</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选举</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">超时，将减少此问题的发生。但是，不能完全消除互斥锁违规，因为在异步系统中，分布式锁从根本上来说是不安全的。 Martin Kleppmann博士在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">他的文章中</font></a><font style="vertical-align: inherit;">令人信服地描述了这一点</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于分布式锁。据他介绍，阻塞服务必须牺牲正确性才能维持异步系统中的生存能力：如果进程在控制阻塞时崩溃，则阻塞服务需要某种方式来强制解除锁定。但是，如果该进程实际上并未失败，而是运行缓慢或暂时不可用，则对其进行解锁可能导致该进程同时被保存在多个位置。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，即使分布式阻止服务使用了某种魔术故障检测器，并且实际上可以保证相互排斥，但在某些非本地资源的情况下，使用它仍然是不安全的。假设进程A持有锁时向数据库D发送消息。此后，进程A崩溃，进程B接收到一个锁，并且还向基D发送了一条消息。问题是，来自进程A的消息（由于异步）可能出现在来自进程B的消息之后，这违反了锁旨在提供的互斥性。 。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为避免此问题，有必要依靠以下事实：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储系统本身</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将支持事务的正确性，或者，如果锁定服务提供了这种机制，则使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">防护”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">令牌</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将包含在锁持有人执行的所有操作中。这将确保在当前锁所有者的操作之间不会突然发生前一个锁所有者的操作。例如，在</font><font style="vertical-align: inherit;">Google的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chubby阻止服务中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些令牌称为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音序器</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在etcd中，您可以将锁键修订版用作全局排序的阻止令牌。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，etcd中的锁定键可用于保护etcd本身中的事务更新。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在交易中检查锁定密钥版本</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果不再持有该锁（即锁密钥版本大于零），则用户可以阻止交易。</font><font style="vertical-align: inherit;">在我们的测试中，这种方法使我们能够成功隔离读取-修改-写入操作，其中写入是唯一受锁定保护的事务。</font><font style="vertical-align: inherit;">这种方法提供的隔离类似于弹幕令牌，但是（像弹幕令牌一样）不能保证原子性：在包含许多操作的更新过程中，进程可能崩溃或丢失互斥体，从而使etcd处于逻辑不一致的状态。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
项目问题的工作成果：</font></font><br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从版本0开始的手表稍后开始</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -尚未确定；</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">锁在阻止后返回而无需检查所有权</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -在主服务器中；</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">锁没有记录为不安全</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -未解决。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4。讨论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的测试中，etcd 3.4.3达到了有关KV操作的期望：我们观察到了严格的可序列化的一致性，包括读，写甚至多键事务，尽管进程暂停，崩溃，时钟和网络的操作以及集群成员数量的变化。</font><font style="vertical-align: inherit;">默认情况下，严格的可序列化行为是在KV操作中实现的；</font></font><code>serializable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置</font><font style="vertical-align: inherit;">了标志的读取性能</font><font style="vertical-align: inherit;">导致出现过时的读取（如文档中所述）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
监控</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（手表）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正常工作-至少在单个按键上。</font><font style="vertical-align: inherit;">在压缩历史记录破坏了旧数据之前，手表成功地发布了每个密钥更新。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，事实证明，etcd中的锁（像所有分布式锁一样）不提供互斥。不同的进程可以同时持有锁-即使在时钟完全同步的健康集群中也是如此。带有锁定API的文档没有对此进行任何说明，并且所提供的锁定示例也不安全。但是，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此补丁</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发布后，锁的一些问题仍然存在</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于我们的合作，etcd团队对文档进行了许多修改（它们已经出现在GitHub上，并将在项目网站的未来版本中发布）。 GitHub Warranties API页面现在指出，默认情况下etcd </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">严格可序列化</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并取消了串行和可序列化是分布式系统中可用的最强一致性级别的主张。关于修订，现在指示开始应该</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从单元（1）开始</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，尽管API文档</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仍然没有说</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从0修订开始的尝试将导致“输出在当前修订加1之后发生的事件”。而不是预期的“所有事件的发送”。锁定安全性问题的文档</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正在开发中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从零修订版开始，某些文档更改（例如描述尝试读取时etcd的特殊行为）仍然需要引起注意。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
像往常一样，我们强调Jepsen在安全性验证方面更喜欢实验性的方法：我们可以确认错误的存在，但不能确认错误的存在。</font><font style="vertical-align: inherit;">人们在寻找问题上付出了巨大的努力，但是我们不能证明etcd的一般正确性。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1建议</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果在etcd中使用锁，请考虑是否需要它们以确保安全性或通过概率限制并发性来简单地提高性能。可以使用Etcd锁来提高性能，但是将其用于安全目的可能会带来风险。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特别是，如果您使用etcd锁来保护共享资源，例如文件，数据库或服务，则该资源应保证安全</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不被</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阻塞。实现此目的的一种方法是使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单调弹幕令牌</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。例如，它可能是与当前持有的锁定键关联的etcd版本。共享资源必须确保客户端使用令牌后</font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了执行某些操作，任何带有令牌的操作</font></font><code>x &lt; y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">都会被拒绝。这种方法不能确保原子性，但是可以保证锁定框架内的操作按顺序执行，而不是间歇执行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们怀疑普通用户不太可能遇到此问题。但是，如果你还是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依靠</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读所有从ETCD的变化，从第一个版本，记住，你需要传递1，而不是0作为参数。我们的实验表明，零修订在这种情况下，意思是“当前版本”，而不是“最早。”</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，锁和etcd（如所有分布式锁）会误导用户：他们可能希望将它们用作常规锁，但是当他们意识到这些锁不提供互斥时，会感到非常惊讶。</font><font style="vertical-align: inherit;">API文档，博客文章以及GitHub上的问题都没有说明这种风险。</font><font style="vertical-align: inherit;">我们建议您在etcd文档中包括锁不提供互斥的信息，并提供使用弹幕令牌更新共享资源状态的示例，而不是可能导致更新丢失的示例。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2进一步的计划</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
etcd项目已被认为稳定了好几年：基于它的Raft算法运行良好，用于KV操作的API简单明了。尽管最近有一些附加功能收到了新的API，但其语义相对简单。我们认为，我们已经研究了足够的基本命令，例如</font></font><code>get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>put</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，事务，阻止和跟踪。但是，还应该执行其他测试。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目前，我们尚未对</font><i><font style="vertical-align: inherit;">删除</font></i><font style="vertical-align: inherit;">进行足够详细的评估</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：不断创建和删除对象时，可能存在与版本和修订版相关的边界情况。在以后的测试中，我们打算对清除操作进行更仔细的研究。我们也没有测试范围查询或使用多个键的跟踪操作，尽管我们怀疑它们的语义类似于使用单个键的操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在测试中，我们使用了进程的暂停，崩溃，时钟的操纵，网络的划分以及集群的组成的更改；在幕后，</font><font style="vertical-align: inherit;">在一个节点上</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出现</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了</font><font style="vertical-align: inherit;">磁盘损坏和其他</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">拜占庭式故障</font></a><font style="vertical-align: inherit;">等问题</font><font style="vertical-align: inherit;">。这些机会可能会在未来的研究中加以探讨。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这项工作得到了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud Native Computing Foundation的支持。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux Foundation的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部分</font><font style="vertical-align: inherit;">，符合</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jepsen的道德政策</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们要感谢etcd团队的帮助，尤其是以下代表：克里斯·阿尼什奇克，李圭镐，李翔，李三岳，胡静怡和布兰登·飞利浦。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">译者的PS</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另请参阅我们的博客：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TiKV-用于云原生的分布式键值数据库</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来自CoreOS的Zetcd：用... storage etcd替换ZooKeeper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KeyDB作为Redis的[潜在]替代品</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据库和Kubernetes（审查和视频报告）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。”</font></font></li>
</ul></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN487516/index.html">使用Prefetch文件的攻击者的狩猎技术和策略</a></li>
<li><a href="../zh-CN487518/index.html">放射性产品。伽玛光谱仪。第2部分</a></li>
<li><a href="../zh-CN487522/index.html">我们让终端飞行（第1部分）</a></li>
<li><a href="../zh-CN487524/index.html">为什么硬件启动黑客马拉松需要</a></li>
<li><a href="../zh-CN487528/index.html">Изменения в пользовательском соглашении и политике конфиденциальности на сервисах Хабра</a></li>
<li><a href="../zh-CN487538/index.html">.NET Interactive在这里！| .NET笔记本预览2</a></li>
<li><a href="../zh-CN487540/index.html">HighLoad ++，Anastasia Tsymbalyuk，Stanislav Tselovalnikov（Sberbank）：我们如何成为MDA</a></li>
<li><a href="../zh-CN487542/index.html">当前-超轻量级块加密（原始PRESENT的翻译：超轻量级块密码）</a></li>
<li><a href="../zh-CN487544/index.html">.NET文档：一月份的新增功能</a></li>
<li><a href="../zh-CN487548/index.html">新实验：使用gRPC-Web从浏览器调用.NET gRPC服务</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>