<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏽 👩‍👧 🛌🏿 日曜大工のベアメタルプロビジョニング、またはゼロからの自動サーバー準備 ❄️ ㊙️ 🐕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、私はデニスです。私の活動分野の1つは、X5でのインフラストラクチャソリューションの開発です。本日は、公開されているツールに基づいて自動サーバー準備システムを導入する方法についてお話ししたいと思います。私の意見では、これは興味深い、シンプルで柔軟なソリューションです。
 
 
 
 準備と...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>日曜大工のベアメタルプロビジョニング、またはゼロからの自動サーバー準備</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/X5RetailGroup/blog/493124/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、私はデニスです。私の活動分野の1つは、X5でのインフラストラクチャソリューションの開発です。</font><font style="vertical-align: inherit;">本日は、公開されているツールに基づいて自動サーバー準備システムを導入する方法についてお話ししたいと思います。</font><font style="vertical-align: inherit;">私の意見では、これは興味深い、シンプルで柔軟なソリューションです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cs/aj/wx/csajwx5dsd-sdlngyst-pfrollu.png"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
準備とは、新しいサーバーからすぐに作成できる、完全に構成されたOS搭載サーバー </font><font style="vertical-align: inherit;">LinuxまたはESXiハイパーバイザー（Windowsサーバーのキャストについては、この記事では説明しません）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバー-構成する必要があるサーバー。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インストールサーバー-ネットワーク経由で準備プロセス全体を提供するメインサーバー。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜ自動化が必要なのですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題があるとしましょう：ピーク時にサーバーをゼロから大量に準備します-1日あたり30。</font><font style="vertical-align: inherit;">異なる製造元およびモデルのサーバー、異なるOSをそれらにインストールできます。ハイパーバイザーが存在する場合と存在しない場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セットアッププロセスに含まれる操作（自動化なし）：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーボード、マウス、モニターをサーバーに接続します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIOS、RAID、IPMIを構成します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネントのファームウェアをアップグレードします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイルシステムイメージをデプロイする（またはハイパーバイザーをインストールして仮想マシンをコピーする）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意。</font><font style="vertical-align: inherit;">または、自動応答ファイルを使用してインストールすることにより、OSを展開できます。</font><font style="vertical-align: inherit;">ただし、これについては記事では説明しません。</font><font style="vertical-align: inherit;">この機能を追加するのは簡単です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OSパラメータ（ホスト名、IPなど）を構成します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチでは、同じ設定が各サーバーで順次実行されます。</font><font style="vertical-align: inherit;">そのような作業の効果は非常に低いです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動化の本質は、サーバーの準備プロセスから人間の関与を排除することです。</font><font style="vertical-align: inherit;">できるだけ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動化のおかげで、操作間のダウンタイムが削減され、同時に複数のサーバーを準備することが可能になります。</font><font style="vertical-align: inherit;">人的要因によるエラーの可能性も大幅に削減されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/g7/ic/x1/g7icx1q3tb0yanpntf9jmw8n4p4.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーはどのように自動的に構成されますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのステップを詳細に分析します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PXEインストールサーバーとして使用するLinuxサーバーがあります。</font><font style="vertical-align: inherit;">サービスがインストールおよび構成されています：DHCP、TFTP。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、PXEによってサーバー（構成が必要なもの）をロードします。</font><font style="vertical-align: inherit;">それがどのように機能するかを思い出してください：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワーク経由で起動するように選択されたサーバー。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーはネットワークカードのPXE-ROMをロードし、DHCP経由でインストールサーバーに接続してネットワークアドレスを取得します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インストールサーバーのDHCPは、アドレスと、PXE経由でさらにダウンロードするための指示を提供します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーは、PXEを介してインストールサーバーからネットワークブートローダーをダウンロードします。PXE構成ファイルに従って、さらにダウンロードが行われます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダウンロードは、受信したパラメーター（カーネル、initramfs、マウントポイント、squashfsイメージなど）に基づいて実行されます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意。</font><font style="vertical-align: inherit;">この記事では、BIOSモードによるPXEブートについて説明します。</font><font style="vertical-align: inherit;">現在、メーカーはUEFIブートモードを積極的に導入しています。</font><font style="vertical-align: inherit;">PXEの場合、違いはDHCPサーバー構成と追加のブートローダーの存在にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PXEサーバーの構成例（pxelinuxメニュー）について考えてみます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルpxelinux.cfg /デフォルト：</font></font><br>
<br>
<pre><code class="plaintext hljs">default menu.c32<font></font>
prompt 0<font></font>
timeout 100<font></font>
menu title X5 PXE Boot Menu<font></font>
LABEL InstallServer Menu<font></font>
	MENU LABEL InstallServer<font></font>
	KERNEL menu.c32<font></font>
	APPEND pxelinux.cfg/installserver<font></font>
LABEL VMware Menu<font></font>
	MENU LABEL VMware ESXi Install<font></font>
	KERNEL menu.c32<font></font>
	APPEND pxelinux.cfg/vmware<font></font>
LABEL toolkit //   <font></font>
	MENU LABEL Linux Scripting Toolkits<font></font>
	MENU default<font></font>
	KERNEL menu.c32<font></font>
	APPEND pxelinux.cfg/toolkit //    </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルpxelinux.cfg /ツールキット：</font></font><br>
<br>
<pre><code class="plaintext hljs">prompt 0<font></font>
timeout 100<font></font>
menu title X5 PXE Boot Menu<font></font>
label mainmenu<font></font>
    menu label ^Return to Main Menu<font></font>
    kernel menu.c32<font></font>
    append pxelinux.cfg/default<font></font>
label x5toolkit-auto //   —  <font></font>
        menu label x5 toolkit autoinstall<font></font>
        menu default<font></font>
        kernel toolkit/tkcustom-kernel<font></font>
        append initrd=toolkit/tk-initramfs.gz quiet net.ifnames=0 biosdevname=0 nfs_toolkit_ip=192.168.200.1 nfs_toolkit_path=tftpboot/toolkit nfs_toolkit_script=scripts/mount.sh script_cmd=master-install.sh CMDIS2=”…”<font></font>
label x5toolkit-shell //   - <font></font>
        menu label x5 toolkit shell<font></font>
        kernel toolkit/tkcustom-kernel<font></font>
        append initrd=toolkit/tkcustom-initramfs.gz quiet net.ifnames=0 biosdevname=0 nfs_toolkit_ip=192.168.200.1 nfs_toolkit_path=tftpboot/toolkit nfs_toolkit_script=scripts/mount.sh script_cmd=/bin/bash CMDIS2=”…”</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階でのカーネルとinitramfsは中間的なlinux-imageであり、これを使用してサーバーの基本的な準備と構成が行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、ブートローダーは多くのパラメーターをカーネルに渡します。</font><font style="vertical-align: inherit;">これらのパラメーターの一部は、カーネル自体によって使用されます。</font><font style="vertical-align: inherit;">そして、私たち自身の目的のためにいくつかを使用することができます。</font><font style="vertical-align: inherit;">これについては後で説明しますが、今のところ、渡されたすべてのパラメーターは/ proc / cmdlineを介して中間Linuxイメージで使用できることを覚えておいてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カーネルとinitramfsはどこで入手できますか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本として、任意のLinuxディストリビューションを選択できます。</font><font style="vertical-align: inherit;">選択するときに注意すること：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブートイメージはユニバーサルである必要があります（利用可能なドライバー、追加のユーティリティをインストールする機能）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどの場合、initramfsをカスタマイズする必要があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X5のソリューションでは、これはどのように行われますか？ CentOS 7がベースとして選択されたので、次のトリックを実行してみましょう：将来のイメージ構造を準備し、それをアーカイブにパックして、内部にファイルシステムアーカイブとなるinitramfsを作成します。イメージをロードすると、アーカイブは作成されたtmpfsセクションにデプロイされます。したがって、必要なユーティリティをすべて備えた最小限の本格的なlive-linuxイメージが得られます。これは、vmkernelとinitramfsの2つのファイルのみで構成されています。</font></font><br>
<br>
<pre><code class="plaintext hljs"># : <font></font>
<font></font>
mkdir -p /tftpboot/toolkit/CustomTK/rootfs /tftpboot/toolkit/CustomTK/initramfs/bin<font></font>
<font></font>
# :<font></font>
<font></font>
yum groups -y install "Minimal Install" --installroot=/tftpboot/toolkit/CustomTK/rootfs/<font></font>
yum -y install nfs-utils mariadb ntpdate mtools syslinux mdadm tbb libgomp efibootmgr dosfstools net-tools pciutils openssl make ipmitool OpenIPMI-modalias rng-tools --installroot=/tftpboot/toolkit/CustomTK/rootfs/<font></font>
yum -y remove biosdevname --installroot=/tftpboot/toolkit/CustomTK/rootfs/<font></font>
<font></font>
#  initramfs:<font></font>
<font></font>
wget https://busybox.net/downloads/binaries/1.31.0-defconfig-multiarch-musl/busybox-x86_64 -O /tftpboot/toolkit/CustomTK/initramfs/bin/busybox<font></font>
chmod a+x /tftpboot/toolkit/CustomTK/initramfs/bin/busybox<font></font>
cp /tftpboot/toolkit/CustomTK/rootfs/boot/vmlinuz-3.10.0-957.el7.x86_64 /tftpboot/toolkit/tkcustom-kernel<font></font>
<font></font>
#  /tftpboot/toolkit/CustomTK/initramfs/init (  ):<font></font>
<font></font>
#!/bin/busybox sh<font></font>
/bin/busybox --install /bin<font></font>
mkdir -p /dev /proc /sys /var/run /newroot<font></font>
mount -t proc proc /proc<font></font>
mount -o mode=0755 -t devtmpfs devtmpfs /dev<font></font>
mkdir -p /dev/pts /dev/shm /dev/mapper /dev/vc<font></font>
mount -t devpts -o gid=5,mode=620 devpts /dev/pts<font></font>
mount -t sysfs sysfs /sys<font></font>
mount -t tmpfs -o size=4000m tmpfs /newroot<font></font>
echo -n "Extracting rootfs... "<font></font>
xz -d -c -f rootfs.tar.xz | tar -x -f - -C /newroot<font></font>
echo "done"<font></font>
mkdir -p /newroot/dev /newroot/proc /newroot/sys<font></font>
mount --move /sys  /newroot/sys<font></font>
mount --move /proc /newroot/proc<font></font>
mount --move /dev  /newroot/dev<font></font>
exec switch_root /newroot /sbin/init<font></font>
<font></font>
#  rootfs  initramfs:<font></font>
<font></font>
cd /tftpboot/toolkit/CustomTK/rootfs<font></font>
tar cJf /tftpboot/toolkit/CustomTK/initramfs/rootfs.tar.xz --exclude ./proc --exclude ./sys --exclude ./dev .<font></font>
cd /tftpboot/toolkit/CustomTK/initramfs<font></font>
find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; /tftpboot/toolkit/tkcustom-initramfs-new.gz</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ロードする必要があるカーネルとinitramfsを指定しました。</font><font style="vertical-align: inherit;">その結果、この段階で、PXEを介して中間Linuxイメージをダウンロードし、OSコンソールを取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すばらしいですが、今度は制御を「自動化」に移す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようにできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イメージをロードした後、mount.shスクリプトに制御を移すことを計画しているとします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動実行にmount.shスクリプトを含めます。</font><font style="vertical-align: inherit;">これを行うには、initramfsを変更する必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initramfsを解凍します（上記のバージョンのinitramfsを使用する場合、これは必要ありません）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ proc / cmdlineを介して渡されたパラメーターを分析し、制御をさらに転送する起動コードに含めます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initramfsをパックします。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意。 X5ツールキットの場合、ブート制御がスクリプトに渡されるため</font></font><code>/opt/x5/toolkit/bin/hook.sh   override.conf  getty tty1 (ExecStart=…) </code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、イメージが読み込まれ、起動時にmount.shスクリプトが開始されます。次に、分析プロセスのmount.shスクリプトが、渡されたパラメーター（script_cmd =）を分析し、必要なプログラム/スクリプトを起動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
label toolkit- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auto</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
kernel ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
append ... nfs_toolkit_script = scripts / mount.sh </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">script_cmd = master-install.sh</font></font><br>
</b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
label toolkit- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shell</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
kernel ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
append ... nfs_toolkit_script = scripts / mount.sh </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">script_cmd = / bin / bash</font></font></b><br>
<br>
<img src="https://habrastorage.org/webt/w9/xc/8b/w9xc8b87fob_jooqjazqiyyiccm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ここの左側はPXEメニューです、右側はコントロール転送スキームです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
支配権の移転により、我々はそれを理解した。</font><font style="vertical-align: inherit;">PXEメニューの選択に応じて、自動チューニングスクリプトまたはデバッグコンソールが起動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動構成の場合、インストールサーバーから必要なディレクトリがマウントされます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スクリプト;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまなサーバーの保存されたBIOS / UEFIテンプレート。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファームウェア;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーのユーティリティ。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ログ。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、mount.shスクリプトは、scriptsディレクトリからmaster-install.shスクリプトに制御を移します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スクリプトツリー（起動の順序）は次のようになります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マスターインストール</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共有機能（共通機能）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">info（情報出力）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデル（サーバーモデルに基づくインストールパラメータの設定）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prepare_utils（必要なユーティリティのインストール）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fwupdate（ファームウェアの更新）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diag（基本診断）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biosconf（BIOS / UEFIセットアップ）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clockfix（マザーボードの時刻の設定）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srmconf（リモートインターフェースの構成）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raidconf（論理ボリュームの構成）</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
の一つ：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレインストール（OSまたはハイパーバイザー（ESXiなど）のインストーラーに制御を移す）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マージされたインストール（イメージの解凍の直接開始）</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今私たちは知っています：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PXE経由でサーバーを起動する方法。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自分のスクリプトに制御を移す方法。</font></font></li>
</ul></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
続けましょう。</font><font style="vertical-align: inherit;">次の問題が関連するようになりました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準備しているサーバーを特定するにはどうすればよいですか？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのユーティリティとサーバーの構成方法？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のサーバーの設定を取得するにはどうすればよいですか？</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準備しているサーバーを特定するにはどうすればよいですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは簡単です-DMI：</font></font><br>
<br>
<pre><code class="plaintext hljs">dmidecode –s system-product-name<font></font>
dmidecode –s system-manufacturer<font></font>
dmidecode –s system-serial-number</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ベンダー、モデル、シリアル番号など、必要なものがすべて揃っています。</font><font style="vertical-align: inherit;">この情報がすべてのサーバーに表示されるかどうかわからない場合は、MACアドレスで識別できます。</font><font style="vertical-align: inherit;">または、サーバーベンダーが異なり、一部のモデルではシリアル番号情報が利用できない場合、同時に両方の方法で使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
受け取った情報に基づいて、インストールサーバーからのネットワークフォルダーがマウントされ、必要なものがすべて読み込まれます（ユーティリティ、ファームウェアなど）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのユーティリティとサーバーの構成方法？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のメーカー向けにLinux用のユーティリティを提供します。</font><font style="vertical-align: inherit;">すべてのユーティリティは、ベンダーの公式Webサイトで入手できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xx/xh/3f/xxxh3f0pg48elgtr8qn9r_wjp4q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファームウェアがあれば、すべてがはっきりしていると思います。</font><font style="vertical-align: inherit;">通常、パッケージ化された実行可能ファイルで提供されます。</font><font style="vertical-align: inherit;">実行可能ファイルは、ファームウェアの更新プロセスを制御し、戻りコードを報告します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BIOSとIPMIは通常、テンプレートを介して構成されます。</font><font style="vertical-align: inherit;">必要に応じて、ロードする前にテンプレートを編集できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のベンダーのRAIDユーティリティは、テンプレートに従って構成することもできます。</font><font style="vertical-align: inherit;">そうでない場合は、構成スクリプトを作成する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAIDを構成する手順は、ほとんどの場合次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在の構成をリクエストします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すでに論理アレイがある場合は、それを消去します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存在する物理ディスクとその数を調べます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい論理配列を作成します。</font><font style="vertical-align: inherit;">エラーが発生した場合は、プロセスを中断します。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定のサーバーの設定を取得するにはどうすればよいですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのサーバー設定がインストールサーバーに保存されているとします。</font><font style="vertical-align: inherit;">この場合、質問に答えるために、最初に次のことを決定する必要があります。設定をインストールサーバーに転送する方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、テキストファイルを処理することはかなり可能です。</font><font style="vertical-align: inherit;">（将来的には、設定を転送するためのバックアップ方法としてテキストファイルを使用できます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インストールサーバーでテキストファイルを「共有」できます。</font><font style="vertical-align: inherit;">そして、それをmount.shスクリプトに追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの行は、たとえば次のようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&lt;シリアル番号&gt; &lt;ホスト名&gt; &lt;サブネット&gt; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの行は、エンジニアが作業マシンからファイルに転送します。</font><font style="vertical-align: inherit;">そして、サーバーをセットアップするときに、特定のサーバーのパラメーターがファイルから読み取られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、将来的には、データベースを使用して設定、状態、サーバーインストールログを保存することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、1つのデータベースでは実行できません。クライアントパーツを作成して、設定をデータベースに転送する必要があります。これはテキストファイルよりも実装が困難ですが、実際にはそれほど難しくはありません。単にデータベースにデータを転送するだけの最低限のバージョンのクライアントは、自分で書くのに非常に適しています。将来的には、フリーモードでもクライアントプログラムを改善できるようになります（レポート、ラベルの印刷、通知の送信など、頭に浮かぶものは何でも）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースに特定の要求を行い、サーバーのシリアル番号を示したら、サーバーを構成するために必要なパラメーターを取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、テキストファイルの場合のように、同時アクセスのためにロックを作成する必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースのすべての段階で構成ログを書き込み、準備段階のイベントとフラグを通じてインストールプロセスを制御できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これで方法がわかりました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PXE経由でサーバーをロードします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スクリプトに制御を移します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準備するサーバーをシリアル番号で識別します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">適切なユーティリティでサーバーを構成します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアント部分を使用して、設定をインストールサーバーデータベースに転送します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
方法を見つけました：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インストールされたサーバーは、データベースから必要な設定を受け取ります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての準備の進捗状況がデータベースに記録されます（ログ、イベント、ステージフラグ）。</font></font></li>
</ul></b><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インストールされているさまざまな種類のソフトウェアはどうですか？</font><font style="vertical-align: inherit;">ハイパーバイザーをインストールし、VMをコピーして、これらすべてを構成する方法は？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルシステムイメージ（Linux）をハードウェアにデプロイする場合、すべてが非常に簡単です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのサーバーコンポーネントをセットアップしたら、イメージを展開します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GRUBブートローダーをインストールします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちはchrootを作成し、必要なものすべてを構成します。</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OSインストーラーに制御を移す方法（ESXiを例として使用）。</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動応答ファイル（キックスタート）を使用して、スクリプトからハイパーバイザーインストーラーへの制御の転送を整理します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディスク上の現在のパーティションを削除します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">500MBのパーティションを作成します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブートとしてマークします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FAT32でフォーマットします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESXiインストールファイルをルートにコピーします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">syslinuxをインストールします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">syslinux.cfgを/ syslinux /にコピーします</font></font></li>
</ul><br>
<pre><code class="plaintext hljs">default esxi<font></font>
prompt 1<font></font>
timeout 50<font></font>
label esxi<font></font>
kernel mboot.c32<font></font>
append -c boot.cfg</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mboot.c32を/ syslinuxにコピーします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boot.cfgにkernelopt = ks = ftpがあるはずです：// &lt;インストールサーバーのIP&gt; /ks_esxi.cfg</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーを再起動します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーの再起動後、ESXiインストーラーはそのハードドライブから起動します。</font><font style="vertical-align: inherit;">指定された自動応答ファイルに従って、必要なすべてのインストーラーファイルがメモリに読み込まれ、ESXiのインストールが開始されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ks_esxi.cfg自動応答ファイルの数行を示します。</font></font><br>
<br>
<pre><code class="plaintext hljs">%firstboot --interpreter=busybox<font></font>
…<font></font>
#   <font></font>
<font></font>
SYSSN=$(esxcli hardware platform get | grep Serial | awk -F " " '{print $3}')<font></font>
<font></font>
#  IP<font></font>
<font></font>
IPADDRT=$(esxcli network ip interface ipv4 get | grep vmk0 | awk -F " " '{print $2}')<font></font>
LAST_OCTET=$(echo $IPADDRT | awk -F'.' '{print $4}')<font></font>
<font></font>
#  NFS -<font></font>
<font></font>
esxcli storage nfs add -H is -s /srv/nfs_share -v nfsshare1<font></font>
<font></font>
#    ssh,   ssh-<font></font>
<font></font>
mv /etc/ssh /etc/ssh.tmp<font></font>
cp -R /vmfs/volumes/nfsshare1/ssh /etc/<font></font>
chmod go-r /etc/ssh/ssh_host_rsa_key<font></font>
<font></font>
#  ovftool,    ,    <font></font>
<font></font>
cp -R /vmfs/volumes/nfsshare1/ovftool /vmfs/volumes/datastore1/<font></font>
<font></font>
#  <font></font>
<font></font>
/vmfs/volumes/datastore1/ovftool/tools/ovftool --acceptAllEulas --noSSLVerify --datastore=datastore1 --name=VM1 /vmfs/volumes/nfsshare1/VM_T/VM1.ova vi://root:esxi_password@127.0.0.1<font></font>
/vmfs/volumes/datastore1/ovftool/tools/ovftool --acceptAllEulas --noSSLVerify --datastore=datastore1 --name=VM2 /vmfs/volumes/nfsshare1/VM_T/VM2.ova vi://root:esxi_password@127.0.0.1<font></font>
<font></font>
#      <font></font>
<font></font>
ssh root@is "mysql -h'192.168.0.1' -D'servers' -u'user' -p'secretpassword' -e \"SELECT ... WHERE servers.serial='$SYSSN'\"" | grep -v ^$ | sed 's/NULL//g' &gt; /tmp/servers<font></font>
...<font></font>
#    <font></font>
<font></font>
echo '#!/bin/sh' &gt; /vmfs/volumes/datastore1/netconf.sh<font></font>
echo "esxcli network ip interface ipv4 set -i=vmk0 -t=static --ipv4=$IPADDR --netmask=$S_SUB || exit 1" &gt;&gt; /vmfs/volumes/datastore1/netconf.sh<font></font>
echo "esxcli network ip route ipv4 add -g=$S_GW -n=default || exit 1" &gt;&gt; /vmfs/volumes/datastore1/netconf.sh<font></font>
chmod a+x /vmfs/volumes/datastore1/netconf.sh<font></font>
<font></font>
#   guestinfo.esxihost.id,     <font></font>
<font></font>
echo "guestinfo.esxihost.id = \"$SYSSN\"" &gt;&gt; /vmfs/volumes/datastore1/VM1/VM1.vmx<font></font>
echo "guestinfo.esxihost.id = \"$SYSSN\"" &gt;&gt; /vmfs/volumes/datastore1/VM2/VM2.vmx<font></font>
...<font></font>
#    <font></font>
<font></font>
SYSNAME=$(esxcli hardware platform get | grep Product | sed 's/Product Name://' | sed 's/^\ *//')<font></font>
UUID=$(vim-cmd hostsvc/hostsummary | grep uuid | sed 's/\ //g;s/,$//' | sed 's/^uuid="//;s/"$//')<font></font>
ssh root@is "mysql -D'servers' -u'user' -p'secretpassword' -e \"UPDATE servers ... SET ... WHERE servers.serial='$SYSSN'\""<font></font>
ssh root@is "mysql -D'servers' -u'user' -p'secretpassword' -e \"INSERT INTO events ...\""<font></font>
<font></font>
#   SSH<font></font>
<font></font>
rm -rf /etc/ssh<font></font>
mv /etc/ssh.tmp /etc/ssh<font></font>
<font></font>
#    <font></font>
<font></font>
esxcli system hostname set --fqdn=esx-${G_NICK}.x5.ru<font></font>
/vmfs/volumes/datastore1/netconf.sh<font></font>
reboot<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階で、ハイパーバイザーがインストールおよび構成され、仮想マシンがコピーされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今仮想マシンを構成する方法？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少し騙しました。インストール中に、VM1.vmxファイルにguestinfo.esxihost.id = "$ SYSSN"パラメータを設定し、そこに物理サーバーのシリアル番号を示しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、起動後、仮想マシン（vmware-toolsパッケージがインストールされている）はこのパラメーターにアクセスできます。</font></font><br>
<br>
<pre><code class="plaintext hljs">ESXI_SN=$(vmtoolsd --cmd "info-get guestinfo.esxihost.id")</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、VMはそれ自体を識別し（物理ホストのシリアル番号を知っています）、インストールサーバーデータベースに要求を出し、構成する必要のあるパラメーターを取得します。</font><font style="vertical-align: inherit;">これはすべて、guestos vmの起動時に自動的に起動されるスクリプトで実行されます（ただし、1回：RunOnce）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これで方法がわかりました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PXE経由でサーバーをロードします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スクリプトに制御を移します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準備するサーバーをシリアル番号で識別します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">適切なユーティリティでサーバーを構成します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クライアント部分を使用して設定をインストールサーバーデータベースに転送します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esxiハイパーバイザーのデプロイや仮想マシンの構成など、さまざまなタイプのPOを構成します（すべて自動的に）。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
方法を見つけました：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インストールされたサーバーは、データベースから必要な設定を受け取ります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての準備の進捗状況がデータベースに記録されます（ログ、イベント、ステージフラグ）。</font></font></li>
</ul></b><br>
<u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論：</font></font></b></u><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このソリューションの独自性は、その柔軟性、シンプルさ、機能、および多様性にあると私は信じています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コメント欄にご意見をお寄せください。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja493112/index.html">3年ではなく6か月で新しいビジネスを始める方法</a></li>
<li><a href="../ja493114/index.html">データエンジニアによるデータの監視方法</a></li>
<li><a href="../ja493116/index.html">「より多くのインタラクティブ性！」または、TeamLead Conf 2020はいかがでしたか</a></li>
<li><a href="../ja493118/index.html">メモリタグ拡張機能の概要（Armv8.5-A）</a></li>
<li><a href="../ja493122/index.html">バンザイゲームオフィス：モスクワの中心にある日本</a></li>
<li><a href="../ja493126/index.html">イベント指向アーキテクチャーのアンチパターン</a></li>
<li><a href="../ja493130/index.html">コロナウイルスを恐れるべきではない理由：神話とCOVID-2019に関するほとんどの真実</a></li>
<li><a href="../ja493132/index.html">data.tableの周り</a></li>
<li><a href="../ja493136/index.html">Unity StorageのFAST VP：仕組み</a></li>
<li><a href="../ja493138/index.html">私に話しかけてください：今日、音声ボットができること</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>