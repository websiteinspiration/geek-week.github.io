<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥üèæ ‚¨áÔ∏è ‚ÜïÔ∏è .NET: Dependency Treatment üåì üç£ üñïüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Who has not encountered problems due to assembly redirect? Most likely, everyone who developed a relatively large application will sooner or later fac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>.NET: Dependency Treatment</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/499838/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Who has not encountered problems due to assembly redirect? </font><font style="vertical-align: inherit;">Most likely, everyone who developed a relatively large application will sooner or later face this problem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now I work at JetBrains, in the JetBrains Rider project, and am involved in the task of migrating Rider to .NET Core. </font><font style="vertical-align: inherit;">Previously engaged in shared infrastructure in Circuit, a cloud-based application hosting platform. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/je/f5/e-/jef5e-nc0okqm_ssla0qhniugio.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Under the cutscene is the transcript of my report from the DotNext 2019 Moscow conference, where I talked about the difficulties when working with assemblies in .NET and showed with practical examples what happens and how to deal with it.</font></font><a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/fMlTLw1agE0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In all the projects where I worked as a .NET developer, I had to deal with various problems with connecting dependencies and loading assemblies. </font><font style="vertical-align: inherit;">We‚Äôll talk about this.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Post structure:</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependency Issues</font></font></b></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strict rig loading</font></font></b></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binding redirects</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strong naming</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core</font></font></a></b> <br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shared frameworks, .runtimeconfig.json</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependency manifest (.deps.json)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacks to Run JetBrains Rider on Core</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug assembly downloads</font></font></a> </b><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusion logs</font></font></a> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Runtime events</font></font></a></li>
</ul><br>
</li>
</ol><br>
<a name="problems"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What are some dependency issues?</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When they started developing the .NET Framework in the early 2000s, the Dependency hell problem was already known, when in all libraries developers allow breaking changes, and these libraries become incompatible for use with already compiled code. </font><font style="vertical-align: inherit;">How to solve such a problem? </font><font style="vertical-align: inherit;">The first solution is obvious. </font><font style="vertical-align: inherit;">Always maintain backward compatibility. </font><font style="vertical-align: inherit;">Of course, this is not very realistic, because breaking change is very easy to put into code. </font><font style="vertical-align: inherit;">For example: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/un/gj/tv/ungjtvaiofi7qkm6a4if5cpgh10.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Breaking changes and .NET libraries</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is an example specific to .NET. We have a method, and we decided to add a parameter with a default value to it. The code will continue to compile if we reassemble it, but binary it will be two completely different methods: one method has zero arguments, the second method has one argument. If the developer inside the dependency broke backward compatibility in this way, then we will not be able to use the code that was compiled with this dependency on the previous version.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second solution to dependency problems is to add versioning of libraries, assemblies - anything. There may be different versioning rules, the point is that we can somehow distinguish different versions of the same library from each other, and you can understand if the update will break or not break. Unfortunately, as soon as we introduce the versions, a different sort of problem appears. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/xc/wu/vgxcwufmesq4jly-ecfrh5p-ko8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Version hell is the inability to use a dependency that is binary compatible, but at the same time has a version that did not fit the runtime or another component that checks these versions. In .NET, a typical manifestation of version hell is FileLoadException, although the file lies on the disk, but for some reason it is not loaded with runtime.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qy/wg/5m/qywg5mjhpkuogm6yez7uhnxitji.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In .NET, assemblies have many different versions - they tried to fix version hells in various ways, and see what happened. We have a package </font></font><code>System.Collections.Immutable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Many people know him. He has the latest version of the NuGet package 1.6.0. It contains a library, an assembly with version 1.2.4.0. You have received that you do not have a build library version 1.2.4.0. How to understand that it lies in the 1.6.0 NuGet package? It will not be easy. In addition to Assembly Version, this library has several more versions. For example, Assembly File Version, Assembly Information Version. This NuGet package actually contains three different assemblies with the same versions (for different versions of the .NET Standard). </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Documentation </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opbuild standard</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A lot of documentation has been written on how to work with assemblies in .NET. </font><font style="vertical-align: inherit;">There is a .NET Guide for developing modern applications for .NET taking into account the .NET Framework, .NET Standard, .NET Core, open source and all that can be. </font><font style="vertical-align: inherit;">About 30% of the entire document is devoted to loading assemblies. </font><font style="vertical-align: inherit;">We will analyze specific problems and examples that may arise.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why is all this necessary? </font><font style="vertical-align: inherit;">Firstly, to avoid stepping on a rake. </font><font style="vertical-align: inherit;">Secondly, you can make life easier for users of your libraries because with your library they will not have the dependency problems they are used to. </font><font style="vertical-align: inherit;">It will also help you cope with the migration of complex applications to .NET Core. </font><font style="vertical-align: inherit;">And to top it all off, you can become an SRE, this is a Senior (Binding) Redirect engineer, to which everyone in the team comes and asks how to write another redirect.</font></font><a name="assembly"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strict assembly Loading</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Strict assembly loading is the main problem that developers on the .NET Framework are facing. </font><font style="vertical-align: inherit;">It is expressed in </font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Before moving on to Strict assembly loading itself, let me remind you of a few basic things. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When you build a .NET application, you end up with some artifact, which is usually located in Bin / Debug or Bin / Release, and contains a certain set of assembly assemblies and configuration files. </font><font style="vertical-align: inherit;">Assemblies will refer to each other by name, Assembly name. </font><font style="vertical-align: inherit;">It is important to understand that assembly links are located directly in the assembly that references this assembly; there are no magic configuration files where assembly references are written. </font><font style="vertical-align: inherit;">Even though it may seem to you that such files exist. </font><font style="vertical-align: inherit;">References are in the assemblies themselves in binary form.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In .NET, there is an assembly resolving process - this is when the assembly definition is already converted to a real assembly, which is on disk or loaded somewhere in memory. Assembly resolving is performed twice: at the build stage, when you have references in * .csproj, and at runtime, when you have references inside the assemblies, and by some rules they turn into assemblies that can be downloaded. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Simple name </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MyAssembly, Version = 6.0.0.0, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Culture = neutral, PublicKeyToken = null </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Strong name </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Newtonsoft.Json, Version = 6.0.0.0, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Culture = neutral, PublicKeyToken = 30ad4fe6b2a6aeed // PublicKey</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's move on to the problem. Assembly name there are two main types. The first kind of assembly name is Simple name. They are easy to identify by the fact that they have PublicKeyToken = null. There is a Strong name, it is easy to identify them by the fact that their PublicKeyToken is not null, but some value. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/40/0v/uf/400vuf0e3w-ykw2fkdx2-ufdutq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's take an example. We have a program that depends on the library with MyUtils utilities, and the version of MyUtils is 9.0.0.0. The same program has a link to another library. This library also wants to use MyUtils, but version 6.0.0.0. MyUtils version 9.0.0.0, and version 6.0.0.0 have PublicKeyToken = null, that is, they have a Simple name. Which version will fall into the binary artifact, 6.0.0.0 or 9.0.0.0? 9th version. Can MyLibrary use MyUtils version 9.0.0.0, which got into the binary artifact?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/js/fs/2x/jsfs2xd1erckl8dkphbrhojfhxk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, it can, because MyUtils has a Simple name and, accordingly, the Strict assembly loading does not exist for it. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kz/tn/a6/kztna61effl0kkiuwnkvi1gpad8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another example. </font><font style="vertical-align: inherit;">Instead of MyUtils, we have a full library from NuGet, which has a Strong name. </font><font style="vertical-align: inherit;">Most libraries in NuGet have a Strong name.</font></font><br>
<br>
<a name="redirects"></a><img src="https://habrastorage.org/webt/rr/xp/qi/rrxpqilvehdbvemijol2iuutbie.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the build stage, version 9.0.0.0 is copied to BIN, but in runtime we get the famous one </font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In order for MyLibrary, which wants version 6.0.0.0 to </font></font><code>Newtonsoft.Json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, to be able to use version 9.0.0.0, you have to go and write Binding redirect to </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binding redirects</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/lw/d_/yq/lwd_yq2otb7kqsbpkpglszjlr-y.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redirecting assembly versions</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
It states that an assembly with such a name and such publicKeyToken should be redirected from such a range of versions to such a range of versions. </font><font style="vertical-align: inherit;">It seems to be a very simple record, but nevertheless it is located here </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but could be in other files. </font><font style="vertical-align: inherit;">There is a file </font></font><code>machine.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inside the .NET Framework, inside the runtime, in which some standard set of redirects is defined, which may differ from version to version of the .NET Framework. </font><font style="vertical-align: inherit;">It may happen that on 4.7.1 nothing works for you, but on 4.7.2 it already works, or vice versa. </font><font style="vertical-align: inherit;">You need to keep in mind that redirects can come not only from yours </font></font><code>.App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and this should be taken into account when debugging.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We simplify the writing of redirects</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No one wants to write Binding redirects with their hands. Let's give this task to MSBuild! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pg/qk/ct/pgqkctk1hwcp0lewpamhi5wn35o.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to enable and disable automatic binding redirection</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
A few tips on how to simplify working with Binding redirect. Tip One: Enable Binding redirect auto-generation in MSBuild. Turned on by property in </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. When building a project, it will fall into a binary artifact </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which indicates redirects to versions of libraries that are in the same artifact. This only works for running applications, console application, WinExe. For libraries, this does not work, because for libraries</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">most often it‚Äôs simply not relevant, because it is relevant for an application that launches and loads assemblies itself. If you made a config for the library, then in the application some dependencies may also differ from those that were when building the library, and it turns out that the config for the library does not make much sense. Nevertheless, sometimes for libraries configs still make sense. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ik/g6/6n/ikg66nyqel3ejmqbln9xb1magyq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The situation when we write tests. Tests are usually found in ClassLibrary and they also need redirects. Test frameworks are able to recognize that the library with tests has a dll-config, and exchange the redirects that are in them for the code from the tests. You can generate these redirects automatically. If we have an old format</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, not SDK-style, you can go the simple way, change the OutputType to Exe and add an empty entry point, this will force MSBuild to generate redirects. You can go the other way and use the hack. You can add another property to </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which makes MSBuild consider that for this OutputType you still need to generate Binding redirects. This method, although it looks like a hack, will allow you to generate redirects for libraries that cannot be redone in Exe, and for other types of projects (except tests). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For the new format, </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">redirects will be generated themselves if you use modern Microsoft.NET.Test.Sdk.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Third tip: do not use Binding redirect generation with NuGet. NuGet has the ability to generate Binding redirect for libraries that pass from packages to the latest versions, but this is not the best option. All of these redirects will have to be added to </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and committed, and if you generate redirects using MSBuild, then redirects are generated during the build. If you commit them, you may have merge conflicts. You yourself can simply forget to update the Binding redirect in the file, and if they are generated during the build, you will not forget. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yi/fr/zq/yifrzq4fnvwitenrhkteup1cjfq.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resolve Assembly Reference </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generate Binding Redirects</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Homework for those who want to better understand how the generation of Binding redirects works: find out how it works, see this in the code. Go to the .NET directory, go bump everywhere with the name property, which is used to enable generation. This is generally such a common approach, if there is some strange property for MSBuild, you can go and take advantage of its use. Fortunately, property is usually used in XML configs, and you can easily find their use. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you examine what is in these XML targets, you will see that this property triggers two MSBuild tasks. The first task is called </font></font><code>ResolveAssemblyReferences</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and it generates a set of redirects that are written to files. The second task </font></font><code>GenerateBindingRedirects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">writes the results of the first task to</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">There is XML logic that slightly corrects the operation of the first task and removes some unnecessary redirects, or adds new ones.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternative to XML Configs</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is not always convenient to keep redirects in the XML config. </font><font style="vertical-align: inherit;">We may have a situation where the application downloads the plugin, and this plugin uses other libraries that require redirects. </font><font style="vertical-align: inherit;">In this case, we may not be aware of the set of redirects that we need, or we may not want to generate XML. </font><font style="vertical-align: inherit;">In such a situation, we can create an AppDomain and, when it is created, still transfer to it where the XML with the necessary redirects is located. </font><font style="vertical-align: inherit;">We can also handle assembly loading errors right in runtime. </font><font style="vertical-align: inherit;">Rantime .NET gives such an opportunity.</font></font><br>
<br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (sender, eventArgs) =&gt; <font></font>
{ <font></font>
   <span class="hljs-keyword">var</span> name = eventArgs.Name; 
   <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
   <font></font>
   <span class="hljs-keyword">return</span> Assembly.LoadFrom(...); <span class="hljs-comment">// PublicKeyToken should be equal</span><font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It has an event, it is called </font></font><code>CurrentDomain.AssemblyResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. By subscribing to this event, we will receive errors about all failed assembly downloads. We get the name of the assembly that did not load, and we get the assembly assembly that requested the first assembly to load. Here we can manually load the assembly from the right place, for example, dropping the version, just taking it from the file, and returning this event from the handler. Or return null if we have nothing to return, if we cannot load the assembly. PublicKeyToken should be the same, assemblies with different PublicKeyToken in no way are friends with each other.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8q/m7/ge/8qm7ge64h4pbldvju9ya91uz8zm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This event applies to only one application domain. </font><font style="vertical-align: inherit;">If our plugin creates an AppDomain inside itself, then this redirect in the runtime will not work in them. </font><font style="vertical-align: inherit;">You need to somehow subscribe to this event in all the AppDomain that the plugin created. </font><font style="vertical-align: inherit;">We can do this using the AppDomainManager. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AppDomainManager is a separate assembly that contains a class that implements a specific interface, and one of the methods of this interface will allow you to initialize any new AppDomain that is created in the application. </font><font style="vertical-align: inherit;">Once the AppDomain is created, this method will be called. </font><font style="vertical-align: inherit;">In it you can subscribe to this event.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strict assembly loading &amp; .NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In .NET Core there is no problem called ‚ÄúStrict assembly loading‚Äù, which is due to the fact that signed assemblies require exactly the version that was requested. There is another requirement. For all assemblies, regardless of whether they are signed by Strong name or not, it is checked that the version that was loaded in runtime is greater than or equal to the previous one. If we are in a situation of an application with plugins, we may have such a situation that the plugin was built, for example, from a new version of the SDK, and the application into which it is downloaded uses the old version of the SDK so far, and instead of falling apart, we can also subscribe to this event, but already in .NET Core, and also load the assembly that we have. We can write this code:</font></font><br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (s, eventArgs) =&gt; <font></font>
{ <font></font>
     CheckForRecursion(); <font></font>
     <span class="hljs-keyword">var</span> name = eventArgs.Name;
     <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
    <font></font>
     name.Version = <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <font></font>
     <font></font>
     <span class="hljs-keyword">return</span> Assembly.Load(name); <font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have the name of the assembly that did not boot, we nullify the version and call it </font></font><code>Assembly.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the same version. There will be no recursion here, because I already checked the recursion. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mt/cs/kr/mtcskrokxuvcn8i4gueywowb3_m.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It was necessary to download MyUtils version 0.0.2.0. In BIN, we have MyUtils version 0.0.1.0. We made a redirect from version 0.0.2.0 to version 0.0. Version 0.0.1.0 will not load with us. An exit will fly out for us that it was not possible to load the assembly with version 0.0.2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16‚Äì1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16‚Äì1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) == <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>) <font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Version</span> { 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Build; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Revision; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Major; 
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Minor; <font></font>
} <font></font>
(<span class="hljs-keyword">ushort</span>) <span class="hljs-number">-1</span> == <span class="hljs-number">65535</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the Version class, not all components are mandatory, and instead of optional components ‚Äì1 are stored, but somewhere inside, an overflow occurs, and the very 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16‚Äì1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are obtained </font><font style="vertical-align: inherit;">. If interested, you can try to find exactly where the overflow occurs. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m5/bl/vl/m5blvl8u1xrfdigr0ay45_ps3q8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you work with reflection assemblies and want to get all types, it may turn out that not all types can get your GetTypes method. An assembly has a class that inherits from another class that is in an assembly that is not loaded.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> IEnumerable <span class="hljs-title">GetTypesSafe</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Assembly assembly</span>)</span> <font></font>
{ <font></font>
    <span class="hljs-keyword">try</span> <font></font>
    { <font></font>
        <span class="hljs-keyword">return</span> assembly.GetTypes(); <font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span> (ReflectionTypeLoadException e) <font></font>
   { <font></font>
        <span class="hljs-keyword">return</span> e.Types.Where(x =&gt; x != <span class="hljs-literal">null</span>); <font></font>
    } <font></font>
}<font></font>
<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, the problem will be that a ReflectionTypeLoadException will be thrown. </font><font style="vertical-align: inherit;">Inside </font></font><code>ReflectionTypeLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there is a property in which there are those types that still managed to be loaded. </font><font style="vertical-align: inherit;">Not all popular libraries take this thing into account. </font><font style="vertical-align: inherit;">AutoMapper, at least one of its versions, if faced with ReflectionTypeLoadException, just fell, instead of going and picking the types from the inside of the exception.</font></font><a name="name"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strong naming</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strong-named assemblies</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Let's talk about what causes Strict assembly loading, this is Strong name. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Strong Name is the signature of the assembly by some private key using asymmetric encryption. PublicKeyToken is the public key hash of this assembly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Strong Naming allows you to distinguish between different assemblies that have the same name. For example, MyUtils is not some unique name, there may be several assemblies with that name, but if you sign Strong name, they will have different PublicKeyToken and we can distinguish them in this way. Strong name is required for some assembly loading scenarios.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, in order to install an assembly in the Global Assembly Cache or to download several versions of side-by-side at once. </font><font style="vertical-align: inherit;">Most importantly, strong named assemblies can only reference other strong named assemblies. </font><font style="vertical-align: inherit;">Since some users want to sign their builds with Strong name, the library developers also sign their libraries, so that it is easier for users to install them, so that users do not have to re-sign these libraries.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strong name: Legacy?</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strong naming and .NET libraries</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Microsoft explicitly says on MSDN that you should not use Strong name for security purposes, that they provide only to distinguish different assemblies with the same name. The assembly key cannot be changed in any way; if you changed it, then you will break redirects to all your users. If you have a private part of the key for Strong name leaked to public access, then you can‚Äôt withdraw this signature in any way. The SNK file format in which Strong name is located does not provide such an opportunity, and other formats for storing keys at least contain a link to the CRL Certificate Revocation List, by which it can be understood that this certificate is no longer valid. There is nothing like that in SNK.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Open-source guide has the following recommendations. Firstly, additionally for security purposes use other technologies. Secondly, if you have an open source library, it is generally suggested that you commit the private part of the key to the repository, so that it is easier for people to fork your library, rebuild it and put it in a ready-made application. Thirdly, never change Strong name. Too destructive. Despite the fact that it is too destructive and is written about it in the Open-source guide, Microsoft sometimes has problems with its own libraries.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ue/kg/l3/uekgl3iwrexq7ejjbabccq4y4p4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is a library called System.Reactive. </font><font style="vertical-align: inherit;">Previously, these were several NuGet packages, one of them is Rx-Linq. </font><font style="vertical-align: inherit;">This is just an example, the same for the rest of the packages. </font><font style="vertical-align: inherit;">In the second version, it was signed with a Microsoft key. </font><font style="vertical-align: inherit;">In the third version, he moved to the repository in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/dotnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> project </font><font style="vertical-align: inherit;">and began to have a .NET Foundation signature. </font><font style="vertical-align: inherit;">The library, in fact, has changed Strong name. </font><font style="vertical-align: inherit;">The NuGet package was renamed, but the assembly is called inside exactly the same as before. </font><font style="vertical-align: inherit;">How to redirect from the second version to the third? </font><font style="vertical-align: inherit;">This redirect can not be done.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strong name validation</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to: Disable strong name bypass feature</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another argument that Strong name is already something that is a thing of the past and remains purely formal is that they are not validated. We have a signed assembly and we want to fix some kind of bug in it, but we do not have access to the sources. We can just take dnSpy - this is a utility that allows you to decompile and fix already compiled assemblies. Everything will work for us. Because by default, Strong name validation bypass is enabled, that is, it only checks that the PublicKeyToken is equal, and the integrity of the signature itself is not checked. There may be environmental studies in which the signature is still verified, and here a vivid example is IIS. Signature integrity is checked on IIS (Strong name validation bypass is disabled by default), and everything will break if we edit the signed assembly. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addition:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can disable signature verification for the assembly using </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">public sign.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> With it, only the public key is used for signing, which ensures the safety of the assembly name. The public keys used by Microsoft are posted </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Rider, public sign can be enabled in the project properties. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vl/_j/ct/vl_jctjjgui-mbcgo5uyzd26lrc.png"><br>
<br>
<img src="https://habrastorage.org/webt/ni/if/hp/niifhpriuvymkfhz78sdeaigs54.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When to change fileassembly versions</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The open-source guide also offers some Versioning policy, the purpose of which is to reduce the number of necessary Binding redirects and changes to them for users on the NET Framework. This Versioning policy is that we should not change Assembly Version constantly. This, of course, can lead to problems with installation in the GAC, so that the installed native image may not correspond to the assembly and you will have to perform JIT compilation again, but, in my opinion, this is less evil than problems with versioning. In the case of CrossGen, native assemblies are not installed globally - there will be no problems.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, the NuGet package Newtonsoft.Json, it has several versions: 12.0.1, 12.0.2, and so on - all of these packages have an assembly with version 12.0.0.0. </font><font style="vertical-align: inherit;">The recommendation is that the Assembly Version should be updated when a major version of the NuGet package changes.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findings</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Follow the tips for the .NET Framework: generate redirects manually and try to use the same version of dependencies in all projects in your solution. </font><font style="vertical-align: inherit;">This should significantly minimize the number of redirects. </font><font style="vertical-align: inherit;">You need Strong naming only if you have a specific build loading scenario where it is needed, or you are developing a library and want to simplify the life for users who really need Strong naming. </font><font style="vertical-align: inherit;">Do not change Strong name.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Standard</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We pass to .NET Standard. It is pretty closely related to Version hell in the .NET Framework. .NET Standard is a tool for writing libraries that are compatible with various implementations of the .NET platform. Implementations refer to the .NET Framework, .NET Core, Mono, Unity, and Xamarin. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hk/-a/-u/hk-a-u16d-oitjurhvta7lhafdi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Link to documentation</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is the .NET Standard support table for various versions of different versions of runtimes. And here we can see that the .NET Framework in no way supports the .NET Standard version 2.1. The release of the .NET Framework, which will support the .NET Standard 2.1 and later, is not yet planned. If you are developing a library and want it to work for users on the .NET Framework, you will have to have a target for .NET Standard 2.0. Besides the fact that the .NET Framework does not support the latest version of the .NET Standard, let's pay attention to the asterisk. The .NET Framework 4.6.1 supports .NET Standard 2.0, but with an asterisk. There is such a footnote directly in the documentation, where did I get this table.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ay/mq/yu/aymqyunvnqjivv13dpqkrzvac6i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consider an example project. An application on the .NET Framework that has one dependency targeting the .NET Standard. Something like this: ConsoleApp and ClassLibrary. Target Library .NET Standard. When we put this project together, it will be like this in our BIN. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/62/og/fh62og_vou9gzibnv5gdd2mp_uk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will have a hundred DLLs there, of which only one related to the application, everything else came in order to support the .NET Standard. The fact is that .NET Standard 2.0 appeared later than the .NET Framework 4.6.1, but at the same time they turned out to be API compatible, and the developers decided to add Standard 2.0 support to .NET 4.6.1. We did it not natively (by inclusion </font></font><code>netstandard.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the runtime itself), but in such a way that .NET Standard * .dll and all other assembly facades are placed directly in BIN.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/af/15/am/af15amgkrw698xqylhfwemd67uy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we look at the dependencies of the version of the .NET Framework that we target and the number of libraries that fell into the BIN, we will see that there are not so many of them in 4.7.1, and since 4.7.2 there are no additional libraries at all, and .NET Standard is supported there natively. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rf/wu/va/rfwuvalfp3bi6zijyw5kjz-wjva.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a tweet from one of the .NET developers, which describes this problem and recommends using the .NET Framework version 4.7.2 if we have .NET Standard libraries. </font><font style="vertical-align: inherit;">Not even with version 2.0 here, but with version 1.5.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findings</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If possible, raise the Target Framework in your project to at least 4.7.1, preferably 4.7.2. </font><font style="vertical-align: inherit;">If you are developing a library to make life easier for library users, make a separate Target for the .NET Framework, it will avoid a huge number of dlls that can conflict with something.</font></font><a name="dotnet"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start with a general theory. </font><font style="vertical-align: inherit;">We will discuss how we launched JetBrains Rider on .NET Core, and why we should talk about it at all. </font><font style="vertical-align: inherit;">Rider is a very large project, it has a huge enterprise solution with a large number of different projects, a complex system of dependencies, you cannot just take it and migrate to another runtime at one time. </font><font style="vertical-align: inherit;">To do this, we have to use some hacks, which we will also analyze.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core application</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What does a typical .NET Core application look like? Depends on how exactly it is deployed, what it is ultimately going to. We can have several scenarios. The first is a Framework-dependent deployment. This is the same as in the .NET Framework when the application uses the runtime pre-installed on the computer. It can be a Self-contained deployment, this is when the application carries a runtime. And there may be a Single-file deployment, this is when we get one exe-file, but in the case of .NET Core inside this exe-file there is an artifact of Self-contained application, this is a self-extracting archive. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/yi/3c/hxyi3c3yxhavujn9ljcmtxkuvj0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will only consider Framework-dependent deployment. We have a dll with the application, there are two configuration files, the first of which is required, this </font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Starting with .NET Core 3.0, an exe file is generated that is needed to make the application more convenient to run, so that you do not need to enter the .NET command if we are on Windows. </font><font style="vertical-align: inherit;">Dependencies fall into this artifact, starting with .NET Core 3.0, in .NET Core 2.1 you need to publish or use another property in </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><a name="config"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shared frameworks, </font></font><code>.runtimeconfig.json</code></h3><br>
<br>
<img src="https://habrastorage.org/webt/cc/a5/ab/cca5ab5zhb3v6b1itc9jjbsiwje.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains the runtime settings that are needed to run it. It indicates under which Shared Framework the application will be launched, and it looks like this. We indicate that the application will run under ‚ÄúMicrosoft.NETCore.App‚Äù version 3.0.0, there may be other Shared Framework. Other settings may also be here. For example, you can enable the server Garbage collector. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c5/un/ic/c5unicttj2dp5ol0jiewknhb48i.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generated during the assembly of the project. And if we want to include the server GC, then we need to somehow modify this file in advance, even before we assemble the project, or add it by hand. You can add your settings here like this. We can either include property in </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, if such property is provided by .NET developers, or if property is not provided, we can create a file called</font></font><code>runtimeconfig.template.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and write the necessary settings here. During assembly, other necessary settings will be added to this template, for example, the same Shared Framework. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/bu/e9/rlbue9y7cikkyzwenefcu2rdxy8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Shared Framework is a set of runtime and libraries. In fact, the same thing as the .NET Framework runtime, which used to be just installed once on the machine and for all was one version. Shared Framework, and, unlike a single .NET Framework runtime, can be versioned, different applications can use different versions of installed runtimes. Also Shared Framework can be inherited. The Shared Framework itself can be viewed in such locations on the disk as are generally installed on the system.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nc/df/7i/ncdf7ioj8afrolkvnlouh77jiaq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are several standard Shared Framework, for example, Microsoft.NETCore.App, which runs conventional console applications, AspNetCore.App, for web applications, and WindowsDesktop.App, the new Shared Framework in .NET Core 3, which runs desktop applications. on Windows Forms and WPF. The last two Shared Framework essentially complement the first one needed for console applications, that is, they do not carry a whole new runtime, but simply supplement the existing one with the necessary libraries. This inheritance looks like there are also in the Shared Framework directories </font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in which the base Shared Framework is specified.</font></font><a name="man"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dependency manifest ( </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/sc/qv/qbscqv1sh6jb_r19ps_qrusogfi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Default probing - .NET Core The</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
second configuration file is this </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This file contains a description of all the dependencies of the application or the Shared Framework, or the library, the libraries </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also have it. It contains all the dependencies, including transitive ones. And the behavior of the .NET Core runtime differs depending on whether </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the application has it or not. If </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not, the application will be able to load all the assemblies that are in its Shared Framework or in its BIN directory. If there </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is, then validation is enabled. If one of the assemblies that is listed in </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is not, then the application simply will not start. You will see the error presented above. If the application tries to load some assembly in runtime, which</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if, for example, using Assembly load methods or during the resolve process of assemblies, you will see an error very similar to Strict assembly loading.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetbrains rider</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rider is a .NET IDE. Not everyone knows that Rider is an IDE consisting of a frontend based on IntelliJ IDEA and written in Java and Kotlin, and a backend. The backend is essentially R #, which can communicate with IntelliJ IDEA. This backend is a cross-platform .NET application now. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Where does it run? Windows uses the .NET Framework, which is installed on the user's computer. On other information systems, on Linux and Mac, Mono is used. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is not an ideal solution when there are different runtimes everywhere, and I want to come to the next state so that Rider runs on .NET Core. In order to improve performance, because in .NET Core all the latest features are associated with this. To reduce memory consumption. Now there is a problem with how Mono works with memory.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Switching to .NET Core will allow you to abandon legacy, unsupported technologies and allow to fix some fixes for the problems that were found in runtime. </font><font style="vertical-align: inherit;">Switching to .NET Core will allow you to control the version of the runtime, that is, Rider will no longer run on the .NET Framework that is installed on the user's computer, but on a specific version of .NET Core, which can be banned, as a self-contained deployment. </font><font style="vertical-align: inherit;">The transition to .NET Core will eventually allow the use of new APIs that are imported specifically in Core. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now the goal is to launch a prototype, launch it, just to check how it will work, what are the potential points of failure, which components will have to be rewritten again, which will require global processing.</font></font><br>
<br>
<a name="rider"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Features that make translating Rider to .NET Core difficult</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visual Studio, even if R # is not installed in it, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crashes from Out Of Memory on large solutions, inside which there are projects with SDK-style * .csproj</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">SDK-style * .csproj is one of the main conditions for a full .NET Core relocation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a problem because Rider is based on R #, they live in the same repository, R # developers want to use Visual Studio to develop their own product in their product in order to make it food. </font><font style="vertical-align: inherit;">In R # there are links specific libraries for the framework with which you need to do something. </font><font style="vertical-align: inherit;">On Windows, we can use the Framework for desktop applications, and on Linux and Mac, Mock is already used for Windows libraries with minimal functionality.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decision</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We decided to stay on the old ones for now </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, assemble under the full Framework, but since the assemblies of the Framework and Core are binary compatible, run them on Core. </font><font style="vertical-align: inherit;">We do not use incompatible features, add all the necessary configuration files manually and download special versions of dependencies for .NET Core, if any.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What hacks did you have to go to?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One hack: we want to call a method that is available only in the Framework, for example, this method is needed in R #, but not on Core. </font><font style="vertical-align: inherit;">The problem is that if there is no method, then the method that calls it during JIT compilation will fall earlier </font></font><code>MissingMethodException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">That is, a method that does not exist has ruined the method that calls it.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>(<span class="hljs-params"></span>)</span> { 
  <span class="hljs-keyword">if</span> (NetFramework) <font></font>
     CallNETFrameworkOnlyMethod();<font></font>
<font></font>
  ... <font></font>
} <font></font>
[<span class="hljs-meta">MethodImpl(MethodImplOptions.NoInlining)</span>] 
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallNETFrameworkOnlyMethod</span>(<span class="hljs-params"></span>)</span> { <font></font>
  NETFrameworkOnlyMethod(); <font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The solution is here: we make calls to incompatible methods into separate methods. There is one more problem: such a method may become inline, therefore we mark it with an attribute </font></font><code>NoInlining</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hack number two: we need to be able to load assemblies in relative paths. We have one assembly for the Framework, there is a special version for .NET Core. How do we download the .NET Core version for .NET Core? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qm/zm/w7/qmzmw79gtllee8uyswgrn0oqnum.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
They will help us </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Let's look at </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the System.Diagnostics.PerformanceCounter library. Such a library is remarkable in terms of its</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It has a runtime section, in which one version of the library with its relative path is indicated. This library, the assembly will be loaded on all runtimes, and it just throws the executions. If, for example, it loads on Linux, the PerformanceCounter does not work on design on Linux, and a PlatformNotSupportedException flies from there. There is also </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a runtimeTargets section </font><font style="vertical-align: inherit;">in this </font><font style="vertical-align: inherit;">and here is already indicated the version of this assembly specifically for Windows, where PerformanceCounter should work.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we take the runtime section and write in it the relative path to the library we want to load, this will not help us. The runtime section actually sets the relative path inside the NuGet package, and not relative to the BIN. If we look for this assembly in BIN, only the file name will be used from there. The runtimeTargets section already contains an honest relative path, an honest path relative to BIN. We will prescribe a relative path for our assemblies in the runtimeTargets section. Instead of the runtime identifier, which is ‚Äúwin‚Äù here, we can take another that we like. For example, we will write the runtime identifier ‚Äúany‚Äù, and this assembly will be loaded generally on all platforms. Or we will write ‚Äúunix‚Äù, and it will boot on Linux, and on Mac, and so on.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next hack: we want to download on Linux and on Mac Mock to build WindowsBase. The problem is that the assembly named WindowsBase is already present in the Shared Framework </font></font><code>Microsoft.NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, even if we are not on Windows. On the Windows Shared Framework, </font></font><code>Microsoft.WindowsDesktop.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowsBase redefines the version that is in </font></font><code>NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Let's look at </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">these Framework, more precisely at those sections that describe WindowsBase. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gc/ox/f3/gcoxf3q7mbfm_a9hzmcujfin5zc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is the difference: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5q/pz/wq/5qpzwq-n21m38b_0xedi9txpwoc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If some library conflicts and is present in several </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then the maximum of them is selected for the pair consisting of </font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The .NET guide says that </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it‚Äôs only needed to show it in Windows Explorer, but it‚Äôs not, it falls into</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This is the only case that I know of when the version prescribed in </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, are actually used. In all other cases, I saw a behavior that no matter what versions </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">were written in, the assembly would continue to load anyway. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/re/j8/bwrej8fa8_gyuyvcjnt3ixvljce.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fourth hack. Task: we have a .deps.json file for the previous two hacks, and we need it only for specific dependencies. Since they are </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generated in semi-manual mode, we have a script that, according to some description of what should get there, generates it during the build, we want to keep this as </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimal as possible so that we can understand what is in it. We want to disable validation and allow the download of assemblies that are in the BIN but are not described in </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solution: enable custom configuration in runtimeconfig. </font><font style="vertical-align: inherit;">This setting is actually needed for backward compatibility with .NET Core 1.0.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findings</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, </font></font><code>.runtime.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on .NET Core - these are kind of analogues </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">let you do the same things, for example, load assemblies in relative ways. </font><font style="vertical-align: inherit;">Using </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, rewriting it manually, you can customize the loading of assemblies on .NET Core, if you have a very complex scenario.</font></font><a name="load"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug assembly downloads</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I talked about some types of problems, so you need to be able to debug problems with loading assemblies. </font><font style="vertical-align: inherit;">What can help with this? </font><font style="vertical-align: inherit;">First, runtimes write logs about how they load assemblies. </font><font style="vertical-align: inherit;">Secondly, you can look more closely at the executions that fly to you. </font><font style="vertical-align: inherit;">You can also focus on runtime events.</font></font><a name="fusion"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusion logs</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/jl/4v/be/jl4vbeqsyjzmab2rx0xvdg-lpi4.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Back to Basics: Using Fusion Log Viewer To Debug Obscure Errors </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusion</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
The mechanism for loading assemblies in the .NET Framework is called Fusion, and it knows how to log what it did to the disk. To enable logging, you need to add special settings to the registry. This is not very convenient, so it makes sense to use utilities, namely Fusion Log Viewer and Fusion ++. Fusion Log Viewer is a standard utility that comes with Visual Studio and can be launched from the Visual Studio command line, Visual Studio Developer Command Prompt. Fusion ++ is an open source analogue of this tool with a nicer interface.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ou/9h/bt/ou9hbtdgx1yjp6rjjdm3q61efpu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fusion Log Viewer looks like this. This is worse than WinDbg because this window does not even stretch. Nevertheless, you can pierce the checkmarks here, although it is not always obvious which set of checkmarks is correct. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gu/h2/by/guh2byfmgazm8yvbxfa_jhf25wo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fusion ++ has one ‚ÄúStart Logging‚Äù button, and then the ‚ÄúStop Logging‚Äù button appears. In it, you can see all the records about loading assemblies, read the logs about what exactly was happening. These logs look something like this in a concise way.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zf/ep/5m/zfep5myuovdov4t7mmtw4czhwqc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is an exemption from Strict assembly loading. </font><font style="vertical-align: inherit;">If we look at the Fusion logs, we will see that we needed to download version 9.0.0.0 after we processed all the configs. </font><font style="vertical-align: inherit;">We found a file in which it is suspected that we have the assembly we need. </font><font style="vertical-align: inherit;">We saw that version 6.0.0.0 is in this file. </font><font style="vertical-align: inherit;">We have a warning that we compared the full names of the assemblies, and they differ in the major version. </font><font style="vertical-align: inherit;">And then an error occurred - version mismatch.</font></font><a name="events"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Runtime events</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/pu/np/bn/punpbnrdvfv_mm5bpweej75ofq8.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logging Runtime Events</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
On Mono, you can enable logging using environment variables, and the logs will eventually be written to </font></font><code>stdout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Not so convenient, but the solution is working. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rj/vv/g9/rjvvg9dfv0ji5sbxm_crgu3ok0a.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Default probing - .NET Core </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation / design docs / host tracing</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
. .NET Core also has a special environment variable </font></font><code>COREHOST_TRACE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that includes logging in </font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. With .NET Core 3.0, you can write logs to a file by specifying the path to it in a variable </font></font><code>COREHOST_TRACEFILE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<img src="https://habrastorage.org/webt/eo/b5/yf/eob5yf90z7cgilees68uxtrhw0w.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is an event that fires when the assemblies fail to load. This is an event </font></font><code>AssembleResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. There is a second useful event, this </font></font><code>FirstChanceException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. You can subscribe to it and get an error about loading assemblies, even if someone wrote try..catch and missed all the executions in the place where</font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">occurred. </font><font style="vertical-align: inherit;">If the application has already been compiled, you can start it </font></font><code>perfview</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and it can monitor .NET executions, and there you can find those related to download files.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findings</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transfer work to tools, to development tools, to an IDE, to MSBuild, which allows you to generate redirects. </font><font style="vertical-align: inherit;">You can switch to .NET Core, then you will forget what Strict Assembly Loading is, and you will be able to use the new API just like we want to achieve it in Rider. </font><font style="vertical-align: inherit;">If you connect the .NET Standard library, then raise the target version of the .NET Framework to at least 4.7.1. </font><font style="vertical-align: inherit;">If you seem to be in a hopeless situation, then look for hacks, use them, or come up with your own hacks for hopeless situations. </font><font style="vertical-align: inherit;">And arm yourself with debugging tools. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I strongly recommend that you read the following links:</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">.NET Guide</a>;</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">     .NET Core</a>.</li>
</ul><br>
<br>
<blockquote>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">DotNext 2020 Piter</a> .       ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="> 8   JUG Ru Group</a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en499824/index.html">The digest of events for HR and IT recruiters in May 2020</a></li>
<li><a href="../en499826/index.html">Distributed blood pressure</a></li>
<li><a href="../en499832/index.html">How to quickly and safely organize the remote work of employees? We talk about different approaches: with VDI and not only</a></li>
<li><a href="../en499834/index.html">Meet the Felix Arithmometer</a></li>
<li><a href="../en499836/index.html">Udalenka vs. office for the development team</a></li>
<li><a href="../en499842/index.html">Why do people relearn</a></li>
<li><a href="../en499846/index.html">When separate garbage collection will start working and why video monitoring of sites for garbage containers is needed</a></li>
<li><a href="../en499850/index.html">How to analyze competitors and set up a digital strategy in 40 minutes</a></li>
<li><a href="../en499852/index.html">English-language documentation for Angular</a></li>
<li><a href="../en499854/index.html">Apache Bigtop and the choice of Hadoop distribution today</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>