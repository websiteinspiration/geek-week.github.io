<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚩 ⚰️ 👨🏿 木に登る方法 🕊️ 🤾🏿 💬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="より正確には、それから降りる方法。しかし、まず最初に。この記事は、PVS-Studioの通常の記事形式とは少し異なります。私たちはしばしば他のプロジェクトのチェックについて書いていますが、内部のキッチンへの扉を開くことはほとんどありません。それを修正して、アナライザーが内部からどのように構築されるか...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>木に登る方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/502518/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/qf/qz/ys/qfqzys_fndtbks6hb68atbrnyrq.png" alt="写真2"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より正確には、それから降りる方法。</font><font style="vertical-align: inherit;">しかし、まず最初に。</font><font style="vertical-align: inherit;">この記事は、PVS-Studioの通常の記事形式とは少し異なります。</font><font style="vertical-align: inherit;">私たちはしばしば他のプロジェクトのチェックについて書いていますが、内部のキッチンへの扉を開くことはほとんどありません。</font><font style="vertical-align: inherit;">それを修正して、アナライザーが内部からどのように構築されるかについて話します。</font><font style="vertical-align: inherit;">より正確には、最も重要な部分-構文ツリーについて。</font><font style="vertical-align: inherit;">この記事では、CおよびC ++言語に関連するPVS-Studioの部分に焦点を当てます。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まず最初に</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構文ツリーは、コンパイラーの中心部分です。いずれにしても、コードはプログラム処理に便利な形式で提示する必要があり、たまたまツリー構造がこれに最適です。ここでは理論を掘り下げません。ツリーはコード内の式とブロックの階層を非常によく反映していると同時に、作業に必要なデータのみを含んでいると言えば十分でしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーは静的アナライザーとどのような関係がありますか？実際、これら2つのツールには多くの共通点があります。コードを解析する最初の段階で、彼らは同じ仕事をします。最初に、コードはトークンのストリームに分割され、パーサーに送られます。次に、構文解析と意味解析のプロセスで、トークンがツリーに編成され、パイプラインに沿ってさらに送信されます。この段階で、コンパイラーはバイナリー・コードを生成する前に中間最適化を実行でき、静的アナライザーはノードをバイパスしてさまざまなチェックを開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツリーが構築されたPVS-Studioアナライザーでは、いくつかのことが起こります。</font></font><br>
<br>
<ul>
<li>    .    , , ,     <i>using </i>  <i>typedef</i>,   . ,  .         ;</li>
<li>     .  ,          ;</li>
<li>   ,      ,    ,      ;</li>
<li>  .        (      ).          . ,         <i>nullptr</i>    ,    ,         .       ;</li>
<li>  .      ,      .        ,    .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分析のしくみの詳細に興味がある場合は、記事「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studioコードアナライザーでエラーと潜在的な脆弱性を見つけるために使用される技術</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」を読むことをお勧めし</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">リストのいくつかのポイントが詳細に検討されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アナライザー内のツリーに何が起こるか、そしてツリーがどのように見えるかをさらに詳しく見ていきます。</font><font style="vertical-align: inherit;">簡単な紹介を終えて、問題の根底に入る時が来ました。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/si/xk/o4/sixko4j1_uucanebxzup6slqpf8.png" alt="写真1"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使い方</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
歴史的に、PVS-Studioはバイナリツリーを使用してコードを表します。この古典的なデータ構造は誰にでもおなじみです。通常、2つの子を参照するノードがあります。子孫を持つことが想定されていないノード、私はターミナル、その他すべて-非ターミナルを呼び出します。非ターミナルには子ノードがない場合がありますが、ターミナルとの主な違いは、子孫が基本的に許可されていることです。ターミナルノード（またはリーフ）には、親以外のものを参照する機能がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-Studioで使用される構造は、従来のバイナリツリーとは少し異なります。これは、便宜上必要です。</font><font style="vertical-align: inherit;">ターミナルノードは通常、キーワード、変数名、リテラルなどに対応します。</font><font style="vertical-align: inherit;">非終端記号-さまざまなタイプの式、コードのブロック、リストなど、ツリーの構成要素。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーの観点から見ると、ここではすべてがかなり標準的です。私は、ジャンルの古典- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドラゴンブックに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">興味があるすべての人にアドバイスします</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは前進しています。</font><font style="vertical-align: inherit;">簡単なコード例と、アナライザーがそれをどのように認識するかを見てみましょう。</font><font style="vertical-align: inherit;">さらに、内部のツリー視覚化ユーティリティからの多くの写真があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、例：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span>
</span>{
  <span class="hljs-keyword">return</span> a + b;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーサーによる処理後のこの単純な関数は、次のようになります（非終端ノードは黄色で強調表示されます）。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/eo/nj/od/eonjodrufyrv6p3w2riiysnfnpo.png" alt="写真6"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この見解には長所と短所があり、後者は、私の意見ではもう少しです。しかし、ツリーを見てみましょう。たとえば、句読点と括弧が含まれているため、多少冗長であることがすぐにわかります。コンパイルの観点からは、これは不要なゴミですが、一部の診断ルールではアナライザーがそのような情報を必要とする場合があります。つまり、アナライザーは抽象構文ツリー（AST）では機能せず</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、解析ツリー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（DT）で機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
木は左から右へ、上から下へと成長します。左の子ノードには、常に宣言子などの意味のあるものが含まれます。右を見ると、</font><i><font style="vertical-align: inherit;">NonLeaf</font></i><font style="vertical-align: inherit;">という単語でマークされた中間の非ターミナルが表示され</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それらは、ツリーがその構造を保持するためにのみ必要です。</font><font style="vertical-align: inherit;">分析の必要性のために、そのようなノードは情報の負荷を運びません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツリーの左側に注目します。</font><font style="vertical-align: inherit;">ここでそれはより大きなクローズアップです：</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/vf/gm/ku/vfgmku_i7oq4oakzu_2gnowmfk8.png" alt="写真10"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この広告は機能します。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeDeclarator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">親ノード</font><font style="vertical-align: inherit;">は、関数の名前とそのパラメーターを使用してノードにアクセスできるオブジェクトです。</font><font style="vertical-align: inherit;">また、型システムのエンコードされた署名も格納されます。</font><font style="vertical-align: inherit;">この図はかなり視覚的であり、ツリーの要素をコードと比較するのは非常に簡単なようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単そうに見えますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
わかりやすくするために、より簡単な例を見てみましょう。</font><font style="vertical-align: inherit;">関数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を呼び出すコードがあるとします</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">f(<span class="hljs-number">42</span>, <span class="hljs-number">23</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツリーの関数呼び出しは次のようになります。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/mf/jx/r2/mfjxr27uqexjmd3olssajdys7lw.png" alt="写真12"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
構造は非常に似ていますが、ここでは宣言の代わりに関数呼び出しが表示されています。ここで、すべての引数を調べて、それぞれに対して何かを実行したいとします。これは、アナライザーコードでよく見られる実際のタスクです。すべてが引数に限定されず、さまざまなタイプのノードをソートする必要があることは明らかですが、ここではこの特定の例を検討します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
親の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FUNCALL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノードへのポインターしかないとします</font><font style="vertical-align: inherit;">。非ターミナルから、左と右の子ノードを取得できます。それぞれのタイプはわかっています。ツリーの構造がわかっているので、引数のリストが置かれているノードにすぐに到達できます。これは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NonLeafであり</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ここからターミナルが画像</font><i><font style="vertical-align: inherit;">42で</font></i><font style="vertical-align: inherit;">成長します。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">引数の数は事前にわからないため、リストにはカンマが含まれているため、この場合はまったく関係ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これをどのように行いますか？</font><font style="vertical-align: inherit;">読む。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自転車工場</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツリーを反復するのは非常に簡単なようです。これを行う関数を作成して、どこでも使用するだけです。各要素を処理するための引数としてラムダを渡すことができます。ほんの少しのニュアンスではないにしても、そうでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、毎回木を回るのは少し異なる必要があります。各ノードを処理するロジックと、リスト全体を操作するロジックは異なります。たとえば、あるケースでは、リスト引数を調べて、それぞれを特定の関数に渡して処理したいとします。別の例では、いくつかの要件を満たす1つの引数を選択して返します。または、リストをフィルタリングして、興味のない要素をリストから破棄します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、現在の要素のインデックスを知る必要がある場合があります。</font><font style="vertical-align: inherit;">たとえば、最初の2つの引数のみを処理して停止したいとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第3に、関数の例から少し離れましょう。</font><font style="vertical-align: inherit;">次のようなコードがあるとします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span>
</span>{
  <span class="hljs-keyword">int</span> c = a + b;<font></font>
  c *= <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">42</span>) <span class="hljs-keyword">return</span> c;
  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは馬鹿げていると思いますが、ツリーの外観に集中しましょう。</font><font style="vertical-align: inherit;">すでに関数宣言を見てきましたが、ここではその本体が必要です。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/f0/q6/hs/f0q6hsldd42blwuenxmv2t6vl7o.png" alt="写真4"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このケースは引数のリストのようなものですが、いくつかの違いに気付くかもしれません。</font><font style="vertical-align: inherit;">前のセクションの写真をもう一度見てください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
気づいてますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そうです、このリストにはコンマがありません。つまり、コンマを続けて処理でき、セパレーターのスキップを心配する必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
合計すると、少なくとも2つのケースがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">区切られたリスト。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全なリスト。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、これがアナライザーコードでどのように行われるかを見てみましょう。次に、引数のリストをトラバースする例を示します。これは、トランスレータの機能の1つを簡略化したバージョンです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessArguments</span><span class="hljs-params">(Ptree* arglist)</span>
</span>{
  <span class="hljs-keyword">if</span> (!arglist) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  Ptree* args = Second(arglist);<font></font>
  <span class="hljs-keyword">while</span> (args)<font></font>
  {<font></font>
    Ptree* p = args-&gt;Car();<font></font>
    <span class="hljs-keyword">if</span> (!Eq(p, <span class="hljs-string">','</span>))<font></font>
    {<font></font>
      ProcessArg(p);<font></font>
    }<font></font>
<font></font>
    args = args-&gt;Cdr();<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じようなコードを見るたびに1ドルも支払われたら、もう金持ちになるでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで何が起こるか見てみましょう。これは、より最近の標準は言うまでもなく、C ++ 11よりもずっと前に書かれた非常に古いコードであることをすぐに言わなければなりません。特に古代文明の時代の断片を探したと言えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、最初に、この関数は括弧内の引数のリストを入力として受け入れます。次のようなものです：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（42、23）</font><i><font style="vertical-align: inherit;">2番目の</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
関数</font><font style="vertical-align: inherit;">は、括弧の内容を取得するためにここで呼び出されます。彼女が行うことは、バイナリツリーを右に1回、次に左に1回移動することだけです。次に、ループは次の要素を順番に取得します：42、次にカンマ、次に23、そして次のステップで</font><i><font style="vertical-align: inherit;">args</font></i><font style="vertical-align: inherit;">ポインター</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブランチの終わりに到達したため、ゼロになります。もちろん、ループは、興味のないコンマをスキップします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロジックがわずかに変更された同様の関数は、多くの場所、特に古いコードにあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一つの例。特定のコードブロックで特定の関数の呼び出しがあるかどうかを確認するにはどうすればよいですか？そのように：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsFunctionCalled</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* body, <span class="hljs-built_in">std</span>::string_view name)</span>
</span>{
  <span class="hljs-keyword">if</span> (!arglist) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  <span class="hljs-keyword">const</span> Ptree* statements = body;
  <span class="hljs-keyword">while</span> (statements)<font></font>
  {<font></font>
    <span class="hljs-keyword">const</span> Ptree* cur = statements-&gt;Car();
    <span class="hljs-keyword">if</span> (IsA(cur, ntExprStatement) &amp;&amp; IsA(cur-&gt;Car(), ntFuncallExpr))<font></font>
    {<font></font>
      <span class="hljs-keyword">const</span> Ptree* funcName = First(cur-&gt;Car());
      <span class="hljs-keyword">if</span> (Eq(funcName, name))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
<font></font>
    statements = statements-&gt;Cdr();<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意。</font><font style="vertical-align: inherit;">注意深い読者は気づくかもしれません。</font><font style="vertical-align: inherit;">彼は何歳？</font><font style="vertical-align: inherit;">そこ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はstd :: string_view</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スティックをアウト。</font><font style="vertical-align: inherit;">すべてが単純です。最も古いコードでさえ徐々にリファクタリングされ、徐々にそのようなものは残りません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでもっとエレガントなものを使うといいでしょう？</font><font style="vertical-align: inherit;">たとえば、標準の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_if</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズム</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">そこでのアルゴリズムは何ですか？通常の範囲ベースのforでも可読性が大幅に向上し、そのようなコードのサポートが容易になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを達成してみましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">木を箱に入れます</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの目標は、ツリーをSTLコンテナーのように動作させることです。</font><font style="vertical-align: inherit;">さらに、リストの内部構造を気にする必要はありません。たとえば、次のようにノードを均一に反復処理します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoSomethingWithTree</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* tree)</span>
</span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cur : someTreeContainer)<font></font>
  {<font></font>
    ....<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、ここには</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">someTreeContainer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれる特定のエンティティが</font><font style="vertical-align: inherit;">あります。</font><font style="vertical-align: inherit;">このようなコンテナには、少なくとも</font><font style="vertical-align: inherit;">イテレータを返す</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">begin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">end</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">必要</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">イテレータと言えば、イテレータも標準的なものと同じように動作するはずです。</font><font style="vertical-align: inherit;">それらから始めましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も単純なケースでは、イテレータは次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t,
          <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt;&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeIterator</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> value_type = Node_t;
  <span class="hljs-keyword">using</span> dereference_type = value_type;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer   = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
    <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  ....<font></font>
<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    m_node = Rest(m_node);<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;dereference_type&gt;(First(m_node));<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードが乱雑にならないように、一部の詳細を削除しました。</font><font style="vertical-align: inherit;">ここでの重要なポイントは、逆参照と増分です。</font><font style="vertical-align: inherit;">イテレーターが定数データと非定数データの両方を処理できるように、テンプレートが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ツリーノードを配置するコンテナーを作成します。</font><font style="vertical-align: inherit;">最も簡単なオプションは次のとおりです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeContainer</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = PtreeIterator&lt;Node_t&gt;;
  <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> Iterator::dereference_type;
  <span class="hljs-keyword">using</span> size_type  = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">typename</span> Iterator::difference_type;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeContainer(Node_t* nodes) :<font></font>
    m_nodes{ nodes }<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (IsLeaf(m_nodes))<font></font>
    {<font></font>
      m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  ....<font></font>
<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> begin() == end();<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたの注意をありがとう、私たちは終わりました、私たちは解散することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いいえ、しばらくお待ちください。</font><font style="vertical-align: inherit;">それはそんなに簡単なことではありませんよね？</font><font style="vertical-align: inherit;">デリミタ付きとデリミタなしの2つのリストオプションに戻りましょう。</font><font style="vertical-align: inherit;">ここで、インクリメントするときは、ツリーの正しいノードを取得するだけなので、問題は解決しません。</font><font style="vertical-align: inherit;">データのみを処理する場合は、コンマをスキップする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題ありません。追加のテンプレートパラメータをイテレータに追加するだけです。</font><font style="vertical-align: inherit;">次のように言ってみましょう：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeIteratorTag</span> :</span> <span class="hljs-keyword">uint8_t</span><font></font>
{<font></font>
  Statement,<font></font>
  List<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, PtreeIteratorTag tag,
  <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt; = <span class="hljs-number">0</span>&gt;<font></font>
class PtreeIterator { .... };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはどのように役立ちますか？</font><font style="vertical-align: inherit;">小学校。</font><font style="vertical-align: inherit;">このパラメータを段階的にチェックし、それに応じて動作します。</font><font style="vertical-align: inherit;">幸い、C ++ 17では、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if constexpr構文</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して、コンパイル段階でこれを解決できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">PtreeIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
{<font></font>
  <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
  </span>{<font></font>
    m_node = Rest(m_node);<font></font>
  }<font></font>
  <span class="hljs-keyword">else</span><font></font>
  {<font></font>
    m_node = RestRest(m_node);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはより良いです、今、私たちは私たちのニーズに合うようにイテレータを選ぶことができます。</font><font style="vertical-align: inherit;">コンテナをどうするか </font><font style="vertical-align: inherit;">たとえば、次のようにできます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, PtreeIteratorTag tag&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeContainer</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = PtreeIterator&lt;Node_t, tag&gt;;<font></font>
  ....<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、私たちは間違いなく終わっていますか？</font><font style="vertical-align: inherit;">実際、そうではありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、それだけではありません</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードを見てみましょう：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(Ptree* argList, Ptree* enumPtree)</span>
</span>{
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">ptrdiff_t</span> argListLen = Length(argList);
  <span class="hljs-keyword">if</span> (argListLen &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">ptrdiff_t</span> i = <span class="hljs-number">0</span>; i &lt; argListLen; ++i)<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<font></font>
    Ptree* elem;<font></font>
<font></font>
    <span class="hljs-keyword">const</span> EGetEnumElement r = GetEnumElementInfo(enumPtree, i, elem, name);<font></font>
    ....<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードはあまり好きではありません。カウンターから始まるループから始まり、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetEnumElementInfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">が非常に疑わしく見える</font><font style="vertical-align: inherit;">という事実で</font><i><font style="vertical-align: inherit;">終わり</font></i><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これでブラックボックスのままですが、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素</font><font style="vertical-align: inherit;">をインデックスで</font><font style="vertical-align: inherit;">取り出し、</font><font style="vertical-align: inherit;">その名前とノードを出力パラメーターを通じてツリーに返す</font><font style="vertical-align: inherit;">と想定でき</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">戻り値も少し奇妙です。</font><font style="vertical-align: inherit;">それを完全に削除しましょう-リスト反復子の理想的な仕事：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem : PtreeContainer&lt;<span class="hljs-keyword">const</span> Ptree, PtreeIteratorTag::List&gt;(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
悪くない。</font><font style="vertical-align: inherit;">このコードだけはコンパイルされません。</font><font style="vertical-align: inherit;">どうして？</font><font style="vertical-align: inherit;">削除したインデックスは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetEnumElementInfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の呼び出しの下のループの本体で使用されたため</font><i><font style="vertical-align: inherit;">です</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ここでは重要ではないので、それがどのように使用されたかを正確にここでは述べません。</font><font style="vertical-align: inherit;">インデックスが必要であると言えば十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、変数を追加して、美しいコードを台無しにしましょう。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem : PtreeContainer&lt;<span class="hljs-keyword">const</span> Ptree, PtreeIteratorTag::List&gt;(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
    UseIndexSomehow(i++);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まだ機能するオプションですが、私は個人的に次のようなことに反応します：</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ov/11/ie/ov11ieyylfaa2qjppdyjjo-yljy.png" alt="写真7"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、この問題を解決してみましょう。</font><font style="vertical-align: inherit;">要素を自動的にカウントできるものが必要です。</font><font style="vertical-align: inherit;">カウンター付きのイテレーターを追加します。</font><font style="vertical-align: inherit;">簡潔にするために、追加の詳細は再度スキップしました。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, PtreeIteratorTag tag,
  <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt;&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeCountingIterator</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> value_type = Node_t;
  <span class="hljs-keyword">using</span> dereference_type = <span class="hljs-built_in">std</span>::pair&lt;value_type, size_type&gt;;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeCountingIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  ....<font></font>
<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
    </span>{<font></font>
      m_node = Rest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
      m_node = RestRest(m_node);<font></font>
    }<font></font>
<font></font>
    ++m_counter;<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> { <span class="hljs-keyword">static_cast</span>&lt;value_type&gt;(First(m_node)), counter() };<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
  size_type m_counter = <span class="hljs-number">0</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、そのようなコードを書くことができますよね？</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [elem, i] :<font></font>
            PtreeCountedContainer&lt;<span class="hljs-keyword">const</span> Ptree, PtreeIteratorTag::List&gt;(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
    UseIndexSomehow(i);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的には本当に可能ですが、問題が1つあります。</font><font style="vertical-align: inherit;">このコードを見ると、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeCountedContainer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という名前の別のエンティティが導入されていることが</font><i><font style="vertical-align: inherit;">わかり</font></i><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">状況は複雑化しているようです。</font><font style="vertical-align: inherit;">私は実際にはさまざまな種類のコンテナを操作したくありません。それらが同じ内部であることを考えると、手自体がOccamのかみそりに届きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナのテンプレートパラメータとしてイテレータを使用する必要がありますが、これについては後で詳しく説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動物園のタイプ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カウンターやさまざまなイテレーターから1分間注意をそらしてください。</font><font style="vertical-align: inherit;">ノードのユニバーサルバイパスを追求して、最も重要なこと、つまりツリー自体を忘れていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードを見てください：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> a, b, c = <span class="hljs-number">0</span>, d;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツリーに表示されるもの：</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/mi/cq/sh/micqshmftdnb7xstjo71sng02s4.png" alt="写真13"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、宣言子のリストを繰り返しましょう。最初に、ツリーについて別のことをお話します。</font><font style="vertical-align: inherit;">それ以前は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ptree</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスへのポインタを扱っていました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、他のすべてのタイプのノードが継承される基本クラスです。</font><font style="vertical-align: inherit;">それらのインターフェースを通じて、追加情報を取得できます。</font><font style="vertical-align: inherit;">特に、図の一番上のノードは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Second</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などのユーティリティ関数を使用せずに、宣言子のリストを返すことができ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">また、低レベルのメソッド</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Car</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cdr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Lisp言語のファンの皆さん）</font><font style="vertical-align: inherit;">は必要ありません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">診断ではツリーの実装を無視できるため、これは非常に優れています。</font><font style="vertical-align: inherit;">現在の抽象化が非常に悪いことに誰もが同意していると思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての宣言子のバイパスは次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDecl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclarator* decl)</span> </span>{ .... }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDeclarators</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclaration* declaration)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> decl : declaration-&gt;GetDeclarators())<font></font>
  {<font></font>
    ProcessDecl(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> PtreeDeclarator*&gt;(decl));<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetDeclarators</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
メソッド</font><font style="vertical-align: inherit;">は、</font><i><font style="vertical-align: inherit;">反復可能な</font></i><font style="vertical-align: inherit;">コンテナを返します。</font><font style="vertical-align: inherit;">この場合の型は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeContainer &lt;const Ptree、PtreeIteratorTag :: List&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードを使用すると、キャストにとっては問題ないとしても、すべてうまくいきます。</font><font style="vertical-align: inherit;">実際、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessDecl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ptree</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から派生したクラスへのポインターを</font><i><font style="vertical-align: inherit;">必要</font></i><font style="vertical-align: inherit;">としていますが、イテレーターはそれについて何も知りません。</font><font style="vertical-align: inherit;">タイプを手動で変換する必要をなくしたいと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イテレータを再度変更し、キャストする機能を追加する時が来たようです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t, PtreeIteratorTag tag,
  <span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt;&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PtreeIterator</span>
{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> value_type = Deref_t;
  <span class="hljs-keyword">using</span> dereference_type = value_type;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべてのテンプレート引数を毎回手動で記述しないようにするために、すべての場合にいくつかのエイリアスを追加します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは良いです。</font><font style="vertical-align: inherit;">これで、カーストが不要な場合は、最初のテンプレート引数のみを指定でき、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タグ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータの値で頭を詰まらせることもできません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、コンテナをどうするのでしょうか？</font><font style="vertical-align: inherit;">イテレータに適したユニバーサルクラスを1つだけ持つことを思い出してください。</font><font style="vertical-align: inherit;">今では、それは下品に多くの異なる組み合わせになり、単純さが必要です。</font><font style="vertical-align: inherit;">このようなもの：</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/xc/nv/ik/xcnvik7rkulnyybu6jngdpcrv4w.png" alt="画像39"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、単一のコンテナクラスですべてのタイプのイテレータをサポートし、逆参照時にどのタイプを返すかを指示できるようにする必要があります。</font><font style="vertical-align: inherit;">次に、コードで、必要なコンテナーを作成し、必要なイテレーターについて考えることなく、コンテナーの操作を開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この質問については、次のセクションで説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターンマジック</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だからここに私たちが必要なものです：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのイテレーターで普遍的に機能する1つのコンテナー。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イテレータは、ノードのリストに応じて、各要素で機能することも、1つの要素を通じて機能することもできます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じイテレータですが、カウンタがあります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプがさらに指定されている場合、両方のイテレータは逆参照時にキャストできるはずです。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、テンプレートパラメータを使用して、なんらかの方法でコンテナタイプをイテレータタイプにバインドする必要があります。</font><font style="vertical-align: inherit;">これが起こったことです：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">typename</span> FwdIt,
          <span class="hljs-keyword">typename</span> Node_t,
          <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;<font></font>
class PtreeContainer<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = FwdIt&lt;Node_t, Deref_t&gt;;
  <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> Iterator::dereference_type;
  <span class="hljs-keyword">using</span> size_type  = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> difference_type = <span class="hljs-keyword">typename</span> Iterator::difference_type;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeContainer(Node_t* nodes) :<font></font>
    m_nodes{ nodes }<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (IsLeaf(m_nodes))<font></font>
    {<font></font>
      m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  ....<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> begin() == end();<font></font>
  }<font></font>
  ....<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、コンテナにメソッドを追加することもできます。</font><font style="vertical-align: inherit;">例えば、これは要素の数を知る方法です：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">difference_type <span class="hljs-title">count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::distance(begin(), end());<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、ここにインデックス演算子があります：</font></font><br>
<br>
<pre><code class="cpp hljs">value_type <span class="hljs-keyword">operator</span>[](size_type index) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
{<font></font>
  size_type i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin(); it != end(); ++it)<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (i++ == index)<font></font>
    {<font></font>
      <span class="hljs-keyword">return</span> *it;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">return</span> value_type{};<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなメソッドは線形に複雑であるため、慎重に処理する必要があることは明らかですが、役立つ場合もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使いやすくするために、エイリアスを追加します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementList =<font></font>
PtreeContainer&lt;PtreeStatementIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeItemList =<font></font>
PtreeContainer&lt;PtreeListIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedStatementList =<font></font>
PtreeContainer&lt;PtreeStatementCountingIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedItemList =<font></font>
PtreeContainer&lt;PtreeListCountingIterator, Node_t, Deref_t&gt;;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これでコンテナを簡単に作成できます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前述の</font><i><font style="vertical-align: inherit;">PtreeDeclaration</font></i><font style="vertical-align: inherit;">クラス</font><i><font style="vertical-align: inherit;">で</font></i><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetDeclarators</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドから</font><font style="vertical-align: inherit;">コンテナー</font><font style="vertical-align: inherit;">を取得したいとします</font><font style="vertical-align: inherit;">。そのイテレーターはセパレーターをスキップしますが、カウンターがありません。逆参照されると、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PtreeDeclarator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプの値を返します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このようなコンテナの宣言は次のとおりです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">using</span> DeclList =<font></font>
      Iterators::PtreeItemList&lt;Ptree, PtreeDeclarator*&gt;;<font></font>
<span class="hljs-keyword">using</span> ConstDeclList =<font></font>
      Iterators::PtreeItemList&lt;<span class="hljs-keyword">const</span> Ptree, <span class="hljs-keyword">const</span> PtreeDeclarator*&gt;;<font></font>
             :<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDecl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclarator* decl)</span> </span>{ .... }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessDeclarators</span><span class="hljs-params">(<span class="hljs-keyword">const</span> PtreeDeclaration* declaration)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> decl : declaration-&gt;GetDeclarators())<font></font>
  {<font></font>
    ProcessDecl(decl);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、エイリアスの型推論はC ++ 20でのみ表示されるため、コードでコンテナーをより便利に作成するために、次のような関数を追加しました。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeStatementList&lt;Node_t&gt; <span class="hljs-title">MakeStatementList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeItemList&lt;Node_t&gt; <span class="hljs-title">MakeItemList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeCountedStatementList&lt;Node_t&gt; <span class="hljs-title">MakeCountedStatementList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t&gt;
<span class="hljs-function">PtreeCountedItemList&lt;Node_t&gt; <span class="hljs-title">MakeCountedItemList</span><span class="hljs-params">(Node_t* node)</span>
</span>{
  <span class="hljs-keyword">return</span> { node };<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enumで</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
機能した関数を思い出してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これで次のように書くことができます：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Ptree* argList)</span>
</span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [elem, i] : MakeCountedItemList(argList))<font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> name = PtreeToString(elem);<font></font>
    ....<font></font>
    UseIndexSomehow(i);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元のバージョンと比較して、それは私には思えます、それは良くなっています：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ProcessEnum</span><span class="hljs-params">(Ptree* argList, Ptree* enumPtree)</span>
</span>{
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">ptrdiff_t</span> argListLen = Length(argList);
  <span class="hljs-keyword">if</span> (argListLen &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">ptrdiff_t</span> i = <span class="hljs-number">0</span>; i &lt; argListLen; ++i)<font></font>
  {<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;<font></font>
    Ptree* elem;<font></font>
<font></font>
    <span class="hljs-keyword">const</span> EGetEnumElement r = GetEnumElementInfo(enumPtree, i, elem, name);<font></font>
    ....<font></font>
    UseIndexSomehow(i);<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それだけです、皆さん</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私にとってはこれですべてです。ご清聴ありがとうございました。</font><font style="vertical-align: inherit;">興味深い、または役立つものを見つけていただけたら幸いです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の内容によると、私はアナライザーのコードを叱りつけているようで、すべてが悪いと言いたいことがあります。</font><font style="vertical-align: inherit;">本当じゃない。</font><font style="vertical-align: inherit;">歴史のある他のプロジェクトと同様に、私たちの分析装置は、過去の時代から残っている地質学的堆積物でいっぱいです。</font><font style="vertical-align: inherit;">発掘し、古代文明の遺物を地下から引き出し、復元して棚の上で見栄えをよくしたとしましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここにはたくさんのコードがあります。</font><font style="vertical-align: inherit;">イテレータの実装をここに含めるかどうか疑問に思い、結局、背後に何も残さないように含めることにしました。</font><font style="vertical-align: inherit;">コードを読むことに興味がない場合は、ここで別れを告げます。</font><font style="vertical-align: inherit;">残りはテンプレートで楽しい時間を過ごしたいです。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コード</font></font></b>
                        <div class="spoiler_text"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常の反復子</font></font></h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t, PtreeIteratorTag tag,
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt; = <span class="hljs-number">0</span>&gt;<font></font>
class PtreeIterator<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> value_type = Deref_t;
  <span class="hljs-keyword">using</span> dereference_type = value_type;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  PtreeIterator() = <span class="hljs-keyword">delete</span>;<font></font>
  PtreeIterator(<span class="hljs-keyword">const</span> PtreeIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> PtreeIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeIterator(PtreeIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>=(PtreeIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> PtreeIterator &amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> m_node == other.m_node;<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> PtreeIterator &amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<font></font>
  }<font></font>
  PtreeIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
    </span>{<font></font>
      m_node = Rest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
      m_node = RestRest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
  PtreeIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> tmp = *<span class="hljs-keyword">this</span>;<font></font>
    ++(*<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> tmp;<font></font>
  }<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;dereference_type&gt;(First(m_node));<font></font>
  }<font></font>
  pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> &amp;(**<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">Node_t* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_node;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListIterator =<font></font>
PtreeIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;</code></pre><br>
<h3>  </h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t, PtreeIteratorTag tag,
<span class="hljs-built_in">std</span>::<span class="hljs-keyword">enable_if_t</span>&lt;<span class="hljs-built_in">std</span>::is_base_of_v&lt;Node_t, Ptree&gt;, <span class="hljs-keyword">int</span>&gt; = <span class="hljs-number">0</span>&gt;<font></font>
class PtreeCountingIterator<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> value_type = Deref_t;
  <span class="hljs-keyword">using</span> dereference_type = <span class="hljs-built_in">std</span>::pair&lt;value_type, size_type&gt;;
  <span class="hljs-keyword">using</span> reference = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_lvalue_reference_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> pointer = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;value_type&gt;;
  <span class="hljs-keyword">using</span> difference_type =
        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">std</span>::declval&lt;pointer&gt;() - <span class="hljs-built_in">std</span>::declval&lt;pointer&gt;());
  <span class="hljs-keyword">using</span> iterator_category = <span class="hljs-built_in">std</span>::forward_iterator_tag;<font></font>
<font></font>
 <span class="hljs-keyword">public</span>:<font></font>
  PtreeCountingIterator(Node_t* node) <span class="hljs-keyword">noexcept</span> : m_node{ node } {}<font></font>
  PtreeCountingIterator() = <span class="hljs-keyword">delete</span>;<font></font>
  PtreeCountingIterator(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeCountingIterator(PtreeCountingIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>=(PtreeCountingIterator&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> m_node == other.m_node;<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> PtreeCountingIterator&amp; other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<font></font>
  }<font></font>
  PtreeCountingIterator&amp; <span class="hljs-keyword">operator</span>++() <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(tag == PtreeIteratorTag::Statement)</span>
    </span>{<font></font>
      m_node = Rest(m_node);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
      m_node = RestRest(m_node);<font></font>
    }<font></font>
<font></font>
    ++m_counter;<font></font>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
  PtreeCountingIterator <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">auto</span> tmp = *<span class="hljs-keyword">this</span>;<font></font>
    ++(*<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">return</span> tmp;<font></font>
  }<font></font>
  dereference_type <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> { <span class="hljs-keyword">static_cast</span>&lt;value_type&gt;(First(m_node)), counter() };<font></font>
  }<font></font>
  value_type <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> (**<span class="hljs-keyword">this</span>).first;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">size_type <span class="hljs-title">counter</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_counter;<font></font>
  }<font></font>
  <span class="hljs-function">Node_t* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_node;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_node = <span class="hljs-literal">nullptr</span>;<font></font>
  size_type m_counter = <span class="hljs-number">0</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::Statement&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeListCountingIterator =<font></font>
PtreeCountingIterator&lt;Node_t, Deref_t, PtreeIteratorTag::List&gt;;</code></pre><br>
<h3> </h3><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>, <span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">typename</span> FwdIt,
          <span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;<font></font>
class PtreeContainer<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">using</span> Iterator = FwdIt&lt;Node_t, Deref_t&gt;;
  <span class="hljs-keyword">using</span> value_type = <span class="hljs-keyword">typename</span> Iterator::dereference_type;
  <span class="hljs-keyword">using</span> size_type  = <span class="hljs-keyword">size_t</span>;
  <span class="hljs-keyword">using</span> difference_type = <span class="hljs-keyword">typename</span> Iterator::difference_type;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
  PtreeContainer(Node_t* nodes) :<font></font>
    m_nodes{ nodes }<font></font>
  {<font></font>
    <span class="hljs-keyword">if</span> (IsLeaf(m_nodes))<font></font>
    {<font></font>
      m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  PtreeContainer() = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer(<span class="hljs-keyword">const</span> PtreeContainer&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> PtreeContainer&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer(PtreeContainer&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
  PtreeContainer&amp; <span class="hljs-keyword">operator</span>=(PtreeContainer&amp;&amp;) = <span class="hljs-keyword">default</span>;<font></font>
<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">nullptr_t</span>) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> empty();<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">nullptr_t</span>) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == <span class="hljs-literal">nullptr</span>);<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(Node_t* node) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> get() == node;<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(Node_t* node) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == node);<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(PtreeContainer other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> get() == other.get();<font></font>
  }<font></font>
  <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(PtreeContainer other) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<font></font>
  }<font></font>
  value_type <span class="hljs-keyword">operator</span>[](size_type index) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span><font></font>
  {<font></font>
    size_type i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin(); it != end(); ++it)<font></font>
    {<font></font>
      <span class="hljs-keyword">if</span> (i++ == index)<font></font>
      {<font></font>
        <span class="hljs-keyword">return</span> *it;<font></font>
      }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> value_type{};<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
  <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{ 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> begin() == end();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">value_type <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>)[<span class="hljs-number">0</span>];<font></font>
  }<font></font>
  <span class="hljs-function">value_type <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{<font></font>
    value_type last{};<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cur : *<span class="hljs-keyword">this</span>)<font></font>
    {<font></font>
      last = cur;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> last;<font></font>
  }<font></font>
  <span class="hljs-function">Node_t* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> m_nodes;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function">difference_type <span class="hljs-title">count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::distance(begin(), end());<font></font>
  }<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">has_at_least</span><span class="hljs-params">(size_type n)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
  </span>{<font></font>
    size_type counter = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin(); it != end(); ++it)<font></font>
    {<font></font>
      <span class="hljs-keyword">if</span> (++counter == n)<font></font>
      {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
<span class="hljs-keyword">private</span>:<font></font>
  Node_t* m_nodes = <span class="hljs-literal">nullptr</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeStatementList =<font></font>
PtreeContainer&lt;PtreeStatementIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeItemList =<font></font>
PtreeContainer&lt;PtreeListIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedStatementList =<font></font>
PtreeContainer&lt;PtreeStatementCountingIterator, Node_t, Deref_t&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Node_t, <span class="hljs-keyword">typename</span> Deref_t = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">add_pointer_t</span>&lt;Node_t&gt;&gt;
<span class="hljs-keyword">using</span> PtreeCountedItemList =<font></font>
PtreeContainer&lt;PtreeListCountingIterator, Node_t, Deref_t&gt;;</code></pre><br>
</div>
                    </div><br>
<p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a></p><div style="text-align:center;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png"></a></div><p></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事を英語圏の読者と共有したい場合は、翻訳へのリンクを使用してください：Yuri Minaev。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">木に登る方法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja502500/index.html">パスポートスキャナーの進化：合板の工芸品から実際のビジネスへ</a></li>
<li><a href="../ja502504/index.html">ユーザーの桁を囲む</a></li>
<li><a href="../ja502506/index.html">GOスケジューラー：今は協調的ではない？</a></li>
<li><a href="../ja502508/index.html">トロリーロボット2.0。パート2. rvizを使用した場合と使用しない場合の管理。rvizの美の要素</a></li>
<li><a href="../ja502512/index.html">ソファー専門家のコンテストの結果：科学的な突っ込みのルール</a></li>
<li><a href="../ja502520/index.html">製品分析に関するmitapレポートのビデオレポート</a></li>
<li><a href="../ja502522/index.html">内部に小さな変圧器を備えたガルバニック絶縁チップを開きます</a></li>
<li><a href="../ja502524/index.html">サイコは文明を作る</a></li>
<li><a href="../ja502526/index.html">JUG Ru Group＃2オンラインストリームウィーク</a></li>
<li><a href="../ja502528/index.html">ESP32の組み込みデバイス用のゲームのプログラミング</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>