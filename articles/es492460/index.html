<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ•Ô∏è üóÑÔ∏è üë®‚Äçüëß‚Äçüë¶ La programaci√≥n funcional es lo que (probablemente) le dijeron. Si escuchaste üöª üåç üåü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Me gustan las conversaciones sobre el tema "Antes me dec√≠an en la escuela / instituto / padres, pero ahora me enter√©". Si, por casualidad, me encuentr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>La programaci√≥n funcional es lo que (probablemente) le dijeron. Si escuchaste</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492460/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Me gustan las conversaciones sobre el tema "Antes me dec√≠an en la escuela / instituto / padres, pero ahora me enter√©". Si, por casualidad, me encuentro al menos un poco competente en el asunto en discusi√≥n, entonces esas conversaciones generalmente se reducen a una de tres opciones: "¬øD√≥nde has escuchado esas tonter√≠as antes?" (si el interlocutor tiene raz√≥n), "¬øy de d√≥nde sacaste que esto es as√≠?" (si est√° equivocado) y "tiene raz√≥n, solo que esto no contradice lo que le dijeron antes" (en la gran mayor√≠a de los casos). Me gustan estas conversaciones por la siguiente raz√≥n: por lo general, su iniciador no est√° cargado con un conocimiento preliminar excesivo del problema, lo que en algunos casos le permite se√±alar algunos puntos que fueron aceptados como obvios, pero en realidad no lo son. Y uno de los temas para tales conversaciones fue la programaci√≥n funcional.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, se ha escrito y dicho tanto sobre FP que parece ser todas las preguntas sobre su aplicabilidad, frescura, rendimiento, etc. ro√≠do hasta la m√©dula √≥sea. Sin embargo, tales preguntas se plantean una y otra vez, y siempre habr√° alguien que quiera hablar sobre lo que todos entendieron mal, pero de hecho es as√≠. Tal vez hoy intentar√© este papel desagradecido, ya que recientemente me llam√≥ la atenci√≥n en varias publicaciones sobre este tema tan sufrido. El </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primero</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segundo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dicen una vez m√°s que la FA es una basura y estudiarla solo arruina el karma de su futuro especialista. Otros ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uno</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) son mucho m√°s adecuados, en ellos el autor pretende explicar que todas estas lambdas, combinadores, categor√≠as no son m√°s que polvo en los ojos, y la FP en s√≠ misma es algo simple, comprensible y agradable en la vida. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øQu√© tan cierto es esto?</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de pasar a la esencia del problema, har√© una peque√±a digresi√≥n y pondr√© √©nfasis. Creo que el contenido de las dos primeras publicaciones es una tonter√≠a de un analfabeto ... especialista que, con los dedos separados, discute cosas que ni siquiera pas√≥ un poco de su precioso tiempo estudiando. Las buenas personas de entre los comentaristas ya han indicado que esto no es m√°s que bromas. El problema es que, como result√≥, no puedo percibir las tesis presentadas en estas traducciones como una broma, ya que tuve que escuchar la mayor√≠a de ellas en vivo. Aparentemente, puede diagnosticar la presencia de trauma psicol√≥gico causado por una sobreoferta de tonter√≠as que ha pasado por el cerebro.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los dos segundos ten√≠an m√°s probabilidades de evocar emociones positivas, porque en ellos el autor aplica la pr√°ctica de FP a las tareas que entiende el desarrollador de OOP. A pesar del desacuerdo con el mensaje b√°sico de la primera publicaci√≥n reflejado en el t√≠tulo y las dudas sobre la razonabilidad de la implementaci√≥n del concepto de m√≥nada en una forma tan expl√≠cita en el lenguaje orientado a OOP, el autor no puede ser reprochado por la falta de elaboraci√≥n del material. Pero hay un aspecto b√°sico, que no pod√≠a ignorar. Este es un tipo de vulgarizaci√≥n de la programaci√≥n funcional, un intento de considerarlo como un conjunto simple de herramientas y enfoques para el dise√±o de programas. Lo cual, en mi opini√≥n, no es del todo cierto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, en este art√≠culo, se intenta demostrar que las propiedades de los programas funcionales que el autor est√° tratando de reproducir en su c√≥digo no son la base de la programaci√≥n funcional, no establecidas por los sabios creadores de Haskell y sus soluciones de dise√±o, sino una consecuencia directa de esos conceptos y modelos que realmente establecido en sus cimientos, o, curiosamente, un intento de compensar las deficiencias que generan estos cimientos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces al punto</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En ciencia, con bastante frecuencia se puede observar la siguiente metamorfosis. Primero, como parte de la consideraci√≥n de cierto proceso / fen√≥meno / teor√≠a, aparece un cierto objeto que posee algunas propiedades importantes y √∫tiles. Pero generalmente tambi√©n resulta ser bastante complicado en su estructura, lo que limita su utilidad pr√°ctica. Por lo tanto, a menudo act√∫an de esta manera: toman las propiedades de un objeto dado como base y sobre esta base construyen una nueva teor√≠a / modelo / descripci√≥n, dentro de la cual el objeto deseado se vuelve simple o incluso trivial, o las propiedades inherentes necesarias aparecen en objetos mucho m√°s simples. Algo como esto est√° relacionado con la programaci√≥n funcional "real" y los "elementos de la programaci√≥n funcional", que est√°n disponibles en lenguajes modernos de alto nivel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como generalmente es √∫til familiarizarse con la historia de su origen para comprender un fen√≥meno, recordemos los momentos de la historia de la teor√≠a de la computaci√≥n y la programaci√≥n que son importantes para nuestra pregunta. A finales del siglo XIX y principios del XX hubo una reestructuraci√≥n significativa de los fundamentos de la ciencia matem√°tica. Esto no solo resolvi√≥ una serie de problemas y contradicciones identificados que se introdujeron en el n√∫cleo mismo de las ideas en ese momento de que hab√≠a matem√°ticas y pruebas matem√°ticas, sino que tambi√©n plante√≥ una serie de nuevas preguntas. Uno de ellos fue el siguiente: ¬øcu√°l es el algoritmo? O, lo que es lo mismo, qu√© clase de problemas se pueden resolver de forma puramente mec√°nica. No profundizar√© en por qu√© esta pregunta result√≥ ser importante; ser√≠a mejor ir directamente a la respuesta que le dio Alan Turing, ampliamente conocido en c√≠rculos no muy estrechos. √âl formul√≥ la tesis:"Solo las funciones para las que se puede construir una m√°quina de Turing son computables". Esta declaraci√≥n no est√° probada. Es decir, de hecho, Turing simplemente dio una definici√≥n formal estricta de lo que se considera una funci√≥n computable, consistente con esas representaciones intuitivas que generalmente est√°n integradas en este concepto. Esta definici√≥n demostr√≥ ser capaz de satisfacer a los solicitantes, porque son muy conscientes de lo que es una m√°quina, incluso con una cinta infinita, y de c√≥mo deber√≠a funcionar. Pero para muchos matem√°ticos, esta definici√≥n no est√° muy satisfecha.que generalmente se invierten en este concepto. Esta definici√≥n demostr√≥ ser capaz de satisfacer a los solicitantes, porque son muy conscientes de lo que es una m√°quina, incluso con una cinta infinita, y de c√≥mo deber√≠a funcionar. Pero para muchos matem√°ticos, esta definici√≥n no est√° muy satisfecha.que generalmente se invierten en este concepto. Esta definici√≥n demostr√≥ ser capaz de satisfacer a los solicitantes, porque son muy conscientes de lo que es una m√°quina, incluso con una cinta infinita, y de c√≥mo deber√≠a funcionar. Pero para muchos matem√°ticos, esta definici√≥n no est√° muy satisfecha.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aparentemente, los conceptos que operaba Turing les parec√≠an insuficientemente ... abstractos. </font><font style="vertical-align: inherit;">En este sentido, no abandonaron los intentos de dar una definici√≥n diferente, que abarcar√≠a una clase m√°s amplia de funciones matem√°ticas y, al mismo tiempo, corresponder√≠a a nuestras ideas intuitivas. </font><font style="vertical-align: inherit;">Estos intentos fueron infructuosos. </font><font style="vertical-align: inherit;">Cada definici√≥n alternativa que se propuso y resisti√≥ las cr√≠ticas result√≥ ser equivalente a la definici√≥n de Turing en el sentido de que describ√≠a exactamente la misma clase de funciones matem√°ticas. </font><font style="vertical-align: inherit;">Sin embargo, estos estudios no fueron de ninguna manera in√∫tiles. </font><font style="vertical-align: inherit;">Los intentos de mirar el objeto de estudio desde un punto de vista diferente generalmente son raramente in√∫tiles. </font><font style="vertical-align: inherit;">En nuestro caso, esto llev√≥ a la aparici√≥n de varias teor√≠as, una de las cuales fue el c√°lculo lambda propuesto por Alonzo Church.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La pereza es el motor del progreso.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øQu√© es tan √∫til en el c√°lculo lambda y por qu√© todos se preocupan tanto? Todo es simple En el modelo propuesto por Turing, el algoritmo es una secuencia de instrucciones que nos es familiar, que nuevamente debe ejecutar el ejecutante habitual. Es intuitivo. Pero la definici√≥n de Church es diferente. El mecanismo de construcci√≥n principal (y esencialmente el √∫nico) en el marco de esta teor√≠a son los llamados t√©rminos lambda, que en nuestros t√©rminos actuales pueden llamarse (condicionalmente) funciones an√≥nimas. El programa (algoritmo) en este caso es una combinaci√≥n de estos t√©rminos construidos de acuerdo con ciertas reglas, los datos iniciales son los valores de las variables libres del t√©rmino lambda, y el proceso de c√°lculo no es m√°s que una reducci√≥n (simplificaci√≥n) del t√©rmino lambda (funci√≥n), que puede ser llevado a cabotan pronto como alguna variable libre obtiene valor. El siguiente hecho result√≥ ser inesperado aqu√≠: tan pronto como una variable recibe un valor, es decir, tan pronto como presentamos una parte de los datos iniciales al programa, podemos realizar la reducci√≥n, pero no de una, sino de dos maneras. En el primer caso, el proceso de c√°lculo resulta ser equivalente al reproducido por calculadoras mec√°nicas t√≠picas como una m√°quina de Turing. La regla le corresponde: los argumentos de la funci√≥n deben calcularse antes de calcular la funci√≥n misma. Pero hay otra opci√≥n: el llamado c√°lculo parcial. En este caso, si solo se calcula una parte de los argumentos, a√∫n podemos calcular (reducir) esa parte de la funci√≥n que usa solo estos argumentos. Este enfoque generalmente se denomina modelo de computaci√≥n "vago".En contraste con esto, el modelo de c√≥mputo de Turing a veces se llama "en√©rgico" o "codicioso"; los lenguajes de programaci√≥n creados sobre esta base se denominar√°n imperativos a continuaci√≥n. Una caracter√≠stica importante de los c√°lculos "vagos" es que si una subrutina se escribe en funci√≥n de, por ejemplo, tres argumentos, pero en realidad usa solo dos, entonces no hay necesidad de calcular este tercer argumento para calcular el valor de la funci√≥n.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y esto nos da interesantes posibilidades pr√°cticas. </font><font style="vertical-align: inherit;">Por ejemplo, la capacidad de trabajar con secuencias infinitas. </font><font style="vertical-align: inherit;">Ser√≠a f√°cil para cualquiera que comenzara a conocer la programaci√≥n funcional en general y con el lenguaje Haskell en particular para comprender esta forma de obtener los primeros </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√∫meros de Fibonacci:</font></font><br>
<br>
<pre><code class="haskell">fibonacci2 a b = a : (fibonacci2 b (a+b))<font></font>
fibonacci = fibonacci2 1 1<font></font>
<font></font>
nfibonacci n = take n fibonacci</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explicaci√≥n para Extra√±os con Haskell</font></font></b><div class="spoiler_text"><i>fibonacci2</i>      ,       ,         fibonacci2    b   (a+b).  ( !)     :<br>
<pre><code class="python">def fibonacci2(a, b) :<font></font>
    return [a] + fibonacci2(b, a+b)<font></font>
<font></font>
def fibonacci() :<font></font>
    return fibonacci2(1, 1)<font></font>
<font></font>
def nfibonacci(n) :<font></font>
    res = []<font></font>
    data = fibonacci()<font></font>
    for i in range(n) :<font></font>
      res.append( data[i] )<font></font>
    return res<font></font>
</code></pre><br>
   nfibonacci.<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La funci√≥n de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fibonacci</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (y esta es precisamente la funci√≥n) genera una lista interminable de n√∫meros. Si utilizamos el modelo computacional que nos es familiar, entonces nfibonacci nunca podr√≠a haber terminado (lo cual, recuerdo, es perfectamente aceptable y no contradice las nociones de su "computabilidad"). Pero si usamos el modelo de c√°lculo "vago", es f√°cil notar que tan pronto como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> toma un valor espec√≠fico, para obtener el valor de la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nfibonacci,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solo necesitamos los primeros n elementos de la lista que son el resultado de la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fibonacci</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En este caso, podemos actuar as√≠: obtener el elemento de la lista: realizar la reducci√≥n, el siguiente elemento es otro paso de reducci√≥n, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-th argumento: la reducci√≥n condujo a la obtenci√≥n del valor de la funci√≥n. Es decir, en este caso obtenemos un resultado por un tiempo finito a pesar del "ciclo" del procedimiento para construir una lista de n√∫meros de Fibonacci. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠, un lector particularmente entusiasta de mentalidad imperativa exclama: "¬° </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero espera, solo un idiota franco implementar√° la construcci√≥n de una lista de n√∫meros de Fibonacci de esta manera! Hay soluciones obvias que no conducen a un bucle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Y √©l, por supuesto, tendr√° raz√≥n. La transferencia est√∫pida de una soluci√≥n que involucra la implementaci√≥n del modelo de c√°lculos" perezosos "en un programa para c√°lculos" codiciosos "no es realmente un indicador de gran inteligencia. Si ofrece esta tarea a un programador que ha mantenido toda su vida profesional Lealtad, digamos, al lenguaje C, entonces probablemente ofrecer√° una variante con un ciclo con un contador y dos variables de estado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero el punto no son los n√∫meros de Fibonacci en s√≠ mismos. El hecho es que la regla para construir una secuencia en este ejemplo est√° separada del m√©todo de procesamiento de sus elementos. Y esta es una propiedad √∫til que es deseable poder reproducir en casos m√°s complejos, cuando los elementos de la secuencia procesada se generan de una manera bastante complicada y la simple transferencia de la soluci√≥n "de frente" para la secuencia de Fibonacci en este caso es ineficaz en el tiempo, la memoria o simplemente conduce a c√≥digo, cuya comprensi√≥n no es accesible a los simples mortales. Tal aspiraci√≥n es natural y puede realizarse, por ejemplo, mediante el uso de iteradores o generadores. En python, por ejemplo, podemos hacer esto:</font></font><br>
<br>
<pre><code class="python">def fibonacci() :<font></font>
    a = 1<font></font>
    b = 1<font></font>
    yield a<font></font>
    yield b<font></font>
    while True :<font></font>
      c = a + b<font></font>
      yield c<font></font>
      a = b<font></font>
      b = c<font></font>
     <font></font>
def nfibonacci(n) :<font></font>
    return [e for e in itertools.islice(fibonacci(), n)]<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fibonacci ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un generador que crea una secuencia elemento por elemento. Y en este caso, en lugar de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fibonacci,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede haber una funci√≥n generadora de cualquier complejidad. Si traemos el c√≥digo por completo, incluido el c√≥digo del cap√≥ del motor, obtenemos un dise√±o de software muy complejo y completamente imperativo. Pero la versi√≥n final es bastante "funcional". En C ++, uno podr√≠a hacer un truco similar al tener una clase especial de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fibonachi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e iteradores para ello. La decisi√≥n variar√° seg√∫n las caracter√≠sticas del lenguaje de programaci√≥n y las preferencias del programador, pero el objetivo seguir√° siendo el mismo: dividir a nivel de organizaci√≥n del programa una forma de construir una secuencia de longitudes previamente desconocidas y una forma de procesar sus elementos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La diferencia es que en el marco del enfoque funcional, dicha organizaci√≥n del programa es natural y se impone por el m√©todo mismo de su implementaci√≥n, mientras que en el marco del programa imperativo requiere un trabajo creativo adicional, incluida la creaci√≥n de conceptos y patrones de dise√±o adicionales.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La limpieza es la clave de la salud.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otra propiedad, en presencia de la cual hablan de un enfoque funcional para la programaci√≥n, es la "pureza" de las funciones. </font><font style="vertical-align: inherit;">Es la ausencia de efectos secundarios. </font><font style="vertical-align: inherit;">Es decir, una llamada de funci√≥n con el mismo conjunto de argumentos deber√≠a conducir al mismo resultado. </font><font style="vertical-align: inherit;">El autor de la </font><font style="vertical-align: inherit;">publicaci√≥n </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">citada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> describi√≥ con suficiente detalle por qu√© en los programas ejecutados en un estilo imperativo, esta propiedad tambi√©n es deseable. </font><font style="vertical-align: inherit;">Sin embargo, no es m√°s que una consecuencia del modelo de c√°lculos utilizado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La raz√≥n por la cual todas las funciones en un programa funcional deben estar limpias es simple. Suponiendo la presencia de estos mismos efectos secundarios, resulta que el orden en que los argumentos de la funci√≥n obtienen su valor afecta directamente el resultado de la funci√≥n. Podemos decir que esto tambi√©n es cierto en el marco del enfoque imperativo, pero en el caso de la "pereza" de los c√°lculos, todo es mucho peor. Incluso si suponemos que los argumentos de la funci√≥n pueden calcularse independientemente unos de otros en un orden arbitrario, la "pereza" a√∫n implica que (condicionalmente) no todo el c√≥digo de la funci√≥n se ejecutar√° de una sola vez. Se ejecutar√° en partes, dependiendo de dos cosas: de hecho, la estructura de la funci√≥n que el compilador condicional nos proporcionar√° amablemente y el orden en el que presentaremos la funci√≥n con sus argumentos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es natural para nosotros esperar que si primero definimos una funci√≥n </font></font><br>
<br>
<pre><code class="python">def f(x,y) :<font></font>
  ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
y despues de ella </font></font><br>
<pre><code class="python">def g(x, y) :<font></font>
  return f(y, x)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
entonces el resultado de llamar a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g (a, b)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ser√° igual al resultado de llamar a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f (b, a)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para cualquier valor computable independiente de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero si </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiene efectos secundarios que afectan el c√°lculo de los valores de los argumentos, nuestras expectativas pueden ser brutalmente enga√±adas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por ejemplo, al calcular </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , se produce la lectura del archivo, y al calcular </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tambi√©n se lee del mismo archivo. </font><font style="vertical-align: inherit;">En los c√°lculos "perezosos", no sabemos de antemano qu√© parte del c√≥digo (para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) se ejecutar√° primero. Eso significa que no sabemos qu√© resultado dar√° el programa, incluso si conocemos el contenido del archivo que deber√≠a leer. Tal comportamiento es en principio inaceptable y, por lo tanto, debe excluirse categ√≥ricamente. Por lo tanto, dentro del </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">marco del modelo de c√°lculos "perezosos" (efectos no controlados) de la funci√≥n deber√≠a estar prohibido</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si se aplica el codicioso orden de los c√°lculos, los efectos secundarios son mucho m√°s predecibles. Por esto y solo por esta raz√≥n, est√°n permitidos en la programaci√≥n imperativa. Pero si abusa de ellos, la funci√≥n se convertir√° en un error. Entonces, no debes abusar de ellos. Entonces, nuevamente, el concepto de ‚Äúpureza‚Äù que es natural en la programaci√≥n funcional es muy demandado en el mundo imperativo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En consecuencia, la tesis</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programa funcional: un programa que consiste en funciones puras </font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incorrecto si se ve como una definici√≥n. </font><font style="vertical-align: inherit;">S√≠, un programa funcional consta de funciones "puras", pero un programa que consiste en funciones puras no tiene que ser "funcional" en absoluto. </font><font style="vertical-align: inherit;">Esta es su propiedad, pero no una propiedad definitoria.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, hay un problema. La capacidad de guardar el estado e incluso la entrada-salida banal son cosas directamente relacionadas con los efectos secundarios. Y la vida sin ellos est√° llena de dolor y sufrimiento. Surge la pregunta: ¬øc√≥mo combinar los efectos secundarios y los c√°lculos "perezosos"? La respuesta en general es de ninguna manera. La respuesta es correcta: en cada caso particular se debe buscar una soluci√≥n particular satisfactoria. Result√≥ que muchas formas de reproducir c√°lculos con efectos secundarios sin violar el concepto de "pureza" de los c√°lculos se ajustan al concepto general de la m√≥nada, tomado de la teor√≠a de categor√≠as. No me gustar√≠a volver a intentar explicar qu√© es y con qu√© se come, aunque solo sea porque en cualquier caso no reemplazar√° (y en mi experiencia ni siquiera simplificar√°) una explicaci√≥n de c√≥mo se pueden implementar espec√≠ficamente las variables de estado,excepciones y cosas similares en lenguajes funcionales "puros". La moraleja principal es que la programaci√≥n imperativa es una fuente de inspiraci√≥n para lo funcional, as√≠ como funcional para lo imperativo. Adem√°s, a veces una idea pasa por un concepto competitivo como a trav√©s de un filtro, regresa de forma alterada y da lugar a la aparici√≥n de una nueva herramienta.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øSe necesitan m√≥nadas en un mundo imperativo? No tengo una opini√≥n establecida sobre este tema. El autor de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ayuno seguro que necesitaba. Me inclino a dudar de esta afirmaci√≥n, ya que el uso del concepto de una m√≥nada en programas funcionales generalmente est√° relacionado con el hecho de que se puede formular un cierto algoritmo independientemente de los efectos secundarios espec√≠ficos que oculta esta m√≥nada. En otras palabras, si un tipo de datos definido por el usuario (hipot√©tico, a√∫n no creado por la humanidad) satisface los requisitos para una m√≥nada, entonces el algoritmo escrito para √©l funcionar√° correctamente. Esto es conveniente principalmente en estudios te√≥ricos. Pero hay un par de matices. En primer lugar, no est√° muy claro por qu√© esconderse en el envoltorio, los efectos secundarios son efectivos en los idiomas para los cuales son un fen√≥meno natural. En segundo lugar,Cuando se escriben programas espec√≠ficos con tipos de datos espec√≠ficos y una arquitectura de destino espec√≠fica, este algoritmo generalizado se ve obligado a someterse a una reestructuraci√≥n para aumentar la productividad. Es posible escribir algoritmos generalizados utilizando m√≥nadas en un estilo imperativo, pero la conveniencia de este enfoque plantea mis dudas. Es poco probable que el hecho de que alg√∫n an√°logo tal vez de tipo std :: opcional de C ++ sea declarado m√≥nada afecte de alguna manera la pr√°ctica de su uso.</font></font><br>
<br>
<h3>   ?</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las funciones de orden superior son una herramienta tan ampliamente utilizada en programas funcionales que el hecho de admitir algo similar en alg√∫n lenguaje de programaci√≥n es suficiente para que algunas personas extra√±as reconozcan este lenguaje como funcional. ¬øQu√© son las "funciones de orden superior"? Esta es una funci√≥n que opera en otras funciones como argumentos, o devuelve una funci√≥n como resultado. Parece que aqu√≠ puede causar debate? Resulta mucho Para empezar, lo que generalmente se entiende por el t√©rmino "funci√≥n". Los programadores generalmente razonan simplemente: si algo se puede llamar como una funci√≥n, entonces se puede considerar como una funci√≥n. En el marco del enfoque imperativo, esto tiene sentido, ya que intuitivamente una funci√≥n es que para un conjunto dado de argumentos da un cierto resultado.Si admitimos la presencia de efectos secundarios, entonces, en el sentido pr√°ctico, realmente no hay diferencia entre la funci√≥n "normal" del lenguaje y, por ejemplo, el objeto de la clase que tiene el operador sobrecargado ().</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero en la programaci√≥n funcional, dicha definici√≥n de una funci√≥n no es suficientemente constructiva, ya que no permite interpretar el concepto de un c√°lculo parcial de esta funci√≥n en s√≠. En la programaci√≥n funcional, una funci√≥n no es "uno de" los elementos estructurales de un programa, sino en cierto sentido lo contrario: todos los elementos del programa son funciones. Por lo tanto, de hecho, esto es "programaci√≥n funcional". Y, de nuevo, si todo es una funci√≥n, es decir, cualquier argumento de cualquier funci√≥n es una funci√≥n, entonces cualquier funci√≥n con argumentos es una funci√≥n de orden superior. Por lo tanto, las funciones de orden superior son un elemento natural de un programa funcional. Tanto es as√≠ que incluso su asignaci√≥n en una clase separada no tiene mucho sentido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como una funci√≥n de orden superior, generalmente se asigna un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mapa</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o un </font><i><font style="vertical-align: inherit;">pliegue</font></i><font style="vertical-align: inherit;"> .</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pero consideraremos una funci√≥n m√°s trivial, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cualquiera</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , de los dos argumentos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f (x, y)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dentro del marco del modelo de c√°lculos "perezosos", los argumentos de esta funci√≥n se calcular√°n solo cuando realmente sean necesarios. Supongamos que el primer argumento es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Calculamos este argumento, proporcionamos su valor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y, adem√°s, calculamos todo lo que podemos calcular sin usar el valor del argumento </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Luego, el resto de los c√°lculos se pueden representar como una nueva funci√≥n, ya </font><font style="vertical-align: inherit;">independiente </font><font style="vertical-align: inherit;">de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por ejemplo, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g (y)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pero en este caso, nada nos impide presentar formalmente </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no en funci√≥n de dos argumentos, sino en funci√≥n de un argumento</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f (x)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cuyo resultado es otra funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g (y)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En otras palabras, dentro del marco del enfoque funcional, cualquier funci√≥n de los </font><font style="vertical-align: inherit;">argumentos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N&gt; 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es una funci√≥n de orden superior, ya que puede interpretarse como una funci√≥n de un argumento, cuyo resultado es la funci√≥n de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">los</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> argumentos </font><i><font style="vertical-align: inherit;">N-1</font></i><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øPodemos implementar este comportamiento como parte de un enfoque imperativo? Por supuesto que podemos. En python, escribir√≠amos algo como lo siguiente:</font></font><br>
<br>
<pre><code class="python">def partial(f, x) :<font></font>
	def g(*args) :<font></font>
		return f(x, *args)<font></font>
	return g<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al llamar a la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parcial</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cuyo primer argumento es la funci√≥n de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> argumentos, y el segundo es el valor de su primer argumento, obtenemos la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-1 del</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> argumento. Ahora podemos usar la nueva funci√≥n donde sea que podamos usar la funci√≥n de </font><font style="vertical-align: inherit;">argumento </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es decir, obtuvieron lo mismo que en el programa funcional. ¬øEntonces? No, no as√≠. Si estuvi√©ramos tratando con un programa verdaderamente funcional, entonces cuando llam√°bamos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parcial</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , calcular√≠amos parte del valor del primer argumento. En algunos casos, incluso podr√≠a resultar que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un valor constante. ¬øQu√© tenemos en un an√°logo imperativo? El valor pasado del argumento </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reci√©n recordado (agregado al contexto de la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Cuando llamamos a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , el valor de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se tomar√° de los contenedores y simplemente se sustituir√° en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es decir, no hay diferencia en la forma, sino en el contenido: significativo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El uso de funciones de funciones es conveniente porque le permite describir naturalmente muchos algoritmos importantes. Por lo tanto, se vieron obligados a aparecer en lenguajes de programaci√≥n imperativos. Y aparecieron. Pero dado que usan un modelo de c√°lculo diferente, esto habr√≠a requerido el desarrollo de nuevos conceptos. Y fueron desarrollados. Por ejemplo, el cierre descrito anteriormente. Es decir, las funciones de √≥rdenes superiores en lenguajes imperativos corresponden a lo que se puede observar en lenguajes funcionales, solo externamente. Pero el contenido es completamente diferente. ¬øEs esto importante para el programador? Probablemente no, pero solo si comprende bien c√≥mo funcionan esos mecanismos que implementan caracter√≠sticas similares en su lenguaje de programaci√≥n favorito. De lo contrario, puede, por ejemplo, implementar "aplicaci√≥n parcial", cerrar al construir una nueva funci√≥n (bueno, olo que en su caso se ver√° como una funci√≥n) en lugar de valor y obtendr√° un comportamiento interesante del programa. Y despu√©s de eso, grita sobre la inferioridad del enfoque funcional.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, ¬øqui√©n enga√±aba a qui√©n?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esta etapa de la presentaci√≥n, es bastante posible poner un punto y coma y volver a la pregunta principal. </font><font style="vertical-align: inherit;">Desde ahora podemos formular las siguientes declaraciones:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La principal diferencia entre la programaci√≥n funcional e imperativa no es la propiedad de la pureza de las funciones, ni la presencia de funciones an√≥nimas, funciones de √≥rdenes superiores, m√≥nadas, polimorfismo param√©trico o cualquier otra cosa. </font><font style="vertical-align: inherit;">La principal diferencia es el uso de un modelo de c√°lculo diferente. </font><font style="vertical-align: inherit;">Todo lo dem√°s no es m√°s que consecuencias.</font></font></li>
<li>,         ,       .    .     ,      ¬´¬ª  ¬´¬ª .    ,                  .  .</li>
<li>  ,      ,        ,           .        .   ‚Äî .</li>
<li>      ,      .       ,        ¬´¬ª ;   ,       .           ,      -     ,   -      .    .</li>
<li>   ,                 .     ,        . , ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a>    ,                           .          .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La programaci√≥n funcional es lo que (probablemente) le dijeron. Estos son la reducci√≥n beta, los combinadores de punto fijo, las m√≥nadas, la escritura Hindley-Milner y m√°s. No confunda el envoltorio con el contenido. FP no se basa en las matem√°ticas m√°s simples, no se puede dominar por un par de noches con un vaso de t√©; es poco probable que se proyecte directamente sobre sus problemas y proyectos apremiantes; no obtendr√° un beneficio r√°pido y garantizado de este conocimiento. Pero muchos elementos de lo que est√° en el enfoque funcional son prestados, procesados ‚Äã‚Äãy finalmente implementados en lenguajes de programaci√≥n orientados al desarrollo de grandes proyectos. S√≠, est√°n organizados de manera diferente a sus antepasados ‚Äã‚Äãfuncionales, pero esto no los hace menos √∫tiles. Solo un idiota cl√≠nico transmitir√° un mensaje serio de que Haskell es un mal lenguaje,porque es dif√≠cil escribir un programa para cualquier tipo de contabilidad. Una persona cargada con la presencia de inteligencia, incluso desde el punto de vista de su actividad profesional, sin una profunda inmersi√≥n en las complejidades de la teor√≠a, es bastante capaz de comprender exactamente qu√© pr√°cticas de la programaci√≥n funcional deber√≠an adoptarse para mejorar su c√≥digo. Por una demostraci√≥n convincente de la cual expreso gratitud</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Psyhast</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aprende programaci√≥n funcional. </font><font style="vertical-align: inherit;">En tu nombre.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es492448/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 406 (9 al 15 de marzo de 2020)</a></li>
<li><a href="../es492450/index.html">Actualizado 03.31. ¬øEl coronavirus se transmite por el aire? Lo que se sabe en este momento</a></li>
<li><a href="../es492454/index.html">Vendemos refactorizaci√≥n de arquitectura a un cliente o cu√°l es el problema de los desarrolladores</a></li>
<li><a href="../es492456/index.html">C√≥mo visualizar y animar modelos (geof√≠sicos). Mostrar datos sin procesar</a></li>
<li><a href="../es492458/index.html">GUI simple para M5Stack (Arduino)</a></li>
<li><a href="../es492462/index.html">Fuente de la verdad: c√≥mo un analista ense√±a a un gerente y un desarrollador a trabajar juntos</a></li>
<li><a href="../es492464/index.html">DBA: organice de manera competente la sincronizaci√≥n y las importaciones</a></li>
<li><a href="../es492466/index.html">C√≥mo pasar de cualquier proveedor de host con cPanel a Plesk en Rusonix en solo cinco pasos</a></li>
<li><a href="../es492468/index.html">Lenovo Thinkserver SE350: un h√©roe de la periferia</a></li>
<li><a href="../es492474/index.html">Estructuramos la informaci√≥n en las cajas de Android y analizamos lo que deber√≠a ser capaz de hacer un prefijo normal.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>