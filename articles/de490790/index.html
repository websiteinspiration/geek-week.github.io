<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏼‍🤝‍🧑🏻 🎅 👩🏼‍💻 Zip-Dateien: Verlauf, Erläuterung und Implementierung 🦖 📫 🤫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe mich lange gefragt, wie Daten komprimiert werden, auch in Zip-Dateien. Einmal habe ich mich entschlossen, meine Neugier zu befriedigen: zu le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Zip-Dateien: Verlauf, Erläuterung und Implementierung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/490790/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bo/tw/dr/botwdrbtegpbnpnwmy7id56fbaa.jpeg"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe mich lange gefragt, wie Daten komprimiert werden, auch in Zip-Dateien. Einmal habe ich mich entschlossen, meine Neugier zu befriedigen: zu lernen, wie Komprimierung funktioniert, und mein eigenes Zip-Programm zu schreiben. Die Implementierung ist zu einer aufregenden Übung in der Programmierung geworden. Es macht Ihnen große Freude, eine debuggte Maschine zu erstellen, die Daten aufnimmt, ihre Bits in eine effizientere Darstellung überträgt und sie dann wieder sammelt. Ich hoffe, Sie werden auch daran interessiert sein, darüber zu lesen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel erklärt ausführlich, wie Zip-Dateien und das Komprimierungsschema funktionieren: LZ77-Komprimierung, Huffman-Algorithmus, Deflate-Algorithmus und mehr. Sie lernen die Geschichte der Entwicklung der Technologie kennen und sehen sich ziemlich effektive Implementierungsbeispiele an, die in C von Grund auf neu geschrieben wurden. Der Quellcode ist hier: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hwzip-1.0.zip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich bin </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ange Albertini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gynvael Coldwind</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fabian Giesen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jonas Skeppstedt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Web</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primiano Tucci</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nico Weber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sehr dankbar </font><font style="vertical-align: inherit;">, die wertvolles Feedback zu den Entwürfen dieses Artikels gegeben haben.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhalt</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschichte</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PKZip</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Info-Zip und Zlib</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winzip</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lempel-Ziv-Kompression (LZ77)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman-Code</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman-Algorithmus</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffmans kanonische Codes</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Effiziente Huffman-Dekodierung</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entleeren</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitströme</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auspacken (Inflation)</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unkomprimierte Entleerungsblöcke</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blöcke mit festen Huffman-Codes entleeren</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blöcke mit dynamischen Huffman-Codes entleeren</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompression (Deflation)</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zip-Dateiformat</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überblick</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenstrukturen</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ende des zentralen Verzeichniseintrags</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zentraler Dateikopf</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lokaler Dateikopf</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung von Zip Read</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung von Zip-Datensätzen</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hwzip</font></font></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Montageanleitungen</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übungen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nützliche Materialien</font></font></a></li>
</ul><br>
<a name="1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschichte</font></font></h2><br>
<a name="2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PKZip</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den achtziger und frühen neunziger Jahren, bevor sich das Internet verbreitete, verwendeten Computerbegeisterte DFÜ-Modems, um über das Telefonnetz eine Verbindung zum Bulletin Board Systems (BBS) -Netzwerk herzustellen. </font><font style="vertical-align: inherit;">BBS war ein interaktives Computersystem, mit dem Benutzer Nachrichten senden, Spiele spielen und Dateien austauschen konnten. </font><font style="vertical-align: inherit;">Um online zu gehen, war es ausreichend, einen Computer, ein Modem und eine gute BBS-Telefonnummer zu haben. </font><font style="vertical-align: inherit;">Zahlen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wurden in Computerzeitschriften</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und auf anderen BBS veröffentlicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein wichtiges Werkzeug zur Erleichterung der Verteilung von Dateien war der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Archivierer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie können eine oder mehrere Dateien in einer einzigen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Archivdatei speichern</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um Informationen bequemer zu speichern oder zu übertragen. Im Idealfall komprimierte das Archiv auch Dateien, um Platz und Zeit für die Übertragung über das Netzwerk zu sparen. In den Tagen von BBS war der Arc-Archivierer beliebt, geschrieben von Tom Henderson von System Enhancement Associates (SEA), einer kleinen Firma, die er mit seinem Schwager gründete. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den späten 1980er Jahren veröffentlichte der Programmierer Phil Katz seine eigene Version von Arc, PKArc. Es war mit SEA Arc kompatibel, funktionierte jedoch dank der in Assemblersprache geschriebenen Unterprogramme und der Verwendung einer neuen Komprimierungsmethode schneller. Das Programm wurde populär, Katz kündigte seinen Job und schuf PKWare, um sich auf die weitere Entwicklung zu konzentrieren. Der Legende nach fand der größte Teil der Arbeit in der Küche seiner Mutter in Glendale, Wisconsin, statt.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1e/50a/990/b1e50a990a86a05045dde9d2a819fbf0.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foto von Phil Katz </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus einem Artikel im Milwaukee Sentinel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vom 19. September 1994.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Die SEA war jedoch mit Katz 'Initiative nicht zufrieden. Das Unternehmen beschuldigte ihn einer Marken- und Urheberrechtsverletzung. Die Rechtsstreitigkeiten und Kontroversen im BBS-Netzwerk und in der PC-Welt sind als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arc Wars bekannt geworden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Am Ende wurde der Streit </font><font style="vertical-align: inherit;">zugunsten der SEA </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beigelegt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Katz gab Arc auf und schuf 1989 ein neues Archivierungsformat, das er Zip nannte und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Öffentlichkeit zugänglich machte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote> ,   ,        ,      .  ,  ".ZIP",             ,      ,     ,          , , ,                  ,     ,      .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Katz 'Programm zum Erstellen solcher Dateien hieß PKZip und verbreitete sich bald in der Welt von BBS und PC. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einer der Aspekte, die höchstwahrscheinlich zum Erfolg des Zip-Formats beigetragen haben, ist, dass die Dokumentation mit PKZip, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application Note</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">geliefert wurde </font><font style="vertical-align: inherit;">, in dem die Funktionsweise des Formats ausführlich erläutert wurde. Auf diese Weise konnten andere das Format erlernen und Programme erstellen, die Zip-Dateien generieren, extrahieren oder auf andere Weise mit ihnen interagieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zip - ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verlustfreies</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Komprimierungsformat </font><font style="vertical-align: inherit;">: Nach dem Entpacken sind die Daten dieselben wie vor der Komprimierung. Der Algorithmus sucht nach Redundanz in den Quelldaten und präsentiert Informationen effizienter. Dieser Ansatz unterscheidet sich von der verlustbehafteten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komprimierung.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das in Formaten wie JPEG und MP3 verwendet wird: Beim Komprimieren werden einige der Informationen, die für das menschliche Auge oder Ohr weniger auffällig sind, verworfen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PKZip wurde als Shareware vertrieben: Es konnte frei verwendet und kopiert werden, aber der Autor schlug den Benutzern vor, das Programm zu „registrieren“. </font><font style="vertical-align: inherit;">Für 47 US-Dollar erhalten Sie gedruckte Anweisungen, Premium-Support und eine erweiterte Version der App.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/031/509/4fc/0315094fc6917b61db8f78b2f776ce13.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine der Schlüsselversionen von PKZip war 2.04c, veröffentlicht am 28. Dezember 1992 ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Version 2.04g</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wurde kurz danach veröffentlicht </font><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Es wurde der Standard-Deflate-Komprimierungsalgorithmus verwendet. </font><font style="vertical-align: inherit;">Die Version bestimmte die Weiterentwicklung der Komprimierung in Zip-Dateien ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel zur Veröffentlichung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58e/bd3/69b/58ebd369bf36c272d0c8c7c9515fc670.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seitdem wurde das Zip-Format in vielen anderen Dateiformaten verwendet. </font><font style="vertical-align: inherit;">Beispielsweise verwenden Java-Archive (.jar), Android-Anwendungspakete (.apk) und Microsoft Office-DOCX-Dateien das Zip-Format. </font><font style="vertical-align: inherit;">Viele Formate und Protokolle verwenden denselben Komprimierungsalgorithmus, Deflate. </font><font style="vertical-align: inherit;">Angenommen, Webseiten werden wahrscheinlich als GZIP-Datei in Ihren Browser übertragen, deren Format die Deflate-Komprimierung verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Phil Katz starb im Jahr 2000. </font><font style="vertical-align: inherit;">PKWare existiert weiterhin und unterstützt das Zip-Format, obwohl sich das Unternehmen hauptsächlich auf Datenschutzsoftware konzentriert.</font></font><br>
<br>
<a name="3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Info-Zip und Zlib</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kurz nach der Veröffentlichung von PKZip im Jahr 1989 erschienen andere Programme zum Entpacken von Zip-Dateien. Zum Beispiel ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entpackungsprogramm</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das auf Unix-Systemen entpackt werden kann. Im März 1990 wurde eine Mailingliste namens Info-ZIP erstellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Info-ZIP-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gruppe </font><font style="vertical-align: inherit;">hat kostenlose Open-Source-Programme </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unzip</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zip veröffentlicht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mit denen Zip-Dateien entpackt und erstellt wurden. Der Code wurde auf viele Systeme portiert und ist immer noch der Standard für Zip-Programme für Unix-Systeme. Dies trug später dazu bei, die Popularität von Zip-Dateien zu erhöhen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobald die Info-Postleitzahl, die die Deflate-Komprimierung und -Dekomprimierung durchgeführt hat, in eine separate </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zlib-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothek verschoben wurde, </font><font style="vertical-align: inherit;">die sie geschrieben haben</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jean-loup Gailly</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Kompression) und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mark Adler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Auspacken).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68b/216/d1d/68b216d1debaffdb2d890067e38bed47.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jean-loup Gailly (links) und Mark Adler (rechts) beim </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USENIX STUG Award</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2009.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Einer der Gründe für die Erstellung der Bibliothek war die bequeme Verwendung der Deflate-Komprimierung in anderen Anwendungen und Formaten, z. B. im neuen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gzip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PNG</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Diese neuen Formate sollten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compress</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GIF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ersetzen </font><font style="vertical-align: inherit;">, die den patentgeschützten LZW-Algorithmus verwendeten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Rahmen der Erstellung dieser Formate verfasste Peter Deutsch die Deflate-Spezifikation und veröffentlichte sie </font><font style="vertical-align: inherit;">im Mai 1996 </font><font style="vertical-align: inherit;">unter dem Namen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internet RFC 1951</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies stellte sich als eine zugänglichere Beschreibung im Vergleich zum ursprünglichen PKZip-Anwendungshinweis heraus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heute wird zlib überall eingesetzt. </font><font style="vertical-align: inherit;">Vielleicht ist er jetzt dafür verantwortlich, diese Seite auf einem Webserver zu komprimieren und in Ihrem Browser zu entpacken. </font><font style="vertical-align: inherit;">Heutzutage werden die meisten Zip-Dateien mit zlib komprimiert und dekomprimiert.</font></font><br>
<br>
<a name="4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winzip</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele von denen, die PKZip nicht fanden, verwendeten WinZip. PC-Benutzer wechselten von DOS zu Windows und von PKZip zu WinZip. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles begann mit einem Projekt des Programmierers Nico Mac, der Software für OS / 2 bei der Mansfield Software Group in Storrs-Mansfield, Connecticut, entwickelte. Nico verwendete den Presentation Manager, dies ist eine grafische Benutzeroberfläche in OS / 2, und er war verärgert, dass er jedes Mal, wenn er Zip-Dateien erstellen wollte, von einem Dateimanager zu DOS-Befehlen wechseln musste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mac schrieb ein einfaches GUI-Programm, das direkt im Presentation Manager mit Zip-Dateien arbeitete, nannte es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PMZip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und veröffentlichte es in den 1990er Jahren als Shareware.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OS / 2 war nicht erfolgreich und die PC-Welt übernahm Microsoft Windows. </font><font style="vertical-align: inherit;">1991 beschloss Mac, das Schreiben von Windows-Programmen zu lernen, und sein erstes Projekt bestand darin, seine Zip-Anwendung auf ein neues Betriebssystem zu portieren. </font><font style="vertical-align: inherit;">Im April 1991 wurde </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WinZip 1.00 veröffentlicht</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es wurde als Shareware mit einer 21-tägigen Testphase und einer Registrierungsgebühr von 29 USD verteilt. </font><font style="vertical-align: inherit;">Sie sah so aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b1/2f4/bcd/0b12f4bcd048691aa0487b9d3a445b39.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den ersten Versionen von WinZip wurde PKZip unter der Haube verwendet. </font><font style="vertical-align: inherit;">Ab Version 5.0 im Jahr 1993 wurde Code aus Info-ZIP für die direkte Verarbeitung von Zip-Dateien verwendet. </font><font style="vertical-align: inherit;">Die Benutzeroberfläche hat sich ebenfalls schrittweise weiterentwickelt.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf4/273/962/bf427396212f63fba9c80db12fdd2132.png"></div><br>
<i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WinZip 6.3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unter Windows 3.11 für Arbeitsgruppen. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WinZip war in den 1990er Jahren eines der beliebtesten Shareware-Programme. </font><font style="vertical-align: inherit;">Am Ende hat es jedoch an Relevanz verloren, da die Unterstützung für Zip-Dateien in Betriebssysteme eingebettet wurde. </font><font style="vertical-align: inherit;">Windows arbeitet seit 2001 mit ihnen als „komprimierte Ordner“ (Windows XP), dafür wird die</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DynaZip-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothek verwendet</font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mac hieß ursprünglich Nico Mak Computing. </font><font style="vertical-align: inherit;">Im Jahr 2000 wurde es in WinZip Computing umbenannt und in diesen Jahren verließ Mack es. </font><font style="vertical-align: inherit;">Im Jahr 2005 verkaufte</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vector Capital das</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unternehmen</font><font style="vertical-align: inherit;">und am Ende ging es in den Besitz von</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Corel über</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das WinZip immer noch als Produkt herausbringt.</font></font><br>
<br>
<a name="5"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lempel-Ziv-Kompression (LZ77)</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Zip-Komprimierung besteht aus zwei Hauptbestandteilen: Lempel-Ziv-Komprimierung und Huffman-Code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Möglichkeit, den Text zu komprimieren, besteht darin, eine Liste gängiger Wörter oder Phrasen zu erstellen, wobei verschiedene Arten dieser Wörter im Text durch Links zum Wörterbuch ersetzt werden. Beispielsweise kann das lange Wort "Komprimierung" im Quelltext als # 1234 dargestellt werden, wobei sich 1234 auf die Position des Wortes in der Liste bezieht. Dies wird als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wörterbuchkomprimierung bezeichnet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter dem Gesichtspunkt der universellen Komprimierung weist dieses Verfahren jedoch mehrere Nachteile auf. Was genau sollte in das Wörterbuch aufgenommen werden? Die Quelldaten können in verschiedenen Sprachen vorliegen, es kann sich sogar um nicht lesbaren Text handeln. Und wenn das Wörterbuch nicht im Voraus zwischen Komprimierung und Dekomprimierung vereinbart wurde, muss es zusammen mit den komprimierten Daten gespeichert und übertragen werden, was den Vorteil der Komprimierung verringert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine elegante Lösung für dieses Problem besteht darin, die Quelldaten selbst als Wörterbuch zu verwenden. Im Jahr </font><font style="vertical-align: inherit;">1977 schlugen Jacob Ziv und Abraham Lempel (der bei Technion arbeitete), </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein universeller Algorithmus für die sequentielle Datenkomprimierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ein Komprimierungsschema vor, bei dem die Quelldaten als Folge von Tripletts dargestellt werden:</font></font><br>
<br>
<pre><code class="cpp hljs">(, , )
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
wo </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Rückwärtsverbindung zu der Folge von Zeichen bilden , </font><font style="vertical-align: inherit;">dass Sie von der vorherigen Position im ursprünglichen Text kopieren möchten, und </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dies ist das nächste Zeichen in den erzeugten Daten.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e5/21e/fdb/5e521efdb5649015f685e26ab308d1b9.jpg"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ce/cfa/2e3/2cecfa2e39798ce3302ff4b48e1a62ef.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abraham Lempel und Jacob Ziv. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie die folgenden Zeilen:</font></font><br>
<br>
<pre><code class="cpp hljs">It was the best of times,<font></font>
it was the worst of times,<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der zweiten Zeile kann die Sequenz "t was the w" als (26, 10, w) dargestellt werden, da sie neu erstellt wird, indem 10 Zeichen von der Position von 26 Zeichen zurück in den Buchstaben "w" kopiert werden. Für Zeichen, die noch nicht angezeigt wurden, werden Backlinks mit der Länge Null verwendet. Zum Beispiel kann das anfängliche "I" als (0, 0, I) dargestellt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Schema wird als Lempel-Ziv-Komprimierung oder LZ77-Komprimierung bezeichnet. In praktischen Implementierungen des Algorithmus wird jedoch normalerweise ein Teil des Tripletts nicht verwendet </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Stattdessen werden Zeichen einzeln generiert und ( </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Paare für Backlinks verwendet </font><font style="vertical-align: inherit;">(diese Option wird als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LZSS-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Komprimierung bezeichnet </font><font style="vertical-align: inherit;">). Wie </font><font style="vertical-align: inherit;">Literale und Backlinks </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codiert werden,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein separates Problem. Wir werden es im Folgenden bei der Analyse des Algorithmus berücksichtigen</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Entleerung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Text:</font></font><br>
<br>
<pre><code class="cpp hljs">It was the best of times,<font></font>
it was the worst of times,<font></font>
it was the age of wisdom,<font></font>
it was the age of foolishness,<font></font>
it was the epoch of belief,<font></font>
it was the epoch of incredulity,<font></font>
it was the season of Light,<font></font>
it was the season of Darkness,<font></font>
it was the spring of hope,<font></font>
it was the winter of despair,<font></font>
we had everything before us,<font></font>
we had nothing before us,<font></font>
we were all going direct to Heaven,<font></font>
we were all going direct the other way<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können Folgendes komprimieren:</font></font><br>
<br>
<pre><code class="cpp hljs">It was the best of times,<font></font>
i(<span class="hljs-number">26</span>,<span class="hljs-number">10</span>)wor(<span class="hljs-number">27</span>,<span class="hljs-number">24</span>)age(<span class="hljs-number">25</span>,<span class="hljs-number">4</span>)wisdom(<span class="hljs-number">26</span>,<span class="hljs-number">20</span>)<font></font>
foolishnes(<span class="hljs-number">57</span>,<span class="hljs-number">14</span>)epoch(<span class="hljs-number">33</span>,<span class="hljs-number">4</span>)belief(<span class="hljs-number">28</span>,<span class="hljs-number">22</span>)incredulity<font></font>
(<span class="hljs-number">33</span>,<span class="hljs-number">13</span>)season(<span class="hljs-number">34</span>,<span class="hljs-number">4</span>)Light(<span class="hljs-number">28</span>,<span class="hljs-number">23</span>)Dark(<span class="hljs-number">120</span>,<span class="hljs-number">17</span>)<font></font>
spring(<span class="hljs-number">31</span>,<span class="hljs-number">4</span>)hope(<span class="hljs-number">231</span>,<span class="hljs-number">14</span>)inter(<span class="hljs-number">27</span>,<span class="hljs-number">4</span>)despair,
<span class="hljs-function">we had <span class="hljs-title">everyth</span><span class="hljs-params">(<span class="hljs-number">57</span>,<span class="hljs-number">4</span>)</span>before <span class="hljs-title">us</span><span class="hljs-params">(<span class="hljs-number">29</span>,<span class="hljs-number">9</span>)</span><span class="hljs-title">no</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">20</span>)</span>
<span class="hljs-title">we</span><span class="hljs-params">(<span class="hljs-number">12</span>,<span class="hljs-number">3</span>)</span>all <span class="hljs-title">go</span><span class="hljs-params">(<span class="hljs-number">29</span>,<span class="hljs-number">4</span>)</span>direct to <span class="hljs-title">Heaven</span>
<span class="hljs-params">(<span class="hljs-number">36</span>,<span class="hljs-number">28</span>)</span><span class="hljs-params">(<span class="hljs-number">139</span>,<span class="hljs-number">3</span>)</span><span class="hljs-params">(<span class="hljs-number">83</span>,<span class="hljs-number">3</span>)</span><span class="hljs-params">(<span class="hljs-number">138</span>,<span class="hljs-number">3</span>)</span>way
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine der wichtigen Eigenschaften von Backlinks ist, dass sie sich überlappen können. </font><font style="vertical-align: inherit;">Dies geschieht, wenn die Länge größer als der Abstand ist. </font><font style="vertical-align: inherit;">Zum Beispiel:</font></font><br>
<br>
<pre><code class="cpp hljs">Fa-la-la-la-la
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können komprimieren auf:</font></font><br>
<br>
<pre><code class="cpp hljs">Fa-la(<span class="hljs-number">3</span>,<span class="hljs-number">9</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es mag Ihnen seltsam erscheinen, aber die Methode funktioniert: Nachdem die Bytes der ersten drei "-la" kopiert wurden, wird das Kopieren mit den neu generierten Bytes fortgesetzt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich ist dies eine Art der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codierung von Serienlängen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , bei der ein Teil der Daten wiederholt kopiert wird, um die gewünschte Länge zu erhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein interaktives Beispiel für die Verwendung der Lempel-Ziv-Komprimierung für Texte wird in einem Artikel von Colin Morris gezeigt. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Werden Pop-Texte immer repetitiver? </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Folgende ist ein Beispiel für das Kopieren von Backlinks in C. Bitte beachten Sie, dass wir aufgrund möglicher Überlappungen </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font><font style="vertical-align: inherit;">nicht verwenden können </font></font><code>memmove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Output the (dist,len) backref at dst_pos in dst. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lz77_output_backref</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_pos,
                                       <span class="hljs-keyword">size_t</span> dist, <span class="hljs-keyword">size_t</span> len)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;<font></font>
<font></font>
        assert(dist &lt;= dst_pos &amp;&amp; <span class="hljs-string">"cannot reference before beginning of dst"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {<font></font>
                dst[dst_pos] = dst[dst_pos - dist];<font></font>
                dst_pos++;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Generieren von Literalen ist einfach, aber der Vollständigkeit halber verwenden wir eine Hilfsfunktion:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Output lit at dst_pos in dst. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lz77_output_lit</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_pos, <span class="hljs-keyword">uint8_t</span> lit)</span>
</span>{<font></font>
        dst[dst_pos] = lit;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass der Aufrufer dieser Funktion sicherstellen muss, dass </font></font><code>dst</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genügend Platz für die generierten Daten vorhanden ist und dass der Backlink vor dem Start des Puffers nicht auf die Position zugreift. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist schwierig, beim Entpacken keine Daten mithilfe von Backlinks zu generieren, sondern diese beim Komprimieren der Quelldaten zuerst zu erstellen. Dies kann auf verschiedene Arten geschehen, aber wir werden die Methode verwenden, die auf Hash-Tabellen von zlib basiert, die in RFC 1951 vorgeschlagen wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden eine Hash-Tabelle mit den Positionen dreistelliger Präfixe verwenden, die zuvor in der Zeile gefunden wurden (kürzere Backlinks bringen keine Vorteile). Deflate erlaubt Backlinks innerhalb der vorherigen 32.768 Zeichen - dies wird als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fenster bezeichnet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies sorgt für eine Streaming-Komprimierung: Die Eingabedaten werden jeweils ein wenig verarbeitet, sofern das Fenster mit den letzten Bytes im Speicher gespeichert ist. Unsere Implementierung setzt jedoch voraus, dass uns alle Eingabedaten zur Verfügung stehen und dass wir sie gleichzeitig vollständig verarbeiten können. Auf diese Weise können Sie sich auf die Komprimierung konzentrieren und nicht auf die Abrechnung, die für die Stream-Verarbeitung erforderlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden zwei Arrays verwenden: in </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält den Hash-Wert des dreistelligen Präfixes für die Position in der Eingabe und in </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält die Position der vorherigen Position mit diesem Hash-Wert. Tatsächlich ist </font></font><code>head[h]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dies die Überschrift einer verknüpften Liste von Präfixpositionen mit einem Hash </font></font><code>h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>prev[x]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">empfängt das Element vor </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Liste.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LZ_WND_SIZE 32768</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LZ_MAX_LEN  258</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HASH_SIZE 15</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NO_POS    SIZE_MAX</span><font></font>
<font></font>
<span class="hljs-comment">/* Perform LZ77 compression on the len bytes in src. Returns false as soon as
   either of the callback functions returns false, otherwise returns true when
   all bytes have been processed. */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">lz77_compress</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> len,
                   <span class="hljs-keyword">bool</span> (*lit_callback)(<span class="hljs-keyword">uint8_t</span> lit, <span class="hljs-keyword">void</span> *aux),
                   <span class="hljs-keyword">bool</span> (*backref_callback)(<span class="hljs-keyword">size_t</span> dist, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">void</span> *aux),
                   <span class="hljs-keyword">void</span> *aux)</span>
</span>{
        <span class="hljs-keyword">size_t</span> head[<span class="hljs-number">1U</span> &lt;&lt; HASH_SIZE];
        <span class="hljs-keyword">size_t</span> prev[LZ_WND_SIZE];<font></font>
<font></font>
        <span class="hljs-keyword">uint16_t</span> h;
        <span class="hljs-keyword">size_t</span> i, j, dist;
        <span class="hljs-keyword">size_t</span> match_len, match_pos;
        <span class="hljs-keyword">size_t</span> prev_match_len, prev_match_pos;<font></font>
<font></font>
        <span class="hljs-comment">/* Initialize the hash table. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(head) / <span class="hljs-keyword">sizeof</span>(head[<span class="hljs-number">0</span>]); i++) {<font></font>
                head[i] = NO_POS;<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um eine neue Zeichenfolgenposition in die Hash-Tabelle einzufügen </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird sie aktualisiert, um die vorherige anzugeben </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und anschließend selbst aktualisiert </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert_hash</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> hash, <span class="hljs-keyword">size_t</span> pos, <span class="hljs-keyword">size_t</span> *head, <span class="hljs-keyword">size_t</span> *prev)</span>
</span>{<font></font>
        prev[pos % LZ_WND_SIZE] = head[hash];<font></font>
        head[hash] = pos;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Achten Sie beim Indizieren auf die Modulo-Operation </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Wir interessieren uns nur für die Positionen, die in das aktuelle Fenster fallen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anstatt den Hash-Wert für jedes dreistellige Präfix von Grund auf neu zu berechnen, verwenden wir einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ring-Hash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und aktualisieren ihn ständig, sodass nur die letzten drei Zeichen in seinem Wert wiedergegeben werden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint16_t</span> <span class="hljs-title">update_hash</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> hash, <span class="hljs-keyword">uint8_t</span> c)</span>
</span>{<font></font>
        hash &lt;&lt;= <span class="hljs-number">5</span>;                     <span class="hljs-comment">/* Shift out old bits. */</span>
        hash ^= c;                      <span class="hljs-comment">/* Include new bits. */</span>
        hash &amp;= (<span class="hljs-number">1U</span> &lt;&lt; HASH_SIZE) - <span class="hljs-number">1</span>;  <span class="hljs-comment">/* Mask off excess bits. */</span><font></font>
<font></font>
        <span class="hljs-keyword">return</span> hash;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hash-Karte kann dann verwendet werden, um effizient nach vorherigen Übereinstimmungen mit einer Sequenz zu suchen, wie unten gezeigt. </font><font style="vertical-align: inherit;">Die Suche nach Übereinstimmungen ist die ressourcenintensivste Komprimierungsoperation, daher wird die Suchtiefe in der Liste begrenzt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch Ändern verschiedener Parameter, z. B. der Suchtiefe in der Liste der Präfixe und Durchführen von verzögerten Vergleichen, wie unten beschrieben, können Sie die Geschwindigkeit erhöhen, indem Sie den Komprimierungsgrad verringern. </font><font style="vertical-align: inherit;">Die Einstellungen in unserem Code werden so ausgewählt, dass sie der maximalen Komprimierungsstufe in zlib entsprechen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Find the longest most recent string which matches the string starting
 * at src[pos]. The match must be strictly longer than prev_match_len and
 * shorter or equal to max_match_len. Returns the length of the match if found
 * and stores the match position in *match_pos, otherwise returns zero. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">find_match</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> pos, <span class="hljs-keyword">uint16_t</span> hash,
                         <span class="hljs-keyword">size_t</span> prev_match_len, <span class="hljs-keyword">size_t</span> max_match_len,
                         <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> *head, <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> *prev,
                         <span class="hljs-keyword">size_t</span> *match_pos)</span>
</span>{
        <span class="hljs-keyword">size_t</span> max_match_steps = <span class="hljs-number">4096</span>;
        <span class="hljs-keyword">size_t</span> i, l;
        <span class="hljs-keyword">bool</span> found;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (prev_match_len == <span class="hljs-number">0</span>) {
                <span class="hljs-comment">/* We want backrefs of length 3 or longer. */</span>
                prev_match_len = <span class="hljs-number">2</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (prev_match_len &gt;= max_match_len) {
                <span class="hljs-comment">/* A longer match would be too long. */</span>
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (prev_match_len &gt;= <span class="hljs-number">32</span>) {
                <span class="hljs-comment">/* Do not try too hard if there is already a good match. */</span>
                max_match_steps /= <span class="hljs-number">4</span>;<font></font>
        }<font></font>
<font></font>
        found = <span class="hljs-literal">false</span>;<font></font>
        i = head[hash];<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (max_match_steps != <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (i == NO_POS) {
                        <span class="hljs-comment">/* No match. */</span>
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
<font></font>
                assert(i &lt; pos &amp;&amp; <span class="hljs-string">"Matches should precede pos."</span>);
                <span class="hljs-keyword">if</span> (pos - i &gt; LZ_WND_SIZE) {
                        <span class="hljs-comment">/* The match is outside the window. */</span>
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
<font></font>
                l = cmp(src, i, pos, prev_match_len, max_match_len);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (l != <span class="hljs-number">0</span>) {<font></font>
                        assert(l &gt; prev_match_len);<font></font>
                        assert(l &lt;= max_match_len);<font></font>
<font></font>
                        found = <span class="hljs-literal">true</span>;<font></font>
                        *match_pos = i;<font></font>
                        prev_match_len = l;<font></font>
<font></font>
                        <span class="hljs-keyword">if</span> (l == max_match_len) {
                                <span class="hljs-comment">/* A longer match is not possible. */</span>
                                <span class="hljs-keyword">return</span> l;<font></font>
                        }<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Look further back in the prefix list. */</span><font></font>
                i = prev[i % LZ_WND_SIZE];<font></font>
                max_match_steps--;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!found) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> prev_match_len;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Compare the substrings starting at src[i] and src[j], and return the length
 * of the common prefix. The match must be strictly longer than prev_match_len
 * and shorter or equal to max_match_len. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> i, <span class="hljs-keyword">size_t</span> j,
                  <span class="hljs-keyword">size_t</span> prev_match_len, <span class="hljs-keyword">size_t</span> max_match_len)</span>
</span>{
        <span class="hljs-keyword">size_t</span> l;<font></font>
<font></font>
        assert(prev_match_len &lt; max_match_len);<font></font>
<font></font>
        <span class="hljs-comment">/* Check whether the first prev_match_len + 1 characters match. Do this
         * backwards for a higher chance of finding a mismatch quickly. */</span>
        <span class="hljs-keyword">for</span> (l = <span class="hljs-number">0</span>; l &lt; prev_match_len + <span class="hljs-number">1</span>; l++) {
                <span class="hljs-keyword">if</span> (src[i + prev_match_len - l] !=<font></font>
                    src[j + prev_match_len - l]) {<font></font>
                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        assert(l == prev_match_len + <span class="hljs-number">1</span>);<font></font>
<font></font>
        <span class="hljs-comment">/* Now check how long the full match is. */</span>
        <span class="hljs-keyword">for</span> (; l &lt; max_match_len; l++) {
                <span class="hljs-keyword">if</span> (src[i + l] != src[j + l]) {
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        assert(l &gt; prev_match_len);<font></font>
        assert(l &lt;= max_match_len);<font></font>
        assert(<span class="hljs-built_in">memcmp</span>(&amp;src[i], &amp;src[j], l) == <span class="hljs-number">0</span>);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> l;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können die Funktion mit </font></font><code>lz77_compress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem Code </font><font style="vertical-align: inherit;">beenden </font><font style="vertical-align: inherit;">, um nach vorherigen Übereinstimmungen zu suchen:</font></font><br>
<br>
<pre><code class="cpp hljs">       <span class="hljs-comment">/* h is the hash of the three-byte prefix starting at position i. */</span>
        h = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (len &gt;= <span class="hljs-number">2</span>) {<font></font>
                h = update_hash(h, src[<span class="hljs-number">0</span>]);<font></font>
                h = update_hash(h, src[<span class="hljs-number">1</span>]);<font></font>
        }<font></font>
<font></font>
        prev_match_len = <span class="hljs-number">0</span>;<font></font>
        prev_match_pos = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i + <span class="hljs-number">2</span> &lt; len; i++) {<font></font>
                h = update_hash(h, src[i + <span class="hljs-number">2</span>]);<font></font>
<font></font>
                <span class="hljs-comment">/* Search for a match using the hash table. */</span><font></font>
                match_len = find_match(src, i, h, prev_match_len,<font></font>
                                       min(LZ_MAX_LEN, len - i), head, prev,<font></font>
                                       &amp;match_pos);<font></font>
<font></font>
                <span class="hljs-comment">/* Insert the current hash for future searches. */</span><font></font>
                insert_hash(h, i, head, prev);<font></font>
<font></font>
                <span class="hljs-comment">/* If the previous match is at least as good as the current. */</span>
                <span class="hljs-keyword">if</span> (prev_match_len != <span class="hljs-number">0</span> &amp;&amp; prev_match_len &gt;= match_len) {
                        <span class="hljs-comment">/* Output the previous match. */</span>
                        dist = (i - <span class="hljs-number">1</span>) - prev_match_pos;
                        <span class="hljs-keyword">if</span> (!backref_callback(dist, prev_match_len, aux)) {
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                        }<font></font>
                        <span class="hljs-comment">/* Move past the match. */</span>
                        <span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; min((i - <span class="hljs-number">1</span>) + prev_match_len,<font></font>
                                                len - <span class="hljs-number">2</span>); j++) {<font></font>
                                h = update_hash(h, src[j + <span class="hljs-number">2</span>]);<font></font>
                                insert_hash(h, j, head, prev);<font></font>
                        }<font></font>
                        i = (i - <span class="hljs-number">1</span>) + prev_match_len - <span class="hljs-number">1</span>;<font></font>
                        prev_match_len = <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* If no match (and no previous match), output literal. */</span>
                <span class="hljs-keyword">if</span> (match_len == <span class="hljs-number">0</span>) {<font></font>
                        assert(prev_match_len == <span class="hljs-number">0</span>);
                        <span class="hljs-keyword">if</span> (!lit_callback(src[i], aux)) {
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Otherwise the current match is better than the previous. */</span><font></font>
<font></font>
                <span class="hljs-keyword">if</span> (prev_match_len != <span class="hljs-number">0</span>) {
                        <span class="hljs-comment">/* Output a literal instead of the previous match. */</span>
                        <span class="hljs-keyword">if</span> (!lit_callback(src[i - <span class="hljs-number">1</span>], aux)) {
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                        }<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Defer this match and see if the next is even better. */</span><font></font>
                prev_match_len = match_len;<font></font>
                prev_match_pos = match_pos;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Output any previous match. */</span>
        <span class="hljs-keyword">if</span> (prev_match_len != <span class="hljs-number">0</span>) {<font></font>
                dist = (i - <span class="hljs-number">1</span>) - prev_match_pos;
                <span class="hljs-keyword">if</span> (!backref_callback(dist, prev_match_len, aux)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                i = (i - <span class="hljs-number">1</span>) + prev_match_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Output any remaining literals. */</span>
        <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
                <span class="hljs-keyword">if</span> (!lit_callback(src[i], aux)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code sucht nach dem längsten Backlink, der an der aktuellen Position generiert werden kann. Vor der Ausgabe entscheidet das Programm jedoch, ob es möglich ist, an der nächsten Position eine noch längere Übereinstimmung zu finden. In zlib wird dies als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verzögerte Vergleichsbewertung bezeichnet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies ist immer noch ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gieriger</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithmus: Er wählt die längste Übereinstimmung aus, auch wenn die aktuell kürzere es Ihnen ermöglicht, später eine Übereinstimmung noch länger zu erzielen und eine stärkere Komprimierung zu erzielen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Lempel-Ziv-Komprimierung kann sowohl schnell als auch langsam arbeiten. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zopfli</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verbrachte viel Zeit damit, nach optimalen Backlinks zu suchen, um zusätzliche Komprimierungsprozentsätze zu erzielen. Dies ist nützlich für Daten, die einmal komprimiert und dann wiederverwendet werden, z. B. für statische Informationen auf einem Webserver. Auf der anderen Seite der Skala befinden sich Kompressoren wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Snappy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LZ4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die nur mit dem letzten 4-Byte-Präfix verglichen werden und sehr schnell sind. Diese Art der Komprimierung ist in Datenbanken und RPC-Systemen nützlich, in denen sich die für die Komprimierung aufgewendete Zeit auszahlt, indem Zeit beim Senden von Daten über ein Netzwerk oder auf die Festplatte gespart wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee, Quelldaten als Wörterbuch zu verwenden, ist sehr elegant, aber Sie können auch von einem statischen Wörterbuch profitieren. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brotli</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein LZ77-basierter Algorithmus, der jedoch auch einen großen verwendet</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">statisches Wörterbuch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Zeichenfolge, die häufig im Netzwerk gefunden werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der LZ77-Code kann </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in lz77.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lz77.c angezeigt werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="6"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman-Code</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite Zip-Komprimierungsalgorithmus ist der Huffman-Code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Begriff </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bezieht sich in diesem Zusammenhang auf ein System zur Darstellung von Daten in einer anderen Form. </font><font style="vertical-align: inherit;">In diesem Fall interessieren wir uns für Code, mit dem vom Lempel-Ziv-Algorithmus generierte Literale und Backlinks effizient dargestellt werden können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Traditionell wird englischer Text unter Verwendung des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">amerikanischen Standardcodes für den Informationsaustausch (ASCII) dargestellt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dieses System weist jedem Zeichen eine Nummer zu, die normalerweise in einer 8-Bit-Darstellung gespeichert ist. </font><font style="vertical-align: inherit;">Hier sind die ASCII-Codes für die Großbuchstaben des englischen Alphabets:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EIN</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">01000001</font></font></td>
<td><strong>N</strong></td>
<td>01001110</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td>01000010</td>
<td><strong>O</strong></td>
<td>01001111</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>01000011</td>
<td><strong>P</strong></td>
<td>01010000</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td>01000100</td>
<td><strong>Q</strong></td>
<td>01010001</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>01000101</td>
<td><strong>R</strong></td>
<td>01010010</td>
</tr>
<tr>
<td><strong>F</strong></td>
<td>01000110</td>
<td><strong>S</strong></td>
<td>01010011</td>
</tr>
<tr>
<td><strong>G</strong></td>
<td>01000111</td>
<td><strong>T</strong></td>
<td>01010100</td>
</tr>
<tr>
<td><strong>H</strong></td>
<td>01001000</td>
<td><strong>U</strong></td>
<td>01010101</td>
</tr>
<tr>
<td><strong>I</strong></td>
<td>01001001</td>
<td><strong>V</strong></td>
<td>01010110</td>
</tr>
<tr>
<td><strong>J</strong></td>
<td>01001010</td>
<td><strong>W</strong></td>
<td>01010111</td>
</tr>
<tr>
<td><strong>K</strong></td>
<td>01001011</td>
<td><strong>X</strong></td>
<td>01011000</td>
</tr>
<tr>
<td><strong>L</strong></td>
<td>01001100</td>
<td><strong>Y</strong></td>
<td>01011001</td>
</tr>
<tr>
<td><strong>M</strong></td>
<td>01001101</td>
<td><strong>Z</strong></td>
<td>01011010</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Byte pro Zeichen ist eine bequeme Möglichkeit, Text zu speichern. Sie können leicht auf Teile des Textes zugreifen oder diese ändern, und es ist immer klar, wie viele Bytes zum Speichern von N Zeichen erforderlich sind oder wie viele Zeichen in N Bytes gespeichert sind. Dies ist jedoch nicht der effektivste Weg in Bezug auf den belegten Raum. Beispielsweise wird im Englischen der Buchstabe E am häufigsten verwendet, und Z wird am wenigsten verwendet. In Bezug auf das Volumen ist es daher effizienter, eine kürzere Bitdarstellung für E und eine längere für Z zu verwenden, anstatt jedem Zeichen die gleiche Anzahl von Bits zuzuweisen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Code, der Codierungen unterschiedlicher Länge für unterschiedliche Quellzeichen angibt, wird als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code variabler Länge bezeichnet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das bekannteste Beispiel ist der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Morsecode.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, in dem jedes Zeichen mit Punkten und Strichen codiert ist, die ursprünglich per Telegraph mit kurzen und langen Impulsen übertragen wurden:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EIN</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• -</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- •</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- • • •</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ö</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- - -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- • - •</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• - - •</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- • •</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- - • -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• •</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• - •</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• • - •</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• • •</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- - • •</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• • • •</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• • -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ich</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• • •</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• • • -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• - - -</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• - -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- • -</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- • • -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">• - • •</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- • - -</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- -</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z.</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- - • •</font></font></strong></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einer der Nachteile des Morsecodes besteht darin, dass ein Codewort ein Präfix eines anderen sein kann. Zum Beispiel hat • • - • keine eindeutige Dekodierung: Es kann F oder ER sein. Dies wird durch Pausen (drei Punkte lang) zwischen den Buchstaben während der Übertragung gelöst. Es wäre jedoch besser, wenn Codewörter keine Präfixe anderer Wörter sein könnten. Dieser Code wird als nicht neu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fixiert bezeichnet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . ASCII-Code mit fester Länge wird nicht neu fixiert, da Codewörter immer dieselbe Länge haben. Codes mit variabler Länge können jedoch auch nicht neu fixiert werden. Telefonnummern werden oft nicht fixiert. Bevor die Notrufnummer 112 in Schweden eingeführt wurde, mussten alle Nummern, die mit 112 beginnen, geändert werden. In den USA gibt es keine einzige Telefonnummer, die mit 911 beginnt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Größe der codierten Nachricht zu minimieren, ist es besser, einen nicht fixierten Code zu verwenden, in dem häufig vorkommende Zeichen kürzere Codewörter haben. </font><font style="vertical-align: inherit;">Der optimale Code ist derjenige, der das kürzestmögliche Ergebnis generiert - die Summe der Längen von Codewörtern multipliziert mit ihrer Häufigkeit ist das minimal mögliche. </font><font style="vertical-align: inherit;">Dies wird zu </font><font style="vertical-align: inherit;">Ehren des Erfinders eines effizienten Algorithmus zum Erzeugen solcher Codes </font><font style="vertical-align: inherit;">als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht-Präfix-Code mit minimaler Redundanz</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als Huffman-Code bezeichnet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="7"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman-Algorithmus</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während des Studiums der Materialien für seine Doktorarbeit über Elektrotechnik am MIT besuchte David Huffman einen Kurs über Informationstheorie, der von Robert Fano unterrichtet wurde. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Legende nach</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erlaubte Fano seinen Schülern zu wählen: Schreiben Sie die Abschlussprüfung oder den Kurs. Huffman entschied sich für Letzteres und erhielt das Thema der Suche nach präfixlosen Codes mit minimaler Redundanz. Es wird angenommen, dass er nicht wusste, dass Fano zu dieser Zeit selbst an dieser Aufgabe arbeitete (der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shannon-Fano-Algorithmus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> war in jenen Jahren die bekannteste Methode </font><font style="vertical-align: inherit;">). Huffmans Arbeit wurde 1952 unter dem Titel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Methode zur Konstruktion von Mindestredundanzcodes veröffentlicht. Seitdem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ihr Algorithmus weit verbreitet.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf0/4fe/003/cf04fe00303a663594eea8e8db063002.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">David Huffman </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pressemitteilung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UC Santa Cruz. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Huffman-Algorithmus erstellt nicht neu fixierten Code mit minimaler Redundanz für den Zeichensatz und dessen Verwendungshäufigkeit. </font><font style="vertical-align: inherit;">Der Algorithmus wählt wiederholt zwei Zeichen aus, die in den Quelldaten am wenigsten wahrscheinlich sind - beispielsweise X und Y - und ersetzt sie durch ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zusammengesetztes Zeichen,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das „X oder Y“ bedeutet. </font><font style="vertical-align: inherit;">Die Häufigkeit des Auftretens eines zusammengesetzten Symbols ist die Summe der Häufigkeiten zweier Quellensymbole. </font><font style="vertical-align: inherit;">Die Codewörter für X und Y können beliebige Codewörter sein, die dem zusammengesetzten Zeichen "X oder Y" gefolgt von 0 oder 1 zugewiesen werden, um die ursprünglichen Zeichen zu unterscheiden. </font><font style="vertical-align: inherit;">Wenn die Eingabedaten auf ein Zeichen reduziert werden, funktioniert der Algorithmus nicht mehr ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Videoerklärung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist ein Beispiel für den Algorithmus, der an einem kleinen Zeichensatz arbeitet:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frequenz</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EIN</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erste Iteration der Verarbeitung:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e90/a8f/4e4/e90a8f4e47c49cd14ca3a55f884d55e3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die beiden seltensten Symbole C und D werden aus der Menge entfernt und durch ein zusammengesetztes Symbol ersetzt, dessen Frequenz die Summe der Frequenzen C und D ist:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e9/b0b/aed/7e9b0baeda34fc4d368c933bed7e1d15.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt sind die seltensten Symbole B und ein zusammengesetztes Symbol mit einer Häufigkeit von 5. Sie werden aus dem Satz entfernt und durch ein zusammengesetztes Symbol mit einer Häufigkeit von 9 ersetzt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bca/94b/ad6/bca94bad698775402e8bab2c6a20f664.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich werden A und ein zusammengesetztes Symbol mit einer Frequenz von 9 zu einem neuen Symbol mit einer Frequenz von 15 kombiniert:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/260/aa3/800/260aa38005cf701421881214915d859a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der gesamte Satz wurde auf ein Zeichen reduziert, die Verarbeitung ist abgeschlossen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Algorithmus erstellte eine Struktur namens </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman-Baum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Eingabezeichen sind Blätter, und je höher die Häufigkeit eines Zeichens ist, desto höher befindet es sich. </font><font style="vertical-align: inherit;">Ausgehend von der Wurzel des Baums können Sie Codewörter für Zeichen generieren, indem Sie 0 oder 1 hinzufügen, wenn Sie sich nach links bzw. rechts bewegen. </font><font style="vertical-align: inherit;">Es stellt sich so heraus:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Codewort</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EIN</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kein Codewort ist ein Präfix für ein anderes. Je öfter ein Symbol vorkommt, desto kürzer ist sein Codewort. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Baum kann auch zum Dekodieren verwendet werden: Wir beginnen bei der Wurzel und gehen nach rechts oder links für den Wert mit 0 oder 1 vor dem Zeichen. Beispielsweise wird die Zeile 010100 in ABBA decodiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass die Länge jedes Codeworts der Tiefe des entsprechenden Baumknotens entspricht. Wie wir im nächsten Teil sehen werden, benötigen wir keinen echten Baum, um Codewörter zuzuweisen. Es reicht aus, die Länge der Wörter selbst zu kennen. Das Ergebnis unserer Implementierung des Huffman-Algorithmus ist daher die Länge der Codewörter. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Zeichensatz zu speichern und die niedrigsten Frequenzen effizient zu finden, verwenden wir die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">binäre Heap-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datenstruktur </font><font style="vertical-align: inherit;">. Insbesondere interessieren uns</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Min-Heap</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , da der Mindestwert oben liegen sollte.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Swap the 32-bit values pointed to by a and b. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap32</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> *a, <span class="hljs-keyword">uint32_t</span> *b)</span>
</span>{
        <span class="hljs-keyword">uint32_t</span> tmp;<font></font>
<font></font>
        tmp = *a;<font></font>
        *a = *b;<font></font>
        *b = tmp;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Move element i in the n-element heap down to restore the minheap property. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">minheap_down</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> *heap, <span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">size_t</span> i)</span>
</span>{
        <span class="hljs-keyword">size_t</span> left, right, min;<font></font>
<font></font>
        assert(i &gt;= <span class="hljs-number">1</span> &amp;&amp; i &lt;= n &amp;&amp; <span class="hljs-string">"i must be inside the heap"</span>);<font></font>
<font></font>
        <span class="hljs-comment">/* While the ith element has at least one child. */</span>
        <span class="hljs-keyword">while</span> (i * <span class="hljs-number">2</span> &lt;= n) {<font></font>
                left = i * <span class="hljs-number">2</span>;<font></font>
                right = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<font></font>
<font></font>
                <span class="hljs-comment">/* Find the child with lowest value. */</span><font></font>
                min = left;<font></font>
                <span class="hljs-keyword">if</span> (right &lt;= n &amp;&amp; heap[right] &lt; heap[left]) {<font></font>
                        min = right;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Move i down if it is larger. */</span>
                <span class="hljs-keyword">if</span> (heap[min] &lt; heap[i]) {<font></font>
                        swap32(&amp;heap[min], &amp;heap[i]);<font></font>
                        i = min;<font></font>
                } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Establish minheap property for heap[1..n]. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">minheap_heapify</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> *heap, <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;<font></font>
<font></font>
        <span class="hljs-comment">/* Floyd's algorithm. */</span>
        <span class="hljs-keyword">for</span> (i = n / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; i--) {<font></font>
                minheap_down(heap, n, i);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Häufigkeit von </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeichen </font><font style="vertical-align: inherit;">zu verfolgen </font><font style="vertical-align: inherit;">, werden wir eine Reihe von </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elementen verwenden. </font><font style="vertical-align: inherit;">Außerdem möchten wir jedes Mal, wenn ein zusammengesetztes Symbol erstellt wird, beide Quellensymbole damit verknüpfen. </font><font style="vertical-align: inherit;">Daher hat jedes Symbol ein „Kommunikationselement“. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den </font><font style="vertical-align: inherit;">Elementelement- </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heap und die </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kommunikationselemente </font><font style="vertical-align: inherit;">zu speichern </font><font style="vertical-align: inherit;">, verwenden wir ein Array von </font></font><code>n * 2 + 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elementen. </font><font style="vertical-align: inherit;">Wenn zwei Zeichen auf dem Heap durch eines ersetzt werden, verwenden wir das zweite Element, um den Link zum neuen Zeichen zu speichern. </font><font style="vertical-align: inherit;">Dieser Ansatz basiert auf der Implementierung der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwaltung von Gigabyte von</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Witten, Moffat und Bell.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An jedem Knoten im Heap werden die 16 höchstwertigen Bits zum Speichern der Symbolfrequenz und die 16 niedrigstwertigen Bits zum Speichern des Index des Symbolkommunikationselements verwendet. Aufgrund der Verwendung hoher Bits wird die Frequenzdifferenz durch das Ergebnis eines 32-Bit-Vergleichs zwischen zwei Elementen des Heaps bestimmt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund dieser Darstellung müssen wir sicherstellen, dass die Häufigkeit der Zeichen immer in 16 Bit passt. Nach Abschluss des Algorithmus hat das endgültige zusammengesetzte Symbol die Häufigkeit aller kombinierten Symbole, dh diese Summe sollte in 16 Bit angegeben werden. Unsere Deflate-Implementierung überprüft dies, indem sie gleichzeitig bis zu 64.535 Zeichen verarbeitet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Symbole mit einer Frequenz von Null erhalten Codewörter mit einer Länge von Null und nehmen nicht an der Kompilierung der Codierung teil.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Codewort die angegebene maximale Tiefe erreicht, werden wir die Häufigkeitsverteilung durch Auferlegen einer Frequenzbegrenzung „glätten“ und es erneut versuchen (ja, mit Hilfe </font></font><code>goto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Es gibt ausgefeiltere Möglichkeiten, eine tiefenbegrenzte Huffman-Codierung durchzuführen, aber diese ist einfach und effizient.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_HUFFMAN_SYMBOLS 288      <span class="hljs-comment">/* Deflate uses max 288 symbols. */</span></span><font></font>
<font></font>
<span class="hljs-comment">/* Construct a Huffman code for n symbols with the frequencies in freq, and
 * codeword length limited to max_len. The sum of the frequencies must be &lt;=
 * UINT16_MAX. max_len must be large enough that a code is always possible,
 * i.e. 2 ** max_len &gt;= n. Symbols with zero frequency are not part of the code
 * and get length zero. Outputs the codeword lengths in lengths[0..n-1]. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">compute_huffman_lengths</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> *freqs, <span class="hljs-keyword">size_t</span> n,
                                    <span class="hljs-keyword">uint8_t</span> max_len, <span class="hljs-keyword">uint8_t</span> *lengths)</span>
</span>{
        <span class="hljs-keyword">uint32_t</span> nodes[MAX_HUFFMAN_SYMBOLS * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>], p, q;
        <span class="hljs-keyword">uint16_t</span> freq;
        <span class="hljs-keyword">size_t</span> i, h, l;
        <span class="hljs-keyword">uint16_t</span> freq_cap = UINT16_MAX;<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span>
        <span class="hljs-keyword">uint32_t</span> freq_sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                freq_sum += freqs[i];<font></font>
        }<font></font>
        assert(freq_sum &lt;= UINT16_MAX &amp;&amp; <span class="hljs-string">"Frequency sum too large!"</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
        assert(n &lt;= MAX_HUFFMAN_SYMBOLS);<font></font>
        assert((<span class="hljs-number">1U</span> &lt;&lt; max_len) &gt;= n &amp;&amp; <span class="hljs-string">"max_len must be large enough"</span>);<font></font>
<font></font>
try_again:<font></font>
        <span class="hljs-comment">/* Initialize the heap. h is the heap size. */</span>
        h = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                freq = freqs[i];<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (freq == <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">/* Ignore zero-frequency symbols. */</span><font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (freq &gt; freq_cap) {<font></font>
                        freq = freq_cap; <span class="hljs-comment">/* Enforce the frequency cap. */</span><font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* High 16 bits: Symbol frequency.
                   Low 16 bits:  Symbol link element index. */</span><font></font>
                h++;<font></font>
                nodes[h] = ((<span class="hljs-keyword">uint32_t</span>)freq &lt;&lt; <span class="hljs-number">16</span>) | (<span class="hljs-keyword">uint32_t</span>)(n + h);<font></font>
        }<font></font>
        minheap_heapify(nodes, h);<font></font>
<font></font>
        <span class="hljs-comment">/* Special case for less than two non-zero symbols. */</span>
        <span class="hljs-keyword">if</span> (h &lt; <span class="hljs-number">2</span>) {
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                        lengths[i] = (freqs[i] == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Build the Huffman tree. */</span>
        <span class="hljs-keyword">while</span> (h &gt; <span class="hljs-number">1</span>) {
                <span class="hljs-comment">/* Remove the lowest frequency node p from the heap. */</span>
                p = nodes[<span class="hljs-number">1</span>];<font></font>
                nodes[<span class="hljs-number">1</span>] = nodes[h--];<font></font>
                minheap_down(nodes, h, <span class="hljs-number">1</span>);<font></font>
<font></font>
                <span class="hljs-comment">/* Get q, the next lowest frequency node. */</span>
                q = nodes[<span class="hljs-number">1</span>];<font></font>
<font></font>
                <span class="hljs-comment">/* Replace q with a new symbol with the combined frequencies of
                   p and q, and with the no longer used h+1'th node as the
                   link element. */</span>
                nodes[<span class="hljs-number">1</span>] = ((p &amp; <span class="hljs-number">0xffff0000</span>) + (q &amp; <span class="hljs-number">0xffff0000</span>))<font></font>
                           | (<span class="hljs-keyword">uint32_t</span>)(h + <span class="hljs-number">1</span>);<font></font>
<font></font>
                <span class="hljs-comment">/* Set the links of p and q to point to the link element of
                   the new node. */</span>
                nodes[p &amp; <span class="hljs-number">0xffff</span>] = nodes[q &amp; <span class="hljs-number">0xffff</span>] = (<span class="hljs-keyword">uint32_t</span>)(h + <span class="hljs-number">1</span>);<font></font>
<font></font>
                <span class="hljs-comment">/* Move the new symbol down to restore heap property. */</span>
                minheap_down(nodes, h, <span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Compute the codeword length for each symbol. */</span>
        h = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {
                <span class="hljs-keyword">if</span> (freqs[i] == <span class="hljs-number">0</span>) {<font></font>
                        lengths[i] = <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
                h++;<font></font>
<font></font>
                <span class="hljs-comment">/* Link element for the i'th symbol. */</span><font></font>
                p = nodes[n + h];<font></font>
<font></font>
                <span class="hljs-comment">/* Follow the links until we hit the root (link index 2). */</span>
                l = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">while</span> (p != <span class="hljs-number">2</span>) {<font></font>
                        l++;<font></font>
                        p = nodes[p];<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (l &gt; max_len) {
                        <span class="hljs-comment">/* Lower freq_cap to flatten the distribution. */</span>
                        assert(freq_cap != <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-string">"Cannot lower freq_cap!"</span>);<font></font>
                        freq_cap /= <span class="hljs-number">2</span>;
                        <span class="hljs-keyword">goto</span> try_again;<font></font>
                }<font></font>
<font></font>
                assert(l &lt;= UINT8_MAX);<font></font>
                lengths[i] = (<span class="hljs-keyword">uint8_t</span>)l;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine elegante Alternative zur binären Heap-Option besteht darin, Zeichen in zwei Warteschlangen zu speichern. </font><font style="vertical-align: inherit;">Das erste enthält die Quellzeichen, sortiert nach Häufigkeit. </font><font style="vertical-align: inherit;">Wenn ein zusammengesetztes Symbol erstellt wird, wird es sekundär hinzugefügt. </font><font style="vertical-align: inherit;">Somit befindet sich das Symbol mit der niedrigsten Frequenz immer an der ersten Position einer der Warteschlangen. </font><font style="vertical-align: inherit;">Dieser Ansatz wird von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jan van Leeuwen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Über die Konstruktion von Huffman-Bäumen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (1976) beschrieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Huffman-Codierung ist optimal für Nicht-Präfix-Codes, in anderen Fällen gibt es jedoch effizientere Methoden: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arithmetische Codierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asymmetrische Zahlensysteme</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="8"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffmans kanonische Codes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im obigen Beispiel haben wir einen Huffman-Baum erstellt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/260/aa3/800/260aa38005cf701421881214915d859a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir von der Wurzel gehen und 0 für den linken Zweig und 1 für den rechten verwenden, erhalten wir die folgenden Codes:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Codewort</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EIN</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Entscheidung, 0 für den linken Zweig und 1 für den rechten Zweig zu verwenden, scheint willkürlich. </font><font style="vertical-align: inherit;">Wenn wir das Gegenteil tun, erhalten wir:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Codewort</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EIN</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">01</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">001</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können zwei Zweige, die von einem Knoten stammen, willkürlich mit Null und Eins markieren (Hauptsache, die Bezeichnungen sind unterschiedlich) und trotzdem den entsprechenden Code erhalten:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29b/acb/499/29bacb4999e9a3f530f22634846a97b7.png"></div><br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Codewort</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EIN</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elf</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">101</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl der Huffman-Algorithmus die erforderlichen Codewortlängen für nicht fixierten Code mit minimaler Redundanz bereitstellt, gibt es viele Möglichkeiten, einzelne Codewörter zuzuweisen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angesichts der Länge des vom Huffman-Algorithmus berechneten Codeworts weist der kanonische Huffman-Code Zeichen auf bestimmte Weise Codewörter zu. Dies ist nützlich, da Sie damit Codewortlängen mit komprimierten Daten speichern und übertragen können: Der Decoder kann Codewörter basierend auf ihren Längen wiederherstellen. Natürlich können Sie Symbolfrequenzen speichern und übertragen und den Huffman-Algorithmus im Decoder ausführen, dies erfordert jedoch mehr Arbeit und mehr Speicherplatz vom Decoder. Eine weitere sehr wichtige Eigenschaft ist, dass die Struktur kanonischer Codes eine effiziente Decodierung verwendet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee ist, Zeichen nacheinander untereinander Codewörter zuzuweisen. Das erste Codewort ist 0. Das nächste ist ein Wort mit einer Länge des vorherigen Wortes + 1. Das erste Wort mit einer Länge von N besteht aus dem letzten Wort der Länge N-1, wobei eins hinzugefügt wird (um ein neues Codewort zu erhalten) und ein Schritt nach links verschoben wird (um die Länge zu erhöhen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Terminologie des Hoffman-Baums werden den Wörtern nacheinander Codewörter in der Reihenfolge von links nach rechts zugewiesen, und zwar eine Ebene nach der anderen, wobei sie sich beim Übergang zur nächsten Ebene nach links verschieben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem ABCD-Beispiel hat der Huffman-Algorithmus Codewörter mit Längen von 1, 2, 3 und 3 zugewiesen. Das erste Wort ist 0. Dies ist auch das letzte Wort der Länge 1. Für die Länge 2 nehmen wir 0 und addieren 1, um den nächsten Code zu erhalten, der zum Präfix von Zwei-Bit-Codes wird Verschieben Sie nach links und erhalten Sie 10. Dies ist nun das letzte Wort der Länge 2. Um die Länge 3 zu erhalten, addieren wir 1 und verschieben: 110. Um das nächste Wort der Länge 3 zu erhalten, addieren wir 1: 111.</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Codewort</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EIN</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Implementierung des kanonischen Codegenerators ist unten dargestellt. </font><font style="vertical-align: inherit;">Beachten Sie, dass der Deflate-Algorithmus erwartet, dass Codewörter auf der Grundlage des LSB-first-Prinzips (zuerst das niedrigstwertige Bit) generiert werden. </font><font style="vertical-align: inherit;">Das heißt, das erste Bit des Codeworts sollte im niedrigstwertigen Bit gespeichert werden. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir die Reihenfolge der Bits ändern müssen, beispielsweise mithilfe der Nachschlagetabelle.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_HUFFMAN_BITS 15          <span class="hljs-comment">/* Deflate uses max 15-bit codewords. */</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">compute_canonical_code</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> *codewords, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *lengths,
                                   <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;
        <span class="hljs-keyword">uint16_t</span> count[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>] = {<span class="hljs-number">0</span>};
        <span class="hljs-keyword">uint16_t</span> code[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">int</span> l;<font></font>
<font></font>
        <span class="hljs-comment">/* Count the number of codewords of each length. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                count[lengths[i]]++;<font></font>
        }<font></font>
        count[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* Ignore zero-length codes. */</span><font></font>
<font></font>
        <span class="hljs-comment">/* Compute the first codeword for each length. */</span>
        code[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (l = <span class="hljs-number">1</span>; l &lt;= MAX_HUFFMAN_BITS; l++) {<font></font>
                code[l] = (<span class="hljs-keyword">uint16_t</span>)((code[l - <span class="hljs-number">1</span>] + count[l - <span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Assign a codeword for each symbol. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                l = lengths[i];<font></font>
                <span class="hljs-keyword">if</span> (l == <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                codewords[i] = reverse16(code[l]++, l); <span class="hljs-comment">/* Make it LSB-first. */</span><font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Reverse the n least significant bits of x.
   The (16 - n) most significant bits of the result will be zero. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint16_t</span> <span class="hljs-title">reverse16</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> x, <span class="hljs-keyword">int</span> n)</span>
</span>{
        <span class="hljs-keyword">uint16_t</span> lo, hi;
        <span class="hljs-keyword">uint16_t</span> reversed;<font></font>
<font></font>
        assert(n &gt; <span class="hljs-number">0</span>);<font></font>
        assert(n &lt;= <span class="hljs-number">16</span>);<font></font>
<font></font>
        lo = x &amp; <span class="hljs-number">0xff</span>;<font></font>
        hi = x &gt;&gt; <span class="hljs-number">8</span>;<font></font>
<font></font>
        reversed = (<span class="hljs-keyword">uint16_t</span>)((reverse8_tbl[lo] &lt;&lt; <span class="hljs-number">8</span>) | reverse8_tbl[hi]);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> reversed &gt;&gt; (<span class="hljs-number">16</span> - n);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setzen Sie nun alles zusammen und schreiben Sie den Encoder-Initialisierungscode:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">huffman_encoder_t</span> <span class="hljs-title">huffman_encoder_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">huffman_encoder_t</span> {</span>
        <span class="hljs-keyword">uint16_t</span> codewords[MAX_HUFFMAN_SYMBOLS]; <span class="hljs-comment">/* LSB-first codewords. */</span>
        <span class="hljs-keyword">uint8_t</span> lengths[MAX_HUFFMAN_SYMBOLS];    <span class="hljs-comment">/* Codeword lengths. */</span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Initialize a Huffman encoder based on the n symbol frequencies. */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">huffman_encoder_init</span><span class="hljs-params">(<span class="hljs-keyword">huffman_encoder_t</span> *e, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> *freqs, <span class="hljs-keyword">size_t</span> n,
                          <span class="hljs-keyword">uint8_t</span> max_codeword_len)</span>
</span>{<font></font>
        assert(n &lt;= MAX_HUFFMAN_SYMBOLS);<font></font>
        assert(max_codeword_len &lt;= MAX_HUFFMAN_BITS);<font></font>
<font></font>
        compute_huffman_lengths(freqs, n, max_codeword_len, e-&gt;lengths);<font></font>
        compute_canonical_code(e-&gt;codewords, e-&gt;lengths, n);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir machen auch eine Funktion, um den Encoder unter Verwendung der bereits berechneten Codelängen zu konfigurieren:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Initialize a Huffman encoder based on the n codeword lengths. */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">huffman_encoder_init2</span><span class="hljs-params">(<span class="hljs-keyword">huffman_encoder_t</span> *e, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *lengths,
                           <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                e-&gt;lengths[i] = lengths[i];<font></font>
        }<font></font>
        compute_canonical_code(e-&gt;codewords, e-&gt;lengths, n);<font></font>
}<font></font>
</code></pre><br>
<a name="9"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Effiziente Huffman-Dekodierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der einfachste Weg, Huffman zu dekodieren, besteht darin, den Baum von der Wurzel aus zu durchlaufen, jeweils ein Eingabebit zu lesen und zu entscheiden, welcher Zweig als nächstes, links oder rechts verwendet werden soll. </font><font style="vertical-align: inherit;">Wenn ein Blattknoten erreicht ist, handelt es sich um ein dekodiertes Zeichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Methode wird oft an Universitäten und in Büchern gelehrt. </font><font style="vertical-align: inherit;">Es ist einfach und elegant, aber die Verarbeitung von Bit zu Bit ist zu langsam. </font><font style="vertical-align: inherit;">Das Dekodieren mit der Nachschlagetabelle ist viel schneller. </font><font style="vertical-align: inherit;">Für das obige Beispiel, in dem die maximale Codewortlänge drei Bit beträgt, können Sie die folgende Tabelle verwenden:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bits</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codewortlänge</font></font></strong></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EIN</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 01</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EIN</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EIN</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EIN</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
<tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></strong></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D.</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl es nur vier Zeichen gibt, benötigen wir eine Tabelle mit acht Einträgen, um alle möglichen Drei-Bit-Kombinationen abzudecken. </font><font style="vertical-align: inherit;">Symbole mit Codewörtern, die kürzer als drei Bits sind, haben mehrere Einträge in der Tabelle. </font><font style="vertical-align: inherit;">Zum Beispiel wurde das Wort 10 mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 </font><font style="vertical-align: inherit;">„ergänzt“ </font><font style="vertical-align: inherit;">, um alle Drei-Bit-Kombinationen ab </font><strong><font style="vertical-align: inherit;">10</font></strong><font style="vertical-align: inherit;"> abzudecken. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um auf diese Weise zu dekodieren, müssen Sie in der Tabelle mit den folgenden drei Eingabebits indizieren und sofort das entsprechende Zeichen und die Länge seines Codeworts finden. </font><font style="vertical-align: inherit;">Die Länge ist wichtig, da wir trotz der Betrachtung der nächsten drei Bits die gleiche Anzahl von Eingabebits wie die Länge des Codeworts erhalten müssen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die auf Suchtabellen basierende Methode funktioniert sehr schnell, hat jedoch einen Nachteil: Die Größe der Tabelle verdoppelt sich mit jedem zusätzlichen Bit in der Länge des Codeworts. Das heißt, der Aufbau der Tabelle verlangsamt sich exponentiell, und wenn sie nicht mehr in den Prozessor-Cache passt, beginnt die Methode langsam zu arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus diesem Grund wird die Nachschlagetabelle normalerweise nur für Codewörter verwendet, die nicht größer als eine bestimmte Länge sind. Und für längere Wörter gehen Sie anders vor. So wie die Huffman-Codierung häufigeren Zeichen kürzere Codewörter zuweist, ist die Verwendung einer Nachschlagetabelle für kurze Codewörter in vielen Fällen eine hervorragende Optimierung. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In zlib</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es werden mehrere Ebenen von Suchtabellen verwendet. </font><font style="vertical-align: inherit;">Wenn das Codewort für die erste Tabelle zu lang ist, wird die Suche in die sekundäre Tabelle verschoben, um die verbleibenden Bits zu indizieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt jedoch eine andere, sehr elegante Methode, die auf den Eigenschaften kanonischer Huffman-Codes basiert. </font><font style="vertical-align: inherit;">Es wird in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Über die Implementierung von Präfixcodes für minimale Redundanz</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Moffat und Turpin, 1997) beschrieben und auch in </font><font style="vertical-align: inherit;">Charles Blooms </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Lost Huffman Paper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erläutert </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir die Codewörter aus der kanonischen Version: 0, 10, 110, 111. Wir verfolgen die ersten Codewörter jeder Länge sowie die Nummer jedes Codeworts in der allgemeinen Reihenfolge - "Symbolindex".</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codewortlänge</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstes Codewort</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erster Zeichenindex</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 (A)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 (B)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 (C)</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da Codewörter nacheinander zugewiesen werden, können wir in der obigen Tabelle das Symbol finden, das diese Bits darstellen, wenn wir die Anzahl der Bits kennen. </font><font style="vertical-align: inherit;">Zum Beispiel sehen wir für das Drei-Bit-111, dass dies ein Versatz von eins gegenüber dem ersten Codewort dieser Länge (110) ist. </font><font style="vertical-align: inherit;">Der erste Zeichenindex dieser Länge ist 3, und ein Versatz von eins ergibt einen Index von 4. Eine andere Tabelle vergleicht den Zeichenindex mit dem Zeichen:</font></font><br>
<br>
<pre><code class="cpp hljs">sym_idx = d-&gt;first_symbol[len] + (bits - d-&gt;first_code[len]);<font></font>
sym = d-&gt;syms[sym_idx];<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine kleine Optimierung: Anstatt den ersten Zeichenindex und das erste Codewort separat zu speichern, können wir den ersten Index in der Tabelle abzüglich des ersten Codeworts speichern:</font></font><br>
<br>
<pre><code class="cpp hljs">sym_idx = d-&gt;offset_first_sym_idx[len] + bits;<font></font>
sym = d-&gt;syms[sym_idx];<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu verstehen, wie viele Bits geschätzt werden müssen, verwenden wir erneut die Codesequenz-Eigenschaft. </font><font style="vertical-align: inherit;">In unserem Beispiel sind alle gültigen Ein-Bit-Codewörter streng kleiner als 1, zwei Bit - streng weniger als 11, drei Bit - weniger als 1000 (tatsächlich gilt dies für alle Drei-Bit-Werte). </font><font style="vertical-align: inherit;">Mit anderen Worten, das gültige N-Bit-Codewort muss strikt kleiner sein als das erste N-Bit-Codewort plus die Anzahl der N-Bit-Codewörter. </font><font style="vertical-align: inherit;">Darüber hinaus können wir diese Grenzen nach links verschieben, sodass sie alle drei Bit breit sind. </font><font style="vertical-align: inherit;">Nennen wir es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">restriktive Bits</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für jede der Codewortlängen:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codewortlänge</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bits begrenzen</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></td>
</tr>
</tbody></table></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Begrenzer für Länge 3 ist auf 4 Bit übergelaufen, dies bedeutet jedoch nur, dass jedes Drei-Bit-Wort ausreicht. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können zwischen den Drei-Bit-Eingabedaten suchen und mit den restriktiven Bits vergleichen, um zu verstehen, wie lang unser Codewort ist. </font><font style="vertical-align: inherit;">Nach Abschluss verschieben wir die Eingabebits, um nur die richtige Anzahl zu berechnen, und suchen dann den Zeichenindex:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (len = <span class="hljs-number">1</span>; len &lt;= <span class="hljs-number">3</span>; len++) {
        <span class="hljs-keyword">if</span> (bits &lt; d-&gt;sentinel_bits[len]) {<font></font>
                bits &gt;&gt;= <span class="hljs-number">3</span> - len;  <span class="hljs-comment">/* Get the len most significant bits. */</span><font></font>
                sym_idx = d-&gt;offset_first_sym_idx[len] + bits;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zeitliche Komplexität des Prozesses ist in Bezug auf die Anzahl der Bits in den Codewörtern linear, aber der Platz wird effizient genutzt, bei jedem Schritt ist nur Laden und Vergleichen erforderlich, und da kürzere Codewörter häufiger sind, ermöglicht das Verfahren die Optimierung der Komprimierung in vielen Situationen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vollständiger Decodercode:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HUFFMAN_LOOKUP_TABLE_BITS 8  <span class="hljs-comment">/* Seems a good trade-off. */</span></span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">huffman_decoder_t</span> <span class="hljs-title">huffman_decoder_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">huffman_decoder_t</span> {</span>
        <span class="hljs-comment">/* Lookup table for fast decoding of short codewords. */</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
                <span class="hljs-keyword">uint16_t</span> sym : <span class="hljs-number">9</span>;  <span class="hljs-comment">/* Wide enough to fit the max symbol nbr. */</span>
                <span class="hljs-keyword">uint16_t</span> len : <span class="hljs-number">7</span>;  <span class="hljs-comment">/* 0 means no symbol. */</span>
        } table[<span class="hljs-number">1U</span> &lt;&lt; HUFFMAN_LOOKUP_TABLE_BITS];<font></font>
<font></font>
        <span class="hljs-comment">/* "Sentinel bits" value for each codeword length. */</span>
        <span class="hljs-keyword">uint16_t</span> sentinel_bits[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];<font></font>
<font></font>
        <span class="hljs-comment">/* First symbol index minus first codeword mod 2**16 for each length. */</span>
        <span class="hljs-keyword">uint16_t</span> offset_first_sym_idx[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];<font></font>
<font></font>
        <span class="hljs-comment">/* Map from symbol index to symbol. */</span>
        <span class="hljs-keyword">uint16_t</span> syms[MAX_HUFFMAN_SYMBOLS];
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span>
        <span class="hljs-keyword">size_t</span> num_syms;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Get the n least significant bits of x. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">lsb</span><span class="hljs-params">(<span class="hljs-keyword">uint64_t</span> x, <span class="hljs-keyword">int</span> n)</span>
</span>{<font></font>
        assert(n &gt;= <span class="hljs-number">0</span> &amp;&amp; n &lt;= <span class="hljs-number">63</span>);
        <span class="hljs-keyword">return</span> x &amp; (((<span class="hljs-keyword">uint64_t</span>)<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Use the decoder d to decode a symbol from the LSB-first zero-padded bits.
 * Returns the decoded symbol number or -1 if no symbol could be decoded.
 * *num_used_bits will be set to the number of bits used to decode the symbol,
 * or zero if no symbol could be decoded. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">huffman_decode</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_decoder_t</span> *d, <span class="hljs-keyword">uint16_t</span> bits,
                                 <span class="hljs-keyword">size_t</span> *num_used_bits)</span>
</span>{
        <span class="hljs-keyword">uint64_t</span> lookup_bits;
        <span class="hljs-keyword">size_t</span> l;
        <span class="hljs-keyword">size_t</span> sym_idx;<font></font>
<font></font>
        <span class="hljs-comment">/* First try the lookup table. */</span><font></font>
        lookup_bits = lsb(bits, HUFFMAN_LOOKUP_TABLE_BITS);<font></font>
        assert(lookup_bits &lt; <span class="hljs-keyword">sizeof</span>(d-&gt;table) / <span class="hljs-keyword">sizeof</span>(d-&gt;table[<span class="hljs-number">0</span>]));
        <span class="hljs-keyword">if</span> (d-&gt;table[lookup_bits].len != <span class="hljs-number">0</span>) {<font></font>
                assert(d-&gt;table[lookup_bits].len &lt;= HUFFMAN_LOOKUP_TABLE_BITS);<font></font>
                assert(d-&gt;table[lookup_bits].sym &lt; d-&gt;num_syms);<font></font>
<font></font>
                *num_used_bits = d-&gt;table[lookup_bits].len;<font></font>
                <span class="hljs-keyword">return</span> d-&gt;table[lookup_bits].sym;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Then do canonical decoding with the bits in MSB-first order. */</span><font></font>
        bits = reverse16(bits, MAX_HUFFMAN_BITS);<font></font>
        <span class="hljs-keyword">for</span> (l = HUFFMAN_LOOKUP_TABLE_BITS + <span class="hljs-number">1</span>; l &lt;= MAX_HUFFMAN_BITS; l++) {
                <span class="hljs-keyword">if</span> (bits &lt; d-&gt;sentinel_bits[l]) {<font></font>
                        bits &gt;&gt;= MAX_HUFFMAN_BITS - l;<font></font>
<font></font>
                        sym_idx = (<span class="hljs-keyword">uint16_t</span>)(d-&gt;offset_first_sym_idx[l] + bits);<font></font>
                        assert(sym_idx &lt; d-&gt;num_syms);<font></font>
<font></font>
                        *num_used_bits = l;<font></font>
                        <span class="hljs-keyword">return</span> d-&gt;syms[sym_idx];<font></font>
                }<font></font>
        }<font></font>
<font></font>
        *num_used_bits = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Decoder zu konfigurieren, berechnen wir die kanonischen Codes wie für </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">huffman_encoder_init vor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und füllen verschiedene Tabellen aus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Initialize huffman decoder d for a code defined by the n codeword lengths.
   Returns false if the codeword lengths do not correspond to a valid prefix
   code. */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">huffman_decoder_init</span><span class="hljs-params">(<span class="hljs-keyword">huffman_decoder_t</span> *d, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *lengths,
                          <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;
        <span class="hljs-keyword">uint16_t</span> count[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>] = {<span class="hljs-number">0</span>};
        <span class="hljs-keyword">uint16_t</span> code[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">uint32_t</span> s;
        <span class="hljs-keyword">uint16_t</span> sym_idx[MAX_HUFFMAN_BITS + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">int</span> l;<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span><font></font>
        assert(n &lt;= MAX_HUFFMAN_SYMBOLS);<font></font>
        d-&gt;num_syms = n;<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
        <span class="hljs-comment">/* Zero-initialize the lookup table. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(d-&gt;table) / <span class="hljs-keyword">sizeof</span>(d-&gt;table[<span class="hljs-number">0</span>]); i++) {<font></font>
                d-&gt;table[i].len = <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Count the number of codewords of each length. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                assert(lengths[i] &lt;= MAX_HUFFMAN_BITS);<font></font>
                count[lengths[i]]++;<font></font>
        }<font></font>
        count[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">/* Ignore zero-length codewords. */</span><font></font>
<font></font>
        <span class="hljs-comment">/* Compute sentinel_bits and offset_first_sym_idx for each length. */</span>
        code[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<font></font>
        sym_idx[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (l = <span class="hljs-number">1</span>; l &lt;= MAX_HUFFMAN_BITS; l++) {
                <span class="hljs-comment">/* First canonical codeword of this length. */</span>
                code[l] = (<span class="hljs-keyword">uint16_t</span>)((code[l - <span class="hljs-number">1</span>] + count[l - <span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">1</span>);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (count[l] != <span class="hljs-number">0</span> &amp;&amp; code[l] + count[l] - <span class="hljs-number">1</span> &gt; (<span class="hljs-number">1U</span> &lt;&lt; l) - <span class="hljs-number">1</span>) {
                        <span class="hljs-comment">/* The last codeword is longer than l bits. */</span>
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
<font></font>
                s = (<span class="hljs-keyword">uint32_t</span>)((code[l] + count[l]) &lt;&lt; (MAX_HUFFMAN_BITS - l));<font></font>
                d-&gt;sentinel_bits[l] = (<span class="hljs-keyword">uint16_t</span>)s;<font></font>
                assert(d-&gt;sentinel_bits[l] == s &amp;&amp; <span class="hljs-string">"No overflow."</span>);<font></font>
<font></font>
                sym_idx[l] = sym_idx[l - <span class="hljs-number">1</span>] + count[l - <span class="hljs-number">1</span>];<font></font>
                d-&gt;offset_first_sym_idx[l] = sym_idx[l] - code[l];<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Build mapping from index to symbol and populate the lookup table. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                l = lengths[i];<font></font>
                <span class="hljs-keyword">if</span> (l == <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                d-&gt;syms[sym_idx[l]] = (<span class="hljs-keyword">uint16_t</span>)i;<font></font>
                sym_idx[l]++;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (l &lt;= HUFFMAN_LOOKUP_TABLE_BITS) {<font></font>
                        table_insert(d, i, l, code[l]);<font></font>
                        code[l]++;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">table_insert</span><span class="hljs-params">(<span class="hljs-keyword">huffman_decoder_t</span> *d, <span class="hljs-keyword">size_t</span> sym, <span class="hljs-keyword">int</span> len,
                         <span class="hljs-keyword">uint16_t</span> codeword)</span>
</span>{
        <span class="hljs-keyword">int</span> pad_len;
        <span class="hljs-keyword">uint16_t</span> padding, index;<font></font>
<font></font>
        assert(len &lt;= HUFFMAN_LOOKUP_TABLE_BITS);<font></font>
<font></font>
        codeword = reverse16(codeword, len); <span class="hljs-comment">/* Make it LSB-first. */</span><font></font>
        pad_len = HUFFMAN_LOOKUP_TABLE_BITS - len;<font></font>
<font></font>
        <span class="hljs-comment">/* Pad the pad_len upper bits with all bit combinations. */</span>
        <span class="hljs-keyword">for</span> (padding = <span class="hljs-number">0</span>; padding &lt; (<span class="hljs-number">1U</span> &lt;&lt; pad_len); padding++) {<font></font>
                index = (<span class="hljs-keyword">uint16_t</span>)(codeword | (padding &lt;&lt; len));<font></font>
                d-&gt;table[index].sym = (<span class="hljs-keyword">uint16_t</span>)sym;<font></font>
                d-&gt;table[index].len = (<span class="hljs-keyword">uint16_t</span>)len;<font></font>
<font></font>
                assert(d-&gt;table[index].sym == sym &amp;&amp; <span class="hljs-string">"Fits in bitfield."</span>);<font></font>
                assert(d-&gt;table[index].len == len &amp;&amp; <span class="hljs-string">"Fits in bitfield."</span>);<font></font>
        }<font></font>
}<font></font>
</code></pre><br>
<a name="10"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entleeren</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der 1993 in PKZip 2.04c eingeführte Deflate-Algorithmus ist eine Standardkomprimierungsmethode in modernen Zip-Dateien. </font><font style="vertical-align: inherit;">Es wird auch in gzip, PNG und vielen anderen Formaten verwendet. </font><font style="vertical-align: inherit;">Es verwendet eine Kombination aus LZ77-Komprimierung und Huffman-Codierung, die wir in diesem Abschnitt diskutieren und implementieren werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor Deflate verwendete PKZip die Komprimierungsmethoden Shrink, Reduce und Implode. </font><font style="vertical-align: inherit;">Heute sind sie selten, obwohl sie nach Deflate noch einige Zeit in Gebrauch waren, weil sie weniger Speicher verbrauchten. </font><font style="vertical-align: inherit;">Aber wir werden sie nicht berücksichtigen.</font></font><br>
<br>
<a name="11"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitströme</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deflate speichert Huffman-Codewörter in einem Bitstrom nach dem LSB-First-Prinzip. Dies bedeutet, dass das erste Bit des Streams im niedrigstwertigen Bit des ersten Bytes gespeichert ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie einen Bitstrom (von links nach rechts gelesen) 1-0-0-1-1. Wenn es nach dem LSB-first-Prinzip gespeichert wird, wird der Bytewert 0b00011001 (binär) oder 0x19 (hexadezimal). Es mag scheinen, dass der Stream einfach rückwärts dargestellt wird (in gewissem Sinne auch), aber der Vorteil ist, dass es für uns einfacher ist, die ersten N Bits aus einem Computerwort zu erhalten: Wir verstecken einfach die N niedrigstwertigen Bits. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Prozeduren stammen aus </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bitstream.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Input bitstream. */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">istream_t</span> <span class="hljs-title">istream_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">istream_t</span> {</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src;  <span class="hljs-comment">/* Source bytes. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *end;  <span class="hljs-comment">/* Past-the-end byte of src. */</span>
        <span class="hljs-keyword">size_t</span> bitpos;       <span class="hljs-comment">/* Position of the next bit to read. */</span>
        <span class="hljs-keyword">size_t</span> bitpos_end;   <span class="hljs-comment">/* Position of past-the-end bit. */</span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Initialize an input stream to present the n bytes from src as an LSB-first
 * bitstream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">istream_init</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> n)</span>
</span>{<font></font>
        is-&gt;src = src;<font></font>
        is-&gt;end = src + n;<font></font>
        is-&gt;bitpos = <span class="hljs-number">0</span>;<font></font>
        is-&gt;bitpos_end = n * <span class="hljs-number">8</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Huffman-Decoder muss die folgenden Bits im Stream betrachten (genügend Bits für das längste mögliche Codewort) und dann den Stream mit der Anzahl der vom decodierten Symbol verwendeten Bits fortsetzen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ISTREAM_MIN_BITS (64 - 7)</span><font></font>
<font></font>
<span class="hljs-comment">/* Get the next bits from the input stream. The number of bits returned is
 * between ISTREAM_MIN_BITS and 64, depending on the position in the stream, or
 * fewer if the end of stream is reached. The upper bits are zero-padded. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">istream_bits</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">istream_t</span> *is)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *next;
        <span class="hljs-keyword">uint64_t</span> bits;
        <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
        next = is-&gt;src + (is-&gt;bitpos / <span class="hljs-number">8</span>);<font></font>
<font></font>
        assert(next &lt;= is-&gt;end &amp;&amp; <span class="hljs-string">"Cannot read past end of stream."</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (is-&gt;end - next &gt;= <span class="hljs-number">8</span>) {
                <span class="hljs-comment">/* Common case: read 8 bytes in one go. */</span><font></font>
                bits = read64le(next);<font></font>
        } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">/* Read the available bytes and zero-pad. */</span>
                bits = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; is-&gt;end - next; i++) {<font></font>
                        bits |= (<span class="hljs-keyword">uint64_t</span>)next[i] &lt;&lt; (i * <span class="hljs-number">8</span>);<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> bits &gt;&gt; (is-&gt;bitpos % <span class="hljs-number">8</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Advance n bits in the bitstream if possible. Returns false if that many bits
 * are not available in the stream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">istream_advance</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">size_t</span> n)</span> </span>{
        <span class="hljs-keyword">if</span> (is-&gt;bitpos + n &gt; is-&gt;bitpos_end) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        is-&gt;bitpos += n;<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Fazit ist, dass Sie auf 64-Bit-Computern </font></font><code>istream_bits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normalerweise als Single-Boot-Befehl und als Arithmetik ausgeführt werden können, da sich die Strukturelemente </font></font><code>istream_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Registern befinden. </font><font style="vertical-align: inherit;">read64le ist in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bits.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementiert </font><font style="vertical-align: inherit;">(moderne Compiler konvertieren es nach dem Little-Endian-Prinzip in einen einzelnen 64-Bit-Download):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Read a 64-bit value from p in little-endian byte order. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">read64le</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p)</span>
</span>{
        <span class="hljs-comment">/* The one true way, see
         * https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html */</span>
        <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">0</span>)  |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>)  |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">16</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">24</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-number">32</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">5</span>] &lt;&lt; <span class="hljs-number">40</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">6</span>] &lt;&lt; <span class="hljs-number">48</span>) |<font></font>
               ((<span class="hljs-keyword">uint64_t</span>)p[<span class="hljs-number">7</span>] &lt;&lt; <span class="hljs-number">56</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir brauchen auch eine Funktion, um den Bitstrom bis zur Grenze des nächsten Bytes fortzusetzen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Round x up to the next multiple of m, which must be a power of 2. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">round_up</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> x, <span class="hljs-keyword">size_t</span> m)</span>
</span>{<font></font>
        assert((m &amp; (m - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-string">"m must be a power of two"</span>);
        <span class="hljs-keyword">return</span> (x + m - <span class="hljs-number">1</span>) &amp; (<span class="hljs-keyword">size_t</span>)(-m); <span class="hljs-comment">/* Hacker's Delight (2nd), 3-1. */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Align the input stream to the next 8-bit boundary and return a pointer to
 * that byte, which may be the past-the-end-of-stream byte. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-title">istream_byte_align</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *byte;<font></font>
<font></font>
        assert(is-&gt;bitpos &lt;= is-&gt;bitpos_end &amp;&amp; <span class="hljs-string">"Not past end of stream."</span>);<font></font>
<font></font>
        is-&gt;bitpos = round_up(is-&gt;bitpos, <span class="hljs-number">8</span>);<font></font>
        byte = is-&gt;src + is-&gt;bitpos / <span class="hljs-number">8</span>;<font></font>
        assert(byte &lt;= is-&gt;end);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> byte;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für einen ausgehenden Bitstrom schreiben wir Bits unter Verwendung eines Lese-, Änderungs- und Schreibprozesses. </font><font style="vertical-align: inherit;">Im schnellen Fall können Sie ein Bit mit einem 64-Bit-Lesevorgang, einer Art Bit-Operation und einem 64-Bit-Schreibvorgang schreiben.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Output bitstream. */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ostream_t</span> <span class="hljs-title">ostream_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ostream_t</span> {</span>
        <span class="hljs-keyword">uint8_t</span> *dst;
        <span class="hljs-keyword">uint8_t</span> *end;
        <span class="hljs-keyword">size_t</span> bitpos;
        <span class="hljs-keyword">size_t</span> bitpos_end;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Initialize an output stream to write LSB-first bits into dst[0..n-1]. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ostream_init</span><span class="hljs-params">(<span class="hljs-keyword">ostream_t</span> *os, <span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> n)</span>
</span>{<font></font>
        os-&gt;dst = dst;<font></font>
        os-&gt;end = dst + n;<font></font>
        os-&gt;bitpos = <span class="hljs-number">0</span>;<font></font>
        os-&gt;bitpos_end = n * <span class="hljs-number">8</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Get the current bit position in the stream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">ostream_bit_pos</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">ostream_t</span> *os)</span>
</span>{
        <span class="hljs-keyword">return</span> os-&gt;bitpos;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Return the number of bytes written to the output buffer. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">ostream_bytes_written</span><span class="hljs-params">(<span class="hljs-keyword">ostream_t</span> *os)</span>
</span>{
        <span class="hljs-keyword">return</span> round_up(os-&gt;bitpos, <span class="hljs-number">8</span>) / <span class="hljs-number">8</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Write n bits to the output stream. Returns false if there is not enough room
 * at the destination. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">ostream_write</span><span class="hljs-params">(<span class="hljs-keyword">ostream_t</span> *os, <span class="hljs-keyword">uint64_t</span> bits, <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint64_t</span> x;
        <span class="hljs-keyword">int</span> shift, i;<font></font>
<font></font>
        assert(n &lt;= <span class="hljs-number">57</span>);<font></font>
        assert(bits &lt;= ((<span class="hljs-keyword">uint64_t</span>)<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-string">"Must fit in n bits."</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (os-&gt;bitpos_end - os-&gt;bitpos &lt; n) {
                <span class="hljs-comment">/* Not enough room. */</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        p = &amp;os-&gt;dst[os-&gt;bitpos / <span class="hljs-number">8</span>];<font></font>
        shift = os-&gt;bitpos % <span class="hljs-number">8</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (os-&gt;end - p &gt;= <span class="hljs-number">8</span>) {
                <span class="hljs-comment">/* Common case: read and write 8 bytes in one go. */</span><font></font>
                x = read64le(p);<font></font>
                x = lsb(x, shift);<font></font>
                x |= bits &lt;&lt; shift;<font></font>
                write64le(p, x);<font></font>
        } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">/* Slow case: read/write as many bytes as are available. */</span>
                x = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; os-&gt;end - p; i++) {<font></font>
                        x |= (<span class="hljs-keyword">uint64_t</span>)p[i] &lt;&lt; (i * <span class="hljs-number">8</span>);<font></font>
                }<font></font>
                x = lsb(x, shift);<font></font>
                x |= bits &lt;&lt; shift;<font></font>
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; os-&gt;end - p; i++) {<font></font>
                        p[i] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; (i * <span class="hljs-number">8</span>));<font></font>
                }<font></font>
        }<font></font>
<font></font>
        os-&gt;bitpos += n;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Write a 64-bit value x to dst in little-endian byte order. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write64le</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">uint64_t</span> x)</span>
</span>{<font></font>
        dst[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">0</span>);<font></font>
        dst[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">8</span>);<font></font>
        dst[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">16</span>);<font></font>
        dst[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">24</span>);<font></font>
        dst[<span class="hljs-number">4</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">32</span>);<font></font>
        dst[<span class="hljs-number">5</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">40</span>);<font></font>
        dst[<span class="hljs-number">6</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">48</span>);<font></font>
        dst[<span class="hljs-number">7</span>] = (<span class="hljs-keyword">uint8_t</span>)(x &gt;&gt; <span class="hljs-number">56</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir müssen auch effizient Bytes in den Stream schreiben. </font><font style="vertical-align: inherit;">Natürlich können Sie 8-Bit-Aufnahmen wiederholt ausführen, aber die Verwendung ist viel schneller </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Align the bitstream to the next byte boundary, then write the n bytes from
   src to it. Returns false if there is not enough room in the stream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">ostream_write_bytes_aligned</span><span class="hljs-params">(<span class="hljs-keyword">ostream_t</span> *os,
                                               <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src,
                                               <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">if</span> (os-&gt;bitpos_end - round_up(os-&gt;bitpos, <span class="hljs-number">8</span>) &lt; n * <span class="hljs-number">8</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        os-&gt;bitpos = round_up(os-&gt;bitpos, <span class="hljs-number">8</span>);
        <span class="hljs-built_in">memcpy</span>(&amp;os-&gt;dst[os-&gt;bitpos / <span class="hljs-number">8</span>], src, n);<font></font>
        os-&gt;bitpos += n * <span class="hljs-number">8</span>;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br>
<a name="12"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auspacken (Inflation)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da der Komprimierungsalgorithmus als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entleeren bezeichnet wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Blasen, Luft aus etwas extrahieren - wird der Entpackungsprozess manchmal als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inflation bezeichnet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn Sie diesen Prozess zum ersten Mal studieren, werden wir verstehen, wie das Format funktioniert. </font><font style="vertical-align: inherit;">Sie können den Code im ersten Teil von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deflate.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deflate.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bits.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tables.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tables.c sehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (generiert mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generate_tables.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Deflate komprimierte Daten werden als eine Reihe von </font><i><font style="vertical-align: inherit;">Blöcken</font></i><font style="vertical-align: inherit;"> gespeichert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jeder Block beginnt mit einem 3-Bit-Header, in dem das erste (niedrigstwertige) Bit gesetzt wird, wenn dies der letzte Block der Reihe ist, und die anderen beiden Bits geben seinen Typ an.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/875/b36/1fd/875b361fd3414431d2a20d1ab0b6ef8b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt drei Arten von Blöcken: unkomprimiert (0), komprimiert mit festen Huffman-Codes (1) und komprimiert mit „dynamischen“ Huffman-Codes (2). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code führt das Entpacken mit Hilfsfunktionen für verschiedene Arten von Blöcken durch, die wir später implementieren werden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> {<font></font>
        HWINF_OK,   <span class="hljs-comment">/* Inflation was successful. */</span>
        HWINF_FULL, <span class="hljs-comment">/* Not enough room in the output buffer. */</span>
        HWINF_ERR   <span class="hljs-comment">/* Error in the input data. */</span>
} <span class="hljs-keyword">inf_stat_t</span>;<font></font>
<font></font>
<span class="hljs-comment">/* Decompress (inflate) the Deflate stream in src. The number of input bytes
   used, at most src_len, is stored in *src_used on success. Output is written
   to dst. The number of bytes written, at most dst_cap, is stored in *dst_used
   on success. src[0..src_len-1] and dst[0..dst_cap-1] must not overlap.
   Returns a status value as defined above. */</span>
<span class="hljs-function"><span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">hwinflate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len, <span class="hljs-keyword">size_t</span> *src_used,
                     <span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_used)</span>
</span>{
        <span class="hljs-keyword">istream_t</span> is;
        <span class="hljs-keyword">size_t</span> dst_pos;
        <span class="hljs-keyword">uint64_t</span> bits;
        <span class="hljs-keyword">bool</span> bfinal;
        <span class="hljs-keyword">inf_stat_t</span> s;<font></font>
<font></font>
        istream_init(&amp;is, src, src_len);<font></font>
        dst_pos = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">do</span> {
                <span class="hljs-comment">/* Read the 3-bit block header. */</span><font></font>
                bits = istream_bits(&amp;is);<font></font>
                <span class="hljs-keyword">if</span> (!istream_advance(&amp;is, <span class="hljs-number">3</span>)) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
                bfinal = bits &amp; <span class="hljs-number">1</span>;<font></font>
                bits &gt;&gt;= <span class="hljs-number">1</span>;<font></font>
<font></font>
                <span class="hljs-keyword">switch</span> (lsb(bits, <span class="hljs-number">2</span>)) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">/* 00: No compression. */</span><font></font>
                        s = inf_noncomp_block(&amp;is, dst, dst_cap, &amp;dst_pos);<font></font>
                        <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">/* 01: Compressed with fixed Huffman codes. */</span><font></font>
                        s = inf_fixed_block(&amp;is, dst, dst_cap, &amp;dst_pos);<font></font>
                        <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">/* 10: Compressed with "dynamic" Huffman codes. */</span><font></font>
                        s = inf_dyn_block(&amp;is, dst, dst_cap, &amp;dst_pos);<font></font>
                        <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>: <span class="hljs-comment">/* Invalid block type. */</span>
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (s != HWINF_OK) {
                        <span class="hljs-keyword">return</span> s;<font></font>
                }<font></font>
        } <span class="hljs-keyword">while</span> (!bfinal);<font></font>
<font></font>
        *src_used = (<span class="hljs-keyword">size_t</span>)(istream_byte_align(&amp;is) - src);<font></font>
<font></font>
        assert(dst_pos &lt;= dst_cap);<font></font>
        *dst_used = dst_pos;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> HWINF_OK;<font></font>
}<font></font>
</code></pre><br>
<a name="13"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unkomprimierte Entleerungsblöcke</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies sind "gespeicherte" Blöcke, der einfachste Typ. </font><font style="vertical-align: inherit;">Es beginnt mit der nächsten 8-Bit-Grenze des Bitstroms mit einem 16-Bit-Wort (len), das die Länge des Blocks angibt. </font><font style="vertical-align: inherit;">Dahinter befindet sich ein weiteres 16-Bit-Wort (nlen), das die Wörter len ergänzt (die Reihenfolge der Bits ist invertiert). </font><font style="vertical-align: inherit;">Es wird angenommen, dass nlen als einfache len-Prüfsumme fungiert: Wenn die Datei beschädigt ist, ergänzen sich die Werte wahrscheinlich nicht und das Programm kann einen Fehler erkennen.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e1/eb8/15b/0e1eb815b2dfec1edb50eeafd1291cc5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach len und nlen sind unkomprimierte Daten. </font><font style="vertical-align: inherit;">Da die Blocklänge ein 16-Bit-Wert ist, ist die Datengröße auf 65.535 Byte begrenzt.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">inf_noncomp_block</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">uint8_t</span> *dst,
                                    <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_pos)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint16_t</span> len, nlen;<font></font>
<font></font>
        p = istream_byte_align(is);<font></font>
<font></font>
        <span class="hljs-comment">/* Read len and nlen (2 x 16 bits). */</span>
        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">32</span>)) {
                <span class="hljs-keyword">return</span> HWINF_ERR; <span class="hljs-comment">/* Not enough input. */</span><font></font>
        }<font></font>
        len  = read16le(p);<font></font>
        nlen = read16le(p + <span class="hljs-number">2</span>);<font></font>
        p += <span class="hljs-number">4</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (nlen != (<span class="hljs-keyword">uint16_t</span>)~len) {
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!istream_advance(is, len * <span class="hljs-number">8</span>)) {
                <span class="hljs-keyword">return</span> HWINF_ERR; <span class="hljs-comment">/* Not enough input. */</span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (dst_cap - *dst_pos &lt; len) {
                <span class="hljs-keyword">return</span> HWINF_FULL; <span class="hljs-comment">/* Not enough room to output. */</span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">memcpy</span>(&amp;dst[*dst_pos], p, len);<font></font>
        *dst_pos += len;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> HWINF_OK;<font></font>
}<font></font>
</code></pre><br>
<a name="14"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blöcke mit festen Huffman-Codes entleeren</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Komprimierte Deflate-Blöcke verwenden Huffman-Code, um eine Folge von LZ77-Literalen darzustellen. </font><font style="vertical-align: inherit;">Backlinks werden mithilfe von Blockendmarkierungen unterbrochen. </font><font style="vertical-align: inherit;">Für Literale, Backlink-Längen und Markierungen wird der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">litlen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Huffman-Code </font><i><font style="vertical-align: inherit;">verwendet</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Und für Backlink-Entfernungen wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dist-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code verwendet </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c35/0e1/a8c/c350e1a8c73f69203949ccc534141497.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Litlen codiert Werte im Bereich von 0 bis 285. </font><font style="vertical-align: inherit;">Die Werte 0-255 werden für Literalbytes verwendet, 256 ist die Blockende-Markierung und 257-285 werden für Backlink-Längen verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Backlinks sind 3-258 Bytes lang. </font><font style="vertical-align: inherit;">Der Litlen-Wert bestimmt die Basislänge, zu der null oder mehr </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zusätzliche Bits</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus dem Stream hinzugefügt werden </font><font style="vertical-align: inherit;">, um die volle Länge gemäß der folgenden Tabelle zu erhalten. </font><font style="vertical-align: inherit;">Zum Beispiel bedeutet ein kleiner Wert von 269 eine Basislänge von 19 und zwei zusätzliche Bits. </font><font style="vertical-align: inherit;">Das Hinzufügen von zwei Bits aus dem Stream ergibt die endgültige Länge von 19 bis 22.</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Litlen</font></font></strong></td>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusätzliche Bits</font></font></strong></td>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Längen</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">257</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">258</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">259</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">260</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">261</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">262</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">263</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">264</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">265</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11-12</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">266</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13-14</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">267</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15-16</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">268</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17-18</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">269</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19-22</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">270</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">23–26</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">271</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">27-30</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">272</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">31–34</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">273</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">35–42</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">274</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">43-50</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">275</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">51–58</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">276</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">59–66</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">277</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">67–82</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">278</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">83–98</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">279</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">99–114</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">280</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">115–130</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">281</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">131–162</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">282</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">163–194</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">283</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">195–226</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">284</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">227–257</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">285</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">258</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist zu beachten, dass ein Litlen-Wert von 284 plus 5 zusätzliche Bits Längen von 227 bis 258 darstellen kann. Die Spezifikation besagt jedoch, dass die Länge 258 - die maximale Länge des Backlinks - unter Verwendung eines separaten Litlen-Werts dargestellt werden muss. </font><font style="vertical-align: inherit;">Dies soll die Codierung in Situationen reduzieren, in denen häufig die maximale Länge erreicht wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Dekomprimierer verwendet die Tabelle, um die Basislänge und zusätzliche Bits aus dem Litlen-Wert (minus 257) zu erhalten:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Table of litlen symbol values minus 257 with corresponding base length
   and number of extra bits. */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">litlen_tbl_t</span> {</span>
        <span class="hljs-keyword">uint16_t</span> base_len : <span class="hljs-number">9</span>;
        <span class="hljs-keyword">uint16_t</span> ebits : <span class="hljs-number">7</span>;<font></font>
};<font></font>
<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">litlen_tbl_t</span> <span class="hljs-title">litlen_tbl</span>[29] = {</span>
<span class="hljs-comment">/* 257 */</span> { <span class="hljs-number">3</span>, <span class="hljs-number">0</span> },
<span class="hljs-comment">/* 258 */</span> { <span class="hljs-number">4</span>, <span class="hljs-number">0</span> },<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/* 284 */</span> { <span class="hljs-number">227</span>, <span class="hljs-number">5</span> },
<span class="hljs-comment">/* 285 */</span> { <span class="hljs-number">258</span>, <span class="hljs-number">0</span> }<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Huffmans fester Litlen-Code ist kanonisch und verwendet die folgenden Codewortlängen (286–287 sind keine gültigen Litlen-Werte, sie sind jedoch an der Codegenerierung beteiligt):</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Litlen-Werte</font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codewortlänge</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0–143</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">144–255</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">256–279</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">280–287</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Dekompressor speichert diese Längen in einer Tabelle, die für die Übertragung an </font></font><code>huffman_decoder_init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> fixed_litlen_lengths[<span class="hljs-number">288</span>] = {
<span class="hljs-comment">/*   0 */</span> <span class="hljs-number">8</span>,
<span class="hljs-comment">/*   1 */</span> <span class="hljs-number">8</span>,<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/* 287 */</span> <span class="hljs-number">8</span>,<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Backlink-Abstände variieren von 1 bis 32.768. Sie werden unter Verwendung eines Schemas codiert, das einem Längencodierungsschema ähnlich ist. </font><font style="vertical-align: inherit;">Der Huffman-Code dist codiert Werte von 0 bis 29, von denen jeder der Basislänge entspricht, zu der zusätzliche Bits hinzugefügt werden, um den endgültigen Abstand zu erhalten:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dist</font></font></strong></td>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusätzliche Bits</font></font></strong></td>
<td width="200"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entfernungen</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5-6</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7-8</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9-12</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13–16</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17-24</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25–32</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">33–48</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elf</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">49–64</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65–96</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dreizehn</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">97–128</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">129–192</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fünfzehn</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">193–256</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sechszehn</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">257–384</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">17</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">385-512</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">achtzehn</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">513-768</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neunzehn</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">769-1024</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwanzig</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1025-1536</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">21</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1537–2048</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2049-3072</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">23</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3073–4096</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elf</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4097-6144</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elf</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6145–8192</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8193–12288</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">27</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12289–16384</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dreizehn</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16385–24576</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">29</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dreizehn</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24577–32768</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Huffmans fester Code dist ist kanonisch. </font><font style="vertical-align: inherit;">Alle Codewörter sind 5 Bit lang. </font><font style="vertical-align: inherit;">Es ist einfach, der Dekomprimierer speichert die Codes in einer Tabelle, die verwendet werden kann </font></font><code>huffman_decoder_init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dist-Werte 30–31 sind nicht korrekt. Es wird angezeigt, dass sie an der Generierung von Huffman-Codes beteiligt sind, aber tatsächlich keine Auswirkung haben):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> fixed_dist_lengths[<span class="hljs-number">32</span>] = {
<span class="hljs-comment">/*  0 */</span> <span class="hljs-number">5</span>,
<span class="hljs-comment">/*  1 */</span> <span class="hljs-number">5</span>,<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">/* 31 */</span> <span class="hljs-number">5</span>,<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dekomprimierungs- oder Entpackungscode - Block mit festen Huffman-Codes entleeren:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">inf_fixed_block</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">uint8_t</span> *dst,
                                  <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_pos)</span>
</span>{
        <span class="hljs-keyword">huffman_decoder_t</span> litlen_dec, dist_dec;<font></font>
<font></font>
        huffman_decoder_init(&amp;litlen_dec, fixed_litlen_lengths,<font></font>
                             <span class="hljs-keyword">sizeof</span>(fixed_litlen_lengths) /
                             <span class="hljs-keyword">sizeof</span>(fixed_litlen_lengths[<span class="hljs-number">0</span>]));<font></font>
        huffman_decoder_init(&amp;dist_dec, fixed_dist_lengths,<font></font>
                             <span class="hljs-keyword">sizeof</span>(fixed_dist_lengths) /
                             <span class="hljs-keyword">sizeof</span>(fixed_dist_lengths[<span class="hljs-number">0</span>]));<font></font>
<font></font>
        <span class="hljs-keyword">return</span> inf_block(is, dst, dst_cap, dst_pos, &amp;litlen_dec, &amp;dist_dec);<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LITLEN_EOB 256</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LITLEN_MAX 285</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LITLEN_TBL_OFFSET 257</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LEN 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_LEN 258</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DISTSYM_MAX 29</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_DISTANCE 1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_DISTANCE 32768</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">inf_block</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_cap,
                            <span class="hljs-keyword">size_t</span> *dst_pos,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_decoder_t</span> *litlen_dec,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_decoder_t</span> *dist_dec)</span>
</span>{
        <span class="hljs-keyword">uint64_t</span> bits;
        <span class="hljs-keyword">size_t</span> used, used_tot, dist, len;
        <span class="hljs-keyword">int</span> litlen, distsym;
        <span class="hljs-keyword">uint16_t</span> ebits;<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
                <span class="hljs-comment">/* Read a litlen symbol. */</span><font></font>
                bits = istream_bits(is);<font></font>
                litlen = huffman_decode(litlen_dec, (<span class="hljs-keyword">uint16_t</span>)bits, &amp;used);<font></font>
                bits &gt;&gt;= used;<font></font>
                used_tot = used;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (litlen &lt; <span class="hljs-number">0</span> || litlen &gt; LITLEN_MAX) {
                        <span class="hljs-comment">/* Failed to decode, or invalid symbol. */</span>
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (litlen &lt;= UINT8_MAX) {
                        <span class="hljs-comment">/* Literal. */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, used_tot)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">if</span> (*dst_pos == dst_cap) {
                                <span class="hljs-keyword">return</span> HWINF_FULL;<font></font>
                        }<font></font>
                        lz77_output_lit(dst, (*dst_pos)++, (<span class="hljs-keyword">uint8_t</span>)litlen);
                        <span class="hljs-keyword">continue</span>;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (litlen == LITLEN_EOB) {
                        <span class="hljs-comment">/* End of block. */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, used_tot)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">return</span> HWINF_OK;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* It is a back reference. Figure out the length. */</span><font></font>
                assert(litlen &gt;= LITLEN_TBL_OFFSET &amp;&amp; litlen &lt;= LITLEN_MAX);<font></font>
                len   = litlen_tbl[litlen - LITLEN_TBL_OFFSET].base_len;<font></font>
                ebits = litlen_tbl[litlen - LITLEN_TBL_OFFSET].ebits;<font></font>
                <span class="hljs-keyword">if</span> (ebits != <span class="hljs-number">0</span>) {<font></font>
                        len += lsb(bits, ebits);<font></font>
                        bits &gt;&gt;= ebits;<font></font>
                        used_tot += ebits;<font></font>
                }<font></font>
                assert(len &gt;= MIN_LEN &amp;&amp; len &lt;= MAX_LEN);<font></font>
<font></font>
                <span class="hljs-comment">/* Get the distance. */</span>
                distsym = huffman_decode(dist_dec, (<span class="hljs-keyword">uint16_t</span>)bits, &amp;used);<font></font>
                bits &gt;&gt;= used;<font></font>
                used_tot += used;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (distsym &lt; <span class="hljs-number">0</span> || distsym &gt; DISTSYM_MAX) {
                        <span class="hljs-comment">/* Failed to decode, or invalid symbol. */</span>
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
                dist  = dist_tbl[distsym].base_dist;<font></font>
                ebits = dist_tbl[distsym].ebits;<font></font>
                <span class="hljs-keyword">if</span> (ebits != <span class="hljs-number">0</span>) {<font></font>
                        dist += lsb(bits, ebits);<font></font>
                        bits &gt;&gt;= ebits;<font></font>
                        used_tot += ebits;<font></font>
                }<font></font>
                assert(dist &gt;= MIN_DISTANCE &amp;&amp; dist &lt;= MAX_DISTANCE);<font></font>
<font></font>
                assert(used_tot &lt;= ISTREAM_MIN_BITS);<font></font>
                <span class="hljs-keyword">if</span> (!istream_advance(is, used_tot)) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Bounds check and output the backref. */</span>
                <span class="hljs-keyword">if</span> (dist &gt; *dst_pos) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (round_up(len, <span class="hljs-number">8</span>) &lt;= dst_cap - *dst_pos) {<font></font>
                        output_backref64(dst, *dst_pos, dist, len);<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &lt;= dst_cap - *dst_pos) {<font></font>
                        lz77_output_backref(dst, *dst_pos, dist, len);<font></font>
                } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">return</span> HWINF_FULL;<font></font>
                }<font></font>
                (*dst_pos) += len;<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie diese Optimierung: Wenn im ausgehenden Puffer nicht genügend Speicherplatz vorhanden ist, geben wir Backlinks mit der folgenden Funktion aus, die jeweils 64 Bit kopiert. </font><font style="vertical-align: inherit;">Dies ist in dem Sinne „chaotisch“, dass häufig einige zusätzliche Bytes kopiert werden (bis zum nächsten Vielfachen von 8). </font><font style="vertical-align: inherit;">Es funktioniert jedoch viel schneller </font></font><code>lz77_output_backref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da weniger zyklische Iterationen und Speicherzugriffe erforderlich sind. </font><font style="vertical-align: inherit;">Tatsächlich werden kurze Backlinks jetzt in einer Iteration verarbeitet, was sehr gut für die Vorhersage von Verzweigungen geeignet ist.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Output the (dist,len) backref at dst_pos in dst using 64-bit wide writes.
   There must be enough room for len bytes rounded to the next multiple of 8. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">output_backref64</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">size_t</span> dst_pos, <span class="hljs-keyword">size_t</span> dist,
                             <span class="hljs-keyword">size_t</span> len)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;
        <span class="hljs-keyword">uint64_t</span> tmp;<font></font>
<font></font>
        assert(len &gt; <span class="hljs-number">0</span>);<font></font>
        assert(dist &lt;= dst_pos &amp;&amp; <span class="hljs-string">"cannot reference before beginning of dst"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (len &gt; dist) {
                <span class="hljs-comment">/* Self-overlapping backref; fall back to byte-by-byte copy. */</span><font></font>
                lz77_output_backref(dst, dst_pos, dist, len);<font></font>
                <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">do</span> {
                <span class="hljs-built_in">memcpy</span>(&amp;tmp, &amp;dst[dst_pos - dist + i], <span class="hljs-number">8</span>);
                <span class="hljs-built_in">memcpy</span>(&amp;dst[dst_pos + i], &amp;tmp, <span class="hljs-number">8</span>);<font></font>
                i += <span class="hljs-number">8</span>;<font></font>
        } <span class="hljs-keyword">while</span> (i &lt; len);<font></font>
}<font></font>
</code></pre><br>
<a name="15"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blöcke mit dynamischen Huffman-Codes entleeren</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Entleeren von Blöcken mit dynamischen Huffman-Codes funktioniert auf die gleiche Weise wie oben beschrieben. Anstelle der vordefinierten Codes für litlen und dist verwenden sie jedoch die Codes, die am Anfang des Blocks im Deflate-Stream selbst gespeichert sind. Der Name ist wahrscheinlich nicht erfolgreich, da dynamische Huffman-Codes auch als Codes bezeichnet werden, die sich während der Codierung ändern - dies ist eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adaptive Huffman-Codierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die hier beschriebenen Codes haben nichts mit diesem Verfahren zu tun. Sie sind nur in dem Sinne dynamisch, dass unterschiedliche Blöcke unterschiedliche Codes verwenden können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Generieren dynamischer Litlen- und Dist-Codes ist der schwierigste Teil des Deflate-Formats. Aber sobald die Codes erzeugt werden, Dekompression wird auf die gleiche Weise wie im vorherigen Teil beschrieben, unter Verwendung von </font></font><code>inf_block</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">inf_dyn_block</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is, <span class="hljs-keyword">uint8_t</span> *dst,
                                <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_pos)</span>
</span>{
        <span class="hljs-keyword">inf_stat_t</span> s;
        <span class="hljs-keyword">huffman_decoder_t</span> litlen_dec, dist_dec;<font></font>
<font></font>
        s = init_dyn_decoders(is, &amp;litlen_dec, &amp;dist_dec);<font></font>
        <span class="hljs-keyword">if</span> (s != HWINF_OK) {
                <span class="hljs-keyword">return</span> s;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> inf_block(is, dst, dst_cap, dst_pos, &amp;litlen_dec, &amp;dist_dec);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Litlen- und Dist-Codes für dynamische Deflate-Blöcke werden als eine Reihe von Codewortlängen gespeichert. </font><font style="vertical-align: inherit;">Die Längen selbst werden mit dem dritten Huffman-Code </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codelen codiert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dieser Code wird durch die Länge der Codewörter ( </font></font><code>codelen_lens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) bestimmt, die im Block gespeichert sind (habe ich erwähnt, dass es schwierig ist?).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84e/1fc/0e3/84e1fc0e3d3cfcb56ff215702d14f73d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Anfang des dynamischen Blocks befinden sich 14 Bits, die die Anzahl der Litlen-, Dist- und Codelen-Längen von Codewörtern bestimmen, die aus dem Block gelesen werden müssen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_CODELEN_LENS 4</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_CODELEN_LENS 19</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_LITLEN_LENS 257</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_LITLEN_LENS 288</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN_DIST_LENS 1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_DIST_LENS 32</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_MAX_LIT 15</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_COPY 16</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_COPY_MIN 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_COPY_MAX 6</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS 17</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS_MIN 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS_MAX 10</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS2 18</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS2_MIN 11</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODELEN_ZEROS2_MAX 138</span><font></font>
<font></font>
<span class="hljs-comment">/* RFC 1951, 3.2.7 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> codelen_lengths_order[MAX_CODELEN_LENS] =<font></font>
{ <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">13</span>, <span class="hljs-number">2</span>, <span class="hljs-number">14</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span> };<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inf_stat_t</span> <span class="hljs-title">init_dyn_decoders</span><span class="hljs-params">(<span class="hljs-keyword">istream_t</span> *is,
                                    <span class="hljs-keyword">huffman_decoder_t</span> *litlen_dec,
                                    <span class="hljs-keyword">huffman_decoder_t</span> *dist_dec)</span>
</span>{
        <span class="hljs-keyword">uint64_t</span> bits;
        <span class="hljs-keyword">size_t</span> num_litlen_lens, num_dist_lens, num_codelen_lens;
        <span class="hljs-keyword">uint8_t</span> codelen_lengths[MAX_CODELEN_LENS];
        <span class="hljs-keyword">uint8_t</span> code_lengths[MAX_LITLEN_LENS + MAX_DIST_LENS];
        <span class="hljs-keyword">size_t</span> i, n, used;
        <span class="hljs-keyword">int</span> sym;
        <span class="hljs-keyword">huffman_decoder_t</span> codelen_dec;<font></font>
<font></font>
        bits = istream_bits(is);<font></font>
<font></font>
        <span class="hljs-comment">/* Number of litlen codeword lengths (5 bits + 257). */</span>
        num_litlen_lens = lsb(bits, <span class="hljs-number">5</span>) + MIN_LITLEN_LENS;<font></font>
        bits &gt;&gt;= <span class="hljs-number">5</span>;<font></font>
        assert(num_litlen_lens &lt;= MAX_LITLEN_LENS);<font></font>
<font></font>
        <span class="hljs-comment">/* Number of dist codeword lengths (5 bits + 1). */</span>
        num_dist_lens = lsb(bits, <span class="hljs-number">5</span>) + MIN_DIST_LENS;<font></font>
        bits &gt;&gt;= <span class="hljs-number">5</span>;<font></font>
        assert(num_dist_lens &lt;= MAX_DIST_LENS);<font></font>
<font></font>
        <span class="hljs-comment">/* Number of code length lengths (4 bits + 4). */</span>
        num_codelen_lens = lsb(bits, <span class="hljs-number">4</span>) + MIN_CODELEN_LENS;<font></font>
        bits &gt;&gt;= <span class="hljs-number">4</span>;<font></font>
        assert(num_codelen_lens &lt;= MAX_CODELEN_LENS);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">5</span> + <span class="hljs-number">5</span> + <span class="hljs-number">4</span>)) {
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann kommen die Codewortlängen für den Codelen-Code. </font><font style="vertical-align: inherit;">Diese Längen sind die üblichen Drei-Bit-Werte, werden jedoch in der in angegebenen speziellen Reihenfolge geschrieben </font></font><code>codelen_lengths_order</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da 19 Längen bestimmt werden müssen, wird nur der Stream gelesen </font></font><code>num_codelen_lens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">alles andere ist implizit null. </font><font style="vertical-align: inherit;">Die Längen werden in einer bestimmten Reihenfolge aufgelistet, sodass die Längen von Null eher am Ende der Liste liegen und nicht im Block gespeichert werden.</font></font><br>
<br>
<pre><code class="cpp hljs">       <span class="hljs-comment">/* Read the codelen codeword lengths (3 bits each)
           and initialize the codelen decoder. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_codelen_lens; i++) {<font></font>
                bits = istream_bits(is);<font></font>
                codelen_lengths[codelen_lengths_order[i]] =<font></font>
                        (<span class="hljs-keyword">uint8_t</span>)lsb(bits, <span class="hljs-number">3</span>);
                <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">3</span>)) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
        }<font></font>
        <span class="hljs-keyword">for</span> (; i &lt; MAX_CODELEN_LENS; i++) {<font></font>
                codelen_lengths[codelen_lengths_order[i]] = <span class="hljs-number">0</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (!huffman_decoder_init(&amp;codelen_dec, codelen_lengths,<font></font>
                                  MAX_CODELEN_LENS)) {<font></font>
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch Einstellen des Codelen-Decoders können wir die Länge der Codewörter litlen und dist vom Stream lesen.</font></font><br>
<br>
<pre><code class="cpp hljs">       <span class="hljs-comment">/* Read the litlen and dist codeword lengths. */</span>
        i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (i &lt; num_litlen_lens + num_dist_lens) {<font></font>
                bits = istream_bits(is);<font></font>
                sym = huffman_decode(&amp;codelen_dec, (<span class="hljs-keyword">uint16_t</span>)bits, &amp;used);<font></font>
                bits &gt;&gt;= used;<font></font>
                <span class="hljs-keyword">if</span> (!istream_advance(is, used)) {
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (sym &gt;= <span class="hljs-number">0</span> &amp;&amp; sym &lt;= CODELEN_MAX_LIT) {
                        <span class="hljs-comment">/* A literal codeword length. */</span>
                        code_lengths[i++] = (<span class="hljs-keyword">uint8_t</span>)sym;<font></font>
                }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16, 17 und 18 sind keine reellen Längen, sondern Indikatoren dafür, dass die vorherige Länge mehrmals wiederholt werden muss oder dass Sie die Länge Null wiederholen müssen:</font></font><br>
<br>
<pre><code class="cpp hljs">               <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_COPY) {
                        <span class="hljs-comment">/* Copy the previous codeword length 3--6 times. */</span>
                        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span>) {
                                <span class="hljs-keyword">return</span> HWINF_ERR; <span class="hljs-comment">/* No previous length. */</span><font></font>
                        }<font></font>
                        n = lsb(bits, <span class="hljs-number">2</span>) + CODELEN_COPY_MIN; <span class="hljs-comment">/* 2 bits + 3 */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">2</span>)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        assert(n &gt;= CODELEN_COPY_MIN &amp;&amp; n &lt;= CODELEN_COPY_MAX);<font></font>
                        <span class="hljs-keyword">if</span> (i + n &gt; num_litlen_lens + num_dist_lens) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">while</span> (n--) {<font></font>
                                code_lengths[i] = code_lengths[i - <span class="hljs-number">1</span>];<font></font>
                                i++;<font></font>
                        }<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_ZEROS) {
                        <span class="hljs-comment">/* 3--10 zeros. */</span>
                        n = lsb(bits, <span class="hljs-number">3</span>) + CODELEN_ZEROS_MIN; <span class="hljs-comment">/* 3 bits + 3 */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">3</span>)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        assert(n &gt;= CODELEN_ZEROS_MIN &amp;&amp;<font></font>
                               n &lt;= CODELEN_ZEROS_MAX);<font></font>
                        <span class="hljs-keyword">if</span> (i + n &gt; num_litlen_lens + num_dist_lens) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">while</span> (n--) {<font></font>
                                code_lengths[i++] = <span class="hljs-number">0</span>;<font></font>
                        }<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_ZEROS2) {
                        <span class="hljs-comment">/* 11--138 zeros. */</span>
                        n = lsb(bits, <span class="hljs-number">7</span>) + CODELEN_ZEROS2_MIN; <span class="hljs-comment">/* 7 bits +138 */</span>
                        <span class="hljs-keyword">if</span> (!istream_advance(is, <span class="hljs-number">7</span>)) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        assert(n &gt;= CODELEN_ZEROS2_MIN &amp;&amp;<font></font>
                               n &lt;= CODELEN_ZEROS2_MAX);<font></font>
                        <span class="hljs-keyword">if</span> (i + n &gt; num_litlen_lens + num_dist_lens) {
                                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">while</span> (n--) {<font></font>
                                code_lengths[i++] = <span class="hljs-number">0</span>;<font></font>
                        }<font></font>
                } <span class="hljs-keyword">else</span> {
                        <span class="hljs-comment">/* Invalid symbol. */</span>
                        <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
                }<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass Litlen- und Dist-Längen einzeln in das Array eingelesen werden </font></font><code>code_lengths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie können nicht separat gelesen werden, da Codelängenläufe von den letzten kleinen Längen auf die ersten dist Längen übertragen werden können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir die Codewortlängen vorbereitet haben, können wir Huffman-Decoder konfigurieren und zur Aufgabe des Decodierens von Literalen und Backlinks zurückkehren:</font></font><br>
<br>
<pre><code class="cpp hljs">       <span class="hljs-keyword">if</span> (!huffman_decoder_init(litlen_dec, &amp;code_lengths[<span class="hljs-number">0</span>],<font></font>
                                  num_litlen_lens)) {<font></font>
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (!huffman_decoder_init(dist_dec, &amp;code_lengths[num_litlen_lens],<font></font>
                                  num_dist_lens)) {<font></font>
                <span class="hljs-keyword">return</span> HWINF_ERR;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> HWINF_OK;<font></font>
}<font></font>
</code></pre><br>
<a name="16"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompression (Deflation)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den vorherigen Teilen haben wir alle für die Deflate-Komprimierung erforderlichen Tools erstellt: Lempel-Ziv, Huffman-Codierung, Bitströme und eine Beschreibung der drei Arten von Deflate-Blöcken. Und in diesem Teil werden wir alles zusammenfügen, um die Deflate-Komprimierung zu erreichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Komprimierung Lempel-Ziv analysiert die Quelldaten in eine Folge von Backlinks und Literalen. Diese Sequenz muss wie im vorherigen Teil beschrieben in Deflate-Blöcke unterteilt und codiert werden. Die Auswahl einer Partitionierungsmethode wird häufig als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blockierung bezeichnet.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Einerseits bedeutet jeder neue Block eine Art Overhead, dessen Volumen von der Art des Blocks und seinem Inhalt abhängt. </font><font style="vertical-align: inherit;">Weniger Blöcke - weniger Aufwand. </font><font style="vertical-align: inherit;">Andererseits können sich diese Kosten für die Erstellung eines neuen Blocks auszahlen. </font><font style="vertical-align: inherit;">Zum Beispiel, wenn die Eigenschaften der Daten es Ihnen ermöglichen, die Huffman-Codierung effizienter durchzuführen und die Gesamtmenge der generierten Daten zu reduzieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Blockieren ist eine schwierige Optimierungsaufgabe. </font><font style="vertical-align: inherit;">Einige Kompressoren (zum Beispiel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zopfli</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) versuchen es besser als andere, aber die meisten verwenden einfach den gierigen Ansatz: Sie geben Blöcke aus, sobald sie eine bestimmte Größe erreichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verschiedene Arten von Blöcken haben ihre eigenen Größenbeschränkungen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicht komprimierte Blöcke dürfen nicht mehr als 65.535 Byte enthalten.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman-Festcodes haben keine maximale Größe.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamische Huffman-Codes haben im Allgemeinen keine maximale Größe, aber da unsere Implementierung des Huffman-Algorithmus 16-Bit-Zeichenfolgen verwendet, sind wir auf 65.535 Zeichen beschränkt.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um Blöcke jeglichen Typs frei zu verwenden, beschränken Sie ihre Größe auf 65.534 Bytes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* The largest number of bytes that will fit in any kind of block is 65,534.
   It will fit in an uncompressed block (max 65,535 bytes) and a Huffman
   block with only literals (65,535 symbols including end-of-block marker). */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_BLOCK_LEN_BYTES 65534</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den ausgehenden Bitstrom und den Inhalt des aktuellen Blocks während der Komprimierung zu verfolgen, verwenden wir die folgende Struktur:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deflate_state_t</span> <span class="hljs-title">deflate_state_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deflate_state_t</span> {</span>
        <span class="hljs-keyword">ostream_t</span> os;<font></font>
<font></font>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *block_src; <span class="hljs-comment">/* First src byte in the block. */</span><font></font>
<font></font>
        <span class="hljs-keyword">size_t</span> block_len;       <span class="hljs-comment">/* Number of symbols in the current block. */</span>
        <span class="hljs-keyword">size_t</span> block_len_bytes; <span class="hljs-comment">/* Number of src bytes in the block. */</span><font></font>
<font></font>
        <span class="hljs-comment">/* Symbol frequencies for the current block. */</span>
        <span class="hljs-keyword">uint16_t</span> litlen_freqs[LITLEN_MAX + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">uint16_t</span> dist_freqs[DISTSYM_MAX + <span class="hljs-number">1</span>];<font></font>
<font></font>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
                <span class="hljs-keyword">uint16_t</span> distance;    <span class="hljs-comment">/* Backref distance. */</span>
                <span class="hljs-keyword">union</span> {
                        <span class="hljs-keyword">uint16_t</span> lit; <span class="hljs-comment">/* Literal byte or end-of-block. */</span>
                        <span class="hljs-keyword">uint16_t</span> len; <span class="hljs-comment">/* Backref length (distance != 0). */</span><font></font>
                } u;<font></font>
        } block[MAX_BLOCK_LEN_BYTES + <span class="hljs-number">1</span>];<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reset_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s)</span>
</span>{<font></font>
        s-&gt;block_len = <span class="hljs-number">0</span>;<font></font>
        s-&gt;block_len_bytes = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">memset</span>(s-&gt;litlen_freqs, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(s-&gt;litlen_freqs));
        <span class="hljs-built_in">memset</span>(s-&gt;dist_freqs, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(s-&gt;dist_freqs));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dem Block Arbeitsergebnisse hinzuzufügen, verwenden </font></font><code>lz77_compress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir die Rückruffunktionen, und wenn die maximale Größe erreicht ist, schreiben wir den Block in den Bitstrom:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">lit_callback</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> lit, <span class="hljs-keyword">void</span> *aux)</span>
</span>{
        <span class="hljs-keyword">deflate_state_t</span> *s = aux;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (s-&gt;block_len_bytes + <span class="hljs-number">1</span> &gt; MAX_BLOCK_LEN_BYTES) {
                <span class="hljs-keyword">if</span> (!write_block(s, <span class="hljs-literal">false</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                s-&gt;block_src += s-&gt;block_len_bytes;<font></font>
                reset_block(s);<font></font>
        }<font></font>
<font></font>
        assert(s-&gt;block_len &lt; <span class="hljs-keyword">sizeof</span>(s-&gt;block) / <span class="hljs-keyword">sizeof</span>(s-&gt;block[<span class="hljs-number">0</span>]));<font></font>
        s-&gt;block[s-&gt;block_len  ].distance = <span class="hljs-number">0</span>;<font></font>
        s-&gt;block[s-&gt;block_len++].u.lit = lit;<font></font>
        s-&gt;block_len_bytes++;<font></font>
<font></font>
        s-&gt;litlen_freqs[lit]++;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">backref_callback</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> dist, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">void</span> *aux)</span>
</span>{
        <span class="hljs-keyword">deflate_state_t</span> *s = aux;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (s-&gt;block_len_bytes + len &gt; MAX_BLOCK_LEN_BYTES) {
                <span class="hljs-keyword">if</span> (!write_block(s, <span class="hljs-literal">false</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                s-&gt;block_src += s-&gt;block_len_bytes;<font></font>
                reset_block(s);<font></font>
        }<font></font>
<font></font>
        assert(s-&gt;block_len &lt; <span class="hljs-keyword">sizeof</span>(s-&gt;block) / <span class="hljs-keyword">sizeof</span>(s-&gt;block[<span class="hljs-number">0</span>]));<font></font>
        s-&gt;block[s-&gt;block_len  ].distance = (<span class="hljs-keyword">uint16_t</span>)dist;<font></font>
        s-&gt;block[s-&gt;block_len++].u.len = (<span class="hljs-keyword">uint16_t</span>)len;<font></font>
        s-&gt;block_len_bytes += len;<font></font>
<font></font>
        assert(len &gt;= MIN_LEN &amp;&amp; len &lt;= MAX_LEN);<font></font>
        assert(dist &gt;= MIN_DISTANCE &amp;&amp; dist &lt;= MAX_DISTANCE);<font></font>
        s-&gt;litlen_freqs[len2litlen[len]]++;<font></font>
        s-&gt;dist_freqs[distance2dist[dist]]++;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Interessanteste ist die Aufnahme von Blöcken. </font><font style="vertical-align: inherit;">Wenn der Block nicht komprimiert ist, ist alles einfach:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_uncomp_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">final</span>)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> len_nlen[<span class="hljs-number">4</span>];<font></font>
<font></font>
        <span class="hljs-comment">/* Write the block header. */</span>
        <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, (<span class="hljs-number">0x0</span> &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-keyword">final</span>, <span class="hljs-number">3</span>)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        len_nlen[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">uint8_t</span>)(s-&gt;block_len_bytes &gt;&gt; <span class="hljs-number">0</span>);<font></font>
        len_nlen[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">uint8_t</span>)(s-&gt;block_len_bytes &gt;&gt; <span class="hljs-number">8</span>);<font></font>
        len_nlen[<span class="hljs-number">2</span>] = ~len_nlen[<span class="hljs-number">0</span>];<font></font>
        len_nlen[<span class="hljs-number">3</span>] = ~len_nlen[<span class="hljs-number">1</span>];<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!ostream_write_bytes_aligned(&amp;s-&gt;os, len_nlen, <span class="hljs-keyword">sizeof</span>(len_nlen))) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!ostream_write_bytes_aligned(&amp;s-&gt;os, s-&gt;block_src,<font></font>
                                         s-&gt;block_len_bytes)) {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um einen statischen Huffman-Block zu schreiben, generieren wir zuerst kanonische Codes basierend auf festen Codewortlängen für Litlen- und Dist-Codes. </font><font style="vertical-align: inherit;">Dann iterieren wir den Block und schreiben die Zeichen auf, die diese Codes verwenden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_static_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">final</span>)</span>
</span>{
        <span class="hljs-keyword">huffman_encoder_t</span> litlen_enc, dist_enc;<font></font>
<font></font>
        <span class="hljs-comment">/* Write the block header. */</span>
        <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, (<span class="hljs-number">0x1</span> &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-keyword">final</span>, <span class="hljs-number">3</span>)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        huffman_encoder_init2(&amp;litlen_enc, fixed_litlen_lengths,<font></font>
                              <span class="hljs-keyword">sizeof</span>(fixed_litlen_lengths) /
                              <span class="hljs-keyword">sizeof</span>(fixed_litlen_lengths[<span class="hljs-number">0</span>]));<font></font>
        huffman_encoder_init2(&amp;dist_enc, fixed_dist_lengths,<font></font>
                              <span class="hljs-keyword">sizeof</span>(fixed_dist_lengths) /
                              <span class="hljs-keyword">sizeof</span>(fixed_dist_lengths[<span class="hljs-number">0</span>]));<font></font>
<font></font>
        <span class="hljs-keyword">return</span> write_huffman_block(s, &amp;litlen_enc, &amp;dist_enc);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_huffman_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *litlen_enc,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *dist_enc)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i, nbits;
        <span class="hljs-keyword">uint64_t</span> distance, dist, len, litlen, bits, ebits;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; s-&gt;block_len; i++) {
                <span class="hljs-keyword">if</span> (s-&gt;block[i].distance == <span class="hljs-number">0</span>) {
                        <span class="hljs-comment">/* Literal or EOB. */</span><font></font>
                        litlen = s-&gt;block[i].u.lit;<font></font>
                        assert(litlen &lt;= LITLEN_EOB);<font></font>
                        <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os,<font></font>
                                           litlen_enc-&gt;codewords[litlen],<font></font>
                                           litlen_enc-&gt;lengths[litlen])) {<font></font>
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                        }<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Back reference length. */</span><font></font>
                len = s-&gt;block[i].u.len;<font></font>
                litlen = len2litlen[len];<font></font>
<font></font>
                <span class="hljs-comment">/* litlen bits */</span><font></font>
                bits = litlen_enc-&gt;codewords[litlen];<font></font>
                nbits = litlen_enc-&gt;lengths[litlen];<font></font>
<font></font>
                <span class="hljs-comment">/* ebits */</span><font></font>
                ebits = len - litlen_tbl[litlen - LITLEN_TBL_OFFSET].base_len;<font></font>
                bits |= ebits &lt;&lt; nbits;<font></font>
                nbits += litlen_tbl[litlen - LITLEN_TBL_OFFSET].ebits;<font></font>
<font></font>
                <span class="hljs-comment">/* Back reference distance. */</span><font></font>
                distance = s-&gt;block[i].distance;<font></font>
                dist = distance2dist[distance];<font></font>
<font></font>
                <span class="hljs-comment">/* dist bits */</span>
                bits |= (<span class="hljs-keyword">uint64_t</span>)dist_enc-&gt;codewords[dist] &lt;&lt; nbits;<font></font>
                nbits += dist_enc-&gt;lengths[dist];<font></font>
<font></font>
                <span class="hljs-comment">/* ebits */</span><font></font>
                ebits = distance - dist_tbl[dist].base_dist;<font></font>
                bits |= ebits &lt;&lt; nbits;<font></font>
                nbits += dist_tbl[dist].ebits;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, bits, nbits)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Schreiben von dynamischen Huffman-Blöcken ist natürlich schwieriger, da sie eine schwierige Codierung von Litlen- und Dist-Codes enthalten. </font><font style="vertical-align: inherit;">Um diese Codierung darzustellen, verwenden wir die folgende Struktur:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">codelen_sym_t</span> <span class="hljs-title">codelen_sym_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">codelen_sym_t</span> {</span>
        <span class="hljs-keyword">uint8_t</span> sym;
        <span class="hljs-keyword">uint8_t</span> count; <span class="hljs-comment">/* For symbols 16, 17, 18. */</span><font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst verwerfen wir das Ende ihrer Nulllängen der Codewörter litlen und dist und kopieren sie dann zur nachfolgenden Codierung in ein reguläres Array. </font><font style="vertical-align: inherit;">Wir können nicht alle Nullen verwerfen: Es ist unmöglich, einen Deflate-Block zu codieren, wenn kein einziger dist-Code darin enthalten ist. </font><font style="vertical-align: inherit;">Es ist auch unmöglich, weniger als 257 Litlen-Codes zu haben, aber da wir immer eine Byte-Endmarkierung haben, gibt es für ein Zeichen von 256 immer eine Codelänge ungleich Null.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Encode litlen_lens and dist_lens into encoded. *num_litlen_lens and
   *num_dist_lens will be set to the number of encoded litlen and dist lens,
   respectively. Returns the number of elements in encoded. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">encode_dist_litlen_lens</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *litlen_lens,
                                      <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *dist_lens,
                                      <span class="hljs-keyword">codelen_sym_t</span> *encoded,
                                      <span class="hljs-keyword">size_t</span> *num_litlen_lens,
                                      <span class="hljs-keyword">size_t</span> *num_dist_lens)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i, n;
        <span class="hljs-keyword">uint8_t</span> lens[LITLEN_MAX + <span class="hljs-number">1</span> + DISTSYM_MAX + <span class="hljs-number">1</span>];<font></font>
<font></font>
        *num_litlen_lens = LITLEN_MAX + <span class="hljs-number">1</span>;<font></font>
        *num_dist_lens = DISTSYM_MAX + <span class="hljs-number">1</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* Drop trailing zero litlen lengths. */</span>
        assert(litlen_lens[LITLEN_EOB] != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-string">"EOB len should be non-zero."</span>);
        <span class="hljs-keyword">while</span> (litlen_lens[*num_litlen_lens - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) {<font></font>
                (*num_litlen_lens)--;<font></font>
        }<font></font>
        assert(*num_litlen_lens &gt;= MIN_LITLEN_LENS);<font></font>
<font></font>
        <span class="hljs-comment">/* Drop trailing zero dist lengths, keeping at least one. */</span>
        <span class="hljs-keyword">while</span> (dist_lens[*num_dist_lens - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; *num_dist_lens &gt; <span class="hljs-number">1</span>) {<font></font>
                (*num_dist_lens)--;<font></font>
        }<font></font>
        assert(*num_dist_lens &gt;= MIN_DIST_LENS);<font></font>
<font></font>
        <span class="hljs-comment">/* Copy the lengths into a unified array. */</span>
        n = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; *num_litlen_lens; i++) {<font></font>
                lens[n++] = litlen_lens[i];<font></font>
        }<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; *num_dist_lens; i++) {<font></font>
                lens[n++] = dist_lens[i];<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> encode_lens(lens, n, encoded);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir die Codelängen zu einem Array hinzugefügt haben, führen wir die Codierung mit Sonderzeichen durch, um dieselben Codelängen auszuführen.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Encode the n code lengths in lens into encoded, returning the number of
   elements in encoded. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">encode_lens</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *lens, <span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">codelen_sym_t</span> *encoded)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i, j, num_encoded;
        <span class="hljs-keyword">uint8_t</span> count;<font></font>
<font></font>
        i = <span class="hljs-number">0</span>;<font></font>
        num_encoded = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (i &lt; n) {
                <span class="hljs-keyword">if</span> (lens[i] == <span class="hljs-number">0</span>) {
                        <span class="hljs-comment">/* Scan past the end of this zero run (max 138). */</span>
                        <span class="hljs-keyword">for</span> (j = i; j &lt; min(n, i + CODELEN_ZEROS2_MAX) &amp;&amp;<font></font>
                                    lens[j] == <span class="hljs-number">0</span>; j++);<font></font>
                        count = (<span class="hljs-keyword">uint8_t</span>)(j - i);<font></font>
<font></font>
                        <span class="hljs-keyword">if</span> (count &lt; CODELEN_ZEROS_MIN) {
                                <span class="hljs-comment">/* Output a single zero. */</span>
                                encoded[num_encoded++].sym = <span class="hljs-number">0</span>;<font></font>
                                i++;<font></font>
                                <span class="hljs-keyword">continue</span>;<font></font>
                        }<font></font>
<font></font>
                        <span class="hljs-comment">/* Output a repeated zero. */</span>
                        <span class="hljs-keyword">if</span> (count &lt;= CODELEN_ZEROS_MAX) {
                                <span class="hljs-comment">/* Repeated zero 3--10 times. */</span><font></font>
                                assert(count &gt;= CODELEN_ZEROS_MIN &amp;&amp;<font></font>
                                       count &lt;= CODELEN_ZEROS_MAX);<font></font>
                                encoded[num_encoded].sym = CODELEN_ZEROS;<font></font>
                                encoded[num_encoded++].count = count;<font></font>
                        } <span class="hljs-keyword">else</span> {
                                <span class="hljs-comment">/* Repeated zero 11--138 times. */</span><font></font>
                                assert(count &gt;= CODELEN_ZEROS2_MIN &amp;&amp;<font></font>
                                       count &lt;= CODELEN_ZEROS2_MAX);<font></font>
                                encoded[num_encoded].sym = CODELEN_ZEROS2;<font></font>
                                encoded[num_encoded++].count = count;<font></font>
                        }<font></font>
                        i = j;<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-comment">/* Output len. */</span><font></font>
                encoded[num_encoded++].sym = lens[i++];<font></font>
<font></font>
                <span class="hljs-comment">/* Scan past the end of the run of this len (max 6). */</span>
                <span class="hljs-keyword">for</span> (j = i; j &lt; min(n, i + CODELEN_COPY_MAX) &amp;&amp;<font></font>
                            lens[j] == lens[i - <span class="hljs-number">1</span>]; j++);<font></font>
                count = (<span class="hljs-keyword">uint8_t</span>)(j - i);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (count &gt;= CODELEN_COPY_MIN) {
                        <span class="hljs-comment">/* Repeat last len 3--6 times. */</span><font></font>
                        assert(count &gt;= CODELEN_COPY_MIN &amp;&amp;<font></font>
                               count &lt;= CODELEN_COPY_MAX);<font></font>
                        encoded[num_encoded].sym = CODELEN_COPY;<font></font>
                        encoded[num_encoded++].count = count;<font></font>
                        i = j;<font></font>
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> num_encoded;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die für die Codierung verwendeten Zeichen werden mit dem Huffman-Code codelen aufgezeichnet. </font><font style="vertical-align: inherit;">Die Längen der Codewörter aus dem Codelen-Code werden in einer bestimmten Reihenfolge in den Block geschrieben, sodass es wahrscheinlicher ist, dass am Ende keine Längen von Null enden. </font><font style="vertical-align: inherit;">Hier ist eine Funktion, die berechnet, wie viele Längen geschrieben werden sollen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> codelen_lengths_order[<span class="hljs-number">19</span>] =<font></font>
{ <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">13</span>, <span class="hljs-number">2</span>, <span class="hljs-number">14</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span> };<font></font>
<font></font>
<span class="hljs-comment">/* Count the number of significant (not trailing zeros) codelen lengths. */</span>
<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">count_codelen_lens</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *codelen_lens)</span>
</span>{
        <span class="hljs-keyword">size_t</span> n = MAX_CODELEN_LENS;<font></font>
<font></font>
        <span class="hljs-comment">/* Drop trailing zero lengths. */</span>
        <span class="hljs-keyword">while</span> (codelen_lens[codelen_lengths_order[n - <span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>) {<font></font>
                n--;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* The first 4 lengths in the order (16, 17, 18, 0) cannot be used to
           encode any non-zero lengths. Since there will always be at least
           one non-zero codeword length (for EOB), n will be &gt;= 4. */</span><font></font>
        assert(n &gt;= MIN_CODELEN_LENS &amp;&amp; n &lt;= MAX_CODELEN_LENS);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> n;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, wir haben bereits die Codes litlen und dist festgelegt, die Codierung der Längen ihrer Codewörter und den Code für diese Längen festgelegt. </font><font style="vertical-align: inherit;">Jetzt können wir einen dynamischen Huffman-Block schreiben:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_dynamic_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">final</span>,
                                <span class="hljs-keyword">size_t</span> num_litlen_lens, <span class="hljs-keyword">size_t</span> num_dist_lens,
                                <span class="hljs-keyword">size_t</span> num_codelen_lens,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *codelen_enc,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">codelen_sym_t</span> *encoded_lens,
                                <span class="hljs-keyword">size_t</span> num_encoded_lens,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *litlen_enc,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *dist_enc)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i;
        <span class="hljs-keyword">uint8_t</span> codelen, sym;
        <span class="hljs-keyword">size_t</span> nbits;
        <span class="hljs-keyword">uint64_t</span> bits, hlit, hdist, hclen, count;<font></font>
<font></font>
        <span class="hljs-comment">/* Block header. */</span>
        bits = (<span class="hljs-number">0x2</span> &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-keyword">final</span>;<font></font>
        nbits = <span class="hljs-number">3</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* hlit (5 bits) */</span><font></font>
        hlit = num_litlen_lens - MIN_LITLEN_LENS;<font></font>
        bits |= hlit &lt;&lt; nbits;<font></font>
        nbits += <span class="hljs-number">5</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* hdist (5 bits) */</span><font></font>
        hdist = num_dist_lens - MIN_DIST_LENS;<font></font>
        bits |= hdist &lt;&lt; nbits;<font></font>
        nbits += <span class="hljs-number">5</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* hclen (4 bits) */</span><font></font>
        hclen = num_codelen_lens - MIN_CODELEN_LENS;<font></font>
        bits |= hclen &lt;&lt; nbits;<font></font>
        nbits += <span class="hljs-number">4</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, bits, nbits)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Codelen lengths. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_codelen_lens; i++) {<font></font>
                codelen = codelen_enc-&gt;lengths[codelen_lengths_order[i]];<font></font>
                <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, codelen, <span class="hljs-number">3</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* Litlen and dist code lengths. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_encoded_lens; i++) {<font></font>
                sym = encoded_lens[i].sym;<font></font>
<font></font>
                bits = codelen_enc-&gt;codewords[sym];<font></font>
                nbits = codelen_enc-&gt;lengths[sym];<font></font>
<font></font>
                count = encoded_lens[i].count;<font></font>
                <span class="hljs-keyword">if</span> (sym == CODELEN_COPY) { <span class="hljs-comment">/* 2 ebits */</span><font></font>
                        bits |= (count - CODELEN_COPY_MIN) &lt;&lt; nbits;<font></font>
                        nbits += <span class="hljs-number">2</span>;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_ZEROS) { <span class="hljs-comment">/* 3 ebits */</span><font></font>
                        bits |= (count - CODELEN_ZEROS_MIN) &lt;&lt; nbits;<font></font>
                        nbits += <span class="hljs-number">3</span>;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sym == CODELEN_ZEROS2) { <span class="hljs-comment">/* 7 ebits */</span><font></font>
                        bits |= (count - CODELEN_ZEROS2_MIN) &lt;&lt; nbits;<font></font>
                        nbits += <span class="hljs-number">7</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (!ostream_write(&amp;s-&gt;os, bits, nbits)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> write_huffman_block(s, litlen_enc, dist_enc);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für jeden Block möchten wir den Typ verwenden, der die geringste Anzahl von Bits erfordert. </font><font style="vertical-align: inherit;">Die Länge eines unkomprimierten Blocks kann schnell berechnet werden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Calculate the number of bits for an uncompressed block, including header. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">uncomp_block_len</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">deflate_state_t</span> *s)</span>
</span>{
        <span class="hljs-keyword">size_t</span> bit_pos, padding;<font></font>
<font></font>
        <span class="hljs-comment">/* Bit position after writing the block header. */</span>
        bit_pos = ostream_bit_pos(&amp;s-&gt;os) + <span class="hljs-number">3</span>;<font></font>
        padding = round_up(bit_pos, <span class="hljs-number">8</span>) - bit_pos;<font></font>
<font></font>
        <span class="hljs-comment">/* Header + padding + len/nlen + block contents. */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span> + padding + <span class="hljs-number">2</span> * <span class="hljs-number">16</span> + s-&gt;block_len_bytes * <span class="hljs-number">8</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für Huffman-codierte Blöcke können Sie die Körperlänge anhand der Litlen- und Dist-Frequenzen von Zeichen und Codewortlängen berechnen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Calculate the number of bits for a Huffman encoded block body. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">huffman_block_body_len</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">deflate_state_t</span> *s,
                                     <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *litlen_lens,
                                     <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *dist_lens)</span>
</span>{
        <span class="hljs-keyword">size_t</span> i, freq, len;<font></font>
<font></font>
        len = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= LITLEN_MAX; i++) {<font></font>
                freq = s-&gt;litlen_freqs[i];<font></font>
                len += litlen_lens[i] * freq;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (i &gt;= LITLEN_TBL_OFFSET) {<font></font>
                        len += litlen_tbl[i - LITLEN_TBL_OFFSET].ebits * freq;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= DISTSYM_MAX; i++) {<font></font>
                freq = s-&gt;dist_freqs[i];<font></font>
                len += dist_lens[i] * freq;<font></font>
                len += dist_tbl[i].ebits * freq;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> len;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Gesamtlänge des statischen Blocks beträgt 3 Bits des Headers plus der Länge des Körpers. </font><font style="vertical-align: inherit;">Das Berechnen der Headergröße eines dynamischen Blocks erfordert viel mehr Arbeit:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Calculate the number of bits for a dynamic Huffman block. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">dyn_block_len</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">size_t</span> num_codelen_lens,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint16_t</span> *codelen_freqs,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *codelen_enc,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *litlen_enc,
                            <span class="hljs-keyword">const</span> <span class="hljs-keyword">huffman_encoder_t</span> *dist_enc)</span>
</span>{
        <span class="hljs-keyword">size_t</span> len, i, freq;<font></font>
<font></font>
        <span class="hljs-comment">/* Block header. */</span>
        len = <span class="hljs-number">3</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* Nbr of litlen, dist, and codelen lengths. */</span>
        len += <span class="hljs-number">5</span> + <span class="hljs-number">5</span> + <span class="hljs-number">4</span>;<font></font>
<font></font>
        <span class="hljs-comment">/* Codelen lengths. */</span>
        len += <span class="hljs-number">3</span> * num_codelen_lens;<font></font>
<font></font>
        <span class="hljs-comment">/* Codelen encoding. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_CODELEN_LENS; i++) {<font></font>
                freq = codelen_freqs[i];<font></font>
                len += codelen_enc-&gt;lengths[i] * freq;<font></font>
<font></font>
                <span class="hljs-comment">/* Extra bits. */</span>
                <span class="hljs-keyword">if</span> (i == CODELEN_COPY) {<font></font>
                        len += <span class="hljs-number">2</span> * freq;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == CODELEN_ZEROS) {<font></font>
                        len += <span class="hljs-number">3</span> * freq;<font></font>
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == CODELEN_ZEROS2) {<font></font>
                        len += <span class="hljs-number">7</span> * freq;<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> len + huffman_block_body_len(s, litlen_enc-&gt;lengths,<font></font>
                                            dist_enc-&gt;lengths);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt werden wir alles zusammenfügen und die Hauptfunktion zum Schreiben von Blöcken erstellen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Write the current deflate block, marking it final if that parameter is true,
   returning false if there is not enough room in the output stream. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">write_block</span><span class="hljs-params">(<span class="hljs-keyword">deflate_state_t</span> *s, <span class="hljs-keyword">bool</span> <span class="hljs-keyword">final</span>)</span>
</span>{
        <span class="hljs-keyword">size_t</span> old_bit_pos, uncomp_len, static_len, dynamic_len;
        <span class="hljs-keyword">huffman_encoder_t</span> dyn_litlen_enc, dyn_dist_enc, codelen_enc;
        <span class="hljs-keyword">size_t</span> num_encoded_lens, num_litlen_lens, num_dist_lens;
        <span class="hljs-keyword">codelen_sym_t</span> encoded_lens[LITLEN_MAX + <span class="hljs-number">1</span> + DISTSYM_MAX + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">uint16_t</span> codelen_freqs[MAX_CODELEN_LENS] = {<span class="hljs-number">0</span>};
        <span class="hljs-keyword">size_t</span> num_codelen_lens;
        <span class="hljs-keyword">size_t</span> i;<font></font>
<font></font>
        old_bit_pos = ostream_bit_pos(&amp;s-&gt;os);<font></font>
<font></font>
        <span class="hljs-comment">/* Add the end-of-block marker in case we write a Huffman block. */</span>
        assert(s-&gt;block_len &lt; <span class="hljs-keyword">sizeof</span>(s-&gt;block) / <span class="hljs-keyword">sizeof</span>(s-&gt;block[<span class="hljs-number">0</span>]));<font></font>
        assert(s-&gt;litlen_freqs[LITLEN_EOB] == <span class="hljs-number">0</span>);<font></font>
        s-&gt;block[s-&gt;block_len  ].distance = <span class="hljs-number">0</span>;<font></font>
        s-&gt;block[s-&gt;block_len++].u.lit = LITLEN_EOB;<font></font>
        s-&gt;litlen_freqs[LITLEN_EOB] = <span class="hljs-number">1</span>;<font></font>
<font></font>
        uncomp_len = uncomp_block_len(s);<font></font>
<font></font>
        static_len = <span class="hljs-number">3</span> + huffman_block_body_len(s, fixed_litlen_lengths,<font></font>
                                                fixed_dist_lengths);<font></font>
<font></font>
        <span class="hljs-comment">/* Compute "dynamic" Huffman codes. */</span><font></font>
        huffman_encoder_init(&amp;dyn_litlen_enc, s-&gt;litlen_freqs,<font></font>
                             LITLEN_MAX + <span class="hljs-number">1</span>, <span class="hljs-number">15</span>);<font></font>
        huffman_encoder_init(&amp;dyn_dist_enc, s-&gt;dist_freqs, DISTSYM_MAX + <span class="hljs-number">1</span>, <span class="hljs-number">15</span>);<font></font>
<font></font>
        <span class="hljs-comment">/* Encode the litlen and dist code lengths. */</span><font></font>
        num_encoded_lens = encode_dist_litlen_lens(dyn_litlen_enc.lengths,<font></font>
                                                   dyn_dist_enc.lengths,<font></font>
                                                   encoded_lens,<font></font>
                                                   &amp;num_litlen_lens,<font></font>
                                                   &amp;num_dist_lens);<font></font>
<font></font>
        <span class="hljs-comment">/* Compute the codelen code. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_encoded_lens; i++) {<font></font>
                codelen_freqs[encoded_lens[i].sym]++;<font></font>
        }<font></font>
        huffman_encoder_init(&amp;codelen_enc, codelen_freqs, MAX_CODELEN_LENS, <span class="hljs-number">7</span>);<font></font>
        num_codelen_lens = count_codelen_lens(codelen_enc.lengths);<font></font>
<font></font>
        dynamic_len = dyn_block_len(s, num_codelen_lens, codelen_freqs,<font></font>
                                    &amp;codelen_enc, &amp;dyn_litlen_enc,<font></font>
                                    &amp;dyn_dist_enc);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (uncomp_len &lt;= dynamic_len &amp;&amp; uncomp_len &lt;= static_len) {
                <span class="hljs-keyword">if</span> (!write_uncomp_block(s, <span class="hljs-keyword">final</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                assert(ostream_bit_pos(&amp;s-&gt;os) - old_bit_pos == uncomp_len);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (static_len &lt;= dynamic_len) {
                <span class="hljs-keyword">if</span> (!write_static_block(s, <span class="hljs-keyword">final</span>)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                assert(ostream_bit_pos(&amp;s-&gt;os) - old_bit_pos == static_len);<font></font>
        } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (!write_dynamic_block(s, <span class="hljs-keyword">final</span>, num_litlen_lens,<font></font>
                                         num_dist_lens, num_codelen_lens,<font></font>
                                         &amp;codelen_enc, encoded_lens,<font></font>
                                         num_encoded_lens, &amp;dyn_litlen_enc,<font></font>
                                         &amp;dyn_dist_enc)) {<font></font>
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                assert(ostream_bit_pos(&amp;s-&gt;os) - old_bit_pos == dynamic_len);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich sollte der Initiator des gesamten Komprimierungsprozesses den Anfangszustand festlegen, die Lempel-Ziv-Komprimierung starten und den resultierenden Block schreiben:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Compress (deflate) the data in src into dst. The number of bytes output, at
   most dst_cap, is stored in *dst_used. Returns false if there is not enough
   room in dst. src and dst must not overlap. */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hwdeflate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len, <span class="hljs-keyword">uint8_t</span> *dst,
               <span class="hljs-keyword">size_t</span> dst_cap, <span class="hljs-keyword">size_t</span> *dst_used)</span>
</span>{
        <span class="hljs-keyword">deflate_state_t</span> s;<font></font>
<font></font>
        ostream_init(&amp;s.os, dst, dst_cap);<font></font>
        reset_block(&amp;s);<font></font>
        s.block_src = src;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!lz77_compress(src, src_len, &amp;lit_callback,<font></font>
                           &amp;backref_callback, &amp;s)) {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!write_block(&amp;s, <span class="hljs-literal">true</span>)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">/* The end of the final block should match the end of src. */</span><font></font>
        assert(s.block_src + s.block_len_bytes == src + src_len);<font></font>
<font></font>
        *dst_used = ostream_bytes_written(&amp;s.os);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br>
<a name="17"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zip-Dateiformat</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oben haben wir untersucht, wie die in Zip-Dateien verwendete Deflate-Komprimierung funktioniert. </font><font style="vertical-align: inherit;">Was ist mit dem Dateiformat selbst? </font><font style="vertical-align: inherit;">In diesem Teil werden wir die Struktur und Implementierung im Detail untersuchen. </font><font style="vertical-align: inherit;">Der Code ist in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zip.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zip.c verfügbar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<a name="18"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überblick</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Dateiformat wird in PKZip </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application Note beschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Datei oder jedes Archivelement in einer Zip-Datei verfügt über einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lokalen Dateikopf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit Metadaten zu dem Element.</font></font></li>
<li><i> </i>   .         ,      ,    ,      Zip-.</li>
<li>  ,     <i>   </i>.       ,        .     Zip-.</li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/821/bba/6ce/821bba6cede767c834da639e00d7d6ba.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes Archivelement wird komprimiert und einzeln gespeichert. Dies bedeutet, dass selbst wenn Übereinstimmungen zwischen Dateien im Archiv vorhanden sind, diese nicht berücksichtigt werden, um die Komprimierung zu verbessern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Position des zentralen Katalogs am Ende ermöglicht es Ihnen, das Archiv schrittweise zu vervollständigen. Wenn Dateielemente komprimiert werden, werden sie dem Archiv hinzugefügt. Der Index wird nach allen komprimierten Größen aufgezeichnet, sodass Sie die Offsets aller Dateien ermitteln können. Das Hinzufügen von Dateien zu einem vorhandenen Archiv ist recht einfach, es wird nach dem letzten Element platziert und das zentrale Verzeichnis wird überschrieben.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Möglichkeit, Archive schrittweise zu erstellen, war besonders wichtig für die Verbreitung von Informationen auf zahlreichen Disketten oder Volumes. Beim Komprimieren schlug PKZip vor, dass Benutzer neue Disketten einlegen und das zentrale Verzeichnis in die letzten (letzten) schreiben. Um ein Archiv mit mehreren Volumes zu entpacken, forderte PKZip zuerst die letzte zu schreibende Diskette zum Lesen des zentralen Verzeichnisses an und dann den Rest der Diskette, die zum Extrahieren der angeforderten Dateien erforderlich ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies mag Sie überraschen, aber es gab keine Regel, die verbot, mehrere Dateien mit demselben Namen im Archiv zu haben. Dies kann beim Auspacken zu großer Verwirrung führen: Wenn mehrere Dateien mit demselben Namen vorhanden sind, welche sollten Sie auspacken? Dies könnte wiederum zu Sicherheitsproblemen führen. Aufgrund des "Master Key" -Fehlers in Android (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CVE-2013-4787</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus dem Bericht über Black Hat) Ein Angreifer könnte bei der Installation von Programmen die Überprüfungen des Betriebssystems für </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">kryptografische Signaturen</font></a><font style="vertical-align: inherit;"> umgehen. Android-Programme werden in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APK-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dateien verteilt, bei denen es sich um Zip-Dateien handelt. Wenn das APK mehrere Dateien mit demselben Namen enthielt, wählte der Signaturprüfcode die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">letzte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datei mit demselben Namen aus, und das Installationsprogramm wählte die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erste</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datei aus, dh die Überprüfung wurde nicht durchgeführt. Mit anderen Worten, dieser kleine Unterschied zwischen den beiden Zip-Bibliotheken ermöglichte es, das gesamte Sicherheitsmodell des Betriebssystems zu umgehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Gegensatz zu den meisten Formaten sollten Zip-Dateien nicht mit einer Signatur oder einer </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">magischen Nummer beginnen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es wird im Allgemeinen nicht angegeben, dass die Zip-Datei auf eine bestimmte Weise gestartet werden soll. Auf diese Weise können Sie problemlos Dateien erstellen, die sowohl als Zip-Datei als auch als anderes Format gültig sind - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Polyglot-Dateien</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Beispielsweise sind selbstextrahierende Zip-Archive (z. B. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pkz204g.exe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) normalerweise sowohl ausführbare als auch Zip-Dateien: Der erste Teil ist ausführbar, gefolgt von einer Zip-Datei (die vom ausführbaren Teil entpackt wird). Das Betriebssystem kann es als ausführbare Datei ausführen, das Zip-Programm öffnet es jedoch als Zip-Datei. Diese Funktion kann dazu führen, dass Sie am Anfang der Datei keine Signatur benötigen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obwohl solche polyglotten Dateien intelligent sind, können sie zu Sicherheitsproblemen führen, da sie Programme austricksen können, die versuchen, den Inhalt der Datei zu bestimmen, und auch die Bereitstellung von Schadcode an einem Ort mit Dateien unterschiedlichen Typs ermöglichen. Bei Exploits wurden beispielsweise </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GIFAR-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dateien verwendet, bei denen es sich gleichzeitig um gültige GIF-Bilder und Java-Archive handelt (JAR, eine Art Zip-Datei). Weitere Informationen zu diesem Problem finden Sie im Artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Missbrauch von Dateiformaten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ab Seite 18). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie wir weiter unten sehen werden, verwenden Zip-Dateien 32-Bit-Felder für Offsets und Größen, um die Größe des Archivs und seiner Elemente auf vier Gigabyte zu begrenzen. In </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application Note 4.5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PKWare hat Formaterweiterungen hinzugefügt, die die Verwendung von 64-Bit-Offsets und -Größen ermöglichen. </font><font style="vertical-align: inherit;">Dateien, die diese Erweiterungen verwenden, haben das Zip64-Format, werden jedoch nicht berücksichtigt.</font></font><br>
<br>
<a name="19"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenstrukturen</font></font></h3><br>
<a name="20"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ende des zentralen Verzeichniseintrags</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ende eines zentralen Verzeichniseintrags (EOCDR) wird normalerweise als Ausgangspunkt für das Lesen einer Zip-Datei verwendet. Es enthält den Speicherort und die Größe des zentralen Verzeichnisses sowie optionale Kommentare zum gesamten Archiv. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Zip-Dateien, die mehrere Disketten oder Volumes belegten, enthielt EOCDR auch Informationen darüber, welche Festplatte wir derzeit verwenden, auf welcher Festplatte das zentrale Verzeichnis startet usw. Heutzutage wird diese Funktionalität nur noch selten verwendet, und der Code in diesem Artikel verarbeitet solche Dateien nicht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EOCDR wird durch die Signatur 'P' 'K' bestimmt, gefolgt von den Bytes 5 und 6. Es folgt die folgende Struktur, die Zahlen werden nach dem Little-Endian-Prinzip gespeichert:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* End of Central Directory Record. */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eocdr</span> {</span>
        <span class="hljs-keyword">uint16_t</span> disk_nbr;        <span class="hljs-comment">/* Number of this disk. */</span>
        <span class="hljs-keyword">uint16_t</span> cd_start_disk;   <span class="hljs-comment">/* Nbr. of disk with start of the CD. */</span>
        <span class="hljs-keyword">uint16_t</span> disk_cd_entries; <span class="hljs-comment">/* Nbr. of CD entries on this disk. */</span>
        <span class="hljs-keyword">uint16_t</span> cd_entries;      <span class="hljs-comment">/* Nbr. of Central Directory entries. */</span>
        <span class="hljs-keyword">uint32_t</span> cd_size;         <span class="hljs-comment">/* Central Directory size in bytes. */</span>
        <span class="hljs-keyword">uint32_t</span> cd_offset;       <span class="hljs-comment">/* Central Directory file offset. */</span>
        <span class="hljs-keyword">uint16_t</span> comment_len;     <span class="hljs-comment">/* Archive comment length. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comment;   <span class="hljs-comment">/* Archive comment. */</span><font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EOCDR sollte sich am Ende der Datei befinden. </font><font style="vertical-align: inherit;">Da sich jedoch möglicherweise ein Kommentar mit einer beliebigen Länge von 16 Bit in seinem Schwanz befindet, muss möglicherweise eine bestimmte Position gefunden werden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Read 16/32 bits little-endian and bump p forward afterwards. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> READ16(p) ((p) += 2, read16le((p) - 2))</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> READ32(p) ((p) += 4, read32le((p) - 4))</span><font></font>
<font></font>
<span class="hljs-comment">/* Size of the End of Central Directory Record, not including comment. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EOCDR_BASE_SZ 22</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EOCDR_SIGNATURE 0x06054b50  <span class="hljs-comment">/* "PK\5\6" little-endian. */</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">find_eocdr</span><span class="hljs-params">(struct eocdr *r, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len)</span>
</span>{
        <span class="hljs-keyword">size_t</span> comment_len;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint32_t</span> signature;<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (comment_len = <span class="hljs-number">0</span>; comment_len &lt;= UINT16_MAX; comment_len++) {
                <span class="hljs-keyword">if</span> (src_len &lt; EOCDR_BASE_SZ + comment_len) {
                        <span class="hljs-keyword">break</span>;<font></font>
                }<font></font>
<font></font>
                p = &amp;src[src_len - EOCDR_BASE_SZ - comment_len];<font></font>
                signature = READ32(p);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (signature == EOCDR_SIGNATURE) {<font></font>
                        r-&gt;disk_nbr = READ16(p);<font></font>
                        r-&gt;cd_start_disk = READ16(p);<font></font>
                        r-&gt;disk_cd_entries = READ16(p);<font></font>
                        r-&gt;cd_entries = READ16(p);<font></font>
                        r-&gt;cd_size = READ32(p);<font></font>
                        r-&gt;cd_offset = READ32(p);<font></font>
                        r-&gt;comment_len = READ16(p);<font></font>
                        r-&gt;comment = p;<font></font>
                        assert(p == &amp;src[src_len - comment_len] &amp;&amp;<font></font>
                               <span class="hljs-string">"All fields read."</span>);<font></font>
<font></font>
                        <span class="hljs-keyword">if</span> (r-&gt;comment_len == comment_len) {
                                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
                        }<font></font>
                }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Aufzeichnen von EOCDR ist einfach. </font><font style="vertical-align: inherit;">Diese Funktion schreibt und gibt die Anzahl der geschriebenen Bytes zurück:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Write 16/32 bits little-endian and bump p forward afterwards. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WRITE16(p, x) (write16le((p), (x)), (p) += 2)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WRITE32(p, x) (write32le((p), (x)), (p) += 4)</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">write_eocdr</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">const</span> struct eocdr *r)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p = dst;<font></font>
<font></font>
        WRITE32(p, EOCDR_SIGNATURE);<font></font>
        WRITE16(p, r-&gt;disk_nbr);<font></font>
        WRITE16(p, r-&gt;cd_start_disk);<font></font>
        WRITE16(p, r-&gt;disk_cd_entries);<font></font>
        WRITE16(p, r-&gt;cd_entries);<font></font>
        WRITE32(p, r-&gt;cd_size);<font></font>
        WRITE32(p, r-&gt;cd_offset);<font></font>
        WRITE16(p, r-&gt;comment_len);<font></font>
        assert(p - dst == EOCDR_BASE_SZ);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (r-&gt;comment_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, r-&gt;comment, r-&gt;comment_len);<font></font>
                p += r-&gt;comment_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">size_t</span>)(p - dst);<font></font>
}<font></font>
</code></pre><br>
<a name="21"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zentraler Dateikopf</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zentrale Verzeichnis besteht aus zentralen Dateiköpfen, die nacheinander für jedes Archivelement geschrieben werden. </font><font style="vertical-align: inherit;">Jede Überschrift beginnt mit der Signatur 'P', 'K', 1, 2, und dann gibt es eine solche Struktur:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXT_ATTR_DIR (1U &lt;&lt; 4)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EXT_ATTR_ARC (1U &lt;&lt; 5)</span><font></font>
<font></font>
<span class="hljs-comment">/* Central File Header (Central Directory Entry) */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfh</span> {</span>
        <span class="hljs-keyword">uint16_t</span> made_by_ver;    <span class="hljs-comment">/* Version made by. */</span>
        <span class="hljs-keyword">uint16_t</span> extract_ver;    <span class="hljs-comment">/* Version needed to extract. */</span>
        <span class="hljs-keyword">uint16_t</span> gp_flag;        <span class="hljs-comment">/* General purpose bit flag. */</span>
        <span class="hljs-keyword">uint16_t</span> method;         <span class="hljs-comment">/* Compression method. */</span>
        <span class="hljs-keyword">uint16_t</span> mod_time;       <span class="hljs-comment">/* Modification time. */</span>
        <span class="hljs-keyword">uint16_t</span> mod_date;       <span class="hljs-comment">/* Modification date. */</span>
        <span class="hljs-keyword">uint32_t</span> crc32;          <span class="hljs-comment">/* CRC-32 checksum. */</span>
        <span class="hljs-keyword">uint32_t</span> comp_size;      <span class="hljs-comment">/* Compressed size. */</span>
        <span class="hljs-keyword">uint32_t</span> uncomp_size;    <span class="hljs-comment">/* Uncompressed size. */</span>
        <span class="hljs-keyword">uint16_t</span> name_len;       <span class="hljs-comment">/* Filename length. */</span>
        <span class="hljs-keyword">uint16_t</span> extra_len;      <span class="hljs-comment">/* Extra data length. */</span>
        <span class="hljs-keyword">uint16_t</span> comment_len;    <span class="hljs-comment">/* Comment length. */</span>
        <span class="hljs-keyword">uint16_t</span> disk_nbr_start; <span class="hljs-comment">/* Disk nbr. where file begins. */</span>
        <span class="hljs-keyword">uint16_t</span> int_attrs;      <span class="hljs-comment">/* Internal file attributes. */</span>
        <span class="hljs-keyword">uint32_t</span> ext_attrs;      <span class="hljs-comment">/* External file attributes. */</span>
        <span class="hljs-keyword">uint32_t</span> lfh_offset;     <span class="hljs-comment">/* Local File Header offset. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *name;     <span class="hljs-comment">/* Filename. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *extra;    <span class="hljs-comment">/* Extra data. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comment;  <span class="hljs-comment">/* File comment. */</span><font></font>
};<font></font>
</code></pre><br>
<code>made_by_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>extract_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codieren Sie Informationen über das Betriebssystem und die Version des Programms, mit dem dieses Element hinzugefügt wurde, sowie darüber, welche Version zum Abrufen erforderlich ist. </font><font style="vertical-align: inherit;">Die wichtigsten acht Bits codieren das Betriebssystem (z. B. 0 bedeutet DOS, 3 bedeutet Unix, 10 bedeutet Windows NTFS) und die unteren acht Bits codieren die Softwareversion. </font><font style="vertical-align: inherit;">Setzen Sie den Dezimalwert auf 20, was Kompatibilität mit PKZip 2.0 bedeutet. </font></font><br>
<br>
<code>gp_flag</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält verschiedene Flags. </font><font style="vertical-align: inherit;">Wir sind interessiert:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 0, das die Tatsache der Verschlüsselung des Elements anzeigt (wir werden dies nicht berücksichtigen);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und die Bits 1 und 2, die den Grad der Deflate-Komprimierung codieren (0 - normal, 1 - maximal, 2 - schnell, 3 - sehr schnell).</font></font></li>
</ul><br>
<code>method</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codiert eine Komprimierungsmethode. 0 - Daten nicht komprimiert, 8 - Delate angewendet. Andere Werte beziehen sich auf alte oder neue Algorithmen, aber fast alle Zip verwenden diese beiden Werte. </font></font><br>
<br>
<code>mod_time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>mod_date</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthalten das Datum und die Uhrzeit der Änderung der Datei, codiert im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MS-DOS-Format</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mit diesem Code konvertieren wir die üblichen C-Zeitstempel </font></font><code>time_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in und aus dem MS-DOS-Format:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Convert DOS date and time to time_t. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">time_t</span> <span class="hljs-title">dos2ctime</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> dos_date, <span class="hljs-keyword">uint16_t</span> dos_time)</span>
</span>{
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> <span class="hljs-title">tm</span> = {</span><span class="hljs-number">0</span>};<font></font>
<font></font>
        tm.tm_sec = (dos_time &amp; <span class="hljs-number">0x1f</span>) * <span class="hljs-number">2</span>;  <span class="hljs-comment">/* Bits 0--4:  Secs divided by 2. */</span>
        tm.tm_min = (dos_time &gt;&gt; <span class="hljs-number">5</span>) &amp; <span class="hljs-number">0x3f</span>; <span class="hljs-comment">/* Bits 5--10: Minute. */</span>
        tm.tm_hour = (dos_time &gt;&gt; <span class="hljs-number">11</span>);      <span class="hljs-comment">/* Bits 11-15: Hour (0--23). */</span><font></font>
<font></font>
        tm.tm_mday = (dos_date &amp; <span class="hljs-number">0x1f</span>);          <span class="hljs-comment">/* Bits 0--4: Day (1--31). */</span>
        tm.tm_mon = ((dos_date &gt;&gt; <span class="hljs-number">5</span>) &amp; <span class="hljs-number">0xf</span>) - <span class="hljs-number">1</span>; <span class="hljs-comment">/* Bits 5--8: Month (1--12). */</span>
        tm.tm_year = (dos_date &gt;&gt; <span class="hljs-number">9</span>) + <span class="hljs-number">80</span>;       <span class="hljs-comment">/* Bits 9--15: Year-1980. */</span><font></font>
<font></font>
        tm.tm_isdst = <span class="hljs-number">-1</span>;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> mktime(&amp;tm);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* Convert time_t to DOS date and time. */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ctime2dos</span><span class="hljs-params">(<span class="hljs-keyword">time_t</span> t, <span class="hljs-keyword">uint16_t</span> *dos_date, <span class="hljs-keyword">uint16_t</span> *dos_time)</span>
</span>{
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">tm</span> = <span class="hljs-title">localtime</span>(&amp;<span class="hljs-title">t</span>);</span><font></font>
<font></font>
        *dos_time = <span class="hljs-number">0</span>;<font></font>
        *dos_time |= tm-&gt;tm_sec / <span class="hljs-number">2</span>;    <span class="hljs-comment">/* Bits 0--4:  Second divided by two. */</span>
        *dos_time |= tm-&gt;tm_min &lt;&lt; <span class="hljs-number">5</span>;   <span class="hljs-comment">/* Bits 5--10: Minute. */</span>
        *dos_time |= tm-&gt;tm_hour &lt;&lt; <span class="hljs-number">11</span>; <span class="hljs-comment">/* Bits 11-15: Hour. */</span><font></font>
<font></font>
        *dos_date = <span class="hljs-number">0</span>;<font></font>
        *dos_date |= tm-&gt;tm_mday;             <span class="hljs-comment">/* Bits 0--4:  Day (1--31). */</span>
        *dos_date |= (tm-&gt;tm_mon + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">5</span>;   <span class="hljs-comment">/* Bits 5--8:  Month (1--12). */</span>
        *dos_date |= (tm-&gt;tm_year - <span class="hljs-number">80</span>) &lt;&lt; <span class="hljs-number">9</span>; <span class="hljs-comment">/* Bits 9--15: Year from 1980. */</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Feld </font></font><code>crc32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert des zyklisch redundanten Codes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unkomprimierter Daten. Es wird verwendet, um die Datenintegrität nach dem Abrufen zu überprüfen. Implementierung hier: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crc32.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<code>comp_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>uncomp_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthalten die komprimierte und unkomprimierte Größe der Elementdateidaten. Die folgenden drei Felder enthalten die Länge des Namens, des Kommentars und zusätzlicher Daten unmittelbar nach dem Titel. </font></font><code>disk_nbr_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entwickelt für Archive mit mehreren Disketten. </font></font><br>
<br>
<code>int_attrs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>ext_attrs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beschreiben Sie die internen und externen Attribute der Datei. Interne beziehen sich auf den Inhalt der Datei. Das niedrigstwertige Bit gibt beispielsweise an, ob die Datei nur Text enthält. Externe Attribute geben an, ob die Datei ausgeblendet, schreibgeschützt usw. ist. Der Inhalt dieser Felder hängt insbesondere vom Betriebssystem ab</font></font><code>made_by_ver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Unter DOS enthalten die unteren 8 Bits das Dateiattributbyte, das aus dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Systemaufruf Int 21 / AX = 4300h abgerufen werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann </font><font style="vertical-align: inherit;">. Zum Beispiel bedeutet Bit 4, dass es sich um ein Verzeichnis handelt, und Bit 5 bedeutet, dass das Attribut "Archiv" festgelegt ist (true für die meisten Dateien unter DOS). Soweit ich weiß, werden diese Bits aus Kompatibilitätsgründen in anderen Betriebssystemen ähnlich gesetzt. Unter Unix enthalten die hohen 16 Bits dieses Felds Dateimodusbits, die von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stat (2)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in zurückgegeben werden </font></font><code>st_mode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<code>lfh_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teilt uns mit, wo nach dem lokalen Dateikopf gesucht werden soll. </font></font><code>name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dateiname (C-Zeile) und </font></font><code>comment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- optionaler Kommentar für dieses Archivelement (C-Zeile). </font></font><code>extra</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann optionale zusätzliche Daten enthalten, z. B. Informationen zum Eigentümer der Unix-Datei, genaueres Datum und Uhrzeit der Änderung oder Zip64-Felder.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dieser Funktion werden die zentralen Header von Dateien gelesen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Size of a Central File Header, not including name, extra, and comment. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CFH_BASE_SZ 46</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CFH_SIGNATURE 0x02014b50 <span class="hljs-comment">/* "PK\1\2" little-endian. */</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">read_cfh</span><span class="hljs-params">(struct cfh *cfh, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len,
                     <span class="hljs-keyword">size_t</span> offset)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint32_t</span> signature;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (offset &gt; src_len || src_len - offset &lt; CFH_BASE_SZ) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        p = &amp;src[offset];<font></font>
        signature = READ32(p);<font></font>
        <span class="hljs-keyword">if</span> (signature != CFH_SIGNATURE) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        cfh-&gt;made_by_ver = READ16(p);<font></font>
        cfh-&gt;extract_ver = READ16(p);<font></font>
        cfh-&gt;gp_flag = READ16(p);<font></font>
        cfh-&gt;method = READ16(p);<font></font>
        cfh-&gt;mod_time = READ16(p);<font></font>
        cfh-&gt;mod_date = READ16(p);<font></font>
        cfh-&gt;crc32 = READ32(p);<font></font>
        cfh-&gt;comp_size = READ32(p);<font></font>
        cfh-&gt;uncomp_size = READ32(p);<font></font>
        cfh-&gt;name_len = READ16(p);<font></font>
        cfh-&gt;extra_len = READ16(p);<font></font>
        cfh-&gt;comment_len = READ16(p);<font></font>
        cfh-&gt;disk_nbr_start = READ16(p);<font></font>
        cfh-&gt;int_attrs = READ16(p);<font></font>
        cfh-&gt;ext_attrs = READ32(p);<font></font>
        cfh-&gt;lfh_offset = READ32(p);<font></font>
        cfh-&gt;name = p;<font></font>
        cfh-&gt;extra = cfh-&gt;name + cfh-&gt;name_len;<font></font>
        cfh-&gt;comment = cfh-&gt;extra + cfh-&gt;extra_len;<font></font>
        assert(p == &amp;src[offset + CFH_BASE_SZ] &amp;&amp; <span class="hljs-string">"All fields read."</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (src_len - offset - CFH_BASE_SZ &lt;<font></font>
            cfh-&gt;name_len + cfh-&gt;extra_len + cfh-&gt;comment_len) {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">write_cfh</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">const</span> struct cfh *cfh)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p = dst;<font></font>
<font></font>
        WRITE32(p, CFH_SIGNATURE);<font></font>
        WRITE16(p, cfh-&gt;made_by_ver);<font></font>
        WRITE16(p, cfh-&gt;extract_ver);<font></font>
        WRITE16(p, cfh-&gt;gp_flag);<font></font>
        WRITE16(p, cfh-&gt;method);<font></font>
        WRITE16(p, cfh-&gt;mod_time);<font></font>
        WRITE16(p, cfh-&gt;mod_date);<font></font>
        WRITE32(p, cfh-&gt;crc32);<font></font>
        WRITE32(p, cfh-&gt;comp_size);<font></font>
        WRITE32(p, cfh-&gt;uncomp_size);<font></font>
        WRITE16(p, cfh-&gt;name_len);<font></font>
        WRITE16(p, cfh-&gt;extra_len);<font></font>
        WRITE16(p, cfh-&gt;comment_len);<font></font>
        WRITE16(p, cfh-&gt;disk_nbr_start);<font></font>
        WRITE16(p, cfh-&gt;int_attrs);<font></font>
        WRITE32(p, cfh-&gt;ext_attrs);<font></font>
        WRITE32(p, cfh-&gt;lfh_offset);<font></font>
        assert(p - dst == CFH_BASE_SZ);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (cfh-&gt;name_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, cfh-&gt;name, cfh-&gt;name_len);<font></font>
                p += cfh-&gt;name_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (cfh-&gt;extra_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, cfh-&gt;extra, cfh-&gt;extra_len);<font></font>
                p += cfh-&gt;extra_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (cfh-&gt;comment_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, cfh-&gt;comment, cfh-&gt;comment_len);<font></font>
                p += cfh-&gt;comment_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">size_t</span>)(p - dst);<font></font>
}<font></font>
</code></pre><br>
<a name="22"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lokaler Dateikopf</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Den Daten jedes Archivelements geht ein lokaler Dateikopf voraus, der die meisten Informationen aus dem zentralen Kopf wiederholt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Duplizierung von Daten in den zentralen und lokalen Headern wurde wahrscheinlich eingeführt, damit PKZip beim Entpacken nicht das gesamte zentrale Verzeichnis im Speicher behält. Stattdessen können beim Extrahieren jeder Datei der Name und andere Informationen aus dem lokalen Header gelesen werden. Darüber hinaus sind lokale Header nützlich, um Dateien aus Zip-Archiven wiederherzustellen, in denen das zentrale Verzeichnis fehlt oder beschädigt ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Redundanz ist jedoch auch die Hauptquelle für Unsicherheit. Was passiert beispielsweise, wenn die Dateinamen in den zentralen und lokalen Headern nicht übereinstimmen? Dies führt häufig zu Fehlern und Sicherheitsproblemen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nicht alle Informationen aus der zentralen Überschrift werden dupliziert. </font><font style="vertical-align: inherit;">Zum Beispiel Felder mit Dateiattributen. </font><font style="vertical-align: inherit;">Wenn das drittniedrigste Bit </font></font><code>gp_flags</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(CRC-32) </font><font style="vertical-align: inherit;">angegeben wird </font><font style="vertical-align: inherit;">, werden die komprimierten und nicht komprimierten Felder auf Null zurückgesetzt, und diese Informationen befinden sich im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datenbeschreibungsblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nach den Daten der Datei selbst (wir werden sie nicht berücksichtigen). </font><font style="vertical-align: inherit;">Auf diese Weise können Sie einen lokalen Header aufzeichnen, bevor die Dateigröße des Elements bekannt ist oder auf welche Größe es komprimiert wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der lokale Header beginnt mit der Signatur 'P', 'K', 3, 4, und dann gibt es eine solche Struktur:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Local File Header. */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lfh</span> {</span>
        <span class="hljs-keyword">uint16_t</span> extract_ver;
        <span class="hljs-keyword">uint16_t</span> gp_flag;
        <span class="hljs-keyword">uint16_t</span> method;
        <span class="hljs-keyword">uint16_t</span> mod_time;
        <span class="hljs-keyword">uint16_t</span> mod_date;
        <span class="hljs-keyword">uint32_t</span> crc32;
        <span class="hljs-keyword">uint32_t</span> comp_size;
        <span class="hljs-keyword">uint32_t</span> uncomp_size;
        <span class="hljs-keyword">uint16_t</span> name_len;
        <span class="hljs-keyword">uint16_t</span> extra_len;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *name;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *extra;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktionen lesen und schreiben lokale Header wie andere Datenstrukturen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Size of a Local File Header, not including name and extra. */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LFH_BASE_SZ 30</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LFH_SIGNATURE 0x04034b50 <span class="hljs-comment">/* "PK\3\4" little-endian. */</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">read_lfh</span><span class="hljs-params">(struct lfh *lfh, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len,
                     <span class="hljs-keyword">size_t</span> offset)</span>
</span>{
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">uint32_t</span> signature;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (offset &gt; src_len || src_len - offset &lt; LFH_BASE_SZ) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        p = &amp;src[offset];<font></font>
        signature = READ32(p);<font></font>
        <span class="hljs-keyword">if</span> (signature != LFH_SIGNATURE) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        lfh-&gt;extract_ver = READ16(p);<font></font>
        lfh-&gt;gp_flag = READ16(p);<font></font>
        lfh-&gt;method = READ16(p);<font></font>
        lfh-&gt;mod_time = READ16(p);<font></font>
        lfh-&gt;mod_date = READ16(p);<font></font>
        lfh-&gt;crc32 = READ32(p);<font></font>
        lfh-&gt;comp_size = READ32(p);<font></font>
        lfh-&gt;uncomp_size = READ32(p);<font></font>
        lfh-&gt;name_len = READ16(p);<font></font>
        lfh-&gt;extra_len = READ16(p);<font></font>
        lfh-&gt;name = p;<font></font>
        lfh-&gt;extra = lfh-&gt;name + lfh-&gt;name_len;<font></font>
        assert(p == &amp;src[offset + LFH_BASE_SZ] &amp;&amp; <span class="hljs-string">"All fields read."</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (src_len - offset - LFH_BASE_SZ &lt; lfh-&gt;name_len + lfh-&gt;extra_len) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">write_lfh</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">const</span> struct lfh *lfh)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p = dst;<font></font>
<font></font>
        WRITE32(p, LFH_SIGNATURE);<font></font>
        WRITE16(p, lfh-&gt;extract_ver);<font></font>
        WRITE16(p, lfh-&gt;gp_flag);<font></font>
        WRITE16(p, lfh-&gt;method);<font></font>
        WRITE16(p, lfh-&gt;mod_time);<font></font>
        WRITE16(p, lfh-&gt;mod_date);<font></font>
        WRITE32(p, lfh-&gt;crc32);<font></font>
        WRITE32(p, lfh-&gt;comp_size);<font></font>
        WRITE32(p, lfh-&gt;uncomp_size);<font></font>
        WRITE16(p, lfh-&gt;name_len);<font></font>
        WRITE16(p, lfh-&gt;extra_len);<font></font>
        assert(p - dst == LFH_BASE_SZ);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (lfh-&gt;name_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, lfh-&gt;name, lfh-&gt;name_len);<font></font>
                p += lfh-&gt;name_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (lfh-&gt;extra_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">memcpy</span>(p, lfh-&gt;extra, lfh-&gt;extra_len);<font></font>
                p += lfh-&gt;extra_len;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">size_t</span>)(p - dst);<font></font>
}<font></font>
</code></pre><br>
<a name="23"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung von Zip Read</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit den oben genannten Funktionen implementieren wir das Lesen der Zip-Datei in den Speicher und erhalten einen Iterator für den Zugriff auf die Archivelemente:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">size_t</span> <span class="hljs-keyword">zipiter_t</span>; <span class="hljs-comment">/* Zip archive member iterator. */</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zip_t</span> <span class="hljs-title">zip_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zip_t</span> {</span>
        <span class="hljs-keyword">uint16_t</span> num_members;    <span class="hljs-comment">/* Number of members. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comment;  <span class="hljs-comment">/* Zip file comment (not terminated). */</span>
        <span class="hljs-keyword">uint16_t</span> comment_len;    <span class="hljs-comment">/* Zip file comment length. */</span>
        <span class="hljs-keyword">zipiter_t</span> members_begin; <span class="hljs-comment">/* Iterator to the first member. */</span>
        <span class="hljs-keyword">zipiter_t</span> members_end;   <span class="hljs-comment">/* Iterator to the end of members. */</span><font></font>
<font></font>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src;
        <span class="hljs-keyword">size_t</span> src_len;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Initialize zip based on the source data. Returns true on success, or false
   if the data could not be parsed as a valid Zip file. */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">zip_read</span><span class="hljs-params">(<span class="hljs-keyword">zip_t</span> *zip, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">size_t</span> src_len)</span>
</span>{
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eocdr</span> <span class="hljs-title">eocdr</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfh</span> <span class="hljs-title">cfh</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lfh</span> <span class="hljs-title">lfh</span>;</span>
        <span class="hljs-keyword">size_t</span> i, offset;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comp_data;<font></font>
<font></font>
        zip-&gt;src = src;<font></font>
        zip-&gt;src_len = src_len;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!find_eocdr(&amp;eocdr, src, src_len)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (eocdr.disk_nbr != <span class="hljs-number">0</span> || eocdr.cd_start_disk != <span class="hljs-number">0</span> ||<font></font>
            eocdr.disk_cd_entries != eocdr.cd_entries) {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Cannot handle multi-volume archives. */</span><font></font>
        }<font></font>
<font></font>
        zip-&gt;num_members = eocdr.cd_entries;<font></font>
        zip-&gt;comment = eocdr.comment;<font></font>
        zip-&gt;comment_len = eocdr.comment_len;<font></font>
<font></font>
        offset = eocdr.cd_offset;<font></font>
        zip-&gt;members_begin = offset;<font></font>
<font></font>
        <span class="hljs-comment">/* Read the member info and do a few checks. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; eocdr.cd_entries; i++) {
                <span class="hljs-keyword">if</span> (!read_cfh(&amp;cfh, src, src_len, offset)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (cfh.gp_flag &amp; <span class="hljs-number">1</span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* The member is encrypted. */</span><font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (cfh.method != ZIP_STORED &amp;&amp; cfh.method != ZIP_DEFLATED) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Unsupported compression method. */</span><font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (cfh.method == ZIP_STORED &amp;&amp;<font></font>
                    cfh.uncomp_size != cfh.comp_size) {<font></font>
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (cfh.disk_nbr_start != <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Cannot handle multi-volume archives. */</span><font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memchr</span>(cfh.name, <span class="hljs-string">'\0'</span>, cfh.name_len) != <span class="hljs-literal">NULL</span>) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Bad filename. */</span><font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (!read_lfh(&amp;lfh, src, src_len, cfh.lfh_offset)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
                }<font></font>
<font></font>
                comp_data = lfh.extra + lfh.extra_len;<font></font>
                <span class="hljs-keyword">if</span> (cfh.comp_size &gt; src_len - (<span class="hljs-keyword">size_t</span>)(comp_data - src)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* Member data does not fit in src. */</span><font></font>
                }<font></font>
<font></font>
                offset += CFH_BASE_SZ + cfh.name_len + cfh.extra_len +<font></font>
                          cfh.comment_len;<font></font>
        }<font></font>
<font></font>
        zip-&gt;members_end = offset;<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie oben erwähnt, sind Elementiteratoren einfach Offsets zum zentralen Dateikopf, über den Sie auf Elementdaten zugreifen können:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> { ZIP_STORED = <span class="hljs-number">0</span>, ZIP_DEFLATED = <span class="hljs-number">8</span> } <span class="hljs-keyword">method_t</span>;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zipmemb_t</span> <span class="hljs-title">zipmemb_t</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zipmemb_t</span> {</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *name;      <span class="hljs-comment">/* Member name (not null terminated). */</span>
        <span class="hljs-keyword">uint16_t</span> name_len;        <span class="hljs-comment">/* Member name length. */</span>
        <span class="hljs-keyword">time_t</span> mtime;             <span class="hljs-comment">/* Modification time. */</span>
        <span class="hljs-keyword">uint32_t</span> comp_size;       <span class="hljs-comment">/* Compressed size. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comp_data; <span class="hljs-comment">/* Compressed data. */</span>
        <span class="hljs-keyword">method_t</span> method;          <span class="hljs-comment">/* Compression method. */</span>
        <span class="hljs-keyword">uint32_t</span> uncomp_size;     <span class="hljs-comment">/* Uncompressed size. */</span>
        <span class="hljs-keyword">uint32_t</span> crc32;           <span class="hljs-comment">/* CRC-32 checksum. */</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *comment;   <span class="hljs-comment">/* Comment (not null terminated). */</span>
        <span class="hljs-keyword">uint16_t</span> comment_len;     <span class="hljs-comment">/* Comment length. */</span>
        <span class="hljs-keyword">bool</span> is_dir;              <span class="hljs-comment">/* Whether this is a directory. */</span>
        <span class="hljs-keyword">zipiter_t</span> next;           <span class="hljs-comment">/* Iterator to the next member. */</span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/* Get the Zip archive member through iterator it. */</span>
<span class="hljs-function"><span class="hljs-keyword">zipmemb_t</span> <span class="hljs-title">zip_member</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">zip_t</span> *zip, <span class="hljs-keyword">zipiter_t</span> it)</span>
</span>{
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfh</span> <span class="hljs-title">cfh</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lfh</span> <span class="hljs-title">lfh</span>;</span>
        <span class="hljs-keyword">bool</span> ok;
        <span class="hljs-keyword">zipmemb_t</span> m;<font></font>
<font></font>
        assert(it &gt;= zip-&gt;members_begin &amp;&amp; it &lt; zip-&gt;members_end);<font></font>
<font></font>
        ok = read_cfh(&amp;cfh, zip-&gt;src, zip-&gt;src_len, it);<font></font>
        assert(ok);<font></font>
<font></font>
        ok = read_lfh(&amp;lfh, zip-&gt;src, zip-&gt;src_len, cfh.lfh_offset);<font></font>
        assert(ok);<font></font>
<font></font>
        m.name = cfh.name;<font></font>
        m.name_len = cfh.name_len;<font></font>
        m.mtime = dos2ctime(cfh.mod_date, cfh.mod_time);<font></font>
        m.comp_size = cfh.comp_size;<font></font>
        m.comp_data = lfh.extra + lfh.extra_len;<font></font>
        m.method = cfh.method;<font></font>
        m.uncomp_size = cfh.uncomp_size;<font></font>
        m.crc32 = cfh.crc32;<font></font>
        m.comment = cfh.comment;<font></font>
        m.comment_len = cfh.comment_len;<font></font>
        m.is_dir = (cfh.ext_attrs &amp; EXT_ATTR_DIR) != <span class="hljs-number">0</span>;<font></font>
<font></font>
        m.next = it + CFH_BASE_SZ +<font></font>
                 cfh.name_len + cfh.extra_len + cfh.comment_len;<font></font>
<font></font>
        assert(m.next &lt;= zip-&gt;members_end);<font></font>
<font></font>
        <span class="hljs-keyword">return</span> m;<font></font>
}<font></font>
</code></pre><br>
<a name="24"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung von Zip-Datensätzen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um eine Zip-Datei in den Speicherpuffer zu schreiben, müssen Sie zunächst herausfinden, wie viel Speicher dafür zugewiesen werden muss. </font><font style="vertical-align: inherit;">Und da wir nicht wissen, wie viele Daten wir komprimieren werden, bevor wir versuchen zu schreiben, berechnen wir die obere Grenze basierend auf den Größen der nicht komprimierten Elemente:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Compute an upper bound on the dst size required by zip_write() for an
 * archive with num_memb members with certain filenames, sizes, and archive
 * comment. Returns zero on error, e.g. if a filename is longer than 2^16-1, or
 * if the total file size is larger than 2^32-1. */</span>
<span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">zip_max_size</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> num_memb, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *filenames,
                      <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *file_sizes, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *comment)</span>
</span>{
        <span class="hljs-keyword">size_t</span> comment_len, name_len;
        <span class="hljs-keyword">uint64_t</span> total;
        <span class="hljs-keyword">uint16_t</span> i;<font></font>
<font></font>
        comment_len = (comment == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : <span class="hljs-built_in">strlen</span>(comment));
        <span class="hljs-keyword">if</span> (comment_len &gt; UINT16_MAX) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        total = EOCDR_BASE_SZ + comment_len; <span class="hljs-comment">/* EOCDR */</span><font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_memb; i++) {<font></font>
                assert(filenames[i] != <span class="hljs-literal">NULL</span>);<font></font>
                name_len = <span class="hljs-built_in">strlen</span>(filenames[i]);
                <span class="hljs-keyword">if</span> (name_len &gt; UINT16_MAX) {
                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
                }<font></font>
<font></font>
                total += CFH_BASE_SZ + name_len; <span class="hljs-comment">/* Central File Header */</span>
                total += LFH_BASE_SZ + name_len; <span class="hljs-comment">/* Local File Header */</span>
                total += file_sizes[i];          <span class="hljs-comment">/* Uncompressed data size. */</span><font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (total &gt; UINT32_MAX) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">uint32_t</span>)total;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code schreibt die Zip-Datei unter Verwendung der Deflate-Komprimierung jedes Elements und reduziert deren Größe:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Write a Zip file containing num_memb members into dst, which must be large
   enough to hold the resulting data. Returns the number of bytes written, which
   is guaranteed to be less than or equal to the result of zip_max_size() when
   called with the corresponding arguments. comment shall be a null-terminated
   string or null. callback shall be null or point to a function which will
   get called after the compression of each member. */</span>
<span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">zip_write</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span> *dst, <span class="hljs-keyword">uint16_t</span> num_memb,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *filenames,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-keyword">const</span> *file_data,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> *file_sizes,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">time_t</span> *mtimes,
                   <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *comment,
                   <span class="hljs-keyword">void</span> (*callback)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">uint32_t</span> size,
                                    <span class="hljs-keyword">uint32_t</span> comp_size))</span>
</span>{
        <span class="hljs-keyword">uint16_t</span> i;
        <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eocdr</span> <span class="hljs-title">eocdr</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfh</span> <span class="hljs-title">cfh</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lfh</span> <span class="hljs-title">lfh</span>;</span>
        <span class="hljs-keyword">bool</span> ok;
        <span class="hljs-keyword">uint16_t</span> name_len;
        <span class="hljs-keyword">uint8_t</span> *data_dst;
        <span class="hljs-keyword">size_t</span> comp_sz;
        <span class="hljs-keyword">uint32_t</span> lfh_offset, cd_offset, eocdr_offset;<font></font>
<font></font>
        p = dst;<font></font>
<font></font>
        <span class="hljs-comment">/* Write Local File Headers and deflated or stored data. */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_memb; i++) {<font></font>
                assert(filenames[i] != <span class="hljs-literal">NULL</span>);<font></font>
                assert(<span class="hljs-built_in">strlen</span>(filenames[i]) &lt;= UINT16_MAX);<font></font>
                name_len = (<span class="hljs-keyword">uint16_t</span>)<span class="hljs-built_in">strlen</span>(filenames[i]);<font></font>
<font></font>
                data_dst = p + LFH_BASE_SZ + name_len;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (hwdeflate(file_data[i], file_sizes[i], data_dst,<font></font>
                              file_sizes[i], &amp;comp_sz) &amp;&amp;<font></font>
                                comp_sz &lt; file_sizes[i]) {<font></font>
                        lfh.method = ZIP_DEFLATED;<font></font>
                        assert(comp_sz &lt;= UINT32_MAX);<font></font>
                        lfh.comp_size = (<span class="hljs-keyword">uint32_t</span>)comp_sz;<font></font>
                } <span class="hljs-keyword">else</span> {
                        <span class="hljs-built_in">memcpy</span>(data_dst, file_data[i], file_sizes[i]);<font></font>
                        lfh.method = ZIP_STORED;<font></font>
                        lfh.comp_size = file_sizes[i];<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (callback != <span class="hljs-literal">NULL</span>) {<font></font>
                        callback(filenames[i], file_sizes[i], lfh.comp_size);<font></font>
                }<font></font>
<font></font>
                lfh.extract_ver = (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">8</span>) | <span class="hljs-number">20</span>; <span class="hljs-comment">/* DOS | PKZIP 2.0 */</span>
                lfh.gp_flag = (lfh.method == ZIP_DEFLATED ? (<span class="hljs-number">0x1</span> &lt;&lt; <span class="hljs-number">1</span>) : <span class="hljs-number">0x0</span>);<font></font>
                ctime2dos(mtimes[i], &amp;lfh.mod_date, &amp;lfh.mod_time);<font></font>
                lfh.crc32 = crc32(file_data[i], file_sizes[i]);<font></font>
                lfh.uncomp_size = file_sizes[i];<font></font>
                lfh.name_len = name_len;<font></font>
                lfh.extra_len = <span class="hljs-number">0</span>;<font></font>
                lfh.name = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>*)filenames[i];<font></font>
                p += write_lfh(p, &amp;lfh);<font></font>
                p += lfh.comp_size;<font></font>
        }<font></font>
<font></font>
        assert(p - dst &lt;= UINT32_MAX);<font></font>
        cd_offset = (<span class="hljs-keyword">uint32_t</span>)(p - dst);<font></font>
<font></font>
        <span class="hljs-comment">/* Write the Central Directory based on the Local File Headers. */</span>
        lfh_offset = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num_memb; i++) {<font></font>
                ok = read_lfh(&amp;lfh, dst, SIZE_MAX, lfh_offset);<font></font>
                assert(ok);<font></font>
<font></font>
                cfh.made_by_ver = lfh.extract_ver;<font></font>
                cfh.extract_ver = lfh.extract_ver;<font></font>
                cfh.gp_flag = lfh.gp_flag;<font></font>
                cfh.method = lfh.method;<font></font>
                cfh.mod_time = lfh.mod_time;<font></font>
                cfh.mod_date = lfh.mod_date;<font></font>
                cfh.crc32 = lfh.crc32;<font></font>
                cfh.comp_size = lfh.comp_size;<font></font>
                cfh.uncomp_size = lfh.uncomp_size;<font></font>
                cfh.name_len = lfh.name_len;<font></font>
                cfh.extra_len = <span class="hljs-number">0</span>;<font></font>
                cfh.comment_len = <span class="hljs-number">0</span>;<font></font>
                cfh.disk_nbr_start = <span class="hljs-number">0</span>;<font></font>
                cfh.int_attrs = <span class="hljs-number">0</span>;<font></font>
                cfh.ext_attrs = EXT_ATTR_ARC;<font></font>
                cfh.lfh_offset = lfh_offset;<font></font>
                cfh.name = lfh.name;<font></font>
                p += write_cfh(p, &amp;cfh);<font></font>
<font></font>
                lfh_offset += LFH_BASE_SZ + lfh.name_len + lfh.comp_size;<font></font>
        }<font></font>
<font></font>
        assert(p - dst &lt;= UINT32_MAX);<font></font>
        eocdr_offset = (<span class="hljs-keyword">uint32_t</span>)(p - dst);<font></font>
<font></font>
        <span class="hljs-comment">/* Write the End of Central Directory Record. */</span>
        eocdr.disk_nbr = <span class="hljs-number">0</span>;<font></font>
        eocdr.cd_start_disk = <span class="hljs-number">0</span>;<font></font>
        eocdr.disk_cd_entries = num_memb;<font></font>
        eocdr.cd_entries = num_memb;<font></font>
        eocdr.cd_size = eocdr_offset - cd_offset;<font></font>
        eocdr.cd_offset = cd_offset;<font></font>
        eocdr.comment_len = (<span class="hljs-keyword">uint16_t</span>)(comment == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : <span class="hljs-built_in">strlen</span>(comment));<font></font>
        eocdr.comment = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>*)comment;<font></font>
        p += write_eocdr(p, &amp;eocdr);<font></font>
<font></font>
        assert(p - dst &lt;= zip_max_size(num_memb, filenames, file_sizes,<font></font>
                                       comment));<font></font>
<font></font>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">uint32_t</span>)(p - dst);<font></font>
}<font></font>
</code></pre><br>
<a name="25"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hwzip</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt wissen wir, wie man Zip-Dateien liest und schreibt, wie man die darin gespeicherten Daten komprimiert und dekomprimiert. </font><font style="vertical-align: inherit;">Schreiben wir nun ein einfaches Zip-Programm, das alle diese Tools enthält. </font><font style="vertical-align: inherit;">Der Code ist unter </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hwzip.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verfügbar </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden ein Makro für die einfache Fehlerbehandlung und mehrere Hilfsfunktionen für die überprüfte Speicherzuordnung verwenden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PERROR_IF(cond, msg) <span class="hljs-meta-keyword">if</span> (cond) { perror(msg); exit(1); }</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">xmalloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span>
</span>{
        <span class="hljs-keyword">void</span> *ptr = <span class="hljs-built_in">malloc</span>(size);<font></font>
        PERROR_IF(ptr == <span class="hljs-literal">NULL</span>, <span class="hljs-string">"malloc"</span>);
        <span class="hljs-keyword">return</span> ptr;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">xrealloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">size_t</span> size)</span>
</span>{<font></font>
        ptr = <span class="hljs-built_in">realloc</span>(ptr, size);<font></font>
        PERROR_IF(ptr == <span class="hljs-literal">NULL</span>, <span class="hljs-string">"realloc"</span>);
        <span class="hljs-keyword">return</span> ptr;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die beiden anderen Funktionen werden zum Lesen und Schreiben von Dateien verwendet:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-title">read_file</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">size_t</span> *file_sz)</span>
</span>{<font></font>
        FILE *f;<font></font>
        <span class="hljs-keyword">uint8_t</span> *buf;
        <span class="hljs-keyword">size_t</span> buf_cap;<font></font>
<font></font>
        f = fopen(filename, <span class="hljs-string">"rb"</span>);<font></font>
        PERROR_IF(f == <span class="hljs-literal">NULL</span>, <span class="hljs-string">"fopen"</span>);<font></font>
<font></font>
        buf_cap = <span class="hljs-number">4096</span>;<font></font>
        buf = xmalloc(buf_cap);<font></font>
<font></font>
        *file_sz = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (feof(f) == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (buf_cap - *file_sz == <span class="hljs-number">0</span>) {<font></font>
                        buf_cap *= <span class="hljs-number">2</span>;<font></font>
                        buf = xrealloc(buf, buf_cap);<font></font>
                }<font></font>
<font></font>
                *file_sz += fread(&amp;buf[*file_sz], <span class="hljs-number">1</span>, buf_cap - *file_sz, f);<font></font>
                PERROR_IF(ferror(f), <span class="hljs-string">"fread"</span>);<font></font>
        }<font></font>
<font></font>
        PERROR_IF(fclose(f) != <span class="hljs-number">0</span>, <span class="hljs-string">"fclose"</span>);
        <span class="hljs-keyword">return</span> buf;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write_file</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *data, <span class="hljs-keyword">size_t</span> n)</span>
</span>{<font></font>
        FILE *f;<font></font>
<font></font>
        f = fopen(filename, <span class="hljs-string">"wb"</span>);<font></font>
        PERROR_IF(f == <span class="hljs-literal">NULL</span>, <span class="hljs-string">"fopen"</span>);<font></font>
        PERROR_IF(fwrite(data, <span class="hljs-number">1</span>, n, f) != n, <span class="hljs-string">"fwrite"</span>);<font></font>
        PERROR_IF(fclose(f) != <span class="hljs-number">0</span>, <span class="hljs-string">"fclose"</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Zip-Programm kann drei Funktionen ausführen: Erstellen Sie eine Liste der Inhalte von Zip-Dateien und extrahieren Sie diese sowie erstellen Sie Zip-Dateien. </font><font style="vertical-align: inherit;">Auflistung ist nirgends einfacher:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">list_zip</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *zip_data;
        <span class="hljs-keyword">size_t</span> zip_sz;
        <span class="hljs-keyword">zip_t</span> z;
        <span class="hljs-keyword">zipiter_t</span> it;
        <span class="hljs-keyword">zipmemb_t</span> m;<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Listing ZIP archive: %s\n\n"</span>, filename);<font></font>
<font></font>
        zip_data = read_file(filename, &amp;zip_sz);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!zip_read(&amp;z, zip_data, zip_sz)) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Failed to parse ZIP file!\n"</span>);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (z.comment_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.*s\n\n"</span>, (<span class="hljs-keyword">int</span>)z.comment_len, z.comment);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (it = z.members_begin; it != z.members_end; it = m.next) {<font></font>
                m = zip_member(&amp;z, it);<font></font>
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.*s\n"</span>, (<span class="hljs-keyword">int</span>)m.name_len, m.name);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
<font></font>
        <span class="hljs-built_in">free</span>(zip_data);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Extraktion ist etwas komplizierter. </font><font style="vertical-align: inherit;">Wir werden Hilfsfunktionen für die Nullterminierung des Dateinamens (um ihn weiterzugeben </font></font><code>fopen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) und das Entpacken verwenden:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> *<span class="hljs-title">terminate_str</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">size_t</span> n)</span>
</span>{
        <span class="hljs-keyword">char</span> *p = xmalloc(n + <span class="hljs-number">1</span>);
        <span class="hljs-built_in">memcpy</span>(p, str, n);<font></font>
        p[n] = <span class="hljs-string">'\0'</span>;
        <span class="hljs-keyword">return</span> p;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-title">inflate_member</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">zipmemb_t</span> *m)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *p;
        <span class="hljs-keyword">size_t</span> src_used, dst_used;<font></font>
<font></font>
        assert(m-&gt;method == ZIP_DEFLATED);<font></font>
<font></font>
        p = xmalloc(m-&gt;uncomp_size);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (hwinflate(m-&gt;comp_data, m-&gt;comp_size, &amp;src_used, p, m-&gt;uncomp_size,<font></font>
                      &amp;dst_used) != HWINF_OK) {<font></font>
                <span class="hljs-built_in">free</span>(p);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (src_used != m-&gt;comp_size || dst_used != m-&gt;uncomp_size) {
                <span class="hljs-built_in">free</span>(p);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> p;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Programm überspringt alle Archivelemente mit Verzeichnissen. </font><font style="vertical-align: inherit;">Dies geschieht, um die sogenannten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Path-Traversal-Angriffe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu vermeiden </font><font style="vertical-align: inherit;">: Ein böswilliges Archiv wird verwendet, um die Datei von außerhalb des vom Benutzer angegebenen Verzeichnisses zu schreiben. </font><font style="vertical-align: inherit;">Lesen Sie die Details in den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Info-ZIP-FAQ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">extract_zip</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename)</span>
</span>{
        <span class="hljs-keyword">uint8_t</span> *zip_data;
        <span class="hljs-keyword">size_t</span> zip_sz;
        <span class="hljs-keyword">zip_t</span> z;
        <span class="hljs-keyword">zipiter_t</span> it;
        <span class="hljs-keyword">zipmemb_t</span> m;
        <span class="hljs-keyword">char</span> *tname;
        <span class="hljs-keyword">uint8_t</span> *inflated;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *uncomp_data;<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Extracting ZIP archive: %s\n\n"</span>, filename);<font></font>
<font></font>
        zip_data = read_file(filename, &amp;zip_sz);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!zip_read(&amp;z, zip_data, zip_sz)) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Failed to read ZIP file!\n"</span>);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (z.comment_len != <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.*s\n\n"</span>, (<span class="hljs-keyword">int</span>)z.comment_len, z.comment);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (it = z.members_begin; it != z.members_end; it = m.next) {<font></font>
                m = zip_member(&amp;z, it);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (m.is_dir) {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" (Skipping dir: %.*s)\n"</span>,<font></font>
                               (<span class="hljs-keyword">int</span>)m.name_len, m.name);
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">memchr</span>(m.name, <span class="hljs-string">'/'</span>,  m.name_len) != <span class="hljs-literal">NULL</span> ||
                    <span class="hljs-built_in">memchr</span>(m.name, <span class="hljs-string">'\\'</span>, m.name_len) != <span class="hljs-literal">NULL</span>) {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" (Skipping file in dir: %.*s)\n"</span>,<font></font>
                               (<span class="hljs-keyword">int</span>)m.name_len, m.name);
                        <span class="hljs-keyword">continue</span>;<font></font>
                }<font></font>
<font></font>
                assert(m.method == ZIP_STORED || m.method == ZIP_DEFLATED);<font></font>
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %s: %.*s"</span>,<font></font>
                       m.method == ZIP_STORED ? <span class="hljs-string">"Extracting"</span> : <span class="hljs-string">" Inflating"</span>,<font></font>
                       (<span class="hljs-keyword">int</span>)m.name_len, m.name);<font></font>
                fflush(<span class="hljs-built_in">stdout</span>);<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (m.method == ZIP_STORED) {<font></font>
                        assert(m.uncomp_size == m.comp_size);<font></font>
                        inflated = <span class="hljs-literal">NULL</span>;<font></font>
                        uncomp_data = m.comp_data;<font></font>
                } <span class="hljs-keyword">else</span> {<font></font>
                        inflated = inflate_member(&amp;m);<font></font>
                        <span class="hljs-keyword">if</span> (inflated == <span class="hljs-literal">NULL</span>) {
                                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error: inflation failed!\n"</span>);
                                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
                        }<font></font>
                        uncomp_data = inflated;<font></font>
                }<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (crc32(uncomp_data, m.uncomp_size) != m.crc32) {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error: CRC-32 mismatch!\n"</span>);
                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
                }<font></font>
<font></font>
                tname = terminate_str((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)m.name, m.name_len);<font></font>
                write_file(tname, uncomp_data, m.uncomp_size);<font></font>
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
<font></font>
                <span class="hljs-built_in">free</span>(inflated);
                <span class="hljs-built_in">free</span>(tname);<font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        <span class="hljs-built_in">free</span>(zip_data);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ein Zip-Archiv zu erstellen, lesen wir die Eingabedateien und füttern sie </font></font><code>zip_write</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da Sie in der Standard-C-Bibliothek die Änderungszeit für Dateien nicht abrufen können, verwenden wir die aktuelle Zeit (ich lasse dies als Hausaufgabe, um diese Funktion zu beheben).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">zip_callback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">uint32_t</span> size, <span class="hljs-keyword">uint32_t</span> comp_size)</span>
</span>{
        <span class="hljs-keyword">bool</span> deflated = comp_size &lt; size;<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">" %s: %s"</span>, deflated ? <span class="hljs-string">"Deflated"</span> : <span class="hljs-string">"  Stored"</span>, filename);
        <span class="hljs-keyword">if</span> (deflated) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">" (%u%%)"</span>, <span class="hljs-number">100</span> - <span class="hljs-number">100</span> * comp_size / size);<font></font>
        }<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create_zip</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *zip_filename, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *comment,
                       <span class="hljs-keyword">uint16_t</span> n, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *filenames)</span>
</span>{
        <span class="hljs-keyword">time_t</span> mtime;
        <span class="hljs-keyword">time_t</span> *mtimes;
        <span class="hljs-keyword">uint8_t</span> **file_data;
        <span class="hljs-keyword">uint32_t</span> *file_sizes;
        <span class="hljs-keyword">size_t</span> file_size, zip_size;
        <span class="hljs-keyword">uint8_t</span> *zip_data;
        <span class="hljs-keyword">uint16_t</span> i;<font></font>
<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Creating ZIP archive: %s\n\n"</span>, zip_filename);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (comment != <span class="hljs-literal">NULL</span>) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n\n"</span>, comment);<font></font>
        }<font></font>
<font></font>
        mtime = time(<span class="hljs-literal">NULL</span>);<font></font>
<font></font>
        file_data = xmalloc(<span class="hljs-keyword">sizeof</span>(*file_data) * n);<font></font>
        file_sizes = xmalloc(<span class="hljs-keyword">sizeof</span>(*file_sizes) * n);<font></font>
        mtimes = xmalloc(<span class="hljs-keyword">sizeof</span>(*mtimes) * n);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {<font></font>
                file_data[i] = read_file(filenames[i], &amp;file_size);<font></font>
                <span class="hljs-keyword">if</span> (file_size &gt;= UINT32_MAX) {
                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s is too large!\n"</span>, filenames[i]);
                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
                }<font></font>
                file_sizes[i] = (<span class="hljs-keyword">uint32_t</span>)file_size;<font></font>
                mtimes[i] = mtime;<font></font>
        }<font></font>
<font></font>
        zip_size = zip_max_size(n, filenames, file_sizes, comment);<font></font>
        <span class="hljs-keyword">if</span> (zip_size == <span class="hljs-number">0</span>) {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"zip writing not possible"</span>);
                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        zip_data = xmalloc(zip_size);<font></font>
        zip_size = zip_write(zip_data, n, filenames,<font></font>
                             (<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span> *<span class="hljs-keyword">const</span> *)file_data,<font></font>
                             file_sizes, mtimes, comment, zip_callback);<font></font>
<font></font>
        write_file(zip_filename, zip_data, zip_size);<font></font>
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
<font></font>
        <span class="hljs-built_in">free</span>(zip_data);
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {
                <span class="hljs-built_in">free</span>(file_data[i]);<font></font>
        }<font></font>
        <span class="hljs-built_in">free</span>(mtimes);
        <span class="hljs-built_in">free</span>(file_sizes);
        <span class="hljs-built_in">free</span>(file_data);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich werden </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Befehlszeilenargumente überprüft und entschieden, was zu tun ist:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print_usage</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *argv0)</span>
</span>{
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Usage:\n\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"  %s list &lt;zipfile&gt;\n"</span>, argv0);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"  %s extract &lt;zipfile&gt;\n"</span>, argv0);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"  %s create &lt;zipfile&gt; [-c &lt;comment&gt;] &lt;files...&gt;\n"</span>, argv0);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>{
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"HWZIP "</span> VERSION <span class="hljs-string">" -- A very simple ZIP program "</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"from https://www.hanshq.net/zip.html\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"list"</span>) == <span class="hljs-number">0</span>) {<font></font>
                list_zip(argv[<span class="hljs-number">2</span>]);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"extract"</span>) == <span class="hljs-number">0</span>) {<font></font>
                extract_zip(argv[<span class="hljs-number">2</span>]);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argc &gt;= <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"create"</span>) == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (argc &gt;= <span class="hljs-number">5</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">3</span>], <span class="hljs-string">"-c"</span>) == <span class="hljs-number">0</span>) {<font></font>
                        create_zip(argv[<span class="hljs-number">2</span>], argv[<span class="hljs-number">4</span>], (<span class="hljs-keyword">uint16_t</span>)(argc - <span class="hljs-number">5</span>),<font></font>
                                   (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *)&amp;argv[<span class="hljs-number">5</span>]);<font></font>
                } <span class="hljs-keyword">else</span> {<font></font>
                        create_zip(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, (<span class="hljs-keyword">uint16_t</span>)(argc - <span class="hljs-number">3</span>),<font></font>
                                   (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> *)&amp;argv[<span class="hljs-number">3</span>]);<font></font>
                }<font></font>
        } <span class="hljs-keyword">else</span> {<font></font>
                print_usage(argv[<span class="hljs-number">0</span>]);
                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br>
<a name="26"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Montageanleitungen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein vollständiger Satz von Quelldateien ist unter </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hwzip-1.0.zip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verfügbar </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">So kompilieren Sie HWZip unter Linux oder Mac:</font></font><br>
<br>
<pre><code class="cpp hljs">$ clang generate_tables.c &amp;&amp; ./a.out &gt; tables.c<font></font>
$ clang -O3 -DNDEBUG -march=native -o hwzip crc32.c deflate.c huffman.c \<font></font>
        hwzip.c lz77.c tables.c zip.c<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter Windows an der Eingabeaufforderung des Entwicklers in Visual Studio (wenn Sie nicht über Visual Studio verfügen, laden Sie die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Build-Tools</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> herunter </font><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="cpp hljs">cl /TC generate_tables.c &amp;&amp; generate_tables &gt; tables.c<font></font>
cl /O2 /DNDEBUG /MT /Fehwzip.exe /TC crc32.c deflate.c huffman.c hwzip.c<font></font>
        lz77.c tables.c zip.c /link setargv.obj<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setargv.obj zum </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweitern von Wildcard-Befehlszeilenargumenten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .)</font></font><br>
<br>
<a name="27"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist erstaunlich, wie sich die Technologie schnell und langsam entwickelt. </font><font style="vertical-align: inherit;">Das Zip-Format wurde vor 30 Jahren basierend auf Technologie aus den fünfziger und siebziger Jahren erstellt. </font><font style="vertical-align: inherit;">Und obwohl sich seitdem viel geändert hat, sind die Zip-Dateien tatsächlich gleich geblieben und sind heute häufiger als je zuvor. </font><font style="vertical-align: inherit;">Ich denke, es wird nützlich sein, ein gutes Verständnis dafür zu haben, wie sie funktionieren.</font></font><br>
<br>
<a name="28"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übungen</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie HWZip die Zeit aufzeichnen, zu der die Datei geändert wurde, und nicht die aktuelle Zeit, zu der das Archiv erstellt wurde. </font><font style="vertical-align: inherit;">Verwenden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stat (2)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unter Linux oder Mac und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetFileTime</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unter Windows. </font><font style="vertical-align: inherit;">Oder fügen Sie ein Befehlszeilenflag hinzu, mit dem der Benutzer eine bestimmte Zeit für Dateiänderungen festlegen kann.</font></font></li>
<li>              gzip-.   —    ,    Deflate (   ).    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC 1952</a>.</li>
<li>    Zip-     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a>.  HWZip ,   <code>read_file</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mmap(2)</a>  Linux  Mac  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CreateFileMapping</a>  Windows.</li>
<li> HWZip ,          Zip64.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> appnote.txt</a>.</li>
</ul><br>
<a name="29"></a><h2> </h2><br>
<ul>
<li>  BBS-   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BBS: The Documentary</a>.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> YouTube</a>.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Part 8: Compression</a>    SEA  PKWare.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a>.</li>
<li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">A better Zip bomb</a>    Zip-,    «»    .</li>
<li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zip Files All The Way Down</a> ,   <i>Zip-</i> — ,    .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ascii-zip</a> —  ,  Deflate-   ASCII-.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rosetta Flash</a>.</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ten Thousand Security Pitfalls: the Zip File Format</a> —        .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reading bits in far too many ways part 1</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">part 2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">part 3</a> —       .</li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Understanding Compression</a>      .</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de490780/index.html">Intel Xeon Scalable Gen2: Großer Verkauf von Kernen</a></li>
<li><a href="../de490782/index.html">AnalogBytes-Konferenz: Roskomnadzor, Medien, Hochlast und alles in allem</a></li>
<li><a href="../de490784/index.html">Ich bin ein Android-Entwickler und wollte keine manuelle Arbeit leisten.</a></li>
<li><a href="../de490786/index.html">Leckanalyse zweiter Ordnung: Wenn es von denen leckt, die Daten von einer Bank stehlen</a></li>
<li><a href="../de490788/index.html">Nutzlose REPL. Yandex-Bericht</a></li>
<li><a href="../de490792/index.html">VXLAN in NSX-V - Unruhige Unterlage</a></li>
<li><a href="../de490796/index.html">So automatisieren Sie die Sicherheit von Containern im Stil von Policy as Code mithilfe von CRD</a></li>
<li><a href="../de490804/index.html">Wie die Mutter eines Hackers ins Gefängnis kam und den Computer des Chefs infizierte</a></li>
<li><a href="../de490808/index.html">Mathematik in der Astronautik: Rotationsdetonationsmotor</a></li>
<li><a href="../de490812/index.html">Spring Professional Certification 5 Einreichungserfahrung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>