<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎰 🌴 🉑 SQLガイド：クエリをより適切に記述する方法（パート2） 🖕🏼 👶 ✨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="続きの記事SQLガイド：クエリをよりよく書く方法（パート1）
 
 依頼から実行計画まで
 アンチパターンは静的ではなく、SQL開発者として成長するにつれて進化することを知っており、代替案について考えるときに留意すべきことがたくさんあるという事実は、アンチパターンの回避とクエリの書き換えも非常に難し...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SQLガイド：クエリをより適切に記述する方法（パート2）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465975/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">続きの記事</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLガイド：クエリをよりよく書く方法（パート1）</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依頼から実行計画まで</font></font></h2><br>
<img width="40%" align="left" src="https://habrastorage.org/webt/0i/6s/ac/0i6sacyjz9j7pwvkqhfnr6ryjby.jpeg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アンチパターンは静的ではなく、SQL開発者として成長するにつれて進化することを知っており、代替案について考えるときに留意すべきことがたくさんあるという事実は、アンチパターンの回避とクエリの書き換えも非常に難しいことを意味します。チャレンジ。どんな助けも役に立ちます。そのため、いくつかのツールを使用してクエリを最適化するためのより構造化されたアプローチが最も効果的であるかもしれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、最後のセクションで説明したアンチパターンのいくつかは、そのような事業者として、パフォーマンスの問題、に根ざしていることに留意すべきである</font></font><code>AND</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>OR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>NOT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスを使用しているとき彼らの不在。パフォーマンスについて考えるには、より構造化されたアプローチだけでなく、より深いアプローチも必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、この構造化された詳細なアプローチは主にクエリプランに基づいています。これは、覚えているように、最初に「解析ツリー」または「解析ツリー」に解析されたクエリの結果であり、どのアルゴリズムを正確に決定するかです。各操作に使用され、その実行が調整されます。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クエリの最適化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
概要で読んだように、オプティマイザによって手動でコンパイルされたプランを確認および設定する必要がある場合があります。</font><font style="vertical-align: inherit;">このような場合は、リクエストプランを確認して、リクエストを再度分析する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプランにアクセスするには、データベース管理システムが提供するツールを使用する必要があります。</font><font style="vertical-align: inherit;">次のツールを自由に使用できます。</font></font><br>
<br>
<ul>
<li>   ,      .   :<br>
<br>
<img src="https://habrastorage.org/webt/1y/ff/wa/1yffwafdtmxfgdeanejdy5wjelo.gif"><br>
</li>
<li>       .      <code>EXPLAIN PLAN</code>  Oracle,      ,    .      <code>EXPLAIN</code> (MySQL, PostgreSQL)  <code>EXPLAIN QUERY PLAN</code> (SQLite).</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PostgreSQLので作業するとき、あなたはを区別することができますこと</font></font><code>EXPLAIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ながら、あなただけのプランナーがそれを実行せずにクエリを実行するつもり方法について説明します説明を取得する場所を</font></font><code>EXPLAIN ANALYZE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際にクエリを実行し、あなたの期待と実際の分析を返しますリクエストプラン。一般的に言えば、実際の実行プランは、リクエストが実際に実行されるプランであり、評価実行プランは、リクエストを実行せずに何を行うかを決定します。これは論理的には同等ですが、実際の実行計画には、要求が実行されたときに実際に何が起こったかに関する追加情報と統計が含まれているため、はるかに便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションの残りの部分では、についての詳細</font></font><code>EXPLAIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>ANALYZE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、およびそれらを使用してクエリプランとその可能なパフォーマンスに関する詳細情報を取得する方法。</font><font style="vertical-align: inherit;">これを行うには、次の2つのテーブルで動作しますれているいくつかの例を開始します</font></font><code>one_million</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>half_million</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは、テーブルから現在の情報を得ることができ</font></font><code>one_million</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て</font></font><code>EXPLAIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">必ずリクエストの真上に配置してください。実行すると、クエリプランが返されます。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">EXPLAIN</span>
<span class="hljs-keyword">SELECT</span> *
<span class="hljs-keyword">FROM</span> one_million;<font></font>
<font></font>
QUERY PLAN<font></font>
____________________________________________________<font></font>
Seq Scan on one_million<font></font>
(cost=0.00..18584.82 rows=1025082 width=36)<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、リクエストのコストが等しく</font></font><code>0.00..18584.82</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、行数</font><font style="vertical-align: inherit;">が等しいことがわかります</font></font><code>1025082</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">列数の幅は同じ</font></font><code>36</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、を使用して統計を更新できます</font></font><code>ANALYZE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">ANALYZE</span> one_million;
<span class="hljs-keyword">EXPLAIN</span>
<span class="hljs-keyword">SELECT</span> *
<span class="hljs-keyword">FROM</span> one_million;<font></font>
<font></font>
QUERY PLAN<font></font>
____________________________________________________<font></font>
Seq Scan on one_million<font></font>
(cost=0.00..18334.00 rows=1000000 width=37)<font></font>
(1 row)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とに加え</font></font><code>EXPLAIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て</font></font><code>ANALYZE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、実際のランタイムを取得することもできます</font></font><code>EXPLAIN ANALYZE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">ANALYZE</span>
<span class="hljs-keyword">SELECT</span> *
<span class="hljs-keyword">FROM</span> one_million;<font></font>
<font></font>
QUERY PLAN<font></font>
___________________________________________________________<font></font>
Seq Scan on one_million<font></font>
(cost=0.00..18334.00 rows=1000000 width=37)<font></font>
(actual time=0.015..1207.019 rows=1000000 loops=1)<font></font>
Total runtime: 2320.146 ms<font></font>
(2 rows)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを使用するデメリットは</font></font><code>EXPLAIN ANALYZE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、リクエストが実際に実行されることなので、これには注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでに見たアルゴリズムはすべて</font></font><code>Seq Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（順次スキャン）または全表スキャンです。これはデータベースで実行されるスキャンであり、スキャンされた表の各行がシリアル順に読み取られ、見つかった列が条件に準拠しているかどうかがチェックされますか否か。パフォーマンスの点では、シーケンシャルスキャンはまだ完全なテーブルスキャンを実行しているため、最良の実行計画ではありません。ただし、テーブルがメモリに収まらない場合、これはそれほど悪くはありません。シーケンシャル読み取りは、遅いディスクでもかなり高速です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インデックススキャンについては、後で詳しく説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、他のアルゴリズムもあります。</font><font style="vertical-align: inherit;">たとえば、次の接続のクエリプランを考えてみます。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">ANALYZE</span>
<span class="hljs-keyword">SELECT</span> *
<span class="hljs-keyword">FROM</span> one_million <span class="hljs-keyword">JOIN</span> half_million
<span class="hljs-keyword">ON</span> (one_million.counter=half_million.counter);<font></font>
QUERY PLAN<font></font>
_________________________________________________________________<font></font>
Hash Join (cost=15417.00..68831.00 rows=500000 width=42)<font></font>
(actual time=1241.471..5912.553 rows=500000 loops=1)<font></font>
Hash Cond: (one_million.counter = half_million.counter)<font></font>
    -&gt; Seq Scan on one_million<font></font>
    (cost=0.00..18334.00 rows=1000000 width=37)<font></font>
    (actual time=0.007..1254.027 rows=1000000 loops=1)<font></font>
    -&gt; Hash (cost=7213.00..7213.00 rows=500000 width=5)<font></font>
    (actual time=1241.251..1241.251 rows=500000 loops=1)<font></font>
    Buckets: 4096 Batches: 16 Memory Usage: 770kB<font></font>
    -&gt; Seq Scan on half_million<font></font>
    (cost=0.00..7213.00 rows=500000 width=5)<font></font>
(actual time=0.008..601.128 rows=500000 loops=1)<font></font>
Total runtime: 6468.337 ms</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クエリオプティマイザがここで選択したものが表示されます</font></font><code>Hash Join</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この操作は、リクエストの時間の複雑さを評価するために必要になるため、覚えておいてください。</font><font style="vertical-align: inherit;">今のところ、</font></font><code>half_million.counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次の例で追加するインデックス</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">ない</font><font style="vertical-align: inherit;">ことに注意してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> half_million(counter);
<span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">ANALYZE</span>
<span class="hljs-keyword">SELECT</span> *
<span class="hljs-keyword">FROM</span> one_million <span class="hljs-keyword">JOIN</span> half_million
<span class="hljs-keyword">ON</span> (one_million.counter=half_million.counter);<font></font>
QUERY PLAN<font></font>
________________________________________________________________<font></font>
<span class="hljs-keyword">Merge</span> <span class="hljs-keyword">Join</span> (<span class="hljs-keyword">cost</span>=<span class="hljs-number">4.12</span>.<span class="hljs-number">.37650</span><span class="hljs-number">.65</span> <span class="hljs-keyword">rows</span>=<span class="hljs-number">500000</span> width=<span class="hljs-number">42</span>)<font></font>
(actual <span class="hljs-built_in">time</span>=<span class="hljs-number">0.033</span>.<span class="hljs-number">.3272</span><span class="hljs-number">.940</span> <span class="hljs-keyword">rows</span>=<span class="hljs-number">500000</span> loops=<span class="hljs-number">1</span>)
<span class="hljs-keyword">Merge</span> Cond: (one_million.counter = half_million.counter)<font></font>
    -&gt; <span class="hljs-keyword">Index</span> <span class="hljs-keyword">Scan</span> <span class="hljs-keyword">using</span> one_million_counter_idx <span class="hljs-keyword">on</span> one_million<font></font>
    (<span class="hljs-keyword">cost</span>=<span class="hljs-number">0.00</span>.<span class="hljs-number">.32129</span><span class="hljs-number">.34</span> <span class="hljs-keyword">rows</span>=<span class="hljs-number">1000000</span> width=<span class="hljs-number">37</span>)<font></font>
    (actual <span class="hljs-built_in">time</span>=<span class="hljs-number">0.011</span>.<span class="hljs-number">.694</span><span class="hljs-number">.466</span> <span class="hljs-keyword">rows</span>=<span class="hljs-number">500001</span> loops=<span class="hljs-number">1</span>)<font></font>
    -&gt; <span class="hljs-keyword">Index</span> <span class="hljs-keyword">Scan</span> <span class="hljs-keyword">using</span> half_million_counter_idx <span class="hljs-keyword">on</span> half_million<font></font>
    (<span class="hljs-keyword">cost</span>=<span class="hljs-number">0.00</span>.<span class="hljs-number">.14120</span><span class="hljs-number">.29</span> <span class="hljs-keyword">rows</span>=<span class="hljs-number">500000</span> width=<span class="hljs-number">5</span>)<font></font>
(actual <span class="hljs-built_in">time</span>=<span class="hljs-number">0.010</span>.<span class="hljs-number">.683</span><span class="hljs-number">.674</span> <span class="hljs-keyword">rows</span>=<span class="hljs-number">500000</span> loops=<span class="hljs-number">1</span>)<font></font>
Total runtime: <span class="hljs-number">3833.310</span> ms<font></font>
(<span class="hljs-number">5</span> <span class="hljs-keyword">rows</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インデックスを作成することにより、クエリオプティマイザーが</font></font><code>Merge join</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスのスキャン時に</font><font style="vertical-align: inherit;">マージマージを使用することを決定したことがわかります</font></font><code>Index Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">インデックススキャンと全テーブルスキャンまたは順次スキャンの違いに</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意してください</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。最初のスキャンは「テーブルスキャン」とも呼ばれ、データまたはインデックスページをスキャンして対応するレコードを見つけ、2番目はテーブルの各行をスキャンします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全体的な実行時間は減少し、パフォーマンスは向上するはずですが、2つのインデックススキャンがあるため、特にテーブルが収まらない場合は、ここでメモリがより重要になります。このような場合、最初にフルインデックススキャンを実行する必要があります。これは高速シーケンシャルリードを使用して実行され、問題ではありませんが、インデックス値で行を選択するランダムリード操作が多数あります。これらはランダムな読み取り操作であり、通常は順次の操作よりも数桁遅くなります。これらの場合、テーブル全体のスキャンは、インデックス全体のスキャンよりも実際に高速に行われます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒント：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EXPLAINの詳細を知りたい場合や、例をさらに詳しく知りたい場合は、Guillaume Lelargeの本を読んでみてください。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「説明を理解する</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">」</font></a></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間の複雑さとBig O</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クエリプランを簡単に確認したので、より深く掘り下げて、計算の複雑さの理論を使用して、より正式な用語でパフォーマンスを考えることができます。</font><font style="vertical-align: inherit;">これは理論的なコンピュータサイエンスの分野であり、とりわけ、複雑さに応じて計算問題の分類に焦点を当てています。</font><font style="vertical-align: inherit;">これらの計算上の問題はアルゴリズムかもしれませんが、クエリでもあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、クエリの場合、必ずしも複雑さに応じて分類されるのではなく、クエリを完了して結果を取得するために必要な時間に応じて分類されます。</font><font style="vertical-align: inherit;">これは時間複雑度と呼ばれ、大きなO表記を使用して、このタイプの複雑度を定式化または測定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビッグOと指定すると、入力が任意に大きくなるにつれて、実行時間を入力と比較してどれだけ速く成長するかでランタイムを表現します。大きなO表記では、係数と低次のメンバーが除外されるため、クエリの実行時間の重要な部分である成長率に集中できます。このように表現すると、低次の係数と項を破棄して、時間の複雑さは漸近的に記述されると彼らは言う。これは、入力サイズが無限大になることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベース言語では、複雑さによって、データテーブルのサイズが大きくなるにつれてクエリが完了するまでにかかる時間が決まり、データベースが大きくなります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースのサイズは、テーブル内のデータ量の増加から増加するだけでなく、インデックスがあるという事実もサイズに影響を与えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クエリプランの時間の複雑さの評価</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先に見たように、実行プランは特に、各操作に使用されるアルゴリズムを決定します。これにより、各クエリの実行時間を、クエリプランに含まれるテーブルのサイズの関数として論理的に表現できます。これは、複雑度関数と呼ばれます。つまり、大きなO表記と実行プランを使用して、クエリの複雑さとパフォーマンスを評価できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のセクションでは、4種類の時間の複雑さの概要を説明し、リクエストの実行時間の複雑さがリクエストが実行されるコンテキストに応じてどのように変化するかを示す例をいくつか示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒント：インデックスはこのストーリーの一部です！</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ただし、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまな種類のインデックス、さまざまな実行プラン、およびさまざまなデータベースのさまざまな実装があるため、以下に示す一時的な問題は非常に一般的であり、特定の設定によって異なる場合があることに注意してください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（1）：一定時間</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らは、アルゴリズムが入力データのサイズに関係なく同じ時間を必要とする場合、一定の時間で動作すると言います。</font><font style="vertical-align: inherit;">クエリに関しては、テーブルのサイズに関係なく同じ時間が必要な場合、一定の時間で実行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタイプのクエリはあまり一般的ではありませんが、ここにそのような例の1つを示します。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">1</span> t.* 
<span class="hljs-keyword">FROM</span> t</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テーブルから任意の行が1つ選択されるため、時間の複雑さは一定です。</font><font style="vertical-align: inherit;">したがって、時間の長さはテーブルのサイズに依存するべきではありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形時間：O（n）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らは、アルゴリズムの実行時間が入力データのサイズに正比例する場合、つまり、時間は入力データのサイズに比例して増加する場合、アルゴリズムは線形時間で機能すると言います。データベースの場合、これは、実行時間がテーブルのサイズに正比例することを意味します。テーブルの行数が増えると、クエリの実行時間が増加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例は、</font></font><code>WHERE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックス</font><font style="vertical-align: inherit;">付けさ</font><font style="vertical-align: inherit;">れていない列の</font><font style="vertical-align: inherit;">条件</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">持つクエリ</font><font style="vertical-align: inherit;">です。全テーブルスキャンが必要になるか</font></font><code>Seq Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">または</font><font style="vertical-align: inherit;">O（n）時間の複雑さにつながります。つまり、目的の識別子（ID）を持つ行を見つけるために、各行を読み取る必要があります。制限はまったくないため、最初の行が条件に一致した場合でも、各行を数える必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のクエリの例も考慮してください。フィールドに</font></font><code>i_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスがない</font><font style="vertical-align: inherit;">場合、O（n）の複雑さになります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> i_id 
<span class="hljs-keyword">FROM</span> item;</code></pre><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">また、前の例は、行数を計算するクエリなどの他のクエリ</font></font><code>COUNT (*) FROM TABLE;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（n）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間の複雑さを</font><font style="vertical-align: inherit;">持つことを意味します。これは、テーブルの行の総数が保存されていないため、フルテーブルスキャンが必要になるためです。</font><font style="vertical-align: inherit;">それ以外の場合、時間の複雑さは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O（1）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と同様になります</font><font style="vertical-align: inherit;">。</font></font><br>
 </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
線形ランタイムは、テーブル結合があるプランのランタイムと密接に関連しています。</font><font style="vertical-align: inherit;">ここではいくつかの例を示します。</font></font><br>
<br>
<ul>
<li>  (hash join)    O(M+N).  -        -  .  -       .   -    -   .   - ,   ,           -.</li>
<li>  (merge joins)    O(M+N),          ,    ,  ,       ,   :<ul>
<li>       ,   ,       O(M+N).</li>
<li>        ,           .   O(M+N).</li>
<li>          ,      ,       O(M log M + N log N).</li>
<li>         ,    ,    ,   ,     ,       O(M + N log N).</li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネストされた結合の場合、複雑度は通常O（MN）です。</font><font style="vertical-align: inherit;">この結合は、1つまたは両方のテーブルが非常に小さい場合（たとえば、10レコード未満）に効果的です。これは、一部のサブクエリが1行のみを返すように記述されているため、クエリを評価するときに非常に一般的な状況です。</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネストされたが、それは別の各レコードに1テーブル内の各レコードを比較して参加している参加。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">対数時間：O（log（n））</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムの実行時間が入力サイズの対数に比例している場合、アルゴリズムは対数時間で機能すると言われています。クエリの場合、これは、実行時間がデータベースサイズの対数に比例している場合に実行されることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この対数時間の複雑さは、インデックススキャンが実行されるクエリプランに有効です。</font></font><code>Index Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">またはクラスター化インデックスのスキャン。</font><font style="vertical-align: inherit;">クラスタ化インデックスは、インデックスの最終レベルにテーブルの実際の行が含まれるインデックスです。</font><font style="vertical-align: inherit;">クラスター化インデックスは、他のインデックスと同様です。1つ以上の列で定義されます。</font><font style="vertical-align: inherit;">それらはインデックスキーを形成します。</font><font style="vertical-align: inherit;">クラスタリングキーは、クラスター化インデックスのキー列です。</font><font style="vertical-align: inherit;">クラスタ化インデックスのスキャンは、基本的には、DBMSでクラスタ化インデックスの行を上から下に読み取る操作です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インデックスが</font></font><code>i_id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あり、通常はO（log（n））の複雑さにつながる</font><font style="vertical-align: inherit;">、次のクエリの例を考えます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> i_stock 
<span class="hljs-keyword">FROM</span> item 
<span class="hljs-keyword">WHERE</span> i_id = N; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インデックスがない場合、時間の複雑さはO（n）になることに注意してください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二次時間：O（n ^ 2）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アルゴリズムの実行時間が入力サイズの2乗に比例する場合、アルゴリズムは2次時間で実行されると考えられています。</font><font style="vertical-align: inherit;">繰り返しになりますが、データベースの場合、これはクエリの実行時間がデータベースサイズの2乗に比例することを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2次時間の複雑さのクエリの考えられる例は次のとおりです。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * 
<span class="hljs-keyword">FROM</span> item, author 
<span class="hljs-keyword">WHERE</span> item.i_a_id=author.a_id </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最小の複雑度はO（n log（n））ですが、最大の複雑度は、接続属性のインデックス情報に基づいてO（n ^ 2）になる場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要約すると</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次のチートシート</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">見</font><font style="vertical-align: inherit;">て、時間の複雑さと有効性に基づいてクエリのパフォーマンスを評価</font><font style="vertical-align: inherit;">することもでき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/dk/cq/fh/dkcqfhsmh_fxl7gorardyts9ptu.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLチューニング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クエリ実行プランと時間の複雑さを考慮して、SQLクエリをさらにカスタマイズできます。</font><font style="vertical-align: inherit;">まず、次の点に注目することができます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不要な全表スキャンを索引スキャンに置き換えます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適な結合順序が適用されていることを確認してください。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックスが最適に使用されていることを確認してください。</font><font style="vertical-align: inherit;">そして</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小さなテーブルの全文スキャンのキャッシュ（小さなテーブルの全テーブルスキャンのキャッシュ）。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLのさらなる使用</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おめでとう！</font><font style="vertical-align: inherit;">この記事の最後に到達しました。SQLクエリのパフォーマンスについて簡単に説明しました。</font><font style="vertical-align: inherit;">アンチパターン、クエリオプティマイザー、およびクエリプランの複雑さを分析、評価、解釈するために使用できるツールについて、もっと情報が得られれば幸いです。</font><font style="vertical-align: inherit;">しかし、あなたはまだ発見することがたくさんあります！</font><font style="vertical-align: inherit;">詳細については、R。RamakrishnanとJ. Gehrkeによる「データベース管理システム」を参照してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、この引用でStackOverflowを否定したくありません。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私のお気に入りのアンチパターンはあなたのリクエストをチェックしません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、次の場合に適用されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クエリは複数のテーブルを提供します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたはリクエストに最適なデザインを持っていると思いますが、仮定をテストしようとしないでください。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初の作業要求を受け入れますが、それが最適にどれだけ近いかはわかりません。</font></font></li>
</ul></blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja465957/index.html">セキュリティウィーク36：スマートフォンの脆弱性の寿命</a></li>
<li><a href="../ja465961/index.html">自分でインターネットマーケティングを学ぶ：50以上の無料コース</a></li>
<li><a href="../ja465963/index.html">ドイツの給与伝記2019</a></li>
<li><a href="../ja465969/index.html">初心者向けではないSystemVerilogのチップ設計に関する書籍を通じて、政治的正しさがロシアに浸透</a></li>
<li><a href="../ja465973/index.html">2018年404festで最も人気のある10の動画レポート</a></li>
<li><a href="../ja465977/index.html">Cisco 200-125 CCNA v3.0のトレーニング。31日目。CDP、Syslog、NTP</a></li>
<li><a href="../ja465979/index.html">すべてを覚えておいてください^ Wは必要なものだけです。Ankiの使用経験。パート1（紹介、最後から2番目）</a></li>
<li><a href="../ja465981/index.html">1Cで使用した場合のIBM DB2 Express-C管理エクスペリエンス：エンタープライズ</a></li>
<li><a href="../ja465983/index.html">Intel Comet Lake：第10世代でわずか14 nm</a></li>
<li><a href="../ja465985/index.html">確率的データ構造を使用するだけでなく、大きなグラフの分散処理を加速します。</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>