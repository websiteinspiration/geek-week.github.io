<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßúüèº üö£üèª üôè Using the OpenCV library to recognize elliptical arcs in 2D sections of 3D point clouds üññüèæ üë®üèø‚Äçüéì ü§ú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In connection with the wider spread of affordable laser scanners (lidars) capable of receiving 3D point clouds ( 3dOT ) and the wider application of t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Using the OpenCV library to recognize elliptical arcs in 2D sections of 3D point clouds</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490400/"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In connection with the wider spread of affordable laser scanners (lidars) capable of receiving 3D point clouds ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) and the wider application of this technology in various fields (from mechanical engineering to security, from the oil industry to architecture), interest in processing algorithms has revived clouds of points. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the popular applications of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3d</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in industry is the creation of design documentation for only constructed, old or converted equipment, which usually consists of pipelines and other structures of cylindrical geometry. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To detect geometric primitives in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , specialized 3D libraries, for example, </font><em><font style="vertical-align: inherit;">Microsoft PCL</font></em><font style="vertical-align: inherit;"> , are usually used</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The approach with the use of ready-made libraries, along with advantages, has disadvantages. For example, it is difficult to incorporate them into existing Kadov processing schemes, which usually have a 2D dimension. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's consider how it would be possible to process </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , for example, a pumping station, starting with 2D sections and using the whole arsenal of 2D processing, which is available in reliable and optimized image processing libraries, for example </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c2/bu/-i/c2bu-isuyb45ji2pz_6nibzg8zi.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 1. 3D OT model of a pumping station</font></font></i><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main element of the sections obtained by scanning various pipe structures are </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elliptical arcs</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8w/zl/2h/8wzl2hcgbhlmexqxdvl6ezottgm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 2. Horizontal cross section of a 3D model of a pumping station at an average level.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
For this article, we restrict our consideration to one key algorithm that allows us to detect arbitrary elliptical arcs - this is an iterative algorithm for the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">growth of arc segments and region binding</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">region growth and edge linking</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Growth algorithms are the most obvious and easily verifiable, albeit time-consuming, in comparison with statistical algorithms, which are better suited to the case when the scene contains loosely coupled, distant objects that belong to one ellipse. </font><font style="vertical-align: inherit;">These algorithms will be discussed in future articles.</font></font><br>
<br>
</p><h4>  </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For now, for simplicity, we omit the procedure for obtaining a section from the source </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file </font><font style="vertical-align: inherit;">, preprocessing a section, clustering it to isolate geometric primitives, as well as subsequent binding, rectification, and other photogrammetric operations needed to obtain model parameters. We will not discuss the parameterization of heuristic search algorithms in the same way. Let us describe all the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic operations</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from which the algorithm is built. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We assume that we need to detect (recognize, classify) an elliptical arc (that is, calculate the parameters of the ellipse, as well as the initial and final angle of the elliptical arc) in this image, cut out from the horizontal section of the point cloud. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/co/rj/km/corjkmmhyxcxvrnex89_iex1aei.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 3. One of the elliptical arcs of the cross section of the 3D model (after smoothing)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to minimize the work with the raster blindly, we will carry out all operations with the raster through </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">outlining</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The OpenCV </font></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findContours</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> procedure </font><font style="vertical-align: inherit;">finds on the raster </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mat</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> all external (without internal shapes) </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contours</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the form of a vector of integer point vectors (in raster coordinates):</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function">Mat <span class="hljs-title">mat</span><span class="hljs-params">(size)</span></span>;
 <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;Point&gt;&gt; contours;<font></font>
 findContours(mat, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is our key operation, which in some simple cases </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">completely solves the task</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">But since degenerate cases are not always found, let us consider in more detail the processing technology through contouring. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The reverse operation, generating a raster according to the existing external circuit using the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function, also looks simple:</font></font><br>
<pre><code class="cpp hljs"> drawContours(mat, contours, <span class="hljs-number">-1</span>, Scalar(<span class="hljs-number">255</span>), <span class="hljs-number">-1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is also very often used to mask contours, draw, or to calculate area. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, at the initial stage, we have a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">set of patches</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (pieces of a certain curve) that need to be connected into an elliptical arc, eliminating parts of other components of the structure (for example, fasteners) or optical noise caused by shadowing during scanning and other reasons. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's create a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">discriminant function</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that will return the type of contour (ellipse, linear segment, hatching or something else), as well as the end points of the contour and its rotated outline rectangle:</font></font><br>
<pre><code class="cpp hljs"> contourTypeSearch(
   <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;contour, Vec4i &amp;def, RotatedRect &amp;rc);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The ratio of the length and width of the rectangle helps to quickly discriminate contours close to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linear segments</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as well as small </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noise contours</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The rotated rectangle in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has a </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">complex</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordinate system. If it is not the angle itself that is required, but its </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trigonometric functions</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , it is all the more less obvious from the context. If the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">absolute value of the angle is used</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , it must be </font><font style="vertical-align: inherit;">taken </font><font style="vertical-align: inherit;">into account that the </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angle is counted from the horizontal to the first edge of the rectangle counterclockwise and has a negative value</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The endpoints of the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elliptical contours are found using our procedure, which receives the </font><em><font style="vertical-align: inherit;">mat</font></em><font style="vertical-align: inherit;"> raster</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a discriminated outline extracted from the original image by masking and returns the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maximum defect</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<pre><code class="cpp hljs"> contourConvFeature(mat, &amp;def, ‚Ä¶ );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main code for this function is to call two </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> procedures </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; *hull = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<font></font>
 convexHull(contour, *hull);<font></font>
 <span class="hljs-built_in">vector</span>&lt;Vec4i&gt; *defs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;Vec4i&gt;();<font></font>
 convexityDefects(contour, *hull, *defs);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first procedure finds a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convex polygon</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the contour under study, the second - calculates all the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convexity defects</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We take only </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the largest</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> defect in terms of convexity, considering that it determines the end points of the contour. This may not be the case if the external or internal boundaries of the contour have </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">features</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In order to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smooth</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> them </font><font style="vertical-align: inherit;">, we apply additional smoothing to the contour under study (and not to the entire image so as not to ‚Äúblur‚Äù the isthmuses between the contours and not violate the original topology). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cb/e2/tl/cbe2tlqhmia2hyb727mcspjsb5w.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 4. Calculation of the bulge defect. </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option (a)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mistakenly defines the red endpoint. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option (b)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">correctly defines endpoints. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option (c)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> redefines the endpoints on the original shape. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since in the technology we adopted, the circuit is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regenerated</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> each time </font><font style="vertical-align: inherit;">, we have to re-search for the points of correspondence (or rather, their indices) by the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exhaustive search</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> procedure </font><font style="vertical-align: inherit;">:</font></font><br>
<pre><code class="cpp hljs"> nearestContourPtIdx(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;contour, <span class="hljs-keyword">const</span> Point&amp; pt);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For cases when it is not possible to completely get rid of the features, an additional mode of </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arc separation</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was also implemented </font><font style="vertical-align: inherit;">(work separately with the internal / external arc). This is important, for example, in cases where the external arc of the contour is in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contact</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with other objects or is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noisy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In this case, you can go to work with the internal arc. In this case, it is not necessary to process the external and internal arcs separately. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also, according to the well-known formula for the ratio of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convexity of the arc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">radius of the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> circle </font><font style="vertical-align: inherit;">is approximately estimated </font><font style="vertical-align: inherit;">and too large ellipses are rejected:</font></font><br>
<pre><code class="matlab hljs">R = bulge / <span class="hljs-number">2</span> + SQR(<span class="hljs-built_in">hypot</span>) / (<span class="hljs-number">8</span> * bulge);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, for all the contours, their </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convexity defect metric was</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> found </font><font style="vertical-align: inherit;">(or they are classified as linear or small and removed from the procedure). </font><font style="vertical-align: inherit;">At the last stage, additional parameters are added to the original metric, such as the rotated dimension parameter, etc., and the full set of metrics under study is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordered by size</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-keyword">typedef</span> tuple&lt;<span class="hljs-keyword">int</span> , <span class="hljs-comment">// </span>
   RotatedRect, <span class="hljs-comment">//  </span>
   Vec4i, <span class="hljs-comment">//  </span>
   <span class="hljs-keyword">int</span>&gt; <span class="hljs-comment">// </span>
   RectDefMetric;</code></pre><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithm for linking arc segments at end points</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The growth algorithm is clear and obvious: we take the largest contour as a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seed</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and try to grow it, that is, find and attach the nearest patches to its end points that satisfy the growth conditions. In the grown figure, we enter the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desired elliptical arc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mask and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">subtract the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> figure from the original set. We repeat the growth procedure </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">until the initial set runs out</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The basic procedure of the growth algorithm looks like this:</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-built_in">vector</span>&lt;Point&gt; *patch =<font></font>
    growingContours(contour, def, tmp, hull);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
where </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contour</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the contour under study, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">def</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is its convexity defect, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hull</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the convex polygon of the entire region, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the auxiliary buffer matrix. At the output, we get a vector grown contour. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The procedure consists of a cycle of attempts to seed growth, ending either by exhausting the available patches for growth, or limited by the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameter of the maximum number of iterations</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tp/se/p1/tpsep1tdzgtvitxcnptg9rxu4m0.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 5. Many patches for growth without seed The</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
main difficulty is to select the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nearest patches</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to the end points of the contour, so that the figure grows only </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forward</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . For </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tangential direction</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we take the averaged line belonging to the arc in the vicinity of the endpoint. In </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 6</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> displays the candidates for connection to the seed at a certain iteration. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5g/8x/ij/5g8xijwx2owywp4kgjielcgoft8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 6. Seed surrounded by a plurality of growth candidate patches.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
For each candidate patch, the following metric is calculated:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> tuple&lt;
   <span class="hljs-keyword">double</span>, <span class="hljs-comment">//    2      2   </span>
   <span class="hljs-keyword">bool</span>, <span class="hljs-keyword">bool</span>, <span class="hljs-comment">//,  4   </span>
   <span class="hljs-keyword">int</span>, <span class="hljs-comment">// </span>
   Vec4i&gt; <span class="hljs-comment">//  </span>
   DistMetric;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Only patches that fall into the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tangential cone are</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> taken into account </font><font style="vertical-align: inherit;">. Then the patch with the smallest distance is selected and, by imprinting the connecting section into the raster, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">connects</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to the corresponding end of the seed. For the other end of the seed, a patch matching the parameters is searched, and if found, is also connected to the seed. Then the seed is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masked and subtracted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from the many patches. The procedure is repeated from the very beginning. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the end of the growth procedure, we got an </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elliptical arc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which remains to be verified. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To get started, using the standard </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the procedure that our patch receives (in the form of a path, we remember that the path and raster are interchangeable with us) and returns the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rotated dimension</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , that is, a complete ellipse.</font></font><br>
<pre><code class="cpp hljs"> RotatedRect box = fitEllipse(patch);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then, we reject too large and too small ellipses, and then we apply our original procedure for </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comparing the areas of the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resulting elliptical arc and the initial growth patch in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raster form</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This procedure includes some disguised tricks, so we will omit its description for now. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And finally, we find the remaining parameters of the detected ellipse - the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">start and end angles</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (we already know the half-axes from </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fitEllipse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To determine the starting and ending angles, we proceed as follows: we transform our complete ellipse, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">back to the polygon,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and by direct enumeration we find its points closest to our ends. Their </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angular coordinates</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(in fact, indices) and will be the starting and ending angles of an elliptical arc. </font><font style="vertical-align: inherit;">In code, it looks like this (a bit simplified):</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function">pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;
   <span class="hljs-title">ellipseAngles</span><span class="hljs-params">(<span class="hljs-keyword">const</span> RotatedRect &amp;box,
   <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;ell, <span class="hljs-keyword">const</span> Point &amp;ps, 
   <span class="hljs-keyword">const</span> Point &amp;pe, <span class="hljs-keyword">const</span> Point &amp;pm)</span> 
 </span>{
    <span class="hljs-built_in">vector</span>&lt;Point&gt; ell0;<font></font>
    ellipse2Poly(Point(box.center.x, box.center.y), <font></font>
      Size(box.size.width / <span class="hljs-number">2</span>, box.size.height / <span class="hljs-number">2</span>),<font></font>
      box.angle, <span class="hljs-number">0</span>, <span class="hljs-number">355</span>, <span class="hljs-number">5</span>, ell0);
    <span class="hljs-keyword">int</span> i0 = nearestContourPtIdx(ell0, ps);
    <span class="hljs-keyword">int</span> i1 = nearestContourPtIdx(ell0, pe);<font></font>
    cutSides(ell0, i0, i1, i2, ell, <span class="hljs-literal">nullptr</span>);
    <span class="hljs-keyword">return</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(i0, i1);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cutSides</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> procedure </font><em><font style="vertical-align: inherit;">takes</font></em><font style="vertical-align: inherit;"> into account the </font><font style="vertical-align: inherit;">elliptical arc traversal </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">topology</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In total, eight possible cases of bypassing the indices </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i0, i1, i2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> should be considered </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Do we go along the outer contour or the inner one, and which of the indices is greater, initial or final? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Easier to see code:</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cutSides</span><span class="hljs-params">(
   <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;ell0, <span class="hljs-keyword">int</span> i0, <span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2, 
   <span class="hljs-built_in">vector</span>&lt;Point&gt; *ell_in, <span class="hljs-built_in">vector</span>&lt;Point&gt; *ell_out)</span>
 </span>{
   <span class="hljs-keyword">if</span> (i0 &lt; i1) {
      <span class="hljs-keyword">if</span> (i2 &gt; i0 &amp;&amp; i2 &lt; i1) {
         <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        }}<font></font>
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (i2 &gt; i1 &amp;&amp; i2 &lt; i0) {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        }}}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Some results of detecting ellipses in complex cases are shown in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 7</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jv/56/hd/jv56hdcpfuvmi59k0unppjknlq4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the following articles, statistical detection methods will be considered.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en490386/index.html">How else to make money on the stock exchange and reduce risk: shares of companies with dividend payment</a></li>
<li><a href="../en490390/index.html">Olga Makushenko, Managing Director of 101XP: ‚Äú5 key mistakes in developing a game as a business‚Äù</a></li>
<li><a href="../en490392/index.html">Catchain: TON Blockchain Consensus Algorithm</a></li>
<li><a href="../en490394/index.html">Commodore Amiga 500+: let no one go offended</a></li>
<li><a href="../en490398/index.html">Red Hogwarts. Officers, or Why a historian is like a detective</a></li>
<li><a href="../en490404/index.html">Why and how 5G will change everything: technology, phased implementation and element base for subscriber equipment</a></li>
<li><a href="../en490406/index.html">Inexpressibly attractive: how we created a haniot that cannot be exposed</a></li>
<li><a href="../en490408/index.html">FreeBSD: –≥–æ—Ä–∞–∑–¥–æ –ª—É—á—à–µ GNU/Linux</a></li>
<li><a href="../en490410/index.html">Live and artificial neurons connected via the Internet</a></li>
<li><a href="../en490412/index.html">Maybe we should calm down a bit with JavaScript?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>