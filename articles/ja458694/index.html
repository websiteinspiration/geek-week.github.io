<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏾 🗼 🤦🏾 Python GILはすでに死んでいますか？ 👇🏿 🔆 👩🏿‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="みなさん、こんにちは！来週の月曜日に、Python開発者コースの新しいグループでクラスが始まります。つまり、別の興味深い資料を公開する時間があるので、これを今から行います。読書を楽しむ。
 
 
 
 2003年に、Intelは新しいPentium 4“ HT”プロセッサをリリースしました。このプロ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Python GILはすでに死んでいますか？</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/458694/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">みなさん、こんにちは！</font><font style="vertical-align: inherit;">来週の月曜日に、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python開発者</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コースの新しいグループでクラスが始まります</font><font style="vertical-align: inherit;">。つまり、別の興味深い資料を公開する時間があるので、これを今から行います。</font><font style="vertical-align: inherit;">読書を楽しむ。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jb/cq/wj/jbcqwjrmctxos6x_uzhptngfd9y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2003年に、Intelは新しいPentium 4“ HT”プロセッサをリリースしました。</font><font style="vertical-align: inherit;">このプロセッサーは3GHzにオーバークロックされ、ハイパースレッディングテクノロジーをサポートしていました。</font></font><a name="habracut"></a><br>
<br>
<img src="https://habrastorage.org/webt/9d/z1/es/9dz1esccmgms80liftaeolcqiui.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後数年間、IntelとAMDは、バス速度の向上、L2キャッシュサイズ、およびマトリックスサイズの縮小によりレイテンシを最小限に抑え、最高のデスクトップパフォーマンスを達成するために苦労しました。</font><font style="vertical-align: inherit;">2004年、周波数が3 GHzのHTモデルは、4 GHzにオーバークロックする580“ Prescott”モデルに置き換えられました。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/AmwzUrL3vMc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先に進むには、クロック周波数を上げる必要があるだけのように見えましたが、新しいプロセッサは、高電力消費と熱放散に悩まされていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、デスクトッププロセッサは4 GHzを提供していますか？</font><font style="vertical-align: inherit;">パフォーマンスを改善するためのパスは、最終的にはバス速度の増加とコアの数の増加によって決まるため、可能性は低いです。</font><font style="vertical-align: inherit;">2006年には、Intel Core 2がPentium 4に取って代わり、クロック速度が大幅に低下しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幅広いユーザー向けにマルチコアプロセッサをリリースすることに加えて、2006年には別のことが起こりました。</font><font style="vertical-align: inherit;">Python 2.5がついにその光を見た！</font><font style="vertical-align: inherit;">すでにベータ版のwithキーワードが付属していますが、これは皆さんご存知で気に入っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python 2.5には、Intel Core 2またはAMD Athlon X2を使用する際に1つの大きな制限がありました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 それはGILでした。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GILとは何ですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 GIL（グローバルインタープリターロック）は、ミューテックスで保護されたPythonインタープリターのブール値です。</font><font style="vertical-align: inherit;">ロックは、メインのCPythonバイトコード計算ループで使用され、現在どのスレッドが命令を実行しているかを判別します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CPythonは、単一のインタープリターで複数のスレッドの使用をサポートしますが、低レベルの操作を実行するには、スレッドがGILへのアクセスを要求する必要があります。</font><font style="vertical-align: inherit;">つまり、これは、Python開発者が非同期コード、マルチスレッドを使用でき、デッドロック中の変数のブロックやプロセッサレベルでのクラッシュを心配する必要がなくなることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GILはマルチスレッドPythonプログラミングを簡素化します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/yz/3h/lgyz3hoq07fkumzp4axuuiqxplk.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GILはまた、CPythonはマルチスレッド化できますが、一度に実行できるスレッドは1つだけであることも教えてくれます。</font><font style="vertical-align: inherit;">これは、クアッドコアプロセッサがこのような処理を行うことを意味します（ブルースクリーンを除いて）。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 GILの現在のバージョンは、</font><font style="vertical-align: inherit;">非同期機能をサポートするため</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に2009年に作成され</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、原則的に削除したり、要件を変更したりした後でも、変更されないままでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GILを削除する提案は、インタープリターのグローバルロックがシングルスレッドコードのパフォーマンスを低下させてはならないという事実によって正当化されました。</font><font style="vertical-align: inherit;">2003年にハイパースレッディングを有効にしようとした人なら誰でも、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私が話している</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こと</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">を</font></a><font style="vertical-align: inherit;">理解でき</font><font style="vertical-align: inherit;">ます。</font></font><br>
 <br>
 <h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPythonでのGilの放棄</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 CPythonでコードを本当に並列化する場合は、いくつかのプロセスを使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CPython 2.6では、</font></font><i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチプロセッシング</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モジュール</font><font style="vertical-align: inherit;">が標準ライブラリに追加されました。マルチプロセッシングは、CPythonでのプロセスの生成をマスクしました（各プロセスには独自のGILがあります）。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">name</span>):</span>
    <span class="hljs-keyword">print</span> <span class="hljs-string">'hello'</span>, name<font></font>
<font></font>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<font></font>
    p = Process(target=f, args=(<span class="hljs-string">'bob'</span>,))<font></font>
    p.start()<font></font>
    p.join()</code></pre><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 プロセスが作成され、コンパイルされたモジュールとPython関数を使用してコマンドがプロセスに送信され、メインプロセスに再結合されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マルチプロセッシングは、キューまたはチャネルを介した変数の使用もサポートします。彼女は、メインプロセスのオブジェクトをロックし、他のプロセスから書き込むために使用されるロックオブジェクトを持っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マルチプロセッシングには1つの大きな欠点があります。これは、処理時間とメモリ使用量の両方に影響する大きな計算負荷を伴います。サイトがなくてもCPythonの起動時間は100〜200ミリ秒です（</font><font style="vertical-align: inherit;">詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https：//hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を確認して</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ください</font></a><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、CPythonに並列コードが含まれる可能性がありますが、複数のオブジェクトを共有する長時間実行プロセスの作業を慎重に計画する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の方法として、Twistedなどのサードパーティパッケージを使用することもできます。</font></font><br>
 <br>
 <h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PEP554とGILの死？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 したがって、CPythonのマルチスレッド化は単純ですが、実際には並列化ではありませんが、マルチプロセッシングは並列ですが、かなりのオーバーヘッドが伴います。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もっと良い方法があるとしたら？</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 GILをバイパスする鍵は名前にあります。インタープリターのグローバルロックは、インタープリターのグローバル状態の一部です。 CPythonプロセスは複数のインタープリターを持つことができるため、いくつかのロックがありますが、この関数へのアクセスはC-API経由のみであるため、この関数が使用されることはほとんどありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CPython 3.8の機能の1つはPEP554です。これは、サブ</font></font><code>interpreters</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリーと標準ライブラリの</font><font style="vertical-align: inherit;">新しいモジュール</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">備えたAPIの実装です</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、Pythonから単一のプロセスで複数のインタープリターを作成できます。 Python 3.8のもう1つの革新は、すべてのインタープリターが独自のGILを持つことです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bq/nc/m2/bqncm29jhm-ytakgrlkasbfe_6y.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 インタープリターの状態には、メモリに割り当てられた領域、Pythonオブジェクト（ローカルおよびグローバル）へのすべてのポインターのコレクションが含まれているため、PEP554のサブインタープリターは他のインタープリターのグローバル変数にアクセスできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マルチプロセッシングと同様に、オブジェクトを共有するインタープリターは、オブジェクトをシリアル化し、IPCフォーム（ネットワーク、ディスク、または共有メモリー）を使用することで構成されます。多く例えば、Pythonでオブジェクトをシリアル化する方法、モジュールがあり</font></font><code>marshal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、モジュール、</font></font><code>pickle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または例えばより標準化方法、</font></font><code>json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>simplexml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それらのそれぞれに長所と短所があり、それらのすべてがコンピューティング負荷を与えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定のプロセスによって変更および制御できる共通のメモリ領域を用意するのが最善です。したがって、オブジェクトはメインインタープリターによって送信され、別のインタープリターによって受信されます。これは、メインプロセスがロックを管理する間、すべてのインタープリターがアクセスできるPyObjectポインターを検索するための管理されたメモリスペースになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/be/ww/d8/bewwd8ju-3akmyhs7ujq7xmyliy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このためのAPIはまだ開発中ですが、おそらく次のようになります。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> _xxsubinterpreters <span class="hljs-keyword">as</span> interpreters
<span class="hljs-keyword">import</span> threading
<span class="hljs-keyword">import</span> textwrap <span class="hljs-keyword">as</span> tw
<span class="hljs-keyword">import</span> marshal<font></font>
<font></font>
<span class="hljs-comment"># Create a sub-interpreter</span><font></font>
interpid = interpreters.create()<font></font>
<font></font>
<span class="hljs-comment"># If you had a function that generated some data</span>
arry = list(range(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>))<font></font>
<font></font>
<span class="hljs-comment"># Create a channel</span><font></font>
channel_id = interpreters.channel_create()<font></font>
<font></font>
<span class="hljs-comment"># Pre-populate the interpreter with a module</span>
interpreters.run_string(interpid, <span class="hljs-string">"import marshal; import _xxsubinterpreters as interpreters"</span>)<font></font>
<font></font>
<span class="hljs-comment"># Define a</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">interpid, channel_id</span>):</span><font></font>
    interpreters.run_string(interpid,<font></font>
                            tw.dedent(<span class="hljs-string">"""
        arry_raw = interpreters.channel_recv(channel_id)
        arry = marshal.loads(arry_raw)
        result = [1,2,3,4,5] # where you would do some calculating
        result_raw = marshal.dumps(result)
        interpreters.channel_send(channel_id, result_raw)
        """</span>),<font></font>
               shared=dict(<font></font>
                   channel_id=channel_id<font></font>
               ),<font></font>
               )<font></font>
<font></font>
inp = marshal.dumps(arry)<font></font>
interpreters.channel_send(channel_id, inp)<font></font>
<font></font>
<span class="hljs-comment"># Run inside a thread</span><font></font>
t = threading.Thread(target=run, args=(interpid, channel_id))<font></font>
t.start()<font></font>
<font></font>
<span class="hljs-comment"># Sub interpreter will process. Feel free to do anything else now.</span><font></font>
output = interpreters.channel_recv(channel_id)<font></font>
interpreters.channel_release(channel_id)<font></font>
output_arry = marshal.loads(output)<font></font>
<font></font>
print(output_arry)</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例ではNumPyを使用しています。</font><font style="vertical-align: inherit;">numpy配列はチャネルを介して送信され、モジュールを使用してシリアル化されます</font></font><code>marshal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。その後、サブインタープリターがデータを（別のGILで）処理するため、CPUに関連する並列化の問題があり、サブインタープリターにとって理想的です。</font></font><br>
<br>
<h4><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非効率的に見えます</font></font></b></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 モジュール</font></font><code>marshal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は非常に高速に動作しますが、メモリから直接オブジェクトを共有するほど高速ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PEP574 </font><font style="vertical-align: inherit;">は、他のピクルストリームとは別にメモリバッファを処理する機能をサポート</font><font style="vertical-align: inherit;">する新しい</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピクル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロトコル</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">（v5）</font></a><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">導入し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">大きなデータオブジェクトの場合、それらをすべて一度にシリアル化し、サブインタープリターから逆シリアル化すると、多くのオーバーヘッドが追加されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいAPIは、次のように（純粋に仮説的に）実装できます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> _xxsubinterpreters <span class="hljs-keyword">as</span> interpreters
<span class="hljs-keyword">import</span> threading
<span class="hljs-keyword">import</span> textwrap <span class="hljs-keyword">as</span> tw
<span class="hljs-keyword">import</span> pickle<font></font>
<font></font>
<span class="hljs-comment"># Create a sub-interpreter</span><font></font>
interpid = interpreters.create()<font></font>
<font></font>
<span class="hljs-comment"># If you had a function that generated a numpy array</span>
arry = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<font></font>
<font></font>
<span class="hljs-comment"># Create a channel</span><font></font>
channel_id = interpreters.channel_create()<font></font>
<font></font>
<span class="hljs-comment"># Pre-populate the interpreter with a module</span>
interpreters.run_string(interpid, <span class="hljs-string">"import pickle; import _xxsubinterpreters as interpreters"</span>)<font></font>
<font></font>
buffers=[]<font></font>
<font></font>
<span class="hljs-comment"># Define a</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">interpid, channel_id</span>):</span><font></font>
    interpreters.run_string(interpid,<font></font>
                            tw.dedent(<span class="hljs-string">"""
        arry_raw = interpreters.channel_recv(channel_id)
        arry = pickle.loads(arry_raw)
        print(f"Got: {arry}")
        result = arry[::-1]
        result_raw = pickle.dumps(result, protocol=5)
        interpreters.channel_send(channel_id, result_raw)
        """</span>),<font></font>
                            shared=dict(<font></font>
                                channel_id=channel_id,<font></font>
                            ),<font></font>
                            )<font></font>
<font></font>
input = pickle.dumps(arry, protocol=<span class="hljs-number">5</span>, buffer_callback=buffers.append)<font></font>
interpreters.channel_send(channel_id, input)<font></font>
<font></font>
<span class="hljs-comment"># Run inside a thread</span><font></font>
t = threading.Thread(target=run, args=(interpid, channel_id))<font></font>
t.start()<font></font>
<font></font>
<span class="hljs-comment"># Sub interpreter will process. Feel free to do anything else now.</span><font></font>
output = interpreters.channel_recv(channel_id)<font></font>
interpreters.channel_release(channel_id)<font></font>
output_arry = pickle.loads(output)<font></font>
<font></font>
print(<span class="hljs-string">f"Got back: <span class="hljs-subst">{output_arry}</span>"</span>)</code></pre><br>
 <h4><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それはパターンに見えます </font></font></b></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 本質的に、この例は低レベルのサブインタープリターのAPIの使用に基づいています。</font><font style="vertical-align: inherit;">ライブラリを使用したことがない場合は</font></font><code>multiprocessing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、いくつかの問題に慣れているようです。</font><font style="vertical-align: inherit;">これは、ストリーム処理ほど単純ではありません。たとえば、この関数をこのような入力データのリストで別々のインタープリターで（現時点では）実行することはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このPEPが他のPEPと統合されるとすぐに、PyPiにいくつかの新しいAPIが表示されると思います。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブインタープリターにはどのくらいのオーバーヘッドがありますか？</font></font></h3><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">短い答え：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームよりも、プロセスよりも。</font></font><br>
 <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長い答え：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インタープリターには独自の状態があるため、PEP554がサブインタープリターの作成を単純化しているにもかかわらず、以下のクローンを作成して初期化する必要があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名前空間のモジュール</font></font><code>__main__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>importlib</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">辞書の内容</font></font><code>sys</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">組み込み関数（</font></font><code>print()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>assert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーム;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カーネル構成。</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カーネル構成はメモリから簡単に複製できますが、モジュールのインポートはそれほど単純ではありません。</font><font style="vertical-align: inherit;">モジュールのPythonへのインポートは遅いため、サブインタープリターを作成するたびにモジュールを別の名前空間にインポートすると、メリットが減少します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyncioはどうですか？</font></font></h3><br><font style="vertical-align: inherit;"></font><code>asyncio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準ライブラリの</font><font style="vertical-align: inherit;">
イベントループの既存の実装は、</font><font style="vertical-align: inherit;">評価用のスタックフレームを作成し、メインインタープリターで状態を共有します（したがって、GILを共有します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PEP554を組み合わせた後、おそらくPython 3.9にすでに含まれているため、イベントループの代替実装を使用できます（まだ誰も行っていません）。これにより、サブインタープリターで非同期メソッドを並列に実行します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クールに聞こえます。私もまとめてください。</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、かなり。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CPythonは同じインタープリターで長い間実行されているため、コードベースの多くの部分で「インタープリター状態」ではなく「ランタイム状態」が使用されているため、PEP554が今導入されても、依然として多くの問題があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、ガベージコレクター（バージョン3.7 &lt;）の状態はランタイムに属します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PyConスプリント中の変更では、ガベージコレクターの状態が</font><font style="vertical-align: inherit;">インタープリター</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に移行</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">始めた</font></a><font style="vertical-align: inherit;">ため、各サブインタープリターは独自のガベージコレクターを（当然のことながら）持つことになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの問題は、CPythonのコードベースにCの多くの拡張機能とともに残っている「グローバル」変数があることです。そのため、突然コードを正しく並列化し始めたときに、いくつかの問題が発生しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つの問題は、ファイル記述子がプロセスに属しているため、1つのインタープリターで書き込み用にファイルを開いている場合、サブインタープリターはこのファイルにアクセスできません（CPythonをさらに変更しないと）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要するに、取り組む必要のある多くの問題がまだあります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論：GILはもう本当ですか？ </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GILは引き続きシングルスレッドアプリケーションに使用されます。</font><font style="vertical-align: inherit;">したがって、PEP554を使用している場合でも、シングルスレッドのコードが突然並列になることはありません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python 3.8で並列コードを記述したい場合、プロセッサに関連する並列化の問題が発生しますが、これは将来へのチケットでもあります！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いつ？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pickle v5とマルチプロセッシング用のメモリ共有は、Python 3.8（2019年10月）で行われる可能性が高く、サブインタープリターはバージョン3.8と3.9の間に表示されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提示された例をいじってみたい場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">//github.com/tonybaloney/cpython/tree/subinterpretersに</font></a><font style="vertical-align: inherit;">必要なすべてのコードを含む別のブランチを作成しました</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">。</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これについてあなたはどう思いますか？</font><font style="vertical-align: inherit;">コメントを書いて、コースでお会いしましょう。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja458676/index.html">コンピュータサイエンス教育を最大限に活用する方法</a></li>
<li><a href="../ja458680/index.html">なぜUMLが必要なのですか？または、神経と時間を節約する方法</a></li>
<li><a href="../ja458684/index.html">ICANNが.orgドメインの価格しきい値を削除-ITコミュニティが反対する理由と次に何が起こるか</a></li>
<li><a href="../ja458686/index.html">@Pythonetc 2019年6月</a></li>
<li><a href="../ja458690/index.html">自動化してください！統合テストを改善した方法</a></li>
<li><a href="../ja458696/index.html">テクスチャリング、またはSurfaceアーティストになるために知っておくべきこと。パート3. PBRと材料</a></li>
<li><a href="../ja458698/index.html">ITプロジェクトにおける平和の道と戦争の道</a></li>
<li><a href="../ja458702/index.html">そり犬：あなたがそれらについて知っておくべきこと、そして彼らがどのように連れてきたのか</a></li>
<li><a href="../ja458704/index.html">小売の例でのDLPシステムの実装</a></li>
<li><a href="../ja458706/index.html">Gopnikは現在海外市場に出ている、または「なぜ通常のプログラマーを見つけるのがそれほど難しいのですか？」</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>