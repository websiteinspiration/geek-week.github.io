<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧖🏽 🌴 🥩 HighLoad ++、Mikhail Tyulenev（MongoDB）：因果関係の一貫性：理論から実践へ 🕡 👨‍🎓 👩🏼‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="次回のHighLoad ++カンファレンスは、2020年4月6日と7日にサンクトペテルブルクで開催されます。
 詳細とチケットはこちら。 HighLoad ++シベリア2019。ホール「クラスノヤルスク」。 6月25日12時。アブストラクトとプレゼンテーション。
 
 
 
 実際の要件は、商用製品...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>HighLoad ++、Mikhail Tyulenev（MongoDB）：因果関係の一貫性：理論から実践へ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/487638/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次回のHighLoad ++カンファレンスは、2020年4月6日と7日にサンクトペテルブルクで開催されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
詳細とチケットは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 HighLoad ++シベリア2019。ホール「クラスノヤルスク」。 6月25日12時。アブストラクトと</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレゼンテーション</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ok/iw/mz/okiwmzx4qkp6dxvjvqjxvfzqtnk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際の要件は、商用製品にとって重要な側面が考慮されていない理論と矛盾することがあります。このレポートでは、商用製品の要件に基づいた学術研究に基づいて、因果律の一貫性コンポーネントを作成するためのさまざまなアプローチを選択して組み合わせるプロセスを紹介します。学生は、論理クロック、依存関係の追跡、システムセキュリティ、クロック同期に対する既存の理論的アプローチ、およびMongoDBがこれらまたはこれらのソリューションで停止した理由について学びます。</font></font><a name="habracut"></a><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mikhail Tyulenev（以下-MT）：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -私は因果一貫性について話します-これは、MongoDBで取り組んだ機能です。</font><font style="vertical-align: inherit;">私は分散システムのグループで働いていますが、2年ほど前にやっていました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ih/xx/xg/ihxxxghkrknnqdxg7tb4w97izi0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その過程で、この機能はよく研究されているので、私は多くの学術研究に精通する必要がありました。</font><font style="vertical-align: inherit;">実稼働アプリケーションで必要とされる非常に具体的な要件を考慮した場合、データベースは実稼働で必要とされるものに適合しないことが判明しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
学術研究の消費者として、私たちがそれから何かを準備し、便利で安全に使用できる既製の料理としてユーザーに提示できる方法について説明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原因の一貫性。</font><font style="vertical-align: inherit;">コンセプトを定義しましょう</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、因果的一貫性とは何かを概説したいと思います。レナードとペニーの2つのキャラクター（シリーズ「ビッグバン理論」）があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7q/nw/lr/7qnwlrmqtidow8cl_jrdakec3d0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ペニーがヨーロッパにいて、レナードが彼女のために何らかのサプライズをしたいとします。パーティーです。そして彼は彼女を友達リストから捨てて、すべての友達を養うために更新を送るより良いものを思いつきません：「ペニーを幸せにしましょう！」 （ヨーロッパにいる彼女は、寝ている間、これをすべて見ることができず、彼女がそこにいないので見ることができません）最後に、この投稿を削除し、「フィード」から削除し、アクセスを復元して、何も気づかず、スキャンダルが発生しないようにします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで問題ありませんが、システムが分散していて、イベントが少し間違っていると仮定します。</font><font style="vertical-align: inherit;">たとえば、イベントが因果関係によって関連付けられていない場合、この投稿が表示された後にペニーアクセス制限が発生した可能性があります。</font><font style="vertical-align: inherit;">実際、これはビジネス機能（この場合）を実行するために因果律の一貫性が必要な場合の例です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、これらはデータベースのかなり重要なプロパティです-それらをサポートする人はほとんどいません。</font><font style="vertical-align: inherit;">モデルに移りましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整合性モデル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的にデータベースの整合性モデルとは何ですか？</font><font style="vertical-align: inherit;">これらは、クライアントが受信できるデータとシーケンスについて分散システムが提供する保証の一部です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則として、すべての整合性モデルは、システムがどのように分散しているか、たとえば、ラップトップの同じノードで機能するシステムのようなものです。</font><font style="vertical-align: inherit;">そして、これは、地理的に分散した何千もの「ノード」で動作するシステムが、これらすべてのプロパティが原則として自動的に実行されるラップトップに似ている程度です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、整合性モデルは分散システムにのみ適用されます。</font><font style="vertical-align: inherit;">以前存在し、同じ垂直スケーリングで機能していたすべてのシステムでは、このような問題は発生しませんでした。</font><font style="vertical-align: inherit;">バッファキャッシュが1つあり、すべてが常にそこから読み取られました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">強力なモデル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、最初のモデルはストロング（または、よく呼ばれる上昇線の能力）です。</font><font style="vertical-align: inherit;">これは一貫性モデルであり、すべての変更が、発生したことの確認を受信するとすぐに、システムのすべてのユーザーに表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、データベース内のすべてのイベントのグローバルな順序が作成されます。</font><font style="vertical-align: inherit;">これは非常に強い一貫性のプロパティであり、一般に非常に高価です。</font><font style="vertical-align: inherit;">しかし、それは非常によく維持されています。</font><font style="vertical-align: inherit;">それは単に非常に高価で遅い-それらは単にめったに使用されません。</font><font style="vertical-align: inherit;">これは上昇能力と呼ばれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「Spanner」でサポートされている別のより強力なプロパティがあります-外部整合性と呼ばれます。</font><font style="vertical-align: inherit;">少し後で彼について話します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因果関係</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、私が話していた因果関係です。ストロングと因果関係の間には話さないサブレベルがいくつかありますが、それらはすべて因果関係に分類されます。これは、すべてのモデルの中で最も強力であり、ネットワークまたはパーティションの存在下で最も強い整合性があるため、重要なモデルです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因果関係は、実際には、イベントが因果関係によって関連付けられている状況です。非常に多くの場合、クライアントの観点からは、「あなたの権利を読む」と認識されます。クライアントがいくつかの値を観察した場合、過去の値を見ることができません。彼はすでに接頭辞の読みを見始めています。それはすべて同じことです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一貫性のモデルとしての因果関係は、サーバー上のイベントの部分的な順序付けであり、すべてのクライアントからのイベントが同じ順序で観察されます。</font><font style="vertical-align: inherit;">この場合、レナードとペニー。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最終的な</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目のモデルは、結果整合性です。これは、すべての分散システムを完全にサポートするものであり、一般的に意味のある最小限のモデルです。これは、次のことを意味します。データに変更があった場合、それらはある時点で整合性を保ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような瞬間、彼女は何も言わず、さもなければ彼女は外部整合性に変わります-全く異なる話があるでしょう。それにもかかわらず、これは非常に人気のあるモデルであり、最も一般的です。デフォルトでは、分散システムのすべてのユーザーが結果整合性を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの比較例を挙げたい</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yn/5s/p9/yn5sp9tyjn4dh4q3vonroirvxic.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
と思います。これらの矢印はどういう意味ですか？</font></font><br>
<br>
<ul>
<li><b>Latency.</b>          :    ,       ,    ,     .   Eventual Consistency   ,   ,  ,    memory       .</li>
<li><b>Availability.</b>           , partitions,  -  –      ,    ,         - . Eventual Consistency        –    ,  .</li>
<li><b>Anomalies.</b>  , ,   .  Strong Consistency       ,  Eventual Consistency     .  :     Eventual Consistency,    ?    ,  Eventual Consistency- ,   , ,    ;        -   ;       .   ,       .</li>
</ul><br>
<h3> CAP</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一貫性、可用性という言葉を目にすると、何が思い浮かびますか？右-CAP定理！今、私は神話を払拭したいと思います...それは私ではありません-素晴らしい記事、素晴らしい本を書いたマーティン・クレップマンがいます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-k/rc/v1/-krcv1vofhv9ofnwbty6ql6hvhg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CAPの定理は、一貫性、可用性、パーティションが2000年代に定式化された原則です。2つ取り、3つを選択することはできません。それはある原則でした。それは数年後、ギルバートとリンチによって定理として証明された。その後、それはマントラとして使用されるようになりました-システムはCA、CP、APなどに分割され始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この定理は、実際には次の理由で証明されました。まず、可用性は0から100までの連続値（0-システムは「死んでいる」、100-迅速に回答します。考慮に慣れています）ではなく、アルゴリズムのプロパティと見なされました。これにより、すべての実行でデータが返されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
応答時間について一言もありません！ 100年後にデータを返すアルゴリズムがあります。これは、CAPの定理の一部である、完全に利用可能なアルゴリズムです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二に、これらの変更はサイズ変更可能な行であるという事実にもかかわらず、同じキーの値の変更についての定理が証明されました。これは、モデルが異なる結果整合性、強整合性（多分）であるため、実際には使用されていないことを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこれがすべてなのですか？</font><font style="vertical-align: inherit;">さらに、CAPの定理が実際に適用できないことが証明された形で使用されることはほとんどありません。</font><font style="vertical-align: inherit;">理論的な形で、それは何とかすべてを制限します。</font><font style="vertical-align: inherit;">直感的には真実であるが、一般的には証明されない特定の原則が判明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原因の一貫性-最強のモデル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在何が起こっているのか-次の3つすべてを取得できます。整合性、可用性はパーティションを使用して取得できます。</font><font style="vertical-align: inherit;">特に、因果一貫性は最も強力な一貫性モデルであり、パーティション（ネットワークブレーク）が存在しても機能します。</font><font style="vertical-align: inherit;">そのため、非常に関心が高く、取り組んでいます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ty/4s/k8/ty4sk8sx4n73xnsxlkw2wtb1ity.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、アプリケーション開発者の作業を簡素化します。</font><font style="vertical-align: inherit;">特に、サーバーからの多くのサポートがあります。1つのクライアント内で発生するすべてのレコードが、この順序で他のクライアントに到着することが保証されている場合です。</font><font style="vertical-align: inherit;">次に、パーティションに耐えます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インテリアキッチンMongoDB</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その昼食を思い出して、私たちは台所に移動します。最初にそのようなデータベースについて聞いた人のために、MongoDBとは何か、システムモデルについて説明します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fn/-b/kj/fn-bkjwvkdxcokzum9xwwkshcu8.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/2u/qz/3g/2uqz3gts5ipfvvojtpo2epigtf4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MongoDB（以下「MongoBD」と呼ぶ）は、水平スケーリング、つまりシャーディングをサポートする分散システムです。各シャード内で、データの冗長性、つまりレプリケーションもサポートします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「MongoBD」（非リレーショナルデータベース）のシャーディングは、自動バランシング、つまりドキュメント（またはリレーショナルデータの観点では「テーブル」）の各コレクションを断片に分割し、サーバーはそれらをシャード間で自動的に移動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントのクエリを配信するクエリルーターは、クライアント経由で動作するクライアントです。彼はすでにデータの場所と場所を知っており、すべてのリクエストを正しいシャードに送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の重要なポイント：MongoDBは単一のマスターです。</font><font style="vertical-align: inherit;">プライマリは1つあります-プライマリが含むキーをサポートするレコードを取得できます。</font><font style="vertical-align: inherit;">マルチマスター書き込みはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはリリース4.2を作成しました-新しい興味深いものがそこに現れました。</font><font style="vertical-align: inherit;">特に、彼らはLuceneを挿入しました-検索-それは "Mongo"で直接実行可能なjavaでした、そしてそこで "Elastic"と同じようにLuceneを通して検索することが可能になりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、彼らは新製品を作りました-チャート、それはアトラス（モンゴ自身のクラウド）でも利用可能です。</font><font style="vertical-align: inherit;">彼らは無料のティアを持っています-あなたはこれで遊ぶことができます。</font><font style="vertical-align: inherit;">私はチャートが本当に好きでした-データの視覚化は非常に直感的です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因果関係の成分</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はこのトピックで公開された約230の記事を数えました-レスリーランパートから。</font><font style="vertical-align: inherit;">さて、私の記憶から、これらの資料の一部をお届けします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2_/dt/2n/2_dt2nhood8jlup51kyeddsy7w8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべては、1970年代に書かれたLeslie Lampertの記事から始まりました。</font><font style="vertical-align: inherit;">ご覧のとおり、このトピックに関するいくつかの研究はまだ進行中です。</font><font style="vertical-align: inherit;">現在、因果関係の一貫性は、分散システムの開発に関連して関心を集めています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制限事項</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
制限は何ですか？</font><font style="vertical-align: inherit;">生産システムが課す制限は学術論文に存在する制限とは非常に異なるため、これは実際には主要なポイントの1つです。</font><font style="vertical-align: inherit;">多くの場合、それらはかなり人工的です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qd/nh/ql/qdnhql6zcor1hzt53ur72spzqzy.jpeg"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まず、「MongoDB」は、すでに述べたように単一のマスターです（これにより大幅に簡素化されます）。</font></font></li>
<li> ,   10     .     -  ,      .</li>
<li>   ,   ,      ,    binary,     ,    .</li>
<li>  ,   Research  :      . «» –  . ,     ,  –    .  ,     .</li>
<li>  ,     –  :    ,   performance degradation   .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もう1つのポイントは、一般に反学問的です。以前のバージョンと将来のバージョンの互換性です。</font><font style="vertical-align: inherit;">古いドライバーは新しい更新をサポートする必要があり、データベースは古いドライバーをサポートする必要があります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、これらすべてに制限があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因果一貫性コンポーネント</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、いくつかのコンポーネントについて説明します。</font><font style="vertical-align: inherit;">一般的な因果関係の一貫性を考慮すると、ブロックを区別できます。</font><font style="vertical-align: inherit;">私たちは、特定のブロックに属する作業から選択しました：依存関係の追跡、時間の選択、これらの時計を互いに同期させる方法、およびセキュリティを確保する方法-これは、これから説明するおおよその計画です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zv/rb/rq/zvrbrqunyfdrj1pmbrjncugqed4.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全な依存関係の追跡</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜそれが必要なのですか？データが複製されるとき-各レコード、各データ変更には、それが依存する変更に関する情報が含まれます。最初の単純な変更は、レコードを含む各メッセージに前のメッセージに関する情報が含まれている場合です</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gk/ue/jh/gkuejhztxm81mfji3fazhsmbmbm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。この例では、中括弧内の数字はレコードの数です。値を持つこれらのレコードが完全に転送される場合もあれば、一部のバージョンが転送される場合もあります。要するに、各変更には前の変更に関する情報が含まれているということです（明らかに、それ自体にすべてが含まれています）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこのアプローチ（完全追跡）を使用しないことにしたのですか？</font><font style="vertical-align: inherit;">明らかに、このアプローチは実用的ではないため、ソーシャルネットワークの変更はすべて、このソーシャルネットワークの以前のすべての変更に依存し、たとえば、更新ごとにFacebookまたはVkontakteを送信します。</font><font style="vertical-align: inherit;">それにもかかわらず、完全依存性追跡という多くの研究があります。これらはソーシャルネットワークであり、状況によっては実際に機能します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明示的な依存関係の追跡</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のものはもっと制限されています。</font><font style="vertical-align: inherit;">ここでも情報の伝達が考慮されますが、それは明らかに依存するものだけです。</font><font style="vertical-align: inherit;">何に依存するかは、原則として、アプリケーションによってすでに決定されています。</font><font style="vertical-align: inherit;">データが複製されると、要求が行われたとき、以前の依存関係が満たされたとき、つまり表示されたときに、応答のみが返されます。</font><font style="vertical-align: inherit;">これは、因果律の一貫性の仕組みの本質です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y_/jc/mw/y_jcmwt2w-vqj9guslui0wl8vgi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼女は、レコード5がレコード1、2、3、4にそれぞれ依存していることを確認します。以前のすべての変更がすでにデータベースに渡されている場合、クライアントはペニーのアクセス命令によって行われた変更にアクセスできるようになるまで待機します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とにかく情報が多すぎて遅くなるため、これも私たちには向いていません。</font><font style="vertical-align: inherit;">別のアプローチがあります...</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランポートクロック</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らはとても古いです。ランポートクロックは、これらの依存関係がランポートクロックと呼ばれるスカラー関数に縮小されることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スカラー関数は抽象的な数値です。しばしば論理時間と呼ばれます。各イベントで、このカウンターは増加します。現在プロセスに認識されているカウンターが各メッセージを送信します。プロセスが同期していない可能性があることは明らかであり、プロセスが完全に異なる時間を持つ可能性があります。それにもかかわらず、システムは何らかの形でそのようなメッセージングとクロックのバランスをとります。この場合はどうなりますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はその大きな破片を2つに分割し、明確にしました。友達はコレクションの一部を含む1つのノードに住み、フィードはこのコレクションの一部を含む別のノードに住むことができます。彼らがどうやって順番を狂わせることができるかは明らかですかまずFeedは「複製された」と言い、次にFriendsと言います。システムが、FriendsコレクションのFriends依存関係も配信されるまでFeedが表示されないという保証を提供しない場合、私が述べた状況になるだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Feedで論理的にカウンター時間が増加することがわかります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gv/pz/vw/gvpzvwwxqonuthkwv6j2ez0fruc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、このランポートクロックと因果律の一貫性（ランポートクロックで説明）の主なプロパティは次のとおりです。イベントAとBがあり、イベントBがイベントA *に依存している場合、イベントAのLogicalTimeはより少なくなります。イベントBのLogicalTimeより</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も*時々、AがBの前に発生した、つまりAがBの前に発生したとさえ言われます-これは、一般的に発生したイベントのセット全体を部分的に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">順序付ける</font><i><font style="vertical-align: inherit;">一種の関係です。</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
逆は間違っています。これは、実際にはランポートクロックの主な欠点の1つである、部分的な順序付けです。同時イベントの概念があります。つまり、（AがBの前に発生した）イベントも（AがBの前に発生した）イベントもありません。例としては、他の誰かの友人へのレナードによる並行した追加があります（レナードでさえも、シェルドンなど）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Lamportウォッチを操作するときによく使用されるプロパティです。これらは、関数を正確に調べ、これから結論を導きます。これらのイベントは依存している可能性があります。</font><font style="vertical-align: inherit;">一方向ではこれが当てはまるため、LogicalTime AがLogicalTime Bよりも小さい場合、BはAの前に発生できません。</font><font style="vertical-align: inherit;">そしてそれ以上なら、多分。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベクトル時計</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ランポートの時計の論理的な発展は、ベクトル時計です。これらは、ここにある各ノードが独自の個別のクロックを含み、ベクトルとして送信されるという点で異なります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、ベクターのゼロインデックスがフィードを担当し、ベクターの最初のインデックスがフレンド（各ノード）を担当していることがわかります。そして今、それらは増加します：記録時に「フィード」のゼロインデックスが増加します-1、2、3：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cv/xm/cd/cvxmcdiz_dgbjsu7elnj3xt2hcc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ベクトルクロックはどのように優れていますか？どのイベントが同時に発生し、いつ異なるノードで発生するかを把握できるという事実。これは、MongoBDのようなシャーディングシステムにとって非常に重要です。しかし、これは素晴らしいことですが、私たちはこれを選択しませんでした。それはうまく機能し、おそらく私たちに適しています...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1万個のシャードがある場合、1万個のコンポーネントを転送することはできません。圧縮しても、別のことを考えます。すべて同じですが、ペイロードはこのベクトル全体のボリュームの数分の1になります。</font><font style="vertical-align: inherit;">したがって、私たちは心と歯を磨いて、このアプローチを断念して別のものに移りました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spanner TrueTime。</font><font style="vertical-align: inherit;">原子時計</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Spannerについての話があると言った。これは21世紀にぴったりです。原子時計、GPS同期。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どんなアイデア？ Spannerは、最近でも利用できるようになったGoogleシステムです（SQLを接続しています）。トランザクションごとにタイムスタンプがあります。時刻が同期されるため、各イベントに特定の時刻を割り当てることができます-アトミッククロックには待機時間があり、その後、別の時間が発生することが保証されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zn/vw/e3/znvwe3zwpqvjhsx-qglxpbqen9g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、データベースに書き込んで一定時間待機するだけで、イベントのシリアル化が自動的に保証されます。それらは、原則的に想像できる最も強い整合性モデルを持っています-それは外部整合性です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
*これは、Lampartウォッチの主な問題です。分散システムでは同期しません。</font><font style="vertical-align: inherit;">これらはNTPを使用しても発散する可能性があり、依然としてうまく機能しません。</font><font style="vertical-align: inherit;">「Spanner」には原子時計があり、同期はマイクロ秒のようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜ選択しなかったのですか？</font><font style="vertical-align: inherit;">ユーザーが組み込みの原子時計を持っているとは限りません。</font><font style="vertical-align: inherit;">それらが表示され、すべてのラップトップに組み込まれている場合、ある種の超クールなGPS同期があります-そうです...それまでの間、可能な限り最高の方法は、Amazon、狂信者のための基地局です...したがって、他の時計を使用しました</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハイブリッド時計</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは実際に、因果の一貫性を確保しながら「MongoBD」を刻むものです。</font><font style="vertical-align: inherit;">それらはハイブリッドですか？</font><font style="vertical-align: inherit;">ハイブリッドはスカラー値ですが、2つのコンポーネントで構成されています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hi/wz/uv/hiwzuvz-czbmb52b9iypojrr0_u.jpeg"><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つ目はUNIXの時代です（「コンピューターの世界の始まり」から何秒経過したか）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つ目はインクリメントで、これも32ビットの符号なし整数です。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際はそれだけです。</font><font style="vertical-align: inherit;">そのようなアプローチがあります：時間を担当する部分は常に時計と同期しています。</font><font style="vertical-align: inherit;">更新が発生するたびに、この部分は時計と同期され、時刻は常に正確であることがわかります。増分により、同時に発生したイベントを区別できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがMongoBDにとってなぜ重要なのですか？</font><font style="vertical-align: inherit;">これにより、特定の時点である種のバックアップ復元を作成できるため、つまり、イベントは時間によってインデックス化されます。</font><font style="vertical-align: inherit;">これは、いくつかのイベントが必要な場合に重要です。</font><font style="vertical-align: inherit;">データベースの場合、イベントは、特定の時間に発生するデータベースへの変更です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も重要な理由のみをお伝えします（誰にも言わないでください）。</font><font style="vertical-align: inherit;">これを行ったのは、MongoDB OpLogの順序付けされたインデックス付きデータが次のようになるためです。</font><font style="vertical-align: inherit;">OpLogは、データベース内のすべての変更を含むデータ構造です。最初にOpLogに移動し、複製された日付またはシャードの場合、それらはすでにストレージ自体に適用されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それが主な理由でした。</font><font style="vertical-align: inherit;">それでも、データベースの開発には実用的な要件もあります。つまり、データベースは単純でなければなりません。つまり、コードがほとんどなく、書き直してテストする必要のある壊れたものはほとんどありません。</font><font style="vertical-align: inherit;">私たちのoplogがハイブリッド時計によってインデックス付けされたという事実は、私たちに大きな助けとなり、正しい選択をすることを可能にしました。</font><font style="vertical-align: inherit;">最初のプロトタイプで本当に効果があり、魔法のように機能しました。</font><font style="vertical-align: inherit;">とてもかっこよかったです！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クロック同期</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
科学文献にはいくつかの同期方法が記載されています。</font><font style="vertical-align: inherit;">2つの異なる断片がある場合の同期について話しています。</font><font style="vertical-align: inherit;">レプリカセットが1つある場合は、そこで同期する必要はありません。これは「単一マスター」です。</font><font style="vertical-align: inherit;">OpLogがあり、すべての変更が該当します。この場合、すべてがOplog自体ですでに順番に並べられています。</font><font style="vertical-align: inherit;">ただし、2つの異なる断片がある場合、ここでは時刻の同期が重要です。</font><font style="vertical-align: inherit;">ここでベクトル時計がさらに役立ちました！</font><font style="vertical-align: inherit;">しかし、私たちはそれらを持っていません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ei/kq/bk/eikqbkbbzrsdquzxjxlzayc81qq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つ目はハートビートです。</font><font style="vertical-align: inherit;">時間の単位ごとに発生する信号を交換できます。</font><font style="vertical-align: inherit;">しかし、ハートビットは遅すぎるため、クライアントにレイテンシを提供できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、本当の時間は素晴らしいものです。</font><font style="vertical-align: inherit;">しかし、再び、これはおそらく未来です... Atlasは既に実行できますが、高速の「Amazonian」時刻同期装置がすでにあります。</font><font style="vertical-align: inherit;">ただし、すべての人が利用できるわけではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゴシップとは、すべてのメッセージに時間が含まれる場合です。</font><font style="vertical-align: inherit;">これは大体私たちが使うものです。</font><font style="vertical-align: inherit;">ノード間の各メッセージ、ドライバー、データノードのルーター、「MongoDB」のすべてのもの-これらはいくつかの要素であり、流れるクロックを含むデータベースコンポーネントです。</font><font style="vertical-align: inherit;">彼らがハイブリッド時間の意味を持っているところならどこでも、それは伝達されます。</font><font style="vertical-align: inherit;">64ビット？</font><font style="vertical-align: inherit;">可能です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのように連携するのですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、少し簡単にするために1つのレプリカセットを確認します。プライマリとセカンダリがあります。セカンダリはレプリケーションを実行し、常にプライマリと完全に同期しているわけではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「Primaries」に特定の時間の値の挿入（挿入）があります。この挿入は、最大の場合、内部カウンターを11増やします。または、クロック値をチェックし、クロックが大きい場合はクロックによって同期します。これにより、時間で並べ替えることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼がレコードを作った後、重要な瞬間が起こります。時間は「MongoDB」にあり、「Oplog」に記録されている場合にのみ増加します。これは、システムの状態を変更するイベントです。絶対にすべての古典的な記事では、イベントはノードに入るメッセージと見なされます。メッセージが到着しました-つまり、システムがその状態を変更しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、調査中にこのメッセージがどのように解釈されるかを理解することが完全には不可能であるという事実によるものです。 「Oplog」に反映されていない場合は、解釈されず、「Oplog」のエントリのみがシステムの状態の変化であることが確実にわかります。これにより、すべてが簡素化されます。モデルにより、1つのレプリカセットのフレームワークやその他多くの便利なものを簡素化して整理できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「Oplog」にすでに記録されている値を返します-「Oplog」にはこの値がすでにあり、その時間が12であることがわかります。今度は、読み取りが別のノード（セカンダリ）から開始され、ClusterTime自体の後ですでに転送されています。メッセージ。彼は言う：「私は少なくとも12年後または12年中に起こったすべてのものを必要とします」（上記の図を参照）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、因果的一貫性（CAT）と呼ばれるものです。理論的には、それ自体が一貫している時間の一部であるという概念があります。この場合、これは時刻12に観測されたシステムの状態で</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あると言えます。セカンダリがプライマリからデータを複製する必要がある状況をシミュレートしているように見えるため、ここには何もありません。彼は待っています...そして今、データが来ました-これらの値を返します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/a1/q7/3q/a1q73qclyk9sn567b2x8szr_ejm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それがすべての仕組みです。ほとんど。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「ほぼ」とはどういう意味ですか？これがどのように機能するかを読んで理解した人がいるとしましょう。 ClusterTimeが発生するたびに、内部論理クロックが更新され、次のレコードが1つ増えることに気づきました。この関数は20行を占めます。この人が、可能な限り最大の64ビット数から1を引いたものを送信するとします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜマイナス1ですか？内部クロックがこの値に置き換えられるため（明らかに、これは可能な限り最大であり、現在の時間よりも大きい）、「Olog」にエントリがあり、クロックがさらに1つインクリメントします-すでに最大値があります（単にすべてのユニットがあり、どこにも行けません） 、符号なし整数）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この後、システムがまったくアクセスできなくなることは明らかです。</font><font style="vertical-align: inherit;">それはアンロード、クリーニングすることができるだけです-多くの手動作業。</font><font style="vertical-align: inherit;">完全な可用性：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/iu/lz/fs/iulzfslzcst3tn9c-qpouy9zqsk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、これが別の場所にレプリケートされる場合、クラスター全体が単純に停止します。</font><font style="vertical-align: inherit;">誰でも非常に迅速かつ簡単に整理できる、絶対に許容できない状況です。</font><font style="vertical-align: inherit;">したがって、この瞬間を最も重要なものの1つと見なしました。</font><font style="vertical-align: inherit;">それを防ぐ方法は？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちの方法は、clusterTimeに署名することです</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、メッセージで送信されます（青色のテキストの前）。しかし、署名（青色のテキスト）の生成も開始しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zg/9r/iu/zg9riuabqzdlnw9dwttrwkwzkmi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
署名は、保護された境界内のデータベース内に格納されているキーによって生成されます。生成、更新されます（ユーザーには何も表示されません）。ハッシュが生成され、各メッセージは作成中に署名され、受信時に検証されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、「どれだけ遅くなるか」という疑問が人々に出てくるでしょう。特にこの機能がない場合は、すぐに機能するはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、因果一貫性を使用するとはどういう意味ですか？これにより、afterClusterTimeパラメーターが表示されます。そしてそれがなければ、とにかく値を渡すだけです。おしゃべりは、バージョン3.6以降、常に機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シグネチャを常に生成したままにしておくと、機能がない場合でもシステムの速度が低下し、これは私たちのアプローチや要件を満たしていません。</font><font style="vertical-align: inherit;">そして、私たちは何をしましたか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">早くやって！</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単なことですが、トリックは興味深いです-私はそれを共有します、おそらく誰かが興味を持つでしょう。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
署名されたデータを格納するハッシュがあります。</font><font style="vertical-align: inherit;">すべてのデータはキャッシュを通過します。</font><font style="vertical-align: inherit;">キャッシュは時間に明確に署名するのではなく、範囲に署名します。</font><font style="vertical-align: inherit;">特定の値が来ると、範囲を生成し、最後の16ビットをマスクし、この値に署名します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s8/ml/3a/s8ml3aaec2pj5xl8t0zvkrp7iik.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような署名を受け取ることにより、システムを（条件付きで）65千倍高速化します。</font><font style="vertical-align: inherit;">それは素晴らしい働きをします：彼らが実験を行ったとき、私たちが一貫した更新を行っていた時間はそこで実際に1万倍に短縮されました。</font><font style="vertical-align: inherit;">彼らが対立しているとき、これが機能しないことは明らかです。</font><font style="vertical-align: inherit;">しかし、ほとんどの場合、これは機能します。</font><font style="vertical-align: inherit;">Rangeシグニチャとシグニチャの組み合わせにより、セキュリティの問題が解決されました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何を学びましたか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これから学んだ教訓：</font></font><br>
<br>
<ul>
<li>  , , ,       .     -  ( ,      . .),  , .   ,       ,    ,   .        –   .<br>
<br>
,     ,      («», ) –      .     ?    .     ,      .   –   ,   .</li>
<li>    .  ,        «»     ,   ,  ,      availability, latency  .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後は、さまざまなアイデアを検討し、いくつかの一般的に異なる記事を1つのアプローチにまとめる必要があったことです。</font><font style="vertical-align: inherit;">たとえば、署名のアイデアは、承認プロトコル内の非ビザンチンフェイラー、承認プロトコル外のビザンチンプロトコルなど、Paxosプロトコルを調査した記事に由来しています...一般的に、これは最終的に私たちが行ったこととまったく同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここにはまったく新しいものはありません！</font><font style="vertical-align: inherit;">しかし、すべてを混ぜ合わせるとすぐに...卵、マヨネーズ、きゅうりはすでに思いついたので、オリビエのサラダのレシピはナンセンスだと言っているようなものです...それは同じ話についてです。</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/6o/pc/q8/6opcq8ew4bcry9qnt0lsdlasflo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで終わります。</font><font style="vertical-align: inherit;">感謝！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ご質問</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">聴衆からの質問（以下-B）：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -マイケル、レポートをありがとう！時間のテーマは面白いです。あなたはうわさ話を使っています。彼らは誰もが自分の時間を持っている、誰もが自分の現地時間を知っていると言いました。私が理解しているように、私たちはドライバーを持っています-ドライバーを持つ多くのクライアント、クエリプランナー、多くのシャードが存在する可能性があります...しかし、突然不一致が生じた場合、システムはどうなるでしょう：先、誰か-少し遅れて？どこに行きますか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -本当に素晴らしい質問です！私は破片について言いたかっただけです。私が質問を正しく理解している場合、この状況があります：シャード1とシャード2があり、これらの2つのシャードから読み取りが行われます-両者には不一致があり、相互に作用しません。それらはoplogに存在します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シャード1が100万件のレコードを作成し、シャード2は何もせず、リクエストが2つのシャードで発生したとします。そして、最初のものは、100万以上のafterClusterTimeを持っています。このような状況では、私が説明したように、シャード2がまったく応答しません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -同期方法と1つの論理時間を選択する方法を知りたいですか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -同期は非常に簡単です。シャード、afterClusterTimeが来て、「キャッチ」で時間を見つけられない場合-承認されていない状態を開始します。つまり、彼は彼の手を使ってこの価値に手を上げます。つまり、このクエリに一致するイベントはありません。彼はこの出来事を人為的に作成し、したがって因果的一貫性を持つようになります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -その後、ネットワーク上のどこかで失われた他のいくつかのイベントがまだ彼に届いた場合？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-破片はシングルマスターなので、もう来ないように配置されています。彼がすでに録音している場合、彼らは来ませんが、後になります。どこかに何かが行き詰まっていると、彼は書き込みを行わず、これらのイベントが到着することは起こり得ません。そして、因果関係の一貫性が侵害されました。彼が書いていないとき、彼ら全員は次に来る必要があります（彼は彼らを待つでしょう）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t2/wb/oo/t2wboofhfs7qpepqz8zwsm1o0u4.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AT：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-ラインについていくつか質問があります。因果律の一貫性は、実行する必要があるアクションの特定のキューがあることを前提としています。パッケージを1つ失うとどうなりますか？ですから、10日目、11日目、12日目が消え、他の誰もがそれが満たされるのを待っています。そして突然車が死んでしまい、何もできなくなりました。実行前に累積されるキューの最大長はありますか？ 1つの状態が失われると、どのような致命的な障害が発生しますか？また、なんらかの前の状態があることを書き留めると、どういうわけかそれから始めるべきでしょうか？そして、彼らは彼からプッシュしませんでした！</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-また、素晴らしい質問です！何してるの？ MongoDBには、クォーラムレコード、クォーラムリードの概念があります。メッセージはいつ消えますか？レコードが定足数でない場合、または読み取り値が定足数でない場合（一部のゴミも付着する可能性があります）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因果一貫性に関しては、大規模な実験的テストを実施しました。その結果、記録と読み取りが定足数でない場合、因果一貫性違反が発生しました。まさにあなたの言うこと！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒント：因果一貫性を使用する場合は、少なくとも定足数の読みを使用してください。この場合、クォーラムレコードが失われても、何も失われません...これは正反対の状況です。ユーザーがデータを失わないようにする場合は、クォーラムレコードを使用する必要があります。原因の一貫性は耐久性を保証しません。耐久性の保証は、レプリケーションおよびレプリケーションに関連する機構によって提供されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -シャーディングでインスタンスを作成する場合（それぞれマスターではなくスレーブ）、それは自身のマシンのUNIX時間または「マスター」の時間に依存します。初めてまたは定期的に同期しましたか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-それを明確にします。シャード（つまり、水平パーティション）-常にプライマリがあります。また、シャードには「マスター」が存在し、レプリカが存在する場合があります。ただし、シャードは特定のドメインをサポートする必要があるため、常に書き込みをサポートします（プライマリはシャード内にあります）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -つまり、すべてが純粋に「マスター」に依存していますか？常に「マスター」時間を使用しますか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -はい。それは比喩的に言うことができます：「Oplog」の「マスター」に録音があるとき、時計は刻々と過ぎています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -接続するクライアントがあり、彼は時間について何も知る必要はありませんか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-一般的に、あなたは何も知る必要はありません！それがクライアントでどのように機能するかについて話すと、クライアントで因果一貫性を使用したいときに、セッションを開く必要があります。これですべてが揃いました。セッション内の両方のトランザクションと権限の取得...セッションは、クライアントで発生する論理イベントの順序です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼がこのセッションを開いて、因果一貫性が必要であると言った場合（デフォルトでセッションが因果一貫性をサポートしている場合）、すべてが自動的に機能します。ドライバーはこの時間を記憶し、新しいメッセージを受信するとそれを増やします。データを返したサーバーから前の応答が返されたのを覚えています。次のリクエストには、afterClusterが含まれます（「time is this than this」）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントはまったく何も知る必要はありません！これは彼には絶対に不透明です。これらの機能を使用している場合、どうすればよいですか？ 1つは、セカンダリを安全に読み取ることができることです。プライマリで書き込み、地理的に複製されたセカンダリから読み取ることができ、確実に機能します。同時に、プライマリに記録されたセッションをセカンダリにも転送できます。つまり、1つのセッションではなく複数のセッションを使用できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -結果整合性のトピックは、新しいコンピュートサイエンスレイヤーに強く関連しています-競合のない複製されたデータ型）。これらのタイプのデータのデータベースへの統合を検討したことがありますか？それについて何と言えますか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -いい質問です！ CRDTは、MongoDB-単一マスターでの書き込み競合に対して意味があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AT：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-私は開発者から質問があります。現実の世界では、ビザンチンの失敗が起こり、保護された境界内の邪悪な人々がプロトコルに固執し始め、特別な方法でクラフトパッケージを送信するようなイエズス会の状況がありますか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8d/m3/p5/8dm3p5em6rsqsv2ojzy-vdylffg.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -周辺の邪悪な人々はトロイの木馬のようなものです！境界内の邪悪な人々は多くの悪いことをすることができます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -大まかに言って、サーバーに穴を残すと、象の動物園を突き刺してクラスタ全体を永久に折りたたむことができます...手動で回復するには時間がかかります...これは、穏やかに言えば、間違っています。一方、これは奇妙なことです。現実の世界では、実際には、自然に類似した内部攻撃が発生する状況がありますか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-私は実際にセキュリティ侵害に遭遇することはめったにないので、私は言うことはできません-おそらくそれは起こります。しかし、開発哲学について語る場合、私たちはそう思います。私たちは安全を確保する人たちを提供する境界線を持っています-それは城、壁です。そして、境界線の内側では、あなたがやりたいことが何でもできます。見ることだけができるユーザーと、ディレクトリを消去することができるユーザーがいることは明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
権利に応じて、ユーザーが実行できる損傷は、マウスである場合と、象である場合があります。完全な権限を持つユーザーが何でもできることは明らかです。害の広範な権利を持たないユーザーは、大幅に被害を減らすことができます。特に、システムを破壊することはできません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AT：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-安全な境界では、誰かがサーバーにガンを設定するためにサーバーの予期しないプロトコルを形成するために登りました。運が良ければ、クラスター全体が...そんなに「よく」起こりますか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -私はそのようなことを聞​​いたことがありません。この方法でサーバーにデータを入力できることは秘密ではありません。プロトコルから、メッセージにそのような何かを書くことができる許可されたユーザーとして、内部を埋めるために...とにかく検証されるので、実際には不可能です。望まないユーザーに対してこの認証を無効にすることができます-これが問題になります。大まかに言えば、彼ら自身が壁を破壊し、そこに象を詰め込むことができます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AT：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-レポートをありがとう。</font><font style="vertical-align: inherit;">セルゲイ（Yandex）。</font><font style="vertical-align: inherit;">「Mong」には、レプリカセットの投票メンバー数を制限する定数があり、この定数は7（7）です。</font><font style="vertical-align: inherit;">なぜこれは定数ですか？</font><font style="vertical-align: inherit;">なぜこれはある種のパラメータではないのですか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -レプリカセットには40ノードもあります。</font><font style="vertical-align: inherit;">常に過半数があります。</font><font style="vertical-align: inherit;">どのバージョンかわからない... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -レプリカセットでは、投票以外のメンバーを実行できますが、投票は最大7です。この場合、レプリカセットを3つのデータセンターにプルした場合、どのようにシャットダウンしますか？</font><font style="vertical-align: inherit;">1つのデータセンターは簡単にオフになり、別のマシンは故障します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MT：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -これはすでにレポートの範囲外です。</font><font style="vertical-align: inherit;">これはよくある質問です。</font><font style="vertical-align: inherit;">多分それから私は彼に言うことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9t/cr/ga/9tcrgaodiufisllhrktf_5iok_a.jpeg"><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/UnAprFMX1d4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">広告のビット:)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いつもご利用いただきありがとうございます。私たちの記事は好きですか？もっと面白い資料を見たいですか？私たちが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発した</font></font></a><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エントリーレベルサーバーのユニークなアナログで</font></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ある</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">$ 4.99から</font></a><font style="vertical-align: inherit;">、注文またはお友達</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">への開発者向けクラウドベースVPSの開発者</font></a><font style="vertical-align: inherit;">への推奨によって私たちをサポートして</font><b><font style="vertical-align: inherit;">ください：</font></b></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VPS（KVM）E5-2697 v3（6コア）10GB DDR4 480GB SSD 1Gbpsの真実19ドルから、またはサーバーを分割する方法？</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（オプションは、RAID1およびRAID10、最大24コア、最大40GB DDR4で利用可能です）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xdは、アムステルダムのEquinix Tier IVデータセンターで2倍安いですか？</font></font></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">オランダでは</font></b><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">199ドルのIntel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV</font></a></b><font style="vertical-align: inherit;">が</font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">2つ</font></a></b><font style="vertical-align: inherit;">だけあり</font><b><font style="vertical-align: inherit;">ます！</font></b></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デルR420-2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB-$ 99から！</font></font></b></b><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">インフラストラクチャビルディングの構築方法</font></a><font style="vertical-align: inherit;">について</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">お</font></a><font style="vertical-align: inherit;">読みください</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Dell R730xd E5-2650 v4サーバーを使用するクラスcは、1ペニーで9,000ユーロかかりますか？</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja487626/index.html">駐車センサーの仕組みと彼をだます方法</a></li>
<li><a href="../ja487628/index.html">老化徴候の9つの特徴に基づく老化の診断</a></li>
<li><a href="../ja487630/index.html">フィールドパズルを作成するための最も単純なアルゴリズム（パート1）</a></li>
<li><a href="../ja487632/index.html">「同僚、もっと静かに呼吸する」：オフィスの騒音が私たちを狂わせる理由-研究について話し合う</a></li>
<li><a href="../ja487636/index.html">最終的にJava 8からアップグレードする価値のあるAPI。パート2</a></li>
<li><a href="../ja487640/index.html">ゲーム自動化テスト</a></li>
<li><a href="../ja487644/index.html">Pythonを使用した株価情報の取得</a></li>
<li><a href="../ja487646/index.html">試験管中性子星。ソノルミネッセンス</a></li>
<li><a href="../ja487648/index.html">それは別のjavascriptフレームワークかもしれません。</a></li>
<li><a href="../ja487650/index.html">SDKに期待して、誤解しないでください：BottomSheetBehaviorでのネストされたスクロールの問題</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>