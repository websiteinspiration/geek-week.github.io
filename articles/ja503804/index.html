<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏸️ Ⓜ️ 🕍 データベース用のタイムマシンを作成し、誤ってエクスプロイトを作成する方法の物語 👨🏽‍🤝‍👨🏼 👩🏼‍🤝‍👨🏽 🚩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、Habr。
 
 データベース内の時間を変更する方法を考えたことはありますか？簡単？まあ、いくつかのケースでは、はい、それは簡単です-Linuxのdateコマンドと物事は帽子の中にあります。そして、サーバーに複数ある場合に、データベースの1つのインスタンス内でのみ時間を変更する必要がある...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>データベース用のタイムマシンを作成し、誤ってエクスプロイトを作成する方法の物語</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503804/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、Habr。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベース内の時間を変更する方法を考えたことはありますか？</font><font style="vertical-align: inherit;">簡単？</font><font style="vertical-align: inherit;">まあ、いくつかのケースでは、はい、それは簡単です-Linuxのdateコマンドと物事は帽子の中にあります。</font><font style="vertical-align: inherit;">そして、サーバーに複数ある場合に、データベースの1つのインスタンス内でのみ時間を変更する必要がある場合はどうでしょうか。</font><font style="vertical-align: inherit;">そして、単一のデータベースプロセスのために？</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして？</font><font style="vertical-align: inherit;">ええと、それだけです、私の友人、それがすべてのポイントです。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、現実とは関係なく、定期的にハブレに配置される別のサーであると誰かが言うでしょう。</font><font style="vertical-align: inherit;">しかし、いいえ、タスクは非常に現実的であり、生産の必要性、つまりコードテストによって決定されます。</font><font style="vertical-align: inherit;">私は同意しますが、テストケースは非常にエキゾチックなものになる可能性があります。将来の特定の日付におけるコードの動作を確認してください。</font><font style="vertical-align: inherit;">この記事では、このタスクがどのように解決されたかを詳細に検討すると同時に、テストと開発者がOracleベースを表すプロセスを少しだけ捉えます。</font><font style="vertical-align: inherit;">長い読書の前に、気持ちよくなって猫を頼んでください。</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックグラウンド</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがなぜ必要なのかを示すために、簡単な紹介から始めましょう。すでに発表したように、データベースに編集を実装するときにテストを作成します。これらのテストが行​​われるシステムはゼロゼロの最初（または開始の少し前）に開発されたため、すべてのビジネスロジックはデータベース内にあり、ストアドプロシージャの形式でpl / sql言語で記述されています。そして、はい、それは私たちに痛みと苦しみをもたらします。しかし、これは遺産であり、あなたはそれとともに生きなければなりません。コードと表形式モデルでは、システム内のパラメーターが時間の経過とともにどのように変化するかを指定できます。つまり、アクティビティをどの日付からどの日付に適用できるかを設定できます。何をすべきか-VAT率の最近の変化はこれの鮮やかな例です。このようなシステムの変更を事前に確認できるように、そのような変更のあるデータベースを将来の特定の日付に転送する必要がある場合、テーブルのコードパラメータは「現時点」でアクティブになります。また、サポートされているシステムの詳細により、テストセッションの開始時に現在のシステム日付の戻り値を言語で変更するだけの模擬テストは使用できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、理由を特定し、次に</font><font style="vertical-align: inherit;">目標</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">達成</font><font style="vertical-align: inherit;">する</font><i><font style="vertical-align: inherit;">方法</font></i><font style="vertical-align: inherit;">を決定</font><i><font style="vertical-align: inherit;">する</font></i><font style="vertical-align: inherit;">必要があり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これを行うために、開発者向けのテストベンチを構築するためのオプションと、各テストセッションがどのように開始されたかを少し遡及します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">石器時代</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
むかしむかし、ツリーが小さく、メインフレームが大きいとき、開発用のサーバーは1つしかなく、テストも行っていました。</font><font style="vertical-align: inherit;">そして原則として、これはすべての人にとって十分でした（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">640Kですべての人にとって十分です！</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短所：時間を変更するタスクでは、システム管理者（ルートからsubdサーバーで時間を変更する）、DBMS管理者（データベースを再起動する）、プログラマ（コードの一部が機能しなくなったため、時間の変更が発生することを通知する必要がありました。たとえば、以前にAPIメソッドを呼び出すために発行されたWebトークンが有効でなくなり、これが驚かされる可能性があります）、テスター（自身のテスト）...すべてが逆の順序で繰り返されました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中世</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間の経過とともに、部門の開発者の数は増加し、ある時点で1台のサーバーで十分ではなくなりました。主に、異なる開発者が同じpl / sqlパッケージを変更し、（時間を変更せずに）パッケージのテストを実行したいという事実が原因です。ますます憤慨が聞かれました。これで十分です。工場は労働者に、土地は農民に！すべてのプログラマーがデータベースを持っています！」ただし、数テラバイトの製品データベースと50〜100人の開発者がいる場合、正直なところ、この形式では、要件はあまり現実的ではありません。それでも、テストと開発のベースが、構造とテーブル内のデータの両方で、売上に大きく遅れないようにしたいと誰もが望んでいます。テスト用に別のサーバーがあったので、それを本番前と呼びましょう。 2つの同一のサーバーから構築され、RMANドルからデータベースを復元するための販売が行われた場所で、約2〜2.5日かかりました。リカバリ後、データベースは個人データやその他の重要なデータを匿名化し、テストアプリケーションからの負荷がこのサーバーに適用されました（プログラマー自身も常に、最近復元されたサーバーで作業していました）。必要なサーバーでの作業は、corosync（pacemaker）でサポートされるクラスターip-resourceを使用して保証されました。全員がアクティブサーバーで作業している間に、2番目のノードでデータベースの回復が再び開始され、2〜3日後に再び場所が変わります。必要なサーバーでの作業は、corosync（pacemaker）でサポートされているクラスターip-resourceを使用して確認されました。全員がアクティブサーバーで作業している間に、2番目のノードでデータベースの回復が再開され、2〜3日後に再び場所が変わります。必要なサーバーでの作業は、corosync（pacemaker）でサポートされるクラスターip-resourceを使用して保証されました。全員がアクティブサーバーで作業している間に、2番目のノードでデータベースの回復が再び開始され、2〜3日後に再び場所が変わります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかな欠点としては、2台のサーバーと2倍のリソース（主にディスク）がprodの2倍必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長所：時間変更の操作とテスト-2番目のサーバー、メインサーバーで実行できます。現時点では、開発者はライブでビジネスを行っています。</font><font style="vertical-align: inherit;">サーバーの変更は、データベースの準備が整ったときにのみ発生し、テスト環境のダウンタイムは最小限です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">科学技術の進歩の時代</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
11gリリース2データベースに切り替えたとき、CloneDBという名前でOracleが提供する興味深いテクノロジーについて読みました。肝心な点は、製品データベースのバックアップ（製品データファイルの直接ビットコピーがある）が特別なサーバーに保存され、DNFS（直接NFS）を介してこのデータファイルのセットを基本的に任意の数のサーバーに公開することであり、サーバー上に1つ持つ必要はありません。 Copy-On-Writeアプローチが実装されているため、同じボリュームのディスク。データベースは、バックアップサーバーからのデータファイルとネットワーク共有を使用してテーブルのデータを読み取り、変更は開発サーバー自体のローカルデータファイルに書き込まれます。ローカルデータファイルがあまり大きくならず、場所が終了しないように、サーバーに対して定期的に「期限のゼロ化」が行われます。サーバーを更新すると、データもテーブルで非個人化され、同時に、すべてのテーブルの更新はローカルデータファイルに分類され、それらのテーブルはローカルサーバーから読み取られ、他のすべてのテーブルはネットワーク経由で読み取られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短所：サーバーは2つありますが（コンシューマーのダウンタイムを最小限に抑えて更新をスムーズに行うため）、ディスクのボリュームが大幅に削減されます。 nfsボールにドルを格納するには、製品としてサーバーのサイズ+-がさらに1つ必要ですが、更新の実行時間自体は短縮されます（特に増分ドルを使用する場合）。 NFSボールを使用したネットワーキングは、IO読み取り操作を著しく遅くします。 CloneDBテクノロジを使用するには、ベースがEnterprise Editionである必要があります。この場合、毎回テストベースでアップグレード手順を実行する必要がありました。幸い、テストデータベースはOracleのライセンスポリシーから除外されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長所：ベースをベイクアップから復元する操作は1日未満で完了します（正確な時間を覚えていません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間の変更：大きな変化はありません。</font><font style="vertical-align: inherit;">これまでに、サーバーの時刻を変更してデータベースを再起動するためのスクリプトが既に作成されていましたが、これを行うに</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">管理者の</font><s><font style="vertical-align: inherit;">秩序の注意を</font></s><font style="vertical-align: inherit;">引く必要はありません</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい歴史の時代</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ディスクスペースをさらに節約し、データをオフラインで読み取るために、CloneDBバージョン（フラッシュバックとスナップショット付き）を、圧縮されたファイルシステムを使用して実装することにしました。</font><font style="vertical-align: inherit;">予備テストでは、Linuxカーネルでの公式サポートはありませんが、ZFSを選択しました（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">記事</font></a><font style="vertical-align: inherit;">からの引用）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）比較のために、Oracleが推進しているBTRFS（bツリーfs）も調べましたが、テストでは、同じCPUとRAMの消費では圧縮率が低くなりました。 RHEL5でZFSサポートを有効にするために、UEK（アンブレイカブルエンタープライズカーネル）に基づく独自のカーネルが構築されました。新しいAxesとカーネルでは、既製のUEKカーネルを使用できます。このようなテストベースの実装もCOWメカニズムに基づいていますが、ファイルシステムスナップショットのレベルです。サーバーに2つのディスクデバイスが提供され、1つでzfsプールが作成されます。RMANを通じて追加のスタンバイデータベースが販売から作成されます。圧縮を使用しているため、パーティションの使用量は実稼働より少なくなります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムは2番目のディスクデバイスにインストールされ、残りは、サーバーとデータベース自体が機能するために必要です（たとえば、元に戻すと一時的なパーティション）。いつでも、zfsプールからスナップショットを作成できます。これは、別のデータベースとして開きます。スナップショットの作成には数秒かかります。魔法です！そして、そのようなデータベースは、サーバーにすべてのインスタンスとzfsプールサイズ自体（非個人化中およびデータベースクローンのライフサイクル中のデータファイルの変更を格納するため）に十分なRAMがある場合、原則としてかなり多く傾けることができます。テストベースを更新する主な時間は、データの個人化解除の操作ですが、15〜20分で収まります。大幅な加速があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
短所：サーバーでは、システム時間を変換するだけでは時間を変更できません。これは、このサーバーで実行されているすべてのデータベースインスタンスが一度にこの時間に該当するためです。この問題の解決策が見つかりました。適切なセクションで説明します。今後は、データベースの1つのインスタンス内のみで時間を変更できると言います（</font><i><font style="vertical-align: inherit;">インスタンスごとの</font></i><font style="vertical-align: inherit;">時間変更アプローチ）</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）同じサーバー上の残りに影響を与えることなく。</font><font style="vertical-align: inherit;">また、サーバー自体の時間も変化しません。</font><font style="vertical-align: inherit;">これにより、ルートスクリプトがサーバーの時刻を変更する必要がなくなります。</font><font style="vertical-align: inherit;">また、この段階で、Jenkins CIを介したインスタンスの時間変更自動化が実装され、ブースを所有するユーザー（比較的言えば、開発チーム）は、自分自身が時間を変更し、ブースを販売で現在の状態に更新し、スナップショットを作成できるジョブに対する権限が与えられます以前に作成したスナップショットへのベースの復元（ロールバック）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最近の歴史の時代</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oracle 12cの登場により、プラグイン可能なデータベースと、その結果としてコンテナーデータベース（cdb）という新しいテクノロジーが登場しました。このテクノロジーを使用すると、1つの物理インスタンス内で、インスタンスの共通のメモリ領域を共有するいくつかの「仮想」データベースを作成できます。長所：サーバーのメモリを節約できます（以前に占有されていたすべてのメモリ（たとえば、5つの異なるインスタンス）は、cdb内のデプロイされたすべてのpdbコンテナで共有でき、それらのみが使用するため、データベースの全体的なパフォーマンスを向上できます前のフェーズではなく、実際にそれが必要な場合、各インスタンスが自身に割り当てられたメモリを「ブロック」し、クローンの1つのアクティビティが低い場合、メモリは効果的に使用されませんでした。つまり、アイドル状態でした）。異なるpdbのデータファイルはまだzfsプールにあり、クローンをデプロイするとき、それらは同じzfsスナップショットメカを使用します。この段階で、ほぼすべての開発者に独自のデータベースを提供できるようになりました。この段階で時間を変更しても、データベースを再起動する必要はなく、時間の変更が必要なプロセスに対してのみ正確に機能します。このデータベースを使用する他のすべてのユーザーは影響を受けません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マイナス：</font><font style="vertical-align: inherit;">現在1つのインスタンスしか持っていないため、前のフェーズからの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インスタンスごとの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間変更アプローチを使用できません</font><font style="vertical-align: inherit;">。しかし、このケースの解決策が見つかりました。そして、この記事を書くきっかけとなったのはまさにこれでした。これからは、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセスごとの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間変化</font><font style="vertical-align: inherit;">、つまり各データベースプロセスでは、一般的に独自の一意の時間を設定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、データベースに接続した直後の一般的なテストセッションは、作業の開始時に適切な時間を設定し、テストを実行して、終了時に時間を返します。 1つの単純な理由で時間を返す必要があります。一部のOracleデータベースプロセスは、データベースクライアントがサーバーから切断されても終了しません。これらは、専用サーバーとは異なり、データベースサーバーの起動時に実行され、ほぼ無期限に実行される（理想的には）共有サーバーと呼ばれるサーバープロセスです。世界の写真）。このようなサーバープロセスで時刻を変更したままにすると、このプロセスで処理される別の接続が誤った時刻を受け取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのシステムでは、共有サーバーが多用されています。 11gまでは、システムが高負荷に耐えるための適切なソリューションは事実上ありませんでした（11gでは、DRCPが出現-データベース常駐接続プール）。そしてこれが理由です-サブでは、専用モードと共有モードの両方で作成できるサーバープロセスの総数に制限があります。専用プロセスは、データベースが共有プロセスのプールから既に準備されている共有プロセスを発行できるよりもゆっくりと生成されます。つまり、新しい接続が常に到着している場合（特に、プロセスが他の遅い操作を実行している場合）、プロセスの総数は増加します。セッション/プロセスの制限に達すると、データベースは新しい接続のサービスを停止し、折りたたみが発生します。共有プロセスのプールの使用への移行により、接続時にサーバー上の新しいプロセスの数を減らすことができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、テストデータベースを構築するためのテクノロジのレビューが完了し、データベース自体の時間変更アルゴリズムの実装を開始できます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インスタンスごとの偽のアプローチ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベース内の時間を変更するにはどうすればよいですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に頭に浮かんだのは、すべてのビジネスロジックコードを含むスキームで作成することでした。独自の関数は、時間とともに機能する言語関数（sysdate、current_dateなど）と重複し、特定の条件下で他の値を与え始めます。たとえば、テスト実行の開始時にセッションコンテキストを介して値を設定します。それはうまくいきませんでした、組み込みの言語関数はユーザーのものと重複しませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、軽量の仮想化システム（Vserver、OpenVZ）とdockerによるコンテナー化をテストしました。どちらも機能しません。ホストシステムと同じカーネルを使用します。つまり、同じシステムタイマー値を使用します。再び落ちる。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ここで私はこの言葉の救済、Linuxの世界の素晴らしい発明-共有オブジェクトの動的ロードの段階での関数の再定義/インターセプトに来ることを恐れません。これは、LD_PRELOADのトリックとして多くの人に知られています。環境変数LD_PRELOADでは、プロセスが必要とする他のすべてのライブラリよりも先にロードされるライブラリを指定できます。このライブラリに、たとえば後でロードされる標準libcと同じ名前の文字が含まれている場合、アプリケーションのシンボルインポートテーブルは関数のようになります。代替モジュールを提供します。そして、まさにそれが</font><i><font style="vertical-align: inherit;">libfaketime</font></i><font style="vertical-align: inherit;">プロジェクトライブラリの</font><i><font style="vertical-align: inherit;">役割</font></i><font style="vertical-align: inherit;">です。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムとは別の時間にデータベースを起動するために使用し始めました。ライブラリは、システムタイマーの操作とシステムの時刻と日付の取得に関連する呼び出しを見逃します。現在のサーバーの日付を基準に移動する時間、またはプロセス内の時間を制御するために、すべてはLD_PRELOADと一緒に設定する必要がある環境変数によって制御されます。時間変更を実装するために、Jenkinsサーバーにジョブを実装しました。これは、データベースサーバーに入り、libfaketimeに設定された環境変数の有無にかかわらず、DBMSを再起動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
置換時間でデータベースを開始するためのアルゴリズムの例：</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-built_in">export</span> LD_PRELOAD=/usr/<span class="hljs-built_in">local</span>/lib/faketime/libfaketime.so
<span class="hljs-built_in">export</span> FAKETIME=<span class="hljs-string">"+1d"</span>
<span class="hljs-built_in">export</span> FAKETIME_NO_CACHE=1<font></font>
<font></font>
<span class="hljs-variable">$ORACLE_HOME</span>/bin/sqlplus @/home/oracle/scripts/restart_db.sql
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、すべてがすぐに機能したと考えれば、あなたは深く誤解されます。</font><font style="vertical-align: inherit;">判明したように、DBMSの起動時にプロセスにロードされるライブラリを検証するためです。</font><font style="vertical-align: inherit;">そしてアラートログで、ベースは起動しませんが、彼は気づいた偽造品に憤慨し始めます。</font><font style="vertical-align: inherit;">今、それを取り除く方法を正確に覚えていません。起動時に健全性チェックの実行を無効にすることができるいくつかのパラメーターがあります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセスごとの偽のアプローチ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つのプロセス内でのみ時間を変更するという一般的な考え方は変わりませんでした-libfaketimeを使用してください。</font><font style="vertical-align: inherit;">ライブラリをプリロードしてデータベースを起動しますが、起動時にゼロタイムオフセットを設定します。これは、すべてのDBMSプロセスに反映されます。</font><font style="vertical-align: inherit;">次に、テストセッション内で、このプロセスのみの環境変数を設定します。</font><font style="vertical-align: inherit;">Pff、ビジネス何か。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、PL / SQL言語に精通している人にとって、この考えの全体の運命はすぐに明らかです。言語が非常に限られていて、基本的に高レベルのタスクに適しているからです。そこではシステムプログラミングを実装できません。一部の低レベルの操作（たとえば、ネットワークの操作、ファイルの操作）は、プリインストールされたシステムdbms / utlパッケージの形式で存在します。私はOracleで働いている間ずっと、プレインストールされたパッケージのリバースエンジニアリングを数回行っていました。それらの一部のコードは、見知らぬ人の目には見えません（それらはラップと呼ばれています）。何かを見ることを禁じられていると、それが内部にどのように配置されているかを知りたくなる誘惑が高まるだけです。しかし、そのようなパッケージの機能は</font><font style="vertical-align: inherit;">ディスク上のso-librariesへの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cインターフェース</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として実装されているため、anvrapperの後でさえ、常に何かが見られるとは限りません</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全体として、実装</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手順の</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">候補者の1人に</font><i><font style="vertical-align: inherit;">外部手順</font></i><font style="vertical-align: inherit;">を使用してアプローチしました</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特別な方法で設計されたライブラリはメソッドをエクスポートでき、Oracleデータベースはそれをpl / sqlを介して呼び出すことができます。有望なようです。上級plsqlコースでこれに出会ったことがあるので、調理方法を非常に遠く覚えていました。そして、それはドキュメントを読む必要があることを意味します。私はそれを読んだ-そしてすぐに落ち込んだ。このようなカスタムsoライブラリのロードは、データベースリスナーを介して別のエージェントプロセスで行われ、このエージェントとの通信はdlinkを介して行われるためです。したがって、私たちのアイデアは、データベースプロセス自体の内部に環境変数を設定することを叫びました。そして、これはすべてセキュリティ上の理由で行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それがどのように機能するかを示すドキュメントからの写真：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pu/1h/07/pu1h07d6fvy1wwetq4deujbpnga.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
so / dllライブラリのタイプはそれほど重要ではありませんが、何らかの理由で画像はWindows専用です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たぶん、誰かがもう1つの潜在的な機会に気づいたのでしょう。はい、これはJavaです。 Oracleでは、ストアドプロシージャコードをplsqlだけでなく、Javaでも記述できますが、plsqlメソッドと同じ方法でエクスポートされます。定期的にこれを行ったので、問題はないはずです。しかし、それから別の落とし穴が隠されました。 Javaは環境のコピーで動作し、JVMプロセスが起動時に持っていた環境変数のみを取得できます。組み込みJVMはデータベースプロセスの環境変数を継承しますが、それだけです。リフレクションを介して読み取り専用マップを変更する方法をインターネットでヒントを見ましたが、それはまだ単なるコピーなので、要点は何ですか。つまり、女性は再び何も残されませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、Javaは貴重な毛皮だけではありません。これを使用すると、データベースプロセス内からプロセスを生成できます。すべての安全でない操作は、java付与メカニズムを通じて個別に解決する必要がありますが、dbms_javaパッケージを使用して行われます。 plsqlコード内から、システムビューのv $セッションとv $プロセスを使用して、コードが実行されている現在のサーバープロセスのプロセスpidを取得できます。さらに、このpidで何かを行うために、セッションから子プロセスを生成できます。開始するには、データベースプロセス内にあるすべての環境変数を推定しました（仮説をテストするため）。</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh
</span>
pid=<span class="hljs-variable">$1</span><font></font>
<font></font>
awk <span class="hljs-string">'BEGIN {RS="\0"; ORS="\n"} $0'</span> <span class="hljs-string">"/proc/<span class="hljs-variable">$pid</span>/environ"</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
よく推論され、それから何が。 environファイルの変数を変更することはまだ不可能です。これは、開始時にプロセスに転送されたデータであり、それらは読み取り専用です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は、stackoverflowで「別のプロセスで環境変数を変更する方法」でインターネットを検索しました。答えのほとんどは不可能であるというものでしたが、この機会を標準以下の汚いハックとして説明する答えが1つありました。そして、その答えは</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルバートアインシュタイン</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gdbでした。デバッガーは、そのpidを知っている任意のプロセスにフックして、その中に存在する任意の関数/プロシージャを、たとえば、いくつかのライブラリーからパブリックにエクスポートされたシンボルとして実行できます。 libcには、環境変数を操作するための関数があり、libcはOracleデータベースの任意のプロセス（およびLinux上の実際には任意のプログラム）にロードされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、外部プロセスで環境変数を設定する方法です（ptraceが使用されているため、ルートから呼び出す必要があります）。</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh
</span>
pid=<span class="hljs-variable">$1</span>
env_name=<span class="hljs-variable">$2</span>
env_val=<span class="hljs-string">"<span class="hljs-variable">$3</span>"</span><font></font>
<font></font>
out=`gdb -q -batch -ex <span class="hljs-string">"attach <span class="hljs-variable">$pid</span>"</span> -ex <span class="hljs-string">'call (int) setenv("'</span><span class="hljs-variable">$env_name</span><span class="hljs-string">'", "'</span><span class="hljs-string">"<span class="hljs-variable">$env_val</span>"</span><span class="hljs-string">'", 1)'</span> -ex <span class="hljs-string">"detach"</span> 2&gt;&amp;1`
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、gdbプロセス内の環境変数を確認することも適しています。</font><font style="vertical-align: inherit;">前述のように、/ proc / pid /の環境ファイルには、プロセスの開始時に存在した変数のみが表示されます。</font><font style="vertical-align: inherit;">そして、プロセスがその作業の過程で何かを作成した場合、これはデバッガを通してのみ見ることができます：</font></font><br>
<pre><code class="bash hljs"><span class="hljs-meta">#!/bin/sh
</span>
pid=<span class="hljs-variable">$1</span>
var_name=<span class="hljs-variable">$2</span><font></font>
<font></font>
var_value=`gdb -q -batch -ex <span class="hljs-string">"attach <span class="hljs-variable">$pid</span>"</span> -ex <span class="hljs-string">'call (char*) getenv("'</span><span class="hljs-variable">$var_name</span><span class="hljs-string">'")'</span> -ex <span class="hljs-string">'detach'</span> | egrep <span class="hljs-string">'^\$1 ='</span>`<font></font>
<font></font>
<span class="hljs-keyword">if</span> [ <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span> == <span class="hljs-string">'$1 = 0x0'</span> ]
<span class="hljs-keyword">then</span>
  <span class="hljs-comment"># variable empty or does not exist</span>
  <span class="hljs-built_in">echo</span> -n
<span class="hljs-keyword">else</span>
  <span class="hljs-comment"># gdb returns $1 = hex_value "string value"</span>
  var_hex=`<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span> | awk <span class="hljs-string">'{print $3}'</span>`<font></font>
  var_value=`<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span> | sed -r -e <span class="hljs-string">'s/^\$1 = '</span><span class="hljs-variable">$var_hex</span><span class="hljs-string">' //;s/^"//;s/"$//'</span>`<font></font>
  <font></font>
  <span class="hljs-built_in">echo</span> -n <span class="hljs-string">"<span class="hljs-variable">$var_value</span>"</span>
<span class="hljs-keyword">fi</span>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ソリューションはすでにポケットにあります。Javaを介してデバッガプロセスを生成します。デバッガプロセスは、それを生成したプロセスに移動し、目的の環境変数を設定して終了します（ムーアが仕事を終えた-ムーアは去ることができます）。</font><font style="vertical-align: inherit;">でも松葉杖みたいな感じがしました。</font><font style="vertical-align: inherit;">もっとエレガントなものが欲しかった。</font><font style="vertical-align: inherit;">データベースプロセス自体に外部からの攻撃なしに環境変数を設定させることは、何とか同じです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アヒルの卵、ウサギのアヒル...</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、誰かが救いに来て、はい、あなたはそれを正しく推測しました、再びJava、すなわちJNI（javaネイティブインターフェース）。</font><font style="vertical-align: inherit;">JNIを使​​用すると、JVM内でネイティブCメソッドを呼び出すことができます。</font><font style="vertical-align: inherit;">コードは、ライブラリの共有オブジェクトの形式で特別な方法で発行され、JVMがロードします。一方、ライブラリ内にあったメソッドは、ネイティブ修飾子で宣言されたクラス内のJavaメソッドにマップされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、わかりました、私たちはクラスを書いています（実際、これは単なるワークピースです）：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Posix</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">setenv</span><span class="hljs-params">(String key, String value, <span class="hljs-keyword">boolean</span> overwrite)</span></span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> String <span class="hljs-title">getenv</span><span class="hljs-params">(String key)</span></span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stub</span><span class="hljs-params">()</span> 
    </span>{<font></font>
        <font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、コンパイルして、将来のライブラリの生成されたhファイルを取得します。</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-comment">#  </span><font></font>
javac Posix.java<font></font>
<font></font>
<span class="hljs-comment">#   Posix.h        JNI</span><font></font>
javah Posix<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヘッダーファイルを受け取ったら、各メソッドの本文を記述します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Posix.h"</span></span><font></font>
<font></font>
<span class="hljs-function">JNIEXPORT jint JNICALL <span class="hljs-title">Java_Posix_setenv</span><span class="hljs-params">(JNIEnv *env, jclass cls, jstring key, jstring value, jboolean overwrite)</span>
</span>{
    <span class="hljs-keyword">char</span>* k = (<span class="hljs-keyword">char</span> *) (*env)-&gt;GetStringUTFChars(env, key, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">char</span>* v = (<span class="hljs-keyword">char</span> *) (*env)-&gt;GetStringUTFChars(env, value, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
    <span class="hljs-keyword">int</span> err = setenv(k, v, overwrite);<font></font>
<font></font>
    (*env)-&gt;ReleaseStringUTFChars(env, key, k);<font></font>
    (*env)-&gt;ReleaseStringUTFChars(env, value, v);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> err;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">JNIEXPORT jstring JNICALL <span class="hljs-title">Java_Posix_getenv</span><span class="hljs-params">(JNIEnv *env, jclass cls, jstring key)</span>
</span>{
    <span class="hljs-keyword">char</span>* k = (<span class="hljs-keyword">char</span> *) (*env)-&gt;GetStringUTFChars(env, key, <span class="hljs-literal">NULL</span>);
    <span class="hljs-keyword">char</span>* v = getenv(k);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> (*env)-&gt;NewStringUTF(env, v);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライブラリをコンパイルします</font></font><br>
<br>
<pre><code class="bash hljs">gcc -I<span class="hljs-string">"<span class="hljs-variable">$JAVA_HOME</span>/include"</span> -I<span class="hljs-string">"<span class="hljs-variable">$JAVA_HOME</span>/include/linux"</span> -fPIC Posix.c -shared -o libPosix.so -Wl,-soname -Wl,--no-whole-archive<font></font>
<font></font>
strip libPosix.so<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaがネイティブライブラリをロードするには、すべてのLinuxルールに従って、システムldがJavaを検出する必要があります。</font><font style="vertical-align: inherit;">さらに、Javaには、ライブラリ検索が行われるパスを含む一連のプロパティがあります。</font><font style="vertical-align: inherit;">Oracle内部で作業する最も簡単な方法は、ライブラリを$ ORACLE_HOME / libに置くことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライブラリを作成したら、データベース内でクラスをコンパイルし、それをplsqlパッケージとして公開する必要があります。</font><font style="vertical-align: inherit;">データベース内にJavaクラスを作成するには、2つのオプションがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> loadjavaユーティリティを介してバイナリクラスファイルをロードする</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sqlplusを使用してソースからクラスコードをコンパイルする</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的には同じですが、2番目の方法を使用します。</font><font style="vertical-align: inherit;">最初のケースでは、hファイルのスタブクラスを受け取ったときに、ステージ1ですべてのクラスコードをすぐに書き込む必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
subdでクラスを作成するには、特別な構文を使用します。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">REPLACE</span> <span class="hljs-keyword">AND</span> RESOLVE <span class="hljs-keyword">JAVA</span> <span class="hljs-keyword">SOURCE</span> NAMED <span class="hljs-string">"Posix"</span> <span class="hljs-keyword">AS</span><font></font>
...<font></font>
...<font></font>
/<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスを作成したら、それをplsqlメソッドとして公開する必要があります。ここでも特別な構文を使用します。</font></font><br>
<br>
<pre><code class="sql hljs">procedure set_env(var_name varchar2, var_value varchar2)<font></font>
is<font></font>
language java name 'Posix.set_env(java.lang.String, java.lang.String)';<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java内で安全でない可能性のあるメソッドを呼び出そうとすると、Javaの許可がユーザーに発行されていないことを示す実行が発生します。</font><font style="vertical-align: inherit;">ネイティブメソッドの読み込みも安全ではない操作です。これは、無関係なコードをデータベースプロセスに直接挿入するためです（ヘッダーでアナウンスされたのと同じエクスプロイト）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、データベースはテストであるため、sysからの接続を心配することなく許可を与えます。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">begin</span>
dbms_java.grant_permission( <span class="hljs-string">'SYSTEM'</span>, <span class="hljs-string">'SYS:java.lang.RuntimePermission'</span>, <span class="hljs-string">'loadLibrary.Posix'</span>, <span class="hljs-string">''</span>);
<span class="hljs-keyword">commit</span>;
<span class="hljs-keyword">end</span>;<font></font>
/<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムのユーザー名は、Javaコードとplsqlラッパーパッケージをコンパイルしたユーザー名です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
System.loadLibraryの呼び出しを介してライブラリをロードするときは、libプレフィックスとso拡張子（ドキュメントで説明されている）を省略し、検索するパスを渡さないことに注意することが重要です。絶対パスを使用してのみライブラリをロードできる同様のSystem.loadメソッドがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、2つの不愉快な驚きが待っています-私はOracleの次のウサギの穴に着陸しました。付与を発​​行すると、かなり曇ったメッセージでエラーが発生します。</font></font><br>
<br>
<pre><code class="plaintext hljs">ORA-29532: Java call terminated by uncaught Java exception: java.lang.SecurityException: policy table update
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題はインターネットでグーグルされ、My Oracle Support（別名Metalink）につながります。</font><font style="vertical-align: inherit;">なぜなら </font><font style="vertical-align: inherit;">Oracleのルールによると、メタリンクからの記事の公開はオープンソースでは許可されていません。ドキュメント番号-259471.1（アクセス権を持つユーザーは自分で読むことができます）についてのみ言及します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題の本質は、オラクルが疑わしいサードパーティのコードをプロセスにロードすることだけを許可しないことです。</font><font style="vertical-align: inherit;">これは論理的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ベースはテストであり、コードに自信があるので、特別な恐れなしにダウンロードを許可します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ふh、冒険は終わりです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生きている、生きている</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
息をのむような状態で、私はフランケンシュタインに命を吹き込もうとすることにしました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プリロードされたlibfaketimeと0オフセットでデータベースを起動します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースに接続し、環境変数の変更前後の時間を表示するだけのコードを呼び出します。</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">begin</span>
dbms_output.enable(<span class="hljs-number">100000</span>);<font></font>
dbms_java.set_output(100000);<font></font>
dbms_output.put_line('old time: '||to_char(sysdate, 'dd.mm.yyyy hh24:mi:ss'));<font></font>
system.posix.set_env('FAKETIME','+1d');<font></font>
dbms_output.put_line('new time: '||to_char(sysdate, 'dd.mm.yyyy hh24:mi:ss'));<font></font>
<span class="hljs-keyword">end</span>;<font></font>
/<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは機能します、いまいましい！</font><font style="vertical-align: inherit;">正直なところ、ORA-600エラーなど、さらに驚きが予想されました。</font><font style="vertical-align: inherit;">ただし、アラートには整数があり、コードは機能し続けました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データベースへの接続が専用として行われる場合、接続が完了した後、プロセスが破棄され、トレースがなくなることに注意することが重要です。</font><font style="vertical-align: inherit;">ただし、共有接続を使用する場合、この場合は既製のプロセスがサーバープールから割り当てられ、環境変数を使用してプロセスの時間を変更します。接続が切断されると、プロセス内で変更されたままになります。</font><font style="vertical-align: inherit;">そして、別のデータベースセッションが同じサーバープロセスに分類されると、驚くべきことに誤った時間を受け取ります。</font><font style="vertical-align: inherit;">したがって、テストセッションの最後に、常に時間をゼロオフセットに戻すことをお勧めします。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
話が面白かったと思います（そして誰かに役立つかもしれません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソースコードはすべて</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Githubで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入手できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
libfaketimeのドキュメント</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのようにテストしますか？</font><font style="vertical-align: inherit;">また、社内でどのようにして開発データベースとテストデータベースを作成しますか？</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後まで読んだ方へのボーナス</font></font></b>
                        <div class="spoiler_text"><img src="https://habrastorage.org/webt/wd/m1/s9/wdm1s9kk6_kckj-xf5amc_o6wjq.jpeg"><br>
</div>
                    </div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja503790/index.html">順列。9年生。パリティタスク</a></li>
<li><a href="../ja503796/index.html">サポートを安くして品質を落とさないようにする</a></li>
<li><a href="../ja503798/index.html">STM32の農場気象ステーション（Bluepill、STM32IDE、HAL）</a></li>
<li><a href="../ja503800/index.html">CDNとは何ですか？</a></li>
<li><a href="../ja503802/index.html">PCを経由せずにクラウド間でファイルを転送する方法</a></li>
<li><a href="../ja503812/index.html">アジャイル海賊と弁証法のいくつかの法則</a></li>
<li><a href="../ja503816/index.html">10年後に体系化。歴史的および技術的回顧</a></li>
<li><a href="../ja503818/index.html">Windows PowerShellとは何で、何を食べますか？パート6：実用的なタスクの解決</a></li>
<li><a href="../ja503820/index.html">自動制御理論入門。技術システムの制御理論の基本概念</a></li>
<li><a href="../ja503826/index.html">対称および非対称のDDoS保護-違いは何ですか？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>